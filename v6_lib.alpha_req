!Version:	X-32U1
!
! COPYRIGHT (c) 1988, 1991 BY
! DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
! ALL RIGHTS RESERVED.
!
! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
! ONLY  IN  ACCORDANCE  OF  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
! INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
! COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
! OTHER PERSON.  NO TITLE TO AND  OWNERSHIP OF THE  SOFTWARE IS  HEREBY
! TRANSFERRED.
!
! THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
! AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
! CORPORATION.
!
! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.

!++
! FACILITY:
! 
!   VMSLIB -- VMS-MACROS.REQ
! 
! ABSTRACT:
! 
!   This module contains a lot of handy macros for systems programming in
!   BLISS.  They are of a general sort, and will be included in LIB.REQ and
!   LIB.L32 (and LIB.L64);
!                  
! AUTHORS:
! 
!   VMS Development
! 
! CREATION DATE: 13 September, 1988
! 
! MODIFICATION HISTORY:
!
!	X-32U1	PAJ0816		Paul A. Jacobi		27-Jan-1995
!		Fix $TIMEDWAIT_10US macro to check the status returned from
!		EXE$TIMEDWAIT_SETUP_10US.
!
!	X-32	DEE0211		David E. Eiche	 	02-Jan-1994
!		Add PIC keyword to PSECT declarations so as not to
!		generate too many image sections in the execlet.
!	      	Also fix the default DDT name.
!
!	X-31	DEE0210		David E. Eiche	 	30-Dec-1993
!		Fix DDTAB and DPTAB PSECT declarations to work with
!		Pathworks drivers.
!
!	X-30	SDD		Steve DiPirro		28-DEC-1993
!		Change system_service macro to correspond to changes in
!		the system service descriptor structure.
!
!	X-29	ROW0844		Ralph O. Weber		21-DEC-1993 11:50
!		Update DPT$IW_STEPVER to signal data structure changes
!		created in ROW0842.
!
!	X-28	ROW0842		Ralph O. Weber		16-DEC-1993 16:28
!		Add DPTAB setup for DPT$IW_IOHANDLES.  Add DDTAB setup for
!		DDT$PS_CSR_MAPPING.  These two new fields are part of driver-
!		based PCI bus CSR mapping support.
!
!	X-27	WDB:HLL82	Walter D. Blaschuk, Jr. 13-NOV-1993
!		HLLDD Project: Disable $COUNT_ENTRY macro.
!
!	X-26	DEE0200		David E. Eiche	 	08-Oct-1993
!		HLLDD: Add DDTAB, DPTAB, and FDTAB macros to allow
!		driver tables to be generated from BLISS.  Add FDT
!		completion routine macros.
!
!	X-25	LSS0291		Leonard S. Szubowicz	 9-Sep-1993
!		HLLDD: Remove definition of compiletime variable HLLDD$STEP1
!		as part of removing support for STEP=1 drivers.
!		Also, remove obsolete JSB linkages: DEVICEDRIVER_FDT_LINKAGE, 
!		DEVICEDRIVER_CANCEL_LINKAGE, DEVICEDRIVER_SEL_CANCEL_LINKAGE,
!		EXE$ABORTIO_LINKAGE, EXE$FINISHIO_LINKAGE, EXE$FINISHIOC_LINKAGE,
!		EXE$IORSNWAIT_LINKAGE, EXE$QIODRVPKT_LINKAGE, EXE$QIORETURN_LINKAGE,
!		EXE$READCHK_LINKAGE, EXE$WRITECHK_LINKAGE, IOC$UNLOCK_LINKAGE
!
!	X-24	TRB		Tom Benson		17-Aug-1993
!		Added linkages required for class scheduler: EXE$INSTIMQ_,
!		EXE$RMVTIMQ_, EXE$MAXACMODE_, and SCH$CHSEP_.
!
!	X-23	SAD		Stuart A. Davidson	16-JUN-1993
!		Add $enable_auditing macro from late Blade change.
!
!	X-22	SAD		Stuart A. Davidson	24-MAY-1993
!		Fix decalraction scoping problem in $disable_auditing
!		and $restore_auditing.
!
!	X-21	SAD0279		Stuart A. Davidson	21-MAY-1993
!		Replace PCB$V_NOAUDIT flag with PCB$L_NOAUDIT count.
!
!	X-20	CEG		Clair Grant		10-MAY-1993
!		Update linkages for NSA$CHECK_AUDIT and NSA$AUDIT_EVENT.
!
!	X-19	EMB		Ellen M. Batbouta	04-May-1993
!		Preserve the appropriate registers, R3 (and R4, R5
!		for EXE$ALOPAGED) in the linkage declarations for
!		EXE$ALOP1IMAG, EXE$ALOP0IMAG, EXE$ALOP1PROC, and
!		EXE$ALOPAGED.	
!
!	X-18	CEG		Clair Grant		15-APR-1993
!		Add $FIND_WITH_RETRY
!
!	X-17	CEG		Clair Grant		 5-APR-1993
!		Update EXE$DELETE_ORB_LINKAGE and EXE$CLEANUP_ORB_LINKAGE
!
!	X-16	CEG		Clair Grant		26-MAR-1993
!		Add linkage for EXE$CVT_IPID_TO_PCB
!
!	X-15	CEG		Clair Grant		18-MAR-1993
!		Add linkages for: SCH$UNLOCK_QUAD, IOC$UNLOCK, IOC$IOLOCKW,
!		NSA$DEVICE_AUDIT, NSA$QUEUE_DEACCESS, SCH$RWAITB,
!		EXE$CVT_EPID_TO_PCB
!
!	X-14	CEG		Clair Grant		 11-MAR-1993
!		Add linkages for: EXE$RESOLVE_ACL, IOC$INSTANTIATE_ORB,
!		IOC$CREATE_DEVICE_ORB, NSA$STRIP_IMAGE_PRIVS,
!		NSA$DEACCESS_AUDIT_LINKAGE
!
!	X-13	CEG		Clair Grant		 8-MAR-1993
!		Remove IOC$VERIFYCHAN_LINKAGE; it's now a call interface.
!
!	X-12	CEG		Clair Grant		02-Mar-1993
!		Add the following macros: $ADD_ARG, $AND_THEN, $CLONE_ORB,
!		$CLONE_TEMPLATE_ORB, $CREATE_ORB, $DISABLE_AUDIT, $EXEC_CALL,
!		$HAS_PRIV, $KERNEL_CALL, $NAMELEN, $OR_ELSE, $OR_THEN,
!		$PRIVS_TO_MASK, $PROBE_IN_DESCRIPTOR, $PROBE_OUT_DESCRIPTOR,
!		$READ_IPL, $RESTORE_AUDIT, $$FLAGS-ORG, $SET_IPL, $$SET_PRIVS_H,
!		$$SET_PRIVS_L, $$SET_PRIVS_OR, $$TRANSLATE_FLAGS_TO_NSA,
!		$$TRANSLATE_FLAGS_TO_NSAP
!
!		Add the following linkages: EXE$CLONE_ARB, EXE$CREDIT_BYTCNT,
!		EXE$CREDIT_BYTCNT_BYTLIM, EXE$DEBIT_BYTCNT,
!		EXE$DEBIT_BYTCNT_ALO, EXE$DEBIT_BYTCNT_BYTLIM,
!		EXE$DEBIT_BYTCNT_BYTLIM_ALO, EXE$DEBIT_BYTCNT_NW,
!		EXE$DEBIT_BYTCNT_BYTLIM_NW, EXE$JOIN_SYSTEM_DOMAIN,
!		IOC$VERIFYCHAN, LCK$GET_DOMAIN_LCKCNT, NSA$DEALLOCATE_NSAB,
!		SCH$CLREF
!
!	X-11	LSS0263		Leonard S. Szubowicz	18-Jan-1993
!		Add $COUNT_ENTRY macro and compile-time constants
!		SYS$COUNT_ENTRY_ENABLED and HLLDD$STEP1.
!
!	NOTE: Ident number changed to reflect current master pack generation.
!
!	X-24	KLN1222		Karen L. Noel		18-Nov-1992
!		Fix linkage for SCH$QAST.
!                                                      
!	X-23	TJH001		Tom Hoey		27-Aug-1992
!		Add BLISS linkages for DECnet Phase V support.
!
!	X-22	DMB		Dave Bernardo		28-Jul-1992
!		Change handling of mode-of-caller services.
!
!	X-21	KLN1208		Karen L. Noel		10-Jul-1992
!		Add flag to system_service macro.
!
!	X-20	KLN1195		Karen L. Noel		27-May-1992
!		Move the SYSTEM_SERVICE macro from [SYS]PAGED_PSECTS.R32
!		to here.
!
!	X-19	KAB		Karen Barth		16-Mar-1992
!		Fix $SAY macro when more than one parameter.
!
!	x-18	RS00200		Richard Sayde		15-Nov-1991
!		Fix $aprobe macro to use a set of PAL probes instead of
!		EXE$PROBEx because the latter uses the VAX method of
!		probes (it does the probe based on the previous mode
!		instead of the current mode).
!
!	X-17	RS00188		Richard Sayde		 7-Nov-1991
!		Add reboot flag to $bug_check macro.
! 
!	X-16	KAB		Karen Barth		30-Oct-1991
!		Fix null expression in $SAY macro.
!
!	X-15	KAB		Karen Barth		18-Oct-1991
!		Add VOLATILE attribute to OUT_BUF in $SAY macro.
!
!   	X-14	PAJ0573  	Paul A. Jacobi	   	27-Sep-1991
!		Update $CPUDISP and $SYSDISP to remove possibility of a
!		compiler warning if 'CONTINUE=YES' is specified.
!
!	X-13	HH0725		Hai Huang		13-Sep-1991
!		Update $INSQ,$REMQ macros.
!
!	X-12	CEG		Clair Grant		05-Sep-1991
!		Fixes for HI_USE_PAGEABLE.....  defs
!
!	X-11	CEG 		Clair Grant		03-Sep-1991
!		Add EXEC$HI_USE_PAGEABLE_DATA option to
!		$DECLARE_PSECT macro
!
!	X-10	CEG		Clair Grant		03-Sep-1991
!		Add EXEC$HI_USE_PAGEABLE_CODE option to
!		$DECLARE_PSECT macro
!
!   	X-9	PAJ0562  	Paul A. Jacobi	   	22-Aug-1991
!		Correct CONTINUE=NO logic of $SYSDISP and $CPUDISP macros.
!
!	X-8	CEG		Clair Grant		20-Aug-1991
!		EXEC$INIT_00n must be longword aligned.
!
!	X-7	CEG		Clair Grant		10-Aug-1991
!		Need to remove a %FI from the error conditional
!
!	X-6	CEG		Clair Grant		08-Aug-1991
!		The psect EXEC$INIT_SSTBL_001 must be longword aligned.
!
!	X-5	CEG		Clair Grant		08-Aug-1991
!		In $DECLARE_PSECT, make the default for all psects be
!		32-byte alignment. Remove EXEC$INIT_PFNTBL_001; it is not used.
!
!   	X-4	PAJ0495   	Paul A. Jacobi	   	25-Apr-1991
!		Add optional parameters to $MCHECK_PROTECT macro.
!
!   	X-3	PAJ0486   	Paul A. Jacobi	   	18-Apr-1991
!		Add $MCHECK_PROTECT macro.
!
!   	X-2	PAJ0464   	Paul A. Jacobi	   	20-Mar-1991
!		Include new $CPUDISP and $SYSDISP macros.  Reset module
!		ident.
!
!   	X-1K11	PAJ0461   	Paul A. Jacobi	   	06-Mar-1991
!		Correct quote level in $TIMEDWAIT_10US macro.
!
!   	X-1K10	PAJ0454   	Paul A. Jacobi	   	05-Mar-1991
!		Rename TIMEDWAIT_10US to $TIMEDWAIT_10US.
!
!   	X-1K9	PAJ0451   	Paul A. Jacobi	   	27-Feb-1991
!		Added TIMEDWAIT_10US macro.
!
!	X-1K8	TNS   		Tom Scarpelli		 7-Feb-1991
!		Change $PROBE macro to accept run-time mode field for RMS.
!
!	X-1K7	TNS   		Tom Scarpelli		20-Dec-1990
!		Make $PROBE macro use the previous mode field.
!
!	X-1K6	SDD  		Steve DiPirro		26-Oct-1990
!		Fix $MOVE_QUAD to work in cases where block/structure
!		addresses passed as parameters too.
!
!	X-1K5	SDD		Steve DiPirro		18-Oct-1990
!		"Ported" the other macros to Alpha:
!		  - $PROBE made obsolete because of Alpha/VAX differences.
!		  - $APROBE replaces $PROBE for Alpha.
!		  - $INSQHI, $INSQTI updated.
!		  - $REMQHI, $REMQTI updated but not supported by EBLISS.
!		    So these merely print out compiler warning messages.
!		  - $MOVE_QUAD fixed for BLISS-32/BLISS-64.
!		  - $SAY fixed for BLISS-64.
!		  - $XDELTA JSB linkage fixed for EBLISS.
! 
!	X-1K4	SDD		Steve DiPirro		15-Oct-1990
!		Added $xxx_PSECT_AT, $DECLARE_PSECT, and
!		$INITIALIZATION_ROUTINE macros for building execlets.
! 
!	X-1K3	RS0018		Richard Sayde		23-Jul-1990
!		Fix typo in $bug_check macro.
! 
! 	X-1K2	RS0011		Richard Sayde		11-Jul-1990
!		Made vms-macros.req architecture specific and ported the 
!		$bug_check macro to Alpha. No other macros ported.
! 
!	X-6	CAM0088		Christopher A. Mega	16-Nov-1989
!		Fix $INSQHI, $INSQTI, $REMQHI, $REMQTI macros.  Fixes
!		provided by Dave Marsh, Reading.  Change involves swapping
!		parameters to macros, and updating them to return the
!		correct status of the actual queue operation.
!		Bump version to match CMS generation
!
!	X-4	JDC0558		Jon Callas		 3-NOV-1989
!		$PROBE is not preserving R1 and R2 properly.
!
!       X-3	DDP0393		Derrell D. Piper       28-JUL-1989  14:16
!		Move UTLDEFB to here.  Add a couple of new macros:
!		    $xxx_WITH_RETRY
!		    $MOVE_QUAD
!		    $SAY
!		    $XDELTA
!
!	X-2	EMB0423		Ellen M. Batbouta	21-Jul-1989
!		Add $INSQHI, $INSQTI, $REMQHI and $REMQTI.
!
!	X-1	JDC0407		Jon Callas		13-SEP-1988
!		Create module.
!--
LINKAGE
    COM$DELATTNAST_lINKAGE = 
	JSB ( REGISTER = 4, 				! Attention AST listhead address
	      REGISTER = 5 ) :				! UCB address
	PRESERVE (0,1,2,3,4,5,6,7)
	NOTUSED (8,9,10,11),

    COM$DRVDEALMEM_LINKAGE = 
	JSB  (REGISTER = 0):				! Address of block to be deallocated
	PRESERVE (0,1,2,3,4,5)
	NOTUSED (6,7,8,9,10,11),

    COM$FLUSHATTNS_LINKAGE = 
	JSB (REGISTER = 4, 				! PCB address
	     REGISTER = 5, 				! UCB address
	     REGISTER = 6,  				! Number of the assigned I/O channel
	     REGISTER = 7) :				! AST listhead address - destroyed on output
	PRESERVE    (3,4,5,6)
	NOPRESERVE  (0,1,2,7)				! R0 returns SS$_NORMAL, R1 and R2 are scratch.
	NOTUSED (8,9,10,11),

    COM$POST_LINKAGE = 
    ! Note: R1 is documented as not being presrved
	JSB (REGISTER = 3, 				! IRP address
	     REGISTER = 5):				! UCB address
	PRESERVE (1,2,3,4,5)
	NOPRESERVE (0)					! R0, R1 scratch
	NOTUSED (6,7,8,9,10,11),

    COM$SETATTNAST_LINKAGE = 
	JSB (REGISTER = 3,				! IRP address
	     REGISTER = 4, 				! PCB address
	     REGISTER = 5, 				! UCB address 
	     REGISTER = 7 ) :				! AST listhead address - destroyed on output
	PRESERVE (3,4,5,9,10)		
	NOPRESERVE (0,1,2,6,7,8),			! R1, R2, R8 scratch

    EXE$ALLOCBUF_LINKAGE  = 
	JSB (REGISTER = 1;				! request size
	     REGISTER = 2):				! address of block
	NOPRESERVE (3,4) 
	PRESERVE (5) 
	NOTUSED (6,7,8,9,10,11),

    EXE$ALONONPAGED_LINKAGE = 
	JSB (REGISTER = 1;				! size of block required
	     REGISTER = 1,				! actual size of allocated block
	     REGISTER = 2) :				! address of allocated block
	PRESERVE (3,4,5,6,7,8,9,10,11),

!   Use EXE$ALONONPAGED
!+
!    EXE$ALO_NPAGE_WAIT_LINKAGE = 
!	JSB (REGISTER = 0,				! address of cleanup routine (0 = none)
!	     REGISTER = 1;				! size of block required
!	     REGISTER = 1,				! actual size of allocated block
!	     REGISTER = 2) :				! address of allocated block
!	NOPRESERVE (3,4,5),
!
!    EXE$ALO_NPAGE_WAITS_LINKAGE = 
!	JSB (REGISTER = 0,				! address of cleanup routine (0 = none)
!	     REGISTER = 1;				! size of block required
!	     REGISTER = 1,				! actual size of allocated block
!	     REGISTER = 2) :				! address of allocated block
!	NOPRESERVE (3,4,5),
!-

    EXE$ALOP0IMAG_LINKAGE = 
	JSB (REGISTER = 1;				! size of block required
	     REGISTER = 1,				! actual size of allocated block
	     REGISTER = 2) :				! address of allocated block
	PRESERVE (3),

    EXE$ALOP1IMAG_LINKAGE = 
	JSB (REGISTER = 1;				! size of block required
	     REGISTER = 1,				! actual size of allocated block
	     REGISTER = 2) :				! address of allocated block
	PRESERVE (3),

    EXE$ALOP1PROC_LINKAGE = 
	JSB (REGISTER = 1;				! size of block required
	     REGISTER = 1,				! actual size of allocated block
	     REGISTER = 2) :				! address of allocated block
	PRESERVE (3),

    EXE$ALOPAGED_LINKAGE = 
	JSB (REGISTER = 1;				! size of block required
	     REGISTER = 1,				! actual size of allocated block
	     REGISTER = 2) :				! address of allocated block
	PRESERVE (3,4,5),

    EXE$CHKACCESS_LINKAGE = 
    ! CHECK ACCESS PROTECTION:
    ! G^EXE$CHKCREACCES - CHECK CREATE ACCESS
    ! G^EXE$CHKDELACCES - CHECK DELETE ACCESS
    ! G^EXE$CHKLOGACCES - CHECK LOGICAL I/O FUNCTION ACCESS
    ! G^EXE$CHKPHYACCES - CHECK PHYSICAL I/O FUNCTION ACCESS
    ! G^EXE$CHKRDACCES - CHECK READ ACCESS
    ! G^EXE$CHKWRTACCES - CHECK WRITE ACCESS
    ! G^EXE$CHKEXEACCES - CHECK EXECUTE ACCESS (IMPLIED BY READ ACCESS)
    !   
    ! INPUTS:
    !	R0 = ADDRESS OF THE AGENT'S RIGHTS BLOCK
    !	R1 = ADDRESS OF THE OBJECT'S RIGHTS BLOCK
    !	R5 = 0
    !		OR
    !	R4 = ADDRESS OF THE ACCESSOR'S PCB
    !	R5 = ADDRESS OF THE OBJECT'S UCB
    !
    ! OUTPUTS:
    !	R0 = SS$_NORMAL FOR ACCESS ALLOWED
    !	R0 = SS$_NOPRIV FOR ACCESS DENIED
    !
    !	R2, R3, AND R4 ARE PRESERVED ACROSS CALL.
    ! NOTE THAT THE FOLLOWING LINKAGE DECLARATION is for the second type of
    ! access.
	JSB (REGISTER = 4, 				! PCB Address
	     REGISTER = 5):				! UCB Address
	NOPRESERVE (1)					! NOTE: I believe R1 is preserved, but to be safe...
	PRESERVE (2,3,4,5,6,7,8,9,10,11),

    EXE$CHKPRO_INT_LINKAGE = 
	JSB (REGISTER = 0,				! address of ARB	
	     REGISTER = 1,				! address of ORB
	     REGISTER = 2,				! address of CHPCTL
	     REGISTER = 3),				! address of CHPRET

    EXE$CLEANUP_ARB_LINKAGE = 
	JSB (REGISTER = 0),				! address of ARB to cleanup

    EXE$CLEANUP_ORB_LINKAGE=
	JSB (REGISTER = 0, 				! orb
	     REGISTER = 2),				! deallocation routine

    EXE$CLONE_ARB_LINKAGE = 
	JSB (REGISTER = 0;				! address of source ARB
	     REGISTER = 1),				! address of cloned ARB

    EXE$COPY_ARB_LINKAGE = 
	JSB (REGISTER = 0;				! address of source ARB
	     REGISTER = 1),				! address of cloned ARB

    EXE$COPY_ORB_LINKAGE = 
	JSB (REGISTER = 0;				! address of source ORB
	     REGISTER = 1),				! address of cloned ORB

    EXE$CREATE_ARB_LINKAGE = 
	JSB (;						! no input arguments
	     REGISTER = 1),				! address of new ARB

    EXE$CREATE_DEFAULT_ORB_LINKAGE = 
	JSB (REGISTER = 0;				! address of OCB
	     REGISTER = 1),				! address of cloned ORB

    EXE$CREATE_ORB_LINKAGE = 
	JSB (;						! no input arguments
	     REGISTER = 1),				! address of new ORB

    EXE$CREDIT_BYTCNT_LINKAGE =				! Add amount to BYTCNT
	JSB (REGISTER = 0,				! request size
	     REGISTER = 4):				! PCB address
	PRESERVE (4)
	NOTUSED (1, 2, 3, 5, 6,7,8,9,10,11),

    EXE$CREDIT_BYTCNT_BYTLM_LINKAGE =			! Add amount to BYTCNT and BYTLM
	JSB (REGISTER = 0,				! request size
	     REGISTER = 4):				! PCB address
	PRESERVE (4)
	NOTUSED (1, 2, 3, 5, 6,7,8,9,10,11),

    EXE$CVT_EPID_TO_PCB_LINKAGE  = 
	JSB (REGISTER = 0;				! EPID to be converted
    	     REGISTER = 0):				! PCB address, or zero if any problems
	PRESERVE (1,2,3,4,5) 
	NOTUSED (6,7,8,9,10,11),

    EXE$CVT_IPID_TO_PCB_LINKAGE  = 
	JSB (REGISTER = 0;				! IPID to be converted
    	     REGISTER = 0):				! PCB address, or zero if any problems
	PRESERVE (1,2,3,4,5) 
	NOTUSED (6,7,8,9,10,11),

    EXE$DEANONPAGED_LINKAGE = 
	JSB (REGISTER = 0):				! address of block to deallocate
	PRESERVE (4,5,6,7,8,9,10,11)
	NOPRESERVE (1,2,3),				! NOTE: SCH$RAVAIL may be called which is DOCUMENTED as
							!  destroying R3, however I don't believe it does.  In
							!  the philosophy of "better safe than sorry" however...

    EXE$DEANONPGDSIZ_LINKAGE  = 
	JSB (REGISTER = 0,				! address of block to deallocate
	     REGISTER = 1) :				! size of block to deallocate
	NOPRESERVE (2,3,4,5),
		  
    EXE$DEAP1_LINKAGE = 
	JSB (REGISTER = 0,				! address of block to deallocate
	     REGISTER = 1) :				! size of block to deallocate
	NOPRESERVE (2,3),
		  
    EXE$DEAPAGED_LINKAGE = 
	JSB (REGISTER = 0) :				! address of block to deallocate
	NOPRESERVE (2,3,4,5),
		  
    EXE$DEAPGDSIZ_LINKAGE = 
	JSB (REGISTER = 0,				! address of block to deallocate
	     REGISTER = 1) :				! size of block to deallocate
	NOPRESERVE (2,3,4,5),
		  
    EXE$DEBIT_BYTCNT_LINKAGE =				! Debit BYTCNT, do not allocate pool.
	JSB (REGISTER = 1,				! request size
	     REGISTER = 4):				! PCB address
	PRESERVE (1, 4)
	NOTUSED (2, 3, 5, 6,7,8,9,10,11),

    EXE$DEBIT_BYTCNT_BYTLM_LINKAGE =			! Debit BYTCNT & BYTLM, do not al
	JSB (REGISTER = 1,				! request size
	     REGISTER = 4):				! PCB address
	PRESERVE (1, 4)
	NOTUSED (2, 3, 5, 6,7,8,9,10,11),

    EXE$DEBIT_BYTCNT_ALO_LINKAGE =			! Debit BYTCNT and allocate pool.
	JSB (REGISTER = 1,				! request size
	     REGISTER = 4;				! PCB address
	     REGISTER = 2):				! address of block
	NOPRESERVE (3,4) 
	PRESERVE (5) 
	NOTUSED (6,7,8,9,10,11),

    EXE$DEBIT_BYTCNT_BYTLM_ALO_LNKG =			! Debit BYTCNT and BYTLM, alloca
	JSB (REGISTER = 1,				! request size
	     REGISTER = 4;				! PCB address
	     REGISTER = 2):				! address of block
	NOPRESERVE (3,4) 
	PRESERVE (5) 
	NOTUSED (6,7,8,9,10,11),

    EXE$DEBIT_BYTCNT_NW_LINKAGE =			! Debit BYTCNT, don't allocate, neve
	JSB (REGISTER = 1,				! request size
	     REGISTER = 4):				! PCB address
	PRESERVE (1, 4)
	NOTUSED (2, 3, 5, 6,7,8,9,10,11),

    EXE$DEBIT_BYTCNT_BYTLM_NW_LNKG =			! Debit both, don't allocate, nev
	JSB (REGISTER = 1,				! request size
	     REGISTER = 4):				! PCB address
	PRESERVE (1, 4)
	NOTUSED (2, 3, 5, 6,7,8,9,10,11),

    EXE$DELETE_ARB_LINKAGE = 
	JSB (REGISTER = 0),				! address of ARB to delete

    EXE$DELETE_ORB_LINKAGE = 
	JSB (REGISTER = 0,				! address of ORB to delete
	     REGISTER = 2),				! deallocation routine

    EXE$EPID_TO_IPID_LINKAGE  = 
	JSB (REGISTER = 0;				! EPID to be converted
	     REGISTER = 0):				! IPID or zero if any problems
	PRESERVE (1,2,3,4,5) 
	NOTUSED (6,7,8,9,10,11),

    EXE$EPID_TO_PCB_LINKAGE = 
	JSB (REGISTER = 0;				! EPID
	     REGISTER = 0):				! PCB address or zero if any problems
	PRESERVE (1,2,3,4,5)
	NOTUSED (6,7,8,9,10,11),

    EXE$CVT_IPID_TO_EPID_LINKAGE  = 
	JSB (REGISTER = 0;				! IPID to be converted
	     REGISTER = 0):				! EPID or zero if any problems
	PRESERVE (1,2,3,4,5) 
	NOTUSED (6,7,8,9,10,11),

    EXE$IPID_TO_PCB_LINKAGE = 
	JSB (REGISTER = 0;				! IPID
	     REGISTER = 0):				! PCB address or zero if any problems
	PRESERVE (1,2,3,4,5)
	NOTUSED (6,7,8,9,10,11),

    EXE$JOIN_SYSTEM_DOMAIN_LINKAGE =
	JSB,						! No arguments

    EXE$LOCATE_SEC_CLASS_LINKAGE =	
	JSB (REGISTER = 1,				! address of class_name
	     REGISTER = 2),				! address of OCB

    EXE$REGISTER_SEC_CLASS_LINKAGE =
	JSB (REGISTER = 1,				! address of class_name
	     REGISTER = 3,				! address of class type
	     REGISTER = 4,				! address of osrv
	     REGISTER = 5,				! address of object_class template
	     REGISTER = 2),				! address of OCB

    EXE$RESOLVE_ACL_LINKAGE =
	JSB (REGISTER = 1),				! ORB to resolve

    EXE$SEARCH_RIGHT_LINKAGE = 
	JSB (REGISTER = 2,				! identifier being sought
	     REGISTER = 4;				! address of the rights segment descriptors
	     REGISTER = 1,				! address of the ID quadword (if found)
	     REGISTER = 5),				! address of the rights segment containing the ID (if found)
    
    EXE$SNDEVMSG_LINKAGE = 
    ! Linkage for EXE$SNDEVMSG routine in Mailbox Driver.
    ! The parameters, PRESERVE and NOPRESERVEs are as documented below, simply
    ! for compatibility reasons.  
	JSB(REGISTER = 3,				! Mailbox UCB address
	    REGISTER = 4, 				! Message Type
	    REGISTER = 5) :				! Device UCB address
	NOPRESERVE (0,1,2,3,4)
	PRESERVE (5,6,7,8,9,10,11),

    EXE$SENDMSG_LINKAGE = 
	JSB (REGISTER = 3,				! Message size
	     REGISTER = 4,				! Message address
	     REGISTER = 5) :				! UCB address of mailbox
	NOPRESERVE (2),

    EXE$WRTMAILBOX_LINKAGE = 
    ! The parameters, PRESERVE and NOPRESERVEs are as documented below, simply
    ! for compatibility reasons.  
	JSB( REGISTER = 3, 				! Message Size
	     REGISTER = 4, 				! Message Address
	     REGISTER = 5):				! Mailbox UCB Address
	PRESERVE (3,4,5,6,7,8,9,10,11)
	NOPRESERVE (0,1,2),

    EXE$ACQUIRE_OLCK_LINKAGE	= 
	JSB (	REGISTER = 2, 				! rsn
		REGISTER = 3, 				! parid
		REGISTER = 4, 				! flags
		REGISTER = 5 ),				! olck

    EXE$RELEASE_OLCK_LINKAGE	= 
	JSB (	REGISTER = 1, 				! flags
		REGISTER = 4 ),				! olck

    EXE$RUNDOWN_OLCKS_LINKAGE	= JSB,

!   Standard Call entry
!+
!    INITIALIZATION_RTN_JSB = 				! Loadable image init routine
!	JSB (REGISTER = 5; 				! Inirtn flags
!	     REGISTER = 0) :				! Return status
!	NOPRESERVE(0,1,2,3)
!	PRESERVE (4,5,6,7,8,9,10,11),
!-

    IOC$CREATE_DEVICE_ORB_LINKAGE = 
	JSB (REGISTER = 0,				! address of name desc
	     REGISTER = 1;				! device class
	     REGISTER = 1):				! address of new ORB 
	PRESERVE (2,3,4,5,6,7,8,9,10,11),

    IOC$CVT_DEVNAM_LINKAGE = 
	JSB (REGISTER = 0,				! Input length of output buffer, output final conversion status
    							!			  SS$_NORMAL or
							!			  SS$_BUFFEROVF (an alternate success status which 
							!				indicates that the supplied buffer could not
							!				hold the device name string)
	     REGISTER = 1,				! Input address of output buffer
	     REGISTER = 4,				! Input name string formation mode
	     REGISTER = 5;				! Address of device UCB
	     REGISTER = 1):				! Output  Length of conversion string.  R1 = 0 if the alternate path name
							!  was requested, but none exists.
	NOPRESERVE (0,1)
	PRESERVE (2,3,4,5,6,7,8,9,10,11),

    IOC$INSTANTIATE_ORB_LINKAGE = 
	JSB (REGISTER = 1,				! ORB
	     REGISTER = 2),				! UCB

    IOC$REQCOM_LINKAGE = 
	JSB (REGISTER = 0, 				! I/O STATUS first longword
	     REGISTER = 1, 				! I/O Status second word
	     REGISTER = 5):				! UCB address
	PRESERVE (4,5,6,7,8,9,10,11)
	NOPRESERVE (0,1,2,3),

    LCK$GET_DOMAIN_LCKCNT_LINKAGE = 
	JSB (REGISTER = 0,				! flags
	     REGISTER = 1,				! resource domain ID
	     REGISTER = 4; 				! PCB
	     REGISTER = 1 ) :				! [OUT] count of locks
	PRESERVE (2,3,4,5,6,7,8,9,10,11),

    LNM$LOCKR_LINKAGE = 
	JSB (REGISTER = 4) :				! PCB address
	PRESERVE (1,4,5,6,7,8,9,10,11)
	NOPRESERVE (0,2,3),				

    LNM$LOCKW_LINKAGE = 
	JSB (REGISTER = 4):				! PCB address
	PRESERVE (1,4,5,6,7,8,9,10,11)
	NOPRESERVE (0,2,3),				


    LNM$UNLOCK_LINKAGE = 
	JSB (REGISTER = 4) :				! PCB
	PRESERVE (4,5,6,7,8,9,10,11)
	NOPRESERVE (0,1,2,3),				! R0-R3 scratch

    LNM$DELETELNMB_LINKAGE = 
	JSB ( REGISTER = 1):				! Address of logical name table entry
	PRESERVE (4,5,6,7,8,9,10,11)
	NOPRESERVE (0,1,2,3),				! R0 - Status: 
							!  SS$_NORPRIV if logical name table is a directory
							!  SS$_NORMAL
							!  SS$_NOLOGNAM if there are o such logical names.

    NSA$ALLOCATE_NSAB_LINKAGE =
	JSB (REGISTER = 2;				! size of required NSAB
	     REGISTER = 3),				! actual address of NSAB

    NSA$AUDIT_EVENT_LINKAGE = 
    	JSB (REGISTER = 0,				! address of NSAB
	     REGISTER = 4) :				! source PCB
	PRESERVE (2,3,4,5,6,7,8,9,10,11),

    NSA$AUDIT_FAILURE_LINKAGE =
	JSB (REGISTER = 0,				! failing status
	     REGISTER = 1),				! audit flags

    NSA$CHECK_AUDIT_LINKAGE = 
	JSB (REGISTER = 0,				! protection check status
	     REGISTER = 1,				! event type and subtype
	     REGISTER = 2,				! address of CHPCTL block
	     REGISTER = 3,				! address of CHPRET block
	     REGISTER = 4) :				! address of PCB
	PRESERVE (4,5,6,7,8,9,10,11),

    NSA$CHECK_PRIVILEGE_LINKAGE = 
	JSB (REGISTER = 0,				! privilege bit, privilege mask address, or identifier address
	     REGISTER = 1,				! address of control structure ($NSAIFPDEF)
	     REGISTER = 4),				! PCB address of process to check (0 = use current process)
	     
    NSA$COMPUTE_SUMMARY_LINKAGE = 
	JSB (REGISTER = 4),				! PCB address (0 = use current PCB)

    NSA$DEACCESS_AUDIT_LINKAGE	= 
	JSB (REGISTER = 0,				! deaccess key
	     REGISTER = 2),				! DAP flags

    NSA$DEALLOCATE_NSAB_LINKAGE =
	JSB (REGISTER = 0),				! address of NSAB to deallocate

    NSA$DEVICE_AUDIT_LINKAGE =
	JSB (REGISTER = 0,				! flags: 0 = creation, 1 = deletion
	     REGISTER = 5),				! UCB address

    NSA$ITMLST_TO_PKTLST_LINKAGE =
	JSB (REGISTER = 2,				! address of item list
	     REGISTER = 3,				! address of buffer to receive packet list
	     REGISTER = 4,				! address of NSAS (with journal names)
	     REGISTER = 5),				! address of username descriptor

    NSA$QUEUE_DEACCESS_LINKAGE	= 
	JSB (REGISTER = 1,				! alarm/audit mask
	     REGISTER = 10,				! address of CHPCTL (with deaccess key)
	     REGISTER = 11),				! address of CHPRET (with alarms)

    NSA$RESOURCE_LINKAGE = 
	JSB (REGISTER = 0,				! reason mask
	     REGISTER = 1) :				! audit flags ($NSADEF)
	PRESERVE (2,3,4,5,6,7,8,9,10,11),

    NSA$SIZE_NSAB_LINKAGE =
	JSB (REGISTER = 2,				! address of item list
    	     REGISTER = 3),				! NSAS structure address

    NSA$STRIP_IMAGE_PRIVS_LINKAGE =
	JSB (REGISTER = 0,				! address of privilege mask
	     REGISTER = 4),				! associated PCB address

    NSA$VALIDATE_JOURNAL_LINKAGE =
	JSB (REGISTER = 2,				! journal type flag
	     REGISTER = 3,				! address of journal name descriptor
	     REGISTER = 4,				! address of username descriptor
	     REGISTER = 5),				! address of journal name descriptor

    OSR$ACCESS_EXCEPTION_LINKAGE = 
	JSB (REGISTER = 8,				! address of ARB
	     REGISTER = 9,				! address of ORB
	     REGISTER = 10,				! address of CHPCTL
	     REGISTER = 11,				! address of CHPRET
	     REGISTER = 0),				! input status

    SCH$CLREF_LINKAGE = 
	JSB (REGISTER = 3,				! EFN number (low byte, zero filled)
	     REGISTER = 4) :				! PCB address
	NOPRESERVE (2,3,4,5),

    SCH$FORCEDEXIT_LINKAGE  = 
    	JSB (REGISTER = 0,
	     REGISTER = 3,
	     REGISTER = 4) :
	NOPRESERVE(1,2) 
	PRESERVE(5) 
	NOTUSED(6,7,8,9,10,11),

    SCH$IOLOCKW_LINKAGE = 
	JSB (REGISTER = 4) :				! address of PCB
	NOPRESERVE (0),				

    SCH$LOCKR_LINKAGE = 
	JSB (REGISTER = 0,				! address of mutex
	     REGISTER = 4) :				! address of PCB
	NOPRESERVE (2,3),				

    SCH$LOCKW_LINKAGE = 
	JSB (REGISTER = 0,				! address of mutex
	     REGISTER = 4) :				! address of PCB
	NOPRESERVE (2,3),				

    SCH$LOCKREXEC_LINKAGE	= JSB (REGISTER = 0) :	! address of mutex
				       NOPRESERVE (1, 2, 3),

    SCH$UNLOCKEXEC_LINKAGE	= JSB (REGISTER = 0) :	! address of mutex
				       NOPRESERVE (1, 2, 3),

    SCH$POSTEF_LINKAGE = 
	JSB (REGISTER = 1,				! PID
	     REGISTER = 2,				! priority increment class number
	     REGISTER = 3;				! EFN number
	     REGISTER = 4) :				! PCB address of process specified by PID
	PRESERVE (5,6,7,8,9,10,11),

    SCH$QAST_LINKAGE  = 
	JSB (REGISTER = 2, 				! Priority boost
	     REGISTER = 5;				! ACB address
	     REGISTER = 4) :				! PCB address
	NOPRESERVE (1,2,3,4,5) 
	NOTUSED (6,7,8,9,10,11),

    SCH$RAVAIL_LINKAGE = 				! Implicit input: IPL <= SYNCH
	JSB  ( REGISTER = 0 ):				! Resource Number
	PRESERVE (4,5,6,7,8,9,10,11)
	NOPRESERVE (0,1,2,3),				! R1-R3 are destroyed	 
							! (NOTE: I think only R2 is actually destroyed, but just to be safe...)

    SCH$RWAITB_LINKAGE = 
	JSB (REGISTER = 0,				! Resource number
	     REGISTER = 1,				! PSL for return
	     REGISTER = 4) :				! PCB address
	NOPRESERVE (2,3)
	PRESERVE (4,5,6,7,8,9,10,11),

    SCH$UNLOCK_LINKAGE = 
	JSB (REGISTER = 0,				! address of mutex
	     REGISTER = 4) :				! address of PCB
	NOPRESERVE (2,3),

    SCH$UNLOCK_QUAD_LINKAGE = 
	JSB (REGISTER = 0,				! address of mutex
	     REGISTER = 4) :				! address of PCB
	NOPRESERVE (2,3),

    EXE$INSTIMQ_LINKAGE =
        JSB (REGISTER = 0,                              ! Abs due time low half
             REGISTER = 1,                              ! Abs due time high half
             REGISTER = 5) :                            ! Address of TQE
          NOPRESERVE(2,3) NOTUSED(6,7,8,9,10,11),

    EXE$RMVTIMQ_LINKAGE =
        JSB (REGISTER = 2,                              ! ACMODE, access mode
             REGISTER = 3,                              ! REQIDT, id #
             REGISTER = 4,                              ! TQEADR, address if kn
             REGISTER = 5) :                            ! PID
        NOPRESERVE(1) NOTUSED(6,7,8,9,10,11),

    EXE$MAXACMODE_LINKAGE =
        JSB (REGISTER = 0) :                            ! Mode parameter
         NOPRESERVE(1) NOTUSED(2,3,4,5,6,7,8,9,10,11),

    SCH$CHSEP_LINKAGE =
        JSB (REGISTER = 0,                              ! priority increment cl
             REGISTER = 4;                              ! PCB to make executable
             REGISTER = 2) :                            ! per-CPU data block
        NOPRESERVE(1,2) PRESERVE(3) NOTUSED(5,6,7,8,9,10,11);


MACRO
    $probe ($$loc, $$len, $$type, $$mode) =
!+
! This macro probes a range using PROBEx or EXE$PROBEx. 
!
! $$loc is the starting address of the range.
! $$len is the length of the range
! $$type is the type of probe to be done, allowable values are:
! 
!   R -- probe for read access. If the probe is a compile-time constant less
!   than a page in length, then PROBER is used, otherwise EXE$PROBER is used.
!
!   W -- probe for write access as per R above.
!
!   RQ -- probe for read access, but always use a PROBER instruction. A Mnemonic
!   for the Q is "quick."
!
!   WQ -- probe for write access, as per RQ.
!
! $$mode is the mode of the probe, maximized with the previous mode --
! defaults to 0 if not specified.
!
! The macro returns a value that is either true or false, suitable for use in an
! IF statement.
!
! NOTE: On Alpha, PROBE probes accessability at either the specified mode or
!	the current mode, whichever is larger. To emulate VAX PROBEs, this 
!	macro will do a RD_PS to read the previous mode field (which is one of
!	the "reserved to software" fields).  It will then take the maximum of 
!	that and the specified mode.  PROBE will then take the maximum of that 
!	and the current mode for the access check.
! 
!-
	BEGIN
	COMPILETIME quick = 0;

	%IF %LENGTH LSS 3
	%THEN
	    %ERROR('Too few parameters in $PROBE')
	%FI

	%IF (NOT %IDENTICAL($$type,r)) AND
	    (NOT %IDENTICAL($$type,w)) AND
	    (NOT %IDENTICAL($$type,rq)) AND
	    (NOT %IDENTICAL($$type,wq)) 
	%THEN
	    %ERROR('Error in $PROBE, ',%STRING(%NAME($$type)),' is an illegal type.')
	%FI

	%IF %IDENTICAL($$type,rq) OR %IDENTICAL($$type,wq)
	%THEN
	    %ASSIGN(quick,1)
	%FI

	%IF quick OR (%CTCE($$len) AND ($$len LEQ 8192))
	%THEN

	    MACRO pbuiltin = 
		%IF %IDENTICAL($$type,r) or %IDENTICAL($$type,rq)
		%THEN
		    PAL_PROBER
		%ELSE
		    PAL_PROBEW
		%FI

		%QUOTE % ;

	    BUILTIN
		PAL_RD_PS,
		pbuiltin;
		
	    LOCAL 
		PS : BLOCK[8,BYTE] INITIAL(PAL_RD_PS());

            %IF %LENGTH GEQ 4
            %THEN
                pbuiltin($$loc,$$len - 1,MAX(.PS[PSL$V_PRVMOD],$$mode))
            %ELSE
                pbuiltin($$loc,$$len - 1,MAX(.PS[PSL$V_PRVMOD],0))
            %FI

	%ELSE
	    LINKAGE
		probe_linkage = JSB (REGISTER = 0, REGISTER = 1, REGISTER = 3)
				  : NOPRESERVE(1,2);

	    EXTERNAL ROUTINE
		%NAME('EXE$PROBE',$$type) : probe_linkage;

	    BUILTIN
		PAL_RD_PS;
		
	    LOCAL 
		PS : BLOCK[8,BYTE] INITIAL(PAL_RD_PS());

            %IF %LENGTH GEQ 4
            %THEN
		%NAME('EXE$PROBE',$$type)($$loc,$$len,MAX(.PS[PSL$V_PRVMOD],$$mode))
            %ELSE
                %NAME('EXE$PROBE',$$type)($$loc,$$len,MAX(.PS[PSL$V_PRVMOD],0))
            %FI

	%FI
	END %;

MACRO
	$aprobe ($$loc, $$len, $$type, $$mode) = 

!+
! This macro probes a range using PROBEx(s). It has replaced
! the $PROBE macro for Alpha/EVMS since the two are used differently.
!
! $$loc is the starting address of the range.
! $$len is the length of the range
! $$type is the type of probe to be done, allowable values are:
! 
!   R -- probe for read access. If the probe is a compile-time less than
!   8192 in length (minimum page size), then PROBER is used, otherwise 
!   a set of PROBERs are used in a loop.
!
!   W -- probe for write access as per R above.
!
!   RQ -- probe for read access, but always use a PROBER instruction. A Mnemonic
!   for the Q is "quick."
!
!   WQ -- probe for write access, as per RQ.
!
! $$mode is the mode of the probe, maximized with the current mode --
! defaults to 0 if not specified.
!
! The macro returns a value that is either true or false, suitable for use in an
! IF statement.
!
! NOTE: On Alpha, PROBE probes accessability at either the specified mode or
!	the current mode, whichever is larger. To emulate VAX PROBEs, pass the
!	previous mode in the mode argument. It will take the max of that and
!	the current mode for the access check.
! 
!-
    BEGIN
	COMPILETIME quick = 0,
		    pmode = 0;
	EXTERNAL    mmg$gl_bwp_mask: LONG,
		    mmg$gl_page_size: LONG;

	%IF %LENGTH LSS 3
	%THEN
	    %ERROR('Too few parameters in $PROBE')
	%FI

	%IF %LENGTH GEQ 4
	%THEN
	    %IF %CTCE($$mode)
	    %THEN
		%ASSIGN(pmode,$$mode)
	    %ELSE
		%ERROR('Error in $PROBE, ',$$mode,' must be a compile-time constant.')
	    %FI
	%FI

	%IF (NOT %IDENTICAL($$type,r)) AND
	    (NOT %IDENTICAL($$type,w)) AND
	    (NOT %IDENTICAL($$type,rq)) AND
	    (NOT %IDENTICAL($$type,wq)) 
	%THEN
	    %ERROR('Error in $PROBE, ',$$type,' is an illegal type.')
	%FI

	MACRO pbuiltin = 
	    %IF %IDENTICAL($$type,r) or %IDENTICAL($$type,rq)
	    %THEN
		PAL_PROBER
	    %ELSE
		PAL_PROBEW
	    %FI

	    %QUOTE % ;

	BUILTIN
	    pbuiltin;
		
	%IF %IDENTICAL($$type,rq) OR %IDENTICAL($$type,wq)
	%THEN
	    %ASSIGN(quick,1)
	%FI

	%IF quick OR (%CTCE($$len) AND ($$len LEQ 8192))
	%THEN
	    ! Quick method requested or the length is a compile time
	    ! constant less than the minimum page size (8192).
	    pbuiltin($$loc,$$len - 1,pmode)
	%ELSE
	    ! Not sure if we cross a page boundary or not. Used run time
	    ! code to do a page at a time
	    LOCAL
		$$probe_addr,
		$$probe_length,
		$$length_remaining,
		$$probe_ok;

	    $$probe_addr = $$loc;
	    $$length_remaining = $$len;
	    $$probe_ok = 1;
	    WHILE .$$probe_ok AND (.$$length_remaining GTR 0) DO BEGIN
		$$probe_length = MIN (.$$length_remaining,
				   .mmg$gl_page_size - 
					(.$$probe_addr AND .mmg$gl_bwp_mask));
		$$length_remaining = .$$length_remaining - .$$probe_length;
		$$probe_ok = pbuiltin(.$$probe_addr,.$$probe_length-1,pmode);
		$$probe_addr = .$$probe_addr + .$$probe_length;
	    END;
	    .$$probe_ok
	%FI
    END %;

MACRO
    $bug_check ($$name, $$type, $$reboot) =
!+
! This macro generates a bugcheck. It is analogous to the MACRO-32 BUG_CHECK
! macro. You use it with a call like $BUG_CHECK(VAXPORT,FATAL);
!
! Note that this macro generates a reference to an external symbol for the
! BUG$_WHATEVER code. It would be real nice if the BUG$_ codes were in LIB, but
! they're not, so they get resolved at link time. Sorry.
!
! $$name   is the name of the of the bugcheck. VAXPORT, KRPEMPTY, etc.
! $$type   is the type of the bugcheck. FATAL makes it a fatal bugcheck,
!          anything else is a non-fatal bugcheck. Case doesn't matter.
! $$reboot is a flag to do either a warm or cold reboot. It only applies if
!	   the bugcheck is fatal.
!-
	BEGIN
	  BUILTIN
	    CALL_PAL,PAL_HALT;
	  COMPILETIME
	    FatalError = 0,
	    ColdReboot =0;
	  %IF (NOT %DECLARED (%NAME ('bug$_', $$name))) %THEN
	    EXTERNAL LITERAL %NAME ('bug$_', $$name);
  	  %FI
	  %IF (NOT %DECLARED (evx$pal_bugchk)) %THEN
	    EXTERNAL LITERAL evx$pal_bugchk;
  	  %FI

          !++
	  ! determine if the BUG_CHECK is fatal or not
	  !--
	  %IF (%LENGTH EQL 0) %THEN
	    ! no parameters passed, error
	    %ERROR (%ASCII 'First parameter of BUG_CHECK macro required')
	  %ELSE
	    %IF (%LENGTH EQL 1) %THEN
	      ! only one parameter, assume Type is NONFATAL
	      %ASSIGN (FatalError, 0)
	    %ELSE
	      ! more than one parameter
	      %IF (%IDENTICAL ($$type,FATAL)) %THEN
		%ASSIGN (FatalError, 1)
	      %ELSE
		%ASSIGN (FatalError, 0)
	      %FI
	    %FI
	  %FI

	  !++
	  ! determine if this is a cold or warm reboot
	  !--
	  %IF (%LENGTH GTR 2) %THEN
	    %IF (FatalError EQL 0) %THEN
	      %WARN (%ASCII'Reboot qualifier ignored on non-fatal bugchecks')
	      %ASSIGN (ColdReboot, 0)
	    %ELSE
	      %IF (%IDENTICAL ($$reboot,COLD_REBOOT)) %THEN
		%ASSIGN (ColdReboot, 1)
	      %ELSE
		%ASSIGN (ColdReboot, 0)
	      %FI
	    %FI
	  %ELSE
	    %ASSIGN (ColdReboot, 0)
	  %FI

	  !++
	  ! execute the BUG_CHECK
	  !--
	  %IF (FatalError EQL 1) %THEN
	    %IF (ColdReboot EQL 1) %THEN
	      ! bugcheck is ORed with STS$K_SEVERE and low bit set (= 5)
	      CALL_PAL (evx$pal_bugchk, 5 OR %NAME ('bug$_',$$name));
	    %ELSE
	      ! bugcheck is ORed with STS$K_SEVERE (= 4)
	      CALL_PAL (evx$pal_bugchk, 4 OR %NAME ('bug$_',$$name));
	    %FI
	    PAL_HALT();
	  %ELSE
	    CALL_PAL (evx$pal_bugchk, %NAME ('bug$_', $$name));
	  %FI
	END %;


!+
! $INSQHI - Execute an interlocked queue insert instruction and retry if 
!	    failure. 
! $INSQTI 
!
!	INPUT:
!
!	ENTRY -  Address of entry to be inserted in queue
!	HEAD  -  Address of queue header
!
!	Note: System is bug_checked if queue operation fails because secondary
!	interlock bit stays set.
!-
MACRO
    $insqhi (entry, head) =
      BEGIN
	BUILTIN
	  pal_insqhil;

	LOCAL
	  counter : INITIAL (0),
	  status : SIGNED;

	WHILE (status = pal_insqhil (head, entry)) LSS 0 DO
	  IF ((counter = .counter + 1) GTRU 90000) THEN
	    $bug_check (badqhdr, fatal);

	.status
      END%;


MACRO
    $insqti (entry, head) =

      BEGIN
	BUILTIN
	  pal_insqtil;

	LOCAL
	  counter : INITIAL (0),
	  status : SIGNED;

	WHILE (status = pal_insqtil (head, entry)) LSS 0 DO
	  IF ((counter = .counter + 1) GTRU 90000) THEN
	    $bug_check (badqhdr, fatal);

	.status
      END%;


!+
! $REMQHI - Execute an interlocked queue remove instruction and retry if failure
! $REMQTI
!
!	INPUT:
!
!	Head -  Address of queue header
!	Entry - Address of a longword where the address of the entry removed
!		is to be stored
!	
!	
!	Note: System is bug_checked if queue operation fails because secondary
!	      interlock bit stays set.
!-
MACRO
    $remqhi (head, entry) =
      BEGIN
	BUILTIN
	  pal_remqhil;

	LOCAL
	  counter : INITIAL (0),
	  status : SIGNED;

	WHILE (status = pal_remqhil (head; entry)) LSS 0 DO
	  IF ((counter = .counter + 1) GTRU 90000) THEN
	    $bug_check (badqhdr, fatal);

	.status

      END %;

MACRO
    $remqti (head, entry) =
      BEGIN
	BUILTIN
	  pal_remqtil;
    
	LOCAL
	  counter : INITIAL (0),
	  status : SIGNED;

	WHILE (status = pal_remqtil (head; entry)) LSS 0 DO
	  IF ((counter = .counter + 1) GTRU 90000) THEN
	    $bug_check (badqhdr, fatal);

	.status

      END %;

!+
! $GET_WITH_RETRY	perform an RMS $GET with automatic retry
! $FIND_WITH_RETRY	perform an RMS $FIND with automatic retry
! $PUT_WITH_RETRY	perform an RMS $PUT with automatic retry
! $UPDATE_WITH_RETRY	perform an RMS $UPDATE with automatic retry
! $DELETE_WITH_RETRY	perform an RMS $DELETE with automatic retry
!
! INPUT:
!
!	RAB	address of RAB
!	SUC	address of routine to execute on successful completion
!	ERR	address of routine to execute on failure
!-

! This macro is used by the RMS retry macros.

MACRO
   $$retry (service, r, e, s) =
      BEGIN
	LITERAL
	    $$retry_limit = 10,			! number of times to retry
	    $$sleep_rlk   = 500;		! 500 ms before retrying

	BIND
	    $$wakedelta = UPLIT LONG (-10*1000*$$sleep_rlk,-1);
	
	LOCAL 
	    counter, status;

	counter = $$retry_limit;
	WHILE ((status = service (RAB = R
				  %IF NOT %NULL(E) %THEN , ERR = E %FI
				  %IF NOT %NULL(S) %THEN , SUC = S %FI)
				 ) EQL rms$_rlk) AND 
				((counter = .counter - 1) GEQ 0) DO
	    IF $schdwk (DAYTIM = $$wakedelta) THEN $hiber;
	.status
	END %;

! The following four keyword macros mimic the real RMS macro definitions.  Each
! of these macros performs the normal RMS operation while providing for
! automatic retry on record-locked errors.  Each operation will be retried ten
! times with a retry interval of 500 ms.
! 
KEYWORDMACRO
    $get_with_retry (rab, err, suc) =
	$$retry (%QUOTE %QUOTE $get, rab, err, suc) %,

    $put_with_retry (rab, err, suc) =
	$$retry (%QUOTE %QUOTE $put, rab, err, suc) %,

    $update_with_retry (rab, err, suc) =
	$$retry (%QUOTE %QUOTE $update, rab, err, suc) %,

    $find_with_retry (rab, err, suc) =
	$$retry (%quote %quote $find, rab, err, suc) %,

    $delete_with_retry (rab, err, suc) =
	$$retry (%QUOTE %QUOTE $delete, rab, err, suc) %;

!+
!
! Macro to copy a quadword using two MOVLs. This should do the exact
! same thing for both BLISS-32 and BLISS-64.
!
! Usage:
!
!   $MOVE_QUAD (SOURCE, DEST);
!
!-
MACRO
    $move_quad (src, dst) =
	BEGIN
	  BIND
	    $$tmp_src = src : VECTOR[2,LONG],
	    $$tmp_dst = dst : VECTOR[2,LONG];

	  $$tmp_dst[0] = .$$tmp_src[0];
	  $$tmp_dst[1] = .$$tmp_src[1];
	END %;

!+
!
! Macro to output a formatted string.
!
! Usage:
!
!   $SAY ('This is a simple string...');
!   $SAY ('This is a !AS string with a unsigned longword (!XL) in it...', %ascid'formatted', 42);
!
!-
MACRO
    $say (string) =
      BEGIN
	EXTERNAL ROUTINE
	  lib$put_output,
	  sys$fao;
	LOCAL
	  out_buf : VOLATILE BLOCK[132,BYTE],
	  out : VECTOR[2,LONG] INITIAL(LONG(%ALLOCATION(out_buf), out_buf));
	sys$fao(%ASCID string, out, out %IF %LENGTH GTR 1 %THEN , %REMAINING %FI);
	lib$put_output(out);
      END %;

!+
!
! Macro to take an XDELTA breakpoint, if XDELTA is loaded.
!
! Usage:
!
!   $XDELTA;
!
!-
MACRO
    $xdelta = 
      BEGIN
	LINKAGE
	  l_ini$brk = JSB;
	EXTERNAL ROUTINE
	  ini$brk : l_ini$brk;
	ini$brk();
      END %;

!
! $xxx_PSECT_AT
!
!	The following macros define the PSECT attributes for the standard
!	VMS exec PSECTs. The attribute macro name is the PSECT name prefixed
!	with a "$" and suffixed by "_PSECT_AT". These macros can then be
!	used in any PSECT declarations with these PSECT names, and the
!	attributes are defined in just one place (for BLISS) - here.
!
! 	The macros defined here are:
!
!		$EXEC$NONPAGED_DATA_PSECT_AT
!		$EXEC$NONPAGED_CODE_PSECT_AT
!		$EXEC$PAGED_DATA_PSECT_AT
!		$EXEC$PAGED_CODE_PSECT_AT
!		$EXEC$HI_USE_PAGEABLE_D_PSECT_A
!		$EXEC$HI_USE_PAGEABLE_C_PSECT_A
!		$EXEC$INIT_000_PSECT_AT
!		$EXEC$INIT_001_PSECT_AT
!		$EXEC$INIT_CODE_PSECT_AT
!		$EXEC$INIT_SSTBL_001_PSECT_AT
!               $EXEC$UNL_000_PSECT_AT
!               $EXEC$UNL_001_PSECT_AT
!		$EXEC$NONPAGED_LINKAGE_PSECT_AT
!		$EXEC$PAGED_LINKAGE_PSECT_AT
!		$EXEC$HI_USE_PAGEABLE_L_PSECT_A
!		$EXEC$INIT_LINKAGE_PSECT_AT
!
!  Input (to some of them):
!
!	ALIGNMENT - If a different alignment than the default is required
!
!
MACRO
	$exec$nonpaged_data_psect_at(alignment) =
	  %if %null(alignment) %then
	    WRITE,NOEXECUTE,PIC,ALIGN(5)
	  %else
	    WRITE,NOEXECUTE,PIC,ALIGN(alignment)
	  %fi %,

	$exec$nonpaged_code_psect_at(alignment) =
	  %if %null(alignment) %then
	    NOWRITE,EXECUTE,PIC,ALIGN(5)
	  %else
	    NOWRITE,EXECUTE,PIC,ALIGN(alignment)
	  %fi %,

	$exec$paged_data_psect_at(alignment) =
	  %if %null(alignment) %then
	    WRITE,NOEXECUTE,PIC,ALIGN(5)
	  %else
	    WRITE,NOEXECUTE,PIC,ALIGN(alignment)
	  %fi %,

	$exec$paged_code_psect_at(alignment) =
	  %if %null(alignment) %then
	    NOWRITE,EXECUTE,PIC,ALIGN(5)
	  %else
	    NOWRITE,EXECUTE,PIC,ALIGN(alignment)
	  %fi %,

	$exec$hi_use_pageable_d_psect_a(alignment) =
	  %if %null(alignment) %then
	    WRITE,NOEXECUTE,PIC,ALIGN(5)
	  %else
	    WRITE,NOEXECUTE,PIC,ALIGN(alignment)
	  %fi %,

	$exec$hi_use_pageable_c_psect_a(alignment) =
	  %if %null(alignment) %then
	    NOWRITE,EXECUTE,PIC,ALIGN(5)
	  %else
	    NOWRITE,EXECUTE,PIC,ALIGN(alignment)
	  %fi %,
              
	$exec$init_000_psect_at =
	  READ,WRITE,EXECUTE,PIC,ALIGN(2)
	%,

	$exec$init_001_psect_at =
	  READ,WRITE,EXECUTE,PIC,ALIGN(2)
	%,

	$exec$init_code_psect_at(alignment) =
	  %if %null(alignment) %then
	    READ,WRITE,EXECUTE,PIC,ALIGN(5)
	  %else
	    READ,WRITE,EXECUTE,PIC,ALIGN(alignment)
	  %fi %,

	$exec$init_sstbl_001_psect_at =
	  READ,WRITE,EXECUTE,PIC,ALIGN(2)
	%,

	$exec$unl_000_psect_at =
	  WRITE,NOEXECUTE,PIC,ALIGN(5)
	%,

	$exec$unl_001_psect_at =
	  WRITE,NOEXECUTE,PIC,ALIGN(5)
	%,
              
	$exec$nonpaged_linkage_psect_at =
	  READ,WRITE,NOEXECUTE,PIC,NOSHARE,CONCATENATE,ALIGN(5)
	%,

	$exec$paged_linkage_psect_at =
	  READ,WRITE,NOEXECUTE,PIC,NOSHARE,CONCATENATE,ALIGN(5)
	%,

	$exec$hi_use_pageable_l_psect_a =
	  READ,WRITE,NOEXECUTE,PIC,NOSHARE,CONCATENATE,ALIGN(5)
	%,

	$exec$init_linkage_psect_at =
	  READ,WRITE,EXECUTE,PIC,NOSHARE,CONCATENATE,ALIGN(5)
	%;


!
! $DECLARE_PSECT
!
!	This macro is used to declare psects within the loadable images
!	of the VMS executive.  It makes sure all the psects have
!	compatible attributes across all the images. Note that it is NOT
!	necessary to explicitly declare LINKage section psect names as
!	they are done implicitly for each of the appropriate code PSECTs.
!	Also note that these macros redefine all the BLISS data PSECTs
!	(PLIT, OWN, GLOBAL) for each data PSECT name.
!
! Inputs:
!	PSECT_NAME - PSECT_NAME is one of the standard VMS executive psects:
!		EXEC$NONPAGED_DATA
!	      	EXEC$NONPAGED_CODE
!		EXEC$PAGED_DATA
!		EXEC$PAGED_CODE
!		EXEC$HI_USE_PAGEABLE_DATA
!		EXEC$HI_USE_PAGEABLE_CODE
!		EXEC$INIT_000
!		EXEC$INIT_001
!		EXEC$INIT_CODE
!		EXEC$INIT_SSTBL_001
!               EXEC$UNL_000
!               EXEC$UNL_001
!
!
!	ALIGNMENT - If a different alignment than the default is required
!
MACRO
	$declare_psect(psect_name,alignment) =

	  %if %identical(psect_name,exec$nonpaged_data) %then
	    PSECT
	      PLIT = exec$nonpaged_data(
				$exec$nonpaged_data_psect_at(alignment)),
	      OWN = exec$nonpaged_data(
				$exec$nonpaged_data_psect_at(alignment)),
	      GLOBAL = exec$nonpaged_data(
				$exec$nonpaged_data_psect_at(alignment))
	  %else

	  %if %identical(psect_name,exec$nonpaged_code) %then
	    PSECT
	      LINK = exec$nonpaged_linkage(
				$exec$nonpaged_linkage_psect_at),
	      CODE = exec$nonpaged_code(
				$exec$nonpaged_code_psect_at(alignment))
	  %else

	  %if %identical(psect_name,exec$paged_data) %then
	    PSECT
	      PLIT = exec$paged_data(
				$exec$paged_data_psect_at(alignment)),
	      OWN = exec$paged_data(
				$exec$paged_data_psect_at(alignment)),
	      GLOBAL = exec$paged_data(
				$exec$paged_data_psect_at(alignment))
	  %else
                                         
	  %if %identical(psect_name,exec$paged_code) %then
	    PSECT
	      LINK = exec$paged_linkage(
				$exec$paged_linkage_psect_at),
	      CODE = exec$paged_code(
				$exec$paged_code_psect_at(alignment))
	  %else

	  %if %identical(psect_name,exec$hi_use_pageable_data) %then
	    PSECT
	      PLIT = exec$hi_use_pageable_data(
				$exec$hi_use_pageable_d_psect_a(alignment)),
	      OWN = exec$hi_use_pageable_data(
				$exec$hi_use_pageable_d_psect_a(alignment)),
	      GLOBAL = exec$hi_use_pageable_data(
				$exec$hi_use_pageable_d_psect_a(alignment))
	  %else
                                         
	  %if %identical(psect_name,exec$hi_use_pageable_code) %then
	    PSECT
	      LINK = exec$hi_use_pageable_linkage(
				$exec$hi_use_pageable_l_psect_a),
	      CODE = exec$hi_use_pageable_code(
				$exec$hi_use_pageable_c_psect_a(alignment))
	  %else

	  %if %identical(psect_name,exec$init_000) %then
	    PSECT
	      PLIT = exec$init_000($exec$init_000_psect_at),
	      OWN = exec$init_000($exec$init_000_psect_at),
	      GLOBAL = exec$init_000($exec$init_000_psect_at)
	  %else

	  %if %identical(psect_name,exec$init_001) %then
	    PSECT
	      PLIT = exec$init_001($exec$init_001_psect_at),
	      OWN = exec$init_001($exec$init_001_psect_at),
	      GLOBAL = exec$init_001($exec$init_001_psect_at)
	  %else

	  %if %identical(psect_name,exec$init_code) %then
	    PSECT
	      LINK = exec$init_linkage(
				$exec$init_linkage_psect_at),
	      CODE = exec$init_code(
				$exec$init_code_psect_at(alignment))
	  %else

	  %if %identical(psect_name,exec$init_sstbl_001) %then
	    PSECT
	      PLIT = exec$init_sstbl_001(
				$exec$init_sstbl_001_psect_at),
	      OWN = exec$init_sstbl_001(
				$exec$init_sstbl_001_psect_at),
	      GLOBAL = exec$init_sstbl_001(
				$exec$init_sstbl_001_psect_at)
	  %else

	  %if %identical(psect_name,exec$unl_000) %then
	    PSECT
	      PLIT = exec$unl_000($exec$unl_000_psect_at),
	      OWN = exec$unl_000($exec$unl_000_psect_at),
	      GLOBAL = exec$unl_000($exec$unl_000_psect_at)
	  %else

	  %if %identical(psect_name,exec$unl_001) %then
	    PSECT
	      PLIT = exec$unl_001($exec$unl_001_psect_at),
	      OWN = exec$unl_001($exec$unl_001_psect_at),
	      GLOBAL = exec$unl_001($exec$unl_001_psect_at)
	  %else

	    %error('Unrecognized PSECT declaration')

	  %fi %fi %fi %fi %fi %fi %fi %fi %fi %fi %fi %fi %;

!
! $INITIALIZATION_ROUTINE
!
!	This macro declares a routine to be an initialization routine.  It
!	enters an absolute vector for the routine in the initialization
!	routine vector table, guaranteeing that this routine will be called
!	when the image is loaded by the VMS linker/loader.
!
! INPUTS:
!
!	NAME - name of the initialization OR unload routine.
!	SYSTEM_RTN - 1 if the initialization/unload routine is external to this
!		image (i.e. in system space).  Defaults to 0 and is only valid
!		for VAX (ignored for Alpha).
!       UNLOAD - 1 if this is an unload routine. Defaults to 0. 
!	PRIORITY - if 1,then this argument indicates that this entry should
!		   be placed into the appropriate table as one of the first
!		   entries.  The tables (one for INITIALIZATION routines and
!		   one for UNLOAD routines) consist of two psects.  Routines
!		   which specify PRIORITY will be placed in the first psect.
!		   Routines which do not specify this argument will be placed
!		   in the second psect.  The routines in the first psect will
!		   be called before the routines in the second psect, thus
!		   giving them priority.  Defaults to 0.
!
! OUTPUTS:
!	A vector and a flags longword is entered into the initialization
!	or unload routine vector table for each routine.
!
KEYWORDMACRO
	$initialization_routine(
				name,
				system_rtn=0,	! Ignored for Alpha
				unload=0,
				priority=0) =
                
	%if unload EQL 0 %then	        	! Default case
	
	  %if priority EQL 0 %then
	    PSECT
	      NODEFAULT = exec$init_001($exec$init_001_psect_at);
	    OWN
	      $$tmp_vec: VECTOR[2,LONG] PSECT(exec$init_001)
	  %else
	    PSECT
	      NODEFAULT = exec$init_000($exec$init_000_psect_at);
	    OWN
	      $$tmp_vec: VECTOR[2,LONG] PSECT(exec$init_000)
	  %fi					! in first psect in table

        %else					! If unload=1

	  %if priority EQL 0 %then
	    PSECT
	      NODEFAULT = exec$unl_001($exec$unl_001_psect_at);
	    OWN
	      $$tmp_vec: VECTOR[2,LONG] PSECT(exec$unl_001)
	  %else
	    PSECT
	      NODEFAULT = exec$unl_000($exec$unl_000_psect_at);
	    OWN
  	      $$tmp_vec: VECTOR[2,LONG] PSECT(exec$unl_000)
	  %fi 					
	%fi

	INITIAL(LONG(name,0)) %;



!+                         
!   TIMEDWAIT_10US     
!   
!	This macro loops around the supplied expression for then specified
!	time or until the given expressions returns true (1).  The macro returns
!	the value of the expression which will be true (1) if the time has
!	not been exceeded or false (0) if the time limit has been exceeded. 
!
!   EXAMPLE:
!
!    STATUS = TIMEDWAIT_10US (10*1000*1000,	! Wait 10 seconds or until 
!	                      .CSR[BIIC$V_STS]);!  self test status bit it set.
!
!    IF NOT .STATUS THEN ERROR();	
!
!
!   INPUT:
!	TIME			- Time in 10 microsecond units
!	EXPRESSION		- Any valid BLISS expression.  When true (1)
!				  will cause TIMEDWAIT_10US macro to exit.
!	BUS			- (optional parameter) When present indicate
!				  the BUS type for EXE$BUS_DELAY
!  
!--                                                    

MACRO
    $TIMEDWAIT_10US (TIME,EXPRESSION,BUS) =
    BEGIN
	LOCAL
	    DELTA:		VECTOR[2,LONG],
	    END_TIME:		VECTOR[2,LONG],
	    REMAINING_TIME,
            STATUS;

	%IF NOT %DECLARED (%QUOTE %QUOTE EXE$TIMEDWAIT_SETUP_10US) 
	    %THEN EXTERNAL ROUTINE EXE$TIMEDWAIT_SETUP_10US; %FI
            
	%IF NOT %DECLARED (%QUOTE %QUOTE EXE$BUS_DELAY) 
	    %THEN EXTERNAL ROUTINE EXE$BUS_DELAY; %FI
            
	%IF NOT %DECLARED (%QUOTE %QUOTE EXE$TIMEDWAIT_COMPLETE)  
	    %THEN EXTERNAL ROUTINE EXE$TIMEDWAIT_COMPLETE; %FI

	DELTA[0] = TIME;
	DELTA[1] = 0;
	STATUS = EXE$TIMEDWAIT_SETUP_10US(DELTA,END_TIME);

     	IF .STATUS THEN
        BEGIN
     	    STATUS = 0;
	    REMAINING_TIME = 1;
	    WHILE ((NOT .STATUS) AND .REMAINING_TIME) DO
	    BEGIN
	        STATUS = EXPRESSION

	        %IF NOT %NULL(BUS) %THEN EXE$BUS_DELAY(BUS) %FI;
            
	        REMAINING_TIME = EXE$TIMEDWAIT_COMPLETE(END_TIME);
	    END;
        END;

    .STATUS 

    END %;



!+                         
!   $CPUDISP
!   
!	This macro conditionally executes the suppied expressions based upon
!	the primary CPU type in EXE$GQ_CPUTYPE, initialized from the HWRPB. See 
!	[LIB]HWRPBDEF.SDL to add new CPU types which will automatically extend 
!	this macro.
!
!   EXAMPLE:
!
!	$CPUDISP('CONTINUE=NO',
!         	  EV3, BEGIN X=2; Y=3; END,
!                 EV4, ROUT2());
!
!   INPUT:
!
!	CONTINUE	- If set to 'CONTINUE=NO', this macro will perform a
!			  $BUG_CHECK if executed on a CPU type that is not
!			  present in the dispatch list.  In most cases it is 
!			  best to specify 'CONTINUE=NO'.  
!
!	                  If set to 'CONTINUE=YES', control will pass to the
!			  next instruction following the macro if executed on 
!			  a CPU type that is not present in the dispatch list.
!
!			  Note that this argument must be enclosed in single 
!			  quote and in uppercase or a generated compiler error
!			  will be produced.
!  
!	DISPATCH LIST	- A list of tupples where the first element is a
!			  CPU type and the second element is any valid BLISS
!			  expression to be execute only if running on the
!			  the CPU type indicated by the first element.
!
!--                                                    
MACRO
    $CPUDISP (CONTINUE) [] =
	%IF (NOT %IDENTICAL(%STRING(CONTINUE),'CONTINUE=NO')) AND
            (NOT %IDENTICAL(%STRING(CONTINUE),'CONTINUE=YES'))
	%THEN
	    %ERROR('Invalid CONTINUE argument of CPUDISP macro')
	%ELSE
	BEGIN
	    %IF NOT %DECLARED(EXE$GQ_CPUTYPE)
	    %THEN
		EXTERNAL EXE$GQ_CPUTYPE;
            %FI
	    MACRO
       	        CASELINE[SYS,ACTION] =   
                    [%NAME('HWRPB_CPU_TYPE$K_',%STRING(SYS))]: ACTION
                    %IF %NULL(%REMAINING)
                    %THEN
                        %QUOTE ;
                        %IF %IDENTICAL(%STRING(CONTINUE),'CONTINUE=NO')
                        %THEN 
                            [INRANGE]:$BUG_CHECK(UNSUPRTCPU);
                            [OUTRANGE]:$BUG_CHECK(UNSUPRTCPU);
                        %ELSE 
                            [INRANGE]:;
                            [OUTRANGE]:;
                        %FI             
                    %FI %QUOTE %;
            CASE .EXE$GQ_CPUTYPE FROM 1 TO HWRPB_CPU_TYPE$K_MAX_CPU_TYPE OF
                CASELINE(%REMAINING) 
            END;                                        
        %FI %;



!+                         
!   $SYSDISP
!   
!	This macro conditionally executes the suppied expressions based upon
!	the system type in EXE$GQ_SYSTYPE, initialized from the HWRPB.  See 
!	[LIB]HWRPBDEF.SDL to add new system types which will automatically 
!	extend this macro.
!
!   EXAMPLE:
!
!	$SYSDISP('CONTINUE=NO',
!         	  ADU, BEGIN X=2; Y=3; END,
!                 COBRA, ROUT2());
!
!   INPUT:
!
!	CONTINUE	- If set to 'CONTINUE=NO', this macro will perform a
!			  $BUG_CHECK if executed on a system type that is not
!			  present in the dispatch list.  In most cases it is 
!			  best to specify 'CONTINUE=NO'.  
!
!	                  If set to 'CONTINUE=YES', control will pass to the
!			  next instruction following the macro if executed on 
!			  a CPU type that is not present in the dispatch list.
!			  Note that this argument must be enclosed in single 
!			  quote and in uppercase or a generated compiler error
!			  will be produced.
!  
!	DISPATCH LIST	- A list of tupples where the first element is a
!			  system type and the second element is any valid BLISS
!			  expression to be execute only if running on the
!			  the system type indicated by the first element.
!
!--                                                    
MACRO
    $SYSDISP (CONTINUE) [] =
	%IF (NOT %IDENTICAL(%STRING(CONTINUE),'CONTINUE=NO')) AND
            (NOT %IDENTICAL(%STRING(CONTINUE),'CONTINUE=YES'))
	%THEN
	    %ERROR('Invalid CONTINUE argument of SYSDISP macro')
	%ELSE
	BEGIN
	    %IF NOT %DECLARED(EXE$GQ_SYSTYPE)
	    %THEN                                                       
		EXTERNAL EXE$GQ_SYSTYPE;
            %FI
	    MACRO
		CASELINE[SYS,ACTION] =   
                    [%NAME('HWRPB_SYSTYPE$K_',%STRING(SYS))]: ACTION
                    %IF %NULL(%REMAINING)
                    %THEN
                        %QUOTE ;
                        %IF %IDENTICAL(%STRING(CONTINUE),'CONTINUE=NO')
                        %THEN 
                            [INRANGE]:$BUG_CHECK(UNSUPRTCPU);
                            [OUTRANGE]:$BUG_CHECK(UNSUPRTCPU);
                        %ELSE 
                            [INRANGE]:;
                            [OUTRANGE]:;
                        %FI
                    %FI %QUOTE %;
            CASE .EXE$GQ_SYSTYPE FROM 1 TO HWRPB_SYSTYPE$K_MAX_SYSTYPE OF
                CASELINE(%REMAINING) 
            END;
        %FI %;


      
!++                         
!   $MCHECK_PROTECT
!   
!	This macro is used to execute an any BLISS expression protected from 
!	a machine check or other error.
!
!   INPUT:
!
!	MASK		- Mask of errors to protect against
!	EXPRESSION	- Any BLISS expression to protect from error, limited
!			  to referencing the four LOCAL storage locations
!			  supplied in the optional arguments.  The expression
!			  may reference an unlimited amount of OWN storage,
!			  however, OWN storage will not allow the routine to 
!			  be re-entrant.
!	P1, P2, P3, P4	- Optional parameters. Up to four LOCAL storage
!			  locations referenced by the expression.  Required 
!			  only if expression references LOCAL storage.
!
!   EXAMPLE
!
! Assume CSR_BASE contains a base CSR address
!
!BEGIN
!
!OWN Y,CSR_BASE;
!LOCAL X,Z;
!
!    STATUS = $MCHECK_PROTECT(MCHK$M_NEXM, .X=..Z;, X, Z);
!    IF .STATUS EQL SS$_MCHECK THEN ERROR();
!
!    STATUS = $MCHECK_PROTECT(MCHK$M_NEXM, Y=.CSR_BASE[CSR1];);
!    IF .STATUS EQL SS$_MCHECK THEN ERROR();
!
!END;
!                                            
!--                       

MACRO
    $MCHECK_PROTECT (MASK, EXPRESSION) =
    BEGIN
    %IF %NULL(%REMAINING)
    %THEN
        ROUTINE MCHK$TEMP =
    %ELSE
        ROUTINE MCHK$TEMP(%REMAINING) =
    %FI

    BEGIN
        EXPRESSION;
        RETURN(SS$_NORMAL);
    END;

    EXTERNAL ROUTINE
        EXE$MCHECK_PROTECT;

    %IF %NULL(%REMAINING)
    %THEN
        EXE$MCHECK_PROTECT(MASK, MCHK$TEMP)
    %ELSE
        EXE$MCHECK_PROTECT(MASK, MCHK$TEMP, %REMAINING)
    %FI

    END %;

!++
!
! SYSTEM_SERVICE
!	This macro declares a system service.
!
! MACRO PARAMETERS
!	NAME - The name of the system service (less the prefix)
!	NARG - The number of arguements for the system_service
!	MARG - The mininum number of arguements (optional)
!	MODE - The Change Mode (KERNEL, EXEC, or CALLERS_MODE)
!	IMASK - The inhibit mask (optional)
!	TYPE - Wait form type, some system services have a wait
!	       form (i.e. QIO and QIOW) (optional depending on
!	       the system service)
!	EXIT - Some system services (RMS) perform their own
!	       exit code in addition to the normal system
!	       service exit code.  This parameter will define
!	       the additional exit code to be used. (optional
!	       depending on the system service)
!	PREFIX - Defines the prefix to be used to define the entry
!		 point, defaults to EXE$ (exec system services)
!	FLAGS - (optional) SSFLAG_K_WCM or SSFLAG_K_WCMNO_REEXEC  must be set 
!		if service could return SS$_WAIT_CALLERS_MODE, defaults to 0
!
! OUTPUTS
!	A system service descriptor table entry, used as input to the
!	system service loader for inner mode services.
!
!	__________________________________________________
!	|	System Service Vector Address            |
!	--------------------------------------------------
!	|	Procedure Descriptor of routine		 |
!	--------------------------------------------------
!	|   MODE    |  IMASK   |   FLAGS    |   TYPE     |
!	--------------------------------------------------
!	|			Unused			 |
!	--------------------------------------------------
!	NOTE:  EXIT_TYPE is not implemented on Alpha
!
!--
KEYWORDMACRO
	SYSTEM_SERVICE(NAME,NARG,MARG,MODE,IMASK,TYPE,EXIT,PREFIX,FLAGS) =

%IF %IDENTICAL(%NAME('MODE_K_',MODE),MODE_K_CALLERS_MODE) %THEN
	%IF	%NULL(PREFIX)	%THEN
		GLOBAL BIND ROUTINE %NAME('SYS$',NAME) = %NAME('EXE$',NAME);

	%ELSE	! %NULL(PREFIX)
		GLOBAL BIND ROUTINE %NAME('SYS$',NAME) = %NAME(PREFIX,NAME);
	%FI

%ELSE
	%IF	%NULL(PREFIX)	%THEN
		EXTERNAL ROUTINE  %NAME('SYS$',NAME);
		OWN
		   %NAME('BASE_VECTOR_',NAME): LONG
		   INITIAL(%NAME('SYS$',NAME))
		   PSECT(EXEC$INIT_SSTBL_001);
	  	OWN
		   %NAME('SELF_RELATIVE_',NAME): LONG
		   INITIAL(%NAME('EXE$',NAME))
	   	   PSECT(EXEC$INIT_SSTBL_001);

	%ELSE	! %NULL(PREFIX)

		EXTERNAL ROUTINE  %NAME('SYS$',NAME);
		OWN
		   %NAME('BASE_VECTOR_',NAME): LONG
		   INITIAL(%NAME('SYS$',NAME))
		   PSECT(EXEC$INIT_SSTBL_001);

		OWN
	   	   %NAME('SELF_RELATIVE_',NAME): LONG
	   	   INITIAL(%NAME(PREFIX,NAME))
	   	   PSECT(EXEC$INIT_SSTBL_001);
	%FI	! %NULL(PREFIX)

	%IF	%NULL(TYPE)	%THEN
    	    	OWN
      	       	   %NAME('TYPE_',NAME): BYTE
       	       	   INITIAL(TYPE_K_NORMAL)
		   PSECT(EXEC$INIT_SSTBL_001);
	%ELSE	! %NULL(TYPE)
    	    	OWN
      	       	   %NAME('TYPE_',NAME): BYTE
       	       	   INITIAL(%NAME('TYPE_K_',TYPE))
		   PSECT(EXEC$INIT_SSTBL_001);
	%FI	! %NULL(TYPE)

	%IF	%NULL(FLAGS)	%THEN
    	    	OWN
      	       	   %NAME('FLAGS_',NAME): BYTE
       	       	   INITIAL(0)
		   PSECT(EXEC$INIT_SSTBL_001);
	%ELSE	! %NULL(FLAGS)
    	    	OWN
      	       	   %NAME('FLAGS_',NAME): BYTE
       	       	   INITIAL(FLAGS)
		   PSECT(EXEC$INIT_SSTBL_001);
	%FI	! %NULL(FLAGS)

	%IF	%NULL(IMASK)	%THEN
    	    	OWN
      	       	   %NAME('IMASK_',NAME): BYTE
       	       	   INITIAL(129)
		   PSECT(EXEC$INIT_SSTBL_001);
	%ELSE	! %NULL(IMASK)
		OWN
		   %NAME('IMASK_',NAME): BYTE
		   INITIAL(IMASK)
		   PSECT(EXEC$INIT_SSTBL_001);
	%FI	!  %NULL(IMASK)

	
	%IF	%NULL(MODE)	%THEN
		%ERROR('NO MODE SPECIFIED FOR SYSTEM SERVICE')
	%ELSE	! %NULL(MODE)
		%IF %IDENTICAL(%NAME('MODE_K_',MODE),MODE_K_KERNEL) %THEN
		    OWN
		       %NAME('MODE_',NAME): BYTE
		       INITIAL(MODE_K_KERNEL)
	   	       PSECT(EXEC$INIT_SSTBL_001);
		%ELSE
	            %IF %IDENTICAL(SSFLAG_K_WCM,FLAGS) OR %IDENTICAL(SSFLAG_K_WCM_NO_REEXEC,FLAGS) %THEN
			       %ERROR('SS$_WAIT_CALLERS_MODE IN KERNEL_MODE ONLY')
		    %FI
		    %IF %IDENTICAL(%NAME('MODE_K_',MODE),MODE_K_EXEC) %THEN
		    	OWN
		      	   %NAME('MODE_',NAME): BYTE
		       	   INITIAL(MODE_K_EXEC)
	   		   PSECT(EXEC$INIT_SSTBL_001);
		    %ELSE
			%ERROR('ILLEGAL MODE-TYPE')
		    %FI
		%FI
	%FI	! %NULL(MODE)
	OWN
      	  %NAME('UNUSED_',NAME): LONG
	  INITIAL(LONG(0))
	  PSECT(EXEC$INIT_SSTBL_001);

%FI	!%IDENTICAL(MODE)

	%IF	%NULL(NARG)	%THEN
		%ERROR('NUMBER OF ARGUEMENTS NOT SPECIFIED FOR SYSTEM SERVICE')
	%FI	! %NULL(NARG)

	  BUILTIN
		ACTUALCOUNT;
	  %IF	%NULL(MARG)	%THEN
		IF ACTUALCOUNT() LSSU NARG !Were enough argument passed?
	  %ELSE ! %NULL(MARG) 
		IF ACTUALCOUNT() LSSU MARG !Were enough argument passed?
	  %FI	! %NULL(MARG)
	  THEN RETURN SS$_INSFARG;
%;

!++
!
! $COUNT_ENTRY
!	This macro implements a debug-time counter of the number of entries
!	into a given system routine.  If the compile-time literal
!	SYS$COUNT_ENTRY_ENABLED is defined, then this macro will create the 
!	counter and generate the code necessary to increment it.  This macro
!	provides equivalent functionality to the Macro-32 $COUNT_ENTRY macro
!	which is defined in SYSMAR.MAR.  The design documents STDCALLJACKETS.PS,
!	JTOC_DESIGN.PS, and INBOUND_DRIVER.PS in EVMS$IO_CMS: rely on this
!	macro to help with validation testing.
!
! MACRO PARAMETERS
!	NAME - The name of the routine
!
! OUTPUTS
!	Generates a global longword counter cell.  Usually the counter cells
!	are named CNT_'name'.   However, if the resultant name is longer than
!	31 characters, then the first four characters of the routine name are 
!	dropped.  The trailing characters of the routine name are much more
!	likely to be required for uniqueness than the prefix characters.
!
!--
! DISABLED -- Commented out SYS$K_COUNT_ENTRY_ENABLED = 1 

MACRO $COUNT_ENTRY (NAME) =
    %IF %DECLARED(SYS$K_COUNT_ENTRY_ENABLED)
    %THEN
        BEGIN
            $DECLARE_PSECT (EXEC$NONPAGED_DATA);	!Counter is nonpaged
            GLOBAL $$COUNTER_NAME(NAME): INITIAL (0);
            $$COUNTER_NAME(NAME) = .$$COUNTER_NAME(NAME) + 1;	    
        END 
    %FI  %;


! $$COUNTER_NAME
!	Helper macro for $COUNT_ENTRY.  It expands to a valid counter variable
!	name that is at most 31 characters long.
!
MACRO $$COUNTER_NAME (NAME) =
    %IF %CHARCOUNT('CNT_',NAME) LEQ 31
    %THEN
        %NAME('CNT_',NAME)
    %ELSE
        %NAME('CNT_',$$DROP4(%EXPLODE(NAME)))		!Drop first 4 chars NAME
    %FI %;


! $$DROP4
!	Helper macro for $$COUNTER_NAME.  It expands to a comma separated list
!	of input parameters after the first 4 parameters are dropped.
!
MACRO $$DROP4 (P1,P2,P3,P4) = %REMAINING % ;


!++
! The definition of the following compiletime variable enables expansion of 
! the $$COUNT_ENTRY macro.  For Macro-32, see [LIB]SYSMAR.MAR.
!--
! DISABLED -- DISABLED -- DISABLED
!COMPILETIME
!    SYS$K_COUNT_ENTRY_ENABLED = 1;


! $SET_IPL
!
!   Set the process IPL.  This (simple) macro should be used only by system
!   services which need to raise IPL to IPL$_ASTDEL to block process deletion.
!
! Usage:
!
!   $set_ipl (ipl$_astdel);
!   $set_ipl (0);
!   $set_ipl (.saved_ipl);
!
! $READ_IPL
!
!   Read the process IPL.
!
! Usage:
!
!   $read_ipl (saved_ipl);

macro
    $set_ipl (level) =
	begin
        builtin pal_mtpr_ipl;
        pal_mtpr_ipl (level);
	end %,
	
    $read_ipl (dst) =
	begin
        builtin pal_mfpr_ipl;
        dst = pal_mfpr_ipl ();
   	end %;

! $KERNEL_CALL
! $EXEC_CALL
!
!   Call a routine via $CMKRNL or $CMEXEC.
!
!   The following two macros violate the BLISS language definition in that they
!   make use of the value of SP while building the argument list.  It is the
!   opinion of the BLISS maintainers that this usage is safe from planned
!   future optimizations.
!
!   These routines were taken from the XQP.
!   
! Usage:
!
!   status = $kernel_call (foo, arg1, argn);
!
!   status = $exec_call (bar, arg1, argn);

macro
    $kernel_call ( rtn_name, arguments ) =
	begin
	local	arg_vector 	: vector [%length];
	compiletime	arg_vector_idx = 0;

	%assign (arg_vector_idx, 0)
	arg_vector [0] = %length - 1;
	%if %length - 1 gtr 0
	%then
	    $add_arg (arguments %if %length - 2 gtr 0 %then, %remaining %fi);
	%fi
	$cmkrnl	(routin = rtn_name,
		 arglst = arg_vector)
	end %;

macro
    $exec_call ( rtn_name, arguments ) =
	begin
	local	arg_vector 	: vector [%length];
	compiletime	arg_vector_idx = 0;

	%assign (arg_vector_idx, 0)
	arg_vector [0] = %length - 1;
	%if %length - 1 gtr 0
	%then
	    $add_arg (arguments %if %length - 2 gtr 0 %then, %remaining %fi);
	%fi
	$cmexec	(routin = rtn_name,
		 arglst = arg_vector)
	end %;

macro
    $add_arg (parameter) [] =
	begin
	%assign (arg_vector_idx, arg_vector_idx + 1)
	arg_vector [arg_vector_idx] = parameter;
	%if %length - 1 gtr 0 %then $add_arg (%remaining); %fi
	end %;

!+
!
! Macro to return the actual length of a blank-filled string.
!
! Usage:
!
!   USERNAME[DSC$W_LENGTH] = $NAMELEN (UAF$S_USERNAME, USERNAME_BUF);
!
!-
MACRO
        $NAMELEN (X, Y) =
            BEGIN
            LOCAL
                TEMP : REF VECTOR[,BYTE],
                R    : INITIAL(0);
            TEMP = CH$FIND_CH(X,Y,%C' ');
            IF NOT CH$FAIL(.TEMP) THEN R = Y + X - .TEMP;
            X - .R
            END %;


%SBTTL	'ORB processing routine interface macros'
!+
!	This is just the temporary location for these macros.
!-

!   $CLONE_ORB
! 
!     Clone a Object Rights Block
! 
! 	$CLONE	srcorb, [alortn], [deartn], [objnam], flags, [itmlst], orb
! 		
! 
KEYWORDMACRO $CLONE_ORB (SRCORB, ALORTN = 0, DEARTN = 0, OBJNAM = 0,
			 FLAGS = 0, ITMLST = 0, ORB ) =
   BEGIN
   EXTERNAL ROUTINE EXE$CLONE_ORB : BLISS ADDRESSING_MODE (GENERAL);
	   EXE$CLONE_ORB ( SDL$STARLET_CONCAT (
			   SDL$STARLET_REQ (SRCORB, %QUOTE SRCORB),
			   ALORTN, DEARTN, OBJNAM, 
			   FLAGS, ITMLST, SDL$STARLET_REQ(ORB, %QUOTE ORB) ) )
   END %;

!   $CREATE_ORB
! 
!     Create a Object Rights Block
! 
! 	$CREATE_ORB	[alortn], [deartn], [objnam], flags, [itmlst], orb
! 		
! 
KEYWORDMACRO $CREATE_ORB (ALORTN = 0, DEARTN = 0, OBJNAM,
		      	  FLAGS = 0, ITMLST = 0, ORB ) =
   BEGIN
   EXTERNAL ROUTINE EXE$CREATE_ORB : BLISS ADDRESSING_MODE (GENERAL);
	   EXE$CREATE_ORB ( SDL$STARLET_CONCAT (ALORTN, DEARTN, 
			     SDL$STARLET_REQ(OBJNAM, %QUOTE OBJNAM),
			     FLAGS , ITMLST, SDL$STARLET_REQ(ORB, %QUOTE ORB)))
   END %;

!   $CLONE_TEMPLATE_ORB
! 
!     Clone a Template (default) Object Rights Block
! 
! 	$CLONE_TEMPLATE_ORB	ocb, tmpnam, [alortn], [deartn], [objnam], 
!				[flags], [itmlst], orb
! 		
! 
KEYWORDMACRO $CLONE_TEMPLATE_ORB (OCB, TMPNAM, ALORTN = 0, DEARTN = 0, 
			          OBJNAM = 0, FLAGS = 0, ITMLST = 0, ORB ) =
   BEGIN
   EXTERNAL ROUTINE EXE$CLONE_TEMPLATE_ORB : BLISS ADDRESSING_MODE (GENERAL);
	   EXE$CLONE_TEMPLATE_ORB ( SDL$STARLET_CONCAT (
			   SDL$STARLET_REQ (OCB, %QUOTE OCB),
			   SDL$STARLET_REQ (TMPNAM, %QUOTE TMPNAM),
			   ALORTN, DEARTN, OBJNAM, FLAGS, ITMLST,
			   SDL$STARLET_REG(ORB, %QUOTE ORB) ) )
   END %;

! $PROBE_IN_DESCRIPTOR
! $PROBE_OUT_DESCRIPTOR
!
!   Probe a string descriptor and its associated buffer and copy the descriptor
!   to local storage.  This protocol is required for all system service input
!   and output arguments which are passed by descriptor.
!
!   Usage:
!
!	global routine sys$service (foo) =
!	    .
!	    .
!	    .
!	local
!	    local_foo : block[dsc$k_s_bln,byte];	! local copy of FOO descriptor
!
!   Required parameter:
!
!	$probe_in_descriptor (foo, local_foo);
!
!   Optional parameter:
!
!	if .foo neqa 0
!	then
!	    $probe_in_descriptor (foo, local_foo);
!
!   Returns:
!
!	SS$_ACCVIO	descriptor or buffer not accessible

macro
    $probe_in_descriptor ($$desc, $$out, $$mode) =
	begin
        if not $probe (.$$desc, dsc$k_s_bln, rq)
	then
	    return ss$_accvio;

	$$out[dsc$w_length] = .$$desc[dsc$w_length];
	$$out[dsc$a_pointer] = .$$desc[dsc$a_pointer];

	if not $probe (.$$out[dsc$a_pointer], .$$out[dsc$w_length], r)
	then
	    return ss$_accvio;
	end %,

    $probe_out_descriptor ($$desc, $$out, $$mode) =
	begin
        if not $probe (.$$desc, dsc$k_s_bln, wq)
	then
	    return ss$_accvio;

	$$out[dsc$w_length] = .$$desc[dsc$w_length];
	$$out[dsc$a_pointer] = .$$desc[dsc$a_pointer];

	if not $probe (.$$out[dsc$a_pointer], .$$out[dsc$w_length], w)
	then
	    return ss$_accvio;
	end %;


!+
! $AND_THEN
!
! Calling:
!
!   IF $AND_THEN ( cond1 [ , cond2 [ , cond3 ... ] ] ) THEN ...
!
! This macro accepts any number of conditional statements and returns the result
! of a logical AND of those statements. The difference between this and a
! standard BLISS "IF (COND1) AND (COND2) THEN" is that:
! (a) the order of evaluation is GUARANTEED to be left to right
! (b) as soon as one condition is found to be false, remaining conditions are
!     NOT evaluated.
!
! For example, the following code, although it may currently generate the code
! you expect, is not guaranteed to (the BLISS apecification explicitly states
! that conditionals are NOT evaluated in any specific order). Assume that
! BLOCK has previously been declared as a REF BLOCK:
!
!   IF (.BLOCK NEQA 0) AND (.BLOCK[BLK$V_FLAG]) THEN ...
!
! Using the $AND_THEN macro, correct code is guaranteed:
!
!   IF $AND_THEN ( .BLOCK NEQA 0 , .BLOCK[BLK$V_FLAG] ) THEN ...
!
! Enclosing each conditional in parentheses is optional.
!-
MACRO $AND_THEN ( C1 )[] =
    %IF %NULL(%REMAINING)
    %THEN
        (C1)
    %ELSE
	( IF (C1) THEN ($AND_THEN(%REMAINING)) ELSE 0 )
    %FI % ;

!+
! $OR_ELSE
! $OR_THEN
!
! Calling:
!
!   IF $OR_THEN ( cond1 [ , cond2 [ , cond3 ... ] ] ) THEN ...
!
! This macro accepts any number of conditional statements and returns the result
! of a logical OR of those statements. The difference between this and a
! standard BLISS "IF (COND1) AND (COND2) THEN" is that:
! (a) the order of evaluation is GUARANTEED to be left to right
! (b) as soon as one condition is found to be true, remaining conditions are
!     NOT evaluated.
!
! For example, the following code, although it may currently generate the code
! you expect, is not guaranteed to (the BLISS apecification explicitly states
! that conditionals are NOT evaluated in any specific order). Assume that
! BLOCK has previously been declared as a REF BLOCK:
!
!   IF (.BLOCK EQLA 0) OR (.BLOCK[BLK$V_FLAG]) THEN ...
!
! Using the $OR_THEN macro, correct code is guaranteed:
!
!   IF $OR_THEN ( .BLOCK EQLA 0 , .BLOCK[BLK$V_FLAG] ) THEN ...
!
! Enclosing each conditional in parentheses is optional.
!-
MACRO $OR_THEN ( C1 )[] =
    %IF %NULL(%REMAINING)
    %THEN
        (C1)
    %ELSE
        ( IF (C1) THEN 1 ELSE ($OR_THEN(%REMAINING)) )
    %FI % ;

MACRO $OR_ELSE ( C1 )[] =
    %IF %NULL(%REMAINING)
    %THEN
        (C1)
    %ELSE
        ( IF (C1) THEN 1 ELSE ($OR_THEN(%REMAINING)) )
    %FI % ;

!+
!
! Macro to construct a quadword privilege mask out of a named privilege list.
!
! Usage:
!
!   local
!	priv_mask : vector[2] initial(0,0);
!   
!   $privs_to_mask (cmkrnl, priv_mask);
!   $privs_to_mask ((world,oper), priv_mask);
!
!-

macro
    $$set_privs_l (priv_name)[] =
        begin
        %if $byteoffset (%name ('PRV$V_', priv_name)) eql 0
        %then
             %name ('PRV$M_', priv_name) $$set_privs_or (%remaining) $$set_privs_l (%remaining)
        %else
            0 $$set_privs_or (%remaining) $$set_privs_l (%remaining)
        %fi
        end %,

    $$set_privs_h (priv_name)[] =
        begin
        %if $byteoffset (%name ('PRV$V_', priv_name)) eql 4
        %then
             1^$bitposition(%name ('PRV$V_', priv_name)) $$set_privs_or (%remaining) $$set_privs_h (%remaining)
        %else
            0 $$set_privs_or (%remaining) $$set_privs_h (%remaining)
        %fi
        end %,

    $$set_privs_or [] =
            or %,

    $privs_to_mask (privs, mask) =
            begin
            bind $$m = mask : vector[,long];
            $$m[0] = $$set_privs_l (%remove (privs));
            $$m[1] = $$set_privs_h (%remove (privs));
            end %;
!+
!
!
!
!-
macro
    $$translate_flags_to_nsap(flag)[] = 
	%name ('NSAP$M_',flag) $$flags_or(%remaining) $$translate_flags_to_nsap(%remaining) %,
	
    $$translate_flags_to_nsa(flag)[] =
	%name ('NSA$M_',flag) $$flags_or(%remaining) $$translate_flags_to_nsa(%remaining) %,

    $$flags_or[] = 
	or %;

!+
!
! Macro to perform a simple privilege check with auditing.
!
! Usage:
!
!   if (status = $has_priv (priv = world, message = world_1, itmlst = audit_list))
!   then
!	begin
!	.
!	.   <<perform privileged function>>
!	.
!	end
!   else
!	return .status;
!
!-
keywordmacro
    $has_priv (priv, mask = current, message, msgcod, itmlst, altprv, flags) =
	begin
	external routine
	    nsa$check_privilege : nsa$check_privilege_linkage 
				  ADDRESSING_MODE(GENERAL);

	local
	    $$status,					! return status
	    priv_mask : vector[2] initial(0,0),		! privs to check
	    psl : block[4,byte];			! current PSL

	builtin
	    pal_rd_ps;

	%if %null(priv)
	%then
	    %error('Privilege name missing from call to $HAS_PRIV');
	%fi

	%if %null(message) and %null(msgcod)
	%then
	    %error('Privilege audit message code not supplied to $HAS_PRIV');
	%fi

	! Convert the privilege list to a privilege mask.
	!
	$privs_to_mask(priv, priv_mask);

	! Fetch the current PSL.
	!
	psl = pal_rd_ps();

	! If we're in kernel or exec mode, just call NSA$CHECK_PRIVILEGE.
	!
	if .psl[psl$v_curmod] eql psl$c_kernel or
	   .psl[psl$v_curmod] eql psl$c_exec
	then
	    begin
	    local
		nsap : block[nsap$k_length,byte];

	    ! Clear the privilege check control block, note that this call
	    ! is from the VMS TCB (internal), that we're passing a quadword
	    ! mask, and store the privilege audit message code in the NSAP.
	    !    
	    ch$fill (0, nsap$k_length, nsap);

	   nsap[nsap$l_flags] = nsap$m_internal or nsap$m_privmask or nsap$m_noprobe;
	    %if not %null(flags) 
	    %then
		nsap[nsap$l_flags] = .nsap[nsap$l_flags] or $$translate_flags_to_nsap(%remove(flags));
	    %fi

	    %if not %null(message)
	    %then
	    nsap[nsap$l_message] = %name('NSA$_',message);		
	    %else
	    nsap[nsap$l_message] = .msgcod;
	    %fi

	    ! Note which privilege mask NSA$CHECK_PRIVILEGE should check.
	    ! Issue an error if the caller gave us a bogus mask name.
	    ! 
	    %if not %identical(mask, current)
	    %then
		%if %identical(mask, process)
		%then
		    nsap[nsap$v_procpriv] = 1;
		%else
		    %if %identical(mask, authorized)
		    %then
			nsap[nsap$v_authpriv] = 1;
		    %else
			%error('Invalid privilege location supplied to $HAS_PRIV - use CURRENT, PROCESS, or AUTHORIZED')
		    %fi		
		%fi		
	    %fi

	    ! If the caller gave us an item list, pass it on.
	    !
	    %if not %null(itmlst)
	    %then
		nsap[nsap$l_audit_list] = itmlst;
	    %fi

	    ! If the caller gave us an alternate priv masck to check, pass it on.
	    !
	    %if not %null(altprv)
	    %then
		nsap[nsap$v_altpriv] = 1;
		$move_quad(altprv, nsap[nsap$q_altpriv]);
	    %fi

	    ! Call NSA$CHECK_PRIVILGE to perform the privilege check.
	    !
	    $$status = nsa$check_privilege (priv_mask, nsap, 0);
	    end
	
	! Otherwise, use the $CHECK_PRIVILEGE system service to do the privilege check.
	!
	else
	    begin
	    local
		i : blockvector[2,itm$s_item,byte];	! a two entry item list

	    ! Initialize our mini item list.
	    !
	    ch$fill (0, %allocation(i), i);

	    ! Store the message code in our mini item list.
	    ! 
	    i[0,itm$w_itmcod] = nsa$_message;
	    i[0,itm$w_bufsiz] = 4;
	    i[0,itm$l_bufadr] = %if not %null(message) %then uplit(%name('NSA$_',message)); %else msgcod; %fi;
	    
	    ! If we were passed a real item list to use then set our last
	    ! item list entry to point to the caller's item list.
	    ! 
	    %if not %null(itmlst)
	    %then
		i[1,itm$w_itmcod] = nsa$_chain;
		i[1,itm$l_bufadr] = itmlst;
	    %fi

	    ! Call the system service to perform the privilege check.
	    !
	    $$status = $check_privilege (prvadr   = priv_mask, 
		    %if not %null(altprv)
		    %then
			%quote altprv   = altprv, 
		    %fi
		    %if not %null(flags)
		    %then
			%quote flags    = nsa$m_internal or $$translate_flags_to_nsa(%remove(flags))
		    %else
			%quote flags    = nsa$m_internal
		    %fi
		    %if %identical(mask, authorized)
		    %then 
		    or nsa$m_authpriv
		    %else
			%if %identical(mask, process)
			%then 
			or nsa$m_procpriv
			%else
			    %if not %identical(mask, current)
			    %then
			    %error('Invalid privilege location supplied to $HAS_PRIV - use CURRENT, PROCESS, or AUTHORIZED')
			    %fi
			%fi
		    %fi ,
				       %quote itmlst = i);
	    end;

	! Return the status from the privilege check to the caller.
	!
	.$$status
	end %;
                         

! $DISABLE_AUDIT
! $ENABLE_AUDIT
! $RESTORE_AUDIT
!
!   Disables or enables and restores auditing around TCB actions which should
!   not be audited or must be audited in a program with NOAUDIT set.  This
!   macro may be called in any mode, but requires CMKRNL if caller was not
!   in exec or kernel mode.
!   
! Usage:
!
!   LOCAL
!	SAVED_AUDIT;
!
!   $DISABLE_AUDIT (SAVED_AUDIT);
!   .
!   .
!   .
!   $RESTORE_AUDIT (SAVED_AUDIT);
!
! or
!
!   LOCAL
!	SAVED_AUDIT;
!
!   $ENABLE_AUDIT (SAVED_AUDIT);
!   .
!   .
!   .
!   $RESTORE_AUDIT (SAVED_AUDIT);

macro
    $disable_audit ($$saved_state) =
	begin
	$$saved_state = -1;
	$restore_audit ($$saved_state);
	end %,

    $enable_audit ($$saved_state) =
	begin
	$$saved_state = 1;
	$restore_audit ($$saved_state);
	end %,

    $restore_audit ($$saved_state) =
	begin
	local $$psl : block[4,byte];
	builtin pal_rd_ps;
	
	$$psl = pal_rd_ps();
	if .$$psl[psl$v_curmod] eql psl$c_kernel
	then
	    begin
	    external ctl$gl_pcb : ref block[,byte];
	    if .ctl$gl_pcb[pcb$l_noaudit] neq 0 or .$$saved_state eql -1
	    then
		begin
		ctl$gl_pcb[pcb$l_noaudit] =
		   .ctl$gl_pcb[pcb$l_noaudit] - .$$saved_state;
		$$saved_state = -.$$saved_state;
		end
	    else
		$$saved_state = 0;
	    end
	else
	    begin
	    routine $$restore_audit ($$s) =
		begin
		external ctl$gl_pcb : ref block[,byte];
		if .ctl$gl_pcb[pcb$l_noaudit] neq 0 or .$$s eql -1
		then
		    begin
		    ctl$gl_pcb[pcb$l_noaudit] =
		        .ctl$gl_pcb[pcb$l_noaudit] - .$$s;
		    return -.$$s;
		    end
		else
		    return 0;
		end;
	    $$saved_state = $kernel_call ($$restore_audit, .$$saved_state);
	    if .$$saved_state neq 1 and .$$saved_state neq -1
	    then
		$$saved_state = 0;
	    end;
	end %;

!++
!
! Driver dispatch table generation macros
!
!--
KEYWORDMACRO
    DDTAB (DEVNAM=DRIVER,	! device name for symbol
  	START=0,		! start I/O routine
  	CTRLINIT=0,		! controller init routine
	FUNCTB,			! FDT address
	CANCEL=0,		! cancel I/O routine
	REGDMP=0,		! register dump routine
	DIAGBF=0,		! diagnostic buffer size
	ERLGBF=0,		! error log buffer size
	UNITINIT=0,		! unit init routine
	ALTSTART=0,		! alt start I/O routine
	MNTVER=0,		! mount verification routine
	CLONEDUCB=0,		! cloned UCB routine
	MNTV_SSSC=0,		! mount ver rout. for shadow sets
	MNTV_FOR=0,		! mount ver rout. for /FOREIGN
	MNTV_SQD=0,		! mount ver rout. for tapes
	CHANNEL_ASSIGN=0,	! routine to call from $ASSIGN
	CANCEL_SELECTIVE=0,	! selective cancel routine
	KP_STACK_SIZE=0,	! KP stack byte count
	KP_REG_MASK=0,		! KP register save mask
	KP_STARTIO=0,		! start I/O for KP drivers
	CSR_MAPPING=0,		! CSR mapping routine
	AUX_STORAGE=0,		! driver-dependent cell
	AUX_ROUTINE=0,		! driver-dependent cell
	PSECT_NAME=$$$110_DATA, ! DDT psect name
	STEP=2) =		! driver step 

    MACRO			! Nested DDTAB macros
	DDTAB_GENRADDR (RTN_NAME, DEFAULT) =
	    %IF NOT %IDENTICAL (RTN_NAME, 0) %THEN
		 (RTN_NAME)
	    %ELSE
		 %IF NOT %NULL (DEFAULT) %THEN
		    (DEFAULT)
		 %ELSE
		    (ioc$return)
		 %FI
	    %FI %QUOTE %,

	DDTAB_REG_SPEC (REGISTER_LIST)[] =
	    %IF %IDENTICAL (0, REGISTER_LIST) %THEN
		0
	    %ELSE 
		(1 ^ (REGISTER_LIST))
		%IF %LENGTH GTR 1 %THEN
		    OR DDTAB_REG_SPEC (%REMAINING)
		%FI
	    %FI %QUOTE %;
    %IF NOT %DECLARED (ioc$return) %THEN
	EXTERNAL ROUTINE	ioc$return;
    %FI
    %IF NOT %DECLARED (ioc$return_success) %THEN
	EXTERNAL ROUTINE	ioc$return_success;
    %FI
    %IF NOT %DECLARED (ioc$return_unsupported) %THEN
	EXTERNAL ROUTINE	ioc$return_unsupported;
    %FI
    %IF NOT %DECLARED (ioc_std$mntver) %THEN
	EXTERNAL ROUTINE	ioc_std$mntver;
    %FI
    PSECT
	NODEFAULT = PSECT_NAME (PIC, READ, WRITE, NOEXECUTE, ALIGN (5));
    GLOBAL
	%NAME (DEVNAM,'$DDT') : PSECT (PSECT_NAME) BLOCK [ddt$k_length, BYTE]
	PRESET (
	    [ddt$iw_size] =		DDT$K_LENGTH,
	    [ddt$iw_diagbuf] =		DIAGBF,
	    [ddt$iw_errorbuf] =		ERLGBF,
	    [ddt$iw_fdtsize] =		FDT$K_LENGTH,
	    [ddt$ps_start_2] =		DDTAB_GENRADDR (START, ioc$return_success),
	    [ddt$ps_start_jsb] =	0,
	    [ddt$ps_ctrlinit_2] =	DDTAB_GENRADDR (CTRLINIT, ioc$return_success),
	    [ddt$ps_unitinit_2] =	DDTAB_GENRADDR (UNITINIT, ioc$return_success),
	    [ddt$ps_cloneducb_2] =	DDTAB_GENRADDR (CLONEDUCB, ioc$return_success),
	    [ddt$ps_fdt_2] =		FUNCTB,
	    [ddt$ps_cancel_2] =		DDTAB_GENRADDR (CANCEL, ioc$return_success),
	    [ddt$ps_regdump_2] =	DDTAB_GENRADDR (REGDMP, ioc$return_success),
	    [ddt$ps_altstart_2] =	DDTAB_GENRADDR (ALTSTART, ioc$return_success),
	    [ddt$ps_altstart_jsb] =	0,
	    [ddt$ps_mntver_2] =		DDTAB_GENRADDR (MNTVER, ioc_std$mntver),
	    [ddt$ps_mntv_sssc] =	DDTAB_GENRADDR (MNTV_SSSC),
	    [ddt$ps_mntv_for] =		DDTAB_GENRADDR (MNTV_FOR),
	    [ddt$ps_mntv_sqd] =		DDTAB_GENRADDR (MNTV_SQD),
	    [ddt$ps_aux_storage] =	DDTAB_GENRADDR (AUX_STORAGE),
	    [ddt$ps_aux_routine] =	DDTAB_GENRADDR (AUX_ROUTINE),
	    [ddt$ps_channel_assign_2] = DDTAB_GENRADDR (CHANNEL_ASSIGN, ioc$return_unsupported),
	    [ddt$ps_cancel_selective_2] = DDTAB_GENRADDR (CANCEL_SELECTIVE, ioc$return_unsupported),
	    [ddt$is_stack_bcnt] =	KP_STACK_SIZE,
	    [ddt$is_reg_mask] =		%IF %IDENTICAL (0, KP_REG_MASK) %THEN
					    KPREG$K_HLL_REG_MASK
					%ELSE
					    DDTAB_REG_SPEC (%REMOVE (KP_REG_MASK))
					%FI,
	    [ddt$ps_kp_startio] =	DDTAB_GENRADDR (KP_STARTIO),
	    [ddt$ps_csr_mapping] =	DDTAB_GENRADDR (CSR_MAPPING, ioc$return_success),
	    [ddt$ps_customer] =		0
	) %;

!++
!
! Driver Prologue Table generation macros
!
!--
KEYWORDMACRO
    DPTAB
	(ADAPTER,  			! Adapter type
	FLAGS=0,			! DPT flags
	UCBSIZE=0,			! size of UCB
	UNLOAD=0,			! unload routine
	MAXUNITS=8,			! max units to configure
	DEFUNITS=1,			! default units to configure
	DELIVER=0,			! unit delivery routine
	VECTOR=0,			! driver-spec address
	NAME,				! driver name
	DECODE=0,			! DECwindows-spec address
	STEP=0,				! EVMS driver step number
	IDB_CRAMS=0,			! CRAMs allocated on IDB
	UCB_CRAMS=0,			! CRAMs allocated on each UCB
	BT_ORDER=0,			! Boot-time init ordering control
	IOHANDLES=0,			! IOHANDLES needed by driver
	DDT=DRIVER$DDT,			!
	STRUC_INIT=DRIVER$STRUC_INIT, 	    !
	STRUC_REINIT=DRIVER$STRUC_REINIT,   !
	PSECT_NAME = $$$105_PROLOGUE,	! DPT psect name
	DPT=DRIVER$DPT) =		! DPT label
    MACRO
	DPTAB_FLAG_SPEC (FLAG_LIST)[] =
	    %IF %IDENTICAL (0, FLAG_LIST) %THEN
		(dpt$m_smpmod)
	    %ELSE 
		(FLAG_LIST)
		%IF %LENGTH GTR 1 %THEN
		    OR DPTAB_FLAG_SPEC (%REMAINING)
		%ELSE
		    OR (dpt$m_smpmod)
		%FI
	    %FI %QUOTE %;
    PSECT
	NODEFAULT = PSECT_NAME (PIC, READ, WRITE, NOEXECUTE, ALIGN (5));

    GLOBAL DPT : PSECT (PSECT_NAME) BLOCK [dpt$k_base_len + nam$c_maxrss, BYTE]
	PRESET (
   	    [dpt$iw_size] =		dpt$k_base_len + nam$c_maxrss,
	    [dpt$ib_type] =		dyn$c_dpt,
	    [dpt$iw_step] =		dpt$k_step_2,
	    [dpt$iw_stepver] =		dpt$k_step2_v2,
	    [dpt$iw_defunits] =		DEFUNITS,
	    [dpt$iw_maxunits] =		MAXUNITS,
	    [dpt$iw_ucbsize] =		UCBSIZE,
	    [dpt$iw_iohandles] =	IOHANDLES,
	    [dpt$iw_idb_crams] =	IDB_CRAMS,
	    [dpt$iw_ucb_crams] =	UCB_CRAMS,
	    [dpt$il_flags] =		DPTAB_FLAG_SPEC (%REMOVE (FLAGS)),
	    [dpt$il_adptype] =		%NAME ('AT$_', ADAPTER),
	    [dpt$ps_init_pd] =		STRUC_INIT,
	    [dpt$ps_reinit_pd] =	STRUC_REINIT,
	    [dpt$ps_deliver_2] =	DELIVER,
	    [dpt$ps_unload] =		UNLOAD,
	    [dpt$ps_ddt] =		DDT,
	    [dpt$is_btorder] =		BT_ORDER,
	    [dpt$ps_vector] =		VECTOR,
!	    [dpt$t_name] =		! Not used
!	    [dpt$ib_name_len] =		! overlaid by
!	    [dpt$t_name_str] =		! driver loading
	    [dpt$iw_iname_len] =	nam$c_maxrss,
	    [dpt$ib_iname_type] =	dsc$k_dtype_t,
	    [dpt$ib_iname_class] =	dsc$k_class_s,
	    [dpt$ps_iname_ptr] =	DPT[dpt$t_image_name],
	    [dpt$ps_decw_sname] = 	DECODE
	) %;

!++
!
! Function Decision Table generation macros
!
!--
KEYWORDMACRO
    FDTAB (
	FDT_NAME = driver$fdt,		! FDT name
	FDT_BUF,			! buffered functions
	FDT_ACT, 			! actions
	PSECT_NAME = $$$110_DATA) =	! FDT psect name
    MACRO
	FDTAB_F2M (FUNC, BUMP) = (1 ^ (%NAME ('IO$_',FUNC) - BUMP)) %QUOTE %,

	FDTAB_BLDBFM (FUNC)[] =
	    %IF NOT %IDENTICAL (0, FUNC) %THEN
		%IF %NAME ('IO$_',FUNC) LSS 32 %THEN
		    %ASSIGN (FDTAB_BUFLO, FDTAB_BUFLO OR FDTAB_F2M (FUNC, 0))
		%ELSE
		    %ASSIGN (FDTAB_BUFHI, FDTAB_BUFHI OR FDTAB_F2M (FUNC, 32))
		%FI
		%IF %LENGTH GTR 1 %THEN
		    FDTAB_BLDBFM (%REMAINING)
		%ELSE
		    [FDTAB_BUF_O, 0, 32, 0] = FDTAB_BUFLO,
		    [FDTAB_BUF_O + 4, 0, 32, 0] = FDTAB_BUFHI
		%FI
	    %FI %QUOTE %,

	FDTAB_SETACT (ACTRTN, FUNC) = 
	    %IF %NAME ('IO$_',FUNC) LSS 32 %THEN
		%IF (FDTAB_FUNCLO AND FDTAB_F2M (FUNC, 0)) NEQ 0 %THEN
		    %ERROR ('Multiple actions associated with function IO$_FUNC')
		%ELSE
		    %ASSIGN (FDTAB_FUNCLO, FDTAB_FUNCLO OR FDTAB_F2M (FUNC, 0))
		    [FDTAB_ACT_O + (4 * %NAME ('IO$_', FUNC)), 0, 32, 0] = ACTRTN
		%FI
	    %ELSE
		%IF (FDTAB_FUNCHI AND FDTAB_F2M (FUNC, 32)) NEQ 0 %THEN
		    %ERROR ('Multiple actions associated with function IO$_FUNC')
		%ELSE
		    %ASSIGN (FDTAB_FUNCHI, FDTAB_FUNCHI OR FDTAB_F2M (FUNC, 32))
		    [FDTAB_ACT_O + (4 * %NAME ('IO$_', FUNC)), 0, 32, 0] = ACTRTN
		%FI
	    %FI %QUOTE %,

	FDTAB_SETDEF (INDEX)[] =
	    %IF INDEX LSS 32 %THEN
		%IF (FDTAB_FUNCLO AND (1 ^ INDEX)) EQL 0 %THEN
		    , [FDTAB_ACT_O + (4 * INDEX), 0, 32, 0] = EXE$ILLIOFUNC
		%FI
	    %ELSE
		%IF (FDTAB_FUNCHI AND (1 ^ (INDEX - 32))) EQL 0 %THEN
		    , [FDTAB_ACT_O + (4 * INDEX), 0, 32, 0] = EXE$ILLIOFUNC
		%FI
	    %FI
	    %ASSIGN (INDEX, INDEX + 1)
	    %IF INDEX LSS 64 %THEN
		FDTAB_SETDEF (INDEX)
	    %FI %QUOTE %,

	FDTAB_DOFUNCLIST (ACTRTN)[FUNCLIST] =
	    FDTAB_SETACT (ACTRTN, FUNCLIST)
	    %QUOTE %,

	FDTAB_BLDACT (ACTRTN, FUNCLIST)[] = 
	    FDTAB_DOFUNCLIST (ACTRTN, %REMOVE (FUNCLIST))
	    %IF %LENGTH GTR 2 %THEN
		, FDTAB_BLDACT (%REMAINING)
	    %ELSE
		FDTAB_SETDEF (FDTAB_INDEX)
	    %FI %QUOTE %;

    COMPILETIME
	FDTAB_INDEX = 0,
	FDTAB_BUFLO = 0,
	FDTAB_BUFHI = 0,
	FDTAB_FUNCLO = 0,
	FDTAB_FUNCHI = 0,
	FDTAB_BUF_O = $BYTEOFFSET (fdt$q_buffered),
	FDTAB_ACT_O = $BYTEOFFSET (fdt$ps_func_rtn);

    %IF NOT %DECLARED (exe$illiofunc) %THEN
	EXTERNAL ROUTINE	exe$illiofunc;
    %FI

    PSECT
	NODEFAULT = PSECT_NAME (PIC, READ, WRITE, NOEXECUTE, ALIGN (5));

    GLOBAL FDT_NAME : PSECT (PSECT_NAME) BLOCK [fdt$k_length, BYTE]
	PRESET (
		FDTAB_BLDBFM (%REMOVE (FDT_BUF)),
		FDTAB_BLDACT (%REMOVE (FDT_ACT))) %;

!++
! Define FDT completion routine macros
!--
MACRO

    call_abortio (irp, pcb, ucb, status) =
	exe_std$abortio (irp, pcb, ucb, status) %,

    call_finishio (irp, ucb, iost1, iost2) =
	BEGIN
	    %IF NOT %NULL (iost1) %THEN
		BIND
		    _irp = irp : ref block [irp$k_length, byte];
	        _irp[ irp$l_iost1 ] = iost1;
	        _irp[ irp$l_iost2 ] = iost2;
	    %FI
            exe_std$finishio (irp, ucb)
	END %,

    call_finishioc (irp, ucb, iost1) =
	call_finishio (irp, ucb, iost1, 0) %,

    call_iorsnwait (irp, pcb, ucb, ccb, status, resource) =
	exe_stdiorsnwait (irp, pcb, ucb, ccb, status, resource)%,

    call_qioacppkt (irp, pcb, ucb) =
	exe_std$qioacppkt (irp, pcb, ucb) %,

    call_qiodrvpkt (irp, ucb) =
	BEGIN
 	    BIND
		_irp = irp : ref block [irp$k_length, byte];
	    _irp[ irp$ps_fdt_context ] = 0;
	    exe_std$insioq (irp, ucb);
	    SS$_FDT_COMPL
	END %;

!
! Macros to lock/unlock SMP SPINLOCKS
!
! Version:	'X-9'
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1986, 1987, 1988, 1990, 1992 BY			    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:	System Library
!
! ABSTRACT:
!
!	These macros are used to generate SMP locking code.
!
! ENVIRONMENT:
!
!	Native mode VAX processor; no operating system facilities are used.
!
!--
!
!
! AUTHOR:  Rod Gamache,		 CREATION DATE:  13-Jan-1986
!
! MODIFIED BY:
!
!	X-9	JRK361		Jim Kauffman		25-Aug-1992
!		Modify $READ_SYSTIME to eliminate HWCLK spinlock acquisition
!		and to call the SYSTEM_PRIMITIVES routine
!
!	X-8	KLN1150		Karen L. Noel		17-Jan-1992
!		Remove mutex part of $sys_lock and $sys_unlock macros.
!
!	X-7	JRK361		Jim Kauffman		13-Jan-1992
!		Restore LOCKIPL qualifier to DEVICELOCK macro
!
!	X-6	JRK361		Jim Kauffman		15-Nov-1991
!		Promote spinlock structure offsets
!
!	X-5	JRK361		Jim Kauffman		1-Jul-1991
!		Restore inline checks for SMP support for performance
!		Correct DEVICELOCK location for IPL
!
!	X-4	ROW0760		Ralph O. Weber		21-MAY-1991 12:02
!		Add END statements to $FORKLOCK, $FORKUNLOCK, and
!		$DEVICEUNLOCK that were incorrectly removed in ROW0753.
!		Change MTX$W_WRT to MTX$W_OWNCNT.  There is no MTX$W_WRT.
!		Change comparisons of MXT$W_WRT with -1 to comparisons of
!		MXT$W_OWNCNT.  MXT$W_OWNCNT is not a sign extended field.
!
!	X-3	ROW0757		Ralph O. Weber		16-MAY-1991 16:58
!		MUTEX is not spelled MUXTEX.
!
!	X-2	ROW0753		Ralph O. Weber		14-MAY-1991 13:34
!		Update TIMEDWAIT usage to the Alpha/VMS forms.
!		Make all macros suitable for usage from Bliss-64, so that
!		this file can be included in LIB.L64.  Delete $GET_CURPCB.
!		It does not apply on Alpha.  Eliminage in-line testing of
!		SMP$V_ENABLED.  Remove FIPL testing in the fork locking
!		macros.
!
!	---------- Ident numbering change due to master pack reorg ---------
!
!	X-17K7	MAS		Mary A. Sullivan	 7-Feb-1991
!		Add "PAL_" to PALcode builtins.
!
!	X-17K6	RS00071		Richard Sayde		31-Jan-1991
!		MTPR_IPL builtin takes IPL value, not address. Update all
!		calls to the builtin.
!
!	X-17K5	RWC020		Richard W. Critz, Jr.	19-Dec-1990
!		Fix $DSBINT and $ENBINT to pass new IPL by value rather
!		than by reference.
!
!	x-17K4	DB0011		Dave Burkey		13-Sept-1990
!		Conditionalize MTPR_IPL use for EVAX to make compatible with
!		MTPR_IPL macro which disallows use of %REF.
!
! 	X-16K4  RS00022		Richard Sayde		 2-Aug-1990
!		Add a dummy format to the $FIND_CPU_MACRO so that the ()'s
!		in the macro calls are not interpreted as a procedure call.
!
!	X-16K3	RS00020		Richard Sayde		 1-Aug-1990
!		$FIND_CPU_DATA macro was not returning a value because of a
!		semicolon at the end of the PAL call. Also, changed the
!		macro to use the BUILTIN MFPR_PRBR instead of he generic
!		PAL call.
!
!	X-16K2	KLN1013		Karen L. Noel		21-May-1990
!		Partially port to Alpha.  I make no promises.
!
!	X-15,16	EMB		Ellen M. Batbouta	19-Jul-1989
!		Try again to fix $SYS_LOCK.
!
!	X-14	EMB0419		Ellen M. Batbouta	17-Jul-1989
!		Fix several of the SMP macros.  In the $FORKUNLOCK and
!		$FORKLOCK macros, FKB$B_FLCK was misspelled.  In the 
!		$SYS_UNLOCK macro, the mutex count in the per-CPU database 
!		was being incremented instead of decremented when releasing 
!		the mutex with read access.  In the $SYS_LOCK macro, an extra 
!		SETIPL is being done on the SMP enabled path.
!		
!
!	X-13	EMB0381		Ellen M. Batbouta	09-Jan-1989
!		Remove extra SETIPL from KEYWORDMACRO $SYS_LOCK.
!
!	X-12	JDC0408		Jon Callas		13-SEP-1988
!		Change references to BUG_CHECK. Not only is there no BUG_CHECK, 
!		but it really should be $BUG_CHECK. A $BUG_CHECK has been
!		added to LIB via VMS-MACROS.REQ with this.
!
!	X-11	RNG5011		Rod N. Gamache		21-Dec-1987
!		Fix BLISS macros to use $FIND_CPU_DATA call.
!		Fix $FORKUNLOCK to check if FIPL or FLCK.
!
!	X-10	RNG5010		Rod N. Gamache		11-Sep-1987
!		Add separate non-keyword macros for SYS_LOCK, SYS_UNLOCK,
!		FORKLOCK and FORKUNLOCK.
!
!	X-9	BAS5009		Barry A Scott		4-Sep-1987
!		Completely re-write most of the BLISS macros.
!
!	X-8	RNG5008		Rod N. Gamache		12-Aug-1987
!		Change refs from SMP$C_xxx to SPL$C_xxx.
!
!	X-7	WCT0047		Ward C. Travis		19-Mar-1987
!		Create  macros  for  Bliss   system  page  lockdown
!		requests.
!
!	X-6	WCT0023		Ward C. Travis		27-Jan-1987
!		Merge  in  changes   by  RNG  to   activate  SAVIPL
!		parameter in SYS_LOCK macros.
!
!	X-5	WCT0021		Ward C. Travis		21-Jan-1987
!		Changes made in  WCT0015 updated.  LOCK  and UNLOCK
!		now have the names SYS_LOCK and SYS_UNLOCK.
!
!	X-4	WCT0015		Ward C. Travis		14-Jan-1987
!		Bugfix to X-3;  renaming  SMPLOCK to  LOCK caused a
!		name conflict with the first parameter to FORKLOCK.
!
!	X-3	WCT0015		Ward C. Travis		 7-Jan-1987
!		Update outdated  SMPLOCK, SMPUNLOCK  definitions to
!		LOCK, UNLOCK for SMP.
!
!**


!
! The KEYWORD SMP MACROS:
!

KEYWORDMACRO
	$DSBINT( NEWIPL, DST, ENVIRON=MULTIPROCESSOR ) =
		BEGIN
		BUILTIN
			PAL_MFPR_IPL, PAL_MTPR_IPL;
		LOCAL
			$$IPL_VAL;
		%IF NOT %NULL( DST )
		%THEN
			DST = PAL_MFPR_IPL();
		%ELSE
			%ERROR('DST parameter is mandatory')
		%FI
		%IF NOT %NULL( NEWIPL )
		%THEN
			$$IPL_VAL = NEWIPL;
			PAL_MTPR_IPL( .$$IPL_VAL );
			%IF NOT %IDENTICAL( %STRING( ENVIRON ), %STRING( UNIPROCESSOR ) )
			%THEN
				%IF NOT %CTCE( NEWIPL ) OR (%CTCE( NEWIPL ) AND NEWIPL GTR IPL$_ASTDEL)
				%THEN
					%WARN('Raising IPL to ',NEWIPL,' provides no multiprocessing synchronization')
				%FI
			%FI
		%ELSE
			$$IPL_VAL = IPL$_POWER;
			PAL_MTPR_IPL( .$$IPL_VAL );
			%IF NOT %IDENTICAL( %STRING( ENVIRON ), %STRING( UNIPROCESSOR ) )
			%THEN
				%WARN('Raising IPL to 31 provides no multiprocessing synchronization')
			%FI
		%FI
		END
	%;

KEYWORDMACRO
	$ENBINT( SRC ) =
		BEGIN
		BUILTIN
			PAL_MTPR_IPL;
		LOCAL
			$$IPL_VAL;
		%IF %NULL( SRC )
		%THEN
			%ERROR('SRC parameter is mandatory')
		%ELSE
			$$IPL_VAL = SRC;
			PAL_MTPR_IPL( .$$IPL_VAL );
		%FI
		END
	%;

KEYWORDMACRO
	$SYS_LOCK( LOCKNAME, LOCKIPL, SAVIPL, CONDITION ) =
	BEGIN
	BUILTIN
		PAL_MTPR_IPL,
		PAL_MFPR_IPL;
	EXTERNAL
		SMP$GL_FLAGS		: BLOCK[4,BYTE] ADDRESSING_MODE( GENERAL ),
		SMP$AR_SPNLKVEC		: REF VECTOR[ , LONG] ADDRESSING_MODE( GENERAL );

	LINKAGE
		SMP_ROUTINE = JSB ( REGISTER = 0 ) : NOTUSED (1,2,3,4,5,6,7,8,9,10,11);
	EXTERNAL ROUTINE
		SMP$ACQUIRE		: SMP_ROUTINE ADDRESSING_MODE( GENERAL ),
		SMP$ACQNOIPL		: SMP_ROUTINE ADDRESSING_MODE( GENERAL );
	LOCAL
		$$SAVED_IPL;

	%IF NOT %NULL( LOCKNAME )
	%THEN

	   %IF NOT %NULL( SAVIPL )
	   %THEN
		SAVIPL = PAL_MFPR_IPL();
	   %FI

	   %IF  %IDENTICAL( %STRING( CONDITION ), %STRING( NOSETIPL ) )
	   %THEN
	      IF .SMP$GL_FLAGS[ SMP$V_ENABLED ]
	      THEN
		SMP$ACQNOIPL( .SMP$AR_SPNLKVEC[ %NAME( SPL$C_, LOCKNAME ) ] );
	   %ELSE
	      IF .SMP$GL_FLAGS[ SMP$V_ENABLED ]
	      THEN
		SMP$ACQUIRE( %NAME( SPL$C_, LOCKNAME ) )
	      ELSE
	        $SETIPL( NEWIPL = %NAME( IPL$_, LOCKNAME ), ENVIRON=UNIPROCESSOR );
	   %FI

	%FI
	END
	%;


KEYWORDMACRO
	$SYS_UNLOCK( LOCKNAME, NEWIPL, CONDITION ) =
	BEGIN
	LITERAL
		MTPR_TBIA = 27;
	BUILTIN
		CALL_PAL,
		PAL_MTPR_IPL;
	EXTERNAL
		SMP$GL_FLAGS		: ADDRESSING_MODE( GENERAL ) BLOCK [ 4, BYTE ];
	LINKAGE
		SMP_ROUTINE = JSB ( REGISTER = 0 ) : NOTUSED (1,2,3,4,5,6,7,8,9,10,11);
	EXTERNAL ROUTINE
		SMP$RELEASE		: SMP_ROUTINE ADDRESSING_MODE( GENERAL ),
		SMP$RESTORE		: SMP_ROUTINE ADDRESSING_MODE( GENERAL );
	LOCAL
		$$SAVED_IPL,
		$$IPL_VAL;

	%IF NOT %NULL( LOCKNAME )
	%THEN

	   IF .SMP$GL_FLAGS[ SMP$V_ENABLED ]
	   THEN
		BEGIN
		%IF NOT %NULL( CONDITION )
		%THEN
			%IF %IDENTICAL( %STRING( CONDITION ), %STRING( RESTORE ) )
			%THEN
				SMP$RESTORE( %NAME( SPL$C_, LOCKNAME ) );
			%ELSE
				%ERROR( 'Bad argument value - condition' )
			%FI
		%ELSE
			SMP$RELEASE( %NAME( SPL$C_, LOCKNAME ) );
		%FI
		END;
	   %IF NOT %NULL( NEWIPL )
	   %THEN
		$$IPL_VAL = NEWIPL;
		PAL_MTPR_IPL( .$$IPL_VAL );
	   %FI
	%FI
	END
	%;

KEYWORDMACRO
	$FIND_CPU_DATA (DUMMY) =
		BEGIN
		  BUILTIN PAL_MFPR_PRBR;

		  PAL_MFPR_PRBR ()
		END
	%;


KEYWORDMACRO
	!
	! LOCK FORK SPINLOCK
	!
	$FORKLOCK
	(
	LOCK = .UCB[ FKB$B_FLCK], 
	LOCKIPL, 
	SAVIPL, 
	PRESERVE = YES,
	FIPL = NO
	)
		=
	BEGIN
	!
	! LINKAGES:
	!
	LINKAGE
		SMP_ROUTINE = JSB ( REGISTER = 0 ) : NOTUSED (1,2,3,4,5,6,7,8,9,10,11);
	EXTERNAL ROUTINE
		SMP$ACQUIRE	: SMP_ROUTINE NOVALUE ADDRESSING_MODE (GENERAL);
	EXTERNAL
		SMP$GL_FLAGS	: ADDRESSING_MODE( GENERAL ) BLOCK [ 4, BYTE ],
		SMP$AL_IPLVEC	: ADDRESSING_MODE( GENERAL ) VECTOR [ , LONG ];
	BUILTIN
		PAL_MFPR_IPL;

	%IF NOT %NULL( SAVIPL )
	%THEN
		SAVIPL = PAL_MFPR_IPL();
	%FI

	IF .SMP$GL_FLAGS[ SMP$V_ENABLED ] 
	THEN
		SMP$ACQUIRE( LOCK )
	ELSE
		$SETIPL ( NEWIPL = .SMP$AL_IPLVEC[ LOCK ], ENVIRON = UNIPROCESSOR );
	END
	% ;

!
! UNLOCK FORK SPINLOCK
!
KEYWORDMACRO
	$FORKUNLOCK
	(
	LOCK = .UCB[ FKB$B_FLCK], 
	NEWIPL, 
	CONDITION, 
	PRESERVE = YES
	)
		=
	BEGIN
	!
	! LINKAGES:
	!
	LINKAGE
		SMP_ROUTINE = JSB ( REGISTER = 0 ) : NOTUSED (1,2,3,4,5,6,7,8,9,10,11);
	EXTERNAL ROUTINE
		SMP$RESTORE : SMP_ROUTINE NOVALUE ADDRESSING_MODE (GENERAL),
		SMP$RELEASE : SMP_ROUTINE NOVALUE ADDRESSING_MODE (GENERAL);
	EXTERNAL
		SMP$GL_FLAGS	 : BLOCK [ 4, BYTE ] ADDRESSING_MODE( GENERAL );
	BUILTIN
		PAL_MTPR_IPL;
	LOCAL
		$$IPL_VAL;

	IF .SMP$GL_FLAGS[ SMP$V_ENABLED ] 
	THEN
	   %IF %IDENTICAL ( %STRING( CONDITION ), %STRING( RESTORE ) )
	   %THEN
		SMP$RESTORE ( LOCK );
	   %ELSE
		SMP$RELEASE ( LOCK );
	   %FI	

	%IF NOT %NULL( NEWIPL )
	%THEN
		$$IPL_VAL = NEWIPL;
		PAL_MTPR_IPL( .$$IPL_VAL );
	%FI
	END
	% ;


KEYWORDMACRO
	$DEVICELOCK
	(
	LOCKADDR = .UCB[ UCB$L_DLCK ], 
	LOCKIPL, 
	SAVIPL, 
	CONDITION, 
	PRESERVE = YES
	)
		=
	BEGIN
	!
	! LINKAGES:
	!
	LINKAGE
		SMP_ROUTINE = JSB ( REGISTER = 0 ) : NOTUSED (1,2,3,4,5,6,7,8,9,10,11);
	EXTERNAL ROUTINE
		SMP$ACQUIREL	: SMP_ROUTINE NOVALUE ADDRESSING_MODE (GENERAL),
		SMP$ACQNOIPL	: SMP_ROUTINE NOVALUE ADDRESSING_MODE (GENERAL);
	EXTERNAL
		SMP$GL_FLAGS	: ADDRESSING_MODE( GENERAL ) BLOCK [ 4, BYTE ];
	LOCAL
		$$$SPINLOCK	: REF BLOCK [, BYTE ];
	BUILTIN
		PAL_MFPR_IPL;

	$$$SPINLOCK = LOCKADDR;

	%IF NOT %NULL( SAVIPL )
	%THEN
		SAVIPL = PAL_MFPR_IPL();
	%FI

	IF .SMP$GL_FLAGS[ SMP$V_ENABLED ] 
	THEN
	   %IF %IDENTICAL (%STRING( CONDITION ), %STRING( NOSETIPL ))
	   %THEN
		SMP$ACQNOIPL( .$$$SPINLOCK );
	   %ELSE
		SMP$ACQUIREL( .$$$SPINLOCK );
	   %FI

	%IF NOT %IDENTICAL( %STRING( CONDITION ), %STRING( NOSETIPL ) )
	%THEN
		IF NOT .SMP$GL_FLAGS[ SMP$V_ENABLED ] 
		THEN
		   %IF NOT %NULL( LOCKIPL )
		   %THEN
			$SETIPL( NEWIPL = LOCKIPL, ENVIRON = UNIPROCESSOR );
		   %ELSE
			$SETIPL( NEWIPL = .$$$SPINLOCK[ SPL$L_IPL ], ENVIRON = UNIPROCESSOR );
		   %FI
	%FI
	END
	%;

!
! UNLOCK DEVICE SPINLOCK
!
KEYWORDMACRO
	$DEVICEUNLOCK
	(
	LOCKADDR = .UCB[ UCB$L_DLCK ],
	NEWIPL, 
	CONDITION, 
	PRESERVE = YES
	)
		=
	BEGIN
	!
	! LINKAGES:
	!
	LINKAGE
		SMP_ROUTINE = JSB(  REGISTER = 0 ) : NOTUSED( 1,2,3,4,5,6,7,8,9,10,11);
	EXTERNAL ROUTINE
		SMP$RESTOREL	: SMP_ROUTINE NOVALUE ADDRESSING_MODE( GENERAL),
		SMP$RELEASEL	: SMP_ROUTINE NOVALUE ADDRESSING_MODE( GENERAL);
	EXTERNAL
		SMP$GL_FLAGS	: BLOCK[ 4, BYTE ] ADDRESSING_MODE( GENERAL );
	BUILTIN
		PAL_MTPR_IPL;
	LOCAL
		$$IPL_VAL;

	IF .SMP$GL_FLAGS[ SMP$V_ENABLED ] 
	THEN
	   %IF %IDENTICAL(  %STRING( CONDITION ), %STRING( RESTORE ) )
	   %THEN
		SMP$RESTOREL( LOCKADDR );
	   %ELSE
		SMP$RELEASEL( LOCKADDR );
	   %FI	

	%IF NOT %NULL( NEWIPL )
	%THEN
		$$IPL_VAL = NEWIPL;
		PAL_MTPR_IPL( .$$IPL_VAL );
	%FI
	END
	%;

KEYWORDMACRO
	$READ_SYSTIME( DST ) =
	BEGIN

	EXTERNAL ROUTINE
		EXE$GET_SYSTIME;

	EXE$GET_SYSTIME(DST);

	END
	%;

KEYWORDMACRO
	$SETIPL( NEWIPL, ENVIRON=MULTIPROCESSOR ) =
		BEGIN
		BUILTIN
			PAL_MTPR_IPL;
		LOCAL
			$$IPL_VAL;

		%IF NOT %NULL( NEWIPL )
		%THEN
			$$IPL_VAL = NEWIPL;
			PAL_MTPR_IPL( .$$IPL_VAL );
			%IF NOT %IDENTICAL( %STRING( ENVIRON ), %STRING( UNIPROCESSOR ) )
			%THEN
				%IF NOT %CTCE( NEWIPL ) OR (%CTCE( NEWIPL ) AND NEWIPL GTR IPL$_ASTDEL)
				%THEN
					%WARN('Raising IPL to ',NEWIPL,' provides no multiprocessing synchronization')
				%FI
			%FI
		%ELSE
			$$IPL_VAL=IPL$_POWER;
			PAL_MTPR_IPL( .$$IPL_VAL );
			%IF NOT %IDENTICAL( %STRING( ENVIRON ), %STRING( UNIPROCESSOR ) )
			%THEN
				%WARN( 'Raising ipl to newipl provides no multiprocessing synchronization' )
			%FI
		%FI
		END
	%;

KEYWORDMACRO
    $LOCK_SYSTEM_PAGES ( LSP_START, LSP_END, NEWIPL ) =
        BEGIN

	LINKAGE
	    MMG_LOCK_SYSTEM_PAGES_CALL = JSB (REGISTER = 0, REGISTER = 1) :
					      NOTUSED (2,3,4,5,6,7,8,9,10,11);
			    
        EXTERNAL ROUTINE
	    MMG$LOCK_SYSTEM_PAGES_CALL	: MMG_LOCK_SYSTEM_PAGES_CALL
				    	  ADDRESSING_MODE (GENERAL)
				  	  NOVALUE;
	BUILTIN
	    PAL_MTPR_IPL;
	LOCAL
		$$IPL_VAL;
	
	MMG$LOCK_SYSTEM_PAGES_CALL (LSP_START, LSP_END);

	%IF NOT %NULL (NEWIPL)
	%THEN
	      $$IPL_VAL = NEWIPL;
	      PAL_MTPR_IPL (.$$IPL_VAL);
	%FI
    END %;

KEYWORDMACRO
    $UNLOCK_SYSTEM_PAGES ( LSP_START, LSP_END, NEWIPL ) =
	BEGIN
	
	LINKAGE
	    MMG_UNLOCK_SYSTEM_PAGES_CALL = JSB (REGISTER = 0, REGISTER = 1) :
						NOTUSED (2,3,4,5,6,7,8,9,10,11);

        EXTERNAL ROUTINE
	    MMG$UNLOCK_SYSTEM_PAGES_CALL: MMG_UNLOCK_SYSTEM_PAGES_CALL
					  ADDRESSING_MODE (GENERAL)
					  NOVALUE;
	BUILTIN
	    PAL_MTPR_IPL;
	LOCAL
		$$IPL_VAL;

	MMG$UNLOCK_SYSTEM_PAGES_CALL (LSP_START, LSP_END);
	
	%IF NOT %NULL (NEWIPL)
	%THEN
	      $$IPL_VAL=NEWIPL;
	      PAL_MTPR_IPL (.$$IPL_VAL);
	%FI
    END %;

!
! The simple SMP MACROS:
!

MACRO
    !
    ! Lock SYSTEM SPINLOCK
    !
    SYS_LOCK (LOCKNAME, LOCKIPL, SAVIPL, CONDITION) =
	BEGIN
	!
	! LINKAGES:
	!
	LINKAGE
	    SMP_ACQUIRE = JSB ( REGISTER = 0 ) :
			NOTUSED (1,2,3,4,5,6,7,8,9,10,11)
	    ;

	EXTERNAL ROUTINE
	    SMP$ACQUIRE : SMP_ACQUIRE NOVALUE ADDRESSING_MODE (GENERAL)
	    ;

	BUILTIN
	    PAL_MFPR_IPL
	;

	%IF NOT %NULL(SAVIPL)
	%THEN
	    %REF(SAVIPL) = PAL_MFPR_IPL ();
	%FI

	SMP$ACQUIRE (%NAME('SPL$C_', LOCKNAME))
	END % ;

MACRO
    !
    ! Unlock SYSTEM SPINLOCK
    !
    SYS_UNLOCK (LOCKNAME, NEWIPL, CONDITION) =
	BEGIN
	!
	! LINKAGES:
	!

	LINKAGE
	    SMP_RESTORE = JSB ( REGISTER = 0 ) :
			NOTUSED (1,2,3,4,5,6,7,8,9,10,11),
	    SMP_RELEASE = JSB ( REGISTER = 0 ) :
			NOTUSED (1,2,3,4,5,6,7,8,9,10,11)
	    ;

	EXTERNAL ROUTINE
	    SMP$RESTORE : SMP_RESTORE NOVALUE ADDRESSING_MODE (GENERAL),
	    SMP$RELEASE : SMP_RELEASE NOVALUE ADDRESSING_MODE (GENERAL)
	    ;

	BUILTIN
	    PAL_MTPR_IPL
	    ;
	LOCAL
		$$IPL_VAL;

	%IF %IDENTICAL (CONDITION,'RESTORE')
	%THEN
	    SMP$RESTORE (%NAME('SPL$C_', LOCKNAME));
	%ELSE
	    SMP$RELEASE (%NAME('SPL$C_', LOCKNAME));
	%FI

	%IF NOT %NULL(NEWIPL)
	%THEN
	      $$IPL_VAL=NEWIPL;
	      PAL_MTPR_IPL (.$$IPL_VAL)
	%FI

	END % ;

MACRO
    !
    ! Lock FORK SPINLOCK
    !
    FORKLOCK (LOCKID, LOCKIPL, SAVIPL, CONDITION) =
	BEGIN
	!
	! LINKAGES:
	!
	LINKAGE
	    SMP_ACQUIRE = JSB ( REGISTER = 0 ) :
			NOTUSED (1,2,3,4,5,6,7,8,9,10,11)
	    ;

	EXTERNAL ROUTINE
	    SMP$ACQUIRE : SMP_ACQUIRE NOVALUE ADDRESSING_MODE (GENERAL)
	    ;

	SMP$ACQUIRE (LOCKID)
	END % ;

MACRO
    !
    ! Unlock SYSTEM SPINLOCK
    !
    FORKUNLOCK (LOCKID, NEWIPL, CONDITION) =
	BEGIN
	!
	! LINKAGES:
	!

	LINKAGE
	    SMP_RESTORE = JSB ( REGISTER = 0 ) :
			NOTUSED (1,2,3,4,5,6,7,8,9,10,11),
	    SMP_RELEASE = JSB ( REGISTER = 0 ) :
			NOTUSED (1,2,3,4,5,6,7,8,9,10,11)
	    ;

	EXTERNAL ROUTINE
	    SMP$RESTORE : SMP_RESTORE NOVALUE ADDRESSING_MODE (GENERAL),
	    SMP$RELEASE : SMP_RELEASE NOVALUE ADDRESSING_MODE (GENERAL)
	    ;

	BUILTIN
	    PAL_MTPR_IPL
	    ;
	LOCAL
		$$IPL_VAL;

	%IF %IDENTICAL (CONDITION,'RESTORE')
	%THEN
	    SMP$RESTORE (LOCKID);
	%ELSE
	    SMP$RELEASE (LOCKID);
	%FI

	%IF NOT %NULL(NEWIPL)
	%THEN
	      $$IPL_VAL=NEWIPL;
	      PAL_MTPR_IPL (.$$IPL_VAL)
	%FI

	END % ;

!Version:	X-2
!
! COPYRIGHT (c) 1990 BY
! DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
! ALL RIGHTS RESERVED.
!
! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
! ONLY  IN  ACCORDANCE  OF  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
! INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
! COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
! OTHER PERSON.  NO TITLE TO AND  OWNERSHIP OF THE  SOFTWARE IS  HEREBY
! TRANSFERRED.
!
! THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
! AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
! CORPORATION.
!
! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.

!++
! FACILITY:
! 
!   VMSLIB -- BIGPAGE_MACROS_LIB.REQ
! 
! ABSTRACT:
! 
!	The macros defined in this file are used by privileged applications
!	to provide commonality in varying page size implementations.
! 
! AUTHORS:
! 
!   Robert F. Hoffman
! 
! CREATION DATE: 20 June 1990
! 
! MODIFICATION HISTORY:
!
!	X-2	Robert F. Hoffman	RFH002		23-Apr-1991
!		Fix conditionalization on VAXPAGE/BIGPAGE
!
!	X-1	Robert F. Hoffman	RFH001		20-Jun-1990
!		Create module.
!--


KEYWORDMACRO
	$EXTRACT_VPN	(VA, VPN, VA_SPACE=SYSTEM, INDEPENDENT=NO)=
!
!	VA - source virtual address
!	VPN - destination for VPN
!	VA_SPACE - SYSTEM, P0, or P1, masks appropriate high bits
!	INDEPENDENT - if YES, always do page-size independent code, even
!		on a VAX
!	Extracts a VPN from a virtual address
!
	%IF	%IDENTICAL(INDEPENDENT,YES)
	%THEN
		%IF	%NULL(vpn)
		%THEN
			%IF	%IDENTICAL(VA_SPACE,SYSTEM)
			%THEN
					va = (.va AND (NOT VA$M_SYSTEM)) ^ .MMG$GL_VA_TO_VPN;
			%ELSE
				%IF	%IDENTICAL(VA_SPACE,P1) OR
					%IDENTICAL(VA_SPACE,PROCESS)
				%THEN
					va = (.va AND (NOT VA$M_P1)) ^ .MMG$GL_VA_TO_VPN;
				%ELSE   !%IDENTICAL(VA_SPACE,P1)
					va = .va ^ .MMG$GL_VA_TO_VPN;
				%FI
			%FI
		%ELSE  	!%NULL(vpn)
			%IF	%IDENTICAL(VA_SPACE,SYSTEM)
			%THEN
					vpn = (.va AND (NOT VA$M_SYSTEM)) ^ .MMG$GL_VA_TO_VPN;
			%ELSE	!%IDENTICAL(VA_SPACE,SYSTEM)
				%IF	%IDENTICAL(VA_SPACE,P1) OR
					%IDENTICAL(VA_SPACE,PROCESS)
				%THEN
					vpn = (.va AND (NOT VA$M_P1)) ^ .MMG$GL_VA_TO_VPN;
				%ELSE    !%IDENTICAL(VA_SPACE,P1)
					vpn = .va ^ .MMG$GL_VA_TO_VPN;
				%FI	!%IDENTICAL(VA_SPACE,P1)
			%FI	!%IDENTICAL(VA_SPACE,SYSTEM)
		%FI   !%NULL(vpn)
	%ELSE	!%IDENTICAL(INDEPENDENT,YES)
		BEGIN
		%IF	VAXPAGE
		%THEN
			%IF	%NULL(vpn)
			%THEN
				%IF	%IDENTICAL(VA_SPACE,SYSTEM)
				%THEN
					va = (.va AND (NOT VA$M_SYSTEM)) ^ -VA$V_VPN;
				%ELSE
					%IF	%IDENTICAL(VA_SPACE,P1) OR
					%IDENTICAL(VA_SPACE,PROCESS)
					%THEN
					va = (.va AND (NOT VA$M_P1)) ^ -VA$V_VPN;
					%ELSE
					va = .va ^ -VA$V_VPN;
					%FI
				%FI
			%ELSE	!%NULL(vpn)
				%IF	%IDENTICAL(VA_SPACE,SYSTEM)
				%THEN
					vpn = (.va AND (NOT VA$M_SYSTEM)) ^ -VA$V_VPN;
				%ELSE	!%IDENTICAL(VA_SPACE,SYSTEM)
					%IF	%IDENTICAL(VA_SPACE,P1) OR
					%IDENTICAL(VA_SPACE,PROCESS)
					%THEN
					vpn = (.va AND (NOT VA$M_P1)) ^ -VA$V_VPN;
					%ELSE	!%IDENTICAL(VA_SPACE,P1)
					vpn = .va ^ -VA$V_VPN;
					%FI	!%IDENTICAL(VA_SPACE,P1)
				%FI	!%IDENTICAL(VA_SPACE,SYSTEM)
			%FI	!%NULL(vpn)
		%FI	!VAXPAGE
		%IF	BIGPAGE
		%THEN
			%IF	%NULL(vpn)
			%THEN
				%IF	%IDENTICAL(VA_SPACE,SYSTEM)
				%THEN
					va = (.va AND (NOT VA$M_SYSTEM)) ^ .MMG$GL_VA_TO_VPN;
				%ELSE
					%IF	%IDENTICAL(VA_SPACE,P1) OR
					%IDENTICAL(VA_SPACE,PROCESS)
					%THEN
					va = (.va AND (NOT VA$M_P1)) ^ .MMG$GL_VA_TO_VPN;
					%ELSE
					va = .va ^ .MMG$GL_VA_TO_VPN;
					%FI
				%FI
			%ELSE	!%NULL(vpn)
				%IF	%IDENTICAL(VA_SPACE,SYSTEM)
				%THEN
					vpn = (.va AND (NOT VA$M_SYSTEM)) ^ .MMG$GL_VA_TO_VPN;
				%ELSE	!%IDENTICAL(VA_SPACE,SYSTEM)
					%IF	%IDENTICAL(VA_SPACE,P1) OR
					%IDENTICAL(VA_SPACE,PROCESS)
					%THEN
					vpn = (.va AND (NOT VA$M_P1)) ^ .MMG$GL_VA_TO_VPN;
					%ELSE	!%IDENTICAL(VA_SPACE,P1)
					vpn = .va ^ .MMG$GL_VA_TO_VPN;
					%FI	!%IDENTICAL(VA_SPACE,P1)
				%FI	!%IDENTICAL(VA_SPACE,SYSTEM)
			%FI	!%NULL(vpn)
		%FI	!BIGPAGE
		END
	%FI	!%IDENTICAL(independent)

	%;

KEYWORDMACRO
	$EXTRACT_PTE_OFFSET	(VA, PTE_OFFSET, VA_SPACE=SYSTEM, INDEPENDENT=NO)=
!
!	VA - source virtual address
!	PTE_OFFSET - destination for PTE_OFFSET
!	VA_SPACE - SYSTEM, P0, or P1, masks appropriate high bits
!	INDEPENDENT - if YES, always do page-size independent code, even
!		on a VAX
!	Converts a virtual address into an offset into a Page Table.
!
	%IF	%IDENTICAL(independent,YES)
	%THEN
		%IF	%NULL(PTE_offset)
		%THEN
			%IF	%IDENTICAL(va_space,SYSTEM)
			%THEN
					va = (.va AND (NOT VA$M_SYSTEM)) ^ .MMG$GL_VA_TO_PTE_OFFSET;
			%ELSE
				%IF	%IDENTICAL(va_space,P1) OR
					%IDENTICAL(VA_SPACE,PROCESS)
				%THEN
					va = (.va AND (NOT VA$M_P1)) ^ .MMG$GL_VA_TO_PTE_OFFSET;
				%ELSE
					va = .va ^ .MMG$GL_VA_TO_PTE_OFFSET;
				%FI
			%FI
		%ELSE	!%NULL(PTE_offset)
			%IF	%IDENTICAL(va_space,SYSTEM)
			%THEN
					PTE_offset = (.va AND (NOT VA$M_SYSTEM)) ^ .MMG$GL_VA_TO_PTE_OFFSET;
			%ELSE
				%IF	%IDENTICAL(va_space,P1) OR
					%IDENTICAL(VA_SPACE,PROCESS)
				%THEN
					va = (.va AND (NOT VA$M_P1)) ^ .MMG$GL_VA_TO_PTE_OFFSET;
				%ELSE	!%IDENTICAL(va_space,P1)
					va = .va ^ .MMG$GL_VA_TO_PTE_OFFSET;
				%FI	!%IDENTICAL(va_space,P1)
			%FI	!%IDENTICAL(va_space,SYSTEM)
		%FI	!%NULL(PTE_offset)
	%ELSE	!%IDENTICAL(independent)
		BEGIN
		%IF	VAXPAGE
		%THEN
			%IF	%NULL(PTE_offset)
			%THEN
				%IF	%IDENTICAL(va_space,SYSTEM)
				%THEN
					va = (.va AND (NOT VA$M_SYSTEM)) ^ -(VA$V_VPN-2);
				%ELSE
					%IF	%IDENTICAL(va_space,P1) OR
					%IDENTICAL(VA_SPACE,PROCESS)
					%THEN
					va = (.va AND (NOT VA$M_P1)) ^ -(VA$V_VPN-2);
					%ELSE
					va = .va ^ -(VA$V_VPN-2);
					%FI
				%FI
			%ELSE	!%NULL(PTE_offset)
				%IF	%IDENTICAL(va_space,SYSTEM)
				%THEN
					PTE_offset = (.va AND (NOT VA$M_SYSTEM)) ^ -(VA$V_VPN-2);
				%ELSE	!%IDENTICAL(va_space,SYSTEM)
					%IF	%IDENTICAL(va_space,P1) OR
					%IDENTICAL(VA_SPACE,PROCESS)
					%THEN
					PTE_offset = (.va AND (NOT VA$M_P1)) ^ -(VA$V_VPN-2);
					%ELSE	!%IDENTICAL(va_space,P1)
					PTE_offset = .va ^ -(VA$V_VPN-2);
					%FI	!%IDENTICAL(va_space,P1)
				%FI	!%IDENTICAL(va_space,SYSTEM)
			%FI	!%NULL(PTE_offset)
		%FI	!VAXPAGE
		%IF	BIGPAGE
		%THEN
			%IF	%NULL(PTE_offset)
			%THEN
				%IF	%IDENTICAL(va_space,SYSTEM)
				%THEN
					va = (.va AND (NOT VA$M_SYSTEM)) ^ .MMG$GL_VA_TO_PTE_OFFSET;
				%ELSE
					%IF	%IDENTICAL(va_space,P1) OR
					%IDENTICAL(VA_SPACE,PROCESS)
					%THEN
					va = (.va AND (NOT VA$M_P1)) ^ .MMG$GL_VA_TO_PTE_OFFSET;
					%ELSE
					va = .va ^ .MMG$GL_VA_TO_PTE_OFFSET;
					%FI
				%FI
			%ELSE	!%NULL(PTE_offset)
				%IF	%IDENTICAL(va_space,SYSTEM)
				%THEN
					PTE_offset = (.va AND (NOT VA$M_SYSTEM)) ^ .MMG$GL_VA_TO_PTE_OFFSET;
				%ELSE	!%IDENTICAL(va_space,SYSTEM)
					%IF	%IDENTICAL(va_space,P1) OR
					%IDENTICAL(VA_SPACE,PROCESS)
					%THEN
					PTE_offset = (.va AND (NOT VA$M_P1)) ^ .MMG$GL_VA_TO_PTE_OFFSET;
					%ELSE	!%IDENTICAL(va_space,P1)
					PTE_offset = .va ^ .MMG$GL_VA_TO_PTE_OFFSET;
					%FI	!%IDENTICAL(va_space,P1)
				%FI	!%IDENTICAL(va_space,SYSTEM)
			%FI	!%NULL(PTE_offset)
		%FI	!BIGPAGE
		END
	%FI	!%IDENTICAL(independent)

	%;

KEYWORDMACRO
	$MAKE_VA	(VPN, VA, VA_SPACE=SYSTEM, INDEPENDENT=NO)=
!
!	VPN - source Virtual Page Number
!	VA - destination Virtual Address
!	VA_SPACE - SYSTEM, P0, or P1, sets appropriate high bits
!	INDEPENDENT - if YES, always do page-size independent code, even
!		on a VAX
!	Converts a VPN to the virtual address of the first byte in that
!		page.
!
	%IF	%IDENTICAL(independent,YES)
	%THEN
		%IF	%NULL(va)
		%THEN
			%IF	%IDENTICAL(va_space,SYSTEM)
			%THEN
					vpn = (.vpn ^ .MMG$GL_VPN_TO_VA) OR VA$M_SYSTEM;
			%ELSE
				%IF	%IDENTICAL(va_space,P1)
				%THEN
					vpn = (.vpn ^ .MMG$GL_VPN_TO_VA) OR VA$M_P1;
				%ELSE
					vpn = .vpn ^ .MMG$GL_VPN_TO_VA;
				%FI
			%FI
		%ELSE    !%NULL(va)
			%IF	%IDENTICAL(va_space,SYSTEM)
			%THEN
					va = (.vpn ^ .MMG$GL_VPN_TO_VA) OR VA$M_SYSTEM;
			%ELSE
				%IF	%IDENTICAL(va_space,P1)
				%THEN
					va = (.vpn ^ .MMG$GL_VPN_TO_VA) OR VA$M_P1;
				%ELSE
					va = .vpn ^ .MMG$GL_VPN_TO_VA;
				%FI
			%FI
		%FI	!%NULL(va)
	%ELSE	!%IDENTICAL(independent)
		BEGIN
		%IF	VAXPAGE
		%THEN
			%IF	%NULL(va)
			%THEN
				%IF	%IDENTICAL(va_space,SYSTEM)
				%THEN
					vpn = (.vpn ^ VA$V_VPN) OR VA$M_SYSTEM;
				%ELSE
					%IF	%IDENTICAL(va_space,P1)
					%THEN
					vpn = (.vpn ^ VA$V_VPN) OR VA$M_P1;
					%ELSE
					vpn = .vpn ^ VA$V_VPN;
					%FI
				%FI
			%ELSE	!%NULL(va)
				%IF	%IDENTICAL(va_space,SYSTEM)
				%THEN
					va = (.vpn ^ VA$V_VPN) OR VA$M_SYSTEM;
				%ELSE
					%IF	%IDENTICAL(va_space,P1)
					%THEN
					va = (.vpn ^ VA$V_VPN) OR VA$M_P1;
					%ELSE
					va = .vpn ^ VA$V_VPN;
					%FI
				%FI
			%FI	!%NULL(va)
		%FI	!VAXPAGE
		%IF	BIGPAGE
		%THEN
			%IF	%NULL(va)
			%THEN
				%IF	%IDENTICAL(va_space,SYSTEM)
				%THEN
					vpn = (.vpn ^ .MMG$GL_VPN_TO_VA) OR VA$M_SYSTEM;
				%ELSE
					%IF	%IDENTICAL(va_space,P1)
					%THEN
					vpn = (.vpn ^ .MMG$GL_VPN_TO_VA) OR VA$M_P1;
					%ELSE
					vpn = .vpn ^ .MMG$GL_VPN_TO_VA;
					%FI
				%FI
			%ELSE    !%NULL(va)
				%IF	%IDENTICAL(va_space,SYSTEM)
				%THEN
					va = (.vpn ^ .MMG$GL_VPN_TO_VA) OR VA$M_SYSTEM;
				%ELSE
					%IF	%IDENTICAL(va_space,P1)
					%THEN
					va = (.vpn ^ .MMG$GL_VPN_TO_VA) OR VA$M_P1;
					%ELSE
					va = .vpn ^ .MMG$GL_VPN_TO_VA;
					%FI
				%FI
			%FI   !%NULL(va)
		%FI	!BIGPAGE
		END
	%FI	!%IDENTICAL(independent)

	%;
! 
! ****************************************************************************
! *                                                                          *
! *  Copyright (c) 1995                                                      *
! *  by DIGITAL Equipment Corporation, Maynard, Mass.                        *
! *                                                                          *
! *  This software is furnished under a license and may be used and  copied  *
! *  only  in  accordance  with  the  terms  of  such  license and with the  *
! *  inclusion of the above copyright notice.  This software or  any  other  *
! *  copies  thereof may not be provided or otherwise made available to any  *
! *  other person.  No title to and ownership of  the  software  is  hereby  *
! *  transferred.                                                            *
! *                                                                          *
! *  The information in this software is subject to change  without  notice  *
! *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment  *
! *  Corporation.                                                            *
! *                                                                          *
! *  DIGITAL assumes no responsibility for the use or  reliability  of  its  *
! *  software on equipment which is not supplied by DIGITAL.                 *
! *                                                                          *
! ****************************************************************************
! ********************************************************************************************************************************
!  Created:  4-MAY-1995 18:57:14 by OpenVMS SDL EV1-36     
!  Source:   4-MAY-1995 18:55:08 $64$DUA3210:[LIB.SRC]SYSDEF.SDL;1 
! ********************************************************************************************************************************
 
!*** MODULE $ACMDEF ***
! +
!  ACMDEF - ACCOUNTING MANAGER DEFINITIONS
! -
literal ACM$S_ACMDEF = 2;               !  Old size name, synonym
literal ACM$S_ACM = 2;
macro ACM$V_PROCESS = 0,0,1,0 %;        !  PROCESS ACCOUNTING ENABLED 
macro ACM$V_IMAGE = 0,1,1,0 %;          !  IMAGE ACCOUNTING ENABLED 
macro ACM$V_INTERACTIVE = 0,2,1,0 %;    !  INTERACTIVE ACCOUNTING ENABLED 
macro ACM$V_LOGFAIL = 0,3,1,0 %;        !  LOGIN FAILURE ACCOUNTING ENABLED 
macro ACM$V_SUBPROCESS = 0,4,1,0 %;     !  SUBPROCESS ACCOUNTING ENABLED 
macro ACM$V_DETACHED = 0,5,1,0 %;       !  DETACHED PROCESS ACCOUNTING ENABLED 
macro ACM$V_BATCH = 0,6,1,0 %;          !  BATCH ACCOUNTING ENABLED 
macro ACM$V_NETWORK = 0,7,1,0 %;        !  NETWORK PROCESS ACCOUNTING ENABLED 
macro ACM$V_PRINT = 0,8,1,0 %;          !  PRINT JOB ACCOUNTING ENABLED 
macro ACM$V_USER_DATA = 0,9,1,0 %;      !  USER_DATA ACCOUNTING ENABLED 
macro ACM$V_ACM_FUNC = 0,10,1,0 %;      !  ACM FUNCTION ACCOUNTING ENABLED 
macro ACM$V_SYS_FUNC = 0,11,1,0 %;      !  SYSTEM FUNCTION ACCOUNTING ENABLED 
macro ACM$V_CCAENAB = 0,12,1,0 %;       !  CHARGE CODE ACCOUNTING ENABLED 
macro ACM$V_CCVENAB = 0,13,1,0 %;       !  CHARGE CODE VALIDATION ENABLED 
literal ACM$S_ACMHDR = 68;
macro ACM$W_TYPE = 0,0,16,0 %;          !  MESSAGE TYPE 
macro ACM$W_MAILBOX = 2,0,16,0 %;       !  MAILBOX UNIT NUMBER 
macro ACM$Q_PRVMSK = 4,0,0,0 %;
literal ACM$S_PRVMSK = 8;               !  PROCESS PRIVILEGE MASK 
macro ACM$L_UIC = 12,0,32,0 %;          !  PROCESS UIC
macro ACM$W_MEM = 12,0,16,0 %;          !  MEMBER UIC 
macro ACM$W_GRP = 14,0,16,0 %;          !  GROUP UIC 
macro ACM$L_ARB_ADDRESS = 4,0,32,1 %;   !  ADDRESS OF CLONED ARB
macro ACM$T_USERNAME = 16,0,0,0 %;
literal ACM$S_USERNAME = 12;            !  USERNAME 
macro ACM$T_ACCOUNT = 28,0,0,0 %;
literal ACM$S_ACCOUNT = 8;              !  ACCOUNT NAME 
macro ACM$B_PROCPRI = 36,0,8,0 %;       !  PROCESS BASE PRIORITY 
macro ACM$B_RMOD = 37,0,8,0 %;          !  REQUESTOR'S ACCESS MODE
macro ACM$L_PID = 40,0,32,0 %;          !  PROCESS ID 
macro ACM$L_STS = 44,0,32,0 %;          !  PROCESS STATUS 
macro ACM$L_OWNER = 48,0,32,0 %;        !  OWNER PROCESS ID (0 => NONE) 
macro ACM$T_TERMINAL = 52,0,0,0 %;
literal ACM$S_TERMINAL = 8;             !  TERMINAL NAME (COUNTED ASCII STRING) 
macro ACM$Q_SYSTIME = 60,0,0,0 %;
literal ACM$S_SYSTIME = 8;              !  CURRENT SYSTEM TIME 
literal ACM$S_ACMDEF1 = 76;             !  Old size name - synonym
literal ACM$S_ACM1 = 76;
macro ACM$W_MSGSTS = -8,0,16,0 %;       !  MSG STATUS IN MAILBOX IOSB (JOBCTL SPECIFIC) 
macro ACM$W_MSGLEN = -6,0,16,0 %;       !  MSG LENGTH IN MAILBOX IOSB (JOBCTL SPECIFIC) 
macro ACM$L_PROCID = -4,0,32,0 %;       !  PROCESS ID IN MAILBOX IOSB (JOBCTL SPECIFIC) 
! 
!  SEND TO ACCOUNTING MANAGER FIELDS
! 
literal ACM$S_ACMDEF2 = 326;            !  Old size name - synonym
literal ACM$S_ACM2 = 326;
macro ACM$W_USERREQ = 68,0,16,0 %;      !  USER REQUEST TYPE 
macro ACM$T_DATA = 70,0,0,0 %;
literal ACM$S_DATA = 256;               !  USER DATA 
! 
!  PROCESS/IMAGE DELETE/PURGE FIELDS
! 
literal ACM$K_PROCLEN = 132;            !  MIN. PROCESS/IMAGE TERMINATION MESSAGE LENGTH 
literal ACM$C_PROCLEN = 132;            !  MIN. PROCESS/IMAGE TERMINATION MESSAGE LENGTH 
literal ACM$S_ACMDEF3 = 148;            !  Old size name - synonym
literal ACM$S_ACM3 = 148;
macro ACM$Q_LOGIN = 68,0,0,0 %;
literal ACM$S_LOGIN = 8;                !  PROCESS/IMAGE START TIME 
macro ACM$L_FINALSTS = 76,0,32,0 %;     !  PROCESS FINAL STATUS 
macro ACM$L_IMGCNT = 80,0,32,0 %;       !  IMAGE EXECUTION COUNT 
macro ACM$L_CPUTIME = 84,0,32,0 %;      !  CPU USAGE 
macro ACM$L_PAGEFLTS = 88,0,32,0 %;     !  PAGEFAULT COUNT 
macro ACM$L_PGFLTIO = 92,0,32,0 %;      !  PAGEFAULT I/O 
macro ACM$L_WSPEAK = 96,0,32,0 %;       !  WORKING SET PEAK 
macro ACM$L_PGFLPEAK = 100,0,32,0 %;    !  PAGE FILE PEAK 
macro ACM$L_DIOCNT = 104,0,32,0 %;      !  DIRECT I/O COUNT 
macro ACM$L_BIOCNT = 108,0,32,0 %;      !  BUFFERED I/O COUNT 
macro ACM$L_VOLUMES = 112,0,32,0 %;     !  VOLUME MOUNT COUNT 
macro ACM$L_VP_CPUTIME = 116,0,32,0 %;  !  VECTOR CPU TIME
macro ACM$W_NODEADDR = 120,0,16,0 %;    !  MESSAGE OFFSET TO REMOTE NODE ADDRESS 
macro ACM$W_NODENAME = 122,0,16,0 %;    !  MESSAGE OFFSET TO REMOTE NODE NAME 
macro ACM$W_REMOTEID = 124,0,16,0 %;    !  MESSAGE OFFSET TO REMOTE ID 
macro ACM$W_IMAGENAME = 126,0,16,0 %;   !  MESSAGE OFFSET TO IMAGE NAME 
macro ACM$W_FULLADDR = 128,0,16,0 %;    !  MESSAGE OFFSET to remote PhaseV address
macro ACM$W_FULLNAME = 130,0,16,0 %;    !  MESSAGE OFFSET to remote Fullname
macro ACM$L_QMGRS_USED = 132,0,0,1 %;
literal ACM$S_QMGRS_USED = 16;          !  BITMAP OF QUEUE MANAGERS ACCESSED BY PROCESS
! 
!  SNDJBC MESSAGE FIELDS
! 
literal ACM$S_SNDJBCDEF = 90;
literal ACM$S_ACMDEF4 = 90;             !  Old size name - synonym
literal ACM$S_ACM4 = 90;
macro ACM$L_IMAGECNT = 68,0,32,0 %;     !  IMAGE COUNT FOR PROCESS
macro ACM$L_EFN = 72,0,32,0 %;          !  COMPLETION EVENT FLAG
macro ACM$L_IOSB = 76,0,32,1 %;         !  COMPLETION IOSB ADDRESS
macro ACM$L_ASTADR = 80,0,32,1 %;       !  COMPLETION AST ADRESS
macro ACM$L_ASTPRM = 84,0,32,0 %;       !  COMPLETION AST PARAMETER
macro ACM$W_FUNC = 88,0,16,0 %;         !  SNDJBC/GETQUI FUNCTION CODE
macro ACM$T_ITMLST = 90,0,0,0 %;        !  START OF ITEMLIST DATA
 
!*** MODULE $ACBDEF ***
! +
!  AST CONTROL BLOCK DEFINITIONS
! 
!  AST CONTROL BLOCKS EXIST AS SEPARATE STRUCTURES AND AS SUBSTRUCTURES
!  WITHIN LARGER CONTROL BLOCKS SUCH AS I/O REQUEST PACKETS AND TIMER
!  QUEUE ENTRIES.
! 
! -
literal ACB$M_POSIX_ACB = %X'8';
literal ACB$M_PKAST = %X'10';
literal ACB$M_NODELETE = %X'20';
literal ACB$M_QUOTA = %X'40';
literal ACB$M_KAST = %X'80';
literal ACB$S_ACB = 36;
macro ACB$L_ASTQFL = 0,0,32,1 %;        ! AST QUEUE FORWARD LINK 
macro ACB$L_ASTQBL = 4,0,32,1 %;        ! AST QUEUE BACKWARD LINK 
macro ACB$W_SIZE = 8,0,16,0 %;          ! STRUCTURE SIZE IN BYTES 
macro ACB$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE CODE 
macro ACB$B_RMOD = 11,0,8,0 %;          ! REQUEST ACCESS MODE 
macro ACB$V_MODE = 11,0,2,0 %;
literal ACB$S_MODE = 2;                 ! MODE FOR FINAL DELIVERY 
macro ACB$V_POSIX_ACB = 11,3,1,0 %;     ! USED FOR DELIVERING SIGNALS/EVENTS
macro ACB$V_PKAST = 11,4,1,0 %;         ! PIGGY BACK SPECIAL KERNEL AST 
macro ACB$V_NODELETE = 11,5,1,0 %;      ! DON'T DELETE ACB ON DELIVERY 
macro ACB$V_QUOTA = 11,6,1,0 %;         ! ACCOUNT FOR QUOTA 
macro ACB$V_KAST = 11,7,1,0 %;          ! SPECIAL KERNEL AST 
macro ACB$L_PID = 12,0,32,0 %;          ! PROCESS ID OF REQUEST 
macro ACB$L_AST = 16,0,32,1 %;          ! AST ROUTINE ADDRESS 
macro ACB$L_ASTPRM = 20,0,32,0 %;       ! AST PARAMETER 
macro ACB$L_KAST = 32,0,32,1 %;         ! INTERNAL KERNEL MODE XFER ADDRESS 
literal ACB$K_LENGTH = 36;              !  Length of block. 
literal ACB$C_LENGTH = 36;              !  Length of block. 
literal ACB$S_ACBDEF = 36;              !  Old size name, synonym for ACB$S_ACB
 
!*** MODULE $ADPDEF ***
! +
!  ADAPTER CONTROL BLOCK DEFINITIONS
! 
!  There is one ADP for each adapter on the system, where an adapter
!  is defined as an interconnect between two busses or a multichannel
!  device.  ADPs are now arranged in a hierarchical structure reflecting
!  the physical topology of the system and I/O buses.  A special system ADP 
!  is placed at the root of the tree to represent a "virtual adapter"
!  to the system bus.  ADPs now contain a pointer to an array of 
!  information for each node on the remote bus to which the adapter 
!  connects.  For example, the ADP for an XMI to BI adapter points to 
!  a 16-entry array for the 16 node BI bus.  Each array entry contains 
!  several items including a hardware ID field, the base address of 
!  the node's CSR space, pointer(s) to data structure(s), a node 
!  number, and a bus-specific field.
! 
!  The ADP sometimes contains a pointer to a bus command table, which contains
!  bit patterns representing commands on the target bus.  These bit patterns
!  are copied to the command field in the hardware mailbox for remote I/O
!  bus register access on SRM-mailbox machines.
! -
literal ADP$M_INDIRECT_VECTOR = %X'1';
literal ADP$M_ONLINE = %X'2';
literal ADP$M_BOOT_ADP = %X'4';
literal ADP$M_PCI_PCI_BRIDGE = %X'8';
literal ADP$M_SHUTDOWN = %X'1';
literal ADP$M_PORTONLY = %X'2';
literal ADP$M_STRUCT_ALLOCATED = %X'4';
literal ADP$S_ADP = 272;
macro ADP$Q_CSR = 0,0,0,1 %;
literal ADP$S_CSR = 8;                  !  Adapter control and status register
macro ADP$W_SIZE = 8,0,16,0 %;          !  Structure size in bytes 
macro ADP$B_TYPE = 10,0,8,0 %;          !  Structure type code 
macro ADP$B_NUMBER = 11,0,8,0 %;        !  Ordinal adapter number 
macro ADP$L_LINK = 12,0,32,1 %;         !  Address of next adapter control block 
macro ADP$L_TR = 16,0,32,0 %;           !  Configuration TR number 
macro ADP$L_ADPTYPE = 20,0,32,0 %;      !  Software adapter type 
macro ADP$PS_NODE_DATA = 24,0,32,1 %;   !  Address of adapter specific node data routine
macro ADP$L_VECTOR = 28,0,32,1 %;       !  Address of vector jump table 
macro ADP$L_CRB = 32,0,32,1 %;          !  Address of channel request block
macro ADP$PS_MBPR = 36,0,32,1 %;        !  Address of mailbox pointer register
macro ADP$Q_QUEUE_TIME = 40,0,0,0 %;
literal ADP$S_QUEUE_TIME = 8;           !  Timeout value for mailbox queueing operation
macro ADP$Q_WAIT_TIME = 48,0,0,0 %;
literal ADP$S_WAIT_TIME = 8;            !  Timeout value for mailbox completion (DON bit set)
macro ADP$PS_PARENT_ADP = 56,0,32,1 %;  !  Address of parent ADP (0 if this is the root ADP)
macro ADP$PS_PEER_ADP = 60,0,32,1 %;    !  Address of next ADP in peer list
macro ADP$PS_CHILD_ADP = 64,0,32,1 %;   !  Address of first child ADP
macro ADP$L_PROBE_CMD = 68,0,32,0 %;    !  Command index used for probing bus
macro ADP$PS_BUS_ARRAY = 72,0,32,1 %;   !  Address of bus array
macro ADP$PS_COMMAND_TBL = 76,0,32,1 %; !  Address of bus specific command table
macro ADP$PS_SPINLOCK = 80,0,32,1 %;    !  Address of spinlock structure
!  For a bus-to-bus adapter, the node_num is the node number of the adapter
!  on the primary bus.  The sec_node_num is the node number of the adapter
!  on the remote bus.  Whether these fields are used or not depends on how
!  the bus and adapter hardware are designed.  Examples:  for xmi, the lamb
!  xmi node number is stored in sec_node_num.  For the other XMI
!  adapters, the xmi node number is stored in node_num and sec_node_num is
!  not used.
macro ADP$W_NODE_NUM = 84,0,16,0 %;
macro ADP$W_PRIM_NODE_NUM = 84,0,16,0 %; !  Primary node number
macro ADP$W_SEC_NODE_NUM = 86,0,16,0 %; !  Secondary node number
macro ADP$B_HOSE_NUM = 90,0,8,0 %;      !  I/O adapter hose number
macro ADP$PS_ADP_SPECIFIC2 = 92,0,32,1 %;
macro ADP$L_ADP_SPECIFIC2 = 92,0,32,0 %;
macro ADP$L_A32_FREE_ITEMS = 92,0,32,0 %; !  Fbus specific usage
macro ADP$PS_ADP_SPECIFIC3 = 96,0,32,1 %;
macro ADP$L_ADP_SPECIFIC3 = 96,0,32,0 %;
macro ADP$L_A64_ITEM_NUM = 96,0,32,0 %; !  Fbus specific usage
macro ADP$L_CRAB = 100,0,32,1 %;        !  Address of map register control block
macro ADP$L_ADAPTER_FLAGS = 104,0,32,0 %;
macro ADP$V_INDIRECT_VECTOR = 104,0,1,0 %; !  Indirect vectored interrupts
macro ADP$V_ONLINE = 104,1,1,0 %;       !  Adapter is online
macro ADP$V_BOOT_ADP = 104,2,1,0 %;     !  Adapter is boot adapter
macro ADP$V_PCI_PCI_BRIDGE = 104,3,1,0 %; !  Adapter represents a PCI/PCI bridge
macro ADP$L_RESERVED1 = 108,0,32,0 %;   !  Reserved for future expansion
macro ADP$L_RESERVED2 = 112,0,32,0 %;   !  Reserved for future expansion
macro ADP$L_RESERVED3 = 116,0,32,0 %;   !  Reserved for future expansion
macro ADP$L_RESERVED4 = 120,0,32,0 %;   !  Reserved for future expansion
macro ADP$PS_NODE_FUNCTION = 124,0,32,1 %; !  Address of adapter-specific node function routine
macro ADP$L_VPORTSTS = 128,0,32,0 %;    !  CI - Vax port status bits
macro ADP$V_SHUTDOWN = 128,0,1,0 %;     !  CI - adapter microcode is stopped
macro ADP$V_PORTONLY = 128,1,1,0 %;     !  CI - port restart only -- no adapter restart
macro ADP$V_STRUCT_ALLOCATED = 128,2,1,0 %; !  CI/SCSI - adapter-wide structures allocated
macro ADP$L_AVECTOR = 132,0,32,1 %;     !  Addr of 1ST SCB vector for this adaptor
macro ADP$Q_SCRATCH_BUF_PA = 136,0,0,0 %;
literal ADP$S_SCRATCH_BUF_PA = 8;
macro ADP$PS_SCRATCH_BUF_VA = 144,0,32,1 %; !  VA, PA, and length of a physically
macro ADP$L_SCRATCH_BUF_LEN = 148,0,32,0 %; !  contiguous memory block
macro ADP$L_LSDUMP = 152,0,32,1 %;      !  Address of physical contiguous
!  memory for the adapter memory dump.
macro ADP$PS_PROBE_CSR = 156,0,32,1 %;  !  Address of adapter-specific probe CSR routine
macro ADP$PS_PROBE_CSR_CLEANUP = 160,0,32,1 %; !  Address of adapter-specific probe CSR cleanup routine
macro ADP$PS_LOAD_MAP_REG = 164,0,32,1 %; !  Address of adapter-specific load map register routine
macro ADP$PS_SHUTDOWN = 168,0,32,1 %;   !  Address of adapter-specific shutdown routine
macro ADP$PS_CONFIG_TABLE = 172,0,32,1 %; !  Pointer to autoconfiguration table
macro ADP$PS_MAP_REG_BASE = 176,0,32,1 %; !  Base virtual address of adapter map registers
macro ADP$PS_ADP_SPECIFIC = 180,0,32,1 %; !  ADP specific cell
macro ADP$PS_ADP_SPECIFIC1 = 180,0,32,1 %;
macro ADP$L_ADP_SPECIFIC1 = 180,0,32,0 %;
macro ADP$L_A32_ITEM_NUM = 180,0,32,0 %; !  Fbus specific usage
macro ADP$PS_ABLK = 180,0,32,1 %;       !  PNDRIVER specific usage
macro ADP$PS_DISABLE_INTERRUPTS = 184,0,32,1 %; !  Address of adapter-specific disable interrupts routine
macro ADP$PS_STARTUP = 188,0,32,1 %;    !  Address of adapter-specific startup routine
macro ADP$PS_INIT = 192,0,32,1 %;       !  Address of adapter-specific initialization routine
macro ADP$PS_ADP_SPECIFIC4 = 196,0,32,1 %;
macro ADP$L_ADP_SPECIFIC4 = 196,0,32,0 %;
macro ADP$L_A64_FREE_ITEMS = 196,0,32,0 %; !  Fbus specific usage
macro ADP$Q_HARDWARE_TYPE = 200,0,0,1 %;
literal ADP$S_HARDWARE_TYPE = 8;        !  Saved hardware device type and revision
macro ADP$Q_HARDWARE_REV = 208,0,0,1 %;
literal ADP$S_HARDWARE_REV = 8;         !  info. Interpretation in adapter-specific.
macro ADP$PS_CRAM_CMD = 216,0,32,1 %;   !  Address of adapter-specific cram init routine
macro ADP$PS_READ_PCI_CONFIG = 220,0,32,1 %; !  Address of adapter-specific read pci config routine
macro ADP$PS_WRITE_PCI_CONFIG = 224,0,32,1 %; !  Address of adapter-specific write pci config routine
macro ADP$PS_MAP_IO = 228,0,32,1 %;     !  Address of adapter-specific I/O space mapping routine
macro ADP$PS_READ_IO = 232,0,32,1 %;    !  Address of adapter-specific read I/O space routine
macro ADP$PS_WRITE_IO = 236,0,32,1 %;   !  Address of adapter-specific write I/O space routine
macro ADP$PS_IOHANDLE_FLINK = 240,0,32,1 %; !  Pointer to IOHANDLE structures associated with this bus
macro ADP$PS_IOHANDLE_BLINK = 244,0,32,1 %; !  Pointer to IOHANDLE structures associated with this bus
!  Make sure that INTD has quadword alignment
macro ADP$L_INTD = 248,0,0,0 %;
literal ADP$S_INTD = 16;                !  Interrupt transfer vector 
macro ADP$L_BUS_NUM = 264,0,32,0 %;     !  Bus number.  Used for systems with remote PCI 
!  buses for Type1 config space address generation.
macro ADP$L_PCI_NODE_NUM = 268,0,32,0 %; !  PCI node number of PCI/PCI bridge adapter
literal ADP$K_CIADPLEN = 272;           !  Length of ADP for CI 
literal ADP$C_CIADPLEN = 272;           !  Length of ADP for CI 
literal ADP$K_NIADPLEN = 272;           !  Length of ADP for NI
literal ADP$C_NIADPLEN = 272;           !  Length of ADP for NI
literal ADP$K_GBIADPLEN = 272;          !  Length of ADP for Generic BI device
literal ADP$C_GBIADPLEN = 272;          !  Length of ADP for Generic BI device
literal ADP$K_MINADPLEN = 272;          !  Length of smallest available ADP
literal ADP$C_MINADPLEN = 272;          !  Length of smallest available ADP
literal ADP$S_ADPDEF = 272;             !  Old ADP size field for compatiblity
 
!*** MODULE $AIBDEF ***
! +
!  FORMAT OF ACP I/O BUFFER PACKET. THIS PACKET CONTAINS ALL THE DATA
!  TRANSMITTED FROM THE USER TO THE ACP AND BACK FOR AN ACP FUNCTION.
!  NOTE THAT THE DESCRIPTORS IN THE PACKET ARE TREATED BY BLISS CODE
!  AS A BLOCKVECTOR.
! -
literal AIB$K_LENGTH = 12;              !  LENGTH OF PACKET HEADER 
literal AIB$C_LENGTH = 12;              !  LENGTH OF PACKET HEADER 
literal AIB$S_AIBDEF = 12;              !  OLD SIZE NAME, SYNONYM FOR AIB$S_AIB
literal AIB$S_AIB = 12;
macro AIB$L_DESCRIPT = 0,0,32,1 %;      !  ADDRESS OF START OF DESCRIPTORS 
macro AIB$W_SIZE = 8,0,16,0 %;          !  SIZE OF PACKET 
macro AIB$B_TYPE = 10,0,8,0 %;          !  PACKET TYPE CODE 
 
!*** MODULE $ABDDEF ***
literal ABD$K_LENGTH = 8;               !  SIZE OF DESCRIPTOR 
literal ABD$C_LENGTH = 8;               !  SIZE OF DESCRIPTOR 
literal ABD$S_ABDDEF = 8;               !  OLD SIZE NAME, SYNONYM FOR ABD$S_ABD
literal ABD$C_WINDOW = 0;               !  DESCRIPTOR FOR WINDOW ADDRESS 
literal ABD$C_FIB = 1;                  !  DESCRIPTOR FOR FIB 
literal ABD$C_NAME = 2;                 !  DESCRIPTOR FOR NAME STRING 
literal ABD$C_RESL = 3;                 !  DESCRIPTOR FOR RESULT LENGTH 
literal ABD$C_RES = 4;                  !  DESCRIPTOR FOR RESULT STRING 
literal ABD$C_ATTRIB = 5;               !  FIRST ATTRIBUTE DESCRIPTOR 
literal ABD$S_ABD = 8;
macro ABD$W_TEXT = 0,0,16,0 %;          !  WORD OFFSET TO DATA TEXT 
macro ABD$W_COUNT = 2,0,16,0 %;         !  BYTE COUNT OF TEXT 
macro ABD$L_USERVA = 4,0,32,1 %;        !  USER VIRTUAL ADDRESS OF TEXT 
 
!*** MODULE $ALFDEF ***
! +
! 
!  $ALFDEF - structure for auto-login file.
! 
! -
literal ALF$C_LENGTH = 128;
literal ALF$K_LENGTH = 128;
literal ALF$S_ALFDEF = 128;
literal ALF$S_ALF = 128;
macro ALF$T_DEVNAME = 0,0,0,0 %;
literal ALF$S_DEVNAME = 63;             !  Terminal device name
macro ALF$T_USERNAME = 63,0,0,0 %;
literal ALF$S_USERNAME = 32;            !  Associated username
 
!*** MODULE $APECSDEF ***
literal APECS$Q_D21071CA_BASE = -2147483648;
literal APECS$Q_D21071CA_BASE_H = 1;
literal APECS$Q_D21071DA_BASE = -1610612736;
literal APECS$Q_D21071DA_BASE_H = 1;
literal APECS$Q_PCI_SCS = -1342177280;
literal APECS$Q_PCI_SCS_H = 1;
literal APECS$Q_PCI_SPARSE_IO = -1073741824;
literal APECS$Q_PCI_SPARSE_IO_H = 1;
literal APECS$Q_PCI_CONFIG = -536870912;
literal APECS$Q_PCI_CONFIG_H = 1;
literal APECS$Q_PCI_SPARSE_MEM = 0;
literal APECS$Q_PCI_SPARSE_MEM_H = 2;
literal APECS$Q_PCI_DENSE_MEM = 0;
literal APECS$Q_PCI_DENSE_MEM_H = 3;
literal APECS_PCI_NODE_COUNT = 13;
literal APECS$K_MEMORY_BANKS = 9;
literal APECS$M_TBASE1_32_10 = %X'FFFFFE00';
literal APECS$M_TBASE2_32_10 = %X'FFFFFE00';
literal APECS$M_PCIBASE1_SG_EN = %X'40000';
literal APECS$M_PCIBASE1_WEN = %X'80000';
literal APECS$M_PCIBASE2_SG_EN = %X'40000';
literal APECS$M_PCIBASE2_WEN = %X'80000';
literal APECS$M_PCIMASK1_31_20 = %X'FFF00000';
literal APECS$M_PCIMASK2_31_20 = %X'FFF00000';
literal APECS$M_HAXR1_PCI_31_27 = %X'F8000000';
literal APECS$M_HAXR2_PCI_1_0 = %X'3';
literal APECS$M_HAXR2_PCI_31_24 = %X'FF000000';
literal APECS$M_PMLC = %X'FF';
literal APECS$K_LENGTH = 16384;
literal APECS$S_APECS = 16384;
macro APECS$L_GCSR = 0,0,32,1 %;
macro APECS$R_BANKSET_BASES = 2048,0,0,0 %;
literal APECS$S_BANKSET_BASES = 512;
macro APECS$R_BANKSET_BASE = 2048,0,0,0 %;
literal APECS$S_BANKSET_BASE = 288;
macro APECS$W_BASE_CSR = 2048,0,16,1 %;
macro APECS$w_fill_base = 2050,0,0,1 %;
literal APECS$s_fill_base = 30;
macro APECS$b_fill_base_array = 2336,0,0,1 %;
literal APECS$s_fill_base_array = 224;
macro APECS$R_BANKSET_CONFIGS = 2560,0,0,0 %;
literal APECS$S_BANKSET_CONFIGS = 512;
macro APECS$R_BANKSET_CONFIG = 2560,0,0,0 %;
literal APECS$S_BANKSET_CONFIG = 288;
macro APECS$R_BANKSET_CONFIG_REG = 2560,0,16,0 %;
literal APECS$S_BANKSET_CONFIG_REG = 2;
macro APECS$W_CONFIG_CSR = 2560,0,16,1 %;
macro APECS$R_BITS = 2560,0,8,0 %;
literal APECS$S_BITS = 1;
macro APECS$V_VALID = 2560,0,1,0 %;
macro APECS$R_BANKSET_timing_aS = 3072,0,0,0 %;
literal APECS$S_BANKSET_timing_aS = 512;
macro APECS$R_BANKSET_timing_a = 3072,0,0,0 %;
literal APECS$S_BANKSET_timing_a = 288;
macro APECS$W_TIMING_A_CSR = 3072,0,16,1 %;
macro APECS$R_BANKSET_timing_bS = 3584,0,0,0 %;
literal APECS$S_BANKSET_timing_bS = 512;
macro APECS$R_BANKSET_timing_b = 3584,0,0,0 %;
literal APECS$S_BANKSET_timing_b = 288;
macro APECS$W_TIMING_B_CSR = 3584,0,16,1 %;
macro APECS$L_DCSR = 8192,0,32,1 %;
macro APECS$L_PEAR = 8224,0,32,1 %;
macro APECS$L_SEAR = 8256,0,32,1 %;
macro APECS$L_DR1 = 8288,0,32,1 %;
macro APECS$L_DR2 = 8320,0,32,1 %;
macro APECS$L_DR3 = 8352,0,32,1 %;
macro APECS$L_TBASE1 = 8384,0,32,1 %;
macro APECS$V_TBASE1_32_10 = 8384,9,23,0 %;
literal APECS$S_TBASE1_32_10 = 23;
macro APECS$L_TBASE2 = 8416,0,32,1 %;
macro APECS$V_TBASE2_32_10 = 8416,9,23,0 %;
literal APECS$S_TBASE2_32_10 = 23;
macro APECS$L_PCIBASE1 = 8448,0,32,1 %;
macro APECS$V_PCIBASE1_SG_EN = 8448,18,1,0 %;
macro APECS$V_PCIBASE1_WEN = 8448,19,1,0 %;
macro APECS$L_PCIBASE2 = 8480,0,32,1 %;
macro APECS$V_PCIBASE2_SG_EN = 8480,18,1,0 %;
macro APECS$V_PCIBASE2_WEN = 8480,19,1,0 %;
macro APECS$L_PCIMASK1 = 8512,0,32,1 %;
macro APECS$V_PCIMASK1_31_20 = 8512,20,12,0 %;
literal APECS$S_PCIMASK1_31_20 = 12;
macro APECS$L_PCIMASK2 = 8544,0,32,1 %;
macro APECS$V_PCIMASK2_31_20 = 8544,20,12,0 %;
literal APECS$S_PCIMASK2_31_20 = 12;
macro APECS$L_HAXR0 = 8576,0,32,1 %;
macro APECS$L_HAXR1 = 8608,0,32,1 %;
macro APECS$V_HAXR1_PCI_31_27 = 8608,27,5,0 %;
literal APECS$S_HAXR1_PCI_31_27 = 5;
macro APECS$L_HAXR2 = 8640,0,32,1 %;
macro APECS$V_HAXR2_PCI_1_0 = 8640,0,2,0 %;
literal APECS$S_HAXR2_PCI_1_0 = 2;
macro APECS$V_HAXR2_PCI_31_24 = 8640,24,8,0 %;
literal APECS$S_HAXR2_PCI_31_24 = 8;
macro APECS$L_PMLT = 8672,0,32,1 %;
macro APECS$V_PMLC = 8672,0,8,0 %;
literal APECS$S_PMLC = 8;
macro APECS$L_TLB_TAG0 = 8704,0,32,1 %;
macro APECS$L_TLB_TAG1 = 8736,0,32,1 %;
macro APECS$L_TLB_TAG2 = 8768,0,32,1 %;
macro APECS$L_TLB_TAG3 = 8800,0,32,1 %;
macro APECS$L_TLB_TAG4 = 8832,0,32,1 %;
macro APECS$L_TLB_TAG5 = 8864,0,32,1 %;
macro APECS$L_TLB_TAG6 = 8896,0,32,1 %;
macro APECS$L_TLB_TAG7 = 8928,0,32,1 %;
macro APECS$L_TLB_DATA0 = 8960,0,32,1 %;
macro APECS$L_TLB_DATA1 = 8992,0,32,1 %;
macro APECS$L_TLB_DATA2 = 9024,0,32,1 %;
macro APECS$L_TLB_DATA3 = 9056,0,32,1 %;
macro APECS$L_TLB_DATA4 = 9088,0,32,1 %;
macro APECS$L_TLB_DATA5 = 9120,0,32,1 %;
macro APECS$L_TLB_DATA6 = 9152,0,32,1 %;
macro APECS$L_TLB_DATA7 = 9184,0,32,1 %;
macro APECS$L_TBIA = 9216,0,32,1 %;
 
!*** MODULE $APLDDEF ***
literal APLD$C_LENGTH = 20;             !  Length of APLD
literal APLD$S_APLD$DEF = 20;           !  Old size name - synonym
literal APLD$S_APLD = 20;
macro APLD$L_BASE = 0,0,32,1 %;         !  Used as base of APLD struct
macro APLD$PS_CMOD_TABLE = 0,0,32,1 %;
macro APLD$PS_CMOD_TABLE_END = 4,0,32,1 %; !  end of cmod table
macro APLD$PS_PLV_LIST = 8,0,32,1 %;    !  base address of routine list
macro APLD$PS_PLV_FLAGS_LIST = 12,0,32,1 %; !  base address of routine flags
macro APLD$L_MAXCODE = 16,0,32,0 %;     !  max cmod code assigned
literal APLD$C_VECTOR_ENTRIES = 42;
literal APLD$C_MSG_VECTOR_ENTRIES = 128;
literal APLD$C_VECTOR_LENGTH = 2584;
literal APLD$S_APLD$VECTOR_DEF = 2584;
literal APLD$S_APLD$VECTOR = 2584;
macro APLD$L_EXEC_APLD_INDEX = 0,0,32,0 %; !  # of EXEC aplds entries
macro APLD$L_KERN_APLD_INDEX = 4,0,32,0 %; !  # of KERN aplds entries
macro APLD$L_EXEC_RUNDOWN_INDEX = 8,0,32,0 %; !  # of EXEC rndown entries
macro APLD$L_KERN_RUNDOWN_INDEX = 12,0,32,0 %; !  # of KERN rndown entries
macro APLD$L_EXEC_APLD_COUNT = 16,0,32,0 %; !  # EXEC aplds relocated
macro APLD$L_KERN_APLD_COUNT = 20,0,32,0 %; !  # KERN aplds relocated
macro APLD$L_EXEC_RUNDOWN_COUNT = 24,0,32,0 %; !  # EXEC rndown relocated
macro APLD$L_KERN_RUNDOWN_COUNT = 28,0,32,0 %; !  # KERN rndown relocated
macro APLD$L_EXEC_APLD_PERM = 32,0,32,0 %; !  # of EXEC aplds process perm
macro APLD$L_KERN_APLD_PERM = 36,0,32,0 %; !  # of KERN aplds process perm
macro APLD$L_EXEC_RUNDOWN_PERM = 40,0,32,0 %; !  # of EXEC rndown proc perm
macro APLD$L_KERN_RUNDOWN_PERM = 44,0,32,0 %; !  # of KERN rndown proc perm
macro APLD$L_MESSAGE_COUNT = 48,0,32,0 %; !  # of message entries
macro APLD$L_MESSAGE_PERM = 52,0,32,0 %; !  # proc perm message entries
macro APLD$R_EXEC_APLD_VECTOR = 56,0,0,0 %;
literal APLD$S_EXEC_APLD_VECTOR = 840;  !  base of EXEC apld structures
macro APLD$R_KERN_APLD_VECTOR = 896,0,0,0 %;
literal APLD$S_KERN_APLD_VECTOR = 840;  !  base of KERN apld structures
macro APLD$PS_EXEC_RUNDOWN_VECTOR = 1736,0,0,1 %;
literal APLD$S_EXEC_RUNDOWN_VECTOR = 168; !  base of EXEC rundown vector
macro APLD$PS_KERN_RUNDOWN_VECTOR = 1904,0,0,1 %;
literal APLD$S_KERN_RUNDOWN_VECTOR = 168; !  base of KERN rundown vector
macro APLD$L_MESSAGE_VECTOR = 2072,0,0,0 %;
literal APLD$S_MESSAGE_VECTOR = 512;    !  base of message vector
 
!*** MODULE $AQBDEF ***
! +
!  DEFINITION OF ACP QUEUE HEADER
! -
literal AQB$M_UNIQUE = %X'1';
literal AQB$M_DEFCLASS = %X'2';
literal AQB$M_DEFSYS = %X'4';
literal AQB$M_CREATING = %X'8';
literal AQB$M_XQIOPROC = %X'10';
literal AQB$K_UNDEFINED = 0;            !  UNDEFINED ACP 
literal AQB$K_F11V1 = 1;                !  FILES-11 STRUCTURE LEVEL 1 
literal AQB$K_F11V2 = 2;                !  FILES-11 STRUCTURE LEVEL 2 
literal AQB$K_MTA = 3;                  !  MAGTAPE 
literal AQB$K_NET = 4;                  !  NETWORKS 
literal AQB$K_REM = 5;                  !  REMOTE I/O 
literal AQB$K_HBS = 6;                  !  HOST BASED SHADOWING
literal AQB$K_F11V3 = 7;                !  Files-11 presentation of ISO 9660
literal AQB$K_F11V4 = 8;                !  Files-11 presentation of High Sierra
literal AQB$K_F64 = 9;                  !  Dollar ACP type
literal AQB$K_UCX = 10;                 !  ACP for TCP/IP Services for OpenVMS
literal AQB$C_MAXACP = 10;              !  maximum AQB supported 
literal AQB$K_LENGTH = 40;              !  SIZE OF AQB 
literal AQB$C_LENGTH = 40;              !  SIZE OF AQB 
literal AQB$S_AQBDEF = 40;              !  OLD SIZE NAME, SYNONYM FOR AQB$S_AQB
literal AQB$S_AQB = 40;
macro AQB$Q_ACPIQ = 0,0,0,0 %;
literal AQB$S_ACPIQ = 8;                !  INTERLOCKED QUEUE
macro AQB$R_ACP_Q_STRUCTURE = 0,0,0,0 %;
literal AQB$S_ACP_Q_STRUCTURE = 8;
macro AQB$L_ACPQFL = 0,0,32,1 %;        !  QUEUE FORWARD LINK 
macro AQB$L_ACPQBL = 4,0,32,1 %;        !  QUEUE BACK LINK 
macro AQB$W_SIZE = 8,0,16,0 %;          !  CONTROL BLOCK SIZE IN BYTES 
macro AQB$B_TYPE = 10,0,8,0 %;          !  BLOCK TYPE CODE 
macro AQB$B_MNTCNT = 11,0,8,0 %;        !  THIS FIELD IS NOW OBSOLETE
!   AND HAS BEEN REPLACED BY
!   AQB$L_MOUNT_COUNT 
macro AQB$L_ACPPID = 12,0,32,0 %;       !  ACP PROCESS PID 
macro AQB$L_LINK = 16,0,32,1 %;         !  AQB LIST LINKAGE 
macro AQB$B_STATUS = 20,0,8,0 %;        !  STATUS BYTE 
macro AQB$V_UNIQUE = 20,0,1,0 %;        !  ACP IS UNIQUE TO THIS DEVICE 
macro AQB$V_DEFCLASS = 20,1,1,0 %;      !  ACP IS DEFAULT FOR THIS CLASS 
macro AQB$V_DEFSYS = 20,2,1,0 %;        !  ACP IS DEFAULT FOR THE SYSTEM 
macro AQB$V_CREATING = 20,3,1,0 %;      !  ACP IS CURRENTLY BEING CREATED 
macro AQB$V_XQIOPROC = 20,4,1,0 %;      !  eXtended QIO PROCessor is being used.
macro AQB$B_ACPTYPE = 21,0,8,0 %;       !  ACP TYPE CODE 
! 
!  ***** The following ACP type codes are now a user visible interface
!  ***** and the values may not be changed.  There are parallel definitions
!  ***** in the $DVIDEF macro that define symbols of the form:
!  *****
!  *****                DVI$C_ACP_F11V1
!  *****                DVI$C_ACP_F11V2
!  *****                DVI$C_ACP_MTA
!  *****                ...
!  *****
!  ***** All new ACP type values must be added at the end and the names
!  ***** must be 5 characters or less to keep the DVI form of the name
!  ***** 15 characters or less.  Any additions must also be made in $DVIDEF
!  ***** and in the list of ASSUMES in the module SYSGETDEV in [SYS.SRC]
! 
macro AQB$B_CLASS = 22,0,8,0 %;         !  ACP CLASS CODE 
macro AQB$L_BUFCACHE = 24,0,32,1 %;     !  POINTER TO BUFFER CACHE
macro AQB$L_MOUNT_COUNT = 28,0,32,0 %;  !  ACP MOUNT COUNT (REPLACES AQB$B_MNTCNT)
macro AQB$L_ORPHANED_VCB = 32,0,32,1 %; !  Pointer to Orphaned VCB
macro AQB$L_ASTADR = 36,0,32,1 %;       !  AST address used for XQP-type file
!  system processing
 
!*** MODULE $ARBDEF ***
! +
! 
!  Access Rights Block - structure defining process access rights and
!  privileges. Currently part of the PCB (meaning that the size of the
!  ARB declared here must track in the PCB).
! 
! -
literal ARB$C_HEADER = 52;              !  Length of header
literal ARB$K_HEADER = 52;              !  Length of header
literal ARB$K_LENGTH = 124;             !  Structure length 
literal ARB$C_LENGTH = 124;             !  Structure length 
literal ARB$S_ARBDEF = 124;
literal ARB$S_ARB = 124;
macro ARB$Q_PRIV = 0,0,0,0 %;
literal ARB$S_PRIV = 8;                 !  Privilege mask
macro ARB$W_SIZE = 8,0,16,0 %;          !  Structure size
macro ARB$B_TYPE = 10,0,8,0 %;          !  Structure type
macro ARB$B_FLAGS = 11,0,8,0 %;         !  ARB flags (unused)
macro ARB$R_CLASS = 12,0,0,0 %;
literal ARB$S_CLASS = 20;               !  Security classification mask
macro ARB$L_RIGHTSLIST = 32,0,0,0 %;
literal ARB$S_RIGHTSLIST = 20;          !  Rights list descriptors
macro ARB$L_PROCESS = 32,0,32,0 %;      !  process rights
macro ARB$L_SYSTEM = 36,0,32,0 %;       !  system rights
macro ARB$L_EXTENDED = 40,0,32,0 %;     !  extended process rights
macro ARB$L_IMAGE = 44,0,32,0 %;        !  image rights
macro ARB$L_RESERVED = 48,0,32,0 %;     !  reserved
macro ARB$R_RIGHTSDESC = 52,0,0,0 %;
literal ARB$S_RIGHTSDESC = 8;           !  Descriptor for local rights list
macro ARB$R_LOCALRIGHTS = 60,0,0,0 %;
literal ARB$S_LOCALRIGHTS = 64;         !  Process local rights list
macro ARB$L_UIC = 60,0,32,0 %;          !  Process UID
macro ARB$W_MEM = 60,0,16,0 %;          !  Member number
macro ARB$W_GRP = 62,0,16,0 %;          !  Group number
 
!*** MODULE $ARCDEF ***
! +
! 
!  Bit definitions for EXE$GL_ARCHFLAG - flags for VAX architecture differences
! 
! -
literal ARC$M_CHAR_EMUL = %X'10';
literal ARC$M_DCML_EMUL = %X'20';
literal ARC$M_EDPC_EMUL = %X'40';
literal ARC$M_CRC_EMUL = %X'80';
literal ARC$M_DFLT_EMUL = %X'100';
literal ARC$M_FFLT_EMUL = %X'200';
literal ARC$M_GFLT_EMUL = %X'400';
literal ARC$M_HFLT_EMUL = %X'800';
literal ARC$M_EMOD_EMUL = %X'1000';
literal ARC$M_POLY_EMUL = %X'2000';
literal ARC$M_VIRT_SCB = %X'4000';
literal ARC$M_VIRT_SPT = %X'8000';
literal ARC$M_VIRT_PCB = %X'10000';
literal ARC$M_LOAD_SMP = %X'20000';
literal ARC$S_ARCDEF = 4;
literal ARC$S_ARC = 4;
macro ARC$R_ARCDEF_BITS = 0,0,32,0 %;
macro ARC$V_CHAR_EMUL = 0,4,1,0 %;      !  Char Str Ins Emul 
macro ARC$V_DCML_EMUL = 0,5,1,0 %;      !  Decimal String Emul
macro ARC$V_EDPC_EMUL = 0,6,1,0 %;      !  EDITPC Instr Emul 
macro ARC$V_CRC_EMUL = 0,7,1,0 %;       !  CRC Instr Emul
macro ARC$V_DFLT_EMUL = 0,8,1,0 %;      !  D-flt Data Type Emul
macro ARC$V_FFLT_EMUL = 0,9,1,0 %;      !  F-flt Data Type Emul
macro ARC$V_GFLT_EMUL = 0,10,1,0 %;     !  G-flt Data Type Emul
macro ARC$V_HFLT_EMUL = 0,11,1,0 %;     !  H-flt Data Type Emul
macro ARC$V_EMOD_EMUL = 0,12,1,0 %;     !  EMOD Instr Emul
macro ARC$V_POLY_EMUL = 0,13,1,0 %;     !  POLY Instr Emul
macro ARC$V_VIRT_SCB = 0,14,1,0 %;      !  SCB located in virtual memory
macro ARC$V_VIRT_SPT = 0,15,1,0 %;      !  SPT located in virtual memory
macro ARC$V_VIRT_PCB = 0,16,1,0 %;      !  HWPCB located in virtual memory
macro ARC$V_LOAD_SMP = 0,17,1,0 %;      !  Load SMP uncoditionally
 
!*** MODULE $ASTSTKDEF ***
! 
!  AST stack - this defines the architected stack contents during
!  an AST.
! 
literal ASTSTK$M_FEN = %X'1';
literal ASTSTK$M_FP_SAVE_DELAYED = %X'2';
literal ASTSTK$K_NO_FEN_LENGTH = 144;
literal ASTSTK$C_NO_FEN_LENGTH = 144;
literal ASTSTK$K_FEN_LENGTH = 336;
literal ASTSTK$C_FEN_LENGTH = 336;
literal ASTSTK$S_ASTSTKDEF = 336;
literal ASTSTK$S_ASTSTK = 336;
macro ASTSTK$Q_FLAGS = 0,0,0,0 %;
literal ASTSTK$S_FLAGS = 8;
macro ASTSTK$V_FEN = 0,0,1,0 %;         !  Floating point enabled
macro ASTSTK$V_FP_SAVE_DELAYED = 0,1,1,0 %; !  FP register save delayed
macro ASTSTK$Q_NO_FEN_R0 = 8,0,0,0 %;
literal ASTSTK$S_NO_FEN_R0 = 8;
macro ASTSTK$Q_F0 = 8,0,0,0 %;
literal ASTSTK$S_F0 = 8;
macro ASTSTK$Q_NO_FEN_R1 = 16,0,0,0 %;
literal ASTSTK$S_NO_FEN_R1 = 8;
macro ASTSTK$Q_F1 = 16,0,0,0 %;
literal ASTSTK$S_F1 = 8;
macro ASTSTK$Q_NO_FEN_R16 = 24,0,0,0 %;
literal ASTSTK$S_NO_FEN_R16 = 8;
macro ASTSTK$Q_F10 = 24,0,0,0 %;
literal ASTSTK$S_F10 = 8;
macro ASTSTK$Q_NO_FEN_R17 = 32,0,0,0 %;
literal ASTSTK$S_NO_FEN_R17 = 8;
macro ASTSTK$Q_F11 = 32,0,0,0 %;
literal ASTSTK$S_F11 = 8;
macro ASTSTK$Q_NO_FEN_R18 = 40,0,0,0 %;
literal ASTSTK$S_NO_FEN_R18 = 8;
macro ASTSTK$Q_F12 = 40,0,0,0 %;
literal ASTSTK$S_F12 = 8;
macro ASTSTK$Q_NO_FEN_R19 = 48,0,0,0 %;
literal ASTSTK$S_NO_FEN_R19 = 8;
macro ASTSTK$Q_F13 = 48,0,0,0 %;
literal ASTSTK$S_F13 = 8;
macro ASTSTK$Q_NO_FEN_R20 = 56,0,0,0 %;
literal ASTSTK$S_NO_FEN_R20 = 8;
macro ASTSTK$Q_F14 = 56,0,0,0 %;
literal ASTSTK$S_F14 = 8;
macro ASTSTK$Q_NO_FEN_R21 = 64,0,0,0 %;
literal ASTSTK$S_NO_FEN_R21 = 8;
macro ASTSTK$Q_F15 = 64,0,0,0 %;
literal ASTSTK$S_F15 = 8;
macro ASTSTK$Q_NO_FEN_R22 = 72,0,0,0 %;
literal ASTSTK$S_NO_FEN_R22 = 8;
macro ASTSTK$Q_F16 = 72,0,0,0 %;
literal ASTSTK$S_F16 = 8;
macro ASTSTK$Q_NO_FEN_R23 = 80,0,0,0 %;
literal ASTSTK$S_NO_FEN_R23 = 8;
macro ASTSTK$Q_F17 = 80,0,0,0 %;
literal ASTSTK$S_F17 = 8;
macro ASTSTK$Q_NO_FEN_R24 = 88,0,0,0 %;
literal ASTSTK$S_NO_FEN_R24 = 8;
macro ASTSTK$Q_F18 = 88,0,0,0 %;
literal ASTSTK$S_F18 = 8;
macro ASTSTK$Q_NO_FEN_R25 = 96,0,0,0 %;
literal ASTSTK$S_NO_FEN_R25 = 8;
macro ASTSTK$Q_F19 = 96,0,0,0 %;
literal ASTSTK$S_F19 = 8;
macro ASTSTK$Q_NO_FEN_R26 = 104,0,0,0 %;
literal ASTSTK$S_NO_FEN_R26 = 8;
macro ASTSTK$Q_F20 = 104,0,0,0 %;
literal ASTSTK$S_F20 = 8;
macro ASTSTK$Q_NO_FEN_R27 = 112,0,0,0 %;
literal ASTSTK$S_NO_FEN_R27 = 8;
macro ASTSTK$Q_F21 = 112,0,0,0 %;
literal ASTSTK$S_F21 = 8;
macro ASTSTK$Q_NO_FEN_R28 = 120,0,0,0 %;
literal ASTSTK$S_NO_FEN_R28 = 8;
macro ASTSTK$Q_F22 = 120,0,0,0 %;
literal ASTSTK$S_F22 = 8;
macro ASTSTK$Q_NO_FEN_R29 = 128,0,0,0 %;
literal ASTSTK$S_NO_FEN_R29 = 8;
macro ASTSTK$Q_F23 = 128,0,0,0 %;
literal ASTSTK$S_F23 = 8;
macro ASTSTK$Q_NO_FEN_FILL = 136,0,0,0 %;
literal ASTSTK$S_NO_FEN_FILL = 8;       !  Fill to ensure octaword alignment
macro ASTSTK$Q_F24 = 136,0,0,0 %;
literal ASTSTK$S_F24 = 8;
macro ASTSTK$Q_F25 = 144,0,0,0 %;
literal ASTSTK$S_F25 = 8;
macro ASTSTK$Q_F26 = 152,0,0,0 %;
literal ASTSTK$S_F26 = 8;
macro ASTSTK$Q_F27 = 160,0,0,0 %;
literal ASTSTK$S_F27 = 8;
macro ASTSTK$Q_F28 = 168,0,0,0 %;
literal ASTSTK$S_F28 = 8;
macro ASTSTK$Q_F29 = 176,0,0,0 %;
literal ASTSTK$S_F29 = 8;
macro ASTSTK$Q_F30 = 184,0,0,0 %;
literal ASTSTK$S_F30 = 8;
macro ASTSTK$Q_F31 = 192,0,0,0 %;
literal ASTSTK$S_F31 = 8;               !  Placeholder for octword alignment
macro ASTSTK$Q_FEN_R0 = 200,0,0,0 %;
literal ASTSTK$S_FEN_R0 = 8;
macro ASTSTK$Q_FEN_R1 = 208,0,0,0 %;
literal ASTSTK$S_FEN_R1 = 8;
macro ASTSTK$Q_FEN_R16 = 216,0,0,0 %;
literal ASTSTK$S_FEN_R16 = 8;
macro ASTSTK$Q_FEN_R17 = 224,0,0,0 %;
literal ASTSTK$S_FEN_R17 = 8;
macro ASTSTK$Q_FEN_R18 = 232,0,0,0 %;
literal ASTSTK$S_FEN_R18 = 8;
macro ASTSTK$Q_FEN_R19 = 240,0,0,0 %;
literal ASTSTK$S_FEN_R19 = 8;
macro ASTSTK$Q_FEN_R20 = 248,0,0,0 %;
literal ASTSTK$S_FEN_R20 = 8;
macro ASTSTK$Q_FEN_R21 = 256,0,0,0 %;
literal ASTSTK$S_FEN_R21 = 8;
macro ASTSTK$Q_FEN_R22 = 264,0,0,0 %;
literal ASTSTK$S_FEN_R22 = 8;
macro ASTSTK$Q_FEN_R23 = 272,0,0,0 %;
literal ASTSTK$S_FEN_R23 = 8;
macro ASTSTK$Q_FEN_R24 = 280,0,0,0 %;
literal ASTSTK$S_FEN_R24 = 8;
macro ASTSTK$Q_FEN_R25 = 288,0,0,0 %;
literal ASTSTK$S_FEN_R25 = 8;
macro ASTSTK$Q_FEN_R26 = 296,0,0,0 %;
literal ASTSTK$S_FEN_R26 = 8;
macro ASTSTK$Q_FEN_R27 = 304,0,0,0 %;
literal ASTSTK$S_FEN_R27 = 8;
macro ASTSTK$Q_FEN_R28 = 312,0,0,0 %;
literal ASTSTK$S_FEN_R28 = 8;
macro ASTSTK$Q_FEN_R29 = 320,0,0,0 %;
literal ASTSTK$S_FEN_R29 = 8;
macro ASTSTK$Q_FEN_FILL = 328,0,0,0 %;
literal ASTSTK$S_FEN_FILL = 8;          !  Fill to ensure octaword alignment
 
!*** MODULE $BBSDEF ***
! +
! 
!  Structure of message from disk ACP to bad block scan utility.
! 
! -
literal BBS$K_LENGTH = 18;
literal BBS$C_LENGTH = 18;
literal BBS$S_BBSDEF = 18;
literal BBS$S_BBS = 18;
macro BBS$B_MSGTYPE = 0,0,8,0 %;        !  message type code (MSG$C_SCANBAD) 
macro BBS$W_SEQUENCE = 4,0,16,0 %;      !  message sequence number 
macro BBS$L_UCB = 8,0,32,1 %;           !  UCB address of device 
macro BBS$W_FID = 12,0,0,0 %;
literal BBS$S_FID = 6;                  !  file ID of file 
 
!*** MODULE $BDDEF ***
! +
!  BD - Buffer Descriptor format in Buffer Descriptor Leaf table 
! -                                                        
literal BD$M_VALID = %X'1';
literal BD$M_RO = %X'2';
literal BD$K_LENGTH = 64;               !  Length of a Buffer Descriptor 
literal BD$C_LENGTH = 64;               !  Length of a Buffer Descriptor 
literal BD$C_PORT_PAGE_SZ = 8192;       !  8K Port Page Size
literal BD$C_BD_IN_BDL = 128;           !  Number of BDs in a BDL
literal BD$S_SHIFT_SIZE = 5;            !  Factor for shift left of a BDL index to get BD address within a BDL
!  Note this shift size must reflect the NPort requirement that the BDL_INDEX be
literal BD$S_BDDEF = 64;                !  Old size name, synonym            
literal BD$S_BUFDESC = 64;
macro BD$Q_FILL_1 = 0,0,0,0 %;
literal BD$S_FILL_1 = 8;                !  Fill for hex alignement. If possible keep bit 16 of this field zero so
!   the even number descriptor is never treated as a valid BD.
macro BD$W_SIZE = 8,0,16,0 %;           !  Structure size in bytes 
macro BD$B_TYPE = 10,0,8,0 %;           !  Structure Type 
macro BD$B_SUBTYPE = 11,0,8,0 %;        !  Structure Subtype for BD 
macro BD$L_CDRP = 12,0,32,1 %;          !  Addr of associated CDRP 
macro BD$L_LINK = 12,0,32,1 %;          !   or addr of next free descriptor 
macro BD$Q_ROOT_PTR0_VIR = 16,0,0,0 %;
literal BD$S_ROOT_PTR0_VIR = 8;         !  Virtual Root Pointer 0	
macro BD$Q_ROOT_PTR1_VIR = 24,0,0,0 %;
literal BD$S_ROOT_PTR1_VIR = 8;         !  Virtual Root Pointer 1
macro BD$W_PAGE_OFFSET = 32,0,16,0 %;   !  Byte offset of start of buffer 
macro BD$W_FLAGS = 34,0,16,0 %;         !  Flags word 
macro BD$V_VALID = 34,0,1,0 %;          !  Valid bit            
macro BD$V_RO = 34,1,1,0 %;             !  Read-Only access mode check enabled if set 
!   - Currently not supported
macro BD$L_BNAME = 36,0,32,0 %;         !  Buffer Name
macro BD$V_BDL_INDEX = 36,0,8,0 %;
literal BD$S_BDL_INDEX = 8;             !  BDL Index
macro BD$V_BDLT_INDEX = 36,8,12,0 %;
literal BD$S_BDLT_INDEX = 12;           !  BDLT Index
macro BD$V_KEY = 36,20,12,0 %;
literal BD$S_KEY = 12;                  !  Sequence Number 
macro BD$L_BUF_LEN = 40,0,32,0 %;       !  Length of mapped buffer 
macro BD$L_SBZ1 = 44,0,32,0 %;          !  Should be zero
!   used by ports with no MAP routine (like PEDRIVER).
macro BD$L_SVAPTE = 48,0,32,1 %;        !  First SVAPTE of User Data Buffer
macro BD$Q_ROOT_PTR0_PHY = 48,0,0,0 %;
literal BD$S_ROOT_PTR0_PHY = 8;         !  Physical Root Pointer 0	
macro BD$V_PTR0_TYPE = 48,0,2,0 %;
literal BD$S_PTR0_TYPE = 2;             !  Type
macro BD$Q_ROOT_PTR1_PHY = 56,0,0,0 %;
literal BD$S_ROOT_PTR1_PHY = 8;         !  Physical Root Pointer 1
macro BD$V_PTR1_TYPE = 56,0,2,0 %;
literal BD$S_PTR1_TYPE = 2;             !  Type
macro BD$L_FILL_2 = 48,0,32,1 %;        !  Skip over "First SVAPTE of User Data Buffer"
macro BD$L_CRCTX = 52,0,32,1 %;         !  Address of CRCTX assoicated with this I/O request
!  based on a buffer descriptor size of 32.
 
!*** MODULE $BDLPTRDEF ***
! +
!  BDLPTR - NPORT Buffer Descriptor Leaf pointer
! 
!  This table is sharable among all SCS ports using the NPORT architectured
!  named buffer convention. buffer descriptors (BD's) are allocated for SCS
!  block transfers. the BDLT must be aligned on a an 8K boundary. The BDLT can
!  support up to 4096 BDL pointers but in this implementation will only
!  support up to 32 BDL pointers for a maximum of 8148 buffer descriptors. This
!  definition only defines a single BDL pointer, each BDL pointer has the
!  identical structure. The VMS implementation uses the first few pointers as
!  defined in CMNBDLTDEF.
! 
!                 63                                                1 0
!                 -----------------------------------------------------
!      		 |   BDL_PTR_PHY	                             |V| V=valid
!                 -----------------------------------------------------
!     		 |   BDL_PTR_VIR                                       |
!                 -----------------------------------------------------
! -
literal BDLPTR$M_VALID = %X'1';
literal BDLPTR$C_LENGTH = 16;           !  Length of structure 
literal BDLPTR$S_SHIFT_SIZE = 4;        !  Factor for shift left of BDLT index to get BDL address
literal BDLPTR$S_BDLPTRDEF = 16;
literal BDLPTR$S_BDLPTR = 16;
macro BDLPTR$Q_PHY_ADDR = 0,0,0,0 %;
literal BDLPTR$S_PHY_ADDR = 8;          !  Buffer Descriptor 0 Leaf Physical Pointer
macro BDLPTR$V_VALID = 0,0,1,0 %;       !  Valid Bit 
macro BDLPTR$Q_VIR_ADDR = 8,0,0,0 %;
literal BDLPTR$S_VIR_ADDR = 8;          !  Buffer Descriptor 0 Leaf Virtual Pointer
 
!*** MODULE $BNAMDEF ***
! +
!  BNAM - NPORT Buffer Name Descriptor 
! 
! -
literal BNAM$C_LENGTH = 4;              !  Length of structure 
literal BNAM$M_BDLT_MASK = -1048321;    !  Mask to use extract BDLT index
literal BNAM$M_BDL_MASK = -256;         !  Mask to use extract BDL index
literal BNAM$M_KEY_MASK = 1048575;      !  Mask to use extract KEY
literal BNAM$S_BNAMDEF = 4;
literal BNAM$S_BNAM = 4;
macro BNAM$L_BNAME = 0,0,32,1 %;        !  Buffer NAME
macro BNAM$V_BDL_INDEX = 0,0,8,0 %;
literal BNAM$S_BDL_INDEX = 8;           !  BDL Index
macro BNAM$V_BDLT_INDEX = 0,8,12,0 %;
literal BNAM$S_BDLT_INDEX = 12;         !  BDLT Index
macro BNAM$V_KEY = 0,20,12,0 %;
literal BNAM$S_KEY = 12;                !  Sequence Number 
 
!*** MODULE $BODDEF ***
! +
!  BOD - Buffer Object Descriptor
!  
!   A buffer object descriptor defines a buffer object used
!   by the I/O subsystem.
! -
literal BOD$M_DELPEN = %X'1';
literal BOD$M_NOQUOTA = %X'2';
literal BOD$S_BOD = 48;
macro BOD$L_FLINK = 0,0,32,1 %;         !   FLINK into PCB list
macro BOD$L_BLINK = 4,0,32,1 %;         !   BLINK into PCB list
macro BOD$W_SIZE = 8,0,16,0 %;          !   Size of fixed portion of BOOTCB 
macro BOD$B_TYPE = 10,0,8,0 %;          !   Type of control block 
macro BOD$L_ACMODE = 12,0,32,0 %;       !   Owner access mode
macro BOD$L_SEQNUM = 16,0,32,0 %;       !   Sequence # at object creation
macro BOD$L_REFCNT = 20,0,32,0 %;       !   No. of references to this BOD
macro BOD$L_FLAGS = 24,0,32,0 %;        !   Flags longword
macro BOD$V_DELPEN = 24,0,1,0 %;        !   Delete pending
macro BOD$V_NOQUOTA = 24,1,1,0 %;       !   No quota charge for S0 window
macro BOD$L_PID = 28,0,32,0 %;          !   PID of creating process
macro BOD$L_PAGCNT = 32,0,32,0 %;       !   No. of pages in buffer object
macro BOD$L_BASEPVA = 36,0,32,1 %;      !   Base process address of buffer object
macro BOD$L_BASESVA = 40,0,32,1 %;      !   Base system address of buffer object
macro BOD$PS_SVAPTE = 44,0,32,1 %;      !   SVAPTE of first system page of buffer object
literal BOD$K_LENGTH = 48;              !  LENGTH OF STRUCTURE
literal BOD$C_LENGTH = 48;              !  LENGTH OF STRUCTURE
literal BOD$S_BODDEF = 48;
 
!*** MODULE $boocmddef ***
! +
! 	Definitions for SYSGEN/SYSBOOT command options flags
! -
literal boocmd$m_nocheck = %X'1';
literal boocmd$m_noreset = %X'2';
literal boocmd$m_save = %X'4';
literal boocmd$m_user = %X'8';
literal boocmd$m_pagefile = %X'10';
literal boocmd$m_noncontig = %X'20';
literal boocmd$m_select = %X'40';
literal boocmd$m_exclude = %X'80';
literal boocmd$m_cont = %X'100';
literal boocmd$M_DEFAULT = %X'200';
literal boocmd$m_usefile = %X'400';
literal boocmd$m_dishex = %X'800';
literal boocmd$m_autolog = %X'1000';
literal boocmd$m_output = %X'2000';
literal boocmd$m_input = %X'4000';
literal boocmd$m_setoutput = %X'8000';
literal boocmd$m_terminal = %X'10000';
literal boocmd$m_contig = %X'20000';
literal boocmd$m_nochkpnt = %X'40000';
literal boocmd$m_remote = %X'80000';
literal boocmd$m_logical = %X'100000';
literal boocmd$m_uart1 = %X'200000';
literal boocmd$m_uart2 = %X'400000';
literal boocmd$m_uart3 = %X'800000';
literal boocmd$m_ni = %X'1000000';
literal boocmd$m_nl_user = %X'2000000';
literal boocmd$m_dins_all = %X'4000000';
literal boocmd$m_dins_idx = %X'8000000';
literal boocmd$m_setcmd = %X'10000000';
literal boocmd$m_clr_modify = %X'20000000';
literal boocmd$m_dynamic_only = %X'40000000';
literal boocmd$S_boocmddef = 4;
literal boocmd$S_boocmd = 4;
macro boocmd$v_nocheck = 0,0,1,0 %;
macro boocmd$v_noreset = 0,1,1,0 %;
macro boocmd$v_save = 0,2,1,0 %;
macro boocmd$v_user = 0,3,1,0 %;
macro boocmd$v_pagefile = 0,4,1,0 %;
macro boocmd$v_noncontig = 0,5,1,0 %;
macro boocmd$v_select = 0,6,1,0 %;
macro boocmd$v_exclude = 0,7,1,0 %;
macro boocmd$v_cont = 0,8,1,0 %;
macro boocmd$V_DEFAULT = 0,9,1,0 %;
macro boocmd$v_usefile = 0,10,1,0 %;
macro boocmd$v_dishex = 0,11,1,0 %;
macro boocmd$v_autolog = 0,12,1,0 %;
macro boocmd$v_output = 0,13,1,0 %;
macro boocmd$v_input = 0,14,1,0 %;
macro boocmd$v_setoutput = 0,15,1,0 %;
macro boocmd$v_terminal = 0,16,1,0 %;
macro boocmd$v_contig = 0,17,1,0 %;
macro boocmd$v_nochkpnt = 0,18,1,0 %;
macro boocmd$v_remote = 0,19,1,0 %;
macro boocmd$v_logical = 0,20,1,0 %;
macro boocmd$v_uart1 = 0,21,1,0 %;
macro boocmd$v_uart2 = 0,22,1,0 %;
macro boocmd$v_uart3 = 0,23,1,0 %;
macro boocmd$v_ni = 0,24,1,0 %;
macro boocmd$v_nl_user = 0,25,1,0 %;
macro boocmd$v_dins_all = 0,26,1,0 %;
macro boocmd$v_dins_idx = 0,27,1,0 %;
macro boocmd$v_setcmd = 0,28,1,0 %;
macro boocmd$v_clr_modify = 0,29,1,0 %;
macro boocmd$v_dynamic_only = 0,30,1,0 %;
 
!*** MODULE $BOODEF ***
! +
!  BOO - Boot Control Block
! 
!  A boot control block is produced by SYSBOOT and placed in non-paged
!  pool.  It is pointed to by the cell EXE$GL_BOOTCB and contains
!  the mapping information for SYSDUMP.DMP.
! -
literal BOO$K_LENGTH = 40;
literal BOO$C_LENGTH = 40;
literal BOO$S_BOODEF = 40;
literal BOO$S_BOO = 40;
macro BOO$L_CHECKSUM = 0,0,32,0 %;      !  Checksum 
macro BOO$L_TIMELBN = 4,0,32,0 %;       !  LBN of system time quadword
macro BOO$W_SIZE = 8,0,16,0 %;          !  Size of fixed portion of BOOTCB 
macro BOO$B_TYPE = 10,0,8,0 %;          !  Type of control block 
macro BOO$B_SUBTYP = 11,0,8,0 %;        !  Sub-type 
macro BOO$L_DMP_VBN = 12,0,32,0 %;      !  Starting VBN for dump file 
macro BOO$L_DMP_SIZE = 16,0,32,0 %;     !  Size in blocks of dump file 
!  from starting VBN to end of file
macro BOO$L_DMP_MAP = 20,0,32,1 %;      !  Adr of map for SYSDUMP.DMP 
macro BOO$L_BUG_WCB = 24,0,32,1 %;      !  Adr of WCB for bugcheck image
macro BOO$L_BUG_IMAGE_VA = 28,0,32,1 %; !  Base VA of image containing bugcheck
macro BOO$L_BUG_PTE_ADDR = 32,0,32,1 %; !  PTEs allocated to do QIOs to dump file
macro BOO$L_SCB_LBN = 36,0,32,0 %;      !  LBN of the storage control block (SCB) on system disk
 
!*** MODULE $boopardef ***
literal boopar$k_length = 48;           !  Length of argument list
literal boopar$S_booparam = 48;
macro boopar$l_arg_revision = 0,0,32,0 %; !  Argument list revision
macro boopar$l_pfn_map = 4,0,32,1 %;    !  Address of allocation bitmap
macro boopar$l_state = 8,0,32,0 %;      !  exe$gl_state
macro boopar$l_va_to_vpn = 12,0,32,0 %; !  
macro boopar$l_vpn_to_va = 16,0,32,0 %; ! 
macro boopar$l_bwp_mask = 20,0,32,0 %;  !  Byte within a page mask
macro boopar$l_file_cache = 24,0,32,1 %; !  addr of file cache
macro boopar$l_cache_size = 28,0,32,0 %; !  file cache size
macro boopar$l_sptbase = 32,0,32,1 %;   !  SPT base
macro boopar$l_scb = 36,0,32,1 %;       !  SCB address
macro boopar$l_hpdesc = 40,0,32,1 %;    !  ldr huge page structure
macro boopar$l_xdtscb = 44,0,32,1 %;    !  Xdelta's SCB address
 
!*** MODULE BOOSTATEDEF ***
literal BOOSTATE$M_SYSBOOT = %X'1';
literal BOOSTATE$M_INIT = %X'2';
literal BOOSTATE$M_SWAPPER = %X'4';
literal BOOSTATE$M_SYSINIT = %X'8';
literal BOOSTATE$M_STARTUP = %X'10';
literal BOOSTATE$M_PFN_INIT = %X'20';
literal BOOSTATE$M_POOL_INIT = %X'40';
literal BOOSTATE$M_XQP = %X'80';
literal BOOSTATE$M_RMS = %X'100';
literal BOOSTATE$M_CONSOLE = %X'200';
literal BOOSTATE$M_SPNLCK_AVAIL = %X'400';
literal BOOSTATE$M_NORDONLY = %X'800';
literal BOOSTATE$M_EXEC_SLICING = %X'1000';
literal BOOSTATE$M_OBJREG = %X'2000';
literal BOOSTATE$M_AUDITING = %X'4000';
literal BOOSTATE$M_OBJECT_SERVICE = %X'8000';
literal BOOSTATE$M_FOREIGN_BOOT = %X'10000';
literal BOOSTATE$S_BOOSTATEDEF = 4;
literal BOOSTATE$S_BOOSTATE = 4;
macro BOOSTATE$V_SYSBOOT = 0,0,1,0 %;   !  SYSBOOT is executing
macro BOOSTATE$V_INIT = 0,1,1,0 %;      !  INIT is executing
macro BOOSTATE$V_SWAPPER = 0,2,1,0 %;   !  The SWAPPER process is executing
macro BOOSTATE$V_SYSINIT = 0,3,1,0 %;   !  The SYSINIT process is executing
macro BOOSTATE$V_STARTUP = 0,4,1,0 %;   !  The STARTUP process is executing
macro BOOSTATE$V_PFN_INIT = 0,5,1,0 %;  !  The PFN database is initialized
macro BOOSTATE$V_POOL_INIT = 0,6,1,0 %; !  Nonpaged pool is available
macro BOOSTATE$V_XQP = 0,7,1,0 %;       !  The XQP has been mapped
macro BOOSTATE$V_RMS = 0,8,1,0 %;       !  RMS has been loaded
macro BOOSTATE$V_CONSOLE = 0,9,1,0 %;   !  Console routines are connected
macro BOOSTATE$V_SPNLCK_AVAIL = 0,10,1,0 %; !  Spinlock database available
macro BOOSTATE$V_NORDONLY = 0,11,1,0 %; !  If set, EXEC should not be
!          made read only.
macro BOOSTATE$V_EXEC_SLICING = 0,12,1,0 %; !  If set, execlets should not 
!          sliced during load.
macro BOOSTATE$V_OBJREG = 0,13,1,0 %;   !  Security Object Registration enabled
macro BOOSTATE$V_AUDITING = 0,14,1,0 %; !  Security auditing subsystem initialized
macro BOOSTATE$V_OBJECT_SERVICE = 0,15,1,0 %; !  Security object service initialized
macro BOOSTATE$V_FOREIGN_BOOT = 0,16,1,0 %; !  If set, system disk is foreign to VMS
 
!*** MODULE $BPTDEF ***
!  +
! 
!   Define bits which control which hardcoded calls to INI$BRK (the initial BPT)
!   will be executed as a system is being booted.
! 
!  -
literal BPT$M_INITBEGIN = %X'1';
literal BPT$M_INITEND = %X'2';
literal BPT$M_SMPSTART = %X'4';
literal BPT$S_BPTDEF = 4;               !  Old size name, synonym
literal BPT$S_BPT = 4;
macro BPT$V_INITBEGIN = 0,0,1,0 %;      !  BRK at start of INIT
macro BPT$V_INITEND = 0,1,1,0 %;        !  BRK at end of INIT
macro BPT$V_SMPSTART = 0,2,1,0 %;       !  BRK at INIT call to setup SMP
 
!*** MODULE $BRKTDEF ***
! 
!  +
!  
!   Structure of breakthru message descriptor block.
!  
!  -
literal BRK$M_LOCKED = %X'1';
literal BRK$M_DONE = %X'2';
literal BRK$M_CHKPRIV = %X'4';
literal BRK$M_CHKUIC = %X'8';
literal BRK$C_LENGTH = 146;
literal BRK$S_BRKTHRU_1 = 146;          !  Old size field (when aggregate had different name)
literal BRK$S_BRK = 147;
!  
!   Common Storage
!   
macro BRK$Q_PRIVS = 0,0,0,0 %;
literal BRK$S_PRIVS = 8;                !   privs to set
macro BRK$W_SIZE = 8,0,16,0 %;          !   block size
macro BRK$W_OUTCNT = 10,0,16,0 %;       !   outstanding I/O count
macro BRK$T_DEVNAME = 12,0,0,0 %;
literal BRK$S_DEVNAME = 16;             !   device name for $ASSIGN
macro BRK$L_DEVUIC = 28,0,32,0 %;       !   UIC of the terminal's owner
macro BRK$L_PCB = 32,0,32,1 %;          !   Address of PCB
macro BRK$L_IOSB = 36,0,32,1 %;         !   Address of return IOSB
macro BRK$L_ASTADR = 40,0,32,1 %;       !   Address of AST routine
macro BRK$L_ASTPRM = 44,0,32,0 %;       !   Value of AST parameter
macro BRK$Q_TIMEOUT = 48,0,0,0 %;
literal BRK$S_TIMEOUT = 8;              !   Timeout value
macro BRK$L_CARCON = 56,0,32,0 %;       !   carriage control
macro BRK$L_FLAGS = 60,0,32,0 %;        !   flags
macro BRK$T_SENDNAME = 64,0,0,0 %;
literal BRK$S_SENDNAME = 16;            !   username/terminal name
macro BRK$W_SENDTYPE = 80,0,16,0 %;     !   send descriptor type
macro BRK$W_SECONDS = 82,0,16,0 %;      !   Timeout in seconds
macro BRK$L_REQID = 84,0,32,0 %;        !   send requestor ID
!  
!   miscellaneous context
!  
macro BRK$L_PIDCTX = 88,0,32,0 %;       !   Last PID in user search
macro BRK$L_UCBCTX = 92,0,32,1 %;       !   Last UCB in TTY search
macro BRK$L_DDBCTX = 96,0,32,1 %;       !   Last DDB in TTY search
macro BRK$L_QIOCTX = 100,0,32,1 %;      !   per QIO context address
macro BRK$W_EFN = 104,0,16,0 %;         !   user event flag *BYTE***?
macro BRK$B_STS = 106,0,8,0 %;          !   status flags
macro BRK$V_LOCKED = 106,0,1,0 %;       !  I/O dataabse locked
macro BRK$V_DONE = 106,1,1,0 %;         !  done looking for terminals
macro BRK$V_CHKPRIV = 106,2,1,0 %;      !  check privilege
macro BRK$V_CHKUIC = 106,3,1,0 %;       !  check UIC of terminal owner
macro BRK$B_PRVMODE = 107,0,8,0 %;      !   previous mode
macro BRK$L_SCRMSGLEN = 108,0,32,0 %;   !   screen message length
macro BRK$L_SCRMSG = 112,0,32,0 %;      !   screen message address
!  
!   status block
!   
macro BRK$W_STATUS = 116,0,16,0 %;      !   status
macro BRK$W_SUCCESSCNT = 118,0,16,0 %;  !   Success count
macro BRK$W_TIMEOUTCNT = 120,0,16,0 %;  !   Timeout count
macro BRK$W_REFUSEDCNT = 122,0,16,0 %;  !   Refused count
!  
!   start of mailbox message 
!  
macro BRK$W_TRMMSG = 124,0,16,0 %;      !   mailbox message code
macro BRK$W_TRMUNIT = 126,0,16,0 %;     !   tty unit number
macro BRK$T_TRMNAME = 128,0,0,0 %;
literal BRK$S_TRMNAME = 16;             !   terminal name
!  
!   real message starts here
!  
macro BRK$W_MSGLEN = 144,0,16,0 %;      !   length of msgbuf
! 
!  Length
! 
macro BRK$T_MSGBUF = 146,0,8,0 %;       !   start of message (Do not include in the length. This field
!   marks the begining of the variable length buffer.  It has a
!   real size for C)
literal BRK2$S_BRK2 = 16;
!  
!   Per QIO storage
!  
macro BRK2$L_COMMON = 0,0,32,1 %;       !   address of common area
macro BRK2$Q_IOSB = 4,0,0,0 %;
literal BRK2$S_IOSB = 8;                !   iosb for QIO
macro BRK2$W_CHAN = 12,0,16,0 %;        !   channel
!    subsequent & adjacent BRK2.
! 
!  Length of Per QIO context
! 
literal BRK2$C_LENGTH = 16;
literal BRKTHRU_2$S_LENGTH = 16;        !  Old size field (when aggregate had different name)
 
!*** MODULE $btadpdef ***
literal btadp$m_booted_device = %X'1';
literal btadp$m_valid = %X'2';
literal btadp$m_foreign = %X'4';
literal btadp$c_length = 312;           !  Length Of Btadp
literal btadp$k_length = 312;           !  Length Of Btadp
! 
literal BTADP$K_FLAVOR_ETH_NOPAD = 0;   !  Ethernet flavor without pad field
literal BTADP$K_FLAVOR_ETH_PAD = 1;     !  Ethernet flavor with pad field
literal BTADP$K_FLAVOR_802E_NOPAD = 2;  !  802E flavor without pad field
literal BTADP$K_FLAVOR_802E_PAD = 3;    !  802E flavor with pad field
literal BTADP$K_LAN_TYPE_CSMACD = 1;    !  CSMACD data link
literal BTADP$K_LAN_TYPE_FDDI = 2;      !  FDDI   data link
literal btadp$K_LAN_LENGTH = 360;       !  Length Of Btadp
literal btadp$S_btadpdef = 360;         !  Old size name, synonym
literal btadp$S_btadp = 360;
macro btadp$pq_flink = 0,0,0,1 %;
literal btadp$s_flink = 8;              !  BTADP forward link
macro btadp$pl_flink_l = 0,0,32,1 %;
macro btadp$il_flink_h = 4,0,32,0 %;
macro btadp$pq_blink = 8,0,0,1 %;
literal btadp$s_blink = 8;              !  BTADP backward link
macro btadp$pl_blink_l = 8,0,32,1 %;
macro btadp$il_blink_h = 12,0,32,0 %;
macro btadp$iq_devtype = 16,0,0,0 %;
literal btadp$s_devtype = 8;            !  Bootstrap Device Type
macro btadp$il_devtype_l = 16,0,32,0 %;
macro btadp$il_devtype_h = 20,0,32,0 %;
macro btadp$iq_unit = 24,0,0,0 %;
literal btadp$s_unit = 8;               !  Boot Device Unit Number
macro btadp$il_unit_l = 24,0,32,0 %;
macro btadp$il_unit_h = 28,0,32,0 %;
macro btadp$pq_csrphy = 32,0,0,1 %;
literal btadp$s_csrphy = 8;             !  Phys. Csr Addr. Of Boot Dev
macro btadp$pl_csrphy_l = 32,0,32,1 %;
macro btadp$il_csrphy_h = 36,0,32,0 %;
macro btadp$pq_csrvir = 40,0,0,1 %;
literal btadp$s_csrvir = 8;             !  Virtual Csr Addr. Of Boot Dev
macro btadp$pl_csrvir_l = 40,0,32,1 %;
macro btadp$il_csrvir_h = 44,0,32,0 %;
macro btadp$pq_adpphy = 48,0,0,1 %;
literal btadp$s_adpphy = 8;             !  Phys. Csr Addr. Of Boot Adp
macro btadp$pl_adpphy_l = 48,0,32,1 %;
macro btadp$il_adpphy_h = 52,0,32,0 %;
macro btadp$pq_adpvir = 56,0,0,1 %;
literal btadp$s_adpvir = 8;             !  Virtual Csr Addr. Of Boot Adp
macro btadp$pl_adpvir_l = 56,0,32,1 %;
macro btadp$il_adpvir_h = 60,0,32,0 %;
macro btadp$iq_bootndt = 64,0,0,0 %;
literal btadp$s_bootndt = 8;            !  Nexus Device Type Of Boot 
macro btadp$il_bootndt_l = 64,0,32,0 %;
macro btadp$il_bootndt_h = 68,0,32,0 %;
macro btadp$pq_node_space_addr = 72,0,0,1 %;
literal btadp$s_node_space_addr = 8;    !  SVA of node space
macro btadp$pl_node_space_addr_l = 72,0,32,1 %;
macro btadp$il_node_space_addr_h = 76,0,32,0 %;
macro btadp$pq_bdtab = 80,0,0,1 %;
literal btadp$s_bdtab = 8;              !  Pointer to BDTAB
macro btadp$pl_bdtab_l = 80,0,32,1 %;
macro btadp$il_bdtab_h = 84,0,32,0 %;
macro btadp$iq_protocol = 88,0,0,1 %;
literal btadp$s_protocol = 8;           !  
macro btadp$il_protocol_l = 88,0,32,0 %;
macro btadp$il_protocol_h = 92,0,32,0 %;
macro btadp$iq_hose = 96,0,0,1 %;
literal btadp$s_hose = 8;               !  
macro btadp$il_hose_l = 96,0,32,0 %;
macro btadp$il_hose_h = 100,0,32,0 %;
macro btadp$iq_slot = 104,0,0,1 %;
literal btadp$s_slot = 8;               !  XMI/FBUS slot
macro btadp$il_slot_l = 104,0,32,0 %;
macro btadp$il_slot_h = 108,0,32,0 %;
macro btadp$pq_remote_addr = 112,0,0,1 %;
literal btadp$s_remote_addr = 8;        !  remote addr (eg. XZA)
macro btadp$pl_remote_addr_l = 112,0,32,1 %;
macro btadp$il_remote_addr_h = 116,0,32,0 %;
macro btadp$iq_chan = 120,0,0,1 %;
literal btadp$s_chan = 8;               !  Channel
macro btadp$il_chan_l = 120,0,32,0 %;
macro btadp$il_chan_h = 124,0,32,0 %;
macro btadp$iq_bus_type = 128,0,0,1 %;
literal btadp$s_bus_type = 8;           !  Bus type value
macro btadp$il_bus_type_l = 128,0,32,0 %;
macro btadp$il_bus_type_h = 132,0,32,0 %;
macro btadp$iq_dma_map_register = 136,0,0,1 %;
literal btadp$s_dma_map_register = 8;   !  Base DMA mapping register
macro btadp$il_dma_map_register_l = 136,0,32,0 %;
macro btadp$il_dma_map_register_h = 140,0,32,0 %;
! 
! 		Define the fields used to control the device name.
! 
macro btadp$IQ_MSCP_SLUN = 144,0,0,0 %;
literal btadp$S_MSCP_SLUN = 8;          !  TMSCP/MSCP SLUN for this device.
macro btadp$T_DEVICE_NAME = 152,0,0,0 %;
literal btadp$S_DEVICE_NAME = 32;       !  Counted string.  Remote device name.  Used for NISCA booting only.
macro btadp$T_NODE_NAME = 184,0,0,0 %;
literal btadp$S_NODE_NAME = 16;         !  Counted string.  Remote system's SCS node name.
macro btadp$IQ_SCSSYSTEMID = 200,0,0,0 %;
literal btadp$S_SCSSYSTEMID = 8;        !  Remote system's SCSSYSTEMID value.
macro btadp$T_CONTROLLER_PREFIX = 208,0,0,0 %;
literal btadp$S_CONTROLLER_PREFIX = 8;  !  Counted string.  Remote device's controller prefix.
macro btadp$B_CONTROLLER_LETTER = 216,0,8,0 %; !  Remote device's controller letter in ASCII.
macro btadp$iq_flags = 224,0,0,1 %;
literal btadp$s_flags = 8;              !  Flags
macro btadp$il_flags_l = 224,0,32,0 %;
macro btadp$il_flags_h = 228,0,32,0 %;
macro btadp$v_booted_device = 224,0,1,0 %; !   is this the boot device
macro btadp$v_valid = 224,1,1,0 %;      !   BTADP validity
macro btadp$v_foreign = 224,2,1,0 %;    !   this device is foreign
macro btadp$L_PATHNAME_LEN = 232,0,32,1 %; !  length of console pathname string
macro btadp$T_PATHNAME = 236,0,0,0 %;
literal btadp$S_PATHNAME = 76;          !  console pathname string for this device
! 
! 		Define the minimum BTADP data structure length.
! 
! 		Define the LAN boot driver fields.
! 
! 		Transmit and receive control variables.
! 
macro btadp$Q_XMT_TIMEOUT = 312,0,0,0 %;
literal btadp$S_XMT_TIMEOUT = 8;        !   LAN transmit timeout.
macro btadp$G_LAN_HW_ADDR = 320,0,0,0 %;
literal btadp$S_LAN_HW_ADDR = 6;        !   LAN hardware address.
macro btadp$B_LAN_DEV_TYPE = 326,0,8,0 %; !   LAN adapter type (from DYN symbols).
macro btadp$Q_PROTOCOL_TYPE = 328,0,0,0 %;
literal btadp$S_PROTOCOL_TYPE = 8;      !  Protocol type value.
macro btadp$L_PROTOCOL_FLAVOR = 336,0,32,0 %; !  (0=Eth/NoPad,1=Eth/Pad,2=802E/NoPad,3=802E/Pad)
macro btadp$L_LAN_HDR_SIZE = 340,0,32,0 %; !  LAN header size.
macro btadp$L_MAX_XMT_SIZE = 344,0,32,0 %; !  Maximum datagram size.
macro btadp$L_MIN_XMT_SIZE = 348,0,32,0 %; !  Minimum datagram size.
! 
! 		Define the LAN type.
! 
macro btadp$L_LAN_TYPE = 352,0,32,0 %;  !  Type of LAN.
! 
! 		Define the minimum BTADP data structure length required for LAN devices.
! 
 
!*** MODULE $BTBDEF ***
literal BTB$K_LENGTH_PART1 = 480;       !  Length of 1st part of boot block
literal BTB$M_NOTCONTIG = %X'1';
literal BTB$K_LENGTH = 512;             !  Length of a boot block
literal BTB$S_BTBDEF = 512;             !  Old size name, synonym
literal BTB$S_BTB = 512;
macro BTB$B_NOP1 = 0,0,8,0 %;           !  Contains NOP opcode
macro BTB$B_BRB = 1,0,8,0 %;            !  Contains BRB opcode
macro BTB$B_BRB_OFFSET = 2,0,8,0 %;     !  Contains PC relative offset of branch
macro BTB$B_NOP2 = 3,0,8,0 %;           !  Contains NOP opcode
macro BTB$L_LBN1 = 4,0,32,1 %;          !  Starting LBN of 1st boot file
macro BTB$W_HIGH_LBN = 4,0,16,0 %;      !  High 32-bits of LBN
macro BTB$W_LOW_LBN = 6,0,16,0 %;       !  Low 32-bits of LBN
macro BTB$B_VAX_BRB = 12,0,8,0 %;       !  Contains BRB opcode (VAX)
macro BTB$B_VAX_OFFSET = 13,0,8,0 %;    !  Contains PC relative offset of branch
macro BTB$B_PDP_BRB = 15,0,8,0 %;       !  Contain BRB opcode (PDP)
macro BTB$B_PDP_OFFSET = 16,0,8,0 %;    !  Contains PC relative offset of branch
macro BTB$B_INST_SET = 24,0,8,0 %;      !  Instruction set code (%x18=VAX)
macro BTB$B_CTRL_TYPE = 25,0,8,0 %;     !  Controller type
macro BTB$B_FILE_STR = 26,0,8,0 %;      !  File structure (ODS-II =2)
macro BTB$B_COMP3 = 27,0,8,0 %;         !  Complement of sum of previous 3 bytes
macro BTB$B_VERSION = 29,0,8,0 %;       !  Boot block version=1
macro BTB$L_SIZE = 32,0,32,0 %;         !  Size in LBNs of image
macro BTB$L_LOAD_OFFSET = 36,0,32,0 %;  !  Load offset into good memory
macro BTB$L_START_OFFSET = 40,0,32,0 %; !  Offset to begin execution
macro BTB$L_CHECKSUM = 44,0,32,0 %;     !  Checksum of three previous longwords
macro BTB$B_CODE = 48,0,0,1 %;
literal BTB$S_CODE = 92;                !  VAX boot block code 
macro BTB$B_FILL8 = 140,0,0,1 %;
literal BTB$S_FILL8 = 340;              !  Reserved for future use
macro BTB$Q_SIZE2 = 480,0,0,1 %;
literal BTB$S_SIZE2 = 8;                !  Size of 2nd boot file
macro BTB$L_LOW_SIZE2 = 480,0,32,1 %;   !  Low 32-bits of size
macro BTB$L_HIGH_SIZE2 = 484,0,32,1 %;  !  High 32-bits of size
macro BTB$Q_LBN2 = 488,0,0,1 %;
literal BTB$S_LBN2 = 8;                 !  Starting LBN of 2nd boot file
macro BTB$L_LOW_LBN2 = 488,0,32,1 %;    !  Low 32-bits of LBN
macro BTB$L_HIGH_LBN2 = 492,0,32,1 %;   !  High 32-bits of LBN
macro BTB$Q_FLAGS = 496,0,0,0 %;
literal BTB$S_FLAGS = 8;                !  Boot block flags
macro BTB$L_LOW_FLAGS = 496,0,32,0 %;   !  Low longword of flags
macro BTB$L_HIGH_FLAGS = 500,0,32,0 %;  !  High longword of flags
macro BTB$V_NOTCONTIG = 496,0,1,0 %;    !  Bootstrap is not contiguous
macro BTB$Q_CHECKSUM2 = 504,0,0,1 %;
literal BTB$S_CHECKSUM2 = 8;            !  Checksum of entire block
macro BTB$L_LOW_CHECK2 = 504,0,32,1 %;  !  Low 32-bits of checksum
macro BTB$L_HIGH_CHECK2 = 508,0,32,1 %; !  High 32-bits of checksum
 
!*** MODULE $BTDDEF ***
! +
! 
!  Boot device codes
! 
! -
!  "$K_" added, 8/30/79, CHP
literal BTD$K_MB = 0;                   !  Massbus device
!  Types 1-31. reserved for
!   Unibus(Qbus) devices
literal BTD$K_DM = 1;                   !  RK06/7
literal BTD$K_DL = 2;                   !  RL02
literal BTD$K_DQ = 3;                   !  RB02/RB80
literal BTD$K_PROM = 8;                 !  PROM (not copied)
literal BTD$K_PROM_COPY = 9;            !  PROM copied (Mayflower)
literal BTD$K_UDA = 17;                 !  UDA
literal BTD$K_TK50 = 18;                !  TK50 (MAYA)
literal BTD$K_KFQSA = 19;               !  KFQSA
literal BTD$K_QBUS_SCSI = 20;           !  Qbus SCSI adapter
!  End of Unibus(Qbus) devices
literal BTD$K_HSCCI = 32;               !  HSC on CI
literal BTD$K_BDA = 33;                 !  BI disk adapter
literal BTD$K_BVPSSP = 34;              !  BVP Storage Systems ports
literal BTD$K_AIE_TK50 = 35;            !  AIE/TK50 port
literal BTD$k_ST506_DISK = 36;          !  ST506 disk (PVAX/VAXstar)
literal BTD$K_KA410_DISK = 36;          !  VAXstar ST506 disk
literal BTD$K_KA420_DISK = 36;          !  PVAX ST506 disk
literal BTD$K_SCSI_5380_TAPE = 37;      !  NCR 5380 SCSI tape (PVAX/VAXstar)
literal BTD$K_KA410_TAPE = 37;          !  VAXstar SCSI tape
literal BTD$K_KA420_TAPE = 37;          !  PVAX SCSI tape
literal BTD$K_DISK9 = 38;               !  Disk on 009
literal BTD$K_SII = 39;                 !  Embedded DSSI controller
literal BTD$K_SHAC = 41;                !  Single chip DSSI adapter.
literal BTD$K_SCSI_5380_DISK = 42;      !  NCR 5380 SCSI disk (PVAX)
literal BTD$K_HSX = 43;
literal BTD$K_KDM70 = 43;
literal BTD$K_HSXTAPE = 44;
literal BTD$K_KDM70TAPE = 44;
literal BTD$K_SWIFT = 45;               !  Another embedded DSSI controller-CIRRUS
literal BTD$K_SCSI_53C94_DISK = 46;
literal BTD$K_SCSI_53C94_TAPE = 47;
literal BTD$K_CONSOLE = 64;             !  Console block storage device
!  Network boot devices (96-103)
literal BTD$K_NET_DLL = 96;             !  Start of network boot devices
!  Codes 96-127 reserved
literal BTD$K_QNA = 96;                 !  DEQNA
literal BTD$K_UNA = 97;                 !  DEUNA
literal BTD$K_AIE_NI = 98;              !  AIE/NI
literal BTD$K_LANCE = 99;               !  LANCE NI chip
literal BTD$K_KA410_NI = 99;            !  VAXstar NI (LANCE chip)
literal BTD$K_KA420_NI = 99;            !  PVAX NI (LANCE chip)
literal BTD$K_SGEC = 100;               !  SGEC chip
literal BTD$K_SERVER_DEBNA = 101;       !  NI-CDROM server
literal BTD$K_SERVER_DEBNI = 102;       !  NI-CDROM server
literal BTD$K_SERVER_XNA = 103;         !  NI-CDROM server
literal BTD$K_DEBNI = 104;              !  DEBNI
literal BTD$K_DEMNA = 105;              !  DEMNA
literal BTD$K_KA520_NI = 106;           !  CIRRUS NI
literal BTD$K_SERVER_QNA = 107;         !  NI-CDROM server
literal BTD$K_SERVER_AIE_NI = 108;      !  NI-CDROM server
literal BTD$K_SERVER_LANCE = 109;       !  NI-CDROM server
literal BTD$K_SERVER_SGEC = 110;        !  NI-CDROM server
literal BTD$K_SERVER_KA520_NI = 111;    !  NI-CDROM server
literal BTD$K_DEMFA = 112;              !  DEMFA
literal BTD$K_SERVER_DEMFA = 113;       !  NI-CDROM server
literal BTD$K_DEFZA = 114;              !  DEFZA
literal BTD$K_SERVER_DEFZA = 115;       !  NI-CDROM server
literal BTD$K_PMAD = 116;               !  PMAD
literal BTD$K_SERVER_PMAD = 117;        !  NI-CDROM server
literal BDT$K_TGEC = 118;               !  TGEC ethernet chip
literal BTD$K_SERVER_TGEC = 119;        !  NI-CDROM server
literal BDT$K_DEANA = 120;              !  Futurebus to Ethernet
literal BTD$K_SERVER_DEANA = 121;       !  NI-CDROM server
literal BTD$K_NETWORK_BOOT = 128;       !  Generic boot over NI
literal BTD$K_NISCS = 128;              !  SCS disk over NI
 
!*** MODULE $BUSDEF ***
! 
!  Bus Type definitions.          
! 
!  DEFINE Bus Types -- used in BUSARRAY$L_BUS_TYPE and 
!                           CMDTABLE$L_BUS_TYPE
! 
!  DEFINE BUS TYPES
! 
literal BUS$_FBUS = 1;
literal BUS$_XMI = 2;
literal BUS$_LBUS = 3;
literal BUS$_TURBO = 4;
literal BUS$_CBUS = 5;
literal BUS$_LSB = 6;
literal BUS$_NI = 7;
literal BUS$_CI = 8;
literal BUS$_FDDI = 9;
literal BUS$_SCSI = 10;
literal BUS$_DSSI = 11;
literal BUS$_KDM70 = 12;
literal BUS$_GENXMI = 13;
literal BUS$_BUSLESS_SYSTEM = 14;
literal BUS$_COREIO = 15;
literal BUS$_EISA = 16;
literal BUS$_VTI_COMBO = 17;
literal BUS$_VME = 18;
literal BUS$_PCI = 19;
literal BUS$_ISA = 20;
literal BUS$_XBUS = 21;
literal BUS$_THIRDPARTY0 = 22;
literal BUS$_THIRDPARTY1 = 23;
literal BUS$_THIRDPARTY2 = 24;
literal BUS$_THIRDPARTY3 = 25;
literal BUS$_THIRDPARTY4 = 26;
literal BUS$_THIRDPARTY5 = 27;
literal BUS$_THIRDPARTY6 = 28;
literal BUS$_THIRDPARTY7 = 29;
literal BUS$_TLSB = 30;
literal BUS$_TIOP = 31;
literal BUS$_ITIOP = 32;
literal BUS$_PCMCIA = 33;
 
!*** MODULE $BUSARRAYDEF ***
! +
!  Bus Array -- each node on a bus has an entry in the Bus Array for that bus.
! 
!    A Bus Array is pointed to by a field in the ADP.  A Bus Array consists 
!    of a header and a number of entries (one for each node on the bus or one
!    for each channel on an adapter.
!    Each entry contains info on the node, such as hardware id, base CSR
!    address, a pointer to a data structure, and node number.
! 
! -
!  Define Bus Array Header
literal BUSARRAYHEADER$K_LENGTH = 24;   !  Keep length before ENTRY_LIST, which has no real
!  length
literal BUSARRAY$S_BUSARRAYHEADER = 24; !  Old size name
literal BUSARRAY$S_BUSARRAY_HEADER = 32;
macro BUSARRAY$PS_PARENT_ADP = 0,0,32,1 %; !  Point back to ADP
macro BUSARRAY$W_SIZE = 8,0,16,0 %;     !  Structure size in bytes
macro BUSARRAY$B_TYPE = 10,0,8,0 %;     !  Structure type
macro BUSARRAY$B_SUBTYPE = 11,0,8,0 %;  !  Structure subtype
macro BUSARRAY$L_BUS_TYPE = 12,0,32,0 %; !  Bus Type code
macro BUSARRAY$L_BUS_NODE_CNT = 16,0,32,0 %; !  Number of entries in Bus Array
macro BUSARRAY$Q_ENTRY_LIST = 24,0,0,1 %;
literal BUSARRAY$S_ENTRY_LIST = 8;      !  Bus Array entries start
!  at entry_list
!  Define Bus Array Entry
literal BUSARRAY$M_NO_RECONNECT = %X'1';
literal BUSARRAY$S_BUSARRAYENTRY = 48;
macro BUSARRAY$Q_HW_ID = 0,0,0,0 %;
literal BUSARRAY$S_HW_ID = 8;           !  Hardware ID.
macro BUSARRAY$Q_CSR = 8,0,0,0 %;
literal BUSARRAY$S_CSR = 8;             !  Base CSR address
macro BUSARRAY$L_NODE_NUMBER = 16,0,32,0 %; !  Node or channel number
macro BUSARRAY$L_FLAGS = 20,0,32,0 %;   !  Flags
macro BUSARRAY$V_NO_RECONNECT = 20,0,1,0 %;
macro BUSARRAY$PS_CRB = 24,0,32,1 %;    !  Pointer to data structure
macro BUSARRAY$PS_ADP = 28,0,32,1 %;    !  Pointer to data structure
macro BUSARRAY$L_AUTOCONFIG = 32,0,32,0 %; !  Reserved for Autoconfigure
macro BUSARRAY$PS_AUTOCONFIG = 32,0,32,1 %; !  Reserved for Autoconfigure
macro BUSARRAY$L_CTRLLTR = 36,0,32,0 %;
macro BUSARRAY$B_CTRLLTR = 36,0,8,0 %;
!  Make sure the following quadword stays aligned properly
macro BUSARRAY$Q_BUS_SPECIFIC = 40,0,0,0 %;
literal BUSARRAY$S_BUS_SPECIFIC = 8;
macro BUSARRAY$L_BUS_SPECIFIC_L = 40,0,32,0 %;
macro BUSARRAY$PS_BUS_SPECIFIC_L = 40,0,32,1 %;
macro BUSARRAY$L_BUS_SPECIFIC_H = 44,0,32,0 %;
macro BUSARRAY$PS_BUS_SPECIFIC_H = 44,0,32,1 %;
literal BUSARRAYENTRY$K_LENGTH = 48;
 
!*** MODULE $C2DEF ***
! +
!  C2 - C2 Subset Definitions
! 
!  This structures maps the bits in the SECURITY_POLICY SYSGEN parameter that
!  are used to enable or remove features that have not been formally evaluated
!  by the NCSC under our C2/B1 VMS/SEVMS evaluation.
! 
! -
literal C2$M_ALLOW_DISPLAY_POSTSCRIPT = %X'1';
literal C2$M_ALLOW_MULTIPLE_DECW_USERS = %X'2';
literal C2$M_ALLOW_ALTERNATE_TRANSPORTS = %X'4';
literal C2$M_ALLOW_SPAN_JOB_TREES = %X'8';
literal C2$M_LOCAL_UPDATE = %X'10';
literal C2$M_LOCAL_PROFILE = %X'20';
literal C2$M_ALLOW_CAPTIVE_SPAWN = %X'40';
literal C2$M_COMPRESS_MAC_STRINGS = %X'80';
literal C2$S_SECPOLDEF = 4;
literal C2$S_SECPOL = 4;
macro C2$L_SECURITY_POLICY = 0,0,32,0 %;
macro C2$V_ALLOW_DISPLAY_POSTSCRIPT = 0,0,1,0 %; !  allow display postscript extensions
macro C2$V_ALLOW_MULTIPLE_DECW_USERS = 0,1,1,0 %; !  allow multiple username to connect to DECW$SERVER
macro C2$V_ALLOW_ALTERNATE_TRANSPORTS = 0,2,1,0 %; !  allow unevaluated transports
macro C2$V_ALLOW_SPAN_JOB_TREES = 0,3,1,0 %; !  allow $SIGPRC to span job trees
!  The following bits control profile management for cluster object
!  when the object server is unavailable.  Setting these bits will
!  allow these objects to have inconsistent profiles within a security
!  domain (cluster).
macro C2$V_LOCAL_UPDATE = 0,4,1,0 %;    !  allow local profile changes
macro C2$V_LOCAL_PROFILE = 0,5,1,0 %;   !  allow local object creation
macro C2$V_ALLOW_CAPTIVE_SPAWN = 0,6,1,0 %; !  allow SPAWN or LIB$SPAWN in CAPTIVE accounts
macro C2$V_COMPRESS_MAC_STRINGS = 0,7,1,0 %; !  compress MAC category strings (SEVMS)
 
!*** MODULE $CADEF ***
! +
!  CONDITIONAL ASSEMBLY PARAMETER DEFINITIONS
! 
!         A NONZERO PARAMETER VALUE INDICATES PRESENCE OF THE FEATURE.
!         A ZERO PARAMETER VALUE INDICATES ABSENCE OF THE FEATURE
! 
!         ALL PARAMETERS MUST BE DEFINED
! -
literal CA$_SIMULATOR = 1;              ! INCLUDE SIMULATOR SUPPORT CODE 
literal CA$_MEASURE = 2;                ! INCLUDE PERFORMANCE MEASUREMENT HOOKS 
literal CA$_MEASURE_IOT = 4;            ! INCLUDE I/O TRANSACTION DATA COLLECTION 
 
!*** MODULE $CANDEF ***
! +
!  CAN - DEFINE DRIVER CANCEL ROUTINE REASON CODES
! 
!  THESE CODES ARE PASSED TO THE CANCEL ROUTINE OF A DRIVER SO THAT
!  THE ROUTINE CAN DISTINGUISH BETWEEN CALLS FROM $DASSGN AND $CANCEL.
! 
! -
literal CAN$C_CANCEL = 0;               ! CANCEL INVOKED DUE TO $CANCEL SERVICE 
literal CAN$C_DASSGN = 1;               ! CANCEL INVOKED DUE TO $DASSGN SERVICE 
literal CAN$C_AMBXDGN = 2;              ! CANCEL INVOKED DUE TO MB DISASSOCIATION
literal CAN$C_MSCPSERVER = 3;           ! CANCEL INVOKED BY MSCP SERVER DUE TO
!        CONNECTION LOSS TO CLIENT NODE
 
!*** MODULE $CDRPDEF ***
! +
!  CDRP - CLASS DRIVER I/O REQUEST PACKET
! 
!  This structure contains within it, at negative offsets, a full IRP.
!  For this reason all IRP fields must be at the same relative offsets
!  as the corresponding fields in the IRP.
! 
! -
literal CDRP$M_WLE_REUSE = %X'1';
literal CDRP$M_WLE_SUPWL = %X'2';
literal CDRP$K_CDRPBASE = 0;
literal CDRP$C_CDRPBASE = 0;
literal CDRP$C_RSPID_WAIT = 1;          !   Waiting for Rspid Resource
literal CDRP$C_POOL_WAIT = 2;           !   Waiting for Pool Resource
literal CDRP$C_CREDIT_WAIT = 3;         !   Waiting for Credit Resource
literal CDRP$C_BD_WAIT = 4;             !   Waiting for Buffer Descriptor Resource
literal CDRP$M_SYSAP_STALLED = %X'1';
literal CDRP$K_LENGTH = 72;
literal CDRP$C_LENGTH = 72;
! 	CDRP extensions
literal CDRP$K_BT_LEN = 88;
literal CDRP$C_BT_LEN = 88;
literal CDRP$M_CAND = %X'1';
literal CDRP$M_CANIO = %X'2';
literal CDRP$M_ERLIP = %X'4';
literal CDRP$M_PERM = %X'8';
literal CDRP$M_HIRT = %X'10';
literal CDRP$M_DENSCK = %X'20';
literal CDRP$M_CONNWALK = %X'40';
literal CDRP$M_COPYSHAD = %X'80';
literal CDRP$M_IVCMD = %X'100';
literal CDRP$M_WALK_2P = %X'200';
literal CDRP$M_LOC_ONLY = %X'400';
literal CDRP$M_LOADBAL = %X'800';
literal CDRP$K_CD_LEN = 96;
literal CDRP$C_CD_LEN = 96;
literal CDRP$K_NORMAL = 0;              !  The standard case (particulary no block xfer)
literal CDRP$K_REQUESTOR = 1;           !  Block transfer requestor
literal CDRP$K_PARTNER = 2;             !  Block transfer partner, active
literal CDRP$K_PART_IDLE = 3;           !  Block transfer partner, idle
literal CDRP$K_REQ_MAP = 4;             !  Block transfer requestor, waiting for buffer handle
literal CDRP$K_PART_MAP = 5;            !  Block transfer partner, waiting for buffer handle
literal CDRP$K_CNX_MSG = 0;             !  Send message
literal CDRP$K_CNX_BLKRD = 1;           !  Block read
literal CDRP$K_CNX_BLKWRT = 2;          !  Block write
literal CDRP$K_CNX_REQ = 3;             !  Request block xfer
literal CDRP$K_CM_LENGTH = 136;
literal CDRP$K_VCNX_NORMAL = 0;         !  The standard case (particulary no block xfer)
literal CDRP$K_VCNX_REQUESTOR = 1;      !  Block transfer requestor
literal CDRP$K_VCNX_PARTNER = 2;        !  Block transfer partner, active
literal CDRP$K_VCNX_PART_IDLE = 3;      !  Block transfer partner, idle
literal CDRP$K_VCNX_REQ_MAP = 4;        !  Block transfer requestor, waiting for buffer handle
literal CDRP$K_VCNX_PART_MAP = 5;       !  Block transfer partner, waiting for buffer handle
literal CDRP$M_CDRP_PARTNER_VALID = %X'1';
literal CDRP$M_XMT_CDRP_BLKXFR = %X'2';
literal CDRP$M_XMT_REQ_SUCCESS = %X'4';
literal CDRP$M_XMT_XFER_DONE = %X'8';
literal CDRP$M_PARTNER_ABORT = %X'10';
literal CDRP$M_XMT_NOTIFIED = %X'20';
literal CDRP$M_XMT_SEGMENT = %X'40';
literal CDRP$M_XMT_MUX_MSG = %X'80';
literal CDRP$K_VCNX_MSG = 0;            !  Normal messages
literal CDRP$K_VCNX_BLKRD = 1;          !  Block transfer read 
literal CDRP$K_VCNX_BLKWRT = 2;         !  Block transfer write
literal CDRP$K_VCNX_REQ = 3;            !  Requestor
literal CDRP$K_SCATP_LENGTH = 160;
literal CDRP$K_IDLE = 0;                !  CDRP is idle
literal CDRP$K_ALLOC_MSG_BUF = 1;       !  Allocate message in progress
literal CDRP$K_RECYCLE_MSG_BUF = 2;     !  Message is being recycled
literal CDRP$K_MAP = 3;                 !  Map wait is in progress
literal CDRP$K_SEND_DATA = 4;           !  Block transfer is in progress
literal CDRP$K_SEND_MSG = 5;            !  Message sending in progress
literal CDRP$K_ALLOC_RSPID = 6;         !  Allocate rspid in progress
literal CDRP$K_SDA_LEN = 148;
literal CDRP$C_SDA_LEN = 148;
literal CDRP$S_CDRP = 312;
macro CDRP$L_IOQFL = -152,0,32,1 %;     ! I/O QUEUE FORWARD LINK 
macro CDRP$L_IOQBL = -148,0,32,1 %;     ! I/O QUEUE BACKWARD LINK 
macro CDRP$W_IRP_SIZE = -144,0,16,0 %;  ! SIZE OF IRP IN BYTES 
macro CDRP$B_IRP_TYPE = -142,0,8,0 %;   ! STRUCTURE TYPE FOR IRP 
macro CDRP$B_RMOD = -141,0,8,0 %;       ! ACCESS MODE OF REQUEST 
macro CDRP$L_PID = -140,0,32,0 %;       ! PROCESS ID OF REQUESTING PROCESS 
macro CDRP$L_AST = -136,0,32,1 %;       ! ADDRESS OF AST ROUTINE 
macro CDRP$L_ASTPRM = -132,0,32,0 %;    ! AST PARAMETER 
macro CDRP$L_WIND = -120,0,32,1 %;      ! ADDRESS OF WINDOW BLOCK
macro CDRP$L_MIRP = -120,0,32,1 %;      ! LINK TO MASTER IRP
macro CDRP$L_KAST = -120,0,32,1 %;      ! PIGGY BACK KERNEL AST ADDRESS
macro CDRP$L_UCB = -116,0,32,1 %;       ! ADDRESS OF DEVICE UCB 
macro CDRP$B_EFN = -112,0,8,0 %;        ! EVENT FLAG NUMBER AND EVENT GROUP 
macro CDRP$B_PRI = -111,0,8,0 %;        ! BASE PRIORITY OF REQUESTING PROCESS 
macro CDRP$B_CLN_INDX = -110,0,8,0 %;   ! Shadow Clone membership index
macro CDRP$B_WLG_FLAGS = -109,0,8,0 %;  !  These flags are shared by DUDRIVER and SHDRIVER and MSCP.
macro CDRP$V_WLE_REUSE = -109,0,1,0 %;  !  Reuse writelog entry
macro CDRP$V_WLE_SUPWL = -109,1,1,0 %;  !  Supplementary writelog
! 
! 
macro CDRP$L_IOSB = -108,0,32,1 %;      !  ADDRESS OF I/O STATUS DOUBLE LONGWORD
macro CDRP$L_CLN_WLE = -108,0,32,0 %;   !  write log entry
macro CDRP$L_CHAN = -104,0,32,0 %;      !  Process I/O channel
macro CDRP$L_EXTEND = -100,0,32,1 %;    !  ADDRESS OF IRPE 
macro CDRP$Q_STATUS = -96,0,0,0 %;
literal CDRP$S_STATUS = 8;
macro CDRP$L_STS = -96,0,32,0 %;        !  Request status
macro CDRP$L_STS2 = -92,0,32,0 %;       !  Second status word
macro CDRP$L_SVAPTE = -88,0,32,1 %;     ! SYSTEM VIRTUAL ADDRESS OF FIRST PTE 
macro CDRP$L_BCNT = -84,0,32,0 %;       ! BYTE COUNT OF TRANSFER 
macro CDRP$L_BOFF = -80,0,32,0 %;       !  Byte offset
macro CDRP$PS_KPB = -76,0,32,1 %;       !  Pointer to KP block
macro CDRP$L_IOST1 = -72,0,32,0 %;      ! FIRST I/O STATUS LONGWORD (FOR I/O POST) 
macro CDRP$L_MEDIA = -72,0,32,0 %;      ! MEDIA ADDRESS 
macro CDRP$L_IOST2 = -68,0,32,0 %;      ! SECOND I/O STATUS LONGWORD 
macro CDRP$L_TT_TERM = -68,0,32,0 %;    ! ADDRESS OF READ TERMINATORS MASK 
macro CDRP$B_CARCON = -68,0,8,0 %;      ! CARRIAGE CONTROL 
macro CDRP$Q_NT_PRVMSK = -64,0,0,0 %;
literal CDRP$S_NT_PRVMSK = 8;           !  PRIVILEGE MASK FOR DECNET 
macro CDRP$L_ABCNT = -64,0,32,0 %;      !  ACCUMULATED BYTES TRANSFERED 
macro CDRP$W_TT_PRMPT = -64,0,16,0 %;   !  PROMPT SIZE 
macro CDRP$L_OBCNT = -60,0,32,0 %;      !  ORIGINAL TRANSFER BYTE COUNT 
macro CDRP$L_FUNC = -56,0,32,0 %;       !  I/O function code
macro CDRP$L_SEGVBN = -52,0,32,0 %;     !  VIRTUAL BLOCK NUMBER OF CURRENT SEGMENT 
macro CDRP$L_DIAGBUF = -48,0,32,1 %;    !  DIAGNOSTIC BUFFER ADDRESS 
macro CDRP$L_SEQNUM = -44,0,32,0 %;     !  SEQUENCE NUMBER
macro CDRP$L_DCD_SRC_UCB = -44,0,32,0 %; !  DISK COPY DATA SOURCE UCB
macro CDRP$L_ARB = -40,0,32,1 %;        !  ACCESS RIGHTS BLOCK ADDRESS
macro CDRP$L_KEYDESC = -36,0,32,1 %;    !  ADDRESS OF ENCRYPTION DESCRIPTOR
macro CDRP$L_WLE_PTR = -36,0,32,0 %;    !  Clone Write log index
macro CDRP$B_CPY_MODE = -36,0,8,0 %;    !  Copy mode identifier
macro CDRP$L_QIO_P1 = -32,0,32,0 %;     !  QIO argument #1
macro CDRP$L_QIO_P2 = -28,0,32,0 %;     !  QIO argument #2
macro CDRP$L_QIO_P3 = -24,0,32,0 %;     !  QIO argument #3
macro CDRP$L_QIO_P4 = -20,0,32,0 %;     !  QIO argument #4
macro CDRP$L_QIO_P5 = -16,0,32,0 %;     !  QIO argument #5
macro CDRP$L_QIO_P6 = -12,0,32,0 %;     !  QIO argument #6
macro CDRP$PS_FDT_CONTEXT = -8,0,32,1 %; !  Contains addr of the
!   FDT Context structu
macro CDRP$PS_CCB = -4,0,32,1 %;        !  Pointer to CCB for this I/O
!  ALL FIELDS INSERTED ABOVE THIS POINT IN THE CDRP
!  MUST BE CHANGED IN THE IRPDEF.SDL FILE.
! 
! 
macro CDRP$L_FQFL = 0,0,32,1 %;         !  Fork Queue FLINK 
macro CDRP$L_FQBL = 4,0,32,1 %;         !  Fork Queue Blink 
macro CDRP$W_CDRPSIZE = 8,0,16,0 %;     !  Size field for positive section only 
macro CDRP$B_CD_TYPE = 10,0,8,0 %;      !  Type, always of interest 
macro CDRP$B_FLCK = 11,0,8,0 %;         !  Fork lock
macro CDRP$L_FPC = 12,0,32,1 %;         !  Fork PC 
macro CDRP$Q_FR3 = 16,0,0,1 %;
literal CDRP$S_FR3 = 8;                 !  Fork R3 
macro CDRP$Q_FR4 = 24,0,0,1 %;
literal CDRP$S_FR4 = 8;                 !  Fork R4 
macro CDRP$L_SAVD_RTN = 32,0,32,1 %;    !  Saved return address from level 1 JSB 
macro CDRP$L_MSG_BUF = 36,0,32,1 %;     !  Address of allocated MSCP buffer 
macro CDRP$L_RSPID = 40,0,32,0 %;       !  Allocated Request ID 
macro CDRP$L_CDT = 44,0,32,1 %;         !  Address of Connection Descriptor Table 
macro CDRP$Q_RES_WAIT_STATE = 48,0,0,0 %;
literal CDRP$S_RES_WAIT_STATE = 8;      !  SCS Resource Wait State Information
macro CDRP$L_WAIT_STATE = 48,0,32,0 %;  !  SCS Resource Wait State: >0 = SCS Wait, <0 = Port-specific Wait
!  Possible SCS states:
macro CDRP$L_SCS_STATE = 52,0,32,0 %;   !  SCS State bits:
macro CDRP$V_SYSAP_STALLED = 52,0,1,0 %; !   SYSAP context has been saved in CDRP fork block
macro CDRP$L_SCS_STALL_DATA = 56,0,32,0 %; !  Data cell used by SCS to save data over a stall
macro CDRP$L_RWCPTR = 60,0,32,1 %;      !  RWAITCNT pointer 
macro CDRP$L_BD_ADDR = 64,0,32,1 %;     !  Address of Buffer Descriptor that maps I/O buffer
macro CDRP$L_LBUFH_AD = 68,0,32,1 %;    !  Local BUFfer Handle ADress 
! 	Block Transfer Extension
macro CDRP$L_LBOFF = 72,0,32,0 %;       !  Local Byte OFFset 
macro CDRP$L_RBUFH_AD = 76,0,32,1 %;    !  Remote BUFfer Handle ADress 
macro CDRP$L_RBOFF = 80,0,32,0 %;       !  Remote Byte OFFset 
macro CDRP$L_XCT_LEN = 84,0,32,0 %;     !  Transfer length in bytes 
! 	Class Driver Extension
macro CDRP$T_LBUFHNDL = 72,0,0,0 %;
literal CDRP$S_LBUFHNDL = 12;           !  Local buffer handle 
macro CDRP$L_UBARSRCE = 84,0,32,0 %;    !  Scratch Cell used for DU/TUDRIVER convenience
macro CDRP$L_DUTUFLAGS = 88,0,32,0 %;   !  Class driver status flags:
macro CDRP$V_CAND = 88,0,1,0 %;         !   canceled I/O request
macro CDRP$V_CANIO = 88,1,1,0 %;        !   cancel operation I/O request
macro CDRP$V_ERLIP = 88,2,1,0 %;        !   error log in progress
macro CDRP$V_PERM = 88,3,1,0 %;         !   CDDB permanent IRP/CDRP
macro CDRP$V_HIRT = 88,4,1,0 %;         !   HIRT permanent IRP/CDRP
macro CDRP$V_DENSCK = 88,5,1,0 %;       !   Tape density check required
macro CDRP$V_CONNWALK = 88,6,1,0 %;     !   Thread walking connections
macro CDRP$V_COPYSHAD = 88,7,1,0 %;     !   CDRP represents an active IO$_COPYSHAD
macro CDRP$V_IVCMD = 88,8,1,0 %;        !   Invalid command processing in progress
macro CDRP$V_WALK_2P = 88,9,1,0 %;      !   Thread trying secondary path before walking other connections
macro CDRP$V_LOC_ONLY = 88,10,1,0 %;    !   VMS MSCPservers are to be ignored during this connection walk
macro CDRP$V_LOADBAL = 88,11,1,0 %;     !   A load balancing pass of connection walking is active
macro CDRP$W_DUTUCNTR = 92,0,16,0 %;    !  General purpose counter
macro CDRP$W_ENDMSGSIZ = 94,0,16,0 %;   !  Size of most recent MSCP end message
! 	Connection management extension
macro CDRP$L_VAL1 = 72,0,32,0 %;        !  data value 1
macro CDRP$L_VAL2 = 76,0,32,0 %;        !  data value 2
macro CDRP$L_VAL3 = 80,0,32,0 %;        !  data value 3
macro CDRP$L_VAL4 = 84,0,32,0 %;        !  data value 4
macro CDRP$L_VAL5 = 88,0,32,0 %;        !  data value 5
macro CDRP$L_VAL6 = 92,0,32,0 %;        !  data value 6
macro CDRP$L_VAL7 = 96,0,32,0 %;        !  data value 7
macro CDRP$L_VAL8 = 100,0,32,0 %;       !  data value 8
macro CDRP$L_VAL9 = 104,0,32,0 %;       !  data value 9
macro CDRP$L_VAL10 = 108,0,32,0 %;      !  data value 10
macro CDRP$L_VAL11 = 112,0,32,0 %;      !  data value 11
macro CDRP$L_VAL12 = 116,0,32,0 %;      !  data value 12
macro CDRP$L_FILL_VAL = 72,0,0,1 %;
literal CDRP$S_FILL_VAL = 20;
macro CDRP$L_CNXSVAPTE = 92,0,32,0 %;   !  Block SVAPTE
macro CDRP$L_CNXBCNT = 96,0,32,0 %;     !  Block xfer length
macro CDRP$W_CNXBOFF = 100,0,16,0 %;    !  Block buffer offset
macro CDRP$B_CNXRMOD = 102,0,8,0 %;     !  Block access mode
macro CDRP$B_CLTSTS = 103,0,8,0 %;      !  A client's status field
macro CDRP$L_MSGBLD = 120,0,32,1 %;     !  Address of MSG BUILD routine
macro CDRP$L_SAVEPC = 124,0,32,0 %;     !  Caller's saved PC
macro CDRP$W_SENDSEQNM = 128,0,16,0 %;  !  Message sequence number
macro CDRP$B_CNXSTATE = 130,0,8,0 %;    !  CNX message state
!  Possible states:
macro CDRP$B_CNX_FUNCTION = 131,0,8,0 %; !  Function code
!  Possible states:
macro CDRP$L_RETRSPID = 132,0,32,0 %;   !  RSPID to return
! 	IPC SCA Transport extension
macro CDRP$L_SCATP_VAL1 = 72,0,32,0 %;  !  data value 1
macro CDRP$L_SCATP_VAL2 = 76,0,32,0 %;  !  data value 2
macro CDRP$L_SCATP_VAL3 = 80,0,32,0 %;  !  data value 3
macro CDRP$L_SCATP_VAL4 = 84,0,32,0 %;  !  data value 4
macro CDRP$L_SCATP_VAL5 = 88,0,32,0 %;  !  data value 5
macro CDRP$L_SCATP_VAL6 = 92,0,32,0 %;  !  data value 6
macro CDRP$L_SCATP_VAL7 = 96,0,32,0 %;  !  data value 7
macro CDRP$L_SCATP_VAL8 = 100,0,32,0 %; !  data value 8
macro CDRP$L_VCNXSVAPTE = 92,0,32,0 %;  !  Block SVAPTE
macro CDRP$L_VCNXBCNT = 96,0,32,0 %;    !  Block xfer length	NOTE these two fields are the
macro CDRP$W_VCNXBOFF = 100,0,16,0 %;   !  Block buffer offset  NOTE other way round on VAX
macro CDRP$B_VCNXRMOD = 102,0,8,0 %;    !  Block access mode
macro CDRP$B_SCATP_CLTSTS = 103,0,8,0 %; !  A client's status field
macro CDRP$L_SCATP_MSGBLD = 104,0,32,1 %; !  Address of MSG BUILD routine
macro CDRP$L_SCATP_SAVEPC = 108,0,32,1 %;
!  Caller's saved PC
macro CDRP$W_SCATP_SENDSEQNM = 112,0,16,0 %; !  Message sequence number
macro CDRP$B_VCNXSTATE = 114,0,8,0 %;   !  VCNX message state
!  Possible states:
macro CDRP$B_SCATP_FLAGS = 115,0,8,0 %; !  FLAGS byte
macro CDRP$V_CDRP_PARTNER_VALID = 115,0,1,0 %; !  The CDRP_PARTNER has valid
!  data.
macro CDRP$V_XMT_CDRP_BLKXFR = 115,1,1,0 %; !  This is block transfer CDRP
macro CDRP$V_XMT_REQ_SUCCESS = 115,2,1,0 %; !  The transmit request 
!  processing is done
!  successfully for this CDRP.
macro CDRP$V_XMT_XFER_DONE = 115,3,1,0 %; !  The data transfer  is 
!  completed for this CDRP.
macro CDRP$V_PARTNER_ABORT = 115,4,1,0 %; !  This block transfer 
!  request is aborted by 
!  partner node.
macro CDRP$V_XMT_NOTIFIED = 115,5,1,0 %; !  Indicates that the associated
!  VCRP has been returned to
!  the user
macro CDRP$V_XMT_SEGMENT = 115,6,1,0 %; !  Indicates this is part
!  of a larger message
macro CDRP$V_XMT_MUX_MSG = 115,7,1,0 %; !  Indicates this message
!  has Session multiplexed
!  link protocol header
! 
! 
macro CDRP$L_SCATP_RETRSPID = 116,0,32,0 %; !  RSPID to return
macro CDRP$L_CDRP_PARTNER = 120,0,32,1 %; !  Partner's CDRP/RCVREQ
macro CDRP$L_VCRP = 124,0,32,1 %;       !  VCRP addr
macro CDRP$L_TLCB = 128,0,32,1 %;       !  TLCB address
macro CDRP$L_RCVREQ = 132,0,32,1 %;     !  RCVREQ address
macro CDRP$L_SAVE_RET = 136,0,32,0 %;   !  Saved caller's 
!  return  PC.
macro CDRP$L_TLCBFQFL = 140,0,32,1 %;   !  Fork queue (in TLCB) flink
macro CDRP$L_TLCBFQBL = 144,0,32,1 %;   !  Fork queue (in TLCB) blink
macro CDRP$L_DISC_REASON = 148,0,32,0 %; !  Disconnect reason
!  for DI msg.
macro CDRP$L_SAVED_STATUS = 152,0,32,0 %; !  Save the status for the VCRP
macro CDRP$B_VCNX_FUNCTION = 156,0,8,0 %; !  VCNX function
!  Possible functions:
! 	Remote SDA Extension
!  Reserve space for block transfer extension
macro CDRP$L_MYSVAPTE = 88,0,32,0 %;    !  System Virtual Address PTE
macro CDRP$L_MYBCNT = 92,0,32,0 %;      !  Byte Count
macro CDRP$L_MYBOFF = 96,0,32,0 %;      !  Byte Offset
macro CDRP$T_MYBUFHDL = 100,0,0,0 %;
literal CDRP$S_MYBUFHDL = 12;           !  Buffer handle 
macro CDRP$L_SAVD_MSG_BUF = 112,0,32,0 %; !  Saved message buffer address
!  during a BLOCK Transfer
macro CDRP$L_SAVD_MSG_SIZ = 116,0,32,0 %; !  Saved message size
macro CDRP$L_VIRT_ADDR = 120,0,32,0 %;  !  Virtual Address
macro CDRP$L_SDA_BCNT = 124,0,32,0 %;   !  Byte Count
macro CDRP$L_SDA_PID = 128,0,32,0 %;    !  Process ID
macro CDRP$L_CPU = 132,0,32,0 %;        !  Target CPU
macro CDRP$Q_PTE = 136,0,0,0 %;
literal CDRP$S_PTE = 8;                 !  Target PTE
macro CDRP$W_STATE = 144,0,16,0 %;      !  CDRP state
!  Possible states:
macro CDRP$W_BLK_STATUS = 146,0,16,0 %; !  Block transfer status
literal CDRP$S_CDRPDEF = 312;           !  Old size name, synonym for CDRP$S_CDRP
 
!*** MODULE $CINDEF ***
! +
! 
!  Connect to interrupt definitions for QIO parameters
! 
! -
literal CIN$M_EFN = %X'1';
literal CIN$M_USECAL = %X'2';
literal CIN$M_REPEAT = %X'4';
literal CIN$M_AST = %X'8';
literal CIN$M_INIDEV = %X'10';
literal CIN$M_START = %X'20';
literal CIN$M_ISR = %X'40';
literal CIN$M_CANCEL = %X'80';
literal CIN$M_EFNUM = %X'FFFF0000';
literal CIN$S_CINDEF = 4;
literal CIN$S_CIN = 4;
macro CIN$V_EFN = 0,0,1,0 %;            !  Set event flag on interrupt. 
macro CIN$V_USECAL = 0,1,1,0 %;         !  Use CALL interface. 
macro CIN$V_REPEAT = 0,2,1,0 %;         !  Do repeated interrupt service. 
macro CIN$V_AST = 0,3,1,0 %;            !  Queue AST on interrupt. 
macro CIN$V_INIDEV = 0,4,1,0 %;         !  Device initialization to do. 
macro CIN$V_START = 0,5,1,0 %;          !  Start I/O routine. 
macro CIN$V_ISR = 0,6,1,0 %;            !  ISR to execute. 
macro CIN$V_CANCEL = 0,7,1,0 %;         !  Cancel I/O routine. 
macro CIN$V_EFNUM = 0,16,16,0 %;
literal CIN$S_EFNUM = 16;               !  Event flag number. 
literal CIN$S_CINDEF1 = 16;
literal CIN$S_CIN1 = 16;
macro CIN$L_INIDEV = 0,0,32,0 %;        !  Offset to device init routine. 
macro CIN$L_START = 4,0,32,0 %;         !  Offset to start device routine. 
macro CIN$L_ISR = 8,0,32,0 %;           !  Offset to interrupt service routine. 
macro CIN$L_CANCEL = 12,0,32,0 %;       !  Offset to cancel I/O routine. 
literal CIN$S_CINDEF2 = 8;
literal CIN$S_CIN2 = 8;
macro CIN$L_SPTCOUNT = 0,0,32,0 %;      !  Number of SPTs allocated. 
macro CIN$L_STARTVPN = 4,0,32,0 %;      !  Starting VPN allocated. 
macro CIN$L_STARTBIT = 4,0,32,0 %;      !  Starting bit in bitmap. 
 
!*** MODULE $CCBDEF ***
! +
!  CCB - CHANNEL CONTROL BLOCK
! 
!  THERE IS ONE CHANNEL CONTROL BLOCK FOR EACH SOFTWARE CHANNEL THAT A
!  PROCESS MAY INITIATE I/O REQUESTS ON. THE NUMBER OF SUCH I/O CHANNELS
!  IS DETERMINED BY THE FIXED NUMBER ASSIGNED TO A PROCESS PLUS ANY
!  ADDITIONAL CHANNELS REQUIRED BY THE IMAGE CURRENTLY BEING EXECUTED
!  BY THE PROCESS.
!      
! -
literal CCB$M_AMB = %X'1';
literal CCB$M_IMGTMP = %X'2';
literal CCB$M_RDCHKDON = %X'4';
literal CCB$M_WRTCHKDON = %X'8';
literal CCB$M_LOGCHKDON = %X'10';
literal CCB$M_PHYCHKDON = %X'20';
literal CCB$M_NOREADACC = %X'40';
literal CCB$M_NOWRITEACC = %X'80';
literal CCB$M_CLONE = %X'100';
literal CCB$S_CCB = 32;
macro CCB$L_UCB = 0,0,32,1 %;           ! ADDRESS OF ASSIGNED DEVICE UCB 
macro CCB$L_WIND = 4,0,32,1 %;          ! ADDRESS OF WINDOW BLOCK 
macro CCB$L_STS = 8,0,32,0 %;           ! CHANNEL STATUS 
macro CCB$V_AMB = 8,0,1,0 %;            !  MAILBOX ASSOCIATED WITH CHANNEL 
macro CCB$V_IMGTMP = 8,1,1,0 %;         !  IMAGE TEMPORARY
macro CCB$V_RDCHKDON = 8,2,1,0 %;       !  READ PROTECTION CHECK COMPLETED
macro CCB$V_WRTCHKDON = 8,3,1,0 %;      !  WRITE PROTECTION CHECK COMPLETED
macro CCB$V_LOGCHKDON = 8,4,1,0 %;      !  LOGICAL I/O ACCESS CHECK DONE
macro CCB$V_PHYCHKDON = 8,5,1,0 %;      !  PHYSICAL I/O ACCESS CHECK DONE
macro CCB$V_NOREADACC = 8,6,1,0 %;      !  READ ACCESS TO DEVICE DISABLED
macro CCB$V_NOWRITEACC = 8,7,1,0 %;     !  WRITE ACCESS TO DEVICE DISABLED
macro CCB$V_CLONE = 8,8,1,0 %;          !  Clone channel after Posix fork()
macro CCB$L_IOC = 12,0,32,0 %;          ! NUMBER OF OUTSTANDING I/O REQUESTS ON CHANNEL 
macro CCB$B_AMOD = 16,0,8,1 %;          ! ACCESS MODE THAT ASSIGNED CHANNEL 
macro CCB$L_DIRP = 20,0,32,1 %;         ! DEACCESS I/O REQUEST PACKET ADDRESS 
macro CCB$L_CHAN = 24,0,32,1 %;         !  associated channel number
macro CCB$W_CHAN = 24,0,16,0 %;
literal CCB$K_LENGTH = 32;              ! LENGTH OF CCB 
literal CCB$S_CCBDEF = 32;              ! OLD SIZE NAME, SYNONYM FOR CCB$S_CCB
 
!*** MODULE $CCDDEF ***
literal CCD$M_NOVALIDATE = %X'1';
literal CCD$M_NOEVENT = %X'2';
literal CCD$M_NORESET = %X'4';
literal CCD$M_SETTODEF = %X'8';
literal CCD$M_SETTOCUR = %X'10';
literal CCD$S_CODE_NOW = 8;             !  current size of code field
literal CCD$K_MAINT = 1;                !  CHARGE record
literal CCD$K_CHARGE = 8;               !  CHARGE record
literal CCD$K_DEFAULT = 16;             !  DEFAULT record
literal CCD$K_GRANT = 24;               !  GRANT record
literal CCD$S_USER_NOW = 12;            !  current size of user field
literal CCD$S_DEFAULT = 68;             !  size of DEFAULT record
literal CCD$S_GRANT = 68;               !  size of GRANT record
literal CCD$M_DISABLE = %X'1';
literal CCD$S_MAINT = 112;              !  size of MAINTenance record
literal CCD$S_CHARGE = 112;             !  size of CHARGE record
literal CCD$K_CTU_KEY = 0;              !  primary key
literal CCD$S_CTU_KEY = 66;             !  primary key size
literal CCD$K_UT_KEY = 1;               !  secondary key
literal CCD$S_UT_KEY = 34;              !  secondary key size
literal CCD$K_EQ = 0;                   !  EQ matching
literal CCD$K_EQNXT = 1;                !  EQNXT matching
literal CCD$S_CCDDEF = 112;
macro CCD$R_FUNCTION_MODIFIERS = 0,0,8,0 %;
literal CCD$S_FUNCTION_MODIFIERS = 1;   !  for $SET_CHARGE
macro CCD$V_NOVALIDATE = 0,0,1,0 %;     !  don't validate CC
macro CCD$V_NOEVENT = 0,1,1,0 %;        !  don't sink an event
macro CCD$V_NORESET = 0,2,1,0 %;        !  don't reset counters
macro CCD$V_SETTODEF = 0,3,1,0 %;       !  set to default CC
macro CCD$V_SETTOCUR = 0,4,1,0 %;       !  set to current CC
macro CCD$R_RECORD = 0,0,0,0 %;
literal CCD$S_RECORD = 112;             !  within charge code database
macro CCD$T_CODE = 0,0,0,0 %;
literal CCD$S_CODE = 32;                !  charge code name
macro CCD$L_TYPE = 32,0,32,0 %;         !  record type
macro CCD$T_USER = 36,0,0,0 %;
literal CCD$S_USER = 32;                !  user name
macro CCD$L_FLAGS = 68,0,32,0 %;        !  flags bits
macro CCD$V_DISABLE = 68,0,1,0 %;       !  disabled
macro CCD$Q_EXPIRY = 72,0,0,0 %;
literal CCD$S_EXPIRY = 8;               !  expiry date+time
macro CCD$T_DESC = 80,0,0,0 %;
literal CCD$S_DESC = 32;                !  description
 
!*** MODULE $CDDBDEF ***
! +
!  CDDB - Class Driver Data Block
! 
!  Auxiliary data block pointed at by the CRB$L_AUXSTRUC of an MSCP speaking
!  intelligent disk or tape controller.  There is one CDDB per such intelligent
!  controller.
! 
! -
literal CDDB$M_SNGLSTRM = %X'1';
literal CDDB$M_IMPEND = %X'2';
literal CDDB$M_INITING = %X'4';
literal CDDB$M_RECONNECT = %X'8';
literal CDDB$M_RESYNCH = %X'10';
literal CDDB$M_POLLING = %X'20';
literal CDDB$M_ALCLS_SET = %X'40';
literal CDDB$M_NOCONN = %X'80';
literal CDDB$M_RSTRTWAIT = %X'100';
literal CDDB$M_QUORLOST = %X'200';
literal CDDB$M_DAPBSY = %X'400';
literal CDDB$M_2PBSY = %X'800';
literal CDDB$M_BSHADOW = %X'1000';
literal CDDB$M_DISABLED = %X'2000';
literal CDDB$M_PATHMOVE = %X'4000';
literal CDDB$M_PRMBSY = %X'8000';
literal CDDB$M_DISC_PEND = %X'10000';
literal CDDB$M_CRNSET = %X'20000';
literal CDDB$M_FIRM_WREV = %X'40000';
literal CDDB$M_PRMBSY_CLEANUP_PERMITTED = %X'80000';
literal CDDB$K_LENGTH = 140;            ! Standard length of CDDB 
literal CDDB$C_LENGTH = 140;            ! Standard length of CDDB 
literal CDDB$S_CDDB = 144;
macro CDDB$L_CDRPQFL = 0,0,32,1 %;      ! Active CDRP Q FLINK 
macro CDDB$L_CDRPQBL = 4,0,32,1 %;      ! Active CDRP Q BLINK 
macro CDDB$W_SIZE = 8,0,16,0 %;         ! Size of CDDB in bytes 
macro CDDB$B_TYPE = 10,0,8,0 %;         ! Major structure type for Class Driver 
macro CDDB$B_SUBTYPE = 11,0,8,0 %;      !  CDDB structure subtype field 
macro CDDB$B_SYSTEMID = 12,0,0,0 %;
literal CDDB$S_SYSTEMID = 8;            ! 48 bit system ID. 
macro CDDB$L_STATUS = 20,0,32,0 %;      ! Status
macro CDDB$V_SNGLSTRM = 20,0,1,0 %;     !  Single stream mode after VC crash 
macro CDDB$V_IMPEND = 20,1,1,0 %;       !  IMmediate command PENDing 
macro CDDB$V_INITING = 20,2,1,0 %;      !  Currently initializing CONNECTION 
macro CDDB$V_RECONNECT = 20,3,1,0 %;    !  Currently re-CONNECTING to MSCP server 
macro CDDB$V_RESYNCH = 20,4,1,0 %;      !  re_CONNECT initiated by Class Driver 
macro CDDB$V_POLLING = 20,5,1,0 %;      !  Polling for units
macro CDDB$V_ALCLS_SET = 20,6,1,0 %;    !  Allocation class has been set
macro CDDB$V_NOCONN = 20,7,1,0 %;       !  CDDB currently has no connection
macro CDDB$V_RSTRTWAIT = 20,8,1,0 %;    !  Waiting to RESTART_NEXT_CDRP
macro CDDB$V_QUORLOST = 20,9,1,0 %;     !  CNXMAN quorum lost processing
macro CDDB$V_DAPBSY = 20,10,1,0 %;      !  DAP CDRP is busy
macro CDDB$V_2PBSY = 20,11,1,0 %;       !  Failover fork block is busy
macro CDDB$V_BSHADOW = 20,12,1,0 %;     !  Controller uses "bundled" shadowing
macro CDDB$V_DISABLED = 20,13,1,0 %;    !  Controller not in use by class driver action
macro CDDB$V_PATHMOVE = 20,14,1,0 %;    !  Closing connection for port load balance
macro CDDB$V_PRMBSY = 20,15,1,0 %;      !  Permanent CDRP in use
macro CDDB$V_DISC_PEND = 20,16,1,0 %;   !  Connection disconnect pending
macro CDDB$V_CRNSET = 20,17,1,0 %;      !  ctrl ref not being seen
macro CDDB$V_FIRM_WREV = 20,18,1,0 %;   !  firmware problem
macro CDDB$V_PRMBSY_CLEANUP_PERMITTED = 20,19,1,0 %; !  Permanent CDRP is busy but connection cleanup has permission to cleanup
!   the PRMCDRP without arbitrating for it.
macro CDDB$L_PDT = 24,0,32,1 %;         ! Port Descriptor Table address 
macro CDDB$L_CRB = 28,0,32,1 %;         ! CRB address 
macro CDDB$L_DDB = 32,0,32,1 %;         ! DDB address 
macro CDDB$Q_CNTRLID = 36,0,0,0 %;
literal CDDB$S_CNTRLID = 8;             ! Controller ID returned by MSCP END PACKET 
macro CDDB$B_CNTRLMDL = 42,0,8,0 %;     !  Controller model ! (byte 6 of controller id) 
macro CDDB$B_CNTRLCLS = 43,0,8,0 %;     !  Controller class (byte 7 of controller id) 
macro CDDB$W_CNTRLFLGS = 44,0,16,0 %;   ! Controller flags also returned by END PACKET 
macro CDDB$W_CNTRLTMO = 46,0,16,0 %;    ! Controller timeout also returned by END PACKET 
macro CDDB$L_OLDRSPID = 48,0,32,0 %;    ! RSPID of oldest outstanding MSCP command 
macro CDDB$L_OLDCMDSTS = 52,0,32,0 %;   ! Latest MSCP command status for this command 
macro CDDB$L_RSTRTCDRP = 56,0,32,1 %;   ! Addr of only active CDRP after VC re-establish 
macro CDDB$L_RETRYCNT = 60,0,32,0 %;    ! # retries remaining for CDRP after VC reset 
macro CDDB$L_DAPCOUNT = 64,0,32,0 %;    ! # DU$TMR loops until DAP_THREAD
macro CDDB$L_RSTRTCNT = 68,0,32,0 %;    ! # of resynch or connection error since boot
macro CDDB$L_RSTRTQFL = 72,0,32,1 %;    ! Queue wherein we accumulate, sort and select 
macro CDDB$L_RSTRTQBL = 76,0,32,1 %;    !  for re-submission following VC re-establish 
macro CDDB$L_SAVED_PC = 80,0,32,1 %;    ! Saved PC on internal subroutine calls 
macro CDDB$L_SAVED_PC1 = 84,0,32,1 %;   ! Saved PC on internal subroutine calls 
macro CDDB$L_UCBCHAIN = 88,0,32,1 %;    ! Chain of UCBs on connection
macro CDDB$L_ORIGUCB = 92,0,32,1 %;     ! Ptr to Orig. UCB if unchained
macro CDDB$L_ALLOCLS = 96,0,32,0 %;     ! Device Allocation Class
macro CDDB$L_DAPCDRP = 100,0,32,1 %;    ! Ptr to Deter.Acc.Path CDRP
macro CDDB$L_CDDBLINK = 104,0,32,1 %;   ! Link in CDDB chain
macro CDDB$L_FOVER_CTR = 108,0,32,0 %;  !  counter of reconnect intervals per failover try
macro CDDB$L_WTUCBCTR = 112,0,32,0 %;   !  counter of UCBs waiting for mount ver. to finish
macro CDDB$L_MAXBCNT = 116,0,32,0 %;    !  Max byte count for this connection
macro CDDB$L_CTRLTR_MASK = 120,0,32,0 %; !  Mask of controller letters (ddCu:) used by this controller
macro CDDB$L_CPYSEQNUM = 124,0,32,0 %;  !  Base value IO$_COPYSHAD sequence number
macro CDDB$L_DAP_LIMIT = 128,0,32,0 %;  !  Credit stall counter
macro CDDB$B_CSVRSN = 132,0,8,0 %;      !  Controller microcode version
macro CDDB$B_CHVRSN = 133,0,8,0 %;      !  Controller hardware version
macro CDDB$W_LOAD_AVAIL = 134,0,16,0 %; !  Load available from MSCP server
macro CDDB$L_COUNTER = 136,0,32,0 %;    !  General purpose counter (currently used by wrong-CDT check)
macro CDDB$L_PERMCDRP = 140,0,32,0 %;   ! Beginning of a permanent CDRP allocated 
!   contiguous to CDDB
literal CDDB$S_CDDBDEF = 144;           ! Old size name, synonym for CDDB$S_CDDB
 
!*** MODULE $CDLDEF ***
! +
!  CDL - SCS CONNECTION DESCRIPTOR LIST
! 
!  THERE IS A SYSTEM WIDE LIST OF CONNECTION DESCRIPTORS POINTED
!  TO BY THE CDL.
! -
literal CDL$C_LENGTH = 16;              ! LENGTH OF NEG PORTION OF STRUCTURE 
literal CDL$S_CDLDEF = 20;
literal CDL$S_CDL = 20;
macro CDL$W_MAXCONIDX = -16,0,16,0 %;   ! MAXIMUM ! OF CDT'S 
macro CDL$L_FREECDT = -12,0,32,1 %;     ! ADDR OF 1ST FREE CDT 
macro CDL$W_SIZE = -8,0,16,0 %;         ! STRUCTURE SIZE IN BYTES 
macro CDL$B_TYPE = -6,0,8,0 %;          ! SCS STRUCTURE TYPE 
macro CDL$B_SUBTYP = -5,0,8,0 %;        ! SCS STRUCT SUBTYPE FOR CDL 
macro CDL$L_NOCDT_CNT = -4,0,32,0 %;    ! Count of CDT allocation failures
macro CDL$L_BASE = 0,0,32,1 %;          ! BASE OF THE TABLE 
 
!*** MODULE $CDTDEF ***
! +
!  CDT - SCS CONNECTION DESCRIPTOR TABLE
! 
!  THESE DESCRIPTORS ARE POINTED TO BY THE SYSTEM WIDE CONNECTION
!  DESCRIPTOR LIST (CDL).  ONE CDT IS USED PER SCS VIRTUAL CIRCUIT
!  OR LISTENING CONNECTION.
! -
literal CDT$C_CLOSED = 0;               !  CLOSED 
literal CDT$C_LISTEN = 1;               !  LISTENING FOR CONNX REQUESTS 
literal CDT$C_OPEN = 2;                 !  OPEN 
literal CDT$C_DISC_ACK = 3;             !  DISCONNECT ACKNOWLEDGED 
literal CDT$C_DISC_REC = 4;             !  DISCONNECT REQ RECEIVED 
literal CDT$C_DISC_SENT = 5;            !  DISCONNECT SENT 
literal CDT$C_DISC_MTCH = 6;            !  DISCONNECT MATCH 
literal CDT$C_CON_SENT = 7;             !  CONNECT REQ SENT 
literal CDT$C_CON_ACK = 8;              !  CONNECT REQ SENT AND ACK'ED 
literal CDT$C_CON_REC = 9;              !  CONNECT REQ RECEIVED 
literal CDT$C_ACCP_SENT = 10;           !  ACCEPT REQ SENT 
literal CDT$C_REJ_SENT = 11;            !  REJECT SENT 
literal CDT$C_DISC_MTCH_RSPQ = 12;      !  MATCHING DISCONNECT RESPONSE IN PROGRESS
literal CDT$C_DISC_RSPQ = 13;           !  DISCONNECT RESPONSE IN PROGRESS
literal CDT$C_VC_FAIL = 14;             !  VIRTUAL CIRCUIT FAILED 
!  
literal CDT$C_CON_PEND = 1;             !  WAITING TO SEND CONNECT REQ 
literal CDT$C_ACCP_PEND = 2;            !  WAITING TO SEND ACCEPT REQ 
literal CDT$C_REJ_PEND = 3;             !  WAITING TO SEND REJECT REQ 
literal CDT$C_DISC_PEND = 4;            !  WAITING TO SEND DISCONNECT REQ 
literal CDT$C_CR_PEND = 5;              !  WAITING TO SEND CREDIT 
literal CDT$C_DCR_PEND = 6;             !  WAITING TO SEND CREDIT IN 
!   PREPARATION FOR DISCONNECT
literal CDT$C_RATING0 = 0;              !  (TYC 4-JAN-89) Undefined yet but valid value
literal CDT$C_RATING1 = 1;              !  (TYC 4-JAN-89) Undefined yet but valid value
literal CDT$C_RATING2 = 2;              !  (TYC 4-JAN-89) Undefined yet but valid value
literal CDT$C_RATING3 = 3;              !  (TYC 4-JAN-89) Undefined yet but valid value
!  MOVE SUGGESTED FOR AN EQUAL PATH (I.E. CI->CI)
literal CDT$C_YELLOW = 4;               !  (TYC 4-JAN-89) port is in YELLOW zone
literal CDT$C_RATING5 = 5;              !  (TYC 4-JAN-89) Undefined yet but valid value
literal CDT$C_RED = 6;                  !  port is in RED zone (i.e. port is saturated)
literal CDT$C_UNEQUAL_PATH = 7;         !  MOVE SUGGESTED FOR AN UNEQUAL PATH (I.E. NI->CI)
literal CDT$C_LOAD_SHARE_DISABLE = 8;   !  load sharing disabled
!  
literal CDT$C_BAD_RATING = -2147483648; !  (TYC 4-JAN-89) Bad load rating marker
literal CDT$K_BAD_RATING = -2147483648;
literal CDT$C_LOADSHARE = 0;            !  (TYC 21-Jun-89) Load sharing SYSAP
literal CDT$C_PRE_LOADSHARE = 1;        !  (TYC 21-Jun-89) Pre-load sharing SYSAP
!  
literal CDT$K_LENGTH = 371;             ! LENGTH OF CDT 
literal CDT$C_LENGTH = 371;             ! LENGTH OF CDT 
literal CDT$S_CDTDEF = 371;             ! Old size name, synonym
literal CDT$S_CDT = 371;
macro CDT$L_MSGINPUT = 0,0,32,1 %;      ! ADDR OF MSG INPUT DISPATCHER 
macro CDT$L_LINK = 0,0,32,1 %;          !  OR LINK TO NEXT FREE CDT 
macro CDT$L_DGINPUT = 4,0,32,1 %;       ! ADDR TO CALL ON DG RECEIVED 
macro CDT$W_SIZE = 8,0,16,0 %;          ! STRUCTURE SIZE IN BYTES 
macro CDT$B_TYPE = 10,0,8,0 %;          ! SCS STRUCTURE TYPE 
macro CDT$B_SUBTYP = 11,0,8,0 %;        ! SCS STRUCT SUBTYPE FOR CDT 
macro CDT$L_ERRADDR = 12,0,32,1 %;      ! ADDR TO CALL FOR ERROR NOTIFICATION 
macro CDT$L_PDT = 16,0,32,1 %;          ! ADDR OF ASSOC PORT DESC TABLE 
macro CDT$L_RCONID = 20,0,32,0 %;       ! REMOTE CONNECTION ID 
macro CDT$L_LCONID = 24,0,32,0 %;       ! LOCAL CONNECTION ID 
macro CDT$L_PB = 28,0,32,1 %;           ! ADDR OF ASSOC PATH BLOCK 
macro CDT$B_RSTATION = 32,0,0,0 %;
literal CDT$S_RSTATION = 6;             ! REMOTE STATION ADDR 
macro CDT$W_REASON = 38,0,16,0 %;       ! REJECT/DISCONNECT REASON 
macro CDT$W_STATE = 40,0,16,0 %;        ! CONNECTION STATE 
! STATE VALUES:
!  0 ORIGIN, INCREMENTS OF 1: 
macro CDT$W_BLKSTATE = 42,0,16,0 %;     ! SCS SEND BLOCKED STATE 
! STATE VALUES:
!  1 ORIGIN, INCREMENTS OF 1: 
!  
macro CDT$L_SCSMSG = 44,0,32,1 %;       ! ADDR OF SCS RECEIVE BUFFER 
macro CDT$L_WAITQFL = 48,0,32,1 %;      ! SEND SCS MSG WAIT QUEUE FLINK 
macro CDT$L_WAITQBL = 52,0,32,1 %;      ! SEND SCS MSG WAIT QUEUE BLINK 
macro CDT$L_CRWAITQFL = 56,0,32,1 %;    ! SEND CREDIT WAIT QUEUE FLINK 
macro CDT$L_CRWAITQBL = 60,0,32,1 %;    ! SEND CREDIT WAIT QUEUE BLINK 
macro CDT$W_SEND = 64,0,16,0 %;         ! CURRENT SEND CREDIT 
macro CDT$W_REC = 66,0,16,0 %;          ! RECEIVE CREDIT (SEND CREDIT 
!  HELD BY REMOTE)
macro CDT$W_MINREC = 68,0,16,0 %;       ! MINIMUM RECEIVE CREDIT (MIN 
!  SEND REQUIRED BY REMOTE)
macro CDT$W_PENDREC = 70,0,16,0 %;      ! RECEIVE CREDIT NOT YET EXTENDED 
!  TO REMOTE
macro CDT$W_INITLREC = 72,0,16,0 %;     ! INITIAL RECEIVE CREDIT 
macro CDT$W_MINSEND = 74,0,16,0 %;      ! MINIMUM SEND CREDIT 
macro CDT$W_DGREC = 76,0,16,0 %;        ! DATAGRAMS QUEUED FOR RECEIVE 
macro CDT$B_PRIORITY = 78,0,8,0 %;      ! BLOCK TRANSFER PRIORIY 
macro CDT$L_RPROCNAM = 80,0,32,1 %;     ! ADDR OF REMOTE PROCESS NAME 
macro CDT$L_LPROCNAM = 84,0,32,1 %;     ! ADDR OF LOCAL PROCESS NAME 
macro CDT$L_CONDAT = 88,0,32,1 %;       ! ADDR OF CONNECT DATA 
macro CDT$L_AUXSTRUC = 92,0,32,1 %;     ! ADDR OF AUXILARY DATA STRUCTURE 
macro CDT$L_BADRSP = 96,0,32,1 %;       ! ADDR IN SYSAP TO CALL WITH 
!  BAD RESPONSE(UNIMPLEMENTED) 
macro CDT$L_FPC = 100,0,32,0 %;         ! SAVED FORK PROCESS PC 
macro CDT$L_FR5 = 104,0,32,0 %;         ! SAVED FORK PROCESS R5 
macro CDT$L_CDTLST = 108,0,32,1 %;      ! LINK FOR CDT LIST FROM PB 
macro CDT$L_DGSENT = 112,0,32,0 %;      ! # APPLICATION DGS SENT
macro CDT$L_DGRCVD = 116,0,32,0 %;      ! # APPLICATION DGS REC'D
macro CDT$L_DGDISCARD = 120,0,32,0 %;   ! # DGS DISCARDED BY DRIVER
macro CDT$L_MSGSENT = 124,0,32,0 %;     ! # APPLICATION MSGS SENT
macro CDT$L_MSGRCVD = 128,0,32,0 %;     ! # APPLICATION MSGS REC'D
macro CDT$L_SNDDATS = 132,0,32,0 %;     ! # SEND DATAS INITIATED
macro CDT$L_BYTSENT = 136,0,32,0 %;     ! # BYTES SENT VIA SEND DATAS
macro CDT$L_REQDATS = 140,0,32,0 %;     ! #REQ DATAS INITIATED
macro CDT$L_BYTREQD = 144,0,32,0 %;     ! BYTES REC'D VIA REQ DATAS
macro CDT$L_BYTMAPD = 148,0,32,0 %;     ! TOTAL BYTES MAPPED
macro CDT$W_QCR_CNT = 152,0,16,0 %;     ! # TIMES QUEUED FOR SEND CREDIT
macro CDT$W_QBDLT_CNT = 154,0,16,0 %;   ! # TIMES QUEUED FOR BDLT
!  (TYC 14-FEB-89) LOAD SHARING FIELDS
macro CDT$L_MOVE_PATH_ADDR = 156,0,32,1 %; !  CONNECTION MOVE ADDRESS
!  1 ORIGIN, INCREMENTS OF 1: 
macro CDT$L_SHARE_FLINK = 160,0,32,1 %; ! DYNAMIC LOAD SHARING CDT QUEUE FLINK
macro CDT$L_SHARE_BLINK = 164,0,32,1 %; ! DYNAMIC LOAD SHARING CDT QUEUE BLINK
macro CDT$L_SB = 168,0,32,1 %;          ! SYSTEM BLOCK ADDRESS
!  R1 load rating on entry (TYC 4-JAN-89)
macro CDT$L_CON_REQ_CTR = 172,0,32,0 %; !  (TYC 25-Apr-89) # of times CONN REQ sent
macro CDT$L_LOAD_RATING = 176,0,32,0 %; !  LOAD RATING (TYC 4-JAN-89 now used)
macro CDT$L_TIME_STAMP = 180,0,32,0 %;  !  TIME STAMP (EXE$GL_ABSTIM) OF CONNECTION FORMATION
macro CDT$L_QUEUE_TIME_STAMP = 184,0,32,0 %; !  (TYC 15-Feb-89) TIME STAMP OF MOVING CDT TO QUEUE
macro CDT$L_DISCON_COUNTER = 188,0,32,0 %; !  (TYC 15-Feb-89) LOAD SHARING DISCONNECT COUNTER
!  used with conditional assembly
macro CDT$L_OPTIMAL_PATH = 192,0,32,1 %; !  (TYC 15-Feb-89) PATH ADDRESS OF THE OPTIMAL PORT
macro CDT$L_BYTES_XFER = 196,0,32,0 %;  !  (TYC 15-Feb-89) TOTAL BYTES XFERRED (BOTH XMIT & RCV)
macro CDT$L_BYTES_DG_XMT = 200,0,32,0 %; !  (TYC 15-Feb-89) TOTAL DG BYTES XMITTED 
macro CDT$L_BYTES_DG_RCV = 204,0,32,0 %; !  (TYC 15-Feb-89) TOTAL DG BYTES RECEIVED
macro CDT$L_BYTES_MSG_XMT = 208,0,32,0 %; !  (TYC 15-Feb-89) TOTAL MSG BYTES XMITTED
macro CDT$L_BYTES_MSG_RCV = 212,0,32,0 %; !  (TYC 15-Feb-89) TOTAL MSG BYTES RECEIVED
macro CDT$L_BYTES_XFER_LAST = 216,0,32,0 %; !  (TYC 31-Aug-89) TOTAL BYTES XFERRED 
!  UP TO LAST LOAD SHARING INTERVAL
macro CDT$L_BYTES_DG_XMT_LAST = 220,0,32,0 %; !  (TYC 31-Aug-89) TOTAL DG BYTES XMITTED
!  UP TO LAST LOAD SHARING INTERVAL
macro CDT$L_BYTES_DG_RCV_LAST = 224,0,32,0 %; !  (TYC 31-Aug-89) TOTAL DG BYTES RECEIVED 
!  UP TO LAST LOAD SHARING INTERVAL
macro CDT$L_BYTES_MSG_XMT_LAST = 228,0,32,0 %; !  (TYC 31-Aug-89) TOTAL MSG BYTES XMITTED 
!  UP TO LAST LOAD SHARING INTERVAL
macro CDT$L_BYTES_MSG_RCV_LAST = 232,0,32,0 %; !  (TYC 31-Aug-89) TOTAL MSG BYTES RECEIVED
!  UP TO LAST LOAD SHARING INTERVAL
macro CDT$L_BYTMAPD_LAST = 236,0,32,0 %; !  (TYC 31-Aug-89) TOTAL BYTES MAPPED 
!  UP TO LAST LOAD SHARING INTERVAL
macro CDT$L_DGSENT_LAST = 240,0,32,0 %; !  (TYC 31-Aug-89) TOTAL DGS XMITTED 
!  UP TO LAST LOAD SHARING INTERVAL
macro CDT$L_DGRCVD_LAST = 244,0,32,0 %; !  (TYC 31-Aug-89) TOTAL DGS RECEIVED
!  UP TO LAST LOAD SHARING INTERVAL
macro CDT$L_MSGSENT_LAST = 248,0,32,0 %; !  (TYC 31-Aug-89) TOTAL MSGS XMITTED
!  UP TO LAST LOAD SHARING INTERVAL
macro CDT$L_MSGRCVD_LAST = 252,0,32,0 %; !  (TYC 31-Aug-89) TOTAL MSGS RECEIVED 
!  UP TO LAST LOAD SHARING INTERVAL
!  (TYC 17-Feb-89) peak counters used with conditional assembly
macro CDT$L_BYTES_XFER_PEAK = 256,0,32,0 %; !  PEAK VALUE OF TOTAL BYTES XFERRED 
macro CDT$L_BYTES_DG_XMT_PEAK = 260,0,32,0 %; !  PEAK VALUE OF TOTAL DG BYTES XMITTED 
macro CDT$L_BYTES_DG_RCV_PEAK = 264,0,32,0 %; !  PEAK VALUE OF TOTAL DG BYTES RECEIVED 
macro CDT$L_BYTES_MSG_XMT_PEAK = 268,0,32,0 %; !  PEAK VALUE OF TOTAL MSG BYTES XMITTED 
macro CDT$L_BYTES_MSG_RCV_PEAK = 272,0,32,0 %; !  PEAK VALUE OF TOTAL MSG BYTES RECEIVED
macro CDT$L_BYTMAPD_PEAK = 276,0,32,0 %; !  PEAK VALUE OF TOTAL BYTES MAPPED 
macro CDT$L_DGSENT_PEAK = 280,0,32,0 %; !  PEAK VALUE OF TOTAL DGS XMITTED 
macro CDT$L_DGRCVD_PEAK = 284,0,32,0 %; !  PEAK VALUE OF TOTAL DGS RECEIVED
macro CDT$L_MSGSENT_PEAK = 288,0,32,0 %; !  PEAK VALUE OF TOTAL MSGS XMITTED
macro CDT$L_MSGRCVD_PEAK = 292,0,32,0 %; !  PEAK VALUE OF TOTAL MSGS RECEIVED 
!  (TYC 17-Feb-89) average counters used with conditional assembly
macro CDT$L_BYTES_XFER_AVG = 296,0,32,0 %; !  AVERAGE VALUE OF TOTAL BYTES XFERRED 
macro CDT$L_BYTES_DG_XMT_AVG = 300,0,32,0 %; !  AVERAGE VALUE OF TOTAL DG BYTES XMITTED 
macro CDT$L_BYTES_DG_RCV_AVG = 304,0,32,0 %; !  AVERAGE VALUE OF TOTAL DG BYTES RECEIVED 
macro CDT$L_BYTES_MSG_XMT_AVG = 308,0,32,0 %; !  AVERAGE VALUE OF TOTAL MSG BYTES XMITTED 
macro CDT$L_BYTES_MSG_RCV_AVG = 312,0,32,0 %; !  AVERAGE VALUE OF TOTAL MSG BYTES RECEIVED
macro CDT$L_BYTMAPD_AVG = 316,0,32,0 %; !  AVERAGE VALUE OF TOTAL BYTES MAPPED 
macro CDT$L_DGSENT_AVG = 320,0,32,0 %;  !  AVERAGE VALUE OF TOTAL DGS XMITTED 
macro CDT$L_DGRCVD_AVG = 324,0,32,0 %;  !  AVERAGE VALUE OF TOTAL DGS RECEIVED
macro CDT$L_MSGSENT_AVG = 328,0,32,0 %; !  AVERAGE VALUE OF TOTAL MSGS XMITTED
macro CDT$L_MSGRCVD_AVG = 332,0,32,0 %; !  AVERAGE VALUE OF TOTAL MSGS RECEIVED 
macro CDT$L_BYTES_XFER_INT = 336,0,32,0 %; !  (TYC 31-AUG-89) TOTAL BYTES XFERRED
!  DURING LAST LOAD SHARING INTERVAL
!  (TYC 21-Jun-89) Moved fields
macro CDT$W_LOCAL_INDEX = 340,0,16,0 %; !  LOCAL PROCESS NAME INDEX
macro CDT$B_LS_FLAG = 342,0,8,0 %;      !  (TYC 15-Feb-89) LOAD SHARING FLAG.  IF SET,
!  THE CONNECTION IS REQUESTED TO DISCONNECT
macro CDT$B_SYSAP_VERSION = 343,0,8,0 %; !  (TYC 21-Jun-89) Flag for SYSAP version
!  (TYC 21-Jun-89) SYSAP version constants
!   be quadword aligned:
macro CDT$B_SCS_MAINT_BLOCK = 352,0,0,0 %;
literal CDT$S_SCS_MAINT_BLOCK = 16;     ! Add a Maintenance block to the CDT
!  which must be quadword aligned
 
!*** MODULE $CEBDEF ***
! +
!  COMMON EVENT BLOCK
! -
literal CEB$K_LENGTH = 72;              ! LENGTH OF COMMON EVENT BLOCK 
literal CEB$C_LENGTH = 72;              ! LENGTH OF COMMON EVENT BLOCK 
literal CEB$S_CEBDEF = 72;
literal CEB$S_CEB = 72;
macro CEB$L_CEBFL = 0,0,32,1 %;         ! POINTER TO NEXT COMMON EVENT BLOCK 
macro CEB$L_CEBBL = 4,0,32,1 %;         ! POINTER TO PREVIOUS COMMON EVENT BLOCK 
macro CEB$W_SIZE = 8,0,16,0 %;          ! SIZE OF COMMON EVENT BLOCK IN BYTES 
macro CEB$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE CODE FOR CEB 
macro CEB$L_STS = 12,0,32,0 %;          ! STATUS FLAGS FOR CEB 
macro CEB$V_NOQUOTA = 12,0,1,0 %;       ! NO QUOTA UPDATE 
macro CEB$V_PERM = 12,1,1,0 %;          ! PERMANENT CLUSTER 
macro CEB$L_PID = 16,0,32,0 %;          ! PID OF CREATOR 
macro CEB$L_EFC = 20,0,32,0 %;          ! EVENT FLAGS (32 BIT VECTOR) 
macro CEB$L_WQFL = 24,0,32,1 %;         ! HEAD OF WAIT QUEUE 
macro CEB$L_WQBL = 28,0,32,1 %;         ! TAIL OF WAIT QUEUE 
macro CEB$L_WQCNT = 32,0,32,0 %;        ! WAIT QUEUE COUNT(LENGTH) 
macro CEB$L_STATE = 36,0,32,0 %;        ! CEF WAIT STATE NUMBER 
macro CEB$L_ORB = 40,0,32,1 %;          ! POINTER TO THE ORB
macro CEB$L_UIC = 44,0,32,0 %;          ! USER IDENT OF CEB CREATOR 
macro CEB$W_GRP = 46,0,16,0 %;          ! GROUP NUMBER OF OWNER 
macro CEB$L_PROT = 48,0,32,0 %;         ! PROTECTION MASK 
macro CEB$L_REFC = 52,0,32,0 %;         ! REFERENCE COUNT FOR CEB 
macro CEB$T_EFCNAM = 56,0,0,0 %;
literal CEB$S_EFCNAM = 16;              ! EVENT CLUSTER TEXT NAME 
 
!*** MODULE $CHFCTXDEF ***
! 
!  CONDITION HANDLING FACILITY INTERNAL CONTEXT OFFSETS
! 
!  This module defines the layout of the Condition Handling Facility 
!  internal context on the stack (in the mode of the exception).
!  This context is created by the VMS hardware exception handling 
!  facility and the RTL LIB$SIGNAL/LIB$STOP routines. This context 
!  is used by the Condition Handling Facility as well as DEBUG.
! 
!  Note that this structure definition only provides offsets for a 
!  small portion of the whole exception context. The whole exception 
!  context contains:
! 
!   	Internal context area (structure defined here)
! 	ALPHA mechanism array
! 	Signal array (which includes the ALPHA exception record)
! 	Exception frame generated by PAL 
! 
!  The mechanism array can't be embedded here because it is subject to 
!  change, and there is no easy way to "include" the mechanism array
!  definition into this module.
! 
!  The signal array is variable length, depending on the exception.
! 
literal CHFCTX$M_SIGNAL = %X'1';
literal CHFCTX$M_STOP = %X'2';
literal CHFCTX$M_FPREGS_VALID = %X'4';
literal CHFCTX$M_UNWIND_AST = %X'8';
literal CHFCTX$M_REINVOKABLE = %X'10';
literal CHFCTX$M_FPREGS_READY = %X'20';
literal CHFCTX$M_SYS_UNWIND = %X'40';
literal CHFCTX$M_GOTO_UNWIND = %X'80';
literal CHFCTX$M_EXIT_UNWIND = %X'100';
literal CHFCTX$M_RECALL_TARGET = %X'200';
literal CHFCTX$K_LENGTH = 80;           !  Length of CHFCTX
literal CHFCTX$C_LENGTH = 80;           !  Length of CHFCTX
literal CHFCTX$S_CHFCTXDEF = 80;
literal CHFCTX$S_CHFCTX = 80;
macro CHFCTX$Q_LINKAGE_PTR = 0,0,0,0 %;
literal CHFCTX$S_LINKAGE_PTR = 8;       !  Linkage section pointer
macro CHFCTX$Q_SIGARGLST = 8,0,0,0 %;
literal CHFCTX$S_SIGARGLST = 8;         !  Address of Signal array 
macro CHFCTX$Q_MCHARGLST = 16,0,0,0 %;
literal CHFCTX$S_MCHARGLST = 8;         !  Address of mechanism array
macro CHFCTX$Q_EXPT_ADDR = 24,0,0,0 %;
literal CHFCTX$S_EXPT_ADDR = 8;         !  Address of exception frame
macro CHFCTX$Q_EXPT_FP = 32,0,0,0 %;
literal CHFCTX$S_EXPT_FP = 8;           !  Exception FP
macro CHFCTX$Q_UNWIND_SP = 40,0,0,0 %;
literal CHFCTX$S_UNWIND_SP = 8;         !  SP during unwind
macro CHFCTX$Q_REINVOKABLE_FP = 48,0,0,0 %;
literal CHFCTX$S_REINVOKABLE_FP = 8;    !  End of reinvokable algorithm
macro CHFCTX$Q_UNWIND_TARGET = 56,0,0,0 %;
literal CHFCTX$S_UNWIND_TARGET = 8;     !  Unwind target (FP)
macro CHFCTX$L_BYTECNT = 64,0,32,0 %;   !  Byte count of exception context
macro CHFCTX$L_SIG_ARGS = 68,0,32,0 %;  !  Original signal array count
macro CHFCTX$L_FLAGS = 72,0,32,0 %;     !  Internal flags
macro CHFCTX$V_SIGNAL = 72,0,1,0 %;     !  Signal flag
macro CHFCTX$V_STOP = 72,1,1,0 %;       !  Stop flag
macro CHFCTX$V_FPREGS_VALID = 72,2,1,0 %; !  Floating Point Registers valid
macro CHFCTX$V_UNWIND_AST = 72,3,1,0 %; !  Unwinding from AST
macro CHFCTX$V_REINVOKABLE = 72,4,1,0 %; !  Reinvokable algorithm in progress
macro CHFCTX$V_FPREGS_READY = 72,5,1,0 %; !  Floating Point Registers ready
macro CHFCTX$V_SYS_UNWIND = 72,6,1,0 %; !  Unwind by depth
macro CHFCTX$V_GOTO_UNWIND = 72,7,1,0 %; !  GOTO unwind in progress
macro CHFCTX$V_EXIT_UNWIND = 72,8,1,0 %; !  Exit unwind in progress
macro CHFCTX$V_RECALL_TARGET = 72,9,1,0 %; !  Re-call target invocation's handler
macro CHFCTX$L_FINALSTS = 72,0,32,0 %;  !  Final status 
macro CHFCTX$L_MSGPTR = 76,0,32,1 %;    !  Address of $EXCMSG error msg
 
!*** MODULE $CHPCTLDEF ***
! 
!  CHeck Protection ConTroL block definition.  This block contains the
!  information concerning the type of access check being made.
! 
literal CHPCTL$M_READ = %X'1';
literal CHPCTL$M_WRITE = %X'2';
literal CHPCTL$M_USEREADALL = %X'4';
literal CHPCTL$M_NOAUDIT = %X'8';
literal CHPCTL$M_NOFAILAUD = %X'10';
literal CHPCTL$M_NOSUCCAUD = %X'20';
literal CHPCTL$M_DELETE = %X'40';
literal CHPCTL$M_MANDATORY = %X'80';
literal CHPCTL$M_FLUSH = %X'100';
literal CHPCTL$M_CREATE = %X'200';
literal CHPCTL$M_INTERNAL = %X'400';
literal CHPCTL$M_SERVER = %X'800';
literal CHPCTL$K_LENGTH = 32;
literal CHPCTL$C_LENGTH = 32;
literal CHPCTL$S_CHPCTL = 32;
macro CHPCTL$L_ACCESS = 0,0,32,0 %;     !  type of access desired
macro CHPCTL$L_FLAGS = 4,0,32,0 %;      !  control flags
macro CHPCTL$V_READ = 4,0,1,0 %;        !  READ access
macro CHPCTL$V_WRITE = 4,1,1,0 %;       !  WRITE access
macro CHPCTL$V_USEREADALL = 4,2,1,0 %;  !  try for READ access via READALL
macro CHPCTL$V_NOAUDIT = 4,3,1,0 %;     !  do not perform any auditing
macro CHPCTL$V_NOFAILAUD = 4,4,1,0 %;   !  do not perform failed access audit
macro CHPCTL$V_NOSUCCAUD = 4,5,1,0 %;   !  do not perform successful access audit
macro CHPCTL$V_DELETE = 4,6,1,0 %;      !  perform audit as DELETE event
macro CHPCTL$V_MANDATORY = 4,7,1,0 %;   !  perform mandatory audit
macro CHPCTL$V_FLUSH = 4,8,1,0 %;       !  force buffer flush in audit server
macro CHPCTL$V_CREATE = 4,9,1,0 %;      !  perform audit as CREATE event
macro CHPCTL$V_INTERNAL = 4,10,1,0 %;   !  audit on behalf of VMS TCB
macro CHPCTL$V_SERVER = 4,11,1,0 %;     !  audit originates in TCB server process
macro CHPCTL$L_MODE = 8,0,32,0 %;       !  access mode of request
macro CHPCTL$L_AUDIT_LIST = 12,0,32,1 %; !  address of associated auditing item list
macro CHPCTL$L_DEACCESS_KEY = 16,0,32,0 %; !  deaccess audit object handle
macro CHPCTL$L_MESSAGE = 20,0,32,0 %;   !  associated auditing message code
macro CHPCTL$L_ARB = 24,0,32,1 %;       !  corresponding ARB
macro CHPCTL$L_ORB = 28,0,32,1 %;       !  corresponding ORB
 
!*** MODULE $CHPRETDEF ***
! +
! 
!  CHeck Protection ConTroL RETurn argument block.  This block contains
!  the information needed to return arguments from the protection check.
! 
! -
literal CHPRET$M_ACMODE = %X'1';
literal CHPRET$M_MAC = %X'2';
literal CHPRET$M_DAC = %X'4';
literal CHPRET$M_MATCHED_ACE = %X'8';
literal CHPRET$M_SOGW = %X'10';
literal CHPRET$M_ACL_KEYID = %X'20';
literal CHPRET$M_IVBUFLEN = %X'40';
literal CHPRET$K_LENGTH = 44;
literal CHPRET$C_LENGTH = 44;
literal CHPRET$S_CHPRET = 44;
macro CHPRET$L_AUDITLEN = 0,0,32,0 %;   !  Size of the audit ACE buffer
macro CHPRET$L_AUDIT = 4,0,32,1 %;      !  Address of the audit ACE buffer
macro CHPRET$L_AUDITRET = 8,0,32,1 %;   !  Address of word to get ACE length
macro CHPRET$L_ALARMLEN = 12,0,32,0 %;  !  Size of the alarm ACE buffer
macro CHPRET$L_ALARM = 16,0,32,1 %;     !  Address of the alarm ACE buffer
macro CHPRET$L_ALARMRET = 20,0,32,1 %;  !  Address of word to get ACE length
macro CHPRET$L_MATCHED_ACELEN = 24,0,32,0 %; !  Size of the matched ACE buffer
macro CHPRET$L_MATCHED_ACE = 28,0,32,1 %; !  Address of the matched ACE buffer
macro CHPRET$L_MATCHED_ACERET = 32,0,32,1 %; !  Address of word to get ACE length
macro CHPRET$L_PRIVS_USED = 36,0,32,1 %; !  Address of longword to get privileges used
macro CHPRET$L_PROGRESS = 40,0,32,0 %;  !  Protection check progress fl
macro CHPRET$V_ACMODE = 40,0,1,0 %;     !  Access mode check failed
macro CHPRET$V_MAC = 40,1,1,0 %;        !  MAC check failed
macro CHPRET$V_DAC = 40,2,1,0 %;        !  DAC check failed
macro CHPRET$V_MATCHED_ACE = 40,3,1,0 %; !  matching ACE was located
macro CHPRET$V_SOGW = 40,4,1,0 %;       !  SOGW check was performed
macro CHPRET$V_ACL_KEYID = 40,5,1,0 %;  !  An identifier ACE was found in the ACL
macro CHPRET$V_IVBUFLEN = 40,6,1,0 %;   !  CHPRET info for auditing is incomplete
 
!*** MODULE $CIAOLDDEF ***
! +
!  CIAOLD - Compound Intrusion Analysis block
! 
!  Contains information about suspected and known intruders
! -
literal CIAOLD$K_TERMINAL = 1;          !  Unknown user at terminal
literal CIAOLD$K_TERM_USER = 2;         !  Known username at terminal
literal CIAOLD$K_NETWORK = 3;           !  Network source
literal CIAOLD$K_USERNAME = 4;          !  Username of parent process
literal CIAOLD$M_INTRUDER = %X'1';
literal CIAOLD$K_LENGTH = 160;          !  Length of CIAOLD block
literal CIAOLD$C_LENGTH = 160;          !  Length of CIAOLD block
literal CIAOLD$S_CIAOLDDEF = 160;
literal CIAOLD$S_CIAOLD = 160;
macro CIAOLD$L_FLINK = 0,0,32,1 %;      !  Forward link to next block
macro CIAOLD$L_BLINK = 4,0,32,1 %;      !  Backward link to previous block
macro CIAOLD$W_SIZE = 8,0,16,0 %;       !  Size of block
macro CIAOLD$B_TYPE = 10,0,8,0 %;       !  Structure type 
macro CIAOLD$B_SUBTYPE = 11,0,8,0 %;    !  Structure subtype
!  Source of breakin attempt
macro CIAOLD$L_FLAGS = 12,0,32,0 %;     !  Breakin type flags 
macro CIAOLD$V_INTRUDER = 12,0,1,0 %;   !  Entry is an intruder
macro CIAOLD$L_COUNT = 16,0,32,0 %;     !  Count of attempts
macro CIAOLD$L_FILL_1 = 20,0,32,0 %;    !  Make TIME naturally aligned
macro CIAOLD$Q_TIME = 24,0,0,0 %;
literal CIAOLD$S_TIME = 8;              !  Expiration time of entry
macro CIAOLD$T_DATA = 32,0,0,0 %;
literal CIAOLD$S_DATA = 128;            !  Data area
 
!*** MODULE $CIBHANDEF ***
! +
!  CIBHAN - CI BUFFER HANDLE FORMAT
! -
literal CIBHAN$K_LENGTH = 12;           ! LENGTH OF CI BUFFER HANDLE 
literal CIBHAN$C_LENGTH = 12;           ! LENGTH OF CI BUFFER HANDLE 
literal CIBHAN$S_CIBHANDEF = 12;
literal CIBHAN$S_CIBHAN = 12;
macro CIBHAN$L_BOFF = 0,0,32,0 %;       ! BYTE OFFSET IN LOCAL BUFFER 
macro CIBHAN$L_BNAME = 4,0,32,0 %;      ! NAME OF LOCAL BUFFER 
macro CIBHAN$L_RCONID = 8,0,32,0 %;     ! REMOTE CONNECTION ID 
 
!*** MODULE $CIFQDTDEF ***
! +
!  CIFQDT - CI FREE MESSAGE/DATAGRAM QUEUE DESCRIPTOR TABLE
! 
!  THIS DATA STRUCTURE AND THE QUEUES IT HAS HEADERS FOR MAY BE
!  SHARED AMONG ALL CI'S ON THE SYSTEM.
! -
literal CIFQDT$K_LENGTH = 32;           ! LENGTH OF CI FQDT 
literal CIFQDT$C_LENGTH = 32;           ! LENGTH OF CI FQDT 
literal CIFQDT$S_CIFQDTDEF = 32;
literal CIFQDT$S_CIFQDT = 32;
macro CIFQDT$W_DGSIZ = 0,0,16,0 %;      ! DATAGRAM SIZE (INCL PORT HEADER) 
macro CIFQDT$W_MSGSIZ = 2,0,16,0 %;     ! MESSAGE SIZE (INCL PORT HEADER) 
macro CIFQDT$W_SIZE = 8,0,16,0 %;       ! STRUCTURE SIZE IN BYTES 
macro CIFQDT$B_TYPE = 10,0,8,0 %;       ! CI STRUCTURE TYPE 
macro CIFQDT$B_SUBTYP = 11,0,8,0 %;     ! CI STRUCT SUBTYPE FOR CI FQDT 
macro CIFQDT$W_DGCNT = 12,0,16,0 %;     ! SUM OF INITL DG CREDITS FOR ALL CONNX 
macro CIFQDT$W_MSGCNT = 14,0,16,0 %;    ! SUM OF INITL MSG CREDITS FOR ALL CONNX 
macro CIFQDT$L_DGFL = 16,0,32,1 %;      ! DG FREE QUEUE FWD LINK 
macro CIFQDT$L_DGBL = 20,0,32,1 %;      ! DG FREE QUEUE BACK LINK 
macro CIFQDT$L_MSGFL = 24,0,32,1 %;     ! MSG FREE QUEUE FWD LINK 
macro CIFQDT$L_MSGBL = 28,0,32,1 %;     ! MSG FREE QUEUE BACK LINK 
 
!*** MODULE $CLONEVADEF ***
! +
!  Copy characteristic definitions
! -
literal CLONEVA$C_COPY = 0;             !  Copy
literal CLONEVA$C_NOCOPY = 1;           !  No copy
literal CLONEVA$C_DZRO = 2;             !  Demand zero
literal CLONEVA$C_CW = 3;               !  Copy on write
literal CLONEVA$C_MAX_CHAR = 3;         !  Maximum value 
 
!*** MODULE $CLUBDEF ***
! +
!  CLUB - CLUSTER BLOCK.  
! 
! 	THERE IS ONE CLUB IN A VMS SYSTEM THAT IS PART OF A CLUSTER.
! 	THE CLUB DEFINES THE STATE OF THE THE CLUSTER AS KNOWN TO
! 	THE LOCAL SYSTEM.
! -
! 
! 	THE CLUB FORK BLOCK (CLUBFKB) IS A SUBBLOCK OF THE CLUB THAT IS
! 	USED WHEN IT NECESSARY TO WAIT IN ORDER TO ALLOCATE MEMORY OR
! 	WHEN IT IS DESIRABLE TO FORK TO ALLOW OTHER FORK PROCESSES A
! 	CHANCE TO RUN.
literal CLUBFKB$M_FKB_BUSY = %X'1';
literal CLUBFKB$M_FORKQ = %X'2';
literal CLUBFKB$C_LENGTH = 40;          !  LENGTH OF CLUBFKB
literal CLUBFKB$K_LENGTH = 40;          !  LENGTH OF CLUBFKB
literal CLUBFKB$S_CLUBFKBDEF = 40;      !  Old size name, synonym
literal CLUBFKB$S_CLUBFKB = 40;
macro CLUBFKB$B_FORK_BLOCK = 0,0,0,1 %;
literal CLUBFKB$S_FORK_BLOCK = 32;      !  FORK BLOCK TO WAIT IN
macro CLUBFKB$L_PC2 = 32,0,32,0 %;      !  SAVED PC
macro CLUBFKB$L_STATUS = 36,0,32,0 %;   !  CLUSTER FAILOVER STATUS FLAGS
macro CLUBFKB$V_FKB_BUSY = 36,0,1,0 %;  !   FORK BLOCK IN USE FLAG
macro CLUBFKB$V_FORKQ = 36,1,1,0 %;     !   FORK BLOCK ON FORK QUEUE
! 
! 	THE CLUB POWERFAIL FORK BLOCK (CLUBPWF) IS A SUBBLOCK OF THE CLUB
! 	THAT IS USED TO FORK FROM IPL 31 TO IPL SCS DURING POWER RECOVERY.
literal CLUBPWF$M_BUSY = %X'1';
literal CLUBPWF$C_LENGTH = 40;          !  LENGTH OF CLUBPWF
literal CLUBPWF$K_LENGTH = 40;          !  LENGTH OF CLUBPWF
literal CLUBPWF$S_CLUBPWFDEF = 40;      !  Old size name, synonym
literal CLUBPWF$S_CLUBPWF = 40;
macro CLUBPWF$B_FORK_BLOCK = 0,0,0,1 %;
literal CLUBPWF$S_FORK_BLOCK = 32;      !  FORK BLOCK TO WAIT IN
!  Place STATUS in aligned quadword for interlocked instructions
macro CLUBPWF$L_STATUS = 32,0,32,0 %;   !  BLOCK STATUS FLAGS
macro CLUBPWF$V_BUSY = 32,0,1,0 %;      !   FORK BLOCK IN USE FLAG
! 
! 	THE CLUSTER FAILOVER CONTROL BLOCK (CLUFCB) IS A SUBBLOCK OF
! 	THE CLUB THAT IS USED TO SEQUENCE FAILOVER ACTIONS IN A CLUSTER.
! 
literal CLUFCB$M_ACTIVE = %X'1';
literal CLUFCB$M_PENDING = %X'2';
literal CLUFCB$M_SYNC_NODE = %X'4';
literal CLUFCB$M_FKB_BUSY = %X'8';
literal CLUFCB$M_WAITING = %X'10';
literal CLUFCB$M_AUX = %X'20';
literal CLUFCB$M_RB_SUSPEND = %X'40';
literal CLUFCB$C_LENGTH = 120;          !  LENGTH OF CLUFCB
literal CLUFCB$K_LENGTH = 120;          !  LENGTH OF CLUFCB
literal CLUFCB$S_CLUFCBDEF = 120;       !  Old size name, synonym
literal CLUFCB$S_CLUFCB = 120;
macro CLUFCB$B_FORK_BLOCK = 0,0,0,1 %;
literal CLUFCB$S_FORK_BLOCK = 32;       !  FORK BLOCK TO WAIT IN
macro CLUFCB$L_STEP = 32,0,32,0 %;      !  CURRENT FAILOVER STEP INDEX
macro CLUFCB$L_ID = 36,0,32,0 %;        !  FAILOVER INSTANCE IDENTIFICATION
macro CLUFCB$L_STATUS = 40,0,32,0 %;    !  CLUSTER FAILOVER STATUS FLAGS
macro CLUFCB$V_ACTIVE = 40,0,1,0 %;     !   FAILOVER ROUTINE ACTIVE
macro CLUFCB$V_PENDING = 40,1,1,0 %;    !   FAILOVER PENDING
macro CLUFCB$V_SYNC_NODE = 40,2,1,0 %;  !   LOCAL NODE IS SYNCHRONIZER
macro CLUFCB$V_FKB_BUSY = 40,3,1,0 %;   !   FORK BLOCK IN USE FLAG
macro CLUFCB$V_WAITING = 40,4,1,0 %;    !   WAITING FOR NODES TO RESPOND
macro CLUFCB$V_AUX = 40,5,1,0 %;        !   AUXILIARY FORK BLOCK ALLOCATED
macro CLUFCB$V_RB_SUSPEND = 40,6,1,0 %; !   REBUILD SUSPENDED
macro CLUFCB$L_SYNC_CSB = 44,0,32,1 %;  !  ADDRESS OF CSB OF SYNCHRONIZING SYSTEM
macro CLUFCB$B_NODEMAP = 48,0,0,1 %;
literal CLUFCB$S_NODEMAP = 32;          !  BITMAP OF ALL INVOLVED NODES
macro CLUFCB$B_RESPMAP = 80,0,0,1 %;
literal CLUFCB$S_RESPMAP = 32;          !  BITMAP OF NODES READY FOR A STEP
macro CLUFCB$L_INDEX = 112,0,32,0 %;    !  STORAGE FOR BIT MAP INDEX
macro CLUFCB$L_AUX_FKB = 116,0,32,1 %;  !  ADDRESS OF AUXILIARY FORK BLOCK 
literal CLUB$M_CLUSTER = %X'1';
literal CLUB$M_QF_ACTIVE = %X'2';
literal CLUB$M_QF_DYNVOTE = %X'4';
literal CLUB$M_QF_WATCHER = %X'8';
literal CLUB$M_SHUTDOWN = %X'10';
literal CLUB$M_QF_REFRESH_REQ = %X'20';
literal CLUB$M_STS_PPHASE = %X'100';
literal CLUB$M_STS_PH0 = %X'200';
literal CLUB$M_STS_PH1B = %X'400';
literal CLUB$M_STS_PH1 = %X'800';
literal CLUB$M_STS_PH2 = %X'1000';
literal CLUB$M_TDF_VALID = %X'2000';
literal CLUB$M_FKB_BUSY = %X'10000';
literal CLUB$M_UNLOCK = %X'20000';
literal CLUB$M_NO_FORM = %X'40000';
literal CLUB$M_INIT = %X'80000';
literal CLUB$M_BACKOUT = %X'100000';
literal CLUB$M_PRIOR_PROTOCOL = %X'200000';
literal CLUB$M_VERBOSE = %X'400000';
literal CLUB$M_LOST_CNX = %X'800000';
literal CLUB$M_QF_FAILED_NODE = %X'1000000';
literal CLUB$M_QF_VOTE = %X'2000000';
literal CLUB$M_QF_NEWVOTE = %X'4000000';
literal CLUB$M_ADJ_QUORUM = %X'8000000';
literal CLUB$M_QUORUM = %X'10000000';
literal CLUB$M_TRANSITION = %X'20000000';
literal CLUB$M_RESLOCKIP = %X'40000000';
literal CLUB$M_QTQEBSY = %X'80000000';
literal CLUB$M_LK_MERGEIP = %X'4';
literal CLUB$M_LK_DO_FULL = %X'8';
literal CLUB$M_LK_FULL = %X'10';
literal CLUB$M_LK_DO_DIR = %X'20';
literal CLUB$M_LK_DIR = %X'40';
literal CLUB$M_LK_NO_RMVDIR = %X'80';
literal CLUB$M_LK_INIT_RBLD = %X'100';
literal CLUB$M_LK_NO_RM = %X'200';
literal CLUB$M_LK_TABLE_V51 = %X'400';
literal CLUB$M_LK_SPECIAL_1 = %X'800';
literal CLUB$M_LK_RM_DSBL = %X'1000';
literal CLUB$M_LK_TABLE_1 = %X'2000';
literal CLUB$M_LK_SHUTDOWN = %X'4000';
literal CLUB$M_LK_SHUT_IP = %X'8000';
literal CLUB$M_NO_FQUORUM = %X'1';
literal CLUB$M_NO_DQUORUM = %X'2';
literal CLUB$M_IFW_REQ = %X'4';
literal CLUB$M_RNS_REQ = %X'8';
literal CLUB$M_CLUGEN_VALID = %X'1';
literal CLUB$C_LENGTH = 576;            !  LENGTH OF CLUB 
literal CLUB$K_LENGTH = 576;            !  LENGTH OF CLUB 
literal CLUB$S_CLUBDEF = 576;           !  Old size name, synonym
literal CLUB$S_CLUB = 576;
macro CLUB$L_CSBQFL = 0,0,32,1 %;       !  CSB QUEUE FORWARD LINK
macro CLUB$L_CSBQBL = 4,0,32,1 %;       !  CSB QUEUE BACKWARD LINK
macro CLUB$W_SIZE = 8,0,16,0 %;         !  SIZE OF CLUB IN BYTES
macro CLUB$B_TYPE = 10,0,8,0 %;         !  STRUCTURE TYPE 
macro CLUB$B_SUBTYPE = 11,0,8,0 %;      !  STRUCTURE SUBTYPE
macro CLUB$L_POLL_CTX = 12,0,32,0 %;    !  SCS POLLER CONTEXT
macro CLUB$L_LOCAL_CSB = 16,0,32,1 %;   !  ADDRESS OF THE CSB FOR LOCAL SYSTEM
macro CLUB$L_ASTQFL = 20,0,32,1 %;      !  AST QUEUE FORWARD LINK
macro CLUB$L_ASTQBL = 24,0,32,1 %;      !  AST QUEUE BACKWARD LINK
macro CLUB$L_FLAGS = 28,0,32,0 %;       !  CLUSTER STATUS FLAGS
macro CLUB$V_CLUSTER = 28,0,1,0 %;      !   THIS NODE IS MEMBER OF CLUSTER
macro CLUB$V_QF_ACTIVE = 28,1,1,0 %;    !   QUORUM FILE IS READABLE, CONTRIBUTE TO STATIC QUORUM
macro CLUB$V_QF_DYNVOTE = 28,2,1,0 %;   !   QUORUM FILE CAN CONTRIBUTE TO DYNAMIC QUORUM
macro CLUB$V_QF_WATCHER = 28,3,1,0 %;   !   NODE IS QUORUM FILE WATCHER
macro CLUB$V_SHUTDOWN = 28,4,1,0 %;     !   NODE READY FOR CLUSTER SHUTDOWN
macro CLUB$V_QF_REFRESH_REQ = 28,5,1,0 %; !   QUORUM FILE REFRESH REQUESTED
macro CLUB$V_STS_PPHASE = 28,8,1,0 %;   !   STATUS ANALYZER POLLING PHASE
macro CLUB$V_STS_PH0 = 28,9,1,0 %;      !   STATUS ANALYZER, PHASE 0 SEEN
macro CLUB$V_STS_PH1B = 28,10,1,0 %;    !   STATUS ANALYZER, PHASE 1 (COORD CNX BROKEN) SEEN
macro CLUB$V_STS_PH1 = 28,11,1,0 %;     !   STATUS ANALYZER, PHASE 1 (COORD CNX OK) SEEN
macro CLUB$V_STS_PH2 = 28,12,1,0 %;     !   STATUS ANALYZER, PHASE 2 SEEN
macro CLUB$V_TDF_VALID = 28,13,1,0 %;   !   Indicates that TDF in club has been written
macro CLUB$V_FKB_BUSY = 28,16,1,0 %;    !   FORK BLOCK IN USE
macro CLUB$V_UNLOCK = 28,17,1,0 %;      !   UNLOCK REQUESTED
macro CLUB$V_NO_FORM = 28,18,1,0 %;     !   PROHIBIT NODE FROM FORMING A NEW CLUSTER
macro CLUB$V_INIT = 28,19,1,0 %;        !   READY FOR CLUSTER JOIN/FORMATION
macro CLUB$V_BACKOUT = 28,20,1,0 %;     !   MUST EVENTUALLY BACK-OUT TRANSITION
macro CLUB$V_PRIOR_PROTOCOL = 28,21,1,0 %; !   Earlier version protocol present 
macro CLUB$V_VERBOSE = 28,22,1,0 %;     !   VERBOSE MODE
macro CLUB$V_LOST_CNX = 28,23,1,0 %;    !   CONNECTION TO CLUSTER MEMBER HAS BEEN LOST
macro CLUB$V_QF_FAILED_NODE = 28,24,1,0 %; !   A NODE HAS BEEN FAILED OUT
macro CLUB$V_QF_VOTE = 28,25,1,0 %;     !   QUORUM DISK IS CONTRIBUTING A (STATIC) VOTE
macro CLUB$V_QF_NEWVOTE = 28,26,1,0 %;  !   STAGING FOR QF_VOTE
macro CLUB$V_ADJ_QUORUM = 28,27,1,0 %;  !   QUORUM ADJUSTMENT REQUESTED
macro CLUB$V_QUORUM = 28,28,1,0 %;      !   CLUSTER IS IN QUORUM
macro CLUB$V_TRANSITION = 28,29,1,0 %;  !   STATE TRANSITION IN PROGRESS
macro CLUB$V_RESLOCKIP = 28,30,1,0 %;   !   RESERVATION LOCK IN PROGRESS
macro CLUB$V_QTQEBSY = 28,31,1,0 %;     !   QUORUM TQE IS ALREADY IN QUE
macro CLUB$L_LK_FLAGS = 32,0,32,0 %;
macro CLUB$V_LK_MERGEIP = 32,2,1,0 %;   !   MERGE IN PROGRESS (LOCAL)
macro CLUB$V_LK_DO_FULL = 32,3,1,0 %;   !   DO A FULL REBUILD
macro CLUB$V_LK_FULL = 32,4,1,0 %;      !   FULL REBUILD
macro CLUB$V_LK_DO_DIR = 32,5,1,0 %;    !   DO A DIRECTORY REBUILD
macro CLUB$V_LK_DIR = 32,6,1,0 %;       !   DIRECTORY REBUILD
macro CLUB$V_LK_NO_RMVDIR = 32,7,1,0 %; !   INHIBIT RMVDIRS
macro CLUB$V_LK_INIT_RBLD = 32,8,1,0 %; !   INITIAL REBUILD FLAG
macro CLUB$V_LK_NO_RM = 32,9,1,0 %;     !   (obsolete)
macro CLUB$V_LK_TABLE_V51 = 32,10,1,0 %; !   (obsolete)
macro CLUB$V_LK_SPECIAL_1 = 32,11,1,0 %; !   (obsolete)
macro CLUB$V_LK_RM_DSBL = 32,12,1,0 %;  !   REMASTER DISABLED DUE TO REBUILD
macro CLUB$V_LK_TABLE_1 = 32,13,1,0 %;  !   FAILOVER TABLE 1 IN USE
macro CLUB$V_LK_SHUTDOWN = 32,14,1,0 %; !   SHUTDOWN REQUESTED
macro CLUB$V_LK_SHUT_IP = 32,15,1,0 %;  !   SHUTDOWN IN PROGRESS
macro CLUB$W_RSEQNUM = 36,0,16,0 %;     !   FULL REBUILD SEQUENCE NUMBER
macro CLUB$W_DIRSEQNUM = 38,0,16,0 %;   !   DIRECTORY REBUILD SEQ
macro CLUB$B_QSTATUS = 40,0,8,0 %;      !  QUORUM STATUS FLAGS
macro CLUB$V_NO_FQUORUM = 40,0,1,0 %;   !   NO FORMAL QUORUM
macro CLUB$V_NO_DQUORUM = 40,1,1,0 %;   !   NO DYNAMIC QUORUM
macro CLUB$V_IFW_REQ = 40,2,1,0 %;      !   INCARNATION FILE WRITE REQUIRED
macro CLUB$V_RNS_REQ = 40,3,1,0 %;      !   REMOVED NODE STATUS REQUIRED
macro CLUB$W_QDVOTES = 42,0,16,0 %;     !  VOTES HELD BY QUORUM DISK
macro CLUB$W_QUORUM = 44,0,16,0 %;      !  CLUSTER QUORUM
macro CLUB$W_VOTES = 46,0,16,0 %;       !  CLUSTER VOTES
macro CLUB$W_CEVOTES = 48,0,16,0 %;     !  UNIVERSE OF VOTES
macro CLUB$W_ADJ_CEVOTES = 50,0,16,0 %; !  UNIVERSE OF VOTES ADJUSTMENT REQUESTED VALUE
macro CLUB$W_NODES = 52,0,16,0 %;       !  NODES IN CLUSTER
macro CLUB$B_FSYSID = 54,0,0,1 %;
literal CLUB$S_FSYSID = 6;              !  FOUNDING NODE'S SYSID
macro CLUB$Q_FTIME = 60,0,0,1 %;
literal CLUB$S_FTIME = 8;               !  FOUNDING TIME
macro CLUB$L_LST_XTN = 68,0,32,0 %;     !  LAST COMPLETED TRANSACTION NUMBER
macro CLUB$L_LST_COORD = 72,0,32,0 %;   !  LAST COMPLETED TRANSACTION COORDINATOR CSID
macro CLUB$Q_LST_TIME = 76,0,0,1 %;
literal CLUB$S_LST_TIME = 8;            !  LAST COMPLETED TRANSACTION TIME-STAMP
macro CLUB$B_LST_CODE = 84,0,8,0 %;     !  LAST COMPLETED TRANSACTION CODE
macro CLUB$B_LST_PHASE = 85,0,8,0 %;    !  LAST COMPLETED TRANSACTION CODE
macro CLUB$W_NEWQDVOTES = 86,0,16,0 %;  !  STAGING FOR QDVOTES
macro CLUB$L_CUR_XTN = 88,0,32,0 %;     !  CURRENT TRANSACTION NUMBER
macro CLUB$L_CUR_COORD = 92,0,32,0 %;   !  CURRENT TRANSACTION COORDINATOR CSID
macro CLUB$Q_CUR_TIME = 96,0,0,1 %;
literal CLUB$S_CUR_TIME = 8;            !  CURRENT TRANSACTION TIME-STAMP
macro CLUB$B_CUR_CODE = 104,0,8,0 %;    !  TRANSACTION CODE
macro CLUB$B_CUR_PHASE = 105,0,8,0 %;   !  TRANSACTION PHASE
macro CLUB$W_MSGCNT = 106,0,16,0 %;     !  OUTSTANDING/WAITING MESSAGE COUNT
macro CLUB$L_COORD = 108,0,32,1 %;      !  COORDINATOR'S CSB ADDRESS
macro CLUB$L_LOCAL_CSID = 112,0,32,0 %; !  LOCAL SYSTEM CSID
macro CLUB$W_LOCAL_CSID_IDX = 112,0,16,0 %; !  SLOT INDEX
macro CLUB$W_LOCAL_CSID_SEQ = 114,0,16,0 %; !  SEQUENCE NUMBER
macro CLUB$W_NEXT_CSID = 116,0,16,0 %;  !  INDEX OF NEXT CSID TO ASSIGN
macro CLUB$W_FIRST_INDEX = 118,0,16,0 %; !  INDEX OF FIRST CSID ASSIGNED
macro CLUB$L_MAX_XTN = 120,0,32,0 %;    !  LARGEST TRANSACTION ID SEEN
macro CLUB$L_RETRYCNT = 124,0,32,0 %;   !  RESOURCE ALLOCATION RETRIES AVAILABLE
macro CLUB$L_CTX0 = 128,0,32,0 %;       !  LEVEL 0 CONTEXT AREA
macro CLUB$L_RET1 = 132,0,32,0 %;       !  LEVEL 1 SUBROUTINE RETURN
macro CLUB$L_CTX1 = 136,0,32,0 %;       !  LEVEL 1 CONTEXT AREA
macro CLUB$L_RET2 = 140,0,32,0 %;       !  LEVEL 2 SUBROUTINE RETURN
macro CLUB$L_CTX2 = 144,0,32,0 %;       !  LEVEL 2 CONTEXT AREA
macro CLUB$L_TQE = 148,0,32,1 %;        !  ADDRESS OF TIMER ENTRY
macro CLUB$L_CSPIPID = 152,0,32,0 %;    !  PID OF CLUSTER SERVER (FOR SCH$WAKE)
macro CLUB$Q_NEWTIME = 156,0,0,0 %;
literal CLUB$S_NEWTIME = 8;             !  NEW VALUE OF TIME
macro CLUB$Q_NEWTIME_REF = 164,0,0,0 %;
literal CLUB$S_NEWTIME_REF = 8;         !  LOCAL REFERENCE FOR NEW TIME
macro CLUB$W_NEWQUORUM = 172,0,16,0 %;  !  NEW VALUE FOR QUORUM
macro CLUB$W_NEWCEVOTES = 174,0,16,0 %; !  NEW UNIVERSE OF VOTES 
macro CLUB$L_FMERIT = 176,0,32,0 %;     !  FIGURE OF MERIT FOR OPTIMAL CLUSTER
macro CLUB$L_E_MEMSEQ = 180,0,32,0 %;   !  EXTENDED MEMBERSHIP STATE SEQUENCE NUMBER
macro CLUB$W_MEMSEQ = 180,0,16,0 %;     !  MEMBERSHIP STATE SEQUENCE NUMBER
macro CLUB$L_RANDOM = 184,0,32,0 %;     !  RANDOM NUMBER GENERATOR CONTEXT
macro CLUB$L_CLUDCB = 188,0,32,1 %;     !  ADDRESS OF QUORUM DISK CONTROL BLOCK
macro CLUB$T_QDNAME = 192,0,0,0 %;
literal CLUB$S_QDNAME = 16;             !  QUORUM DISK FULLDEVNAM
macro CLUB$L_CLUICB = 208,0,32,1 %;     !  ADDRESS OF INCARNATION FILE CONTROL BLOCK
macro CLUB$L_FOREIGN_CLUSTER = 212,0,32,0 %; !  SHIFT REGISTER INDICATING FOREIGN CLUSTER SEEN
macro CLUB$L_ENBL_VERBOSE = 216,0,32,0 %; !  TIME TO ENABLE VERBOSE MODE
macro CLUB$L_QLOST_CLUGEN = 220,0,32,0 %; !  CLUSTER GENERATION WHEN QUORUM LOST
macro CLUB$L_STG_JOIN_CLUGEN = 224,0,32,0 %; !  STAGING AREA FOR CLUSTER GENERATION
macro CLUB$L_JOIN_CLUGEN = 228,0,32,0 %; !  JOINING NODE'S LAST CLUSTER GENERATION NUMBER
macro CLUB$W_STG_JOIN_FLAGS = 232,0,16,0 %; !  STAGING AREA FOR JOIN FLAGS
macro CLUB$W_JOIN_FLAGS = 234,0,16,0 %; !  JOINING NODE'S FLAGS
macro CLUB$V_CLUGEN_VALID = 234,0,1,0 %; !   GENERATION DATA FIELDS VALID
macro CLUB$Q_CSPQ = 240,0,0,0 %;
literal CLUB$S_CSPQ = 8;                !  QUEUE FOR COMMUNICATION WITH CSP
macro CLUB$B_FORK_BLOCK = 248,0,0,1 %;
literal CLUB$S_FORK_BLOCK = 40;         !  FORK BLOCK TO WAIT IN (CLUBFKB SUB-STRUCTURE)
macro CLUB$B_NODEMAP = 288,0,0,1 %;
literal CLUB$S_NODEMAP = 32;            !  BITMAP OF ALL POSSIBLE NODES
macro CLUB$B_CLUFCB = 320,0,0,1 %;
literal CLUB$S_CLUFCB = 120;            !  CLUSTER FAILOVER CONTROL BLOCK
macro CLUB$B_HANG_FKB = 440,0,0,1 %;
literal CLUB$S_HANG_FKB = 32;           !  FORK BLOCK TO USE TO BLOCK ACTIVITY AT IPL 4
macro CLUB$B_CLUBPWF = 472,0,0,1 %;
literal CLUB$S_CLUBPWF = 40;            !  FORK BLOCK TO USE DURING POWER RECOVERY
!  New cells located at end to minimize rebuiding.  Should be moved someday.
macro CLUB$L_RESLOCKTMO = 512,0,32,0 %; !  RESERVATION EXPIRATION TIME
macro CLUB$L_RESLOCKCSID = 516,0,32,0 %; !  CSID OF RESERVATION HOLDER
macro CLUB$L_LOCKTIME = 520,0,32,0 %;   !  TIME LOCKED
macro CLUB$W_MERGE_CNT = 524,0,16,0 %;  !  MERGE COUNTER
macro CLUB$W_PARSEQNUM = 526,0,16,0 %;  !  PARTIAL REBUILD SEQUENCE NUMBER
macro CLUB$B_NEWRBLD_REQ = 528,0,8,0 %; !  PROPOSED REBUILD REQUEST
macro CLUB$B_RBLD_CLU = 529,0,8,0 %;    !  REBUILD IN PROGRESS IN CLUSTER
macro CLUB$B_RBLD_LOC = 530,0,8,0 %;    !  REBUILD IN PROGRESS ON LOCAL NODE
macro CLUB$L_CLURCBFL = 532,0,32,1 %;   !  ACTIVE RCBs
macro CLUB$L_CLURCBBL = 536,0,32,1 %;   ! 
macro CLUB$W_RBLD_INHIB = 540,0,16,0 %; !  REASONS TO INHIBIT A LOCK REBUILD
macro CLUB$B_RM_QUOTA = 542,0,8,0 %;    !  REMASTERING QUOTA
macro CLUB$W_NCNID = 544,0,16,0 %;      !  NEXT CLUSTER NODE ID
macro CLUB$W_NEWNCNID = 546,0,16,0 %;   !  NEW NEXT CLUSTER NODE ID
macro CLUB$L_TOFF = 548,0,32,0 %;       !  LOCKING OFF
macro CLUB$L_TON = 552,0,32,0 %;        !  LOCKING ON
macro CLUB$L_TBLS = 556,0,32,1 %;       !  TABLE START
macro CLUB$L_QTQE = 560,0,32,1 %;       !  POINTER TO QUORUM LOSS TQE
macro CLUB$L_SYNC_STEP = 564,0,32,0 %;  !  SYNC STEP COUNT (move to clurcb)
macro CLUB$Q_TDF = 568,0,0,0 %;
literal CLUB$S_TDF = 8;                 !  DTS TDF
 
!*** MODULE $CLUDCBDEF ***
! +
!  CLUDCB - Cluster Quorum Disk Control Block
! -
literal CLUDCB$M_QS_REM_INA = %X'1';
literal CLUDCB$M_QS_REM_ACT = %X'2';
literal CLUDCB$M_QS_NOT_READY = %X'4';
literal CLUDCB$M_QS_READY = %X'8';
literal CLUDCB$M_QS_ACTIVE = %X'10';
literal CLUDCB$M_QS_CLUSTER = %X'20';
literal CLUDCB$M_QS_VOTE = %X'40';
literal CLUDCB$M_QF_INQTMO = %X'1';
literal CLUDCB$M_QF_INQIP = %X'2';
literal CLUDCB$M_QF_TIM = %X'4';
literal CLUDCB$M_QF_RIP = %X'8';
literal CLUDCB$M_QF_WIP = %X'10';
literal CLUDCB$M_QF_ERROR = %X'20';
literal CLUDCB$M_QF_FIRST_ERR = %X'40';
literal CLUDCB$M_QF_WRL_ERR = %X'80';
literal CLUDCB$M_QF_NOACCESS = %X'100';
literal CLUDCB$M_CSP_ACK = %X'1';
literal CLUDCB$M_CSP_LBN_VALID = %X'2';
literal CLUDCB$M_CSP_MVHELP = %X'4';
literal CLUDCB$K_F_LENGTH = 64;         !  Length of fixed portion of CLUDCB
literal CLUDCB$C_F_LENGTH = 64;         !  Length of fixed portion of CLUDCB
literal CLUDCB$K_LENGTH = 580;          !  Length of CLUDCB
literal CLUDCB$C_LENGTH = 580;          !  Length of CLUDCB
!  The quorum disk is specified with 4 sysgen parameters. DISK_QUORUM1
literal CLUDCB$S_DISK_QUORUM = 16;
literal CLUDCB$S_CLUDCB = 580;
macro CLUDCB$L_CLUDCBFL = 0,0,32,1 %;   !  Forward Link (not used)
macro CLUDCB$L_CLUDCBBL = 4,0,32,1 %;   !  Backward Link (not used)
macro CLUDCB$W_SIZE = 8,0,16,0 %;       !  Size of CLUDCB (bytes)
macro CLUDCB$B_TYPE = 10,0,8,0 %;       !  Structure type
macro CLUDCB$B_SUBTYPE = 11,0,8,0 %;    !  Structure subtype
macro CLUDCB$L_UCB = 12,0,32,1 %;       !  Address of quorum disk UCB
macro CLUDCB$L_IRP = 16,0,32,1 %;       !  Address of IRP
macro CLUDCB$L_TQE = 20,0,32,1 %;       !  Address of timer queue entry
macro CLUDCB$L_WATCHER_CSID = 24,0,32,0 %; !  CSID of quorum file watcher
macro CLUDCB$L_ACT_COUNT = 28,0,32,0 %; !  Saved activity counter
macro CLUDCB$L_QFLBN = 32,0,32,0 %;     !  Quorum file logical block number
macro CLUDCB$W_STATE = 40,0,16,0 %;     !  Quorum disk state bits
macro CLUDCB$V_QS_REM_INA = 40,0,1,0 %; !  Remote inactive
macro CLUDCB$V_QS_REM_ACT = 40,1,1,0 %; !  Remote active
macro CLUDCB$V_QS_NOT_READY = 40,2,1,0 %; !  Not ready
macro CLUDCB$V_QS_READY = 40,3,1,0 %;   !  Ready
macro CLUDCB$V_QS_ACTIVE = 40,4,1,0 %;  !  Active
macro CLUDCB$V_QS_CLUSTER = 40,5,1,0 %; !  Active and this node is a cluster member
macro CLUDCB$V_QS_VOTE = 40,6,1,0 %;    !  Potential vote
macro CLUDCB$W_FLAGS = 44,0,16,0 %;     !  CLUDCB status bits
macro CLUDCB$V_QF_INQTMO = 44,0,1,0 %;  !  Status inquiry timed out
macro CLUDCB$V_QF_INQIP = 44,1,1,0 %;   !  Remote inquiry in progress
macro CLUDCB$V_QF_TIM = 44,2,1,0 %;     !  Read or write timed out
macro CLUDCB$V_QF_RIP = 44,3,1,0 %;     !  Read in progress
macro CLUDCB$V_QF_WIP = 44,4,1,0 %;     !  Write in progress
macro CLUDCB$V_QF_ERROR = 44,5,1,0 %;   !  Quorum disk error has been reported
macro CLUDCB$V_QF_FIRST_ERR = 44,6,1,0 %; !  First error has already been seen
macro CLUDCB$V_QF_WRL_ERR = 44,7,1,0 %; !  Quorum disk is write-locked
macro CLUDCB$V_QF_NOACCESS = 44,8,1,0 %; !  Never access the quorum disk directly
!  The interlocked flags field is in its own quadword for granulary reasons
macro CLUDCB$W_CSP_FLAGS = 48,0,16,0 %; !  Flags for interlocked communication with CSP
macro CLUDCB$V_CSP_ACK = 48,0,1,0 %;    !  CSP request has been acknowledged
macro CLUDCB$V_CSP_LBN_VALID = 48,1,1,0 %; !  CSP has found a quorum file
macro CLUDCB$V_CSP_MVHELP = 48,2,1,0 %; !  Restart mount verification 
macro CLUDCB$B_COUNTER = 56,0,8,0 %;    !  Iteration counter
macro CLUDCB$T_BUFFER = 64,0,0,0 %;
literal CLUDCB$S_BUFFER = 516;          !  Quorum file buffer
!  to DISK_QUORUM4. Each parameter can specify 4 bytes.
 
!*** MODULE $CLUDEF ***
! +
!  CLUDEF - CLUSTER DEFINITIONS
! -
literal CLU$C_MAX_NODES = 256;          !  MAX CLUSTER NODES
literal CLU$K_MAX_NODES = 256;          !  MAX CLUSTER NODES
 
!*** MODULE $CLUEVTIDEF ***
!  get the ACB def
!  get the CLUEVTHNDL def
literal CLUACB$K_LENGTH = 52;           !  Length of block.
literal CLUACB$C_LENGTH = 52;           !  Length of block.
literal cluacb$S_cluacb = 52;
macro cluacb$r_generic_acb = 0,0,0,0 %;
literal cluacb$s_generic_acb = 36;
macro cluacb$r_handle = 36,0,0,0 %;
literal cluacb$s_handle = 8;            !  unique handle id (in case of cancellation)
macro cluacb$l_event = 44,0,32,0 %;     !  event type value
macro cluacb$l_local_queue = 48,0,32,1 %; !  set indicates CLUACB on CLUEVT private queue
literal CLUEVT$K_LENGTH = 64;           !  Length of block.
literal CLUEVT$C_LENGTH = 64;           !  Length of block.
literal cluevt$S_cluevt = 64;
macro cluevt$l_reserved_1 = 0,0,32,0 %; !  set up default header
macro cluevt$l_reserved_2 = 4,0,32,0 %;
macro cluevt$w_size = 8,0,16,0 %;
macro cluevt$b_type = 10,0,8,0 %;
macro cluevt$b_subtype = 11,0,8,0 %;
macro cluevt$l_seq_num = 12,0,32,0 %;   !  ever increasing counter
macro cluevt$l_add_qfl = 16,0,32,1 %;   !  queued CLUACBs
macro cluevt$l_add_qbl = 20,0,32,1 %;
macro cluevt$l_rem_qfl = 24,0,32,1 %;
macro cluevt$l_rem_qbl = 28,0,32,1 %;
macro cluevt$l_reserved_3 = 32,0,32,0 %; !  reserved for future use
macro cluevt$l_reserved_4 = 36,0,32,0 %;
macro cluevt$l_reserved_5 = 40,0,32,0 %;
macro cluevt$l_reserved_6 = 44,0,32,0 %;
macro cluevt$l_reserved_7 = 48,0,32,0 %;
macro cluevt$l_reserved_8 = 52,0,32,0 %;
macro cluevt$l_reserved_9 = 56,0,32,0 %;
macro cluevt$l_reserved_0 = 60,0,32,0 %;
 
!*** MODULE $CLUICBDEF ***
! +
!  CLUICB - Incarnation File Control Block
! -
literal CLUICB$M_WIP = %X'1';
literal CLUICB$M_WREQ = %X'2';
literal CLUICB$K_F_LENGTH = 32;         !  Length of fixed portion
literal CLUICB$C_F_LENGTH = 32;         !  Length of fixed portion
!  End of fixed portion of the block
literal CLUICB$T_BUFFER = 32;           !  Start of incarnation
!   file buffer area
literal CLUICB$S_CLUICB = 32;
!  Fixed portion
macro CLUICB$L_FL = 0,0,32,1 %;         !  Forward Link
macro CLUICB$L_BL = 4,0,32,1 %;         !  Backward Link
macro CLUICB$W_SIZE = 8,0,16,0 %;       !  Size of block
macro CLUICB$B_TYPE = 10,0,8,0 %;       !  Structure type
macro CLUICB$B_SUBTYPE = 11,0,8,0 %;    !  Structure subtype
macro CLUICB$L_IRP = 12,0,32,1 %;       !  Address of IRP
macro CLUICB$L_LBN = 16,0,32,0 %;       !  Incarnation file logical block number
macro CLUICB$W_WIP_CNT = 20,0,16,0 %;   !  Write-in-progress counter
macro CLUICB$W_FLAGS = 24,0,16,0 %;     !  Flags
macro CLUICB$V_WIP = 24,0,1,0 %;        !  Write-in-progress bit 
macro CLUICB$V_WREQ = 24,1,1,0 %;       !  Write requested bit
 
!*** MODULE $CLUOPTDEF ***
! +
!  CLUOPT - Cluster Optimal ReConfiguration Context Block
! -
literal CLUOPT$K_LENGTH = 116;          !  Length of CLUOPT
literal CLUOPT$C_LENGTH = 116;          !  Length of CLUOPT
literal CLUOPT$S_CLUOPT = 116;
macro CLUOPT$L_PREV = 0,0,32,1 %;       !  Link to previous CLUOPT block
macro CLUOPT$W_SIZE = 8,0,16,0 %;       !  Size of CLUOPT (bytes)
macro CLUOPT$B_TYPE = 10,0,8,0 %;       !  Structure type
macro CLUOPT$B_SUBTYPE = 11,0,8,0 %;    !  Structure subtype
macro CLUOPT$L_CMERIT = 12,0,32,0 %;    !  Figure of merit of nodes in CMAP
macro CLUOPT$L_ACMERIT = 16,0,32,0 %;   !  Figure of merit of nodes in AMAP + CMAP
macro CLUOPT$B_CMAP = 20,0,0,1 %;
literal CLUOPT$S_CMAP = 32;             !  Map of nodes in proposed cluster
macro CLUOPT$B_AMAP = 52,0,0,1 %;
literal CLUOPT$S_AMAP = 32;             !  Map of nodes available for cluster
macro CLUOPT$B_RMAP = 84,0,0,1 %;
literal CLUOPT$S_RMAP = 32;             !  Map of nodes remaining for consideration
 
!*** MODULE $CLUPBDEF ***
! +
!  CLUPB - PARALLEL CONTEXT BLOCK
! 
! -
literal CLUPB$M_BUSY = %X'1';
literal CLUPB$K_FIX_LENGTH = 52;
!   Optional extensions for user's of the service
literal CLUPB$K_RBLD_LENGTH = 72;
literal CLUPB$K_LENGTH = 72;            ! LENGTH
literal CLUPB$C_LENGTH = 72;            ! LENGTH
literal CLUPB$S_CLUPBDEF = 72;
literal CLUPB$S_CLUPB = 72;
!  This section reserved for the service itself
macro CLUPB$B_FORK_BLOCK = 0,0,0,1 %;
literal CLUPB$S_FORK_BLOCK = 32;        !  FORK BLOCK
macro CLUPB$W_FLAGS = 32,0,16,0 %;      !  STATUS FLAGS
macro CLUPB$V_BUSY = 32,0,1,0 %;
macro CLUPB$B_THREADS = 34,0,8,0 %;     !  ACTIVE THREADS
macro CLUPB$B_MAX_THREADS = 35,0,8,0 %; !  MAX ACTIVE THREADS
macro CLUPB$L_PARENT = 36,0,32,0 %;     !  PARENT CONTEXT BLOCK
!  This section filled in by user of service
macro CLUPB$L_ACTION = 40,0,32,1 %;     !  ACTION ROUTINE
macro CLUPB$L_CPLRTN = 44,0,32,1 %;     !  COMPLETION ROUTINE
macro CLUPB$L_CPLPRM = 48,0,32,0 %;     !  COMPLETION PARAMETER
!   Lock rebuild extensions
macro CLUPB$L_RTN1 = 52,0,32,0 %;       !  SAVED RETURN ADDRESS
macro CLUPB$L_RTRSB = 56,0,32,1 %;      !  ROOT RSB
macro CLUPB$L_RSB_LIST = 60,0,32,1 %;   !  RSB LIST ADDRESS
macro CLUPB$L_LKB_LIST = 64,0,32,1 %;   !  LKB LIST ADDRESS
macro CLUPB$B_QCNT = 68,0,8,0 %;        !  QUEUE COUNTER
!   Other extensions can go here
 
!*** MODULE $CLURCBDEF ***
! +
!  CLURCB - REMASTER CONTROL BLOCK
! 
! -
literal CLURCB$M_BUSY = %X'1';
literal CLURCB$M_FQ = %X'2';
literal CLURCB$M_EXP_DONE_VLD = %X'4';
literal CLURCB$M_QUOTA = %X'8';
literal CLURCB$M_OLDMST = %X'10';
literal CLURCB$M_EXPMSG = %X'20';
literal CLURCB$M_TQE = %X'40';
literal CLURCB$M_CANCEL = %X'80';
literal CLURCB$K_LENGTH = 276;          ! LENGTH OF CLURCB
literal CLURCB$C_LENGTH = 276;          ! LENGTH OF CLURCB
literal CLURCB$S_CLURCBDEF = 276;       ! Old size name synonym
literal CLURCB$S_CLURCB = 276;
macro CLURCB$L_CLURCBFL = 0,0,32,1 %;   !  FORWARD LINK
macro CLURCB$L_CLURCBBL = 4,0,32,1 %;   !  BACKWARD LINK
macro CLURCB$W_SIZE = 8,0,16,0 %;       !  SIZE IN BYTES
macro CLURCB$B_TYPE = 10,0,8,0 %;       !  STRUCTURE TYPE 
macro CLURCB$B_SUBTYPE = 11,0,8,0 %;    !  STRUCTURE SUBTYPE
macro CLURCB$W_RSEQNUM = 12,0,16,0 %;   !  FULL REBUILD SEQ NUM
macro CLURCB$W_PARSEQNUM = 14,0,16,0 %; !  PARTIAL REBUILD SEQ NUM
!  Align the fork block
macro CLURCB$B_FORK_BLOCK = 16,0,0,1 %;
literal CLURCB$S_FORK_BLOCK = 64;       !  FORK BLOCK / TQE TO WAIT IN
macro CLURCB$L_FLAGS = 80,0,32,0 %;     !  STATUS FLAGS
macro CLURCB$V_BUSY = 80,0,1,0 %;       !  Fork block in use
macro CLURCB$V_FQ = 80,1,1,0 %;         !  On fork queue
macro CLURCB$V_EXP_DONE_VLD = 80,2,1,0 %; !  Expected done count valid
macro CLURCB$V_QUOTA = 80,3,1,0 %;      !  Quota charged
macro CLURCB$V_OLDMST = 80,4,1,0 %;     !  Old master
macro CLURCB$V_EXPMSG = 80,5,1,0 %;     !  Message expected
macro CLURCB$V_TQE = 80,6,1,0 %;        !  Queued as TQE
macro CLURCB$V_CANCEL = 80,7,1,0 %;     !  Cancel TQE thread
macro CLURCB$B_QCNT = 84,0,8,0 %;       !  LOCK QUEUE COUNTER
macro CLURCB$L_LKB_LIST = 88,0,32,1 %;  !  ADDRESS OF LKB LIST
macro CLURCB$L_RSB_LIST = 92,0,32,1 %;  !  ADDRESS OF RSB LIST
macro CLURCB$L_CNTX1 = 96,0,32,0 %;     !  CONTEXT STORAGE
macro CLURCB$L_CNTX2 = 100,0,32,0 %;    !  CONTEXT STORAGE
macro CLURCB$L_WAITRET = 104,0,32,1 %;  !  RETURN PC STORAGE
macro CLURCB$L_ERRRET = 108,0,32,1 %;   !  RETURN PC ON ERROR
macro CLURCB$L_EXPTIME = 112,0,32,0 %;  !  Expiration time
macro CLURCB$W_EXP_DONE = 116,0,16,0 %; !  RBLD_DONES expected
macro CLURCB$W_RCV_DONE = 118,0,16,0 %; !  RBLD_DONES received
macro CLURCB$L_NEWMASTER = 120,0,32,0 %; !  NEW MASTER'S CSID
macro CLURCB$L_OLDMASTER = 124,0,32,0 %; !  OLD MASTER'S CSID
macro CLURCB$L_RSB = 128,0,32,1 %;      !  ADDRESS OF ROOT RSB
macro CLURCB$L_CLUB = 132,0,32,1 %;     !  ADDRESS OF CLUB
macro CLURCB$W_RESPCNT = 136,0,16,0 %;  !  EXPECTED RESPONSE COUNT
macro CLURCB$W_INDEX = 138,0,16,0 %;    !  MAP INDEX    
macro CLURCB$L_SAVRTN = 140,0,32,1 %;   !  SAVED RETURN ADDRESS
macro CLURCB$L_MSGBLD = 144,0,32,1 %;   !  MESSAGE BUILD ROUTINE
macro CLURCB$B_NODEMAP = 148,0,0,1 %;
literal CLURCB$S_NODEMAP = 32;          !  NODES TO REBUILD
macro CLURCB$B_SHUTMAP = 180,0,0,1 %;
literal CLURCB$S_SHUTMAP = 32;          !  NODES WITH TRAFFIC SHUTDOWN
macro CLURCB$B_ACKMAP = 212,0,0,1 %;
literal CLURCB$S_ACKMAP = 32;           !  NODES RETURNING ACKS
macro CLURCB$B_RESMAP = 244,0,0,1 %;
literal CLURCB$S_RESMAP = 32;           !  NODES NEEDING RESUMPTION
 
!*** MODULE $CLUSDADEF ***
! +
! 	$CLUSDADEF - define an incoming connect block.  This block handles
! 	all of the activity for one connection.  Since only one command
! 	can be active at any time, a permanent CDRP is allocated with
! 	this block.
! -
literal CLUSDA$C_BUGCHK = 1;            !   Cluster bugcheck protocol
literal CLUSDA$C_PRTLEV = 2;            !   Remote SDA Protocol level
literal CLUSDA$C_IDLE = 0;              !   Idle
literal CLUSDA$C_ACTIVE = 1;            !   CDRP is in use
literal CLUSDA$C_LENGTH = 24;           !  LENGTH OF FIXED PART
literal CLUSDA$K_LENGTH = 24;           !  LENGTH OF FIXED PART
literal CLUSDA$S_CLUSDADEF = 25;
literal CLUSDA$S_CLUSDA = 25;
! 
macro CLUSDA$L_FLINK = 0,0,32,1 %;      !  Queue forward link
macro CLUSDA$L_BLINK = 4,0,32,1 %;      !  Queue backward link
macro CLUSDA$W_SIZE = 8,0,16,0 %;       !  Structure size
macro CLUSDA$W_TYPE = 10,0,16,0 %;      !  Structure type
macro CLUSDA$L_CDT = 12,0,32,1 %;       !  CDT address
macro CLUSDA$L_PDT = 16,0,32,1 %;       !  PDT address
macro CLUSDA$W_STATE = 20,0,16,0 %;     !  Connect state
!  State values
macro CLUSDA$B_CDRP = 24,0,8,1 %;
literal CLUSDA$S_CDRP = 1;              !  Start of permanent CDRP
 
!*** MODULE $CMNBDLTDEF ***
literal CMNBDLT$K_RESERVED_LENGTH = 80; !  Length of Reserved area
literal CMNBDLT$K_LENGTH = 128;         !  Length of Header
literal CMNBDLT$C_LENGTH = 128;         !  Length of Header 
literal CMNBDLT$C_LEAF_ENTRY_SZ = 16;   !  Length of one leaf pointer entry
literal CMNBDLT$C_INIT_BDLT_INDEX = 7;
!  Initial BDLT LAST_INDEX, used to show space occupied by BDLT header is in use
literal CMNBDLT$S_CMNBDLTDEF = 144;     !  Old size name - synonym
literal CMNBDLT$S_CMNBDLT = 144;
macro CMNBDLT$Q_PHY_ADDR = 0,0,0,0 %;
literal CMNBDLT$S_PHY_ADDR = 8;         !  BDLT physical address        
macro CMNBDLT$W_SIZE = 8,0,16,0 %;      !  Structure size in bytes 
macro CMNBDLT$B_TYPE = 10,0,8,0 %;      !  Structure Type 
macro CMNBDLT$B_SUBTYPE = 11,0,8,0 %;   !  Structure Subtype for BDLT 
macro CMNBDLT$L_BD_CNT = 12,0,32,0 %;   !  Current number of assigned BDs
macro CMNBDLT$L_FILL = 16,0,32,0 %;     !  Unused for alignment
macro CMNBDLT$L_QBDLT_CNT = 20,0,32,0 %; !  Count of BDLT waits
macro CMNBDLT$L_LAST_INDEX = 24,0,32,0 %; !  Highest current BDLT Index
macro CMNBDLT$L_MAX_INDEX = 28,0,32,0 %; !  Maximum allowed BDLT Index
macro CMNBDLT$L_FREE_BD = 32,0,32,1 %;  !  Free BD list
macro CMNBDLT$L_PORT_PTR = 36,0,32,1 %; !  reserved for port/port driver pointer
macro CMNBDLT$L_WAITFL = 40,0,32,1 %;   !  BD Wait Queue FLINK 
macro CMNBDLT$L_WAITBL = 44,0,32,1 %;   !  BD Wait Queue BLINK 
macro CMNBDLT$Q_RESERVED_1 = 48,0,0,0 %;
literal CMNBDLT$S_RESERVED_1 = 8;       !  Reserved quadword 
macro CMNBDLT$Q_RESERVED_2 = 56,0,0,0 %;
literal CMNBDLT$S_RESERVED_2 = 8;       !  Reserved quadword 
macro CMNBDLT$Q_RESERVED_3 = 64,0,0,0 %;
literal CMNBDLT$S_RESERVED_3 = 8;       !  Reserved quadword 
macro CMNBDLT$Q_RESERVED_4 = 72,0,0,0 %;
literal CMNBDLT$S_RESERVED_4 = 8;       !  Reserved quadword 
macro CMNBDLT$Q_RESERVED_5 = 80,0,0,0 %;
literal CMNBDLT$S_RESERVED_5 = 8;       !  Reserved quadword 
macro CMNBDLT$Q_RESERVED_6 = 88,0,0,0 %;
literal CMNBDLT$S_RESERVED_6 = 8;       !  Reserved quadword 
macro CMNBDLT$Q_RESERVED_7 = 96,0,0,0 %;
literal CMNBDLT$S_RESERVED_7 = 8;       !  Reserved quadword 
macro CMNBDLT$Q_RESERVED_8 = 104,0,0,0 %;
literal CMNBDLT$S_RESERVED_8 = 8;       !  Reserved quadword 
macro CMNBDLT$Q_RESERVED_9 = 112,0,0,0 %;
literal CMNBDLT$S_RESERVED_9 = 8;       !  Reserved quadword 
macro CMNBDLT$Q_RESERVED_10 = 120,0,0,0 %;
literal CMNBDLT$S_RESERVED_10 = 8;      !  Reserved quadword 
macro CMNBDLT$Q_BDL_PTR0_PHY = 128,0,0,0 %;
literal CMNBDLT$S_BDL_PTR0_PHY = 8;     !  Buffer Descriptor 0 Leaf Physical Pointer
macro CMNBDLT$Q_BDL_PTR0_VIR = 136,0,0,0 %;
literal CMNBDLT$S_BDL_PTR0_VIR = 8;     !  Buffer Descriptor 0 Leaf Virtual Pointer
 
!*** MODULE $CONDEF ***
! +
! 
!  Console function codes (defined in SRM).
! 
! -
literal CON$C_SWDONE = 1;               !  Software done
literal CON$C_BOOTCPU = 2;              !  Boot function code
literal CON$C_CLRWARM = 3;              !  Clear warm start flag
literal CON$C_CLRCOLD = 4;              !  Clear cold start flag
! +
! 
!  Routine specifier codes used when calling CON$ASSIST_PSWITCH
! 
! -
literal CON$C_START_SWITCH = 1;         !  Start primary switch operation
literal CON$C_ABORT_SWITCH = 2;         !  Abort primary switch operation
literal CON$C_FINISH_SWITCH = 3;        !  Finish primary switch operation
literal RXCST$M_IE = %X'40';
literal RXCST$M_RDY = %X'80';
literal RXCST$S_RXCST = 1;
macro RXCST$V_IE = 0,6,1,0 %;           !  Receiver Interrupt Enable
macro RXCST$V_RDY = 0,7,1,0 %;          !  Receiver Data Ready
literal TXCST$M_IE = %X'40';
literal TXCST$M_RDY = %X'80';
literal TXCST$M_ERR = %X'8000';
literal TXCST$S_TXCST = 2;
macro TXCST$V_IE = 0,6,1,0 %;           !  Transmitter Interrupt Enable
macro TXCST$V_RDY = 0,7,1,0 %;          !  Transmitter Ready for Input
macro TXCST$V_ERR = 0,15,1,0 %;         !  Error sending, pls re-transmit
literal RXTX$M_ERR = %X'8000';
literal RXTX$S_RXTX = 2;
macro RXTX$V_DATA = 0,0,8,0 %;
literal RXTX$S_DATA = 8;                !  Data field of RXDB/TXDB
macro RXTX$V_ID = 0,8,4,0 %;
literal RXTX$S_ID = 4;                  !  ID field of RXDB/TXDB
macro RXTX$V_ERR = 0,15,1,0 %;          !  Error bit, RXDB only
 
!*** MODULE $COREIODEF ***
literal COREIO$M_LDP_DMA_PA_LO = %X'FFFE0';
literal COREIO$M_LDP_DMA_PA_HI = %X'FFF00000';
literal COREIO$M_SCOMM_TR_DMA_PA = %X'FFFFFFE0';
literal COREIO$M_SCOMM_RC_DMA_PA = %X'FFFFFFE0';
literal COREIO$M_PRINTER_TR_DMA_PA = %X'FFFFFFE0';
literal COREIO$M_PRINTER_RC_DMA_PA = %X'FFFFFFE0';
literal COREIO$M_ISDN_TR_DMA_PA = %X'FFFFFFE0';
literal COREIO$M_ISDN_TR_BUF_DMA_PA = %X'FFFFFFE0';
literal COREIO$M_ISDN_RC_DMA_PA = %X'FFFFFFE0';
literal COREIO$M_ISDN_RC_BUF_DMA_PA = %X'FFFFFFE0';
literal COREIO$M_SSR_GPO_0 = %X'1';
literal COREIO$M_SSR_GPO_1 = %X'2';
literal COREIO$M_SSR_GPO_2 = %X'4';
literal COREIO$M_SSR_GPO_3 = %X'8';
literal COREIO$M_SSR_GPO_4 = %X'10';
literal COREIO$M_SSR_GPO_5 = %X'20';
literal COREIO$M_SSR_GPO_6 = %X'40';
literal COREIO$M_SSR_GPO_7 = %X'80';
literal COREIO$M_SSR_GPO_8 = %X'100';
literal COREIO$M_SSR_GPO_9 = %X'200';
literal COREIO$M_SSR_GPO_10 = %X'400';
literal COREIO$M_SSR_GPO_11 = %X'800';
literal COREIO$M_SSR_GPO_12 = %X'1000';
literal COREIO$M_SSR_GPO_13 = %X'2000';
literal COREIO$M_SSR_GPO_14 = %X'4000';
literal COREIO$M_SSR_GPO_15 = %X'8000';
literal COREIO$M_SSR_LANCE_DMA_EN = %X'10000';
literal COREIO$M_SSR_SCSI_DMA_EN = %X'20000';
literal COREIO$M_SSR_SCSI_DMA_DIR = %X'40000';
literal COREIO$M_SSR_ISDN_RCV_EN = %X'80000';
literal COREIO$M_SSR_ISDN_TR_EN = %X'100000';
literal COREIO$M_SSR_FLOPPY_DMA_EN = %X'200000';
literal COREIO$M_SSR_FLOPPY_DMA_DIR = %X'400000';
literal COREIO$M_SSR_SCC1_RC_DMA_EN = %X'10000000';
literal COREIO$M_SSR_SCC1_TR_DMA_EN = %X'20000000';
literal COREIO$M_SSR_SCC0_RC_DMA_EN = %X'40000000';
literal COREIO$M_SSR_SCC0_TR_DMA_EN = %X'80000000';
literal COREIO$M_SSR_LEDS = %X'FF';
literal COREIO$M_SSR_LANCE_RESET = %X'100';
literal COREIO$M_SSR_RTC_RESET = %X'400';
literal COREIO$M_SSR_SSC_RESET = %X'800';
literal COREIO$M_SSR_ISDN_RESET = %X'1000';
literal COREIO$M_SSR_10BASET_SEL = %X'2000';
literal COREIO$M_SSR_NI_LOOPBACK = %X'4000';
literal COREIO$M_SSR_TXDIS = %X'8000';
literal COREIO$M_SSR_ISDN_RC_DMA_EN = %X'80000';
literal COREIO$M_SSR_ISDN_TR_DMA_EN = %X'100000';
literal COREIO$M_SSR_PRINTER_RC_DMA_EN = %X'10000000';
literal COREIO$M_SSR_PRINTER_TR_DMA_EN = %X'20000000';
literal COREIO$M_SSR_COMM_RC_DMA_EN = %X'40000000';
literal COREIO$M_SSR_COMM_TR_DMA_EN = %X'80000000';
literal COREIO$M_SSR_IO_MASK = %X'F';
literal COREIO$M_SSR_IO_MASK_EN = %X'10';
literal COREIO$M_SSR_FPE = %X'80';
literal COREIO$M_SSR_SMR0 = %X'1000000';
literal COREIO$M_SSR_SMR1 = %X'2000000';
literal COREIO$M_SSR_SMRA = %X'4000000';
literal COREIO$M_SSR_FAST_MODE = %X'8000000';
literal COREIO$M_SSR_KBD_RC_DMA_EN = %X'10000000';
literal COREIO$M_SSR_KBD_TR_DMA_EN = %X'20000000';
literal COREIO$C_SIR = 544;             !  A constant for C programmers - defines offset of SIR structure
literal COREIO$M_SIR_GP_INT_0 = %X'1';
literal COREIO$M_SIR_GP_INT_1 = %X'2';
literal COREIO$M_SIR_GP_INT_2 = %X'4';
literal COREIO$M_SIR_GP_INT_3 = %X'8';
literal COREIO$M_SIR_GP_INT_4 = %X'10';
literal COREIO$M_SIR_GP_INT_5 = %X'20';
literal COREIO$M_SIR_GP_INT_6 = %X'40';
literal COREIO$M_SIR_GP_INT_7 = %X'80';
literal COREIO$M_SIR_GP_INT_8 = %X'100';
literal COREIO$M_SIR_GP_INT_9 = %X'200';
literal COREIO$M_SIR_GP_INT_10 = %X'400';
literal COREIO$M_SIR_GP_INT_11 = %X'800';
literal COREIO$M_SIR_GP_INT_12 = %X'1000';
literal COREIO$M_SIR_GP_INT_13 = %X'2000';
literal COREIO$M_SIR_GP_INT_14 = %X'4000';
literal COREIO$M_SIR_GP_INT_15 = %X'8000';
literal COREIO$M_SIR_LANCE_DMA_ER = %X'10000';
literal COREIO$M_SIR_SCSI_DMA_MRE = %X'20000';
literal COREIO$M_SIR_SCSI_DMA_OV = %X'40000';
literal COREIO$M_SIR_SCSI_DMA_PTR = %X'80000';
literal COREIO$M_SIR_ISDN_DMA_MRE = %X'100000';
literal COREIO$M_SIR_ISDN_DMA_RC_INTR = %X'200000';
literal COREIO$M_SIR_ISDN_DMA_TR_INTR = %X'400000';
literal COREIO$M_SIR_FLOPPY_DMA_INT = %X'800000';
literal COREIO$M_SIR_SCC1_DMA_OV = %X'1000000';
literal COREIO$M_SIR_SCC1_RCV_INT = %X'2000000';
literal COREIO$M_SIR_SCC1_TR_DMA_ME = %X'4000000';
literal COREIO$M_SIR_SCC1_TR_INT = %X'8000000';
literal COREIO$M_SIR_SCC0_DMA_OV = %X'10000000';
literal COREIO$M_SIR_SCC0_RCV_INT = %X'20000000';
literal COREIO$M_SIR_SCC0_TR_DMA_ME = %X'40000000';
literal COREIO$M_SIR_SCC0_TR_INT = %X'80000000';
literal COREIO$M_SIR_HALT0 = %X'1';
literal COREIO$M_SIR_HALT1 = %X'2';
literal COREIO$M_SIR_ALT_CONSOLE = %X'8';
literal COREIO$M_SIR_SCC0_SI = %X'40';
literal COREIO$M_SIR_SCC1_SI = %X'80';
literal COREIO$M_SIR_NI_INTR = %X'100';
literal COREIO$M_SIR_ISDN_INTR = %X'2000';
literal COREIO$M_SIR_LANCE_DMA_RE = %X'10000';
literal COREIO$M_SIR_PP_RC_DMA_OVR = %X'1000000';
literal COREIO$M_SIR_PP_RC_HP_INTR = %X'2000000';
literal COREIO$M_SIR_PP_TR_DMA_MRE = %X'4000000';
literal COREIO$M_SIR_PP_TR_PE_INTR = %X'8000000';
literal COREIO$M_SIR_COMM_RC_DMA_OVR = %X'10000000';
literal COREIO$M_SIR_COMM_RC_HP_INTR = %X'20000000';
literal COREIO$M_SIR_COMM_TR_DMA_MRE = %X'40000000';
literal COREIO$M_SIR_COMM_TR_PE_INTR = %X'80000000';
literal COREIO$M_SIR_TC_SLOT0 = %X'4';
literal COREIO$M_SIR_TC_SLOT1 = %X'8';
literal COREIO$M_SIR_SCC0_INT = %X'40';
literal COREIO$M_SIR_SCC1_INT = %X'80';
literal COREIO$M_SIR_LANCE_INT = %X'100';
literal COREIO$M_SIR_ISDN_INT = %X'2000';
literal COREIO$M_SIR_CONS_SEL = %X'8000';
literal COREIO$C_SIMR = 576;            !  A constant for C programmers - defines offset of SIMR structure
literal COREIO$M_SIMR_GP_INT_0 = %X'1';
literal COREIO$M_SIMR_GP_INT_1 = %X'2';
literal COREIO$M_SIMR_GP_INT_2 = %X'4';
literal COREIO$M_SIMR_GP_INT_3 = %X'8';
literal COREIO$M_SIMR_GP_INT_4 = %X'10';
literal COREIO$M_SIMR_GP_INT_5 = %X'20';
literal COREIO$M_SIMR_GP_INT_6 = %X'40';
literal COREIO$M_SIMR_GP_INT_7 = %X'80';
literal COREIO$M_SIMR_GP_INT_8 = %X'100';
literal COREIO$M_SIMR_GP_INT_9 = %X'200';
literal COREIO$M_SIMR_GP_INT_10 = %X'400';
literal COREIO$M_SIMR_GP_INT_11 = %X'800';
literal COREIO$M_SIMR_GP_INT_12 = %X'1000';
literal COREIO$M_SIMR_GP_INT_13 = %X'2000';
literal COREIO$M_SIMR_GP_INT_14 = %X'4000';
literal COREIO$M_SIMR_GP_INT_15 = %X'8000';
literal COREIO$M_SIMR_LANCE_DMA_ER = %X'10000';
literal COREIO$M_SIMR_SCSI_DMA_MRE = %X'20000';
literal COREIO$M_SIMR_SCSI_DMA_OV = %X'40000';
literal COREIO$M_SIMR_SCSI_DMA_PTR = %X'80000';
literal COREIO$M_SIMR_ISDN_DMA_MRE = %X'100000';
literal COREIO$M_SIMR_ISDN_DMA_RC_INTR = %X'200000';
literal COREIO$M_SIMR_ISDN_DMA_TR_INTR = %X'400000';
literal COREIO$M_SIMR_FLOPPY_DMA_INT = %X'800000';
literal COREIO$M_SIMR_SCC1_DMA_OV = %X'1000000';
literal COREIO$M_SIMR_SCC1_RCV_INT = %X'2000000';
literal COREIO$M_SIMR_SCC1_TR_DMA_ME = %X'4000000';
literal COREIO$M_SIMR_SCC1_TR_INT = %X'8000000';
literal COREIO$M_SIMR_SCC0_DMA_OV = %X'10000000';
literal COREIO$M_SIMR_SCC0_RCV_INT = %X'20000000';
literal COREIO$M_SIMR_SCC0_TR_DMA_ME = %X'40000000';
literal COREIO$M_SIMR_SCC0_TR_INT = %X'80000000';
literal COREIO$M_SIMR_HALT0 = %X'1';
literal COREIO$M_SIMR_HALT1 = %X'2';
literal COREIO$M_SIMR_ALT_CONSOLE = %X'8';
literal COREIO$M_SIMR_SCC0_SI = %X'40';
literal COREIO$M_SIMR_SCC1_SI = %X'80';
literal COREIO$M_SIMR_NI_INTR = %X'100';
literal COREIO$M_SIMR_ISDN_INTR = %X'2000';
literal COREIO$M_SIMR_LANCE_DMA_RE = %X'10000';
literal COREIO$M_SIMR_PP_RC_DMA_OVR = %X'1000000';
literal COREIO$M_SIMR_PP_RC_HP_INTR = %X'2000000';
literal COREIO$M_SIMR_PP_TR_DMA_MRE = %X'4000000';
literal COREIO$M_SIMR_PP_TR_PE_INTR = %X'8000000';
literal COREIO$M_SIMR_COMM_RC_DMA_OVR = %X'10000000';
literal COREIO$M_SIMR_COMM_RC_HP_INTR = %X'20000000';
literal COREIO$M_SIMR_COMM_TR_DMA_MRE = %X'40000000';
literal COREIO$M_SIMR_COMM_TR_PE_INTR = %X'80000000';
literal COREIO$M_SIMR_TC_SLOT0 = %X'4';
literal COREIO$M_SIMR_TC_SLOT1 = %X'8';
literal COREIO$M_SIMR_SCC0_INT = %X'40';
literal COREIO$M_SIMR_SCC1_INT = %X'80';
literal COREIO$M_SIMR_LANCE_INT = %X'100';
literal COREIO$M_SIMR_ISDN_INT = %X'2000';
literal COREIO$M_SIMR_CONS_SEL = %X'8000';
literal COREIO$M_SADR_TC_ADDR = %X'1FFFFE0';
literal COREIO$M_ISDN_DATA_TR_DATA = %X'FFFFFF';
literal COREIO$M_ISDN_DATA_RC_DATA = %X'FFFFFF';
literal COREIO$M_LANCE_SLOT_CS = %X'F';
literal COREIO$M_LANCE_SLOT_HW_ADDR = %X'3F0';
literal COREIO$M_SCC0_SLOT_CS = %X'F';
literal COREIO$M_SCC0_SLOT_HW_ADDR = %X'3F0';
literal COREIO$M_SCC1_SLOT_CS = %X'F';
literal COREIO$M_SCC1_SLOT_HW_ADDR = %X'3F0';
literal COREIO$C_ISDN_AUDIO = 49152;    !  A constant for C programmers - defines offset of ISDN CSR
literal COREIO$Q_tc_number = 1;         !  High nibble of addr
literal COREIO$Q_slot0_dense_base = 0;  !  base PA of TC slot 0
literal COREIO$Q_slot1_dense_base = 536870912; !  base PA of TC slot 1
literal COREIO$Q_slot2_dense_base = 1073741824; !  base PA of TC slot 2
literal COREIO$Q_slot3_dense_base = 1610612736; !  base PA of TC slot 3
literal COREIO$Q_slot4_dense_base = -2147483648; !  base PA of TC slot 4
literal COREIO$Q_slot5_dense_base = -1610612736; !  base PA of TC slot 5
literal COREIO$Q_lance_rap = 1572872;   !  PA of LANCE RAP reg
literal COREIO$Q_lance_rdp_dense = 786432; !  PA of LANCE RDP reg
literal COREIO$Q_ni_adr_rom_dense = 524288; !  PA of NI ADR ROM
literal COREIO$Q_ldp_dense = 262176;    !  PA of LDP reg
literal COREIO$Q_lance_slot = 524992;   !  PA of lance slot
literal COREIO$Q_ssr = 524800;          !  SSR reg
literal COREIO$Q_sir = 524832;          !  SIR reg
literal COREIO$Q_simr = 524848;         !  SIMR reg
literal COREIO$S_COREIODEF = 57344;     !  Old COREIO size field for compatibility
literal COREIO$S_COREIO = 57344;
macro COREIO$L_IOCTL_CSR = 0,0,32,1 %;  !  Core I/O base CSR address
macro COREIO$L_LDP = 64,0,32,0 %;       !  Ethernet Lance DMA pointer
macro COREIO$V_LDP_DMA_PA_LO = 64,5,15,0 %;
literal COREIO$S_LDP_DMA_PA_LO = 15;
macro COREIO$V_LDP_DMA_PA_HI = 64,20,12,0 %;
literal COREIO$S_LDP_DMA_PA_HI = 12;
macro COREIO$L_SCOMM_TR = 96,0,32,0 %;  !  Serial comm transmit port 1 DMA pointer
macro COREIO$V_SCOMM_TR_DMA_PA = 96,5,27,0 %;
literal COREIO$S_SCOMM_TR_DMA_PA = 27;
macro COREIO$L_SCOMM_RC = 128,0,32,0 %; !  Serial comm receive port 1 DMA pointer
macro COREIO$V_SCOMM_RC_DMA_PA = 128,5,27,0 %;
literal COREIO$S_SCOMM_RC_DMA_PA = 27;
macro COREIO$L_PRINTER_TR = 160,0,32,0 %; !  Printer transmit port DMA pointer
macro COREIO$V_PRINTER_TR_DMA_PA = 160,5,27,0 %;
literal COREIO$S_PRINTER_TR_DMA_PA = 27;
macro COREIO$L_PRINTER_RC = 192,0,32,0 %; !  Printer receive port DMA pointer
macro COREIO$V_PRINTER_RC_DMA_PA = 192,5,27,0 %;
literal COREIO$S_PRINTER_RC_DMA_PA = 27;
macro COREIO$L_ISDN_TR = 256,0,32,0 %;  !  ISDN transmit DMA pointer
macro COREIO$V_ISDN_TR_DMA_PA = 256,5,27,0 %;
literal COREIO$S_ISDN_TR_DMA_PA = 27;
macro COREIO$L_ISDN_TR_BUF = 288,0,32,0 %; !  ISDN transmit DMA buffer pointer
macro COREIO$V_ISDN_TR_BUF_DMA_PA = 288,5,27,0 %;
literal COREIO$S_ISDN_TR_BUF_DMA_PA = 27;
macro COREIO$L_ISDN_RC = 320,0,32,0 %;  !  ISDN receive DMA pointer 
macro COREIO$V_ISDN_RC_DMA_PA = 320,5,27,0 %;
literal COREIO$S_ISDN_RC_DMA_PA = 27;
macro COREIO$L_ISDN_RC_BUF = 352,0,32,0 %; !  ISDN receive DMA buffer pointer 
macro COREIO$V_ISDN_RC_BUF_DMA_PA = 352,5,27,0 %;
literal COREIO$S_ISDN_RC_BUF_DMA_PA = 27;
macro COREIO$L_DATA0 = 384,0,32,0 %;    !  System Data Buffer 0
macro COREIO$L_DATA1 = 416,0,32,0 %;    !  System Data Buffer 1
macro COREIO$L_DATA2 = 448,0,32,0 %;    !  System Data Buffer 2
macro COREIO$L_DATA3 = 480,0,32,0 %;    !  System Data Buffer 3
macro COREIO$L_SSR = 512,0,32,0 %;      !  System support register
macro COREIO$V_SSR_GPO_0 = 512,0,1,0 %;
macro COREIO$V_SSR_GPO_1 = 512,1,1,0 %;
macro COREIO$V_SSR_GPO_2 = 512,2,1,0 %;
macro COREIO$V_SSR_GPO_3 = 512,3,1,0 %;
macro COREIO$V_SSR_GPO_4 = 512,4,1,0 %;
macro COREIO$V_SSR_GPO_5 = 512,5,1,0 %;
macro COREIO$V_SSR_GPO_6 = 512,6,1,0 %;
macro COREIO$V_SSR_GPO_7 = 512,7,1,0 %;
macro COREIO$V_SSR_GPO_8 = 512,8,1,0 %;
macro COREIO$V_SSR_GPO_9 = 512,9,1,0 %;
macro COREIO$V_SSR_GPO_10 = 512,10,1,0 %;
macro COREIO$V_SSR_GPO_11 = 512,11,1,0 %;
macro COREIO$V_SSR_GPO_12 = 512,12,1,0 %;
macro COREIO$V_SSR_GPO_13 = 512,13,1,0 %;
macro COREIO$V_SSR_GPO_14 = 512,14,1,0 %;
macro COREIO$V_SSR_GPO_15 = 512,15,1,0 %;
macro COREIO$V_SSR_LANCE_DMA_EN = 512,16,1,0 %;
macro COREIO$V_SSR_SCSI_DMA_EN = 512,17,1,0 %;
macro COREIO$V_SSR_SCSI_DMA_DIR = 512,18,1,0 %;
macro COREIO$V_SSR_ISDN_RCV_EN = 512,19,1,0 %;
macro COREIO$V_SSR_ISDN_TR_EN = 512,20,1,0 %;
macro COREIO$V_SSR_FLOPPY_DMA_EN = 512,21,1,0 %;
macro COREIO$V_SSR_FLOPPY_DMA_DIR = 512,22,1,0 %;
macro COREIO$V_SSR_SCC1_RC_DMA_EN = 512,28,1,0 %;
macro COREIO$V_SSR_SCC1_TR_DMA_EN = 512,29,1,0 %;
macro COREIO$V_SSR_SCC0_RC_DMA_EN = 512,30,1,0 %;
macro COREIO$V_SSR_SCC0_TR_DMA_EN = 512,31,1,0 %;
macro COREIO$V_SSR_LEDS = 512,0,8,0 %;
literal COREIO$S_SSR_LEDS = 8;
macro COREIO$V_SSR_LANCE_RESET = 512,8,1,0 %;
macro COREIO$V_SSR_RTC_RESET = 512,10,1,0 %;
macro COREIO$V_SSR_SSC_RESET = 512,11,1,0 %;
macro COREIO$V_SSR_ISDN_RESET = 512,12,1,0 %;
macro COREIO$V_SSR_10BASET_SEL = 512,13,1,0 %;
macro COREIO$V_SSR_NI_LOOPBACK = 512,14,1,0 %;
macro COREIO$V_SSR_TXDIS = 512,15,1,0 %;
macro COREIO$V_SSR_ISDN_RC_DMA_EN = 512,19,1,0 %;
macro COREIO$V_SSR_ISDN_TR_DMA_EN = 512,20,1,0 %;
macro COREIO$V_SSR_PRINTER_RC_DMA_EN = 512,28,1,0 %;
macro COREIO$V_SSR_PRINTER_TR_DMA_EN = 512,29,1,0 %;
macro COREIO$V_SSR_COMM_RC_DMA_EN = 512,30,1,0 %;
macro COREIO$V_SSR_COMM_TR_DMA_EN = 512,31,1,0 %;
macro COREIO$V_SSR_IO_MASK = 512,0,4,0 %;
literal COREIO$S_SSR_IO_MASK = 4;
macro COREIO$V_SSR_IO_MASK_EN = 512,4,1,0 %;
macro COREIO$V_SSR_FPE = 512,7,1,0 %;
macro COREIO$V_SSR_SMR0 = 512,24,1,0 %;
macro COREIO$V_SSR_SMR1 = 512,25,1,0 %;
macro COREIO$V_SSR_SMRA = 512,26,1,0 %;
macro COREIO$V_SSR_FAST_MODE = 512,27,1,0 %;
macro COREIO$V_SSR_KBD_RC_DMA_EN = 512,28,1,0 %;
macro COREIO$V_SSR_KBD_TR_DMA_EN = 512,29,1,0 %;
macro COREIO$L_SIR = 544,0,32,0 %;      !  System interrupt register
macro COREIO$V_SIR_GP_INT_0 = 544,0,1,0 %;
macro COREIO$V_SIR_GP_INT_1 = 544,1,1,0 %;
macro COREIO$V_SIR_GP_INT_2 = 544,2,1,0 %;
macro COREIO$V_SIR_GP_INT_3 = 544,3,1,0 %;
macro COREIO$V_SIR_GP_INT_4 = 544,4,1,0 %;
macro COREIO$V_SIR_GP_INT_5 = 544,5,1,0 %;
macro COREIO$V_SIR_GP_INT_6 = 544,6,1,0 %;
macro COREIO$V_SIR_GP_INT_7 = 544,7,1,0 %;
macro COREIO$V_SIR_GP_INT_8 = 544,8,1,0 %;
macro COREIO$V_SIR_GP_INT_9 = 544,9,1,0 %;
macro COREIO$V_SIR_GP_INT_10 = 544,10,1,0 %;
macro COREIO$V_SIR_GP_INT_11 = 544,11,1,0 %;
macro COREIO$V_SIR_GP_INT_12 = 544,12,1,0 %;
macro COREIO$V_SIR_GP_INT_13 = 544,13,1,0 %;
macro COREIO$V_SIR_GP_INT_14 = 544,14,1,0 %;
macro COREIO$V_SIR_GP_INT_15 = 544,15,1,0 %;
macro COREIO$V_SIR_LANCE_DMA_ER = 544,16,1,0 %;
macro COREIO$V_SIR_SCSI_DMA_MRE = 544,17,1,0 %;
macro COREIO$V_SIR_SCSI_DMA_OV = 544,18,1,0 %;
macro COREIO$V_SIR_SCSI_DMA_PTR = 544,19,1,0 %;
macro COREIO$V_SIR_ISDN_DMA_MRE = 544,20,1,0 %;
macro COREIO$V_SIR_ISDN_DMA_RC_INTR = 544,21,1,0 %;
macro COREIO$V_SIR_ISDN_DMA_TR_INTR = 544,22,1,0 %;
macro COREIO$V_SIR_FLOPPY_DMA_INT = 544,23,1,0 %;
macro COREIO$V_SIR_SCC1_DMA_OV = 544,24,1,0 %;
macro COREIO$V_SIR_SCC1_RCV_INT = 544,25,1,0 %;
macro COREIO$V_SIR_SCC1_TR_DMA_ME = 544,26,1,0 %;
macro COREIO$V_SIR_SCC1_TR_INT = 544,27,1,0 %;
macro COREIO$V_SIR_SCC0_DMA_OV = 544,28,1,0 %;
macro COREIO$V_SIR_SCC0_RCV_INT = 544,29,1,0 %;
macro COREIO$V_SIR_SCC0_TR_DMA_ME = 544,30,1,0 %;
macro COREIO$V_SIR_SCC0_TR_INT = 544,31,1,0 %;
macro COREIO$V_SIR_HALT0 = 544,0,1,0 %;
macro COREIO$V_SIR_HALT1 = 544,1,1,0 %;
macro COREIO$V_SIR_ALT_CONSOLE = 544,3,1,0 %;
macro COREIO$V_SIR_SCC0_SI = 544,6,1,0 %;
macro COREIO$V_SIR_SCC1_SI = 544,7,1,0 %;
macro COREIO$V_SIR_NI_INTR = 544,8,1,0 %;
macro COREIO$V_SIR_ISDN_INTR = 544,13,1,0 %;
macro COREIO$V_SIR_LANCE_DMA_RE = 544,16,1,0 %;
macro COREIO$V_SIR_PP_RC_DMA_OVR = 544,24,1,0 %;
macro COREIO$V_SIR_PP_RC_HP_INTR = 544,25,1,0 %;
macro COREIO$V_SIR_PP_TR_DMA_MRE = 544,26,1,0 %;
macro COREIO$V_SIR_PP_TR_PE_INTR = 544,27,1,0 %;
macro COREIO$V_SIR_COMM_RC_DMA_OVR = 544,28,1,0 %;
macro COREIO$V_SIR_COMM_RC_HP_INTR = 544,29,1,0 %;
macro COREIO$V_SIR_COMM_TR_DMA_MRE = 544,30,1,0 %;
macro COREIO$V_SIR_COMM_TR_PE_INTR = 544,31,1,0 %;
macro COREIO$V_SIR_TC_SLOT0 = 544,2,1,0 %;
macro COREIO$V_SIR_TC_SLOT1 = 544,3,1,0 %;
macro COREIO$V_SIR_SCC0_INT = 544,6,1,0 %;
macro COREIO$V_SIR_SCC1_INT = 544,7,1,0 %;
macro COREIO$V_SIR_LANCE_INT = 544,8,1,0 %;
macro COREIO$V_SIR_ISDN_INT = 544,13,1,0 %;
macro COREIO$V_SIR_CONS_SEL = 544,15,1,0 %;
macro COREIO$L_SIMR = 576,0,32,0 %;     !  System interrupt mask register
macro COREIO$V_SIMR_GP_INT_0 = 576,0,1,0 %;
macro COREIO$V_SIMR_GP_INT_1 = 576,1,1,0 %;
macro COREIO$V_SIMR_GP_INT_2 = 576,2,1,0 %;
macro COREIO$V_SIMR_GP_INT_3 = 576,3,1,0 %;
macro COREIO$V_SIMR_GP_INT_4 = 576,4,1,0 %;
macro COREIO$V_SIMR_GP_INT_5 = 576,5,1,0 %;
macro COREIO$V_SIMR_GP_INT_6 = 576,6,1,0 %;
macro COREIO$V_SIMR_GP_INT_7 = 576,7,1,0 %;
macro COREIO$V_SIMR_GP_INT_8 = 576,8,1,0 %;
macro COREIO$V_SIMR_GP_INT_9 = 576,9,1,0 %;
macro COREIO$V_SIMR_GP_INT_10 = 576,10,1,0 %;
macro COREIO$V_SIMR_GP_INT_11 = 576,11,1,0 %;
macro COREIO$V_SIMR_GP_INT_12 = 576,12,1,0 %;
macro COREIO$V_SIMR_GP_INT_13 = 576,13,1,0 %;
macro COREIO$V_SIMR_GP_INT_14 = 576,14,1,0 %;
macro COREIO$V_SIMR_GP_INT_15 = 576,15,1,0 %;
macro COREIO$V_SIMR_LANCE_DMA_ER = 576,16,1,0 %;
macro COREIO$V_SIMR_SCSI_DMA_MRE = 576,17,1,0 %;
macro COREIO$V_SIMR_SCSI_DMA_OV = 576,18,1,0 %;
macro COREIO$V_SIMR_SCSI_DMA_PTR = 576,19,1,0 %;
macro COREIO$V_SIMR_ISDN_DMA_MRE = 576,20,1,0 %;
macro COREIO$V_SIMR_ISDN_DMA_RC_INTR = 576,21,1,0 %;
macro COREIO$V_SIMR_ISDN_DMA_TR_INTR = 576,22,1,0 %;
macro COREIO$V_SIMR_FLOPPY_DMA_INT = 576,23,1,0 %;
macro COREIO$V_SIMR_SCC1_DMA_OV = 576,24,1,0 %;
macro COREIO$V_SIMR_SCC1_RCV_INT = 576,25,1,0 %;
macro COREIO$V_SIMR_SCC1_TR_DMA_ME = 576,26,1,0 %;
macro COREIO$V_SIMR_SCC1_TR_INT = 576,27,1,0 %;
macro COREIO$V_SIMR_SCC0_DMA_OV = 576,28,1,0 %;
macro COREIO$V_SIMR_SCC0_RCV_INT = 576,29,1,0 %;
macro COREIO$V_SIMR_SCC0_TR_DMA_ME = 576,30,1,0 %;
macro COREIO$V_SIMR_SCC0_TR_INT = 576,31,1,0 %;
macro COREIO$V_SIMR_HALT0 = 576,0,1,0 %;
macro COREIO$V_SIMR_HALT1 = 576,1,1,0 %;
macro COREIO$V_SIMR_ALT_CONSOLE = 576,3,1,0 %;
macro COREIO$V_SIMR_SCC0_SI = 576,6,1,0 %;
macro COREIO$V_SIMR_SCC1_SI = 576,7,1,0 %;
macro COREIO$V_SIMR_NI_INTR = 576,8,1,0 %;
macro COREIO$V_SIMR_ISDN_INTR = 576,13,1,0 %;
macro COREIO$V_SIMR_LANCE_DMA_RE = 576,16,1,0 %;
macro COREIO$V_SIMR_PP_RC_DMA_OVR = 576,24,1,0 %;
macro COREIO$V_SIMR_PP_RC_HP_INTR = 576,25,1,0 %;
macro COREIO$V_SIMR_PP_TR_DMA_MRE = 576,26,1,0 %;
macro COREIO$V_SIMR_PP_TR_PE_INTR = 576,27,1,0 %;
macro COREIO$V_SIMR_COMM_RC_DMA_OVR = 576,28,1,0 %;
macro COREIO$V_SIMR_COMM_RC_HP_INTR = 576,29,1,0 %;
macro COREIO$V_SIMR_COMM_TR_DMA_MRE = 576,30,1,0 %;
macro COREIO$V_SIMR_COMM_TR_PE_INTR = 576,31,1,0 %;
macro COREIO$V_SIMR_TC_SLOT0 = 576,2,1,0 %;
macro COREIO$V_SIMR_TC_SLOT1 = 576,3,1,0 %;
macro COREIO$V_SIMR_SCC0_INT = 576,6,1,0 %;
macro COREIO$V_SIMR_SCC1_INT = 576,7,1,0 %;
macro COREIO$V_SIMR_LANCE_INT = 576,8,1,0 %;
macro COREIO$V_SIMR_ISDN_INT = 576,13,1,0 %;
macro COREIO$V_SIMR_CONS_SEL = 576,15,1,0 %;
macro COREIO$L_SADR = 608,0,32,0 %;     !  System address register
macro COREIO$V_SADR_TC_ADDR = 608,5,20,0 %;
literal COREIO$S_SADR_TC_ADDR = 20;
macro COREIO$L_ISDN_DATA_TR = 640,0,32,0 %; !  ISDN Data Transmit
macro COREIO$V_ISDN_DATA_TR_DATA = 640,0,24,0 %;
literal COREIO$S_ISDN_DATA_TR_DATA = 24;
macro COREIO$L_ISDN_DATA_RC = 672,0,32,0 %; !  ISDN Data Receive
macro COREIO$V_ISDN_DATA_RC_DATA = 672,0,24,0 %;
literal COREIO$S_ISDN_DATA_RC_DATA = 24;
macro COREIO$L_LANCE_SLOT = 704,0,32,0 %; !  Lance slot register
macro COREIO$V_LANCE_SLOT_CS = 704,0,4,0 %;
literal COREIO$S_LANCE_SLOT_CS = 4;
macro COREIO$V_LANCE_SLOT_HW_ADDR = 704,4,6,0 %;
literal COREIO$S_LANCE_SLOT_HW_ADDR = 6;
macro COREIO$L_SCC0_SLOT = 768,0,32,0 %; !  SCC0 slot register
macro COREIO$V_SCC0_SLOT_CS = 768,0,4,0 %;
literal COREIO$S_SCC0_SLOT_CS = 4;
macro COREIO$V_SCC0_SLOT_HW_ADDR = 768,4,6,0 %;
literal COREIO$S_SCC0_SLOT_HW_ADDR = 6;
macro COREIO$L_SCC1_SLOT = 800,0,32,0 %; !  SCC1 slot register
macro COREIO$V_SCC1_SLOT_CS = 800,0,4,0 %;
literal COREIO$S_SCC1_SLOT_CS = 4;
macro COREIO$V_SCC1_SLOT_HW_ADDR = 800,4,6,0 %;
literal COREIO$S_SCC1_SLOT_HW_ADDR = 6;
macro COREIO$L_NI_ADR_ROM = 8192,0,32,0 %; !  Ethernet address ROM
macro COREIO$L_LANCE_RDP = 16384,0,32,0 %; !  Lance ethernet CSR
macro COREIO$L_LANCE_RAP = 16392,0,32,0 %; !  Lance ethernet CSR
macro COREIO$L_SCC0B_COMM_RAP = 24576,0,32,0 %; !  Comm Port 1 RAP
macro COREIO$L_SCC0B_COMM_DATA = 24584,0,32,0 %; !  Comm Port 1 data
macro COREIO$L_SCC0A_MOUSE_RAP = 24592,0,32,0 %; !  Mouse RAP
macro COREIO$L_SCC0A_MOUSE_DATA = 24600,0,32,0 %; !  Mouse port data register
macro COREIO$L_SCC1B_PRINT_RAP = 32768,0,32,0 %; !  Printer Port 2 RAP
macro COREIO$L_SCC1B_PRINT_DATA = 32776,0,32,0 %; !  Printer Port 2 data
macro COREIO$L_SCC1A_KEY_RAP = 32784,0,32,0 %; !  Keyboard RAP
macro COREIO$L_SCC1A_KEY_DATA = 32792,0,32,0 %; !  Keyboard port data register
macro COREIO$L_RTC_SEC = 40960,0,32,0 %; !  TOY clock CSR--seconds
macro COREIO$L_RTC_ALMS = 40968,0,32,0 %; !  TOY clock CSR--seconds alarm
macro COREIO$L_RTC_MIN = 40976,0,32,0 %; !  TOY clock CSR--minutes
macro COREIO$L_RTC_ALMN = 40984,0,32,0 %; !  TOY clock CSR--minutes alarm
macro COREIO$L_RTC_HOUR = 40992,0,32,0 %; !  TOY clock CSR--hours
macro COREIO$L_RTC_ALMH = 41000,0,32,0 %; !  TOY clock CSR--hours alarm
macro COREIO$L_RTC_DOW = 41008,0,32,0 %; !  TOY clock CSR--day of week
macro COREIO$L_RTC_DAY = 41016,0,32,0 %; !  TOY clock CSR--date of month
macro COREIO$L_RTC_MON = 41024,0,32,0 %; !  TOY clock CSR--month
macro COREIO$L_RTC_YEAR = 41032,0,32,0 %; !  TOY clock CSR--year
macro COREIO$L_RTC_REGA = 41040,0,32,0 %; !  TOY clock CSR--register A 
macro COREIO$L_RTC_REGB = 41048,0,32,0 %; !  TOY clock CSR--register B 
macro COREIO$L_RTC_REGC = 41056,0,32,0 %; !  TOY clock CSR--register C 
macro COREIO$L_RTC_REGD = 41064,0,32,0 %; !  TOY clock CSR--register D 
macro COREIO$L_RTC_RAM = 41072,0,32,0 %; !  TOY clock CSR--base of BBU RAM
macro COREIO$L_ISDN_AUDIO = 49152,0,32,0 %; !  ISDN audio chip CSR
 
!*** MODULE $CPBDEF ***
! +
! 
!  Constants defining CPU capability numbers and flags for routines
! 
literal CPB$C_PRIMARY = 0;              !  Primary CPU (aka TIMEKEEPER)
literal CPB$C_NS = 1;                   !  future
literal CPB$C_QUORUM = 2;               !  Cluster quorum required
literal CPB$C_RUN = 3;                  !  Run capability
literal CPB$C_HARDAFF = 31;
literal CPB$C_MAX = 32;
literal CPB$C_VECTOR = 1;               !  equate NS with VECTOR
literal CPB$M_PRIMARY = %X'1';
literal CPB$M_VECTOR = %X'2';
literal CPB$M_QUORUM = %X'4';
literal CPB$M_RUN = %X'8';
literal CPB$M_IMPLICIT_AFFINITY = %X'40000000';
literal CPB$M_EXPLICIT_AFFINITY = %X'80000000';
literal CPB$S_CPBDEF = 4;
literal CPB$S_CPB = 4;
macro CPB$V_PRIMARY = 0,0,1,0 %;        !  Primary (timekeeper)
macro CPB$V_VECTOR = 0,1,1,0 %;         !  Vector processor
macro CPB$V_QUORUM = 0,2,1,0 %;         !  Cluster quorum required
macro CPB$V_RUN = 0,3,1,0 %;            !  CPU can run processes
macro CPB$V_IMPLICIT_AFFINITY = 0,30,1,0 %; !  Implicit affinity to a CPU
macro CPB$V_EXPLICIT_AFFINITY = 0,31,1,0 %; !  Explicit affinity to a CPU
literal CPB$M_FLAG_CHECK_CPU = %X'1';
literal CPB$M_FLAG_PERMANENT = %X'2';
literal CPB$M_FLAG_PRIMARY = %X'4';
literal CPB$S_CPB_FLAGSDEF = 1;
literal CPB$S_CPB_FLAGS = 1;
macro CPB$V_FLAG_CHECK_CPU = 0,0,1,0 %; !  Check that process can run
macro CPB$V_FLAG_PERMANENT = 0,1,1,0 %; !  Affect process permanent mask
macro CPB$V_FLAG_PRIMARY = 0,2,1,0 %;   !  Request to run on primary cpu
macro CPB$V_FLAG_FILLER = 0,3,3,0 %;
literal CPB$S_FLAG_FILLER = 3;          ! *** ADD ALL NEW BITFIELDS BEFORE THIS DECLARATION 
! *** THIS FIELD IS USED TO ASSURE MASKS ARE WITHIN RANGE
 
!*** MODULE $CPUDEF ***
! +
! 
!  Per-CPU Database definitions. One of these structures exists for
!  each CPU that is participating in symmetric multiprocessing.
! 
!  The per-CPU database consists of 2 parts. A fixed portion that exists
!  for any CPU type is defined first. A variable portion is also defined as
!  necessary for various CPU types. The contents of the variable portion
!  are CPU-specific.
! 
!  When creating a per-CPU database, one must allocate space to include
!  both the fixed portion and a variable portion that is specific to the
!  CPU type for which the database is being created.
! 
! -
literal CPU$C_MAX_CPUS = 32;            !  Maximum number of CPUs supported
literal CPU$C_RESERVED = 0;             !  Zero is reserved
literal CPU$C_INIT = 1;                 !  CPU is being INITialized
literal CPU$C_RUN = 2;                  !  CPU is RUNning
literal CPU$C_STOPPING = 3;             !  CPU is STOPping
literal CPU$C_STOPPED = 4;              !  CPU is STOPPED
literal CPU$C_TIMOUT = 5;               !  Boot of CPU timed out
literal CPU$C_BOOT_REJECTED = 6;        !  CPU refuses to join SMP
literal CPU$C_BOOTED = 7;               !  CPU booted - waiting for "go"
literal CPU$M_INV_TBS = %X'1';
literal CPU$M_INV_TBA = %X'2';
literal CPU$M_BUGCHK = %X'4';
literal CPU$M_BUGCHKACK = %X'8';
literal CPU$M_RECALSCHD = %X'10';
literal CPU$M_UPDASTSR = %X'20';
literal CPU$M_UPDATE_HWCLOCK = %X'40';
literal CPU$M_WORK_FQP = %X'80';
literal CPU$M_QLOST = %X'100';
literal CPU$M_RESCHED = %X'200';
literal CPU$M_VIRTCONS = %X'400';
literal CPU$M_IOPOST = %X'800';
literal CPU$M_INV_ISTREAM = %X'1000';
literal CPU$M_INV_TBSD = %X'2000';
literal CPU$M_INV_TBS_MMG = %X'4000';
literal CPU$M_INV_TBSD_MMG = %X'8000';
literal CPU$M_CPUFILL_1 = %X'FFFFFFF';
literal CPU$M_CPUSPEC1 = %X'10000000';
literal CPU$M_CPUSPEC2 = %X'20000000';
literal CPU$M_CPUSPEC3 = %X'40000000';
literal CPU$M_CPUSPEC4 = %X'80000000';
literal CPU$K_NUM_SWIQS = 6;            !  Number of software interrupt queues
literal CPU$M_SYS_ASTEN = %X'F';
literal CPU$M_SYS_ASTSR = %X'F0';
literal CPU$M_SYS_FEN = %X'1';
literal CPU$M_SYS_PME = %X'4000000000000000';
literal CPU$M_SYS_DATFX = %X'8000000000000000';
literal CPU$M_TERM_ASTEN = %X'F';
literal CPU$M_TERM_ASTSR = %X'F0';
literal CPU$M_TERM_FEN = %X'1';
literal CPU$M_TERM_PME = %X'4000000000000000';
literal CPU$M_TERM_DATFX = %X'8000000000000000';
literal CPU$M_SCHED = %X'1';
literal CPU$M_FOREVER = %X'2';
literal CPU$M_NEWPRIM = %X'4';
literal CPU$M_PSWITCH = %X'8';
literal CPU$M_STOPPING = %X'1';
literal CPU$M_PCSAMPLE_ACTIVE = %X'1';
literal CPU$S_CPU = 1440;
macro CPU$L_CURPCB = 0,0,32,1 %;        !  Address of CPU's current PCB
macro CPU$L_SLOT_VA = 4,0,32,1 %;       !  Address of CPU's HWRPB slot
macro CPU$W_SIZE = 8,0,16,0 %;          !  Structure size
macro CPU$B_TYPE = 10,0,8,0 %;          !  Structure type
macro CPU$B_SUBTYPE = 11,0,8,0 %;       !  Structure subtype
macro CPU$L_STATE = 12,0,32,0 %;        !  State of this processor
macro CPU$L_CPUMTX = 16,0,32,0 %;       !  Count of CPUMTX acquires
macro CPU$L_CUR_PRI = 20,0,32,0 %;      !  Current Process Priority
! 
!   CPU type independent work request bits
! 
macro CPU$L_WORK_REQ = 24,0,32,0 %;     !  Work request bitmask
macro CPU$V_INV_TBS = 24,0,1,0 %;       !  Invalidate TB single
macro CPU$V_INV_TBA = 24,1,1,0 %;       !  Invalidate TB all
macro CPU$V_BUGCHK = 24,2,1,0 %;        !  BUG_CHECK requested
macro CPU$V_BUGCHKACK = 24,3,1,0 %;     !  BUG_CHECK acked
macro CPU$V_RECALSCHD = 24,4,1,0 %;     !  Recalculate per cpu mask,reschedule
macro CPU$V_UPDASTSR = 24,5,1,0 %;      !  Update ASTSR register
macro CPU$V_UPDATE_HWCLOCK = 24,6,1,0 %; !  Update local hardware clocks
macro CPU$V_WORK_FQP = 24,7,1,0 %;      !  Process work queue
macro CPU$V_QLOST = 24,8,1,0 %;         !  Stall until quorum regained
macro CPU$V_RESCHED = 24,9,1,0 %;       !  Issue IPL 3 SOFTINT
macro CPU$V_VIRTCONS = 24,10,1,0 %;     !  Enter virtual console mode (primary)
macro CPU$V_IOPOST = 24,11,1,0 %;       !  Issue IPL 4 SOFTINT
macro CPU$V_INV_ISTREAM = 24,12,1,0 %;  !  Invalidate cached instruction stream
macro CPU$V_INV_TBSD = 24,13,1,0 %;     !  Invalidate data TB single
macro CPU$V_INV_TBS_MMG = 24,14,1,0 %;  !  Invalidate TB single MMG synchronized
macro CPU$V_INV_TBSD_MMG = 24,15,1,0 %; !  Invalidate TB single MMG synchronized
! 
!  Define 4 CPU type specific work request bits as bit #s 28-31.
! 
macro CPU$V_CPUSPEC1 = 24,28,1,0 %;     !  CPU specific
macro CPU$V_CPUSPEC2 = 24,29,1,0 %;     !  CPU specific
macro CPU$V_CPUSPEC3 = 24,30,1,0 %;     !  CPU specific
macro CPU$V_CPUSPEC4 = 24,31,1,0 %;     !  CPU specific
! 
macro CPU$L_PHY_CPUID = 28,0,32,0 %;    !  CPU ID number
macro CPU$L_CPUID_MASK = 32,0,32,0 %;   !  CPU ID in bitmask form
macro CPU$L_BUSYWAIT = 36,0,32,0 %;     !  <>0 = Spinning for lock
! 
macro CPU$Q_SWIQFL = 40,0,0,1 %;
literal CPU$S_SWIQFL = 48;              !  Software interrupt queues
macro CPU$L_PSFL = 88,0,32,1 %;         !  POST QUEUE forward link
macro CPU$L_PSBL = 92,0,32,1 %;         !  POST QUEUE backward link
macro CPU$Q_WORK_FQFL = 96,0,0,0 %;
literal CPU$S_WORK_FQFL = 8;            !  Work packet queue
macro CPU$Q_WORK_IFQ = 96,0,0,0 %;
literal CPU$S_WORK_IFQ = 8;             !  Work packet queue
! 
macro CPU$L_ZEROED_PAGE_SPTE = 104,0,32,1 %; !  SPTE address
macro CPU$L_ZEROED_PAGE_VA = 108,0,32,1 %; !  VA for zeroed page filling
macro CPU$L_ZEROED_PAGE_STATE = 112,0,32,0 %; !  State for interrupted filling
! ******************************************************************
! 	HWPCB for this CPU's dedicated System Process
! 
!  This Hardware Privileged Context Block provides the context for when this
!  CPU has no other process to run.
! 
!  NOTE WELL: This HWPCB must be aligned to a 128 byte boundary, the
! 	architected natural alignment of a HWPCB.
! 
!  NOTE WELL: There are bit symbols defined here for accessing the saved ASTEN,
! 	ASTSR, FEN and DATFX values in the HWPCB. These symbols are NOT to be used when
! 	interfacing to the ASTEN, ASTSR, FEN or DATFX internal processor registers directly.
! 	See the specific internal register definitions for bitmasks and constants
! 	to be used when interfacing to the IPRs directly.
! 
macro CPU$Q_PHY_SYS_HWPCB = 120,0,0,0 %;
literal CPU$S_PHY_SYS_HWPCB = 8;        !  Physical address of HWPCB
!  Start of aligned section
macro CPU$Q_SYS_HWPCB = 128,0,0,0 %;
literal CPU$S_SYS_HWPCB = 8;            !  Base of HWPCB
macro CPU$Q_SYS_KSP = 128,0,0,0 %;
literal CPU$S_SYS_KSP = 8;              !  Kernel stack pointer
macro CPU$Q_SYS_ESP = 136,0,0,0 %;
literal CPU$S_SYS_ESP = 8;              !  Executive stack pointer
macro CPU$Q_SYS_SSP = 144,0,0,0 %;
literal CPU$S_SYS_SSP = 8;              !  Supervisor stack pointer
macro CPU$Q_SYS_USP = 152,0,0,0 %;
literal CPU$S_SYS_USP = 8;              !  User stack pointer
macro CPU$Q_SYS_PTBR = 160,0,0,0 %;
literal CPU$S_SYS_PTBR = 8;             !  Page Table Base Register
macro CPU$Q_SYS_ASN = 168,0,0,0 %;
literal CPU$S_SYS_ASN = 8;              !  Address Space Number
macro CPU$Q_SYS_ASTSR_ASTEN = 176,0,0,0 %;
literal CPU$S_SYS_ASTSR_ASTEN = 8;      !  ASTSR / ASTEN quadword
macro CPU$V_SYS_ASTEN = 176,0,4,0 %;
literal CPU$S_SYS_ASTEN = 4;            !  AST Enable Register
macro CPU$V_SYS_ASTSR = 176,4,4,0 %;
literal CPU$S_SYS_ASTSR = 4;            !  AST Pending Summary Register
macro CPU$Q_SYS_FEN_DATFX = 184,0,0,0 %;
literal CPU$S_SYS_FEN_DATFX = 8;        !  Floating Point Enable / DATFX
macro CPU$V_SYS_FEN = 184,0,1,0 %;      !  Floating Point Enable = 1
macro CPU$V_SYS_PME = 188,30,1,0 %;     !  Performance Monitor Enable
macro CPU$V_SYS_DATFX = 188,31,1,0 %;   !  Data Alignment Trap Fixup
macro CPU$Q_SYS_CC = 192,0,0,0 %;
literal CPU$S_SYS_CC = 8;               !  Cycle Counter
macro CPU$Q_SYS_UNQ = 200,0,0,0 %;
literal CPU$S_SYS_UNQ = 8;              !  Process Unique Value
macro CPU$Q_SYS_PAL_RSVD = 208,0,0,1 %;
literal CPU$S_SYS_PAL_RSVD = 48;        !  Reserved for PAL Scratch
! 
!  End of Hardware Privileged Context Block (HWPCB) for the system process
! 
! ******************************************************************
! ******************************************************************
! 	HWPCB for this CPU's Terminating Process.
! 
!  This Hardware Privileged Context Block provides the context for when this
!  CPU needs a place to run when a powerfail may, unexpectedly, happen.
! 
!  Remember, when a process's HWPCB is loaded (active on the CPU) the contents
!  of the HWPCB are undefined since the processor may use that area as
!  scratch space.  All code paths that execute higher than IPL IPL$_POWER-2 (29)
!  for an extended period of time may need to execute in the context of this
!  process.  Currently this includes most code surrounding powerfail/restart
!  and parts of SMP$START_SECONDARY.
! 
!  NOTE WELL: This HWPCB must be aligned to a 128 byte boundary, the
! 	architected natural alignment of a HWPCB.
! 
!  NOTE WELL: There are bit symbols defined here for accessing the saved ASTEN,
! 	ASTSR, FEN  and DATFX values in the HWPCB. These symbols are NOT to be used when
! 	interfacing to the ASTEN, ASTSR, FEN or DATFX internal processor registers directly.
! 	See the specific internal register definitions for bitmasks and constants
! 	to be used when interfacing to the IPRs directly.
! 
!  Start of aligned section
macro CPU$Q_TERM_HWPCB = 256,0,0,0 %;
literal CPU$S_TERM_HWPCB = 8;           !  Base of HWPCB
macro CPU$Q_TERM_KSP = 256,0,0,0 %;
literal CPU$S_TERM_KSP = 8;             !  Kernel stack pointer
macro CPU$Q_TERM_ESP = 264,0,0,0 %;
literal CPU$S_TERM_ESP = 8;             !  Executive stack pointer
macro CPU$Q_TERM_SSP = 272,0,0,0 %;
literal CPU$S_TERM_SSP = 8;             !  Supervisor stack pointer
macro CPU$Q_TERM_USP = 280,0,0,0 %;
literal CPU$S_TERM_USP = 8;             !  User stack pointer
macro CPU$Q_TERM_PTBR = 288,0,0,0 %;
literal CPU$S_TERM_PTBR = 8;            !  Page Table Base Register
macro CPU$Q_TERM_ASN = 296,0,0,0 %;
literal CPU$S_TERM_ASN = 8;             !  Address Space Number
macro CPU$Q_TERM_ASTSR_ASTEN = 304,0,0,0 %;
literal CPU$S_TERM_ASTSR_ASTEN = 8;     !  ASTSR / ASTEN quadword
macro CPU$V_TERM_ASTEN = 304,0,4,0 %;
literal CPU$S_TERM_ASTEN = 4;           !  AST Enable Register
macro CPU$V_TERM_ASTSR = 304,4,4,0 %;
literal CPU$S_TERM_ASTSR = 4;           !  AST Pending Summary Register
macro CPU$Q_TERM_FEN_DATFX = 312,0,0,0 %;
literal CPU$S_TERM_FEN_DATFX = 8;       !  Floating Point Enable /DATFX
macro CPU$V_TERM_FEN = 312,0,1,0 %;     !  Floating Point Enable = 1
macro CPU$V_TERM_PME = 316,30,1,0 %;    !  Performance Monitor Enable
macro CPU$V_TERM_DATFX = 316,31,1,0 %;  !  Data Alignment Trap Fixup
macro CPU$Q_TERM_CC = 320,0,0,0 %;
literal CPU$S_TERM_CC = 8;              !  Cycle Counter
macro CPU$Q_TERM_UNQ = 328,0,0,0 %;
literal CPU$S_TERM_UNQ = 8;             !  Process Unique Value
macro CPU$Q_TERM_PAL_RSVD = 336,0,0,1 %;
literal CPU$S_TERM_PAL_RSVD = 48;       !  Reserved for PAL Scratch
! 
!   End of aligned portion of HWPCB.  Next quadword is used so we don't need to 
!   convert a virtual address to a physical address every time we use the terminating
!   process.
! 
macro CPU$Q_PHY_TERM_HWPCB = 384,0,0,0 %;
literal CPU$S_PHY_TERM_HWPCB = 8;       !  Physical address of HWPCB
! 
!  End of Hardware Privileged Context Block (HWPCB) for the terminating process
! 
! ******************************************************************
! 
!  Per-CPU state saved during powerfail interrupt processing. The state
!  that is saved here is process independent, yet specific to this CPU.
! 
macro CPU$Q_SAVED_PCBB = 392,0,0,0 %;
literal CPU$S_SAVED_PCBB = 8;           !  PCBB from powerdown (non-zero
!   if state successfully saved)
macro CPU$Q_SCBB = 400,0,0,0 %;
literal CPU$S_SCBB = 8;                 !  SCBB from powerdown
macro CPU$Q_SISR = 408,0,0,0 %;
literal CPU$S_SISR = 8;                 !  SISR from powerdown
! ******************************************************************
!  The following storage is used by BUGCHECK code. The order must be
!  preserved since it is assumed by a table within the bugcheck code.
! 
macro CPU$Q_BC_KSP = 416,0,0,0 %;
literal CPU$S_BC_KSP = 8;               !  Stored KSP
macro CPU$Q_BC_ESP = 424,0,0,0 %;
literal CPU$S_BC_ESP = 8;               !  Stored ESP
macro CPU$Q_BC_SSP = 432,0,0,0 %;
literal CPU$S_BC_SSP = 8;               !  Stored SSP
macro CPU$Q_BC_USP = 440,0,0,0 %;
literal CPU$S_BC_USP = 8;               !  Stored USP
macro CPU$Q_BC_PTBR = 448,0,0,0 %;
literal CPU$S_BC_PTBR = 8;              !  Stored PTBR
macro CPU$Q_BC_ASN = 456,0,0,0 %;
literal CPU$S_BC_ASN = 8;               !  Stored ASN
macro CPU$Q_BC_ASTSR_ASTEN = 464,0,0,0 %;
literal CPU$S_BC_ASTSR_ASTEN = 8;       !  Stored AST SR and EN
macro CPU$Q_BC_FEN = 472,0,0,0 %;
literal CPU$S_BC_FEN = 8;               !  Stored FEN / PME / DATFX
macro CPU$Q_BC_CC = 480,0,0,0 %;
literal CPU$S_BC_CC = 8;                !  Stored CC
macro CPU$Q_BC_UNQ = 488,0,0,0 %;
literal CPU$S_BC_UNQ = 8;               !  Process Unique Value
macro CPU$Q_BC_PAL_RSVD = 496,0,0,1 %;
literal CPU$S_BC_PAL_RSVD = 48;         !  PAL reserved area
macro CPU$Q_BC_R0 = 544,0,0,0 %;
literal CPU$S_BC_R0 = 8;                !  Stored R0
macro CPU$Q_BC_R1 = 552,0,0,0 %;
literal CPU$S_BC_R1 = 8;                !  Stored R1
macro CPU$Q_BC_R2 = 560,0,0,0 %;
literal CPU$S_BC_R2 = 8;                !  Stored R2
macro CPU$Q_BC_R3 = 568,0,0,0 %;
literal CPU$S_BC_R3 = 8;                !  Stored R3
macro CPU$Q_BC_R4 = 576,0,0,0 %;
literal CPU$S_BC_R4 = 8;                !  Stored R4
macro CPU$Q_BC_R5 = 584,0,0,0 %;
literal CPU$S_BC_R5 = 8;                !  Stored R5
macro CPU$Q_BC_R6 = 592,0,0,0 %;
literal CPU$S_BC_R6 = 8;                !  Stored R6
macro CPU$Q_BC_R7 = 600,0,0,0 %;
literal CPU$S_BC_R7 = 8;                !  Stored R7
macro CPU$Q_BC_R8 = 608,0,0,0 %;
literal CPU$S_BC_R8 = 8;                !  Stored R8
macro CPU$Q_BC_R9 = 616,0,0,0 %;
literal CPU$S_BC_R9 = 8;                !  Stored R9
macro CPU$Q_BC_R10 = 624,0,0,0 %;
literal CPU$S_BC_R10 = 8;               !  Stored R10
macro CPU$Q_BC_R11 = 632,0,0,0 %;
literal CPU$S_BC_R11 = 8;               !  Stored R11
macro CPU$Q_BC_R12 = 640,0,0,0 %;
literal CPU$S_BC_R12 = 8;               !  Stored R12
macro CPU$Q_BC_R13 = 648,0,0,0 %;
literal CPU$S_BC_R13 = 8;               !  Stored R13
macro CPU$Q_BC_R14 = 656,0,0,0 %;
literal CPU$S_BC_R14 = 8;               !  Stored R14
macro CPU$Q_BC_R15 = 664,0,0,0 %;
literal CPU$S_BC_R15 = 8;               !  Stored R15
macro CPU$Q_BC_R16 = 672,0,0,0 %;
literal CPU$S_BC_R16 = 8;               !  Stored R16
macro CPU$Q_BC_R17 = 680,0,0,0 %;
literal CPU$S_BC_R17 = 8;               !  Stored R17
macro CPU$Q_BC_R18 = 688,0,0,0 %;
literal CPU$S_BC_R18 = 8;               !  Stored R18
macro CPU$Q_BC_R19 = 696,0,0,0 %;
literal CPU$S_BC_R19 = 8;               !  Stored R19
macro CPU$Q_BC_R20 = 704,0,0,0 %;
literal CPU$S_BC_R20 = 8;               !  Stored R20
macro CPU$Q_BC_R21 = 712,0,0,0 %;
literal CPU$S_BC_R21 = 8;               !  Stored R21
macro CPU$Q_BC_R22 = 720,0,0,0 %;
literal CPU$S_BC_R22 = 8;               !  Stored R22
macro CPU$Q_BC_R23 = 728,0,0,0 %;
literal CPU$S_BC_R23 = 8;               !  Stored R23
macro CPU$Q_BC_R24 = 736,0,0,0 %;
literal CPU$S_BC_R24 = 8;               !  Stored R24
macro CPU$Q_BC_R25 = 744,0,0,0 %;
literal CPU$S_BC_R25 = 8;               !  Stored R25
macro CPU$Q_BC_R26 = 752,0,0,0 %;
literal CPU$S_BC_R26 = 8;               !  Stored R26
macro CPU$Q_BC_R27 = 760,0,0,0 %;
literal CPU$S_BC_R27 = 8;               !  Stored R27
macro CPU$Q_BC_R28 = 768,0,0,0 %;
literal CPU$S_BC_R28 = 8;               !  Stored R28
macro CPU$Q_BC_R29 = 776,0,0,0 %;
literal CPU$S_BC_R29 = 8;               !  Stored R29
macro CPU$Q_BC_PC = 784,0,0,0 %;
literal CPU$S_BC_PC = 8;                !  Stored PC
macro CPU$Q_BC_PS = 792,0,0,0 %;
literal CPU$S_BC_PS = 8;                !  Stored PS
macro CPU$Q_BC_F0 = 800,0,0,0 %;
literal CPU$S_BC_F0 = 8;                !  Stored F0
macro CPU$Q_BC_F1 = 808,0,0,0 %;
literal CPU$S_BC_F1 = 8;                !  Stored F1
macro CPU$Q_BC_F2 = 816,0,0,0 %;
literal CPU$S_BC_F2 = 8;                !  Stored F2
macro CPU$Q_BC_F3 = 824,0,0,0 %;
literal CPU$S_BC_F3 = 8;                !  Stored F3
macro CPU$Q_BC_F4 = 832,0,0,0 %;
literal CPU$S_BC_F4 = 8;                !  Stored F4
macro CPU$Q_BC_F5 = 840,0,0,0 %;
literal CPU$S_BC_F5 = 8;                !  Stored F5
macro CPU$Q_BC_F6 = 848,0,0,0 %;
literal CPU$S_BC_F6 = 8;                !  Stored F6
macro CPU$Q_BC_F7 = 856,0,0,0 %;
literal CPU$S_BC_F7 = 8;                !  Stored F7
macro CPU$Q_BC_F8 = 864,0,0,0 %;
literal CPU$S_BC_F8 = 8;                !  Stored F8
macro CPU$Q_BC_F9 = 872,0,0,0 %;
literal CPU$S_BC_F9 = 8;                !  Stored F9
macro CPU$Q_BC_F10 = 880,0,0,0 %;
literal CPU$S_BC_F10 = 8;               !  Stored F10
macro CPU$Q_BC_F11 = 888,0,0,0 %;
literal CPU$S_BC_F11 = 8;               !  Stored F11
macro CPU$Q_BC_F12 = 896,0,0,0 %;
literal CPU$S_BC_F12 = 8;               !  Stored F12
macro CPU$Q_BC_F13 = 904,0,0,0 %;
literal CPU$S_BC_F13 = 8;               !  Stored F13
macro CPU$Q_BC_F14 = 912,0,0,0 %;
literal CPU$S_BC_F14 = 8;               !  Stored F14
macro CPU$Q_BC_F15 = 920,0,0,0 %;
literal CPU$S_BC_F15 = 8;               !  Stored F15
macro CPU$Q_BC_F16 = 928,0,0,0 %;
literal CPU$S_BC_F16 = 8;               !  Stored F16
macro CPU$Q_BC_F17 = 936,0,0,0 %;
literal CPU$S_BC_F17 = 8;               !  Stored F17
macro CPU$Q_BC_F18 = 944,0,0,0 %;
literal CPU$S_BC_F18 = 8;               !  Stored F18
macro CPU$Q_BC_F19 = 952,0,0,0 %;
literal CPU$S_BC_F19 = 8;               !  Stored F19
macro CPU$Q_BC_F20 = 960,0,0,0 %;
literal CPU$S_BC_F20 = 8;               !  Stored F20
macro CPU$Q_BC_F21 = 968,0,0,0 %;
literal CPU$S_BC_F21 = 8;               !  Stored F21
macro CPU$Q_BC_F22 = 976,0,0,0 %;
literal CPU$S_BC_F22 = 8;               !  Stored F22
macro CPU$Q_BC_F23 = 984,0,0,0 %;
literal CPU$S_BC_F23 = 8;               !  Stored F23
macro CPU$Q_BC_F24 = 992,0,0,0 %;
literal CPU$S_BC_F24 = 8;               !  Stored F24
macro CPU$Q_BC_F25 = 1000,0,0,0 %;
literal CPU$S_BC_F25 = 8;               !  Stored F25
macro CPU$Q_BC_F26 = 1008,0,0,0 %;
literal CPU$S_BC_F26 = 8;               !  Stored F26
macro CPU$Q_BC_F27 = 1016,0,0,0 %;
literal CPU$S_BC_F27 = 8;               !  Stored F27
macro CPU$Q_BC_F28 = 1024,0,0,0 %;
literal CPU$S_BC_F28 = 8;               !  Stored F28
macro CPU$Q_BC_F29 = 1032,0,0,0 %;
literal CPU$S_BC_F29 = 8;               !  Stored F29
macro CPU$Q_BC_F30 = 1040,0,0,0 %;
literal CPU$S_BC_F30 = 8;               !  Stored F30
macro CPU$Q_BC_IPL = 1048,0,0,0 %;
literal CPU$S_BC_IPL = 8;               !  Stored IPL
macro CPU$Q_BC_MCES = 1056,0,0,0 %;
literal CPU$S_BC_MCES = 8;              !  Stored MCES
macro CPU$Q_BC_PCBB = 1064,0,0,0 %;
literal CPU$S_BC_PCBB = 8;              !  Stored PCBB
macro CPU$Q_BC_PRBR = 1072,0,0,0 %;
literal CPU$S_BC_PRBR = 8;              !  Stored PRBR
macro CPU$Q_BC_VPTB = 1080,0,0,0 %;
literal CPU$S_BC_VPTB = 8;              !  Sotred VPTB
macro CPU$Q_BC_SCBB = 1088,0,0,0 %;
literal CPU$S_BC_SCBB = 8;              !  Stored SCBB
macro CPU$Q_BC_SISR = 1096,0,0,0 %;
literal CPU$S_BC_SISR = 8;              !  Stored SISR
macro CPU$Q_BC_FPCR = 1104,0,0,0 %;
literal CPU$S_BC_FPCR = 8;              !  Stored FPCR
! 
macro CPU$L_BUGCODE = 1112,0,32,0 %;    !  BUGCHECK code
! 
! 
!  End of storage used by BUGCHECK code.
! ******************************************************************
macro CPU$L_CAPABILITY = 1116,0,32,0 %; !  Bitmask of CPU's capabilities
macro CPU$Q_BOOT_TIME = 1120,0,0,0 %;
literal CPU$S_BOOT_TIME = 8;            !  System time this cpu booted
macro CPU$Q_ASN = 1128,0,0,0 %;
literal CPU$S_ASN = 8;                  !  Last ASN assigned for this CPU
macro CPU$Q_ASNSEQ = 1136,0,0,0 %;
literal CPU$S_ASNSEQ = 8;               !  Current ASN sequence number
! 
!  Time counters defined as follows:
!  (Also applies to UKERNEL and UNULLCPU cells)
! 
!      KERNEL mode in process context, no spinlock busywait active
!      EXECUTIVE mode
!      SUPERVISOR mode
!      USER mode
!      KERNEL mode in system context (PS<SYS_STATE> = 1), no spinlock busywait active
!      KERNEL mode in process or system context, spinlock busywait is active
! 
!      NULL time counter
! 
macro CPU$Q_KERNEL = 1144,0,0,0 %;
literal CPU$S_KERNEL = 48;              !  Clock ticks in each mode
macro CPU$Q_MPSYNCH = 1184,0,0,0 %;
literal CPU$S_MPSYNCH = 8;              !  Clock ticks in MP synchronization
macro CPU$Q_NULLCPU = 1192,0,0,0 %;
literal CPU$S_NULLCPU = 8;              !  Clock ticks in per-CPU system process (null)
macro CPU$L_HARDAFF = 1200,0,32,0 %;    !  Count of processes with
!   hard affinity for this CPU
! 
!  Spinlock acquisition/release tracking and verification data
! 
macro CPU$L_RANK_VEC = 1204,0,32,0 %;   !  Ranks of spinlocks currently held
macro CPU$L_IPL_VEC = 1208,0,32,0 %;    !  IPL vector of held spinlocks
macro CPU$L_IPL_ARRAY = 1212,0,0,1 %;
literal CPU$S_IPL_ARRAY = 128;          !  IPL counts of held spinlocks
! 
!  Cells for CPU sanity timer
! 
macro CPU$L_TPOINTER = 1340,0,32,1 %;   !  Address of SANITY_TIMER of
!   CPU being watched
macro CPU$L_SANITY_TIMER = 1344,0,32,0 %; !  # of sanity cycles before this CPU times out
macro CPU$L_SANITY_TICKS = 1348,0,32,0 %; !  # of ticks until next sanity cycle
! 
!  CPU flags
! 
macro CPU$L_FLAGS = 1352,0,32,0 %;      !  Various CPU flags
macro CPU$V_SCHED = 1352,0,1,0 %;       !  Idle loop vying for SCHED
macro CPU$V_FOREVER = 1352,1,1,0 %;     !  STOP/CPU with /FOREVER qualifier
macro CPU$V_NEWPRIM = 1352,2,1,0 %;     !  Primary-to-be CPU
macro CPU$V_PSWITCH = 1352,3,1,0 %;     !  Live primary switch requested by primary CPU
! 
!  The following field, INTFLAGS, must be longword aligned since
!  interlocked instructions are used to access the bitfields.
! 
macro CPU$L_INTFLAGS = 1356,0,32,0 %;   !  Interlocked CPU flags
macro CPU$V_STOPPING = 1356,0,1,0 %;    !  CPU stopping flag
! 
!  System stack base and limit
! 
macro CPU$L_SYS_STACK_BASE = 1360,0,32,1 %;
macro CPU$L_SYS_STACK_LIMIT = 1364,0,32,1 %;
! 
!  Descriptor used to locate the variable portion of the per-CPU database.
!  This approach allows the fixed portion of the database to more easily
!  grow over time. The offset represents a byte offset from the start of
!  the fixed portion of the per-CPU database to a variable portion containing
!  CPU-specific data. The variable portion is located adjacent to the fixed
!  portion of the database.
! 
macro CPU$L_VARIABLE_OFFSET = 1368,0,32,0 %; !  Offset to variable portion of database
macro CPU$L_VARIABLE_LENGTH = 1372,0,32,0 %; !  Length in bytes of variable portion
! 
!  Define cells for machine check recovery block. These two longwords  
!  are assumed to be adjacent.
! 
macro CPU$L_MCHK_MASK = 1376,0,32,0 %;  !  Function mask for current recovery block
macro CPU$L_MCHK_SP = 1380,0,32,1 %;    !  Saved SP for return at end of block
!  0 (zero) if no current recovery block
! 
!  Define a cell to point to a machine check crashes save area. This pointer
!  is used by SDA to display the machine check information after a crash.
! 
macro CPU$PQ_MCHK_CRASH_AREA_VA = 1384,0,0,1 %;
literal CPU$S_MCHK_CRASH_AREA_VA = 8;   !  VA of mcheck crash area
macro CPU$PL_MCHK_CRASH_AREA_VA_L = 1384,0,32,1 %;
macro CPU$IL_MCHK_CRASH_AREA_VA_H = 1388,0,32,0 %;
! 
!  Define cells for processor_corrected_error_svapte and processor_mchk_abort
!  _svapte. 
!  
macro CPU$L_PROC_CORRECTED_ERROR_SVAP = 1392,0,32,1 %;
macro CPU$L_PROC_MCHK_ABORT_SVAPTE = 1396,0,32,1 %; !  sva of spte allocated during initialization 
!  used to map the logout areas. 
macro CPU$PQ_LOGOUT_AREA_VA = 1400,0,0,1 %;
literal CPU$S_LOGOUT_AREA_VA = 8;       !  VA of mcheck logout area
macro CPU$PL_LOGOUT_AREA_VA_L = 1400,0,32,1 %;
macro CPU$IL_LOGOUT_AREA_VA_H = 1404,0,32,0 %;
! 
!  Soft tick dynamic timing offsets to determine when a 10ms "soft" tick 
!  occurs for each CPU.
! 
macro CPU$L_SOFT_TICK = 1408,0,32,0 %;
macro CPU$L_TIME_DEVIATION = 1412,0,32,0 %;
! 
!  The following fields support PC sampling.  They must be longword aligned.
! 
macro CPU$L_PCSAMPLE_BUFFER = 1416,0,32,1 %;
macro CPU$L_PCSAMPLE_FLAGS = 1420,0,32,0 %;
macro CPU$V_PCSAMPLE_ACTIVE = 1420,0,1,0 %; !  Sample being collected.
! 
!  Performance monitoring cells to replace global roll-up cells in idle loop.
!  These cells MUST remain on quadword boundaries since they are updated by
!  system quadword builtins.  Any changes above these offsets must take this
!  into account.
! 
macro CPU$Q_IDLE_LOOP_COUNT = 1424,0,0,0 %;
literal CPU$S_IDLE_LOOP_COUNT = 8;      !  Count of idle code loops
macro CPU$Q_ZEROED_PAGE_COUNT = 1432,0,0,0 %;
literal CPU$S_ZEROED_PAGE_COUNT = 8;    !  Count of free pages zeroed
! 
!  End of fixed portion of the per-CPU database. A variable portion may be required
!  by this CPU type.
! 
! 
!  Beginning of quadword aligned, variable portion of the per-CPU database.
!  Access to this is via the VARIABLE_OFFSET and VARIABLE_LENGTH data cells
!  in the fixed portion of the database.
! 
literal CPU$K_LENGTH = 1440;            !  Total fixed structure size
literal CPU$C_LENGTH = 1440;            !  Total fixed structure size
 
!*** MODULE $CQBICDEF ***
! ++
! 	CQBIC definitions
! --
!  Offsets within page containing interprocessor doorbell registers
literal CQBIC$W_INTPR0 = 320;           ! Arbiter doorbell
literal CQBIC$W_INTPR1 = 322;           ! Auxiliary #1 doorbell
literal CQBIC$W_INTPR2 = 324;           ! Auxiliary #2 doorbell
literal CQBIC$W_INTPR3 = 326;           ! Auxiliary #3 doorbell
literal CQBIC$W_INTPR4 = 328;           ! Auxiliary #4 doorbell
literal CQBIC$W_INTPR5 = 330;           ! Auxiliary #5 doorbell
literal CQBIC$W_INTPR6 = 332;           ! Auxiliary #6 doorbell
literal CQBIC$W_INTPR7 = 334;           ! Auxiliary #7 doorbell
!  Offsets within page containing SCR, memory and map registers
literal CQBIC$L_SCR = 0;                ! System configuration
literal CQBIC$L_DSER = 4;               ! DMA system error
literal CQBIC$L_MEAR = 8;               ! DMA master error
literal CQBIC$L_SEAR = 12;              ! DMA slave error
literal CQBIC$L_MAP_BASE = 16;          ! Scatter/gather map base
literal CQBIC$M_INTPR_DBIRQ = %X'1';
literal CQBIC$M_INTPR_LMEAE = %X'20';
literal CQBIC$M_INTPR_DBIIE = %X'40';
literal CQBIC$M_INTPR_AUXHLT = %X'100';
literal CQBIC$M_INTPR_TBIA = %X'4000';
literal CQBIC$M_INTPR_DMAQME = %X'8000';
literal CQBIC$S_INTPR = 2;
macro CQBIC$V_INTPR_DBIRQ = 0,0,1,0 %;  !  Doorbell interrupt request
macro CQBIC$V_INTPR_MBZ_1 = 0,1,4,0 %;
literal CQBIC$S_INTPR_MBZ_1 = 4;
macro CQBIC$V_INTPR_LMEAE = 0,5,1,0 %;  !  Local memory enable
macro CQBIC$V_INTPR_DBIIE = 0,6,1,0 %;  !  Doorbell interrupt enable
macro CQBIC$V_INTPR_MBZ_2 = 0,7,1,0 %;
macro CQBIC$V_INTPR_AUXHLT = 0,8,1,0 %; !  Auxiliary halt
macro CQBIC$V_INTPR_MBZ_3 = 0,9,5,0 %;
literal CQBIC$S_INTPR_MBZ_3 = 5;
macro CQBIC$V_INTPR_TBIA = 0,14,1,0 %;  !  Xlate buffer invalidate all
macro CQBIC$V_INTPR_DMAQME = 0,15,1,0 %; !  DMA memory space error
 
!*** MODULE $CRABDEF ***
literal CRAB$K_LENGTH = 88;             !  Length of base structure (not including allocation array)
literal CRAB$S_CRAB = 96;
macro CRAB$L_FLINK = 0,0,32,1 %;        !  Forward link
macro CRAB$L_BLINK = 4,0,32,1 %;        !  Backward link
macro CRAB$W_SIZE = 8,0,16,0 %;         !  Structure size in bytes
macro CRAB$B_TYPE = 10,0,8,0 %;         !  Structure type
macro CRAB$B_SUBTYPE = 11,0,8,0 %;      !  Structure subtype
macro CRAB$L_SPINLOCK = 12,0,32,1 %;    !  Address of dynamic spinlock
macro CRAB$L_WQFL = 16,0,32,1 %;        !  Wait queue flink--points to links in CRCTX
macro CRAB$L_WQBL = 20,0,32,1 %;        !  Wait queue blink
macro CRAB$PS_ADP = 24,0,32,1 %;        !  Address of ADP
macro CRAB$L_TOTAL_ITEMS = 28,0,32,0 %; !  Total number of items
macro CRAB$L_ALLOC_GRAN_MASK = 32,0,32,0 %; !  Allocation granularity mask
macro CRAB$L_NOSYNC_SPINLOCK = 36,0,32,1 %; !  Address of dynamic spinlock
macro CRAB$L_RESERVED1 = 40,0,32,1 %;   !  Reserved longword
macro CRAB$L_RESERVED2 = 44,0,32,1 %;   !  Reserved longword
macro CRAB$L_RESERVED3 = 48,0,32,1 %;   !  Reserved longword
macro CRAB$L_VALID_DESC_CNT = 52,0,32,0 %; !  Count of valid descriptors
macro CRAB$L_FQFL = 56,0,32,1 %;        ! FORK QUEUE FORWARD LINK 
macro CRAB$L_FQBL = 60,0,32,1 %;        ! FORK QUEUE BACKWARD LINK 
macro CRAB$W_FSIZE = 64,0,16,0 %;       ! SIZE OF FKB IN BYTES 
macro CRAB$B_FTYPE = 66,0,8,0 %;        ! STRUCTURE TYPE OF FKB 
macro CRAB$B_FLCK = 67,0,8,0 %;         ! FORK LOCK NUMBER
macro CRAB$L_FPC = 68,0,32,1 %;         ! FORK PC 
macro CRAB$Q_FR3 = 72,0,0,1 %;
literal CRAB$S_FR3 = 8;                 ! FORK R3 
macro CRAB$Q_FR4 = 80,0,0,1 %;
literal CRAB$S_FR4 = 8;                 ! FORK R4 
macro CRAB$L_ALLOC_ARRAY = 88,0,32,0 %; !  Start of Allocation array
literal CRAB_ARRAY$S_CRAB_ARRAY = 8;
macro CRAB_ARRAY$L_NUM = 0,0,32,0 %;    !  Starting item number
macro CRAB_ARRAY$L_CNT = 4,0,32,0 %;    !  Item count
literal CRAB_ARRAY$K_LENGTH = 8;        !  Length of CRAB array entry
 
!*** MODULE $CRAMDEF ***
! +
!  CRAM - CSR Register Access Mailbox
! 
!  The CSR register access mailbox describes the remote I/O CSR access to be
!  performed.
! 
! -
literal CRAM$M_IN_USE = %X'1';
literal CRAM$M_DER = %X'2';
literal CRAM$M_CMD_VAL = %X'3FFFFFFF';
literal CRAM$M_CMD_BRIDGE = %X'40000000';
literal CRAM$M_CMD_WRITE = %X'80000000';
literal CRAM$M_MBX_DONE = %X'1';
literal CRAM$M_MBX_ERROR = %X'2';
literal CRAM$K_LENGTH = 128;            !  Length of structure
literal CRAM$S_CRAMDEF = 128;           !  Old CRAM size field for compatibility
!  Define common command indices
literal CRAMCMD$K_RDQUAD32 = 1;         !  Quadword read  in 32 bit space
literal CRAMCMD$K_RDLONG32 = 2;         !  Longword "     "  "  "   "
literal CRAMCMD$K_RDWORD32 = 3;         !  Word     "     "  "  "   "
literal CRAMCMD$K_RDBYTE32 = 4;         !  Byte     "     "  "  "   "
literal CRAMCMD$K_WTQUAD32 = 5;         !  Quadword write "  "  "   "
literal CRAMCMD$K_WTLONG32 = 6;         !  Longword "     "  "  "   "
literal CRAMCMD$K_WTWORD32 = 7;         !  Word     "     "  "  "   "
literal CRAMCMD$K_WTBYTE32 = 8;         !  Byte     "     "  "  "   "
literal CRAMCMD$K_RDQUAD64 = 9;         !  Quadword read  in 64 bit space
literal CRAMCMD$K_RDLONG64 = 10;        !  Longword "     "  "  "   "
literal CRAMCMD$K_RDWORD64 = 11;        !  Word     "     "  "  "   "
literal CRAMCMD$K_RDBYTE64 = 12;        !  Byte     "     "  "  "   "
literal CRAMCMD$K_WTQUAD64 = 13;        !  Quadword write "  "  "   "
literal CRAMCMD$K_WTLONG64 = 14;        !  Longword "     "  "  "   "
literal CRAMCMD$K_WTWORD64 = 15;        !  Word     "     "  "  "   "
literal CRAMCMD$K_WTBYTE64 = 16;        !  Byte     "     "  "  "   "
literal CRAMCMD$K_RDTRIBYTE32 = 17;     !  Tribyte  read  "  32 "   "
literal CRAMCMD$K_WTTRIBYTE32 = 18;     !  Tribyte  write "  32 "   "
literal CRAMCMD$K_RDTRIBYTE64 = 19;     !  Tribyte  read  "  64 "   "
literal CRAMCMD$K_WTTRIBYTE64 = 20;     !  Tribyte  write "  64 "   "
literal CRAMCMD$K_MININDEX = 1;
literal CRAMCMD$K_MAXINDEX = 20;
literal CRAM$S_CRAM = 128;
macro CRAM$L_FLINK = 0,0,32,1 %;        !  Forward link
macro CRAM$L_BLINK = 4,0,32,1 %;        !  Backward link
macro CRAM$W_SIZE = 8,0,16,0 %;         !  Structure size in bytes
macro CRAM$B_TYPE = 10,0,8,0 %;         !  Structure type
macro CRAM$B_SUBTYPE = 11,0,8,0 %;      !  Structure subtype
macro CRAM$L_MBPR = 12,0,32,1 %;        !  Address of MBPR
macro CRAM$Q_HW_MBX = 16,0,0,0 %;
literal CRAM$S_HW_MBX = 8;              !  PA of hardward mailbox
macro CRAM$Q_QUEUE_TIME = 24,0,0,0 %;
literal CRAM$S_QUEUE_TIME = 8;          !  Queue timeout time
macro CRAM$Q_WAIT_TIME = 32,0,0,0 %;
literal CRAM$S_WAIT_TIME = 8;           !  Wait timeout
macro CRAM$L_DRIVER = 40,0,32,0 %;      !  Spare longword for driver
macro CRAM$L_IDB = 44,0,32,1 %;         !  Pointer to IDB
macro CRAM$L_UCB = 48,0,32,1 %;         !  Pointer to UCB
macro CRAM$R_CRAM_FLAGS_OVERLAY = 52,0,32,0 %;
macro CRAM$L_CRAM_FLAGS = 52,0,32,0 %;  !  Flags bitmask
macro CRAM$V_IN_USE = 52,0,1,0 %;       !  CRAM is valid
macro CRAM$V_DER = 52,1,1,0 %;          !  Disable-error-reporting
macro CRAM$L_ADP = 56,0,32,1 %;         !  Pointer to ADP
!  This piece must be 64 byte aligned - this is the hardware mailbox
macro CRAM$L_COMMAND = 64,0,32,0 %;     !  Bus command
macro CRAM$L_CMD_BITS = 64,0,32,0 %;
macro CRAM$V_CMD_VAL = 64,0,30,0 %;
literal CRAM$S_CMD_VAL = 30;            !  Remote bus command bits
macro CRAM$V_CMD_BRIDGE = 64,30,1,0 %;  !  BRIDGE bit
macro CRAM$V_CMD_WRITE = 64,31,1,0 %;   !  WRITE bit
macro CRAM$B_BYTE_MASK = 68,0,8,0 %;    !  Active byte mask
macro CRAM$B_HOSE = 70,0,8,0 %;         !  I/O bus number
macro CRAM$Q_RBADR = 72,0,0,0 %;
literal CRAM$S_RBADR = 8;               !  Remote bus address
macro CRAM$Q_WDATA = 80,0,0,0 %;
literal CRAM$S_WDATA = 8;               !  Data to be written
macro CRAM$L_WDATA = 80,0,32,0 %;       !  Data to be written
macro CRAM$W_WDATA = 80,0,16,0 %;       !  Data to be written
macro CRAM$B_WDATA = 80,0,8,0 %;        !  Data to be written
macro CRAM$Q_RDATA = 96,0,0,0 %;
literal CRAM$S_RDATA = 8;               !  Returned read data
macro CRAM$L_RDATA = 96,0,32,0 %;
macro CRAM$W_RDATA = 96,0,16,0 %;
macro CRAM$B_RDATA = 96,0,8,0 %;
macro CRAM$W_MBX_FLAGS = 104,0,16,0 %;  !  Flags bitmask
macro CRAM$V_MBX_DONE = 104,0,1,0 %;    !  Mailbox operation completed
macro CRAM$V_MBX_ERROR = 104,1,1,0 %;   !  Error in operation
macro CRAM$W_ERROR_BITS = 106,0,0,0 %;  !  Device specific error bits
!  Mailbox data structure used by hardware and bootstrap code
literal HW_CRAM$M_MBX_DONE = %X'1';
literal HW_CRAM$M_MBX_ERROR = %X'2';
literal HW_CRAM$S_HW_CRAM = 64;
macro HW_CRAM$L_COMMAND = 0,0,32,0 %;   !  Bus command
macro HW_CRAM$B_BYTE_MASK = 4,0,8,0 %;  !  Active byte mask
macro HW_CRAM$B_HOSE = 6,0,8,0 %;       !  I/O bus number
macro HW_CRAM$Q_RBADR = 8,0,0,0 %;
literal HW_CRAM$S_RBADR = 8;            !  Remote bus address
macro HW_CRAM$Q_WDATA = 16,0,0,0 %;
literal HW_CRAM$S_WDATA = 8;            !  Data to be written
macro HW_CRAM$Q_RDATA = 32,0,0,0 %;
literal HW_CRAM$S_RDATA = 8;            !  Returned read data
macro HW_CRAM$W_MBX_FLAGS = 40,0,16,0 %; !  Flags bitmask
macro HW_CRAM$V_MBX_DONE = 40,0,1,0 %;  !  Mailbox operation completed
macro HW_CRAM$V_MBX_ERROR = 40,1,1,0 %; !  Error in operation
macro HW_CRAM$W_ERROR_BITS = 42,0,0,0 %; !  Device specific error bits
literal HW_CRAM$K_LENGTH = 64;          !  Length of structure
literal HW_CRAM$S_HW_CRAMDEF = 64;      !  Old HW_CRAM size field for compatibility
!  Command table definition.  Note -- the order of the longwords in the
!  CMDARRAY vector must be the same as the order of the constant command
!  indices defined above.
! 
literal CMDTABLEHEADER$K_LENGTH = 12;
literal CMDTABLE$S_CMDTABLE = 96;
macro CMDTABLE$PS_ADP = 0,0,32,1 %;
macro CMDTABLE$L_BUS_TYPE = 4,0,32,0 %; !  Bus Type
macro CMDTABLE$W_SIZE = 8,0,16,0 %;     !  Structure size in bytes
macro CMDTABLE$B_TYPE = 10,0,8,0 %;     !  Structure type
macro CMDTABLE$B_SUBTYPE = 11,0,8,0 %;  !  Structure subtype
macro CMDTABLE$L_CMD_VECTOR = 12,0,0,0 %; !  beginning of vector of commands
macro CRAMCMD$L_RDQUAD32 = 16,0,32,0 %; !  Quadword read  in 32 bit space
macro CRAMCMD$L_RDLONG32 = 20,0,32,0 %; !  Longword "     "  "  "   "
macro CRAMCMD$L_RDWORD32 = 24,0,32,0 %; !  Word     "     "  "  "   "
macro CRAMCMD$L_RDBYTE32 = 28,0,32,0 %; !  Byte     "     "  "  "   "
macro CRAMCMD$L_WTQUAD32 = 32,0,32,0 %; !  Quadword write "  "  "   "
macro CRAMCMD$L_WTLONG32 = 36,0,32,0 %; !  Longword "     "  "  "   "
macro CRAMCMD$L_WTWORD32 = 40,0,32,0 %; !  Word     "     "  "  "   "
macro CRAMCMD$L_WTBYTE32 = 44,0,32,0 %; !  Byte     "     "  "  "   "
macro CRAMCMD$L_RDQUAD64 = 48,0,32,0 %; !  Quadword read  in 64 bit space
macro CRAMCMD$L_RDLONG64 = 52,0,32,0 %; !  Longword "     "  "  "   "
macro CRAMCMD$L_RDWORD64 = 56,0,32,0 %; !  Word     "     "  "  "   "
macro CRAMCMD$L_RDBYTE64 = 60,0,32,0 %; !  Byte     "     "  "  "   "
macro CRAMCMD$L_WTQUAD64 = 64,0,32,0 %; !  Quadword write "  "  "   "
macro CRAMCMD$L_WTLONG64 = 68,0,32,0 %; !  Longword "     "  "  "   "
macro CRAMCMD$L_WTWORD64 = 72,0,32,0 %; !  Word     "     "  "  "   "
macro CRAMCMD$L_WTBYTE64 = 76,0,32,0 %; !  Byte     "     "  "  "   "
macro CRAMCMD$L_RDTRIBYTE32 = 80,0,32,0 %; !  Tribyte  read  "  32 "   "
macro CRAMCMD$L_WTTRIBYTE32 = 84,0,32,0 %; !  Tribyte  write "  32 "   "
macro CRAMCMD$L_RDTRIBYTE64 = 88,0,32,0 %; !  Tribyte  read  "  64 "   "
macro CRAMCMD$L_WTTRIBYTE64 = 92,0,32,0 %; !  Tribyte  write "  64 "   "
literal CMDTABLE$K_LENGTH = 96;         !  Length of structure
literal CMDTABLE$S_CMDTABLEDEF = 96;    !  Old CMDTABLE size field for compatibility
 
!*** MODULE $CRAMHDEF ***
! +
!  CRAMH - CSR Regsiter Access Mailbox Header
! 
!  The CSR register access mailbox header describes the page of mailboxes
! 
! -
literal CRAMH$S_CRAMH = 128;
macro CRAMH$L_FLINK = 0,0,32,1 %;       !  Forward link
macro CRAMH$L_BLINK = 4,0,32,1 %;       !  Backward link
macro CRAMH$W_SIZE = 8,0,16,0 %;        !  Structure size in bytes
macro CRAMH$B_TYPE = 10,0,8,0 %;        !  Structure type
macro CRAMH$B_SUBTYPE = 11,0,8,0 %;     !  Structure subtype
macro CRAMH$L_MAX = 12,0,32,0 %;        !  Mailbox max index
macro CRAMH$Q_PA_BASE = 16,0,0,0 %;
literal CRAMH$S_PA_BASE = 8;            !  Base PA of page
macro CRAMH$L_AVAIL = 24,0,32,0 %;      !  Mailboxes available
macro CRAMH$B_MAP = 28,0,0,0 %;
literal CRAMH$S_MAP = 64;               !  Usage bitmap
!  Sized for 64KB page max
literal CRAMH$K_LENGTH = 128;           !  Length of structure
 
!*** MODULE $CRBDEF ***
! +
!  CRB - CHANNEL REQUEST BLOCK
! 
!  THERE IS ONE CHANNEL REQUEST BLOCK FOR EACH SET OF DEVICES WHOSE
!  ACCESS TO A SET OF CONTROLLERS MUST BE SYNCHRONIZED. EACH CHANNEL
!  CONTROL BLOCK ALLOWS UP TO FOUR CONTROLLERS TO WHICH THE INDIVIDUAL
!  DEVICES CAN BE ATTACHED.
! -
literal CRB$M_XZA_CHAN0 = %X'1';
literal CRB$M_XZA_CHAN1 = %X'2';
literal CRB$M_XZA_ADPERR = %X'4';
literal CRB$M_BSY = %X'1';
literal CRB$M_UNINIT = %X'2';
literal CRB$K_LENGTH = 128;             ! LENGTH OF STANDARD CRB 
literal CRB$C_LENGTH = 128;             ! LENGTH OF STANDARD CRB 
literal CRB$S_CRB = 144;
macro CRB$L_FQFL = 0,0,32,1 %;          ! FORK QUEUE FORWARD LINK
macro CRB$L_FQBL = 4,0,32,1 %;          ! FORK QUEUE BACKWARD LINK
macro CRB$W_SIZE = 8,0,16,0 %;          ! SIZE OF CRB IN BYTES 
macro CRB$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE FOR CRB 
macro CRB$B_FLCK = 11,0,8,0 %;          ! FORK LOCK NUMBER
macro CRB$L_FPC = 12,0,32,1 %;          ! FORK PC
macro CRB$Q_FR3 = 16,0,0,1 %;
literal CRB$S_FR3 = 8;                  ! FORK R3
macro CRB$Q_FR4 = 24,0,0,1 %;
literal CRB$S_FR4 = 8;                  ! FORK R4
macro CRB$L_WQFL = 32,0,32,1 %;         ! WAIT QUEUE FORWARD LINK
macro CRB$L_WQBL = 36,0,32,1 %;         ! WAIT QUEUE BACKWARD LINK
macro CRB$B_TT_TYPE = 40,0,8,0 %;
macro CRB$L_TT_TYPE = 40,0,32,0 %;      ! controler type (DZ11, DZ32)
macro CRB$L_XZA_STS = 40,0,32,0 %;      ! Coordination for XZA driver
macro CRB$V_XZA_CHAN0 = 40,0,1,0 %;     ! Channel 0 reinit flag
macro CRB$V_XZA_CHAN1 = 40,1,1,0 %;     ! Channel 1 reinit flag
macro CRB$V_XZA_ADPERR = 40,2,1,0 %;    ! XZA error/reset flag
macro CRB$L_REFC = 44,0,32,0 %;         ! REFERENCE COUNT OF UCB'S 
macro CRB$W_REFC = 44,0,16,0 %;
macro CRB$B_MASK = 48,0,8,0 %;
macro CRB$L_MASK = 48,0,32,0 %;         ! CHANNEL ALLOCATION MASK 
macro CRB$V_BSY = 48,0,1,0 %;           !  CHANNEL IS BUSY (1=YES) 
macro CRB$V_UNINIT = 48,1,1,0 %;        !  GENBI  CRB is uninitialized. (1=YES) 
macro CRB$PS_BUSARRAY = 52,0,32,1 %;    !  Bus array for SCSI ports
macro CRB$Q_AUXSTRUC = 56,0,0,1 %;
literal CRB$S_AUXSTRUC = 8;             ! Auxiliary structure addr
macro CRB$L_AUXSTRUC = 56,0,32,0 %;
macro CRB$PS_AUXSTRUC = 56,0,32,1 %;
macro CRB$Q_LAN_STRUC = 64,0,0,1 %;
literal CRB$S_LAN_STRUC = 8;            ! Auxiliary pointer for LAN drivers
macro CRB$L_LAN_STRUC = 64,0,32,0 %;
macro CRB$PS_LAN_STRUC = 64,0,32,1 %;
macro CRB$Q_SCS_STRUC = 72,0,0,1 %;
literal CRB$S_SCS_STRUC = 8;
macro CRB$L_SCS_STRUC = 72,0,32,0 %;
macro CRB$PS_SCS_STRUC = 72,0,32,1 %;
macro CRB$L_TIMELINK = 80,0,32,1 %;     ! Thread of CRB's for periodic wakeup 
macro CRB$L_TT_MODEM = 80,0,32,1 %;     ! modem control timer thread
macro CRB$L_NODE = 84,0,32,0 %;         ! node number on bus
macro CRB$L_DUETIME = 88,0,32,0 %;      ! Due time for periodic wakeup 
macro CRB$PS_SYSG_DBLK = 88,0,32,1 %;   ! workstation SLU port driver/DW interface
macro CRB$L_TOUTROUT = 92,0,32,1 %;     ! Address of periodic wakeup routine 
macro CRB$L_TT_TIMREFC = 92,0,32,0 %;   ! lines with active modem timers
macro CRB$PS_DLCK = 96,0,32,1 %;        ! ADDRESS OF DEVICE SPINLOCK
macro CRB$PS_CRB_LINK = 100,0,32,1 %;   ! pointer to next CRB on ADP
macro CRB$Q_CTRLR_SHUTDOWN = 104,0,0,1 %;
literal CRB$S_CTRLR_SHUTDOWN = 8;       ! Address of controller shutdown routine
macro CRB$PS_CTRLR_SHUTDOWN = 104,0,32,1 %;
macro CRB$L_INTD = 112,0,0,0 %;
literal CRB$S_INTD = 16;                ! DEFAULT TRANSFER VECTOR START
macro CRB$L_INTD2 = 128,0,0,0 %;
literal CRB$S_INTD2 = 16;               ! 2ND DEFAULT TRANSFER VECTOR START
literal CRB$S_CRBDEF = 144;             ! OLD CRB SIZE FOR COMPATIBILITY
 
!*** MODULE $CRCTXDEF ***
literal CRCTX$M_HIGH_PRIO = %X'1';
literal CRCTX$M_ITEM_VALID = %X'2';
literal CRCTX$S_CRCTX = 96;
macro CRCTX$L_FLINK = 0,0,32,1 %;       !  Forward link
macro CRCTX$L_BLINK = 4,0,32,1 %;       !  Backward link
macro CRCTX$W_SIZE = 8,0,16,0 %;        !  Structure size in bytes
macro CRCTX$B_TYPE = 10,0,8,0 %;        !  Structure type
macro CRCTX$B_SUBTYPE = 11,0,8,0 %;     !  Structure subtype
macro CRCTX$L_CRAB = 12,0,32,1 %;       !  Address of CRAB
macro CRCTX$B_FLCK = 16,0,8,0 %;        ! FORK LOCK NUMBER
macro CRCTX$L_FLCK = 16,0,32,0 %;       ! FORK LOCK NUMBER
macro CRCTX$L_FLAGS = 20,0,32,1 %;      ! 
macro CRCTX$V_HIGH_PRIO = 20,0,1,0 %;   !  High priority request, attempt to
!  allocate resource immediately, 
!  without regard for whether there
!  are other threads waiting.
macro CRCTX$V_ITEM_VALID = 20,1,1,0 %;  !  Flag to indicate that the item
!  number and count fields are valid.
!  Used for sanity check by DEALLOC_CNT_RES.
! 
! 
macro CRCTX$L_WQFL = 24,0,32,1 %;       !  Stalled requests are queued
macro CRCTX$L_WQBL = 28,0,32,1 %;       !  to CRAB wait queue with these links
macro CRCTX$L_CONTEXT1 = 32,0,32,1 %;
macro CRCTX$Q_CONTEXT1 = 32,0,0,1 %;
literal CRCTX$S_CONTEXT1 = 8;
macro CRCTX$L_CONTEXT2 = 40,0,32,1 %;
macro CRCTX$Q_CONTEXT2 = 40,0,0,1 %;
literal CRCTX$S_CONTEXT2 = 8;
macro CRCTX$L_CONTEXT3 = 48,0,32,1 %;
macro CRCTX$Q_CONTEXT3 = 48,0,0,1 %;
literal CRCTX$S_CONTEXT3 = 8;
macro CRCTX$L_ITEM_CNT = 56,0,32,1 %;   !  Count of allocated items
macro CRCTX$L_ITEM_NUM = 60,0,32,1 %;   !  First allocated item num
macro CRCTX$L_UP_BOUND = 64,0,32,1 %;   !  Allocation upper bound
macro CRCTX$L_LOW_BOUND = 68,0,32,1 %;  !  Allocation lower bound
macro CRCTX$L_CALLBACK = 72,0,32,1 %;   !  Callback address
macro CRCTX$L_SAVED_CALLBACK = 76,0,32,1 %; !  Saved callback address
macro CRCTX$L_AUX_CONTEXT = 80,0,32,1 %; !  Auxiliary context longword
macro CRCTX$L_RESERVED1 = 84,0,32,1 %;  !  Reserved longword
macro CRCTX$L_RESERVED2 = 88,0,32,1 %;  !  Reserved longword
macro CRCTX$L_RESERVED3 = 92,0,32,1 %;  !  Reserved longword
literal CRCTX$K_LENGTH = 96;            !  Length of structure
literal CRCTX$S_CRCTXDEF = 96;          !  Old size name, synonym
 
!*** MODULE $VECDEF ***
! +
!  CRB INTERRUPT TRANSFER VECTOR STRUCTURE DEFINITIONS
! -
literal VEC$S_VEC = 16;
! CRB INTERRUPT TRANSFER VECTOR 
macro VEC$PS_ISR_CODE = 0,0,32,1 %;     ! address of Interrupt Service Routine Code entry
macro VEC$PS_ISR_PD = 4,0,32,1 %;       ! address of ISR Procedure Descriptor
macro VEC$L_IDB = 8,0,32,1 %;           ! ADDRESS OF ASSOCIATED IDB 
macro VEC$PS_ADP = 12,0,32,1 %;         ! ADDRESS OF ADP 
literal VEC$K_LENGTH = 16;              ! LENGTH OF STANDARD DISPATCHER 
literal VEC$C_LENGTH = 16;              ! LENGTH OF STANDARD DISPATCHER 
literal S_VECDEF = 16;                  ! OLD VEC SIZE NAME FOR COMPATIBILITY
 
!*** MODULE $CTSIDEF ***
literal CTSI$K_REVISION = 1;            !  CTSI Revision 1 only.
literal CTSI$C_REVISION = 1;
literal CTMD$K_SIZE = 8;                !  Size
literal CTMD$C_SIZE = 8;                !  Size
literal CTMD$S_CTMD = 8;                !  Module descriptor in the CTSIA.
macro CTMD$W_PGCOUNT = 0,0,16,0 %;      !  Module length in pages
macro CTMD$L_BASEADDR = 4,0,32,1 %;     !  Base physical addr.
literal CTCB$K_SIZE = 28;               !  Length of channel block
literal CTCB$C_SIZE = 28;               !  Length of channel block
literal CTCB$S_CTCB = 28;               !  Channel block in the CTSIA.
macro CTCB$B_DVATR = 0,0,8,0 %;         !  Device attributes
macro CTCB$B_CHATR = 1,0,8,0 %;         !  Channel attributes
macro CTCB$W_STATESZ = 2,0,16,0 %;      !  State size
macro CTCB$L_PHY_ENTRY = 4,0,32,1 %;    !  Physical entry point
macro CTCB$L_VIR_ENTRY = 8,0,32,1 %;    !  Virtual entry point
macro CTCB$L_PHY_SEGMENT = 12,0,32,1 %; !  IO segment physical addr
macro CTCB$L_VIR_SEGMENT = 16,0,32,1 %; !  IO segment virtual addr
macro CTCB$L_PHY_EXTEND = 20,0,32,1 %;  !  Extended state phys. addr
macro CTCB$L_VIR_EXTEND = 24,0,32,1 %;  !  Extended state virt. addr
literal CTIOS$K_SIZE = 8;               !  Descriptor length
literal CTIOS$C_SIZE = 8;               !  Descriptor length
literal CTIOS$S_CTIOS = 8;
!  Console I/O segment array and descriptors
macro CTIOS$W_SGMT_COUNT = 0,0,16,0 %;  !  # segments for channel
macro CTIOS$B_BASE_SEGMENT = 4,0,8,0 %; !  Offset for first segment dx.
macro CTIOS$W_PGCOUNT = 0,0,16,0 %;     !  Pages in this segment
macro CTIOS$L_SEGMENT = 4,0,32,1 %;     !  Physical Segment address
literal CTSI$K_MODULE_COUNT = 6;
literal CTSI$C_MODULE_COUNT = 6;
literal CTSI$K_CHN_COUNT = 6;
literal CTSI$C_CHN_COUNT = 6;
literal CTSI$M_CMUSE = %X'3';
literal CTSI$M_INUSE = %X'4';
literal CTSI$M_CM = %X'10';
literal CTSI$S_CTSIDEF = 316;           !  Old size name -  synonym
literal CTSI$S_CTSI = 316;
macro CTSI$L_BASE = 0,0,32,1 %;         !  Physical base address of CTSI
macro CTSI$W_SIZE = 4,0,16,0 %;         !  Size in bytes of CTSI
macro CTSI$W_IDENT = 6,0,16,0 %;        !  Indent string "CT"
macro CTSI$B_SPARE0 = 8,0,8,0 %;
macro CTSI$B_CHKSUM = 9,0,8,0 %;        !  Checksum of first bytes
macro CTSI$B_FLAGS = 10,0,8,0 %;        !  Flags
macro CTSI$V_CMUSE = 10,0,2,0 %;
literal CTSI$S_CMUSE = 2;
macro CTSI$V_INUSE = 10,2,1,0 %;        !  Routine in use
macro CTSI$V_SPARE0 = 10,3,1,0 %;
macro CTSI$V_CM = 10,4,1,0 %;           !  Console mode
macro CTSI$B_REVISN = 11,0,8,0 %;       !  Console revision
macro CTSI$Q_MODULE_DESC = 12,0,0,0 %;
literal CTSI$S_MODULE_DESC = 48;        !  Module descriptors
macro CTSI$L_CHNBLK = 60,0,0,0 %;
literal CTSI$S_CHNBLK = 168;            !  Channel blocks of size = (7 longs)
macro CTSI$Q_SAVE = 228,0,0,0 %;
literal CTSI$S_SAVE = 8;                !  Save ptrs
macro CTSI$Q_RESTORE = 236,0,0,0 %;
literal CTSI$S_RESTORE = 8;             !  Restore pointers
macro CTSI$Q_TRANS = 244,0,0,0 %;
literal CTSI$S_TRANS = 8;               !  Translate ptrs
macro CTSI$Q_GETCHR = 252,0,0,0 %;
literal CTSI$S_GETCHR = 8;              !  GET CHAR ptrs
macro CTSI$L_GETCHR_STATE = 260,0,0,0 %;
literal CTSI$S_GETCHR_STATE = 16;       !  GET CHAR state
macro CTSI$Q_PUTCHR = 276,0,0,0 %;
literal CTSI$S_PUTCHR = 8;              !  PUT CHAR ptrs
macro CTSI$L_PUTCHR_STATE = 284,0,0,0 %;
literal CTSI$S_PUTCHR_STATE = 16;       !  PUT CHAR state
macro CTSI$Q_PUTMSG = 300,0,0,0 %;
literal CTSI$S_PUTMSG = 8;              !  Put message routine
macro CTSI$Q_READPROMPT = 308,0,0,0 %;
literal CTSI$S_READPROMPT = 8;          !  Read with prompt routine
 
!*** MODULE $CSBDEF ***
! +
!  CSB - CLUSTER SYSTEM BLOCK.
! 
!      	THERE IS ONE CSB FOR EACH SYSTEM IN THE CLUSTER.
! -
literal CSB$K_OPEN = 1;                 !   OPEN
literal CSB$K_STATUS = 2;               !   SENDING/WAITING FOR STATUS
literal CSB$K_RECONNECT = 3;            !   ATTEMPTING TO RECONNECT
literal CSB$K_NEW = 4;                  !   BRAND NEW BLOCK
literal CSB$K_CONNECT = 5;              !   ATTEMPTING INITIAL CONNECTION
literal CSB$K_ACCEPT = 6;               !   ACCEPTING INITIAL CONNECTION
literal CSB$K_DISCONNECT = 7;           !   DISCONNECT IN PROGRESS
literal CSB$K_REACCEPT = 8;             !   ACCEPTING RECONNECT REQUEST
literal CSB$K_WAIT = 9;                 !   TIME-OUT IN PROGRESS
literal CSB$K_DEAD = 10;                !   NO CONNECTION POSSIBLE
literal CSB$K_LOCAL = 11;               !   LOCAL SYSTEM CSB
literal CSB$M_LONG_BREAK = %X'1';
literal CSB$M_MEMBER = %X'2';
literal CSB$M_REMOVED = %X'4';
literal CSB$M_QF_SAME = %X'8';
literal CSB$M_QF_WATCHER = %X'10';
literal CSB$M_QF_NOACCESS = %X'20';
literal CSB$M_OLDVER_1 = %X'40';
literal CSB$M_CWPS = %X'80';
literal CSB$M_CLUSTER = %X'100';
literal CSB$M_QF_ACTIVE = %X'200';
literal CSB$M_SHUTDOWN = %X'400';
literal CSB$M_GONE = %X'800';
literal CSB$M_MULTITASK = %X'1000';
literal CSB$M_RANGELOCK = %X'2000';
literal CSB$M_DYN_REMASTER = %X'4000';
literal CSB$M_LOCKED = %X'10000';
literal CSB$M_SELECTED = %X'20000';
literal CSB$M_RESERVED1 = %X'40000';
literal CSB$M_SEND_EXT_STATUS = %X'80000';
literal CSB$M_LOCAL = %X'1000000';
literal CSB$M_STATUS_RCVD = %X'2000000';
literal CSB$M_SEND_STATUS = %X'4000000';
literal CSB$M_QF_RFRSH_RQD = %X'8000000';
literal CSB$M_QF_RFRSH_IP = %X'10000000';
literal CSB$M_QF_IOSYNCH = %X'20000000';
literal CSB$M_ACT_LSHARE = %X'40000000';
literal CSB$M_PASS_LSHARE = %X'80000000';
literal CSB$M_CAP_RM8SEC = %X'1';
literal CSB$M_CAP_VCC = %X'2';
literal CSB$M_CAP_DTS = %X'4';
literal CSB$M_CAP_EXT_STATUS = %X'8';
literal CSB$C_LENGTH = 272;             !  LENGTH OF CSB 
literal CSB$K_LENGTH = 272;             !  LENGTH OF CSB 
literal CSB$S_CSBDEF = 272;             !  Old size name - synonym
literal CSB$S_CSB = 272;
macro CSB$L_SYSQFL = 0,0,32,1 %;        !  SYSTEM QUEUE FORWARD LINK
macro CSB$L_SYSQBL = 4,0,32,1 %;        !  SYSTEM QUEUE BACKWARD LINK
macro CSB$W_SIZE = 8,0,16,0 %;          !  SIZE OF CSB IN BYTES
macro CSB$B_TYPE = 10,0,8,0 %;          !  STRUCTURE TYPE 
macro CSB$B_SUBTYPE = 11,0,8,0 %;       !  STRUCTURE SUBTYPE
macro CSB$L_CDT = 12,0,32,1 %;          !  CDT ADDRESS
macro CSB$L_PDT = 16,0,32,1 %;          !  PDT ADDRESS
macro CSB$L_SENTQFL = 20,0,32,1 %;      !  SENT LIST HEAD LINK
macro CSB$L_SENTQBL = 24,0,32,1 %;      !  SENT LIST TAIL LINK
macro CSB$L_RESENDQFL = 28,0,32,1 %;    !  RESEND LIST HEAD LINK
macro CSB$L_RESENDQBL = 32,0,32,1 %;    !  RESEND LIST TAIL LINK
macro CSB$L_WARMCDRPQFL = 36,0,32,1 %;  !  WARM CDRP QUEUE FORWARD LINK
macro CSB$L_WARMCDRPQBL = 40,0,32,1 %;  !  WARM CDRP QUEUE BACKWARD LINK
macro CSB$W_SENDSEQNM = 44,0,16,0 %;    !  NEXT SEQUENCE NUMBER TO SEND
macro CSB$W_RCVDSEQNM = 46,0,16,0 %;    !  LAST SEQUENCE NUMBER RECEIVED
macro CSB$W_ACKRSEQNM = 48,0,16,0 %;    !  LAST ACK RECEIVED SEQ. NUM.
macro CSB$B_UNACKEDMSGS = 50,0,8,0 %;   !  NUMBER OF UNACKED MESSAGES
macro CSB$B_REMACKLIM = 51,0,8,0 %;     !  REMOTE SIDE'S ACK LIMIT
macro CSB$L_CURRCDRP = 52,0,32,1 %;     !  ADDRESS OF CDRP IN CRITICAL SECTION
macro CSB$Q_SWINCARN = 56,0,0,0 %;
literal CSB$S_SWINCARN = 8;             !  REMOTE SOFTWARE INCARN. NUM.
macro CSB$B_ECOLVL = 64,0,8,0 %;        !  PROTOCOL ECO LEVEL
macro CSB$B_VERNUM = 65,0,8,0 %;        !  PROTOCOL VERSION NUMBER
macro CSB$B_WARMCDRPS = 66,0,8,0 %;     !  NUMBER OF CDRPS ON FREE QUEUE
macro CSB$B_STATE = 67,0,8,0 %;         !  STATE OF CONNECTION
!  STATE VALUES:
macro CSB$L_TQE = 68,0,32,1 %;          !  ADDRESS OF TIMER QUEUE ENTRY
macro CSB$L_TIMEOUT = 72,0,32,0 %;      !  TIME TO GIVE UP RECONNECTING
macro CSB$L_CSID = 76,0,32,0 %;         !  Cluster System ID
macro CSB$W_CSID_IDX = 76,0,16,0 %;     !  Slot index
macro CSB$W_CSID_SEQ = 78,0,16,0 %;     !  Sequence number
macro CSB$W_VOTES = 80,0,16,0 %;        !  VOTES HELD BY NODE
macro CSB$W_QUORUM = 82,0,16,0 %;       !  QUORUM SET IN NODE
macro CSB$W_LCKDIRWT = 84,0,16,0 %;     !  LOCK MANAGER DISTRIBUTED DIRECTORY WEIGHT
macro CSB$W_QDVOTES = 86,0,16,0 %;      !  VOTES ASSIGNED TO QUORUM DISK
macro CSB$L_PARTNERQFL = 88,0,32,1 %;   !  LISTHEAD FWD PTR FOR BLOCK-XFER PARTNER BTXs
macro CSB$L_PARTNERQBL = 92,0,32,1 %;   !  LISTHEAD BACK PTR FOR BLOCK-XFER PARTNER BTXs
macro CSB$L_STATUS = 96,0,32,0 %;       !  STATUS OF NODE IN CLUSTER
!  THE FOLLOWING BITS ARE ALWAYS MEANINGFUL
!  BYTE 0
macro CSB$V_LONG_BREAK = 96,0,1,0 %;    !   LONG BREAK IN CONNECTION
macro CSB$V_MEMBER = 96,1,1,0 %;        !   NODE IS MEMBER OF LOCAL CLUSTER
macro CSB$V_REMOVED = 96,2,1,0 %;       !   NODE REMOVED FROM CLUSTER
macro CSB$V_QF_SAME = 96,3,1,0 %;       !   REMOTE QUORUM DISK MATCHES LOCAL DISK
macro CSB$V_QF_WATCHER = 96,4,1,0 %;    !   REMOTE NODE IS WATCHING A QUORUM FILE
macro CSB$V_QF_NOACCESS = 96,5,1,0 %;   !   NODE WILL NEVER ACCESS QUORUM DISK
macro CSB$V_OLDVER_1 = 96,6,1,0 %;      !   OLD VERSION PROTOCOL FLAG
macro CSB$V_CWPS = 96,7,1,0 %;          !   NODE SPEAKS CWPS
!  BYTE 1
macro CSB$V_CLUSTER = 96,8,1,0 %;       !   REMOTE NODE IS CLUSTER MEMBER
macro CSB$V_QF_ACTIVE = 96,9,1,0 %;     !   REMOTE NODE'S QUORUM FILE IS READABLE
macro CSB$V_SHUTDOWN = 96,10,1,0 %;     !   REMOTE NODE READY FOR CLUSTER SHUTDOWN
macro CSB$V_GONE = 96,11,1,0 %;         !   KNOWN TO HAVE SHUTDOWN
macro CSB$V_MULTITASK = 96,12,1,0 %;    !   NODE SPEAKS MULTITASK
macro CSB$V_RANGELOCK = 96,13,1,0 %;    !   supports ranges and priorities
macro CSB$V_DYN_REMASTER = 96,14,1,0 %; !   supports dynamic remastering 
!  THE FOLLOWING BITS ARE MEANINGFUL IF THIS NODE IS THE COORDINATOR
!  BYTE 2
macro CSB$V_LOCKED = 96,16,1,0 %;       !   NODE LOCKED BY COORDINATOR
macro CSB$V_SELECTED = 96,17,1,0 %;     !   NODE SELECTED BY COORDINATOR
macro CSB$V_RESERVED1 = 96,18,1,0 %;    !   Bit was used for a VAX release
macro CSB$V_SEND_EXT_STATUS = 96,19,1,0 %; !   NEED TO SEND EXTENDED STATUS
!  THE FOLLOWING BITS ARE OF LOCAL SIGNIFICANCE ONLY
macro CSB$V_LOCAL = 96,24,1,0 %;        !   MARK CSB FOR LOCAL SYSTEM
macro CSB$V_STATUS_RCVD = 96,25,1,0 %;  !   STATUS RECEIVED FROM REMOTE SYSTEM
macro CSB$V_SEND_STATUS = 96,26,1,0 %;  !   NEED TO SEND STATUS TO REMOTE SYSTEM
macro CSB$V_QF_RFRSH_RQD = 96,27,1,0 %; !   NEED QUORUM FILE REFRESH
macro CSB$V_QF_RFRSH_IP = 96,28,1,0 %;  !   QF REFRESH IN PROGRESS
macro CSB$V_QF_IOSYNCH = 96,29,1,0 %;   !   QF IO SYNCH DONE
macro CSB$V_ACT_LSHARE = 96,30,1,0 %;   !   ACTIVE SIDE TO LOAD SHARING
macro CSB$V_PASS_LSHARE = 96,31,1,0 %;  !   PASSIVE SIDE TO LOAD SHARING
macro CSB$L_CLUB = 100,0,32,1 %;        !  ADDRESS OF CLUB
macro CSB$L_SB = 104,0,32,1 %;          !  ADDRESS OF SB FOR REMOTE SYSTEM
macro CSB$B_REF_CNT = 108,0,8,0 %;      !  REFERENCE COUNT
macro CSB$B_CLUVER = 109,0,8,0 %;       !  CLUSTER VERSION NUMBER
macro CSB$W_NODES = 110,0,16,0 %;       !  Number of nodes in remote cluster
macro CSB$W_CNX_STS_R0 = 112,0,16,0 %;  !  CONNECTION REQUEST R0 STATUS
macro CSB$W_CNX_STS_R1 = 114,0,16,0 %;  !  CONNECTION REQUEST R1 STATUS
macro CSB$Q_REFTIME = 116,0,0,1 %;
literal CSB$S_REFTIME = 8;              !  CREATION/ADDITION/REMOVAL TIME
macro CSB$L_RMAX_VCTMO = 124,0,32,0 %;  !  MAX REMOTE VC TIMEOUT INTERVAL
macro CSB$W_LASTSENT = 128,0,16,0 %;    !  SEQ. NUM. OF MESSAGE LAST SENT
macro CSB$W_EVOTES = 130,0,16,0 %;      !  REMOTE NODE'S EXPECTED VOTES
macro CSB$B_CNCT = 132,0,0,1 %;
literal CSB$S_CNCT = 16;                !  CONNECT/ACCEPT DATA AREA
macro CSB$B_NODEMAP = 148,0,0,1 %;
literal CSB$S_NODEMAP = 32;             !  BITMAP OF NODE CONNECTIVITY
macro CSB$W_CNID = 180,0,16,0 %;        !  CLUSTER NODE ID
macro CSB$W_PASS_CNTR = 182,0,16,0 %;   !  Total Passive loadshare ops
macro CSB$W_ACT_CNTR = 184,0,16,0 %;    !  Total Active loadshare ops
macro CSB$W_ERR_CNTR = 186,0,16,0 %;    !  Total Errors on connection
macro CSB$L_CAPABILITY = 188,0,32,0 %;  !  Node capabilities 
macro CSB$V_CAP_RM8SEC = 188,0,1,0 %;   !  8 second activity scan
macro CSB$V_CAP_VCC = 188,1,1,0 %;      !  VCC Enabled
macro CSB$V_CAP_DTS = 188,2,1,0 %;      !  DTS Enabled
macro CSB$V_CAP_EXT_STATUS = 188,3,1,0 %; !  Extended status message
macro CSB$B_HWNAME = 192,0,0,1 %;
literal CSB$S_HWNAME = 61;              !  SYSTEM NAME
macro CSB$B_FILL_6 = 253,0,24,1 %;
literal CSB$S_FILL_6 = 3;               !  Padding
macro CSB$L_ABSTIM_OFFSET = 256,0,32,1 %; !  Offset to obtain nodes ABSTIM
macro CSB$T_SW_VERSION = 264,0,0,0 %;
literal CSB$S_SW_VERSION = 8;           !  Software Version
 
!*** MODULE $CSDTDEF ***
! +
!  CSDT - CLUSTER SERVER DISPATCH TABLE
! 
! -
! 
! 	CSDTE - CLUSTER SERVER DISPATCH TABLE ENTRY
! 
! 
literal CSDTE$C_LENGTH = 64;            !  LENGTH
literal CSDTE$K_LENGTH = 64;            !  LENGTH
literal CSDTE$S_CSDTEDEF = 64;
literal CSDTE$S_CSDTE = 64;
macro CSDTE$Q_REQ_IQ = 0,0,0,0 %;
literal CSDTE$S_REQ_IQ = 8;             !  INTERLOCKED REQUEST QUEUE
macro CSDTE$Q_WAITQ = 8,0,0,0 %;
literal CSDTE$S_WAITQ = 8;              !  WAIT QUEUE
macro CSDTE$L_IPID = 16,0,32,0 %;       !  SERVER IPID
macro CSDTE$L_QUEUED = 20,0,32,0 %;     !  NUMBER OF WAITS
macro CSDTE$L_REQUESTS = 24,0,32,0 %;   !  TOTAL REQUESTS MADE
macro CSDTE$L_WAITCNT = 28,0,32,0 %;    !  ENTRIES IN WAIT QUEUE
macro CSDTE$L_MAXACTIVE = 32,0,32,0 %;  !  MAXIMUM ACTIVE REQUESTS ALLOWED
macro CSDTE$L_ACTIVE = 36,0,32,0 %;     !  NUMBER ACTIVE REQUESTS
literal CSDT$C_LENGTH = 16;             !  LENGTH OF FIXED PART
literal CSDT$K_LENGTH = 16;             !  LENGTH OF FIXED PART
literal CSDT$T_CSDTEVEC = 16;           !  START OF VARIABLE PART
literal CSDT$S_CSDTDEF = 16;
literal CSDT$S_CSDT = 16;
macro CSDT$W_SIZE = 8,0,16,0 %;         !  SIZE OF IN BYTES
macro CSDT$B_TYPE = 10,0,8,0 %;         !  STRUCTURE TYPE 
macro CSDT$B_SUBTYPE = 11,0,8,0 %;      !  STRUCTURE SUBTYPE
 
!*** MODULE $CTLP1FLAGSDEF ***
!  +
!  CTL P1 flags
! 
!  These are flags in the CTL p1 region to define miscellaneous things.
!  They reside in the cell CTL$GQ_MISC_P1_FLAGS, defined in SHELL.MAR.
! 
!  -
literal CTLP1FLAGS$M_GSD_CLEAN = %X'1';
literal CTLP1FLAGS$M_IPC_CLEAN = %X'2';
literal CTLP1FLAGS$M_PSX_PML = %X'4';
literal CTLP1FLAGS$S_CTLP1DEF = 1;      !  Old size name - synonym
literal CTLP1FLAGS$S_CTLP1 = 1;
macro CTLP1FLAGS$V_GSD_CLEAN = 0,0,1,0 %; !  GSD clean-up is in progress
macro CTLP1FLAGS$V_IPC_CLEAN = 0,1,1,0 %; !  $IPC association clean-up is in progress
macro CTLP1FLAGS$V_PSX_PML = 0,2,1,0 %; !  POSIX user stack locked in working set
 
!*** MODULE $CWPSDEF ***
! +
!  cwpssrv - Common service structure header
! 
!   All cwpsxxx$ packets contain the following header information.
! 
!  Fields marked with ++ must be filled/zeroed by service-specific
!  routines (at least for pcntrl services)
!  
! -
! 
!  The CWPSSRV$ structure is exchanged with remote nodes.  Any updates to this
!  structure must take mixed-version operation into account.
! 
literal cwpssrv$m_btx_done = %X'1';
literal cwpssrv$m_sec_class = %X'1';
literal cwpssrv$m_jpibuf = %X'2';
literal cwpssrv$m_noquota = %X'4';
literal cwpssrv$m_group_priv = %X'8';
literal cwpssrv$m_world_priv = %X'10';
literal cwpssrv$m_secaudit = %X'20';
literal cwpssrv$m_noaudit = %X'40';
literal cwpssrv$k_retry_cnt = 5;        !  five retries is about
!   4 seconds
literal cwpssrv$k_length = 112;         !  length of data structure common
literal cwpssrv$k_srvcode_begin = 0;    !  - marker for beginning of codes
literal cwpssrv$k_canwak = 1;           !  $CANWAK service
literal cwpssrv$k_delprc = 2;           !  $DELPRC service
literal cwpssrv$k_forcex = 3;           !  $FORCEX service
literal cwpssrv$k_resume = 4;           !  $RESUME service
literal cwpssrv$k_schdwk = 5;           !  $SCHDWK service
literal cwpssrv$k_setpri = 6;           !  $SETPRI service
literal cwpssrv$k_suspnd = 7;           !  $SUSPND service
literal cwpssrv$k_wake = 8;             !  $WAKE service
literal cwpssrv$k_srvcode_end = 9;      !  - marker for end of SRV codes
!  CWPS subtypes for other services
literal cwpssrv$k_getjpi = 20;          !  $GETJPI service
literal cwpssrv$k_creprc = 21;          !  $CREPRC service
literal cwpssrv$k_termin = 22;          !  process termination message
!  CWPS subtypes for security service codes
literal cwpssrv$k_grantid = 28;         !  $GRANTID service
literal cwpssrv$k_revokid = 29;         !  $WAKE service
literal cwpssrv$k_version_1 = 1;        !  initial version
literal cwpssrv$k_version_2 = 2;
literal cwpssrv$k_version_3 = 3;
literal cwpssrv$k_version_4 = 4;
literal cwpssrv$k_version_5 = 5;
literal cwpssrv$k_version_6 = 6;
literal cwpssrv$k_version_7 = 7;
literal cwpssrv$k_version_8 = 8;
literal cwpssrv$k_version_9 = 9;
literal cwpssrv$k_version_10 = 10;
literal cwpssrv$k_version_11 = 11;
literal cwpssrv$k_version_12 = 12;
literal cwpssrv$k_initial_maj_vers = 1;
literal cwpssrv$k_initial_min_vers = 1;
literal cwpssrv$s_$cwpssrvdef = 112;
literal cwpssrv$S_cwpssrv = 112;
macro cwpssrv$l_send_length = 0,0,32,0 %; !  length sent to partner
macro cwpssrv$l_return_length = 4,0,32,0 %; !  length returned from partner
macro cwpssrv$w_size = 8,0,16,0 %;      !  size of structure	++
macro cwpssrv$b_type = 10,0,8,0 %;      !  structure type code	++
macro cwpssrv$b_subtype = 11,0,8,0 %;   !  structure subtype and service code  ++
macro cwpssrv$w_btx_status = 12,0,16,0 %; !  status of block transfer request
macro cwpssrv$b_btx_flags = 14,0,8,0 %; !  state of block transfer
macro cwpssrv$v_btx_done = 14,0,1,0 %;  !  block transfer is complete
macro cwpssrv$b_func = 15,0,8,0 %;      !  CLSMSG request function code
macro cwpssrv$w_srv_maj_vers = 16,0,16,0 %; !  incompatible version formats
macro cwpssrv$w_srv_min_vers = 18,0,16,0 %; !  upwards compatible extensions
macro cwpssrv$w_ext_maj_vers = 20,0,16,0 %; !  incompatible version formats
macro cwpssrv$w_ext_min_vers = 22,0,16,0 %; !  upwards compatible extensions
macro cwpssrv$l_status = 24,0,32,0 %;   !  status from remote service
macro cwpssrv$l_bxfr_status = 28,0,32,0 %; !  status from block transfer
macro cwpssrv$l_maximum_length = 32,0,32,0 %; !  maximum possible return length
macro cwpssrv$l_flags = 36,0,32,0 %;    !  longword of flags
macro cwpssrv$v_sec_class = 36,0,1,0 %; !  sec class present...
macro cwpssrv$v_jpibuf = 36,1,1,0 %;    !  jpi requests buffered
macro cwpssrv$v_noquota = 36,2,1,0 %;   !  quota has not been charged
macro cwpssrv$v_group_priv = 36,3,1,0 %; !  requestor running image with GROUP privilege
macro cwpssrv$v_world_priv = 36,4,1,0 %; !  requestor running image with WORLD privilege
macro cwpssrv$v_secaudit = 36,5,1,0 %;  !  requestor running with mandatory process auditing
macro cwpssrv$v_noaudit = 36,6,1,0 %;   !  requestor is part of TCB
macro cwpssrv$l_ext_offset = 40,0,32,0 %; !  offset to service-specific extension
macro cwpssrv$a_post_routine = 44,0,32,0 %; !  address of post-processing routine  ++
macro cwpssrv$l_rqstr_csid = 48,0,32,0 %; !  CSID of the requestor's node
macro cwpssrv$l_rqstr_pid = 52,0,32,0 %; !  IPID of the requestor
macro cwpssrv$l_rqstr_epid = 56,0,32,0 %; !  EPID of the requestor
macro cwpssrv$l_rqstr_imgcnt = 60,0,32,0 %; !  image count of requestor
macro cwpssrv$l_rqstr_rightslen = 64,0,32,0 %; !  length of process rights info
macro cwpssrv$l_rqstr_rightsoff = 68,0,32,0 %; !  offset to start of rights info
macro cwpssrv$l_rqstr_pidadr = 72,0,32,1 %; !  original pid address from user
macro cwpssrv$l_partner_csid = 76,0,32,0 %; !  CSID of the partner node
macro cwpssrv$l_sought_epid = 80,0,32,0 %; !  epid for target process
macro cwpssrv$l_return_epid = 84,0,32,0 %; !  actual epid from target process
macro cwpssrv$w_prcnamlen = 88,0,16,0 %; !  length of target process name
macro cwpssrv$w_prcnamoff = 90,0,16,0 %; !  offset to start of target process name
macro cwpssrv$l_free_offset = 92,0,32,0 %; !  offset to free data area
macro cwpssrv$l_spare1 = 96,0,32,0 %;   !  zero if unused
macro cwpssrv$w_spare2 = 100,0,16,0 %;  !  zero if unused
macro cwpssrv$b_spare3 = 102,0,8,0 %;   !  zero if unused
macro cwpssrv$b_retries_left = 103,0,8,0 %; !  number of retries remaining
macro cwpssrv$q_time = 104,0,0,0 %;
literal cwpssrv$s_time = 8;             !  time structure allocated
literal cwps$_enabled = 1;              !  assemble the code
literal cwps$_nervous = 1;              !  do reasonable checking
literal cwps$_scared = 1;               !  do a lot of consistency checking
literal cwps$_paranoid = 1;             !  do excessive checking
literal cwps$_statistics = 1;           !  collect statistics
literal cwpscan$k_length = 0;           !  length of $CANWAK
literal cwpsdel$k_length = 0;           !  length of $DELPRC
literal cwpsres$k_length = 0;           !  length of $RESUME
literal cwpssus$k_length = 0;           !  length of $SUSPND
literal cwpswak$k_length = 0;           !  length of $WAKE
! 
!  The CWPSFEX$ structure is exchanged with remote nodes.  Any updates to this
!  structure must take mixed-version operation into account.
! 
literal cwpsfex$k_length = 4;           !  length of data structure
literal cwpsfex$s_$cwpsfexdef = 4;      !  Old size name - synonym
literal cwpsfex$S_cwpsfex = 4;
macro cwpsfex$l_code = 0,0,32,0 %;      !  code to pass to remote
!  Version # of 6-cell SETPRI extension
literal cwpssrv$k_setpri_min_vers2 = 2;
! 
!  The CWPSPRI$ structure is exchanged with remote nodes.  Any updates to this
!  structure must take mixed-version operation into account.
! 
literal cwpspri$k_length = 24;          !  length of data structure
literal cwpspri$s_$cwpspridef = 24;     !  Old size name - synonym
literal cwpspri$S_cwpspri = 24;
macro cwpspri$l_user_prvpri = 0,0,32,1 %; !  address of user's prvpri cell
macro cwpspri$l_pri = 4,0,32,0 %;       !  priority we send to remote
macro cwpspri$l_prvpri = 8,0,32,0 %;    !  priority we receive from remote
macro cwpspri$l_user_prvpol = 12,0,32,1 %; !  address of user's prvpol cell
macro cwpspri$l_pol = 16,0,32,0 %;      !  policy we send to remote (or -1)
macro cwpspri$l_prvpol = 20,0,32,0 %;   !  prev policy we receive from remote
! 
!  The CWPSSWK$ structure is exchanged with remote nodes.  Any updates to this
!  structure must take mixed-version operation into account.
! 
literal cwpsswk$k_length = 16;          !  length of data structure
literal cwpsswk$s_$cwpsswkdef = 16;     !  Old size name - synonym
literal cwpsswk$S_cwpsswk = 16;
macro cwpsswk$q_daytim = 0,0,0,0 %;
literal cwpsswk$s_daytim = 8;           !  time to wake up
macro cwpsswk$q_reptim = 8,0,0,0 %;
literal cwpsswk$s_reptim = 8;           !  time to repeat wake up
! 
!  The CWPSJPI$ structure is exchanged with remote nodes.  Any updates to this
!  structure must take mixed-version operation into account.
! 
literal cwpsjpi$k_length = 60;          !  length of data structure
literal cwpsjpi$s_$cwpsjpidef = 60;     !  Old size name - synonym
literal cwpsjpi$S_cwpsjpi = 60;
macro cwpsjpi$l_pscan_off = 0,0,32,0 %; !  offset to start of pscanctx
macro cwpsjpi$l_itmoff = 4,0,32,0 %;    !  offset to item list in structure
macro cwpsjpi$l_bufoff = 8,0,32,0 %;    !  offset to return buffer
macro cwpsjpi$l_vecoff = 12,0,32,0 %;   !  offset to vector for item addr
macro cwpsjpi$l_acboff = 16,0,32,0 %;   !  offset to acb structure
macro cwpsjpi$l_itmlst = 20,0,32,1 %;   !  address of original item list
macro cwpsjpi$l_buflen = 24,0,32,0 %;   !  length of user's buffers
macro cwpsjpi$l_iosbadr = 28,0,32,1 %;  !  user's I/O status address
macro cwpsjpi$q_iosb = 32,0,0,0 %;
literal cwpsjpi$s_iosb = 8;             !  return iosb contents
macro cwpsjpi$l_astadr = 40,0,32,1 %;   !  AST address
macro cwpsjpi$l_astprm = 44,0,32,0 %;   !  AST parameter
macro cwpsjpi$l_pscanctx_addr = 48,0,32,1 %; !  PSCANCTX record address
macro cwpsjpi$w_pscan_seqnum = 52,0,16,0 %; !  sequence number of PSCANCTX
macro cwpsjpi$b_efn = 54,0,8,0 %;       !  event flag to set 
macro cwpsjpi$b_acmode = 55,0,8,0 %;    !  access mode of original call
macro cwpsjpi$w_ctlflags = 56,0,16,0 %; !  JPI$_GETJPI_CONTROL_FLAGS bits
macro cwpsjpi$w_spare0 = 58,0,16,0 %;   !  spare, align
! 
!  The CWPSVEC$ structure is a local structure.  If modified, you do not need
!  to take mixed-version operation into account, however you must be sure that
!  all modules and images which reference the structure are updated together.
! 
literal cwpsvec$k_length = 8;           !  length of data structure
literal cwpsvec$s_$cwpsvecdef = 8;      !  Old size name - synonym
literal cwpsvec$S_cwpsvec = 8;
macro cwpsvec$l_usr_bufadr = 0,0,32,1 %; !  user's address for buffer items
macro cwpsvec$l_usr_lenadr = 4,0,32,1 %; !  user's address for returned length
! 
!  The CWPSACB$ structure is a local structure.  If modified, you do not need
!  to take mixed-version operation into account, however you must be sure that
!  all modules and images which reference the structure are updated together.
! 
literal cwpsacb$k_acb_length = 36;      !  length of embedded block
literal cwpsacb$k_length = 80;          !  length of data structure (less PCB)
literal cwpsacb$S_$cwpsacbdef = 81;     !  Old size name - synonym
literal cwpsacb$S_cwpsacb = 81;
macro cwpsacb$l_astqfl = 0,0,32,1 %;    !  ast queue forward link 
macro cwpsacb$l_astqbl = 4,0,32,1 %;    !  ast queue backward link 
macro cwpsacb$w_size = 8,0,16,0 %;      !  structure size in bytes 
macro cwpsacb$b_type = 10,0,8,0 %;      !  structure type code 
macro cwpsacb$b_rmod = 11,0,8,0 %;      !  request access mode 
macro cwpsacb$l_pid = 12,0,32,0 %;      !  process id of request 
macro cwpsacb$l_ast = 16,0,32,1 %;      !  ast routine address 
macro cwpsacb$l_astprm = 20,0,32,0 %;   !  ast parameter 
macro cwpsacb$l_kast = 32,0,32,1 %;     !  internal kernel mode xfer address 
macro cwpsacb$l_bufadr = 36,0,32,1 %;   !  address of buffer
macro cwpsacb$l_buflen = 40,0,32,0 %;   !  length of the buffer
macro cwpsacb$l_msgbuf = 44,0,32,1 %;   !  message buffer address
macro cwpsacb$l_csb = 48,0,32,1 %;      !  csb address
macro cwpsacb$l_cdrp = 52,0,32,1 %;     !  cdrp address
macro cwpsacb$l_read_length = 56,0,32,0 %; !  length of bxfr read request
macro cwpsacb$l_write_length = 60,0,32,0 %; !  length of bxfr write request
macro cwpsacb$l_rightsdesc = 64,0,0,0 %;
literal cwpsacb$s_rightsdesc = 8;       !  descriptor for rightslist
macro cwpsacb$b_func = 72,0,8,0 %;      !  function code from message
macro cwpsacb$b_spare0 = 73,0,8,0 %;
macro cwpsacb$w_spare1 = 74,0,16,0 %;
macro cwpsacb$l_spare2 = 76,0,32,0 %;   !  trojan PCB should be octaword aligned
macro cwpsacb$b_trojan_pcb = 80,0,8,0 %; !  start of false PCB
! 
!  The CWPSSQH$ structure is a local structure.  If modified, you do not need
!  to take mixed-version operation into account, however you must be sure that
!  all modules and images which reference the structure are updated together.
! 
literal cwpssqh$k_length = 32;          !  length of data structure
literal cwpssqh$S_$cwpssqhdef = 32;     !  Old size name - synonym
literal cwpssqh$S_cwpssqh = 32;
macro cwpssqh$l_flink = 0,0,32,1 %;     !  forward link
macro cwpssqh$l_blink = 4,0,32,1 %;     !  back link
macro cwpssqh$w_size = 8,0,16,0 %;      !  size of structure (SQH only)
macro cwpssqh$b_type = 10,0,8,0 %;      !  structure type code
macro cwpssqh$b_subtype = 11,0,8,0 %;   !  structure subtype
macro cwpssqh$l_alloc_length = 12,0,32,0 %; !  actual length of allocation
macro cwpssqh$l_mpid = 16,0,32,0 %;     !  master pid
macro cwpssqh$l_spare0 = 20,0,32,0 %;   !  enough to make it octaword
macro cwpssqh$l_spare1 = 24,0,32,0 %;   !  aligned...
macro cwpssqh$l_spare3 = 28,0,32,0 %;
! 
!  The CWPSNODI*$ structures are local structures.  If modified, you do not need
!  to take mixed-version operation into account, however you must be sure that
!  all modules and images which reference the structures are updated together.
! 
literal cwpsnodih$k_header = 16;        !  length of data structure
literal cwpsnodih$S_$cwpsnodihdef = 17; !  Old size name - synonym
literal cwpsnodih$S_cwpsnodih = 17;
macro cwpsnodih$l_flink = 0,0,32,1 %;   !  forward link
macro cwpsnodih$l_blink = 4,0,32,1 %;   !  back link
macro cwpsnodih$w_size = 8,0,16,0 %;    !  size of structure
macro cwpsnodih$b_type = 10,0,8,0 %;    !  structure type code
macro cwpsnodih$b_subtype = 11,0,8,0 %; !  structure subtype
macro cwpsnodih$l_count = 12,0,32,0 %;  !  count of nodes
macro cwpsnodih$b_node_list = 16,0,8,0 %; !  start of list of node blocks
literal cwpsnodi$k_length = 32;         !  length of data structure
literal cwpsnodi$S_$cwpsnodidef = 32;   !  Old size name - synonym
literal cwpsnodi$S_cwpsnodi = 32;
macro cwpsnodi$l_hwtype = 0,0,32,0 %;   !  hardware type (and flink)
macro cwpsnodi$w_hw_model = 4,0,16,0 %; !  integer model code
macro cwpsnodi$l_csid = 8,0,32,0 %;     !  node's csid
macro cwpsnodi$b_name = 12,0,0,0 %;
literal cwpsnodi$s_name = 16;           !  node's name (ASCIC)
macro cwpsnodi$l_sb = 28,0,32,1 %;      !  sb address
 
!*** MODULE $CXBDEF ***
!  +
!   CXB - COMPLEX CHAINED BUFFER
!  
!   THESE OFFSETS ARE USED IN THE HEADER OF DISJOINT SEGMENTS
!   WHICH ARE TO BE PRESENTED TO THE USER AS A UNIT.
!  
!  -
literal CXB$M_RESP = %X'1';
literal CXB$L_NI_ALTXMT = 28;           !  ALTSTART XMT parameters
literal CXB$C_AGENT_SCRATCH_LEN = 44;
!  This marks the length of the standard CXB.
literal CXB$K_LENGTH = 84;
literal CXB$C_LENGTH = 84;
!  Data link layer scratch space
literal CXB$M_FLTR_MCA = %X'1';
literal CXB$M_FLTR_CTL = %X'2';
literal CXB$M_FLTR_SRC = %X'4';
literal CXB$M_FLTR_STARTUP = %X'1';
literal CXB$M_FLTR_INTXMIT = %X'2';
literal CXB$T_R_DATA = 120;             !  Start of RCV data
literal CXB$W_R_LEN_802 = 132;          !  802 length field
literal CXB$T_R_USER_ETH = 134;         !  Start of user ETH data
literal CXB$W_R_SIZE = 134;             !  Size of message if padded
literal CXB$X_R_CTL = 136;              !  802 CTL field
literal CXB$G_R_PID = 137;              !  5-byte Protocol Identifier
literal CXB$T_R_USER_802E = 142;        !  Start of user 802E data
literal CXB$C_DLL = 52;                 !  Size of CXB$T_DLL 
literal CXB$C_DLL_SCRATCH_LEN = 52;     !  Size of CXB$T_DLL 
!  ** This field must be quadword aligned for CNDRIVER.
literal CXB$K_HEADER = 136;             !  CXB size up to this point 
literal CXB$C_HEADER = 136;             !  CXB size up to this point 
literal CXB$C_TRAILER = 4;              !  Space after CXB data for CRC code 
literal CXB$K_OVERHEAD = 140;           !  CXB$C_HEADER + CXB$C_TRAILER 
literal CXB$C_OVERHEAD = 140;           !  CXB$C_HEADER + CXB$C_TRAILER 
literal CXB$S_CXBDEF = 140;             !  Old size name - synonym
literal CXB$S_CXB = 140;
macro CXB$L_FL = 0,0,32,1 %;            !  Forward queue link 
macro CXB$L_BL = 4,0,32,1 %;            !  Backward queue link 
macro CXB$W_SIZE = 8,0,16,0 %;          !  Block size 
macro CXB$B_TYPE = 10,0,8,0 %;          !  Block type 
macro CXB$B_FLAG = 11,0,8,0 %;          !  Flag byte
macro CXB$V_RESP = 11,0,1,0 %;          !   Command/Response indicator
macro CXB$W_BOFF = 12,0,16,0 %;         !  Offset to data link data
macro CXB$W_BCNT = 14,0,16,0 %;         !  Size of data link data
macro CXB$L_DATA_CHAIN = 16,0,32,1 %;   !  Pointer to data chain buffer descriptor
macro CXB$Q_STATION = 20,0,0,0 %;
literal CXB$S_STATION = 8;              !  Contains destination address or source address
macro CXB$W_CTL = 28,0,16,0 %;          !  802.2 ctl field either byte or word value
macro CXB$B_CTL_SIZE = 30,0,8,0 %;      !  802.2 ctl field value size
macro CXB$B_DSAP = 31,0,8,0 %;          !  802.2 ALT/FFI XMT dest sap
macro CXB$Q_RESERVED = 32,0,0,0 %;
literal CXB$S_RESERVED = 8;             !  Reserved for future use
!  Agent specific scratch space.
macro CXB$T_AGENT_SCRATCH = 40,0,0,0 %;
literal CXB$S_AGENT_SCRATCH = 44;
!  DECnet-VAX agent specific fields.
macro CXB$T_AGENT_DECNET = 40,0,0,0 %;
literal CXB$S_AGENT_DECNET = 44;
macro CXB$W_LENGTH = 40,0,16,0 %;       !  Length of data 
macro CXB$W_OFFSET = 42,0,16,0 %;       !  Offset to start of nsp message 
macro CXB$B_CODE = 44,0,8,0 %;          !  Buffer code 
macro CXB$B_STS = 45,0,8,0 %;           !  Status fields
macro CXB$W_CHANNEL = 46,0,16,0 %;      !  Store channel number for AST 
macro CXB$L_LINK = 48,0,32,1 %;         !  Link word for chained data message 
macro CXB$L_IRP = 52,0,32,1 %;          !  IRP address for transmits 
macro CXB$L_END_ACTION = 56,0,32,1 %;   !  Pointer to I/O done routine
!  The following fields contain the context that NSP needs to process a packet
!  which has been received out of order.
macro CXB$L_R_NSP_MSG = 60,0,32,1 %;    !  This is the address of the next
!  byte in the NSP message after
!  the segment number field (R1)
macro CXB$L_R_DATA_SIZE = 64,0,32,0 %;  !  This is the number of as yet
!  unaccounted bytes in message (R2)
macro CXB$W_R_SEG_NUM = 68,0,16,0 %;    !  This is the messages segment number (R3)
!   Backlink pointer for NSP to associate the CXB with the user's originating
!   IRP.  The non-agent specific field, CXB$L_IRP, cannot be used because the
!   datalink drivers use this field for the same purpose, but different IRP.
!   The datalink's IRP is the DECnet routing supplied IRP queued to the 
!   altstart interface.
macro CXB$L_USER_IRP = 70,0,32,1 %;     !  link to user's IRP
macro CXB$L_LAST_DCB = 74,0,32,1 %;     !  pointer to last DCB
!  Size of the agent scratch area 
macro CXB$T_DLL = 84,0,0,0 %;
literal CXB$S_DLL = 52;
!  The following three structures define the fields used by the
!  Ethernet/802 datalink drivers.
macro CXB$T_DLL_NI802 = 84,0,0,0 %;
literal CXB$S_DLL_NI802 = 52;
macro CXB$B_NI_FUNC = 84,0,8,0 %;       !  Internal function code
macro CXB$B_R_FLAGS = 85,0,8,0 %;       !  Flags
macro CXB$W_NI_RID = 86,0,16,0 %;       !  Request ID
macro CXB$B_NI_SLOT = 86,0,8,0 %;       !  Mapping slot number
macro CXB$B_NI_RING = 87,0,8,0 %;       !  Ring Entry number
macro CXB$L_T_IRP = 88,0,32,1 %;        !  User IRP address
macro CXB$W_R_NCHAIN = 92,0,16,0 %;     !  Number of buffers in chain
macro CXB$W_R_LENERR = 94,0,16,0 %;     !  Length and Rcv error status
macro CXB$L_R_UCB = 96,0,32,1 %;        !  UCB address of receiver
macro CXB$W_HDR_SIZE = 100,0,16,0 %;    !  Size of receive header
macro CXB$B_R_FMT = 102,0,8,0 %;        !  Receive packet format
macro CXB$r_filter = 103,0,8,0 %;
literal CXB$s_filter = 1;
macro CXB$B_R_FILTER = 103,0,8,0 %;     !  Receive CXB filtering mask word
macro CXB$V_FLTR_MCA = 103,0,1,0 %;     !  MCA filtering has been performed
macro CXB$V_FLTR_CTL = 103,1,1,0 %;     !  CTL filtering has been performed
macro CXB$V_FLTR_SRC = 103,2,1,0 %;     !  SRC filtering has been performed
macro CXB$B_T_FILTER = 103,0,8,0 %;     !  Transmit CXB filtering mask word
macro CXB$V_FLTR_STARTUP = 103,0,1,0 %; !  Delete CXB, complete IRP
macro CXB$V_FLTR_INTXMIT = 103,1,1,0 %; !  Add CXB to Receive list
macro CXB$T_DLL_NI802XMT = 84,0,0,0 %;
literal CXB$S_DLL_NI802XMT = 52;
macro CXB$T_T_DATA = 122,0,0,0 %;
literal CXB$S_T_DATA = 14;              !  Start of standard XMT
macro CXB$T_DLL_NI802RCV = 84,0,0,0 %;
literal CXB$S_DLL_NI802RCV = 52;
macro CXB$G_R_DEST = 120,0,0,0 %;
literal CXB$S_R_DEST = 6;               !  Destination address
macro CXB$G_R_SRC = 126,0,0,0 %;
literal CXB$S_R_SRC = 6;                !  Source address
macro CXB$W_R_PTYPE = 132,0,16,0 %;     !  Protocol type
macro CXB$B_R_DSAP = 134,0,8,0 %;       !  802 DSAP field
macro CXB$B_R_SSAP = 135,0,8,0 %;       !  802 SSAP field
!  the CRC trailer
 
!*** MODULE $DALDEF ***
! +
!  DAL - Device Allocation Lock (value block contents)
! 
!  This structure defines the contents of the lock value block for a 
!  device allocation lock.
! -
literal DAL$M_NOTFIRST_MNT = %X'1';
literal DAL$M_FOREIGN = %X'2';
literal DAL$M_GROUP = %X'4';
literal DAL$M_SYSTEM = %X'8';
literal DAL$M_WRITE = %X'10';
literal DAL$M_NOQUOTA = %X'20';
literal DAL$M_OVR_PROT = %X'40';
literal DAL$M_OVR_OWNUIC = %X'80';
literal DAL$M_NOINTERLOCK = %X'100';
literal DAL$M_SHADOW_MBR = %X'200';
literal DAL$S_DALDEF = 10;
literal DAL$S_DAL = 10;
macro DAL$W_FLAGS = 0,0,16,0 %;         !  Device usage flags:
macro DAL$V_NOTFIRST_MNT = 0,0,1,0 %;   !    not first time device mounted.
macro DAL$V_FOREIGN = 0,1,1,0 %;        !    device mounted /FOREIGN
macro DAL$V_GROUP = 0,2,1,0 %;          !    device mounted /GROUP
macro DAL$V_SYSTEM = 0,3,1,0 %;         !    device mounted /SYSTEM
macro DAL$V_WRITE = 0,4,1,0 %;          !    write access allowed
macro DAL$V_NOQUOTA = 0,5,1,0 %;        !    quota checking disabled
macro DAL$V_OVR_PROT = 0,6,1,0 %;       !    override protection
macro DAL$V_OVR_OWNUIC = 0,7,1,0 %;     !    override volume ownership
macro DAL$V_NOINTERLOCK = 0,8,1,0 %;    !    access NOT VAXcluster interlocked
macro DAL$V_SHADOW_MBR = 0,9,1,0 %;     !    shadow set member
macro DAL$W_PROTECTION = 2,0,16,0 %;    !  Volume protection
macro DAL$L_OWNER_UIC = 4,0,32,0 %;     !  Volume owner UIC
macro DAL$W_FIRST_MOUNTER_GROUP = 8,0,16,0 %; !  UIC group of first mounter
 
!*** MODULE $DCBDEF ***
!  +
!   DCB - Data link layer chained buffer descriptor
!  
!   This descriptor may be used in one of two ways. The first way is to 
!   use this descriptor to describe a direct I/O transfer. The second 
!   is to use this descriptor to describe a chain of buffers to transmit
!   or a chain of buffers which have been received.
!  
!  -
literal DCB$M_TYPE_IO = %X'1';
literal DCB$K_HEADER = 32;              !  DCB size up to this point 
literal DCB$C_HEADER = 32;              !  DCB size up to this point 
literal DCB$S_DCBDEF = 32;
literal DCB$S_DCB = 32;
macro DCB$L_FLINK = 0,0,32,1 %;         !  Forward link
macro DCB$L_BLINK = 4,0,32,1 %;         !  Backward link
macro DCB$W_SIZE = 8,0,16,0 %;          !  Size of block
macro DCB$B_TYPE = 10,0,8,0 %;          !  Type of block
macro DCB$B_MODE = 11,0,8,0 %;          !  Access mode of agent
macro DCB$L_LINK = 12,0,32,1 %;         !  Link to next buffer in chain
macro DCB$W_STS = 16,0,16,0 %;          !  Old word width STS field 
macro DCB$L_STS = 16,0,32,0 %;
macro DCB$V_TYPE_IO = 16,0,1,0 %;       !  If set DIRECT if clear buffered
macro DCB$L_SVAPTE = 20,0,32,1 %;       !  SVAPTE of buffer if not specified
!  then the buffer is embedded 
!  in this buffer
macro DCB$W_BOFF = 24,0,16,0 %;         !  Offset to start of data. Data
macro DCB$L_BOFF = 24,0,32,0 %;         !  link headers must be back built
!  from this offset.
macro DCB$W_BCNT = 28,0,16,0 %;         !  segment of the data. For receives
macro DCB$L_BCNT = 28,0,32,0 %;         !  contains the size of the segment
!  of data contained in this buffer.
 
!*** MODULE $DDBDEF ***
! +
!  DDB - DEVICE DATA BLOCK
! 
!  THERE IS ONE DEVICE DATA BLOCK FOR EACH CONTROLLER IN A SYSTEM.
! +
literal DDB$M_NO_TIMEOUT = %X'1';
literal DDB$K_PACK = 1;                 ! LARGE DISK PACKS 
literal DDB$K_CART = 2;                 ! DISK CARTRIDGES 
literal DDB$K_SLOW = 3;                 ! SLOW (CHEAP) DISKS (E.G., FLOPPY) 
literal DDB$K_TAPE = 4;                 ! BLOCK STRUCTURED TAPE (E.G., TU58) 
literal DDB$S_DDB = 64;
macro DDB$L_LINK = 0,0,32,1 %;          ! ADDRESS OF NEXT DDB IN LIST (0=LAST) 
macro DDB$PS_LINK = 0,0,32,1 %;         ! ADDRESS OF NEXT DDB IN LIST (0=LAST) 
macro DDB$L_UCB = 4,0,32,1 %;           ! ADDRESS OF FIRST UCB FOR THIS DDB 
macro DDB$PS_UCB = 4,0,32,1 %;          ! ADDRESS OF FIRST UCB FOR THIS DDB 
macro DDB$W_SIZE = 8,0,16,0 %;          ! SIZE OF DDB IN BYTES 
macro DDB$IW_SIZE = 8,0,16,0 %;         ! SIZE OF DDB IN BYTES 
macro DDB$B_TYPE = 10,0,8,0 %;          ! TYPE OF DATA STRUCTURE FOR DDB 
macro DDB$IB_TYPE = 10,0,8,0 %;         ! TYPE OF DATA STRUCTURE FOR DDB 
macro DDB$B_FLAGS = 11,0,8,0 %;
macro DDB$V_NO_TIMEOUT = 11,0,1,0 %;    !  No TIMEOUT handling
macro DDB$L_DDT = 12,0,32,1 %;          ! ADDRESS OF THE DRIVER DISPATCH TABLE 
macro DDB$PS_DDT = 12,0,32,1 %;         ! ADDRESS OF THE DRIVER DISPATCH TABLE 
macro DDB$L_ACPD = 16,0,32,0 %;         ! NAME OF DEFAULT ACP FOR DEVICE UNITS
macro DDB$IL_ACPD = 16,0,32,0 %;        ! NAME OF DEFAULT ACP FOR DEVICE UNITS
macro DDB$B_ACPCLASS = 19,0,8,0 %;      ! CLASS CODE OF DEFAULT ACP 
macro DDB$IB_ACPCLASS = 19,0,8,0 %;     ! CLASS CODE OF DEFAULT ACP 
macro DDB$T_NAME = 20,0,0,0 %;
literal DDB$S_NAME = 16;                ! GENERIC PATH NAME OF DEVICE 
macro DDB$B_NAME_LEN = 20,0,8,0 %;      !  	CHARACTER COUNT
macro DDB$IB_NAME_LEN = 20,0,8,0 %;     !  	CHARACTER COUNT
macro DDB$T_NAME_STR = 21,0,0,0 %;
literal DDB$S_NAME_STR = 15;            !  	CHARACTER STRING
macro DDB$PS_DPT = 36,0,32,1 %;         ! ADDR OF DRIVER DPT
macro DDB$PS_DRVLINK = 40,0,32,1 %;     ! ADDR OF NEXT DDB FOR THIS DRIVER
macro DDB$L_SB = 44,0,32,1 %;           ! ADDR OF SYSTEMBLOCK
macro DDB$PS_SB = 44,0,32,1 %;          ! ADDR OF SYSTEMBLOCK
macro DDB$L_CONLINK = 48,0,32,1 %;      ! NEXT DDB IN CONNECTION SUB-CHAIN
macro DDB$PS_CONLINK = 48,0,32,1 %;     ! NEXT DDB IN CONNECTION SUB-CHAIN
macro DDB$L_ALLOCLS = 52,0,32,0 %;      ! DEVICE ALLOCATION CLASS
macro DDB$IL_ALLOCLS = 52,0,32,0 %;     ! DEVICE ALLOCATION CLASS
macro DDB$L_2P_UCB = 56,0,32,1 %;       ! ADDRESS OF FIRST UCB ON SECONDARY PATH
macro DDB$PS_2P_UCB = 56,0,32,1 %;      ! ADDRESS OF FIRST UCB ON SECONDARY PATH
macro DDB$L_DP_UCB = 56,0,32,1 %;       ! OLD STYLE SYNONYM FOR ABOVE
literal DDB$K_LENGTH = 64;              ! LENGTH OF STANDARD DDB 
literal DDB$C_LENGTH = 64;              ! LENGTH OF STANDARD DDB 
literal DDB$S_DDBDEF = 64;              ! OLD DDB SIZE FOR COMPATIBILITY
 
!*** MODULE $DDTDEF ***
! +
!  DDT - DRIVER DISPATCH TABLE
! 
!  EACH DEVICE DRIVER HAS A DRIVER DISPATCH TABLE.
! -
literal DDT$S_DDT = 112;
macro DDT$IW_SIZE = 8,0,16,1 %;         ! Structure size
macro DDT$W_DIAGBUF = 12,0,16,0 %;      ! SIZE OF DIAGNOSTIC BUFFER IN BYTES 
macro DDT$IW_DIAGBUF = 12,0,16,0 %;     ! SIZE OF DIAGNOSTIC BUFFER IN BYTES 
macro DDT$W_ERRORBUF = 14,0,16,0 %;     ! SIZE OF ERROR LOG BUFFER IN BYTES 
macro DDT$IW_ERRORBUF = 14,0,16,0 %;    ! SIZE OF ERROR LOG BUFFER IN BYTES 
macro DDT$W_FDTSIZE = 16,0,16,0 %;      ! SIZE OF FDT IN BYTES 
macro DDT$IW_FDTSIZE = 16,0,16,0 %;     ! SIZE OF FDT IN BYTES 
macro DDT$PS_START_2 = 20,0,32,1 %;     ! STEP 2 DRIVER START I/O ROUTINE 
macro DDT$PS_START_JSB = 24,0,32,1 %;   ! STEP 2 DRIVER JSB_START I/O ROUTINE 
macro DDT$PS_CTRLINIT_2 = 28,0,32,1 %;  ! STEP 2 CONTROLLER INITIALIZATION ROUTINE
macro DDT$PS_UNITINIT_2 = 32,0,32,1 %;  ! STEP 2 UNIT INITIALIZATION ROUTINE
macro DDT$PS_CLONEDUCB_2 = 36,0,32,1 %; ! STEP 2 CLONED UCB ROUTINE
macro DDT$PS_FDT_2 = 40,0,32,1 %;       ! ADDR OF STEP 2 FUNCTION DECISION TABLE
macro DDT$PS_CANCEL_2 = 44,0,32,1 %;    ! STEP 2 CANCEL I/O ROUTINE
macro DDT$PS_REGDUMP_2 = 48,0,32,1 %;   ! STEP 2 DEVICE REGISTER DUMP ROUTINE
macro DDT$PS_ALTSTART_2 = 52,0,32,1 %;  ! STEP 2 ALTERNATE START I/O ROUTINE
macro DDT$PS_ALTSTART_JSB = 56,0,32,1 %; ! STEP 2 JSB ALTERNATE START I/O ROUTINE
macro DDT$PS_MNTVER_2 = 60,0,32,1 %;    ! STEP 2 MOUNT VERIFICATION ROUTINE
macro DDT$L_MNTV_SSSC = 64,0,32,1 %;    ! ADDRESS OF SHADOW SET STATE CHANGE MV ENTRY
macro DDT$PS_MNTV_SSSC = 64,0,32,1 %;   ! ADDRESS OF SHADOW SET STATE CHANGE MV ENTRY
macro DDT$L_MNTV_FOR = 68,0,32,1 %;     ! ADDRESS OF FOREIGN DEVICE MV ENTRY
macro DDT$PS_MNTV_FOR = 68,0,32,1 %;    ! ADDRESS OF FOREIGN DEVICE MV ENTRY
macro DDT$L_MNTV_SQD = 72,0,32,1 %;     ! ADDRESS OF SEQUENTIAL DEVICE MV ENTRY
macro DDT$PS_MNTV_SQD = 72,0,32,1 %;    ! ADDRESS OF SEQUENTIAL DEVICE MV ENTRY
macro DDT$L_AUX_STORAGE = 76,0,32,1 %;  ! ADDRESS OF AUXILIARY STORAGE AREA
macro DDT$PS_AUX_STORAGE = 76,0,32,1 %; ! ADDRESS OF AUXILIARY STORAGE AREA
macro DDT$L_AUX_ROUTINE = 80,0,32,1 %;  ! ADDRESS OF AUXILIARY ROUTINE
macro DDT$PS_AUX_ROUTINE = 80,0,32,1 %; ! ADDRESS OF AUXILIARY ROUTINE
macro DDT$PS_CHANNEL_ASSIGN_2 = 84,0,32,1 %; ! STEP 2 ROUTINE TO CALL FROM $ASSIGN
macro DDT$PS_CANCEL_SELECTIVE_2 = 88,0,32,1 %; ! STEP 2 SELECTIVE CANCEL I/O ROUTINE
macro DDT$IS_STACK_BCNT = 92,0,32,0 %;  ! BYTES OF KP STACK REQUIRED
macro DDT$IS_REG_MASK = 96,0,32,0 %;    ! KP REGISTER SAVE MASK
macro DDT$PS_KP_STARTIO = 100,0,32,1 %; ! ADDRESS OF KERNEL PROCESS START I/O ROUTINE
macro DDT$PS_CSR_MAPPING = 104,0,32,1 %; ! ADDRESS OF CSR MAPPING ROUTINE
macro DDT$PS_CUSTOMER = 108,0,32,1 %;   ! Reserved_to_customer pointer
literal DDT$K_LENGTH = 112;             ! LENGTH OF DDT 
literal DDT$C_LENGTH = 112;             ! LENGTH OF DDT 
literal DDT$S_DDTDEF = 112;             ! OLD DDT LENGTH NAME FOR COMPATIBILITY
 
!*** MODULE $DEADEF ***
! 
!  Define the layout of the Deaccess Audit Pending block.  This record is
!  used to store the information necessary to write a deaccess audit event
!  upon object deaccess.  These records are queued off a per-process queue
!  (NSA$GQ_DEACCESS_AUDIT) and managed by NSA$QUEUE_DEACCESS_AUDIT, 
!  NSA$DEACCESS_AUDIT, and $DELPRC.
! 
literal DEA$K_LENGTH = 48;
!  Define flags used by the NSA$DEACCESS_AUDIT routine.
literal DEA$K_FLUSH_ALL = 1;            !  flush all DEAs
literal DEA$K_FLUSH_BY_OCB = 2;         !  flush all DEAs by object class
literal DEA$S_DEA = 48;
macro DEA$L_FLINK = 0,0,32,1 %;         !  FLINK
macro DEA$L_BLINK = 4,0,32,1 %;         !  BLINK
macro DEA$L_SIZE = 8,0,32,0 %;          !  size of DEA record
macro DEA$L_TYPE = 12,0,32,0 %;         !  type of structure (DYN$C_DEA)
macro DEA$L_FLAGS = 16,0,32,0 %;        !  flags (unused)
macro DEA$L_DEACCESS_KEY = 20,0,32,0 %; !  deaccess audit key
macro DEA$L_AUDIT_MASK = 24,0,32,0 %;   !  alarm/audit mask
macro DEA$L_OCB = 28,0,32,1 %;          !  OCB address
macro DEA$L_ALARM_SIZE = 32,0,32,0 %;   !  size of alarm string
macro DEA$L_AUDIT_SIZE = 36,0,32,0 %;   !  size of audit string
macro DEA$L_ALARM = 40,0,32,1 %;        !  alarm string address
macro DEA$L_AUDIT = 44,0,32,1 %;        !  audit string address
 
!*** MODULE $DJIDEF ***
! 
!  Item codes for interface from job controller to LOGINOUT.
! 
literal DJI$K_CPU_MAXIMUM = 1;          !  (longword)	CPU maximum (10 ms units)
literal DJI$K_FILE_IDENTIFICATION = 2;  !  (28 bytes)	DVI, FID, DID of command procedure
literal DJI$K_FLAGS = 3;                !  (longword)	flags
literal DJI$K_JOB_NAME = 4;             !  (string)	job name
literal DJI$K_LOG_QUEUE = 5;            !  (string)	log file queue
literal DJI$K_LOG_SPECIFICATION = 6;    !  (string)	log file specification
literal DJI$K_PARAMETER_1 = 7;          !  (string)	value of P1
literal DJI$K_PARAMETER_2 = 8;          !  (string)	value of P2
literal DJI$K_PARAMETER_3 = 9;          !  (string)	value of P3
literal DJI$K_PARAMETER_4 = 10;         !  (string)	value of P4
literal DJI$K_PARAMETER_5 = 11;         !  (string)	value of P5
literal DJI$K_PARAMETER_6 = 12;         !  (string)	value of P6
literal DJI$K_PARAMETER_7 = 13;         !  (string)	value of P7
literal DJI$K_PARAMETER_8 = 14;         !  (string)	value of P8
literal DJI$K_RESTART = 15;             !  (string)	value of BATCH$RESTART
literal DJI$K_USERNAME = 16;            !  (string)	username
literal DJI$K_WSDEFAULT = 17;           !  (longword)	working set default
literal DJI$K_WSEXTENT = 18;            !  (longword)	working set extent
literal DJI$K_WSQUOTA = 19;             !  (longword)	working set quota
literal DJI$K_ADJUST_PRIORITY = 20;     !  (longword)   adjusted priority
literal DJI$K_CLI = 21;                 !  (string)	CLI name
literal DJI$K_CLASS = 22;               !  (20 bytes)	process classification
literal DJI$K_NOTE = 23;                !  (string)	the job's note
literal DJI$K_CHARGE_CODE_NAME = 24;    !  (string)	account or charge code name
literal DJI$K_INPUT_FLAGS = 32769;      !  (longword)	flags
literal DJI$K_CONDITION_VECTOR = 32770; !  (1 to 3 longwords) error conditions
literal DJI$K_FILE_SPECIFICATION = 32771; !  (string)	filespec of failed logfile
literal DJI$S_DJI_ITEM_HEADER = 4;
macro DJI$W_ITEM_SIZE = 0,0,16,0 %;     !  Item size
macro DJI$W_ITEM_CODE = 2,0,16,0 %;     !  Item code
literal DJI$S_ITEM_HEADER = 4;          !  Size (using prior aggregate name)
! 
!  Structure of FLAGS item.
! 
literal DJI$M_DELETE_FILE = %X'1';
literal DJI$M_LOG_DELETE = %X'2';
literal DJI$M_LOG_NULL = %X'4';
literal DJI$M_LOG_SPOOL = %X'8';
literal DJI$M_NOTIFY = %X'10';
literal DJI$M_RESTARTING = %X'20';
literal DJI$M_TERMINATE = %X'40';
literal DJI$M_USE_CPU_MAXIMUM = %X'80';
literal DJI$M_USE_WSDEFAULT = %X'100';
literal DJI$M_USE_WSEXTENT = %X'200';
literal DJI$M_USE_WSQUOTA = %X'400';
literal DJI$S_FLAGS = 4;                !  Old size name synonym
literal DJI$S_DJI_FLAGS = 4;
macro DJI$L_FLAGS = 0,0,32,0 %;
macro DJI$V_DELETE_FILE = 0,0,1,0 %;    !  delete command procedure
macro DJI$V_LOG_DELETE = 0,1,1,0 %;     !  delete log file
macro DJI$V_LOG_NULL = 0,2,1,0 %;       !  log specification is NLA0:
macro DJI$V_LOG_SPOOL = 0,3,1,0 %;      !  spool log file
macro DJI$V_NOTIFY = 0,4,1,0 %;         !  spool log file with /NOTIFY
macro DJI$V_RESTARTING = 0,5,1,0 %;     !  job is restarting
macro DJI$V_TERMINATE = 0,6,1,0 %;      !  job should terminate
macro DJI$V_USE_CPU_MAXIMUM = 0,7,1,0 %; !  use specified CPU_MAXIMUM
macro DJI$V_USE_WSDEFAULT = 0,8,1,0 %;  !  use specified WSDEFAULT
macro DJI$V_USE_WSEXTENT = 0,9,1,0 %;   !  use specified WSEXTENT
macro DJI$V_USE_WSQUOTA = 0,10,1,0 %;   !  use specified WSQUOTA
! 
!  Structure of INPUT_FLAGS item.
! 
literal DJI$M_NO_FILE = %X'1';
literal DJI$S_INPUT_FLAGS = 4;          !  Old size name synonym
literal DJI$S_DJI_INPUT_FLAGS = 4;
macro DJI$L_INPUT_FLAGS = 0,0,32,0 %;
macro DJI$V_NO_FILE = 0,0,1,0 %;        !  do not return a file
 
!*** MODULE $DMBDEF ***
! +
!  DMB32 (BICOMBO) specific register definitions
! -
literal DMB$M_FORCE_FAIL = %X'1';
literal DMB$M_PROGRAM_RESET = %X'2';
literal DMB$M_PTE_VALID = %X'4';
literal DMB$M_SKIP_SELFTEST = %X'8';
literal DMB$M_MAINT_LEVEL1 = %X'10';
literal DMB$M_MAINT_LEVEL2 = %X'20';
literal DMB$M_SYNC = %X'100';
literal DMB$M_ASYNC = %X'200';
literal DMB$M_PRINT = %X'400';
literal DMB$M_DIAG_FAIL = %X'800';
literal DMB$M_X21_SUPPORT = %X'1000';
literal DMB$M_CABLE_KEY = %X'2000';
literal DMB$M_TURN_CONN = %X'4000';
literal DMB$M_MANF_CONN = %X'8000';
literal DMB$M_RX_I_E = %X'100';
literal DMB$M_TX_I_E = %X'200';
literal DMB$M_SYNC_I_E = %X'800';
literal DMB$M_PR_I_E = %X'800';
literal DMB$M_PR_DAVFU_READY = %X'10000';
literal DMB$M_PR_CONNECT_VERIFY = %X'20000';
literal DMB$M_PR_OFFLINE = %X'40000';
literal DMB$M_ASYNC_RESET = %X'400';
literal DMB$M_SYNC_RESET = %X'400';
literal DMB$M_PRINTER_RESET = %X'400';
literal DMB$M_PR_DMA_START = %X'1';
literal DMB$M_PR_DMA_PTE = %X'2';
literal DMB$M_PR_DMA_PHYS = %X'4';
literal DMB$M_PR_DMA_ABORT = %X'100';
literal DMB$M_PR_FORMAT = %X'200';
literal DMB$M_PR_TAB = %X'1000000';
literal DMB$M_PR_TRUNC = %X'2000000';
literal DMB$M_PR_AUTO_RETURN = %X'4000000';
literal DMB$M_PR_AUTO_FORM = %X'8000000';
literal DMB$M_PR_NON_PRINT = %X'10000000';
literal DMB$M_PR_DAVFU = %X'20000000';
literal DMB$M_PR_WRAP = %X'40000000';
literal DMB$M_PR_UPPER = %X'80000000';
literal DMB$M_TX1_DMA_START = %X'1';
literal DMB$M_TX1_DMA_PTE = %X'2';
literal DMB$M_TX1_DMA_PHYS = %X'4';
literal DMB$M_TX1_X21 = %X'8';
literal DMB$M_TX1_PAR = %X'10';
literal DMB$M_TX1_DMA_ABORT = %X'100';
literal DMB$M_RX1_DMA_START = %X'1';
literal DMB$M_RX1_DMA_PTE = %X'2';
literal DMB$M_RX1_DMA_PHYS = %X'4';
literal DMB$M_RX1_X21 = %X'8';
literal DMB$M_RX1_DMA_ABORT = %X'100';
literal DMB$M_RX_ENABLE = %X'1';
literal DMB$M_RX_MATCH_ENA = %X'4';
literal DMB$M_RX_PRIMARY = %X'8';
literal DMB$M_X21ENABLE = %X'10';
literal DMB$M_CLOCK_CONTROL = %X'40';
literal DMB$M_CODING_TYPE = %X'80';
literal DMB$M_BAUD_RATE = %X'F00';
literal DMB$M_LOOP = %X'1000';
literal DMB$M_V35_SELECT = %X'2000';
literal DMB$M_V10_SELECT = %X'4000';
literal DMB$M_MODEM_SUPPRESS = %X'8000';
literal DMB$M_LINE_RESET = %X'80000000';
literal DMB$M_SYNC_ML1 = %X'1';
literal DMB$M_SYNC_DTR = %X'2';
literal DMB$M_SYNC_DRS = %X'4';
literal DMB$M_SYNC_ML2 = %X'8';
literal DMB$M_SYNC_RTS = %X'10';
literal DMB$M_SPARE_MODEM = %X'E0';
literal DMB$M_SYNC_RXCLOCK = %X'100';
literal DMB$M_SYNC_TXCLOCK = %X'200';
literal DMB$M_SYNC_TI = %X'400';
literal DMB$M_SYNC_CTS = %X'1000';
literal DMB$M_SYNC_DCD = %X'2000';
literal DMB$M_SYNC_RI = %X'4000';
literal DMB$M_SYNC_DSR = %X'8000';
literal DMB$M_PROTOCOL = %X'70000';
literal DMB$C_PRO_DDCMP = 0;
literal DMB$C_PRO_SDLC = 1;
literal DMB$C_PRO_HDLC = 2;
literal DMB$C_PRO_BISYNC = 3;
literal DMB$C_PRO_GENBYTE = 7;
literal DMB$M_ERROR_TYPE = %X'380000';
literal DMB$C_ERR_CRC1 = 0;
literal DMB$C_ERR_CRC0 = 1;
literal DMB$C_ERR_LVE = 2;
literal DMB$C_ERR_CRC16 = 3;
literal DMB$C_ERR_LRC0 = 4;
literal DMB$C_ERR_LRCE = 5;
literal DMB$C_ERR_LVO = 6;
literal DMB$C_NOCON = 7;
literal DMB$M_RX_BPC = %X'1C00000';
literal DMB$M_TX_BPC = %X'E000000';
literal DMB$M_STRIP_SYNC = %X'10000000';
literal DMB$M_EBCDIC_CODE = %X'20000000';
literal DMB$M_IDLE_SYNC = %X'40000000';
literal DMB$M_MODEM_OVERRIDE = %X'80000000';
literal DMB$M_TX2_DMA_START = %X'1';
literal DMB$M_TX2_DMA_PTE = %X'2';
literal DMB$M_TX2_DMA_PHYS = %X'4';
literal DMB$M_TX2_X21 = %X'8';
literal DMB$M_TX2_PAR = %X'10';
literal DMB$M_TX2_DMA_ABORT = %X'100';
literal DMB$M_RX2_DMA_START = %X'1';
literal DMB$M_RX2_DMA_PTE = %X'2';
literal DMB$M_RX2_DMA_PHYS = %X'4';
literal DMB$M_RX2_X21 = %X'8';
literal DMB$M_RX2_DMA_ABORT = %X'100';
literal DMB$M_SYNC_CABLE = %X'F000000';
literal DMB$M_SYNC_LOOP = %X'20000000';
literal DMB$M_SYNC_VALID = %X'40000000';
literal DMB$M_SYNC_X21 = %X'80000000';
literal DMB$M_PREEMPT_GO = %X'8000';
literal DMB$M_ML = %X'1';
literal DMB$M_DTR = %X'2';
literal DMB$M_DRS = %X'4';
literal DMB$M_RTS = %X'10';
literal DMB$M_TX_INT_DELAY = %X'200';
literal DMB$M_RX_ENA = %X'400';
literal DMB$M_BREAK = %X'800';
literal DMB$M_MAINT = %X'3000';
literal DMB$M_REPORT_MODEM = %X'4000';
literal DMB$M_DISCARD_FLOW = %X'8000';
literal DMB$M_CHAR_LENGTH = %X'30000';
literal DMB$M_PARITY_ENAB = %X'40000';
literal DMB$M_EVEN_PARITY = %X'80000';
literal DMB$M_STOP_CODE = %X'100000';
literal DMB$M_USE_CTS = %X'200000';
literal DMB$M_IAUTO_FLOW = %X'400000';
literal DMB$M_OAUTO_FLOW = %X'800000';
literal DMB$M_RX_SPEED = %X'F000000';
literal DMB$M_TX_SPEED = %X'F0000000';
literal DMB$M_TX_DMA_START = %X'1';
literal DMB$M_TX_DMA_PTE = %X'2';
literal DMB$M_TX_DMA_PHYS = %X'4';
literal DMB$M_TX_OUT_ABORT = %X'100';
literal DMB$M_ML2 = %X'400';
literal DMB$M_CTS = %X'1000';
literal DMB$M_DCD = %X'2000';
literal DMB$M_RI = %X'4000';
literal DMB$M_DSR = %X'8000';
literal DMB$M_SNDOFF = %X'800000';
literal DMB$M_TX_ENA = %X'80000000';
literal DMB$M_TX_PREEMPT = %X'100';
literal DMB$M_TX_FIFO_DONE = %X'200';
literal DMB$M_TX_ACT = %X'80000000';
literal DMB$M_SYNC_MODEM = %X'100';
literal DMB$M_SYNC_TX_ACT = %X'200';
literal DMB$M_SYNC_SECOND_BUFFER = %X'400';
literal DMB$M_PARITY_ERR = %X'1000';
literal DMB$M_FRAME_ERR = %X'2000';
literal DMB$M_OVERRUN_ERR = %X'4000';
literal DMB$M_NON_CHAR = %X'8000';
literal DMB$M_DATA_VALID = %X'80000000';
literal DMB$C_NO_ERROR = 0;
literal DMB$C_DMA_ERROR = 1;
literal DMB$C_MSG_ERROR = 2;
literal DMB$C_LAST_CHAR_ERROR = 3;
literal DMB$C_BUFFER_ERROR = 4;
literal DMB$C_MODEM_ERROR = 5;
literal DMB$C_ABORT_ERROR = 6;
literal DMB$C_X21_ERROR = 7;
literal DMB$C_OFFLINE_ERROR = 8;
literal DMB$C_INTERNAL_ERROR = 9;
literal DMB$C_HEADER_CRC_ERROR = 1;
literal DMB$C_DATA_CRC_ERROR = 2;
literal DMB$C_LENGTH_ERROR = 3;
literal DMB$C_LENGTH_AND_CRC_ERROR = 4;
literal DMB$C_ABORT_CHARACTER_ERROR = 5;
literal DMB$C_INVALID_CHARACTER_ERROR = 6;
literal DMB$C_HOST_ABORT_ERROR = 1;
literal DMB$C_DMB_ABORT_ERROR = 2;
literal DMB$C_RX_OVERRUN_ERROR = 1;
literal DMB$C_TX_UNDERRUN_ERROR = 2;
literal DMB$S_DMBDEF = 528;             !  Old size name - synonym
literal DMB$S_DMB = 528;
macro DMB$L_MAINT = 256,0,32,0 %;       ! Maintenance register
macro DMB$V_FORCE_FAIL = 256,0,1,0 %;   ! Force failure
macro DMB$V_PROGRAM_RESET = 256,1,1,0 %; ! Programmed reset
macro DMB$V_PTE_VALID = 256,2,1,0 %;    ! Page tables valid
macro DMB$V_SKIP_SELFTEST = 256,3,1,0 %; ! Skip self test
macro DMB$V_MAINT_LEVEL1 = 256,4,1,0 %; ! Maintenance level 1
macro DMB$V_MAINT_LEVEL2 = 256,5,1,0 %; ! Maintenance level 2
macro DMB$V_SYNC = 256,8,1,0 %;         ! Sync lines present
macro DMB$V_ASYNC = 256,9,1,0 %;        ! Async lines present
macro DMB$V_PRINT = 256,10,1,0 %;       ! Printer present
macro DMB$V_DIAG_FAIL = 256,11,1,0 %;   ! Diagnostic error
macro DMB$V_X21_SUPPORT = 256,12,1,0 %; ! X21 firmware support present
macro DMB$V_CABLE_KEY = 256,13,1,0 %;   ! Cable key signal present
macro DMB$V_TURN_CONN = 256,14,1,0 %;   ! stag. loopback conn. present
macro DMB$V_MANF_CONN = 256,15,1,0 %;   ! Mfg. loopback conn. present
! 
!  The following 3 registers are the Control Status Registers (CSRs) for
!  the Async, Sync, and Printer ports in that order.
!            
macro DMB$L_ACSR = 260,0,32,0 %;        ! Async Control Status Register
macro DMB$B_ASYNC_IND_ADD = 260,0,8,1 %; ! Indirect Addr. Register Ptr.
macro DMB$V_RX_I_E = 260,8,1,0 %;       ! Receive Interrupt Enable
macro DMB$V_TX_I_E = 260,9,1,0 %;       ! Transmit Interrupt Enable
macro DMB$L_SCSR = 264,0,32,0 %;        ! Sync Control Status Register
macro DMB$B_SYNC_IND_ADD = 264,0,8,1 %; ! Indirect Addr. Register Ptr.
macro DMB$V_SYNC_I_E = 264,11,1,0 %;    ! Sync Interrupt Enable
macro DMB$L_PCSR = 268,0,32,0 %;        ! Printer Control Status Register
macro DMB$V_PR_I_E = 268,11,1,0 %;      ! Printer Interrupt Enable
macro DMB$V_PR_DAVFU_READY = 268,16,1,0 %; ! DAVFU ready
macro DMB$V_PR_CONNECT_VERIFY = 268,17,1,0 %; ! Connect verify
macro DMB$V_PR_OFFLINE = 268,18,1,0 %;  ! Line printer error
! 
!  Configuration of devices on DMB32.
! 
macro DMB$L_CONFIG = 276,0,32,0 %;      ! Device Configuration
macro DMB$B_ASYNC_LINES = 276,0,8,1 %;  ! Number of async lines
macro DMB$B_SYNC_LINES = 277,0,8,1 %;   ! Number of sync lines
macro DMB$B_PRINTER_LINES = 278,0,8,1 %; ! Number of printer ports
! 
!  The following 3 registers are the 2nd Control Status Registers for
!  each of the ports on the DMB32 (Async, Sync, and Printer).
!   	
macro DMB$L_ACSR2 = 280,0,32,1 %;       ! 2ND Async Control Status Register
macro DMB$V_ASYNC_RESET = 280,10,1,0 %; ! Async Port reset
macro DMB$B_RX_TIMER = 282,0,8,1 %;     ! Rcv Interrupt delay timer
macro DMB$L_SCSR2 = 284,0,32,1 %;       ! 2ND Sync Control Status Register
macro DMB$V_SYNC_RESET = 284,10,1,0 %;  ! Sync Port reset
macro DMB$L_PCSR2 = 288,0,32,0 %;       ! 2ND Printer Control Status Register
macro DMB$V_PRINTER_RESET = 288,10,1,0 %; ! Printer Port reset
macro DMBDEF$$_FILL_11 = 292,0,0,1 %;
literal DMBDEFS_FILL_11 = 44;
macro DMB$L_SPTE = 336,0,32,0 %;        ! SPTE system page table register
macro DMB$L_SPTS = 340,0,32,0 %;        ! System page table size register
macro DMB$L_GPTE = 344,0,32,0 %;        ! Global page table register
macro DMB$L_GPTS = 348,0,32,0 %;        ! Global page table size register
! 
!  The following 6 registers are specific to the printer port on the
!  DMB32.
! 
macro DMB$L_PFIX = 352,0,32,0 %;        ! Printer prefix/suffix control
macro DMB$B_PREFIX_COUNT = 352,0,8,1 %; ! Prefix count
macro DMB$B_PREFIX_CHAR = 353,0,8,1 %;  ! Prefix character
macro DMB$B_SUFFIX_COUNT = 354,0,8,1 %; ! Suffix count
macro DMB$B_SUFFIX_CHAR = 355,0,8,1 %;  ! Suffix character
macro DMB$L_PBUFAD = 356,0,32,1 %;      ! Printer Buffer Address            
macro DMB$L_PBUFCT = 360,0,32,0 %;      ! Printer Buffer count/offset
macro DMB$W_PR_BUFF_OFF = 360,0,16,1 %; ! printer buffer offset
macro DMB$W_PR_BUFF_CT = 362,0,16,1 %;  ! transmit DMA char. count
macro DMB$L_PCTRL = 364,0,32,0 %;       ! Printer Control Register
macro DMB$V_PR_DMA_START = 364,0,1,0 %; ! Start a DMA transfer
macro DMB$V_PR_DMA_PTE = 364,1,1,0 %;   ! PTE address
macro DMB$V_PR_DMA_PHYS = 364,2,1,0 %;  ! Physical address
macro DMB$V_PR_DMA_ABORT = 364,8,1,0 %; ! Abort a DMA transfer
macro DMB$V_PR_FORMAT = 364,9,1,0 %;    ! Format control
macro DMB$B_PR_ERROR = 366,0,8,1 %;     ! Error code
macro DMB$V_PR_TAB = 364,24,1,0 %;      ! Tab expansion
macro DMB$V_PR_TRUNC = 364,25,1,0 %;    ! Truncation of Data
macro DMB$V_PR_AUTO_RETURN = 364,26,1,0 %; ! Auto CR insert
macro DMB$V_PR_AUTO_FORM = 364,27,1,0 %; ! Auto FF to LF convert
macro DMB$V_PR_NON_PRINT = 364,28,1,0 %; ! Non printing char. accept
macro DMB$V_PR_DAVFU = 364,29,1,0 %;    ! DAVFU
macro DMB$V_PR_WRAP = 364,30,1,0 %;     ! Line Wrap
macro DMB$V_PR_UPPER = 364,31,1,0 %;    ! Convert to upper case
macro DMB$L_PCAR = 368,0,32,0 %;        ! Printer Carriage Counter
macro DMB$W_PR_LINE = 368,0,16,1 %;     ! Lines printed
macro DMB$W_PR_CHAR = 370,0,16,1 %;     ! Characters transmitted
macro DMB$L_PSIZE = 372,0,32,0 %;       ! Printer page size
macro DMB$W_PR_WIDTH = 372,0,16,1 %;    ! Line Width
macro DMB$W_PR_PAGE = 374,0,16,1 %;     ! Page size
! 
!  The next 16 registers are specific to the SYNC port on the DMB32.
! 
macro DMB$L_TBUFFAD1 = 384,0,32,1 %;    ! Transmit Buffer Address 1
macro DMB$L_TBUFFCT1 = 388,0,32,0 %;    ! Transmit Buffer Count/offset 1
macro DMB$W_TX_BUFF_OFF1 = 388,0,16,1 %; ! Transmit buffer offset
macro DMB$W_TX_CHAR_CT1 = 390,0,16,1 %; ! Transmit DMA character count
macro DMB$L_RBUFFAD1 = 392,0,32,1 %;    ! Receive Buffer Address 1
macro DMB$L_RBUFFCT1 = 396,0,32,0 %;    ! Receive Buffer Count/offset 1
macro DMB$W_RX_BUFF_OFF1 = 396,0,16,1 %; ! Receive buffer offset
macro DMB$W_RX_CHAR_CT1 = 398,0,16,1 %; ! Receive DMA character count
macro DMB$L_TLNCTRL1 = 400,0,32,0 %;    ! Buffer 1 Transmit Control
macro DMB$V_TX1_DMA_START = 400,0,1,0 %; ! Start a DMA transfer
macro DMB$V_TX1_DMA_PTE = 400,1,1,0 %;  ! PTE address
macro DMB$V_TX1_DMA_PHYS = 400,2,1,0 %; ! Physical address
macro DMB$V_TX1_X21 = 400,3,1,0 %;      ! X.21 mode
macro DMB$V_TX1_PAR = 400,4,1,0 %;      ! Parameter change
macro DMB$V_TX1_DMA_ABORT = 400,8,1,0 %; ! Transmitter DMA abort
macro DMB$B_TX1_ERROR = 403,0,8,1 %;    ! Transmitter Error bits
macro DMB$L_RLNCTRL1 = 404,0,32,0 %;    ! Buffer 1 Receive Control
macro DMB$V_RX1_DMA_START = 404,0,1,0 %; ! Start a DMA transfer
macro DMB$V_RX1_DMA_PTE = 404,1,1,0 %;  ! PTE address
macro DMB$V_RX1_DMA_PHYS = 404,2,1,0 %; ! Physical address
macro DMB$V_RX1_X21 = 404,3,1,0 %;      ! X.21 mode
macro DMB$V_RX1_DMA_ABORT = 404,8,1,0 %; ! Receiver DMA abort
macro DMB$B_RX1_ERROR = 407,0,8,1 %;    ! Receiver error bits
macro DMB$L_LPR1 = 408,0,32,0 %;        ! Sync line parameters 1
macro DMB$V_RX_ENABLE = 408,0,1,0 %;    ! Receiver Enable
macro DMB$V_RX_MATCH_ENA = 408,2,1,0 %; ! Receiver Match character enable
macro DMB$V_RX_PRIMARY = 408,3,1,0 %;   ! Primary-Secondary Station
macro DMB$V_X21ENABLE = 408,4,1,0 %;    ! X21 Protocol Enable
macro DMB$V_CLOCK_CONTROL = 408,6,1,0 %; ! Clock control bit
macro DMB$V_CODING_TYPE = 408,7,1,0 %;  ! Data coding type
macro DMB$V_BAUD_RATE = 408,8,4,0 %;
literal DMB$S_BAUD_RATE = 4;            ! Internal B.R. Generator speed
macro DMB$V_LOOP = 408,12,1,0 %;        ! Maintenance Loop back
macro DMB$V_V35_SELECT = 408,13,1,0 %;  ! V.35 select
macro DMB$V_V10_SELECT = 408,14,1,0 %;  ! V.10 select
macro DMB$V_MODEM_SUPPRESS = 408,15,1,0 %; ! Supress modem change ints
macro DMB$B_NUMBER_SYNC = 410,0,8,1 %;  ! Number of sync characters
macro DMB$V_LINE_RESET = 408,31,1,0 %;  ! Line reset request
macro DMB$L_LPR2 = 412,0,32,0 %;        ! Sync line parameters 2
macro DMB$V_SYNC_ML1 = 412,0,1,0 %;     ! Modem loop output
macro DMB$V_SYNC_DTR = 412,1,1,0 %;     ! Data terminal ready output
macro DMB$V_SYNC_DRS = 412,2,1,0 %;     ! Data rate select output
macro DMB$V_SYNC_ML2 = 412,3,1,0 %;     ! 2nd modem loop output
macro DMB$V_SYNC_RTS = 412,4,1,0 %;     ! Request to send output
macro DMB$V_SPARE_MODEM = 412,5,3,0 %;
literal DMB$S_SPARE_MODEM = 3;          ! 
macro DMB$V_SYNC_RXCLOCK = 412,8,1,0 %; ! Receive clock running
macro DMB$V_SYNC_TXCLOCK = 412,9,1,0 %; ! Transmit clock running
macro DMB$V_SYNC_TI = 412,10,1,0 %;     ! Test indicator
macro DMB$V_SYNC_CTS = 412,12,1,0 %;    ! Clear to send input
macro DMB$V_SYNC_DCD = 412,13,1,0 %;    ! Data carrier detect input
macro DMB$V_SYNC_RI = 412,14,1,0 %;     ! Ring indicator input
macro DMB$V_SYNC_DSR = 412,15,1,0 %;    ! Data set ready input
macro DMB$V_PROTOCOL = 412,16,3,0 %;
literal DMB$S_PROTOCOL = 3;             ! Protocol type
macro DMB$V_ERROR_TYPE = 412,19,3,0 %;
literal DMB$S_ERROR_TYPE = 3;
macro DMB$V_RX_BPC = 412,22,3,0 %;
literal DMB$S_RX_BPC = 3;               ! #of receive bits per char.  
macro DMB$V_TX_BPC = 412,25,3,0 %;
literal DMB$S_TX_BPC = 3;               ! # of transmit bits per char.
macro DMB$V_STRIP_SYNC = 412,28,1,0 %;  ! Strip Sync
macro DMB$V_EBCDIC_CODE = 412,29,1,0 %; ! Character code
macro DMB$V_IDLE_SYNC = 412,30,1,0 %;   ! Idle Sync
macro DMB$V_MODEM_OVERRIDE = 412,31,1,0 %; ! Modem control override
macro DMB$L_TBUFFAD2 = 416,0,32,1 %;    ! Transmit Buffer Address 2
macro DMB$L_TBUFFCT2 = 420,0,32,0 %;    ! Transmit Buffer count/offset 1
macro DMB$W_TX_BUFF_OFF2 = 420,0,16,1 %; ! Transmit buffer offset
macro DMB$W_TX_CHAR_CT2 = 422,0,16,1 %; ! Transmit DMA character count
macro DMB$L_RBUFFAD2 = 424,0,32,1 %;    ! Receive Buffer Address 2
macro DMB$L_RBUFFCT2 = 428,0,32,0 %;    ! Receive Buffer count/offset 2
macro DMB$W_RX_BUFF_OFF2 = 428,0,16,1 %; ! Receive buffer offset
macro DMB$W_RX_CHAR_CT2 = 430,0,16,1 %; ! Receive DMA character count
macro DMB$L_TLNCTRL2 = 432,0,32,0 %;    ! Buffer 2 Transmit Control
macro DMB$V_TX2_DMA_START = 432,0,1,0 %; ! Start a DMA transfer
macro DMB$V_TX2_DMA_PTE = 432,1,1,0 %;  ! PTE address
macro DMB$V_TX2_DMA_PHYS = 432,2,1,0 %; ! Physical address
macro DMB$V_TX2_X21 = 432,3,1,0 %;      ! X.21 mode
macro DMB$V_TX2_PAR = 432,4,1,0 %;      ! Parameter change
macro DMB$V_TX2_DMA_ABORT = 432,8,1,0 %; ! Transmitter DMA abort
macro DMB$B_TX2_ERROR = 435,0,8,1 %;    ! Transmitter error bits
macro DMB$L_RLNCTRL2 = 436,0,32,0 %;    ! Buffer 2 Receive control
macro DMB$V_RX2_DMA_START = 436,0,1,0 %; ! Start a DMA transfer
macro DMB$V_RX2_DMA_PTE = 436,1,1,0 %;  ! PTE address
macro DMB$V_RX2_DMA_PHYS = 436,2,1,0 %; ! Physical address
macro DMB$V_RX2_X21 = 436,3,1,0 %;      ! X.21 mode
macro DMB$V_RX2_DMA_ABORT = 436,8,1,0 %; ! Receiver DMA abort
macro DMB$B_RX2_ERROR = 439,0,8,1 %;    ! Receiver error bits
macro DMB$L_LPR3 = 440,0,32,0 %;        ! Sync Line parameters 3
macro DMB$B_SYNC_CHAR = 440,0,8,1 %;    ! Sync character
macro DMB$B_RX_MATCH = 441,0,8,1 %;     ! Receive match character
macro DMB$B_ADDRESS1 = 442,0,8,1 %;     ! First address character
macro DMB$B_ADDRESS2 = 443,0,8,1 %;     ! Second address character
macro DMB$L_BUFCTRL = 444,0,32,0 %;     ! Sync Buffer Control Bits
macro DMB$B_TX_BUFF_PRIO = 444,0,8,1 %; ! Transmitter Buf. Priority
macro DMB$B_RX_BUFF_PRIO = 445,0,8,1 %; ! Receiver Buffer Priority
macro DMB$B_SYNC_TEST_INPUT = 446,0,8,1 %; ! Test inputs
macro DMB$V_SYNC_CABLE = 444,24,4,0 %;
literal DMB$S_SYNC_CABLE = 4;           ! Electrical Configuration
macro DMB$V_SYNC_LOOP = 444,29,1,0 %;   ! Loopback present
macro DMB$V_SYNC_VALID = 444,30,1,0 %;  ! Valid cable
macro DMB$V_SYNC_X21 = 444,31,1,0 %;    ! X.21 Mode
! 
!  The next 10 registers are for the async port on the DMB32
!                                               
macro DMB$L_PREEMPT = 448,0,32,0 %;     ! Preempt Buffer
macro DMB$B_PREEMPT_CHAR = 448,0,8,1 %; ! Character to Transmit
macro DMB$V_PREEMPT_GO = 448,15,1,0 %;  ! Start Preempt
macro DMB$L_TBUFFAD = 452,0,32,1 %;     ! Transmit Buffer Address
macro DMB$L_TBUFFCT = 456,0,32,0 %;     ! Transmit Buffer Count-Offset
macro DMB$W_TX_BUFF_OFF = 456,0,16,1 %; ! Transmit Buffer Offset
macro DMB$W_TX_CHAR_CT = 458,0,16,1 %;  ! Transmit Buffer Count
macro DMB$L_LPR = 460,0,32,0 %;         ! Line parameter register
macro DMB$V_ML = 460,0,1,0 %;           ! Modem Loop
macro DMB$V_DTR = 460,1,1,0 %;          ! Data Terminal Ready
macro DMB$V_DRS = 460,2,1,0 %;          ! Data Rate Select
macro DMB$V_RTS = 460,4,1,0 %;          ! Request to Send
macro DMB$V_TX_INT_DELAY = 460,9,1,0 %; ! Transmit Interrupt Control
macro DMB$V_RX_ENA = 460,10,1,0 %;      ! Receiver Enable
macro DMB$V_BREAK = 460,11,1,0 %;       ! Break control
macro DMB$V_MAINT = 460,12,2,0 %;
literal DMB$S_MAINT = 2;                ! Maintenance Mode
macro DMB$V_REPORT_MODEM = 460,14,1,0 %; ! Report Modem changes
macro DMB$V_DISCARD_FLOW = 460,15,1,0 %; ! Discard flow contr. characters
macro DMB$V_CHAR_LENGTH = 460,16,2,0 %;
literal DMB$S_CHAR_LENGTH = 2;          ! character length
macro DMB$V_PARITY_ENAB = 460,18,1,0 %; ! Parity enable
macro DMB$V_EVEN_PARITY = 460,19,1,0 %; ! Even parity
macro DMB$V_STOP_CODE = 460,20,1,0 %;   ! Stop code
macro DMB$V_USE_CTS = 460,21,1,0 %;     ! CTS controls output
macro DMB$V_IAUTO_FLOW = 460,22,1,0 %;  ! Auto f.c. of incoming data
macro DMB$V_OAUTO_FLOW = 460,23,1,0 %;  ! Auto f.c. of outgoing data
macro DMB$V_RX_SPEED = 460,24,4,0 %;
literal DMB$S_RX_SPEED = 4;             ! Received data speed
macro DMB$V_TX_SPEED = 460,28,4,0 %;
literal DMB$S_TX_SPEED = 4;             ! Transmitted data rate
macro DMB$L_LNCTRL = 464,0,32,0 %;      ! Line Control
macro DMB$V_TX_DMA_START = 464,0,1,0 %; ! Start a DMA transfer
macro DMB$V_TX_DMA_PTE = 464,1,1,0 %;   ! PTE address
macro DMB$V_TX_DMA_PHYS = 464,2,1,0 %;  ! Physical address
macro DMB$V_TX_OUT_ABORT = 464,8,1,0 %; ! Transmitter output abort
macro DMB$B_TX_ERROR = 466,0,8,1 %;     ! Transmitter error bits
macro DMB$L_LSTAT = 468,0,32,0 %;       ! Line status register
macro DMB$V_ML2 = 468,10,1,0 %;         ! Spare modem control lead
macro DMB$V_CTS = 468,12,1,0 %;         ! Clear to send
macro DMB$V_DCD = 468,13,1,0 %;         ! Data carrier detected
macro DMB$V_RI = 468,14,1,0 %;          ! Ring indicator
macro DMB$V_DSR = 468,15,1,0 %;         ! Data set ready
macro DMB$V_SNDOFF = 468,23,1,0 %;      ! Send XOFF
macro DMB$V_TX_ENA = 468,31,1,0 %;      ! Transmitter enable
macro DMB$L_FLOWC = 472,0,32,0 %;       ! Flow control characters
macro DMB$B_SENT_XOFF = 472,0,8,1 %;    ! Transmitted XOFF
macro DMB$B_SENT_XON = 473,0,8,1 %;     ! Transmitted XON
macro DMB$B_RECEIVED_XOFF = 474,0,8,1 %; ! Received XOFF
macro DMB$B_RECEIVED_XON = 475,0,8,1 %; ! Received XON
macro DMB$L_TBUF = 516,0,32,0 %;        ! Transmit completion fifo
macro DMB$B_TX_LINE = 516,0,8,1 %;      ! Transmit line number
macro DMB$V_TX_PREEMPT = 516,8,1,0 %;   ! Preempt completed
macro DMB$V_TX_FIFO_DONE = 516,9,1,0 %; ! fifo empty
macro DMB$B_TX_DMA_ERROR = 518,0,8,1 %; ! Transmit error code
macro DMB$V_TX_ACT = 516,31,1,0 %;      ! Transmitter action
macro DMB$L_SBUF = 520,0,32,0 %;        ! Sync line completion fifo
macro DMB$B_SYNC_LINE = 520,0,8,1 %;    ! Sync line number
macro DMB$V_SYNC_MODEM = 520,8,1,0 %;   ! Modem change
macro DMB$V_SYNC_TX_ACT = 520,9,1,0 %;  ! Sync Transmit complete
macro DMB$V_SYNC_SECOND_BUFFER = 520,10,1,0 %; ! buffer number
macro DMB$V_SBUF_SPARE = 520,11,5,0 %;
literal DMB$S_SBUF_SPARE = 5;           ! 
macro DMB$R_SBUF_X = 522,0,8,0 %;
literal DMB$S_SBUF_X = 1;               ! 
macro DMB$B_SYNC_MODEM_STATUS = 522,0,8,1 %; ! Sync line new modem status
macro DMB$B_SYNC_ERROR = 522,0,8,1 %;   ! Sync line error code
macro DMB$L_RBUF = 524,0,32,0 %;        ! Async Receiver Buffer
macro DMB$B_RXCHAR = 524,0,8,1 %;       ! Received character
macro DMB$V_PARITY_ERR = 524,12,1,0 %;  ! Parity error
macro DMB$V_FRAME_ERR = 524,13,1,0 %;   ! Framing error
macro DMB$V_OVERRUN_ERR = 524,14,1,0 %; ! Overrun error
macro DMB$V_NON_CHAR = 524,15,1,0 %;    ! non character data
macro DMB$B_RX_LINE = 526,0,8,1 %;      ! Receive line number
macro DMB$V_DATA_VALID = 524,31,1,0 %;  ! Data valid
 
!*** MODULE $DMPDEF ***
! 
!  LAYOUT OF THE HEADER BLOCK OF THE SYSTEM DUMP FILE
!  (WHICH IS THE FIRST DISK BLOCK OF SYS$SYSTEM:SYSDUMP.DMP)
! 
literal DMP$M_OLDDUMP = %X'1';
literal DMP$M_EMPTY = %X'2';
literal DMP$M_HDRBLK = %X'4';
literal DMP$M_ERRLOG = %X'8';
literal DMP$M_MEMORY = %X'10';
literal DMP$M_SPT = %X'20';
literal DMP$M_WRITECOMP = %X'40';
literal DMP$M_ERRLOGCOMP = %X'80';
literal DMP$M_DUMP_STYLE = %X'F00';
literal DMP$M_BITS_12_15 = %X'F000';
literal DMP$M_BITS_16_31 = %X'FFFF0000';
literal DMP$K_FULL_DUMP = 0;            !  FULL PHYSICAL MEMORY DUMP (OLD WAY)
literal DMP$K_SUBSET_DUMP = 1;          !  SUBSETTED DUMP FILE (NOT ALL INFO SAVED)
literal DMP$M_DUMPSTYLE_MASK = 1;
literal DMP$M_FULL_MESSAGES = 2;
literal DMP$C_DUMP_LUMP = 127;          !  NUMBER OF SPTES REQUIRED FOR SUBSET DUMPS
literal DMP$K_DUMPVER = 1536;           !  DUMP FILE VERSION NUMBER
literal DMP$K_LENGTH = 260;             !  LENGTH OF FILE HEADER 
literal DMP$C_LENGTH = 260;             !  LENGTH OF FILE HEADER 
literal DMP$S_DMPDEF = 264;             !  Old size name - synonym
literal DMP$S_DMP = 264;
macro DMP$L_ERRSEQ = 0,0,32,0 %;        !  LAST ERROR LOG SEQ. NUMBER 
macro DMP$W_FLAGS = 4,0,16,0 %;         !  DUMP FILE FLAGS
macro DMP$B_FILLER6 = 6,0,8,0 %;        !  UNUSED
macro DMP$B_ERLBUFPAGES = 7,0,8,0 %;    !  PAGES PER ERL BUFFER; IF ZERO, CORRECT VALUE IS ONE
macro DMP$V_OLDDUMP = 4,0,1,0 %;        !  SET IF DUMP ALREADY ANALYZED 
macro DMP$V_EMPTY = 4,1,1,0 %;          !  SET IF DUMP HAS NO DATA BLOCKS 
macro DMP$V_HDRBLK = 4,2,1,0 %;         !  SET IF ERROR WRITING FIRST BLOCK OF DUMP HEADER
macro DMP$V_ERRLOG = 4,3,1,0 %;         !  SET IF ERROR WRITING BLOCKS 2-3 OF DUMP HEADER
macro DMP$V_MEMORY = 4,4,1,0 %;         !  SET IF ERROR WRITING MEMORY CONTENTS TO DUMP FILE
macro DMP$V_SPT = 4,5,1,0 %;            !  SET IF ERROR WRITING SYSTEM PAGE TABLE BLOCKS TO DUMP FILE
macro DMP$V_WRITECOMP = 4,6,1,0 %;      !  SET IF DUMP WRITE WAS COMPLETED
macro DMP$V_ERRLOGCOMP = 4,7,1,0 %;     !  SET IF HEADER/ERROR LOGS WRITE WAS COMPLETED
macro DMP$V_DUMP_STYLE = 4,8,4,0 %;
literal DMP$S_DUMP_STYLE = 4;           !  SET TO DIFFERENTIATE BETWEEN DIFFERENT STYLE DUMPS
macro DMP$V_BITS_12_15 = 4,12,4,0 %;
literal DMP$S_BITS_12_15 = 4;           !  UNUSED
macro DMP$V_BITS_16_31 = 4,16,16,0 %;
literal DMP$S_BITS_16_31 = 16;          !  OVERLAYS DMP$B_BUFPAGES
!  DUMP_STYLE BITFIELD SETTINGS
macro DMP$Q_PTBR = 8,0,0,0 %;
literal DMP$S_PTBR = 8;                 !  PAGE TABLE BASE REGISTER
macro DMP$Q_KSP = 16,0,0,0 %;
literal DMP$S_KSP = 8;                  !  KERNEL STACK POINTER 
macro DMP$Q_ESP = 24,0,0,0 %;
literal DMP$S_ESP = 8;                  !  EXECUTIVE STACK POINTER 
macro DMP$Q_SSP = 32,0,0,0 %;
literal DMP$S_SSP = 8;                  !  SUPERVISOR STACK POINTER 
macro DMP$Q_USP = 40,0,0,0 %;
literal DMP$S_USP = 8;                  !  USER STACK POINTER 
macro DMP$L_PALREV = 48,0,32,0 %;       !  PAL REVISION NUMBER
macro DMP$L_MEMPAG = 52,0,32,0 %;       !  NUMBER OF BYTES PER PAGE 
macro DMP$L_PAGEBITS = 56,0,32,0 %;     !  NUMBER OF BITS IN PAGE INDEX
macro DMP$L_PAGEMASK = 60,0,32,0 %;     !  MASK FOR PAGE INDEX
macro DMP$L_SYMVECT_VA = 64,0,32,1 %;   !  ABSOLUTE VIRTUAL ADDRESS OF SYMBOL VECTOR IN MEMORY
macro DMP$L_SYSVER = 68,0,32,0 %;       !  SYSTEM VERSION NUMBER 
macro DMP$L_CHECK = 72,0,32,0 %;        !  ONES COMPLEMENT OF SYSVER 
macro DMP$W_DUMPVER = 76,0,16,0 %;      !  DUMP FILE VERSION NUMBER
macro DMP$W_ERLBUFCNT = 78,0,16,0 %;    !  NUMBER OF ERROR LOG BUFFERS 
macro DMP$W_ERLBUFHEAD = 80,0,16,0 %;   !  RING BUFFER HEAD INDEX 
macro DMP$W_ERLBUFTAIL = 82,0,16,0 %;   !  RING BUFFER TAIL INDEX 
macro DMP$L_ERRSTATUS = 84,0,32,0 %;    !  LAST ERROR STATUS FROM DUMP WRITE
macro DMP$L_DUMPERRS = 88,0,32,0 %;     !  COUNT OF ERRORS DURING DUMP WRITE
macro DMP$L_DUMPBLOCKCNT = 92,0,32,0 %; !  COUNT OF BLOCKS DUMPED
macro DMP$L_NEEDBLOCKCNT = 96,0,32,0 %; !  THE NUMBER OF BLOCKS NEEDED FOR COMPLETE DUMP
macro DMP$L_SAVEPRCCNT = 100,0,32,0 %;  !  COUNT OF SAVED PROCESSES (SUBSET DUMP)
macro DMP$Q_SYSIDENT = 104,0,0,0 %;
literal DMP$S_SYSIDENT = 8;             !  TEXT ident for SYS.EXE
macro DMP$L_HWRPB_VBN = 112,0,32,0 %;   !  VBN where HWRPB is saved
!  trap info:
macro DMP$L_TRAP_VALID = 116,0,32,0 %;  !  Set if a trap happened
macro DMP$Q_TRAP_R2 = 120,0,0,0 %;
literal DMP$S_TRAP_R2 = 8;              !  trap exception frame
macro DMP$Q_TRAP_R3 = 128,0,0,0 %;
literal DMP$S_TRAP_R3 = 8;
macro DMP$Q_TRAP_R4 = 136,0,0,0 %;
literal DMP$S_TRAP_R4 = 8;
macro DMP$Q_TRAP_R5 = 144,0,0,0 %;
literal DMP$S_TRAP_R5 = 8;
macro DMP$Q_TRAP_R6 = 152,0,0,0 %;
literal DMP$S_TRAP_R6 = 8;
macro DMP$Q_TRAP_R7 = 160,0,0,0 %;
literal DMP$S_TRAP_R7 = 8;
macro DMP$Q_TRAP_PC = 168,0,0,0 %;
literal DMP$S_TRAP_PC = 8;
macro DMP$Q_TRAP_PS = 176,0,0,0 %;
literal DMP$S_TRAP_PS = 8;
macro DMP$Q_TRAP_VA = 184,0,0,0 %;
literal DMP$S_TRAP_VA = 8;              !  trap VA
macro DMP$L_TRAP_MMF = 192,0,32,0 %;    !  trap MMF
! 
!  additional space for later use
! 
macro DMP$T_EXTRA_SPACE = 196,0,0,0 %;
literal DMP$S_EXTRA_SPACE = 64;
macro DMP$L_CRASHERL = 260,0,32,0 %;    !  SYSTEM CRASH ERR LOG ENTRY 
 
!*** MODULE $DIAGDEF ***
! *
! 
!  Constants defining literals used in $DIAGNOSE system service
! 
literal DIAG$C_SETAFF = 1;              !  request to set affinity -- Set/Release
!  explicit process affinity to any CPU.
literal DIAG$C_ACTVCPUS = 2;            !  request to read SMP$GL_ACTIVE_CPUS
literal DIAG$C_DISABLAFF = 0;           !  disable explicit affinity to a CPU
literal DIAG$C_ENABLAFF = 1;            !  enable explicit affinity to a CPU
 
!*** MODULE $DPTDEF ***
! +
!  DPT - DRIVER PROLOGUE TABLE
! 
!  EACH DEVICE DRIVER HAS A DRIVER PROLOGUE TABLE.
! -
literal DPT$K_STEP_1 = 1;               ! A STEP 1 DRIVER
literal DPT$K_STEP_2 = 2;               ! A STEP 2 DRIVER
literal DPT$K_STEP1_V1 = 1;             ! STEP 1 VERSION 1
literal DPT$K_STEP1_V2 = 2;             ! STEP 1 VERSION 2
literal DPT$K_STEP2_V1 = 1;             ! STEP 2 VERSION 1
literal DPT$K_STEP2_V2 = 2;             ! STEP 2 VERSION 2 (CSR mapping)
literal DPT$K_IOGEN_REQ_STEP2VER = 2;
literal DPT$M_SUBCNTRL = %X'1';
literal DPT$M_SVP = %X'2';
literal DPT$M_NOUNLOAD = %X'4';
literal DPT$M_SCS = %X'8';
literal DPT$M_DUSHADOW = %X'10';
literal DPT$M_SCSCI = %X'20';
literal DPT$M_BVPSUBS = %X'40';
literal DPT$M_UCODE = %X'80';
literal DPT$M_SMPMOD = %X'100';
literal DPT$M_DECW_DECODE = %X'200';
literal DPT$M_TPALLOC = %X'400';
literal DPT$M_SNAPSHOT = %X'800';
literal DPT$M_NO_IDB_DISPATCH = %X'1000';
literal DPT$M_SCSI_PORT = %X'2000';
literal DPT$K_BASE_LEN = 136;           ! LENGTH OF PRE IMAGE NAME DRIVER PROLOGUE
literal DPT$C_BASE_LEN = 136;           ! LENGTH OF PRE IMAGE NAME DRIVER PROLOGUE
literal DPT$S_DPT = 144;
macro DPT$L_FLINK = 0,0,32,1 %;         ! FORWARD LINK TO NEXT DPT 
macro DPT$PS_FLINK = 0,0,32,1 %;        ! FORWARD LINK TO NEXT DPT 
macro DPT$L_BLINK = 4,0,32,1 %;         ! BACKWARD LINK TO PREVIOUS DPT 
macro DPT$PS_BLINK = 4,0,32,1 %;        ! BACKWARD LINK TO PREVIOUS DPT 
macro DPT$W_SIZE = 8,0,16,0 %;          ! SIZE OF DRIVER 
macro DPT$IW_SIZE = 8,0,16,0 %;         ! SIZE OF DRIVER 
macro DPT$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE 
macro DPT$IB_TYPE = 10,0,8,0 %;         ! STRUCTURE TYPE 
macro DPT$IW_STEP = 12,0,16,0 %;        ! DRIVER STEP NUMBER
macro DPT$IW_STEPVER = 14,0,16,0 %;     ! VERSION WITHIN A DRIVER STEP
macro DPT$W_DEFUNITS = 16,0,16,0 %;     ! DEFAULT NUMBER OF UNITS 
macro DPT$IW_DEFUNITS = 16,0,16,0 %;    ! DEFAULT NUMBER OF UNITS 
macro DPT$W_MAXUNITS = 18,0,16,0 %;     ! MAXIMUM UNITS THAT CAN BE CONNECTED 
macro DPT$IW_MAXUNITS = 18,0,16,0 %;    ! MAXIMUM UNITS THAT CAN BE CONNECTED 
macro DPT$W_UCBSIZE = 20,0,16,0 %;      ! SIZE OF UCB 
macro DPT$IW_UCBSIZE = 20,0,16,0 %;     ! SIZE OF UCB 
macro DPT$IW_IOHANDLES = 22,0,16,0 %;   ! Number of IOHANDLES that driver needs
macro DPT$IW_IDB_CRAMS = 24,0,16,0 %;   ! Number of CRAMS to allocate for the IDB
macro DPT$IW_UCB_CRAMS = 26,0,16,0 %;   ! Number of CRAMS to allocate for the UCB
macro DPT$L_FLAGS = 28,0,32,0 %;        ! DRIVER LOADER FLAGS
macro DPT$IL_FLAGS = 28,0,32,0 %;       ! DRIVER LOADER FLAGS
macro DPT$B_FLAGS = 28,0,8,0 %;         ! an old-world synonym for the above
macro DPT$V_SUBCNTRL = 28,0,1,0 %;      ! DEVICE IS A SUB-CONTROLLER 
macro DPT$V_SVP = 28,1,1,0 %;           ! DEVICE REQUIRES A SYSTEM PAGE 
macro DPT$V_NOUNLOAD = 28,2,1,0 %;      ! DRIVER IS NOT TO BE UNLOADED 
macro DPT$V_SCS = 28,3,1,0 %;           ! Load common SCS code with driver
macro DPT$V_DUSHADOW = 28,4,1,0 %;      ! SHADOWING DISK CLASS DRIVER
macro DPT$V_SCSCI = 28,5,1,0 %;         ! Load common SCS/CI subroutines with driver
macro DPT$V_BVPSUBS = 28,6,1,0 %;       ! Load common BVP subroutines with driver
macro DPT$V_UCODE = 28,7,1,0 %;         ! Driver has associated microcode image
macro DPT$V_SMPMOD = 28,8,1,0 %;        ! Driver has been modified for SMP
macro DPT$V_DECW_DECODE = 28,9,1,0 %;   ! DECwindows decoder (class) driver
macro DPT$V_TPALLOC = 28,10,1,0 %;      ! Use tape allocation class parameter
macro DPT$V_SNAPSHOT = 28,11,1,0 %;     ! Driver has been certified for system snapshot
macro DPT$V_NO_IDB_DISPATCH = 28,12,1,0 %; ! Don't use IDB$L_UCBLST for UCB vectors
macro DPT$V_SCSI_PORT = 28,13,1,0 %;    ! Driver is an SCSI port driver
macro DPT$IL_ADPTYPE = 32,0,32,0 %;     ! ADAPTER TYPE CODE 
macro DPT$IL_REFC = 36,0,32,0 %;        ! COUNT OF DDB'S THAT REFERENCE DRIVER 
macro DPT$PS_INIT_PD = 40,0,32,1 %;     ! STRUCTURE INIT ROUTINE DESC ADDRESS
macro DPT$PS_REINIT_PD = 44,0,32,1 %;   ! STRUCTURE RE-INIT ROUTINE DESC ADDRESS
macro DPT$PS_DELIVER_2 = 48,0,32,1 %;   ! STEP 2 UNIT DELIVERY ROUTINE DESC ADDRESS
macro DPT$PS_UNLOAD = 52,0,32,1 %;      ! UNLOAD ROUTINE DESC ADDRESS
macro DPT$PS_DDT = 56,0,32,1 %;         ! POINTER TO DRIVER'S DDT ADDRESS
macro DPT$PS_DDB_LIST = 60,0,32,1 %;    ! POINTER TO FIRST DDB IN LIST FOR THIS DRIVER
macro DPT$IS_BTORDER = 64,0,32,1 %;     ! BOOTTIME INIT CALL ORDERING NUMBER
macro DPT$L_VECTOR = 68,0,32,1 %;       ! POINTER TO VECTOR TABLE (IN TTDRIVER) 
macro DPT$PS_VECTOR = 68,0,32,1 %;      ! POINTER TO VECTOR TABLE (IN TTDRIVER) 
macro DPT$T_NAME = 72,0,0,0 %;
literal DPT$S_NAME = 16;                ! AUTHOR'S NAME FOR THE DRIVER
macro DPT$B_NAME_LEN = 72,0,8,0 %;      !  	CHARACTER COUNT
macro DPT$IB_NAME_LEN = 72,0,8,0 %;     !  	CHARACTER COUNT
macro DPT$T_NAME_STR = 73,0,0,0 %;
literal DPT$S_NAME_STR = 15;            !  	CHARACTER STRING
macro DPT$L_ECOLEVEL = 88,0,32,0 %;     ! ECO LEVEL FROM IMAGE HEADER 
macro DPT$IL_ECOLEVEL = 88,0,32,0 %;    ! ECO LEVEL FROM IMAGE HEADER 
macro DPT$L_UCODE = 92,0,32,0 %;        ! ASSOCIATED MICROCODE IMAGE
macro DPT$Q_LINKTIME = 96,0,0,0 %;
literal DPT$S_LINKTIME = 8;             ! LINK DATE AND TIME FROM IMAGE HEADER 
macro DPT$IQ_IMAGE_NAME = 104,0,0,0 %;
literal DPT$S_IMAGE_NAME = 8;           ! STRING DESCRIPTOR FOR DRIVER'S IMAGE NAME
macro DPT$IW_INAME_LEN = 104,0,16,0 %;  ! -- IMAGE NAME LENGTH
macro DPT$IB_INAME_TYPE = 106,0,8,0 %;  ! -- IMAGE NAME DESC TYPE
macro DPT$IB_INAME_CLASS = 107,0,8,0 %; ! -- IMAGE NAME DESC TYPE
macro DPT$PS_INAME_PTR = 108,0,32,1 %;  ! -- IMAGE NAME DESC POINTER
macro DPT$IL_LOADER_HANDLE = 112,0,0,0 %;
literal DPT$S_LOADER_HANDLE = 16;       ! EXECLET LOADER HANDLE
macro DPT$L_DECW_SNAME = 128,0,32,1 %;  ! POINTER TO COUNTED ASCII STRING
macro DPT$PS_DECW_SNAME = 128,0,32,1 %; ! POINTER TO COUNTED ASCII STRING
macro DPT$PS_CUSTOMER = 132,0,32,1 %;   ! Reserved_to_customer
macro DPT$T_IMAGE_NAME = 136,0,8,0 %;
literal DPT$S_DPTDEF = 144;             ! OLD DPT SIZE NAME FOR COMPATIBILITY
 
!*** MODULE $DSRVDEF ***
! +
!  DSRV  ( )  Definitions
! 
! 	This module defines the main data structure of the MSCP
! 	server. This structure contains the values specified in
! 	the start up qualifiers when the server was loaded, the 
! 	UQB vector table, and statistics that are kept for server
! 	performance measurements.
! 
!  <<== !NOTICE! ==>>
! 
! 	DO NOT change offsets of the top part of the data structure.
!  	If new fields have to be added please make them below the 
! 	forward and backward links to the UQB.
! -
! Max number of served units
literal DSRV$M_LOG_ENABLD = %X'1';
literal DSRV$M_LOG_PRESENT = %X'2';
literal DSRV$M_PKT_LOGGED = %X'4';
literal DSRV$M_PKT_LOST = %X'8';
literal DSRV$M_LBSTEP1 = %X'10';
literal DSRV$M_LBSTEP2 = %X'20';
literal DSRV$M_LBEVENT = %X'40';
literal DSRV$M_HULB_DEL = %X'80';
literal DSRV$M_MON_ACTIVE = %X'100';
literal DSRV$M_LB_REQ = %X'200';
literal DSRV$M_CONFIG_WAIT = %X'400';
literal DSRV$C_LENGTH = 2964;
literal DSRV$K_LENGTH = 2964;
literal DSRV$K_AR_ADD = 2;              !  Action routine code
literal DSRV$K_MAX_UNITS = 512;
literal DSRV$S_DSRVDEF = 2964;          !  Old size name synonym
literal DSRV$S_DSRV = 2964;
macro DSRV$L_FLINK = 0,0,32,1 %;        !  Field maintained for 
macro DSRV$L_BLINK = 4,0,32,1 %;        !   compatability
macro DSRV$W_SIZE = 8,0,16,0 %;         !  Structure size in bytes
macro DSRV$B_TYPE = 10,0,8,0 %;         !  MSCP type structure
macro DSRV$B_SUBTYPE = 11,0,8,0 %;      !   with a DSRV subtype      (1)
macro DSRV$W_STATE = 12,0,16,0 %;       !  Current state of the server
macro DSRV$V_LOG_ENABLD = 12,0,1,0 %;   !  Logging is enabled
macro DSRV$V_LOG_PRESENT = 12,1,1,0 %;  !  Logging code is present
macro DSRV$V_PKT_LOGGED = 12,2,1,0 %;   !  A packet has been logged
macro DSRV$V_PKT_LOST = 12,3,1,0 %;     !  One or more packets over-
!   written since last read
macro DSRV$V_LBSTEP1 = 12,4,1,0 %;      !  Load balancing step1 active
macro DSRV$V_LBSTEP2 = 12,5,1,0 %;      !  Load balancing step2 active
macro DSRV$V_LBEVENT = 12,6,1,0 %;      !  An event of interest to LB has
!   occured while STEP1 was active
macro DSRV$V_HULB_DEL = 12,7,1,0 %;     !  One or more HULBs to be deleted
macro DSRV$V_MON_ACTIVE = 12,8,1,0 %;   !  The load monitor thread is active
macro DSRV$V_LB_REQ = 12,9,1,0 %;       !  A load balance request has been sent
macro DSRV$V_CONFIG_WAIT = 12,10,1,0 %; !  Waiting for STACONFIG to complete
macro DSRV$W_BUFWAIT = 14,0,16,0 %;     ! I/Os that had to wait
macro DSRV$L_LOG_BUF_START = 16,0,32,1 %; !  Address of start of buffer
macro DSRV$L_LOG_BUF_END = 20,0,32,1 %; !  Address of end of buffer
macro DSRV$L_NEXT_READ = 24,0,32,1 %;   !  Adrs of next packet to read
macro DSRV$L_NEXT_WRITE = 28,0,32,1 %;  !  Adrs of next packet to write
macro DSRV$W_INC_LOLIM = 32,0,16,0 %;   !  Low unit number to log
macro DSRV$W_INC_HILIM = 34,0,16,0 %;   !  High unit number to log
macro DSRV$W_EXC_LOLIM = 36,0,16,0 %;   !  Low unit number not to log
macro DSRV$W_EXC_HILIM = 38,0,16,0 %;   !  High unit number not to log
macro DSRV$L_SRVBUF = 40,0,32,1 %;      !  Address of preallocated pool
macro DSRV$L_FREE_LIST = 44,0,32,1 %;   !  Pointer to head of free pool
macro DSRV$L_AVAIL = 48,0,32,0 %;       !  Sum of bytes available in buffer
macro DSRV$L_BUFFER_MIN = 52,0,32,0 %;  !  Min xfer size based on buffer
macro DSRV$L_SPLITXFER = 56,0,32,0 %;   !  Fragmented I/O count
macro DSRV$W_VERSION = 60,0,16,0 %;     !  Server software version
macro DSRV$W_CFLAGS = 62,0,16,0 %;      !  Controller flags
macro DSRV$W_CTIMO = 64,0,16,0 %;       !  Controller timeout
macro DSRV$Q_CTRL_ID = 68,0,0,0 %;
literal DSRV$S_CTRL_ID = 8;             !  Unique MSCP device identifier
macro DSRV$L_MEMW_TOT = 76,0,32,0 %;    !  Number of I/Os that had to wait
macro DSRV$W_MEMW_CNT = 80,0,16,0 %;    !  Requests in memory wait queue
macro DSRV$W_MEMW_MAX = 82,0,16,0 %;    !  Most requests ever in MEMWAIT
macro DSRV$L_MEMW_FL = 84,0,32,1 %;     !  Queue listhead for requests
macro DSRV$L_MEMW_BL = 88,0,32,1 %;     !   in memory wait state
macro DSRV$W_NUM_HOST = 92,0,16,0 %;    !  Count of hosts being served
macro DSRV$W_NUM_UNIT = 94,0,16,0 %;    !  Count of disks being served
macro DSRV$L_HQB_FL = 96,0,32,1 %;      !  Host queue block list head
macro DSRV$L_HQB_BL = 100,0,32,1 %;     ! 
macro DSRV$L_UQB_FL = 104,0,32,1 %;     !  Unit queue block list head
macro DSRV$L_UQB_BL = 108,0,32,1 %;     ! 
! 
!  new fields should be added here, after the UQB linkages
! 
! 
! 	Server Load Balancing fields
! 
! 	The following fields containing working information and statistics
! 	for the server load balancing function. Load balancing status bits
! 	are defined in DSRV$STATE above. Time fields are in EXE$GL_ABSTIM
! 	format.
! 
macro DSRV$W_LOAD_AVAIL = 112,0,16,0 %; !  Current load available
macro DSRV$W_LOAD_CAPACITY = 114,0,16,0 %; !  Server load capacity
macro DSRV$W_LBLOAD = 116,0,16,0 %;     !  Target load for LB request
macro DSRV$W_LBRESP = 118,0,16,0 %;     !  Load available from other server
macro DSRV$W_LM_LOAD1 = 120,0,16,0 %;   !  previous interval load 1
macro DSRV$W_LM_LOAD2 = 122,0,16,0 %;   !  previous interval load 2
macro DSRV$W_LM_LOAD3 = 124,0,16,0 %;   !  previous interval load 3
macro DSRV$W_LM_LOAD4 = 126,0,16,0 %;   !  previous interval load 4
macro DSRV$W_LBINIT_CNT = 128,0,16,0 %; !  Count of LB requests we have sent
macro DSRV$W_LBFAIL_CNT = 130,0,16,0 %; !  Count of LB requests that failed
macro DSRV$W_LBREQ_CNT = 132,0,16,0 %;  !  Count of LB requests from other servers
macro DSRV$W_LBRESP_CNT = 134,0,16,0 %; !  Count of LB requests we to which we responded
macro DSRV$L_LBREQ_TIME = 136,0,32,0 %; !  Time last LB request was sent
macro DSRV$L_LBMON_TIME = 140,0,32,0 %; !  Time of last LB monitor pass
macro DSRV$L_LM_FKB = 144,0,32,1 %;     !  Address of load monitor thread FKB
macro DSRV$L_LB_FKB = 148,0,32,1 %;     !  Address of load balance thread FKB
macro DSRV$W_LM_INTERVAL = 152,0,16,0 %; !  Load monitoring interval
macro DSRV$B_LB_COUNT1 = 154,0,8,0 %;   !  Counter for load balancing thread
macro DSRV$B_LB_COUNT2 = 155,0,8,0 %;   !  Counter for load balancing thread
macro DSRV$L_HULB_FL = 156,0,32,1 %;    !  HULB queue listhead
macro DSRV$L_HULB_BL = 160,0,32,1 %;    ! 
macro DSRV$B_HOSTS = 164,0,0,0 %;
literal DSRV$S_HOSTS = 32;              !  Bit array of hosts served
macro DSRV$L_UNITS = 196,0,0,1 %;
literal DSRV$S_UNITS = 2048;            !  Table of UQB addresses
! 
! 	Statistics gathering fields
! 
! 	Two tables are maintained below. The first table is made up of the 
! 	frequency count for each of the opcodes received since the server
! 	was loaded. The opcode is used as an index into the table to its own
! 	frequency count (the zeroeth element contains a total count). The 
! 	second table is made up of the frequency counters for all the
! 	different sized block transfers. For this table, the size of the 
! 	transfer is the index into the table.
! 
macro DSRV$L_OPCOUNT = 2244,0,32,0 %;   !  Total operations count
macro DSRV$L_ABORT_CNT = 2248,0,32,0 %; !    - 1 -
macro DSRV$L_GET_CMD_CNT = 2252,0,32,0 %; !    - 2 -
macro DSRV$L_GET_UNT_CNT = 2256,0,32,0 %; !    - 3 -
macro DSRV$L_SET_CON_CNT = 2260,0,32,0 %; !    - 4 -
macro DSRV$L_ACC_NVM_CNT = 2264,0,32,0 %; !    - 5 -
macro DSRV$L_DISPLAY_CNT = 2268,0,32,0 %; !    - 6 -
macro DSRV$L_GET_UNN_CNT = 2272,0,32,0 %; !    - 7 -
macro DSRV$L_AVAIL_CNT = 2276,0,32,0 %; !    - 8 -
macro DSRV$L_ONLIN_CNT = 2280,0,32,0 %; !    - 9 -
macro DSRV$L_SET_UNT_CNT = 2284,0,32,0 %; !    - 10 -
macro DSRV$L_DET_ACC_CNT = 2288,0,32,0 %; !    - 11 -
macro DSRV$L_MOVE_CNT = 2292,0,32,0 %;  !    - 12 -
macro DSRV$L_DCD_CNT = 2296,0,32,0 %;   !    - 13 -
macro DSRV$L_ACCES_CNT = 2308,0,32,0 %; !    - 16 -
macro DSRV$L_CMP_CON_CNT = 2312,0,32,0 %; !    - 17 -
macro DSRV$L_ERASE_CNT = 2316,0,32,0 %; !    - 18 -
macro DSRV$L_FLUSH_CNT = 2320,0,32,0 %; !    - 19 -
macro DSRV$L_REPLC_CNT = 2324,0,32,0 %; !    - 20 -
macro DSRV$L_ERASEG_CNT = 2332,0,32,0 %; !    - 22 -
macro DSRV$L_FORMAT_CNT = 2340,0,32,0 %; !    - 24 -
macro DSRV$L_WRI_HIS_CNT = 2344,0,32,0 %; !    - 25 -
macro DSRV$L_CMP_HST_CNT = 2372,0,32,0 %; !    - 32 -
macro DSRV$L_READ_CNT = 2376,0,32,0 %;  !    - 33 -
macro DSRV$L_WRITE_CNT = 2380,0,32,0 %; !    - 34 -
macro DSRV$L_REA_CED_CNT = 2384,0,32,0 %; !    - 35 -
macro DSRV$L_WRI_TM_CNT = 2388,0,32,0 %; !    - 36 -
macro DSRV$L_REPOS_CNT = 2392,0,32,0 %; !    - 37 -
macro DSRV$L_TERCO_CNT = 2436,0,32,0 %; !    - 48 -
macro DSRV$L_VCFAIL_CNT = 2440,0,32,0 %; !  Count of VC failures
macro DSRV$L_BLKCOUNT = 2444,0,0,0 %;
literal DSRV$S_BLKCOUNT = 516;          !  Counters for block xfer reqs
macro DSRV$L_PCB = 2960,0,32,0 %;       !  Pointer to simulated PCB
 
!*** MODULE $DTNDEF ***
literal DTN$K_BASE_LENGTH = 24;         !  length of fixed portion of DTN
literal DTN$K_LENGTH = 52;              !  standard length of DTN
literal DTN$K_NAMELEN_MAX = 27;         !  max length of name string
literal DTN$S_DTN = 52;
macro DTN$PS_FLINK = 0,0,32,1 %;        !  flink to next DTN
macro DTN$PS_BLINK = 4,0,32,1 %;        !  blink to previous DTN
macro DTN$W_SIZE = 8,0,16,0 %;          !  size of DTN in bytes 
macro DTN$B_TYPE = 10,0,8,0 %;          !  structure type of DTN 
macro DTN$B_SUBTYPE = 11,0,8,0 %;       !  structure subtype
macro DTN$L_FLAGS = 12,0,32,0 %;        !  various flag bits
macro DTN$B_DEVTYPE = 16,0,8,0 %;       !  copy of UCB$B_DEVTYPE
macro DTN$B_DEVCLASS = 17,0,8,0 %;      !  copy of UCB$B_DEVCLASS
macro DTN$PS_UCBLIST = 20,0,32,1 %;     !  pointer to list of UCBs
macro DTN$T_DTNAME = 24,0,0,0 %;
literal DTN$S_DTNAME = 28;              !  name stored in ASCIC format
macro DTN$IB_DTNAME_LEN = 24,0,8,0 %;   !  length of the device name
macro DTN$T_DTNAME_STR = 25,0,0,0 %;
literal DTN$S_DTNAME_STR = 27;          !  actual string
 
!*** MODULE $DTSSDEF ***
! +
! 
!  Bit definitions for EXE$GL_DTSSFLAGS - flags for Distributed Time Service
! 
! -
literal DTSS$M_ACTIVE = %X'1';
literal DTSS$M_CALCULATE_CLOCK = %X'2';
literal DTSS$S_DTSSDEF = 1;
literal DTSS$S_DTSS = 1;
macro DTSS$V_ACTIVE = 0,0,1,0 %;        !  Time service active
macro DTSS$V_CALCULATE_CLOCK = 0,1,1,0 %; !  Service wants to synch clock
 
!*** MODULE $DYNDEF ***
! +
!  DATA STRUCTURE TYPE DEFINITIONS
! 
!  EACH DATA STRUCTURE THAT IS ALLOCATED FROM THE DYNAMIC MEMORY
!  POOL SHOULD HAVE A VALID TYPE IN ITS 11TH BYTE.
! -
! BASE AND OFFSET OF 1 
literal DYN$C_ADP = 1;                  ! UNIBUS ADAPTER CONTROL BLOCK 
literal DYN$C_ACB = 2;                  ! AST CONTROL BLOCK 
literal DYN$C_AQB = 3;                  ! ACP QUEUE BLOCK 
literal DYN$C_CEB = 4;                  ! COMMON EVENT BLOCK 
literal DYN$C_CRB = 5;                  ! CHANNEL REQUEST BLOCK 
literal DYN$C_DDB = 6;                  ! DEVICE DESCRIPTOR BLOCK 
literal DYN$C_FCB = 7;                  ! FILE CONTROL BLOCK 
literal DYN$C_FRK = 8;                  ! FORK BLOCK 
literal DYN$C_IDB = 9;                  ! INTERRUPT DISPATCH BLOCK 
literal DYN$C_IRP = 10;                 ! I/O REQUEST PACKET 
literal DYN$C_LOG = 11;                 ! LOGICAL NAME BLOCK 
literal DYN$C_PCB = 12;                 ! PROCESS CONTROL BLOCK 
literal DYN$C_PQB = 13;                 ! PROCESS QUOTA BLOCK 
literal DYN$C_RVT = 14;                 ! RELATIVE VOLUME TABLE 
literal DYN$C_TQE = 15;                 ! TIMER QUEUE ENTRY 
literal DYN$C_UCB = 16;                 ! UNIT CONTROL BLOCK 
literal DYN$C_VCB = 17;                 ! VOLUME CONTROL BLOCK 
literal DYN$C_WCB = 18;                 ! WINDOW CONTROL BLOCK 
literal DYN$C_BUFIO = 19;               ! BUFFERED I/O BLOCK 
literal DYN$C_TYPAHD = 20;              ! TERMINAL TYPEAHEAD BUFFER 
literal DYN$C_GSD = 21;                 ! GLOBAL SECTION DESCRIPTOR BLOCK 
literal DYN$C_MVL = 22;                 ! MAGNETIC TAPE VOLUME LIST 
literal DYN$C_NET = 23;                 ! NETWORK MESSAGE BLOCK 
literal DYN$C_KFE = 24;                 ! KNOWN FILE ENTRY 
literal DYN$C_MTL = 25;                 ! MOUNTED VOLUME LIST ENTRY 
literal DYN$C_BRDCST = 26;              ! BROADCAST MESSAGE BLOCK 
literal DYN$C_CXB = 27;                 ! COMPLEX CHAINED BUFFER 
literal DYN$C_NDB = 28;                 !  NETWORK NODE DESCRIPTOR BLOCK 
literal DYN$C_SSB = 29;                 !  LOGICAL LINK SUBCHANNEL STATUS BLOCK 
literal DYN$C_DPT = 30;                 !  DRIVER PROLOGUE TABLE 
literal DYN$C_JPB = 31;                 !  JOB PARAMETER BLOCK 
literal DYN$C_PBH = 32;                 !  PERFORMANCE BUFFER HEADER 
literal DYN$C_PDB = 33;                 !  PERFORMANCE DATA BLOCK 
literal DYN$C_PIB = 34;                 !  PERFORMANCE INFORMATION BLOCK 
literal DYN$C_PFL = 35;                 !  PAGE FILE CONTROL BLOCK 
literal DYN$C_PFLMAP = 36;              !  Page file mapping window
literal DYN$C_PTR = 37;                 !  POINTER CONTROL BLOCK 
literal DYN$C_KFRH = 38;                !  KNOWN FILE IMAGE HEADER 
literal DYN$C_DCCB = 39;                !  Data Cache Control Block
literal DYN$C_EXTGSD = 40;              ! EXTENDED GLOBAL SECTION DESCRIPTOR 
literal DYN$C_SHMGSD = 41;              ! SHARED MEMORY GLOBAL SECTION DESCRIPTOR 
literal DYN$C_SHB = 42;                 ! SHARED MEMORY CONTROL BLOCK 
literal DYN$C_MBX = 43;                 ! MAILBOX CONTROL BLOCK 
literal DYN$C_IRPE = 44;                ! I/O REQUEST PACKET EXTENSION 
literal DYN$C_SLAVCEB = 45;             ! SLAVE COMMON EVENT BLOCK 
literal DYN$C_SHMCEB = 46;              ! SHARED MEMORY MASTER COMMON EVENT BLOCK 
literal DYN$C_JIB = 47;                 ! JOB INFORMATION BLOCK 
literal DYN$C_TWP = 48;                 !  Terminal driver write packet 
literal DYN$C_RBM = 49;                 !  Realtime SPT bit map 
literal DYN$C_VCA = 50;                 !  Disk volume cache block 
literal DYN$C_CDB = 51;                 ! X25 LES CHANNEL DATA BLOCK 
literal DYN$C_LPD = 52;                 ! X25 LES PROCESS DESCRIPTOR 
literal DYN$C_LKB = 53;                 ! LOCK BLOCK 
literal DYN$C_RSB = 54;                 ! RESOURCE BLOCK 
literal DYN$C_LKID = 55;                ! LOCK ID TABLE 
literal DYN$C_RSHT = 56;                ! RESOURCE HASH TABLE 
literal DYN$C_CDRP = 57;                ! CLASS DRIVER REQUEST PACKET 
literal DYN$C_ERP = 58;                 !  ERRORLOG PACKET 
literal DYN$C_CIDG = 59;                ! DATAGRAM BUFFER FOR CI PORT 
literal DYN$C_CIMSG = 60;               ! MESSAGE BUFFER FOR CI PORT 
literal DYN$C_XWB = 61;                 ! DECNET LOGICAL LINK CONTEXT BLOCK 
!    (REPLACES "NDB" BLOCK)
literal DYN$C_WQE = 62;                 ! DECNET WORK QUEUE BLOCK 
!    (REPLACES "NET" BLOCK)
literal DYN$C_ACL = 63;                 ! ACCESS CONTROL LIST QUEUE ENTRY 
literal DYN$C_LNM = 64;                 ! LOGICAL NAME BLOCK 
literal DYN$C_FLK = 65;                 !  Fork Lock Request Block
literal DYN$C_RIGHTSLIST = 66;          ! RIGHTS LIST
literal DYN$C_KFD = 67;                 !  Known File Device Directory block
literal DYN$C_KFPB = 68;                !  Known File list Pointer Block
literal DYN$C_CIA = 69;                 !  Compound Intrusion Analysis block
literal DYN$C_PMB = 70;                 !  Page Fault Monitor Control Block
literal DYN$C_PFB = 71;                 !  Page Fault Monitor Buffer
literal DYN$C_CHIP = 72;                !  Internal CHKPRO block
literal DYN$C_ORB = 73;                 !  Objects Rights Block
literal DYN$C_QVAST = 74;               !  QVSS AST block
literal DYN$C_MVWB = 75;                !  Mount Verification work buffer
literal DYN$C_UNC = 76;                 !  Universal Context Block
literal DYN$C_DCB = 77;                 !  DCB, for DECnet chained I/O
literal DYN$C_VCRP = 78;                !  VAX Communication Request Packet
literal DYN$C_SPL = 79;                 !  Spinlock control block
literal DYN$C_ARB = 80;                 !  Access Rights Block
literal DYN$C_LCKCTX = 81;              !  Lock context block
literal DYN$C_BOD = 82;                 !  Buffer object descriptor
literal DYN$C_FTRD = 83;                !  FTDRIVER read request packet
literal DYN$C_DDTM_EVENT = 84;          !  DDTM Event Notification block
literal DYN$C_DFLB = 85;                !  Dump File Locator Block
literal DYN$C_PTC = 86;                 !  Posix Terminal Control
literal DYN$C_OCB = 87;                 !  Object Class Block (Security)
literal DYN$C_CPCB = 88;                !  Common Process Control Block 
literal DYN$C_HWPCB = 89;               !  Hardware Process Control Block 
literal DYN$C_GCB = 90;                 !  Glyph Control Block
literal DYN$C_RDPB = 91;                !  Resource Domain Pointer Block
literal DYN$C_RDDB = 92;                !  Resource Domain Data Block
literal DYN$C_SCDRP = 93;               !  SCSI Class Driver Request Packet
literal DYN$C_TQE_ACB = 94;             !  TQE-ACB block
literal DYN$C_NSAB = 95;                !  Security Audit Block
literal DYN$C_DEA = 96;                 !  DEaccess Audit pending block
! 
!  THE FOLLOWING CODES ARE SUBTYPABLE, THAT IS EACH CODE REFERS TO A GENERIC
!  FUNCTION AND WITHIN THAT FUNCTION THERE MAY BE MANY DIFFERENT SUB-TYPES
!  OF BLOCKS.  THIS SCHEME WAS ADOPTED TO PRESERVE TYPES.  THE SUB-TYPE IS
!  IN THE 12TH BYTE.
! 
literal DYN$C_SUBTYPE = 96;             !  START OF SUBTYPABLES 
literal DYN$C_SCS = 96;                 !  SYSTEM COMMUNICATION SERVICES 
literal DYN$C_SCS_CDL = 1;              !  CONNECT DISPATCH LIST 
literal DYN$C_SCS_CDT = 2;              !  CONNECT DISPATCH TABLE 
literal DYN$C_SCS_DIR = 3;              !  DIRECTORY BLOCK 
literal DYN$C_SCS_PB = 4;               !  PATH BLOCK 
literal DYN$C_SCS_PDT = 5;              !  PORT DESCRIPTOR TABLE 
literal DYN$C_SCS_RDT = 6;              !  REQUEST DESCRIPTOR TABLE 
literal DYN$C_SCS_SB = 7;               !  SYSTEM BLOCK 
literal DYN$C_SCS_SPPB = 8;             !  SCA POLLER PROCESS BLOCK
literal DYN$C_SCS_SPNB = 9;             !  SCA POLLER NAME BLOCK
literal DYN$C_SCS_SBNB = 10;            !  SCS LOAD SHARE NAME BLOCK
literal DYN$C_SCS_PLVEC = 11;           !  SCS PORT LOAD VECTOR
literal DYN$C_SCS_PDTLIST = 12;         !  (TYC 14-Feb-89) SCS PDT LIST
literal DYN$C_SCS_BD = 13;              !  Buffer Descriptor Entry
literal DYN$C_SCS_CMNBDLT = 14;         !  Buffer Descriptor Leaf Table
literal DYN$C_CI = 97;                  !  CI PORT SPECIFIC 
literal DYN$C_CI_BDT = 1;               !  BUFFER DESCRIPTOR TABLE 
literal DYN$C_CI_FQDT = 2;              !  FREE QUE DESCRIPTOR TABLE 
literal DYN$C_LOADCODE = 98;            !  LOADABLE CODE 
literal DYN$C_NON_PAGED = 1;            !  NON PAGED CODE
literal DYN$C_PAGED = 2;                !  PAGED CODE
literal DYN$C_LC_MP = 3;                !  MULTIPROCESSOR CODE 
literal DYN$C_LC_SCS = 4;               !  SCS CODE 
literal DYN$C_LC_CLS = 5;               !  CLUSTER CODE
literal DYN$C_LC_CHREML = 6;            !  CHAR/DECIMAL INS EMUL 
literal DYN$C_LC_FPEMUL = 7;            !  FLOAT PNT EMULATOR
literal DYN$C_LC_MSCP = 8;              !  MSCP SERVER
literal DYN$C_LC_SYSL = 9;              !  SYSLOA
literal DYN$C_INIT = 99;                !  STRUCTURES SET UP BY INIT OR INIT'N ROUTINES
literal DYN$C_PCBVEC = 1;               !  PROCESS CONTROL BLOCK VECTOR 
literal DYN$C_PHVEC = 2;                !  PROCESS HEADER VECTOR 
literal DYN$C_SWPMAP = 3;               !  SWAPPER MAP 
literal DYN$C_MPWMAP = 4;               !  MODIFIED PAGE WRITER MAP 
literal DYN$C_PRCMAP = 5;               !  PROCESS BITMAP 
literal DYN$C_BOOTCB = 6;               !  BOOT CONTROL BLOCK 
literal DYN$C_CONF = 7;                 !  CONFIGURATION ARRAYS 
literal DYN$C_CST = 8;                  !  CLUSTER SYSTEM TABLE
literal DYN$C_COLOR_ARRAYS = 9;         !  PFN COLOR ARRAYS
literal DYN$C_CLASSDRV = 100;           !  CLASS DRIVER MAJOR STRUCTURE TYPE CODE 
literal DYN$C_CD_CDDB = 1;              !  CLASS DRIVER DATA BLOCK 
literal DYN$C_CD_BBRPG = 2;             !  BAD BLOCK REPLACEMENT PAGE 
literal DYN$C_CD_SHDW_WRK = 3;          !  SHADOW SET WORK BUFFER
literal DYN$C_CLU = 101;                !  CLUSTER MAJOR STRUCTURE TYPE CODE
literal DYN$C_CLU_CSB = 1;              !  CONNECTION STATUS BLOCK
literal DYN$C_CLU_CLUVEC = 2;           !  CLUSTER SYSTEM VECTOR
literal DYN$C_CLU_CLUB = 3;             !  CLUSTER BLOCK
literal DYN$C_CLU_BTX = 4;              !  CLUSTER BLOCK TRANSFER EXTENSION
literal DYN$C_CLU_CLUDCB = 5;           !  CLUSTER DISK QUORUM CONTROL BLOCK
literal DYN$C_CLU_CLUOPT = 6;           !  CLUSTER OPTIMAL RECONFIGURATION CONTEXT BLOCK
literal DYN$C_CLU_LCKDIR = 7;           !  LOCK MANAGER DISTRIBUTED DIRECTORY VECTOR
literal DYN$C_CLU_ICB = 8;              !  INCARNATION FILE CONTROL BLOCK
literal DYN$C_CLU_CLURCB = 9;           !  REMASTER CONTROL BLOCK
literal DYN$C_CLU_NTE = 10;             !  NOTIFICATION TABLE ENTRY
literal DYN$C_CLU_CSDT = 11;            !  SERVER DISPATCH TABLE
literal DYN$C_PGD = 102;                !  PAGED DYNAMIC MEMORY
literal DYN$C_PGD_F11BC = 1;            !  F11BXQP BUFFER CACHE.
literal DYN$C_KFERES = 2;               !  KFE resident sections
literal DYN$C_DECW = 103;               !  DECWINDOWS
literal DYN$C_DECW_GPB = 1;             !  GPX Packet Buffer
literal DYN$C_DECW_GPD = 2;             !  GPX Physical Data
literal DYN$C_DECW_INB = 3;             !  Input Buffer descriptor
literal DYN$C_DECW_DVI = 4;             !  Device Info block
literal DYN$C_VWS = 104;                !  UIS Structure
!  UIS subtypes
literal DYN$C_UIS_ARD = 1;              !  Allocation region 
literal DYN$C_UIS_VDB = 2;              !  Virtual display control block
literal DYN$C_UIS_WDB = 3;              !  Display window control block
literal DYN$C_UIS_SEG = 4;              !  Segment control block
literal DYN$C_UIS_ATB = 5;              !  Attribute block
literal DYN$C_UIS_OTP = 6;              !  Output primitive
literal DYN$C_UIS_APD = 7;              !  Application-specific data
literal DYN$C_UIS_SEGEND = 8;           !  Segment "end" marker (really part of SEG)
literal DYN$C_UIS_URG = 9;              !  User region AST request block
literal DYN$C_UIS_VDT = 10;             !  Display transformation
literal DYN$C_UIS_MENU = 11;            !  Window options menu or menu items
literal DYN$C_UIS_KBB = 12;             !  Virtual keyboard control block
literal DYN$C_UIS_RES = 13;             !  Resize/rescale information block
literal DYN$C_UIS_VCMD = 14;            !  Virtual color map descriptor
literal DYN$C_UIS_VCMS = 15;            !  Virtual color map section
literal DYN$C_UIS_CMSD = 16;            !  Color map segment descriptor
literal DYN$C_UIS_CMSB = 17;            !  Color map segment allocation control block
literal DYN$C_UIS_CMS = 18;             !  Color map segment
literal DYN$C_UIS_FNT = 19;             !  Font block
literal DYN$C_UIS_FNTH = 20;            !  Font header -- extra memory at head of a font
literal DYN$C_UIS_VPD = 21;             !  Viewport descriptor block
literal DYN$C_UIS_VRD = 22;             !  Viewport region descriptor
literal DYN$C_UIS_BMD = 23;             !  
literal DYN$C_UIS_OFF_MEM = 24;         !  Offscreen memory descriptor
literal DYN$C_UIS_USB = 25;             !  UIS system-wide storage
literal DYN$C_UIS_QBE = 26;             !  QVSS block extension
literal DYN$C_UIS_MEM = 27;             !  Video scanline allocation block
literal DYN$C_UIS_VSL_MEM = 28;         !  VAX scanline storage
literal DYN$C_UIS_SL_TEMP = 29;         !  Scanline temporary storage
literal DYN$C_UIS_ERROR = 30;           !  Error handler "spare" memory
!  VPS subtypes
literal DYN$C_VPS_FM = 86;              ! 
literal DYN$C_VPS_CTX = 87;             !  
literal DYN$C_VPS_PPD = 88;             !  Per-process data structure
literal DYN$C_VPS_SDB = 89;             !  Scan descriptor block
literal DYN$C_VPS_BTD = 90;             !  Bitmap descriptor
!  VWS subtypes
literal DYN$C_VWS_REGIS = 170;          !  ReGIS buffer
literal DYN$C_VWS_VT200 = 171;          !  VT200 emulator buffer
literal DYN$C_VWS_CHR_ARR = 172;        !  Character array
literal DYN$C_VWS_CLIP = 173;           !  Clipping region desc
literal DYN$C_VWS_CUR = 174;            ! 
literal DYN$C_VWS_FNTD = 175;           !  Font descriptor
literal DYN$C_VWS_SCR = 176;            ! 
literal DYN$C_VWS_UPD = 177;            ! 
literal DYN$C_VWS_UPDE = 178;           !  UPD extension
literal DYN$C_VWS_VIEW = 179;           !  Driver Viewport control block
literal DYN$C_VWS_DOP = 180;            !  Device output primative packet
literal DYN$C_VWS_GLYB = 181;           !  Glyph storage block
literal DYN$C_DSRV = 105;               !  Disk Server structure type
!  Server subtypes
literal DYN$C_DSRV_DSRV = 1;            !  Disk server structure
literal DYN$C_DSRV_HQB = 2;             !  Host Queue Block
literal DYN$C_DSRV_HRB = 3;             !  Host Request Block
literal DYN$C_DSRV_IOBUF = 4;           !  Server local I/O Buffer
literal DYN$C_DSRV_UQB = 5;             !  Unit Queue Block
literal DYN$C_DSRV_HULB = 6;            !  Host-Unit Load Block
literal DYN$C_MP = 106;                 !  MP related structure
!  MP subtypes
literal DYN$C_MP_MPB = 1;               !  Logical Console Block
literal DYN$C_MP_CPU = 2;               !  Per-CPU database
literal DYN$C_NSA = 107;                !  Non-discretionary Security Audit
literal DYN$C_NSA_EVENT = 1;            !  Event enable vectors
literal DYN$C_NSA_FAILURE = 2;          !  Failure mode vectors
literal DYN$C_NSA_ALARM = 3;            !  Security alarm packet list
literal DYN$C_CWPS = 108;               !  Cluster-Wide Process Services
!  CWPS subtypes for process control service codes
literal DYN$C_CWPS_CANWAK = 1;          !  $CANWAK service
literal DYN$C_CWPS_DELPRC = 2;          !  $DELPRC service
literal DYN$C_CWPS_FORCEX = 3;          !  $FORCEX service
literal DYN$C_CWPS_RESUME = 4;          !  $RESUME service
literal DYN$C_CWPS_SCHDWK = 5;          !  $SCHDWK service
literal DYN$C_CWPS_SETPRI = 6;          !  $SETPRI service
literal DYN$C_CWPS_SUSPND = 7;          !  $SUSPND service
literal DYN$C_CWPS_WAKE = 8;            !  $WAKE service
!  CWPS subtypes for other services
literal DYN$C_CWPS_GETJPI = 20;         !  $GETJPI service
literal DYN$C_CWPS_CREPRC = 21;         !  $CREPRC service
literal DYN$C_CWPS_TERMIN = 22;         !  process termination message
!  CWPS subtypes for security service codes
literal DYN$C_CWPS_GRANTID = 28;        !  $GRANTID service
literal DYN$C_CWPS_REVOKID = 29;        !  $WAKE service
!  CWPS subtypes for miscellaneous structures
literal DYN$C_CWPSACB = 64;             !  CWPSACB$ structure
literal DYN$C_CWPSNODI = 65;            !  CWPSNODI$ structure
literal DYN$C_CWPSSQH = 66;             !  CWPSSQH$ structure
literal DYN$C_PSCANBUF = 67;            !  PSCAN JPI buffer
literal DYN$C_PSCANCTX = 68;            !  PSCAN context
literal DYN$C_PSCANITM = 69;            !  PSCAN JPI itemlist
literal DYN$C_VP = 109;                 !  Vector processing support
!  Vector processing subtypes
literal DYN$C_VP_VCTX = 1;              !  Vector context block
literal DYN$C_VP_VEXC = 2;              !  Vector saved exception block
literal DYN$C_SHAD = 110;               !  Volume Shadowing structure type
literal DYN$C_VCC = 111;                !  VAXcluster cache
!  VCC subtypes
literal DYN$C_VCC_CL = 1;               !  Cache Line
literal DYN$C_VCC_CPT = 2;              !  Cache Page Table
literal DYN$C_VCC_HT = 3;               !  Hash Table
!  for VCC_CFCB SUBTYPE and RMOD overlap so force correct RMOD bits
literal DYN$C_VCC_CFCB = 32;            !  Cache FCB
literal DYN$C_OBSOLETE_ENS = 112;       !  Event Notification Services
!  ENS subtypes
literal DYN$C_OBSOLETE_ENS_ADB = 1;     !  AST Data Block
literal DYN$C_OBSOLETE_ENS_ECB = 2;     !  Cancelation Request Block
literal DYN$C_OBSOLETE_ENS_EDB = 3;     !  Event Declaration Block
literal DYN$C_OBSOLETE_ENS_EFD = 4;     !  Event Facility Descriptor
literal DYN$C_OBSOLETE_ENS_ENB = 5;     !  Notification Request Block
literal DYN$C_OBSOLETE_ENS_END = 6;     !  Event Notification Database Block
literal DYN$C_OBSOLETE_ENS_ENS = 7;     !  Server Base Block
literal DYN$C_OBSOLETE_ENS_EPB = 8;     !  Event Parameter Block
literal DYN$C_OBSOLETE_ENS_ETB = 9;     !  Event Tracking Block
literal DYN$C_OBSOLETE_ENS_NAB = 10;    !  NAme Block
literal DYN$C_OBSOLETE_ENS_SIG = 11;    !  Signature List Block
literal DYN$C_DDTM = 113;               !  Digital Distributed Transaction Mgr
!  DDTM subtypes
literal DYN$C_DDTM_XCB = 1;             !  Transaction Control Block
literal DYN$C_DDTM_XSCB = 2;            !  Transaction Segment Control Block
literal DYN$C_DDTM_XPCB = 3;            !  Transaction Participant Control Block
literal DYN$C_DDTM_CDCB = 4;            !  Commit Domain Control Block
literal DYN$C_DDTM_CMDB = 5;            !  Communication Manager Definition Block
literal DYN$C_DDTM_CMCB = 6;            !  Communication Manager Control Block
literal DYN$C_DDTM_RMCB = 7;            !  Resource Manager Control Block
literal DYN$C_DDTM_NDCB = 8;            !  V1 DDTM Communication Manager Block
literal DYN$C_DDTM_DGCB = 9;            !  TPCom Dialogue Control Block
literal DYN$C_DDTM_LGCB = 10;           !  Log Control Block
literal DYN$C_DDTM_NNCB = 11;           !  Node Name Cache Block
literal DYN$C_DDTM_DDTMTXT = 12;        !  DECdtm text block
!  Subtypes for the Log Manager (LM)
literal DYN$C_LM_LBDB = 13;             !  Log Buffer Descriptor Block
literal DYN$C_LM_LMLINK = 14;           !  Log Server Link Message
literal DYN$C_LM_LMOPCB = 15;           !  Parameter Block for LM$OPEN call
literal DYN$C_LM_LMRCB = 16;            !  Read Control Block
literal DYN$C_LM_LMTRCB = 17;           !  Transition Control Block
literal DYN$C_LM_LMREAD = 18;           !  Read Return
literal DYN$C_LM_LCB = 19;              !  Log Control Block
literal DYN$C_LM_LMTREE = 20;           !  TID Tree Entry
literal DYN$C_LM_LMHT = 21;             !  Hash Table
literal DYN$C_LM_LMTE = 22;             !  Hash Table Entry
!  Additional subtypes for DECdtm (DDTM)
literal DYN$C_DDTM_XTCB = 23;           !  Thread Control Block
literal DYN$C_DDTM_XTCBLW = 24;         !  "Lightweight" Thread Control Block
literal DYN$C_DDTM_STACK = 25;          !  Thread Stack Control Block
literal DYN$C_DDTM_XBID = 26;           !  Transaction Brand Id Control Block
literal DYN$C_DDTM_XSBID = 27;
literal DYN$C_DDTM_XDCB = 28;           !  Default Transaction Control Block
literal DYN$C_DDTM_XCBX = 29;           !  Transaction Control Block Extension
literal DYN$C_DDTM_XPCBX = 30;          !  Transaction Participant Control Block Extension
!  Additional subtypes for the Log Manager (LM) extended structures
literal DYN$C_LM_LMOPCBX = 31;          !  Open Control Block
literal DYN$C_LM_LMRCBX = 32;           !  Read Control Block
literal DYN$C_LM_LMTRCBX = 33;          !  Transition Control Block
literal DYN$C_SMI = 114;                !  System Management Integrator 
!  SMI subtypes
literal DYN$C_SMI_CSCB = 1;             !  Cluster/System Communications Block
literal DYN$C_SMI_CTX = 2;              !  Internal context block
literal DYN$C_SMI_SUPB = 3;             !  Server User Profile Block
literal DYN$C_SMI_RTTB = 4;             !  RouTine Table Block
literal DYN$C_TSRV = 115;               !  Tape Server structure type
!  Server subtypes
literal DYN$C_TSRV_TSRV = 1;            !  Tape server structure
literal DYN$C_TSRV_HQB = 2;             !  Host Queue Block
literal DYN$C_TSRV_HRB = 3;             !  Host Request Block
literal DYN$C_TSRV_UQB = 4;             !  Unit Queue Block
literal DYN$C_TSRV_TBUFF = 5;           !  Tape local Buffer
literal DYN$C_LAVC = 116;               !  Local Area VAX Cluster structures.
!  LAVC subtypes
literal DYN$C_LAVC_ROOT = 1;            !  ROOT block data structure.
literal DYN$C_LAVC_PORT = 2;            !  PORT block data structure.
literal DYN$C_LAVC_VC = 3;              !  Virtual Circuit data structure.
literal DYN$C_LAVC_CH = 4;              !  Channel Block data structure.
literal DYN$C_LAVC_BUS = 5;             !  BUS block data structure.
literal DYN$C_LAVC_COMP = 6;            !  Network component description data structure.
literal DYN$C_LAVC_CLST = 7;            !  Network component list data structure.
literal DYN$C_LAVC_ID_TABLE = 8;        !  Network component ID table structure.
literal DYN$C_DECNET = 117;             !  DECNET structures
! 
!   DECNET subtype definitions.  Each component gets a multiple of 8
!   entries; except the first (which gets 7 because we wanted 0 to be
!   the unknown entry).
! 
!   Note that the DECNET subtypes break the SUBTYPE NAME RESTRICTIONS
!   and the format code in SDA special cases for
!   this occurance.
! 
literal DYN$C_NET_UNK = 0;              !  Unknown subtype of zero
! 
!   Base image vectors (2-8)
! 	   
literal DYN$C_NET_NBI_NDVEC = 2;        !  Network Data Vectors
literal DYN$C_NET_NBI_NBIRV = 3;        !  Global Routine Vectors
literal DYN$C_NET_NBI_GRVH = 4;         !  Global routine init vector header
literal DYN$C_NET_NBI_GRVE = 5;         !  Global routine init vector entry
! 
!   Common trace support data structures (9-16)
! 	   
literal DYN$C_NET_CTF_TB = 9;           !  Trace block
literal DYN$C_NET_CTF_TR = 10;          !  Trace record
literal DYN$C_NET_CTF_MH = 11;          !  Module header
literal DYN$C_NET_CTF_REQ = 12;         !  Trace requests
! 
!   EMAA support structures (17-24)
! 
literal DYN$C_NET_EMAA_MRCP = 17;       !  Management request control packet
literal DYN$C_NET_EMAA_IVK = 18;        !  Invoke block
literal DYN$C_NET_EMAA_EMAA = 19;       !  Misc dynamic EMAA structures
literal DYN$C_NET_EMAA_EIB = 20;        !  Entity information block
literal DYN$C_NET_EMAA_EISDB = 21;      !  Entity semantic block
literal DYN$C_NET_EMAA_EAB = 22;        !  Entity access block
literal DYN$C_NET_EMAA_IVKIDTBL = 23;   !  Invoke Block ID Table
literal DYN$C_NET_EMAA_ERTTBL = 24;     !  Entity Registration Table
! 
!   Loader support data structures (25-32)
! 	   
literal DYN$C_NET_LDR_LIE = 25;         !  Loaded Image Entry block
! 
!   Task support data structures (33-40)
! 	   
literal DYN$C_NET_TSK_NTK = 33;         !  Network task scheduler database
literal DYN$C_NET_TSK_TCX = 34;         !  Task context block
literal DYN$C_NET_TSK_TPB = 35;         !  Task parameter block
literal DYN$C_NET_TSK_SQX = 36;         !  Scheduler queue block
literal DYN$C_NET_TSK_SCX = 37;         !  Scheduler control block
! 
!   Timer support data structures (41-48)
! 	   
literal DYN$C_NET_TIM_NTM = 41;         !  Network timer database
literal DYN$C_NET_TIM_TEB = 42;         !  Timer element block
! 
!   VCI support data structures (49-56)
! 	   
literal DYN$C_NET_VCI_VRT = 49;         !  VCI Registration Table
literal DYN$C_NET_VCI_VID = 50;         !  VCI Identification Table
literal DYN$C_NET_VCI_VCIB = 51;        !  VCI Communication Info Block
! 
!   EVL support data structures (57-64)
! 	   
literal DYN$C_NET_EVL_EVT = 57;         !  EVL Event Report
! 
! 	Itemlist support structure (65-72)
! 
literal DYN$C_NET_ITEM = 65;            !  Network Itemlist
! 
! 	Session control support structure (73-88 = 16 entries)
! 
literal DYN$C_NET_SCL_SESSID = 73;      !  Session Connection Id Table
literal DYN$C_NET_SCL_SPB = 74;         !  Session Port Block
literal DYN$C_NET_SCL_SCLSVP = 75;      !  Session VCI Port data block
literal DYN$C_NET_SCL_SCLATTR = 76;     !  Session VCI port attribute block
literal DYN$C_NET_SCL_BUFFER = 77;      !  Generic session buffer
literal DYN$C_NET_SCL_CRPROC = 78;      !  Create process block
literal DYN$C_NET_SCL_CRPROCNCB = 79;   !  Create process NCB block
literal DYN$C_NET_SCL_USER_CRPROC = 80; !  Create process usermode block
! 
!   NSP support data structures (89-96)
! 	   
literal DYN$C_NET_NSP_ATB = 89;         !  NSP Association Table
literal DYN$C_NET_NSP_TCTB = 90;        !  NSP Transport Connection Table
literal DYN$C_NET_NSP_NSP = 91;         !  NSP service blk subtype
literal DYN$C_NET_NSP_LSP = 92;         !  LSP service blk subtype
literal DYN$C_NET_NSP_RSP = 93;         !  RSP service blk subtype
literal DYN$C_NET_NSP_PORT = 94;        !  PORT service blk subtype
! 
!   LAN support data structures (97-104)
! 	   
literal DYN$C_NET_LAN_LAN = 97;         !  LAN LAN Entity Block
literal DYN$C_NET_LAN_LSB = 98;         !  LAN Station Block
literal DYN$C_NET_LAN_LPB = 99;         !  LAN Port Block
! 
!   Thread support data structures (105-112)
! 	   
literal DYN$C_NET_THREAD = 105;         !  Thread Block
! 
! 	Network Routing Layer data structures (113-144 = 32 entries)
! 
literal DYN$C_NET_NRL_NRD = 113;        !  Global database
literal DYN$C_NET_NRL_HTB = 114;        !  Hash table header
literal DYN$C_NET_NRL_CKT = 115;        !  Circuit database entry
literal DYN$C_NET_NRL_ADJ = 116;        !  Adjacency database entry
literal DYN$C_NET_NRL_PSB = 117;        !  Protocol service block
literal DYN$C_NET_NRL_TP = 118;         !  Transport database entry
literal DYN$C_NET_NRL_CKTEVT = 119;     !  Circuit event block
! 
!   Node agent data structures (145-152)
! 
literal DYN$C_NET_NODE_IDS = 145;       !  ID table header
literal DYN$C_NET_NODE_DATABASE = 146;  !  Permanent database
! 
!   OSITP support data structures (153-168 = 16 Entries)
!    
literal DYN$C_NET_OSITP_ATB = 153;      !  OSI Association Table
literal DYN$C_NET_OSITP_TCTB = 154;     !  OSI Transport Connection Table
literal DYN$C_NET_OSITP_NCCB = 155;     !  OSI Transport 
!  Network Connection Block
literal DYN$C_NET_OSITP_ILB = 156;      !  OSI Transport 
!  Itemlist Block
literal DYN$C_NET_OSITP_TLB = 157;      !  OSI Transport 
!  Timer List Block
literal DYN$C_NET_OSITP_TMP = 158;      !  OSI Transport 
!  Template Name Block
literal DYN$C_NET_OSITP_OSI = 159;      !  OSI Transport 
!  OSI Block
literal DYN$C_NET_OSITP_PORT = 160;     !  OSI Transport 
!  port Block
literal DYN$C_NET_OSITP_LSP = 161;      !  OSI Transport 
!  LSP Block
literal DYN$C_NET_OSITP_RSP = 162;      !  OSI Transport 
!  RSP Block
! 
!   QIO data structures (169-176)
!    
literal DYN$C_NET_QIO_DAB = 169;        !  Declared Application Block
literal DYN$C_NET_QIO_QLB = 170;        !  QIO Link Block
! 
!   MOP data structures (177-192)
!    
literal DYN$C_NET_MOP_MRCPIN = 177;     !  MRCP Inbound from management
literal DYN$C_NET_MOP_MRCPOUT = 178;    !  MRCP Outbound to management
literal DYN$C_NET_MOP_MANAGEMENTABORT = 179; !  Management Abort Block
literal DYN$C_NET_MOP_CPRPIN = 180;     !  Create Port Request Packet Inbound
literal DYN$C_NET_MOP_CPRPOUT = 181;    !  Create Port Request Packet Outbound
literal DYN$C_NET_MOP_DPRPIN = 182;     !  Delete Port Request Packet Inbound
literal DYN$C_NET_MOP_DPRPOUT = 183;    !  Delete Port Request Packet Outbound
literal DYN$C_NET_MOP_VCRPIN = 184;     !  VCRP Inbound from Datalink
literal DYN$C_NET_MOP_VCRPOUT = 185;    !  VCRP Outbound to Datalink
literal DYN$C_NET_MOP_ENPIN = 186;      !  Event Notification Packet Inbound
literal DYN$C_NET_MOP_ENPOUT = 187;     !  Event Notification Packet Outbound
literal DYN$C_NET_MOP_PDUOUT = 188;     !  PDU Outbound to Datalink
literal DYN$C_NET_MOP_SUBPDU = 189;     !  Sub PDU
literal DYN$C_NET_MOP_CPB = 190;        !  Console Carrier Connect Parameter Block
literal DYN$C_NET_MOP_WORK = 191;       !  Thread Work BLock
literal DYN$C_NET_MOP_TRC = 192;        !  Tracepoint substructure
literal DYN$C_NET_MOP_TIMER = 193;      !  Timer block
! 
!  End of DECNET subtype definitions
! 
literal DYN$C_PSX = 118;                !  Generic type code for Posix structures
literal DYN$C_PSX_XCTX = 1;             !  System Service Context Area
literal DYN$C_PSX_XPCB = 2;             !  Extended PCB
literal DYN$C_PSX_XSIG = 3;             !  Signal Block
literal DYN$C_PSX_PXSB = 4;             !  Session Block
literal DYN$C_PSX_PXPG = 5;             !  Process Group Block
literal DYN$C_PSX_SHSH = 6;             !  Semaphore hash table
literal DYN$C_PSX_SIDT = 7;             !  Semaphore Id table
literal DYN$C_PSX_SOB = 8;              !  semaphore Operation block
literal DYN$C_PSX_SMB = 9;              !  semaphore block
literal DYN$C_PSX_FCCB = 10;            !  fork_callbacks control block
literal DYN$C_PSX_FCDB = 11;            !  fork_callbacks dispatch block
literal DYN$C_QMAN = 119;               !  Generic type code for Queue Manager structures
literal DYN$C_QMAN_QDB = 1;             !  Queue Data block
literal DYN$C_QMAN_QMANMSG = 2;         !  Queue manager message header
literal DYN$C_QMAN_GQC = 3;             !  Queue manager GETQUI context block
literal DYN$C_SM = 120;                 !  Storage Management Subtypes
literal DYN$C_SM_MMECB = 1;             !  MME control block
literal DYN$C_SM_MCB = 2;               !  Mount context block
literal DYN$C_MISC = 121;               !  Miscellaneous types
!  Miscellaneous data structures
literal DYN$C_CRAM = 1;                 !  Controller Register Access Mailbox
literal DYN$C_CRAMH = 2;                !  Page header for CRAM
literal DYN$C_KPB = 3;                  !  Kernel Process Block
literal DYN$C_CRAB = 4;                 !  Counted resouce allocation block
literal DYN$C_CRCTX = 5;                !  Counted resouce context block
literal DYN$C_BUSARRAY = 6;             !  Bus Array
literal DYN$C_VLE = 7;                  !  Vector List Extension
literal DYN$C_CMDTABLE = 8;             !  Bus Command Table
literal DYN$C_CAR = 9;                  !  XZA/SCSI Carrier structure
literal DYN$C_QBUF = 10;                !  XZA/SCSI Q_Buffer structure
literal DYN$C_PADBLK = 11;              !  XZA/SCSI Pad Buffer structure
literal DYN$C_SGMAP = 12;               !  XZA/SCSI Scatter-Gather Map struct.
literal DYN$C_C710S = 13;               !  Cobra NCR 53C710 SCSI Port 
literal DYN$C_SPDT = 14;                !  SCSI Port Descriptor Table
literal DYN$C_SCDT = 15;                !  SCSI Connection Descriptor Table
literal DYN$C_PRCEVT = 16;              !  Process event block
literal DYN$C_PRCSTR = 17;              !  Alternate procstrt 
literal DYN$C_ECB = 18;                 !  A1742A/SCSI Enhanced Control Block struct
literal DYN$C_ASB = 19;                 !  A1742A/SCSI Status Block structure
literal DYN$C_SGL = 20;                 !  A1742A/SCSI Scatter/Gather List Struct
literal DYN$C_ICDB = 21;                !  A1742A/SCSI Init. Configuration Data Block
literal DYN$C_FDT_CONTEXT = 22;         !  FDT Context Structure
literal DYN$C_DTN = 23;                 !  Dynamic Type Name structure 
literal DYN$C_SSI_BLOCK = 24;           !  System Service Intercept Control block
literal DYN$C_IOHANDLE = 25;            !  IOHANDLE structure for platform independent mapping
literal DYN$C_STDT = 26;                !  SCSI Target Descriptor Table RCL0001
literal DYN$C_MCJ = 27;                 !  Magic Cookie Jar to hold IOHANDLEs
literal DYN$C_ISACFG = 28;              !  ISA Config Data Blocks
literal DYN$C_SCSICLS = 29;             !  SCSI Class driver random data blocks
literal DYN$C_RC = 122;                 !  Generic type code for RAID control structures
literal DYN$C_IPC = 123;                !  Generic type code for IPC structures
!  System Service Data Structure Subtypes
literal DYN$C_IPC_AB = 1;               !  Association Block
literal DYN$C_IPC_CB = 2;               !  Connection Block
literal DYN$C_IPC_IPCBUF = 3;           !  Buffer Descriptor
!  SYSIPC Data Structure Subtypes
literal DYN$C_IPC_NT = 4;               !  Name Table
literal DYN$C_IPC_TDB = 5;              !  Transport Descriptor Block
literal DYN$C_IPC_TPCB = 6;             !  Transport Control Block
literal DYN$C_IPC_LCB = 7;              !  Link Control Block
literal DYN$C_IPC_LIST = 8;             !  List (generic table) Header
literal DYN$C_IPC_PHL = 9;              !  Physical Link Block
!  Local Transport data structure subtypes
literal DYN$C_IPC_LCCB = 10;            !  Local Copy Control Block
!  DECnet NSP Transport data structure subtypes
literal DYN$C_IPC_IPC_CCB = 11;         !  ACP Channel Control Block
literal DYN$C_IPC_IPC_ACP = 12;         !  Global ACP Data Cell Block
!  SCA Transport data structure subtypes
literal DYN$C_IPC_TLTB = 13;            !  Transport Logical Link Table
literal DYN$C_IPC_TLCB = 14;            !  Transport Logical Link Control Block
literal DYN$C_IPC_TVCB = 15;            !  Transport Virtual Circuit Block
literal DYN$C_IPC_TCB = 16;             !  Transport Control Block
literal DYN$C_IPC_TPBTX = 17;           !  SCA Transport Block Transfer CDRP Extension
!  Shared data structure subtypes
literal DYN$C_IPC_IPST = 18;            !  IPST
literal DYN$C_IPC_IPLK = 19;            !  IPLK
literal DYN$C_IPC_IPB = 20;             !  IPB
literal DYN$C_IPC_IPC = 21;             !  ACP Work Block
literal DYN$C_IPC_POOL = 22;            !  Pool header - structure follows
literal DYN$C_FILE_SYSTEM = 124;        !  File system structures
literal DYN$C_SQE = 1;                  !  XQP serialization queue entry
! 
!  Dollar File system types
! 
literal DYN$C_F64 = 125;                !  Generic type code for Files-64 structures
literal DYN$C_F64_F64DATA = 1;
literal DYN$C_F64_FDB = 2;
literal DYN$C_F64_CDESC = 3;
literal DYN$C_F64_MCB = 4;
literal DYN$C_F64_DIRENTRY = 5;
literal DYN$C_F64_F64VPI_PATH = 6;
literal DYN$C_F64_F64VPI_PATHCOMP = 7;
literal DYN$C_F64_F64VPI_MCB = 8;
literal DYN$C_F64_F64VPI_FDB = 9;
literal DYN$C_FILES_64 = 126;           !  Generic type code for all Dollar facilities
! 
!  SPECIAL DYNAMIC MEMORY TYPES.  THESE ARE HANDLED SPECIALLY BY
!  EXE$DALONONPAGED.
! 
literal DYN$C_SPECIAL = 128;            !  START OF SPECIAL TYPES 
!  BASE OF 128 AND OFFSET OF 1 
literal DYN$C_SHRBUFIO = 128;           !  SHARED MEMORY BUFFERED I/O 
literal DYN$C_LNMC = 129;               !  Logical-name cache block
 
!*** MODULE $EIAFDEF ***
! +
!  EIAF - EXTENDED IMAGE ACTIVATOR FIXUP SECTION
! 
!  THE IMAGE ACTIVATOR FIXUP SECTION IS AN IMAGE SECTION THAT IS CREATED
!  BY THE LINKER AND USED BY THE IMAGE ACTIVATOR TO MODIFY THE IMAGE AS
!  IT IS ACTIVATED.  THIS IS DONE TO MAINTAIN THE POSITION INDEPENDENCE
!  OF EXTERNAL REFERENCES.
! -
literal EIAF$K_LENGTH = 84;             !  Length of fixed area (should be quadword aligned)
literal EIAF$C_LENGTH = 84;             !  Length of fixed area
literal EIAF$S_EIAFDEF = 84;
literal EIAF$S_EIAF = 84;
macro EIAF$R_VERSION = 0,0,0,0 %;
literal EIAF$S_VERSION = 8;             !  Version of this EIAF
macro EIAF$L_MAJORID = 0,0,32,0 %;      !  Major ID
macro EIAF$L_MINORID = 4,0,32,0 %;      !  Minor ID
macro EIAF$L_IAFLINK = 8,0,32,1 %;
macro EIAF$Q_IAFLINK = 8,0,0,1 %;
literal EIAF$S_IAFLINK = 8;
macro EIAF$L_FIXUPLNK = 16,0,32,1 %;
macro EIAF$Q_FIXUPLNK = 16,0,0,1 %;
literal EIAF$S_FIXUPLNK = 8;
macro EIAF$L_SIZE = 24,0,32,1 %;        !  Size of fixed part of EIAF 
macro EIAF$L_FLAGS = 28,0,32,0 %;       !  Flags 
macro EIAF$V_SHR = 28,0,1,0 %;          !  This is in a shareable image 
macro EIAF$L_QRELFIXOFF = 32,0,32,1 %;  !  Offset to quadword relocation fixup data
macro EIAF$L_LRELFIXOFF = 36,0,32,1 %;  !  Offset to longword relocation fixup data
macro EIAF$L_QDOTADROFF = 40,0,32,1 %;  !  Offset to quadword .address fixup data
macro EIAF$L_LDOTADROFF = 44,0,32,1 %;  !  Offset to longword .address fixup data
macro EIAF$L_CODEADROFF = 48,0,32,1 %;  !  Offset to code address fixup data
macro EIAF$L_LPFIXOFF = 52,0,32,1 %;    !  Offset to linkage pair fixup data
macro EIAF$L_CHGPRTOFF = 56,0,32,1 %;   !  Offset to isect change prot. data 
macro EIAF$L_SHLSTOFF = 60,0,32,1 %;    !  Offset to shareable image list 
macro EIAF$L_SHRIMGCNT = 64,0,32,1 %;   !  Number of shareable images in shlst 
macro EIAF$L_SHLEXTRA = 68,0,32,1 %;    !  Number of extra shareable images allowed 
macro EIAF$L_PERMCTX = 72,0,32,1 %;     !  Permanent sharable image context 
macro EIAF$L_BASE_VA = 76,0,32,1 %;     !  Base address of the image itself
macro EIAF$L_LPPSBFIXOFF = 80,0,32,1 %; !  Offset to "linkage pair with procedure signature" fixups
 
!*** MODULE $EICPDEF ***
! +
!  EICP - EXTENDED CHANGE IMAGE SECTION PROTECTION DATA
! 
!  THIS STRUCTURE IS USED IN THE IMAGE FIXUP SECTION BY THE LINKER
!  TO INFORM THE IMAGE ACTIVATOR OF THE IMAGE SECTIONS THAT NEED
!  THEIR PROTECTION CHANGED.
! -
literal EICP$K_LENGTH = 16;             !  size of one section's data 
literal EICP$C_LENGTH = 16;             !  size of one section's data 
literal EICP$S_EICPDEF = 16;
literal EICP$S_EICP = 16;
macro EICP$L_BASEVA = 0,0,32,0 %;
macro EICP$Q_BASEVA = 0,0,0,0 %;
literal EICP$S_BASEVA = 8;
macro EICP$L_SIZE = 8,0,32,0 %;         !  size in bytes of the image section
macro EICP$L_NEWPRT = 12,0,32,0 %;      !  new protection 
 
!*** MODULE $EIHADEF ***
! +
!  EXTENDED IMAGE HEADER ACTIVATION SECTION OFFSETS
! -
literal EIHA$K_LENGTH = 48;             ! SIZE OF ACTIVATION SECTION 
literal EIHA$C_LENGTH = 48;             ! SIZE OF ACTIVATION SECTION 
literal EIHA$S_EIHADEF = 48;
literal EIHA$S_EIHA = 48;
macro EIHA$L_SIZE = 0,0,32,0 %;         !  Size in bytes of EIHA(#transfers = size/8)
macro EIHA$L_SPARE = 4,0,32,0 %;        !  Spare
macro EIHA$Q_TFRADR1 = 8,0,0,0 %;
literal EIHA$S_TFRADR1 = 8;
macro EIHA$L_TFRADR1 = 8,0,32,0 %;
macro EIHA$L_TFRADR1_H = 12,0,32,0 %;
macro EIHA$Q_TFRADR2 = 16,0,0,0 %;
literal EIHA$S_TFRADR2 = 8;
macro EIHA$L_TFRADR2 = 16,0,32,0 %;
macro EIHA$L_TFRADR2_H = 20,0,32,0 %;
macro EIHA$Q_TFRADR3 = 24,0,0,0 %;
literal EIHA$S_TFRADR3 = 8;
macro EIHA$L_TFRADR3 = 24,0,32,0 %;
macro EIHA$L_TFRADR3_H = 28,0,32,0 %;
macro EIHA$Q_TFRADR4 = 32,0,0,0 %;
literal EIHA$S_TFRADR4 = 8;
macro EIHA$L_TFRADR4 = 32,0,32,0 %;
macro EIHA$L_TFRADR4_H = 36,0,32,0 %;
macro EIHA$L_INISHR = 40,0,32,0 %;      ! (valid if IHD$V_INISHR set)
macro EIHA$Q_INISHR = 40,0,0,0 %;
literal EIHA$S_INISHR = 8;
 
!*** MODULE $EIHDDEF ***
! +
!  EXTENDED IMAGE HEADER RECORD DEFINITIONS - FIRST RECORD OF THE EXTENDED IMAGE HEADER
! -
literal EIHD$K_MAJORID = 3;             !  Major id constant
literal EIHD$K_MINORID = 0;             !  Minor id constant
literal EIHD$K_EXE = 1;                 !  Executable image 
literal EIHD$K_LIM = 2;                 !  Linkable image 
literal EIHD$C_MINCODE = 0;             !  Low bound of ALIAS values
literal EIHD$C_NATIVE = 0;              !  Alpha native mode image
literal EIHD$C_CLI = 1;                 !  Image is a CLI, run LOGINOUT
literal EIHD$C_MAXCODE = 1;             !  High bound of ALIAS values
literal EIHD$M_LNKDEBUG = %X'1';
literal EIHD$M_LNKNOTFR = %X'2';
literal EIHD$M_NOP0BUFS = %X'4';
literal EIHD$M_PICIMG = %X'8';
literal EIHD$M_P0IMAGE = %X'10';
literal EIHD$M_DBGDMT = %X'20';
literal EIHD$M_INISHR = %X'40';
literal EIHD$M_XLATED = %X'80';
literal EIHD$M_BIND_CODE_SEC = %X'100';
literal EIHD$M_BIND_DATA_SEC = %X'200';
literal EIHD$K_LENGTH = 104;            !  Length of fixed area 
literal EIHD$C_LENGTH = 104;            !  Length of fixed area 
literal EIHD$K_ALIAS_MINCODE = -1;      !  Low bound of ALIAS values
!   Following are reserved but not used by the Alpha linker
literal EIHD$K_VAX = -1;                !  Native mode image
literal EIHD$K_RSX = 0;                 !  RSX image produced by TKB
literal EIHD$K_BPA = 1;                 !  BASIC plus analog
literal EIHD$K_ALIAS = 2;               !  Last 126 bytes contains ASCIC of image to activate
literal EIHD$K_VAX_CLI = 3;             !  Image is a CLI, run LOGINOUT
literal EIHD$K_PMAX = 4;                !  PMAX system image
!   Alpha linker writes this value into last word of 1st header block for system images only
literal EIHD$K_ALPHA = 5;
literal EIHD$K_ALIAS_MAXCODE = 5;       !  High bound of ALIAS values
literal EIHD$S_EIHDDEF = 512;           !  Old size name - synonym
literal EIHD$S_EIHD = 512;
macro EIHD$R_VERSION = 0,0,0,0 %;
literal EIHD$S_VERSION = 8;             !  Version of this EIHD
macro EIHD$L_MAJORID = 0,0,32,0 %;      !  Major id 
macro EIHD$L_MINORID = 4,0,32,0 %;      !  Minor id 
macro EIHD$L_SIZE = 8,0,32,0 %;         !  Size in bytes of image header 
macro EIHD$L_ISDOFF = 12,0,32,0 %;      !  Byte offset to ISD list 
macro EIHD$L_ACTIVOFF = 16,0,32,0 %;    !  Byte offset to activation data 
macro EIHD$L_SYMDBGOFF = 20,0,32,0 %;   !  Byte offset to symbol table and debug data 
macro EIHD$L_IMGIDOFF = 24,0,32,0 %;    !  Byte offset to image ident data 
macro EIHD$L_PATCHOFF = 28,0,32,0 %;    !  Byte offset to patch data 
macro EIHD$L_IAFVA = 32,0,32,1 %;
macro EIHD$Q_IAFVA = 32,0,0,1 %;
literal EIHD$S_IAFVA = 8;
macro EIHD$L_SYMVVA = 40,0,32,1 %;
macro EIHD$Q_SYMVVA = 40,0,0,1 %;
literal EIHD$S_SYMVVA = 8;
macro EIHD$L_VERSION_ARRAY_OFF = 48,0,32,0 %; !  Byte offset to version number array
macro EIHD$L_IMGTYPE = 52,0,32,0 %;     !  Image type 
! 
!  IMAGE TYPE CODES
! 
macro EIHD$L_SUBTYPE = 56,0,32,0 %;     !  Code to use secondary image name
! *****************************************
! 
!   Define legal range of SUBTYPE constants. MINCODE must be equal to the
! 	lowest value and MAXCODE must be equal to the highest value.
! 
macro EIHD$L_IMGIOCNT = 60,0,32,0 %;    !  size in bytes of image i/o section requested 
! 0 if default
macro EIHD$L_IOCHANCNT = 64,0,32,0 %;   !  # channels requested
macro EIHD$Q_PRIVREQS = 68,0,0,0 %;
literal EIHD$S_PRIVREQS = 8;            !  requested privelege mask
macro EIHD$L_HDRBLKCNT = 76,0,32,0 %;   !  # header diskblocks
macro EIHD$R_LNKFLAGS_OVERLAY = 80,0,32,0 %;
macro EIHD$L_LNKFLAGS = 80,0,32,0 %;    !  Linker produced image flags 
macro EIHD$R_LNKFLAGS_BITS = 80,0,16,0 %;
macro EIHD$V_LNKDEBUG = 80,0,1,0 %;     !  Full debugging requested 
macro EIHD$V_LNKNOTFR = 80,1,1,0 %;     !  First transfer address missing 
macro EIHD$V_NOP0BUFS = 80,2,1,0 %;     !  RMS use of P0 for image i/o disabled 
macro EIHD$V_PICIMG = 80,3,1,0 %;       !  Image is position independent 
macro EIHD$V_P0IMAGE = 80,4,1,0 %;      !  Image is in P0 space only 
macro EIHD$V_DBGDMT = 80,5,1,0 %;       !  Image header has dmt fields
macro EIHD$V_INISHR = 80,6,1,0 %;       !  Transfer array contains valid IHA$L_INISHR
macro EIHD$V_XLATED = 80,7,1,0 %;       !  Translated image
macro EIHD$V_BIND_CODE_SEC = 80,8,1,0 %; !  EXE image sections can be put into S0 if set
macro EIHD$V_BIND_DATA_SEC = 80,9,1,0 %; !  DATA image sections can be put into S0 if set
macro EIHD$L_IDENT = 84,0,32,0 %;       !  GBL SEC ident value for linkable image 
macro EIHD$L_SYSVER = 88,0,32,0 %;      !  SYS$K_VERSION or 0 if not linked with exec 
macro EIHD$R_CONTROL = 92,0,0,0 %;
literal EIHD$S_CONTROL = 12;            !  Linker control fields
macro EIHD$B_MATCHCTL = 92,0,8,0 %;     !  Linker match control
macro EIHD$B_FILL_1 = 93,0,8,0 %;       !  Spares
macro EIHD$B_FILL_2 = 94,0,8,0 %;       !  Spares
macro EIHD$B_FILL_3 = 95,0,8,0 %;       !  Spares
macro EIHD$L_SYMVECT_SIZE = 96,0,32,0 %; !  Size of the symbol vector in bytes
macro EIHD$L_VIRT_MEM_BLOCK_SIZE = 100,0,32,0 %; !  Virtual memory size used for link (value given to /BPAGE, power of 2
!                                     from 9 to 16)
macro EIHD$T_SKIP = 104,0,0,0 %;
literal EIHD$S_SKIP = 406;              !  ALIAS is last word in 512 byte block of system image
macro EIHD$W_ALIAS = 510,0,16,0 %;      !  CODE identifies image type to MOM
! *****************************************
! 
!   Define legal range of ALIAS constants. ALIAS_MINCODE must be equal to the
! 	lowest value and ALIAS_MAXCODE must be equal to the highest value.
! 
 
!*** MODULE $EIHIDEF ***
! +
!  EXTENDED IMAGE HEADER IDENTIFICATION SECTION OFFSETS
! -
literal EIHI$K_MAJORID = 1;
literal EIHI$K_MINORID = 2;
literal EIHI$K_LENGTH = 104;            ! LENGTH OF IMAGE HEADER IDENT SECTION 
literal EIHI$C_LENGTH = 104;            ! LENGTH OF IMAGE HEADER IDENT SECTION 
literal EIHI$S_EIHIDEF = 104;           !  Old size name - synonym
literal EIHI$S_EIHI = 104;
macro EIHI$R_VERSION = 0,0,0,0 %;
literal EIHI$S_VERSION = 8;             !  Version of this EIHP
macro EIHI$L_MAJORID = 0,0,32,0 %;      !  Major ID
macro EIHI$L_MINORID = 4,0,32,0 %;      !  Minor ID
macro EIHI$Q_LINKTIME = 8,0,0,0 %;
literal EIHI$S_LINKTIME = 8;            ! DATE AND TIME THIS IMAGE WAS LINKED 
! STANDARD SYSTEM QUADWORD FORMAT
macro EIHI$T_IMGNAM = 16,0,0,0 %;
literal EIHI$S_IMGNAM = 40;             ! IMAGE NAME STRING 
macro EIHI$T_IMGID = 56,0,0,0 %;
literal EIHI$S_IMGID = 16;              ! IMAGE IDENT STRING 
macro EIHI$T_LINKID = 72,0,0,0 %;
literal EIHI$S_LINKID = 16;             ! LINKER IDENT STRING 
macro EIHI$T_IMGBID = 88,0,0,0 %;
literal EIHI$S_IMGBID = 16;             ! IMAGE BUILD IDENT STRING 
 
!*** MODULE $EIHPDEF ***
! +
!  EXTENDED IMAGE HEADER PATCH SECTION OFFSETS
! -
literal EIHP$K_LENGTH = 60;             ! LENGTH OF PATCH HEADER SECTION 
literal EIHP$C_LENGTH = 60;             ! LENGTH OF PATCH HEADER SECTION 
literal EIHP$S_EIHPDEF = 60;
literal EIHP$S_EIHP = 60;
macro EIHP$R_VERSION = 0,0,0,0 %;
literal EIHP$S_VERSION = 8;             !  Version of this EIHP
macro EIHP$L_MAJORID = 0,0,32,0 %;      !  Major ID
macro EIHP$L_MINORID = 4,0,32,0 %;      !  Minor ID
macro EIHP$L_ECO1 = 8,0,32,0 %;         ! DEC ECO LEVELS 1-32 
macro EIHP$L_ECO2 = 12,0,32,0 %;        ! DEC ECO LEVELS 33-64 
macro EIHP$L_ECO3 = 16,0,32,0 %;        ! DEC ECO LEVELS 65-98 
macro EIHP$L_ECO4 = 20,0,32,0 %;        ! USER ECO LEVELS 99-132 
macro EIHP$L_PATCOMTXT = 24,0,32,0 %;   ! PATCH COMMAND TEXT VIRTUAL BLOCK NUMBER 
macro EIHP$L_RW_PATSIZ = 28,0,32,0 %;   ! SIZE OF FREE RW PATCH AREA 
macro EIHP$L_RW_PATADR = 32,0,32,0 %;
macro EIHP$Q_RW_PATADR = 32,0,0,0 %;
literal EIHP$S_RW_PATADR = 8;
macro EIHP$L_RO_PATSIZ = 40,0,32,0 %;   ! SIZE OF FREE RO PATCH AREA 
macro EIHP$L_RO_PATADR = 44,0,32,0 %;
macro EIHP$Q_RO_PATADR = 44,0,0,0 %;
literal EIHP$S_RO_PATADR = 8;
macro EIHP$Q_PATDATE = 52,0,0,0 %;
literal EIHP$S_PATDATE = 8;             ! DATE OF MOST RECENT PATCH 
 
!*** MODULE $EIHSDEF ***
! +
!  IMAGE HEADER SYMBOL TABLE AND DEBUG SECTION OFFSETS
! -
literal EIHS$K_MAJORID = 1;
literal EIHS$K_MINORID = 1;
literal EIHS$K_LENGTH = 32;             ! LENGTH OF SYMBOL TABLE SECTION 
literal EIHS$C_LENGTH = 32;             ! LENGTH OF SYMBOL TABLE SECTION 
literal EIHS$S_EIHSDEF = 32;
literal EIHS$S_EIHS = 32;
macro EIHS$R_VERSION = 0,0,0,0 %;
literal EIHS$S_VERSION = 8;             !  Version of this EIHP
macro EIHS$L_MAJORID = 0,0,32,0 %;      !  Major ID
macro EIHS$L_MINORID = 4,0,32,0 %;      !  Minor ID
macro EIHS$L_DSTVBN = 8,0,32,0 %;       ! DEBUG SYMBOL TABLE VIRTUAL BLOCK NUMBER 
macro EIHS$L_DSTSIZE = 12,0,32,0 %;     ! DEBUG SYMBOL SIZE IN BYTES
macro EIHS$L_GSTVBN = 16,0,32,0 %;      ! GLOBAL SYMBOL TABLE VIRTUAL BLOCK NUMBER 
macro EIHS$L_GSTSIZE = 20,0,32,0 %;     ! GLOBAL SYMBOL TABLE RECORD COUNT 
macro EIHS$L_DMTVBN = 24,0,32,0 %;      ! VBN OF DMT INFORMATION
macro EIHS$L_DMTBYTES = 28,0,32,0 %;    ! LENGTH OF DMT INFO
 
!*** MODULE $EIHVNDEF ***
literal EIHVN$M_SUBVERSION_MINOR_ID = %X'FFFF';
literal EIHVN$M_SUBVERSION_MAJOR_ID = %X'FFFF0000';
literal EIHVN$S_EIMG_VERSION_ARRAY = 8;
macro EIHVN$L_SUBSYSTEM_MASK = 0,0,32,0 %; !  Bit mask of nonzero version numbers
macro EIHVN$L_SUBVERSION_ARRAY = 4,0,32,0 %; !  First array element
macro EIHVN$V_SUBVERSION_MINOR_ID = 4,0,16,0 %;
literal EIHVN$S_SUBVERSION_MINOR_ID = 16; !  Minor ID for each component
macro EIHVN$V_SUBVERSION_MAJOR_ID = 4,16,16,0 %;
literal EIHVN$S_SUBVERSION_MAJOR_ID = 16; !  Major ID for each component
literal EIHVN$M_VERSION_MINOR_ID = %X'FFFFFF';
literal EIHVN$M_VERSION_MAJOR_ID = %X'FF000000';
literal EIHVN$S_EIMG_OVERALL_VERSION = 4;
macro EIHVN$V_VERSION_MINOR_ID = 0,0,24,0 %;
literal EIHVN$S_VERSION_MINOR_ID = 24;  !  Minor ID of SYS.STB
macro EIHVN$V_VERSION_MAJOR_ID = 0,24,8,0 %;
literal EIHVN$S_VERSION_MAJOR_ID = 8;   !  Major ID of SYS.STB
literal EIHVN$K_LENGTH = 132;
literal EIHVN$C_LENGTH = 132;
 
!*** MODULE $EISABUSDEF ***
! 
!  This file describes the layout of EISA CSR space.  It is based
!  on the EISA spec, V3.10 BCPR Service, INC.
! 
literal EISA$M_PIC_L_ICW1_ICW4 = %X'1';
literal EISA$M_PIC_L_ICW1_SNGL = %X'2';
literal EISA$M_PIC_L_OCW2_L0 = %X'1';
literal EISA$M_PIC_L_OCW2_L1 = %X'2';
literal EISA$M_PIC_L_OCW2_L2 = %X'4';
literal EISA$M_PIC_L_OCW2_EOI = %X'20';
literal EISA$M_PIC_L_OCW2_SL = %X'40';
literal EISA$M_PIC_L_OCW2_R = %X'80';
literal EISA$M_PIC_L_OCW3_RIS = %X'1';
literal EISA$M_PIC_L_OCW3_RR = %X'2';
literal EISA$M_PIC_L_OCW3_P = %X'4';
literal EISA$M_PIC_L_OCW3_SMM = %X'20';
literal EISA$M_PIC_L_OCW3_ESMM = %X'40';
literal EISA$M_PIC_L_ICW2_ZEROES = %X'7';
literal EISA$M_PIC_L_ICW2_VEC = %X'F8';
literal EISA$M_PIC_L_ICW3_IRQ0_SLAVE = %X'1';
literal EISA$M_PIC_L_ICW3_IRQ1_SLAVE = %X'2';
literal EISA$M_PIC_L_ICW3_IRQ2_SLAVE = %X'4';
literal EISA$M_PIC_L_ICW3_IRQ3_SLAVE = %X'8';
literal EISA$M_PIC_L_ICW3_IRQ4_SLAVE = %X'10';
literal EISA$M_PIC_L_ICW3_IRQ5_SLAVE = %X'20';
literal EISA$M_PIC_L_ICW3_IRQ6_SLAVE = %X'40';
literal EISA$M_PIC_L_ICW3_IRQ7_SLAVE = %X'80';
literal EISA$M_PIC_L_ICW4_MODE = %X'1';
literal EISA$M_PIC_L_ICW4_AEOI = %X'2';
literal EISA$M_PIC_L_ICW4_BUFF = %X'18';
literal EISA$M_PIC_L_ICW4_NEST = %X'20';
literal EISA$M_PIC_L_OCW1_MASK = %X'FF';
literal EISA$M_PIC_L_T1_SYSTIM_BCD = %X'1';
literal EISA$M_PIC_L_T1_SYSTIM_MODE = %X'E';
literal EISA$M_PIC_L_T1_SYSTIM_RW = %X'30';
literal EISA$M_PIC_L_T1_SYSTIM_STAT = %X'40';
literal EISA$M_PIC_L_T1_SYSTIM_OUT = %X'80';
literal EISA$M_PIC_L_T1_REF_BCD = %X'1';
literal EISA$M_PIC_L_T1_REF_MODE = %X'E';
literal EISA$M_PIC_L_T1_REF_RW = %X'30';
literal EISA$M_PIC_L_T1_REF_STAT = %X'40';
literal EISA$M_PIC_L_T1_REF_OUT = %X'80';
literal EISA$M_PIC_L_T1_SPKR_BCD = %X'1';
literal EISA$M_PIC_L_T1_SPKR_MODE = %X'E';
literal EISA$M_PIC_L_T1_SPKR_RW = %X'30';
literal EISA$M_PIC_L_T1_SPKR_STAT = %X'40';
literal EISA$M_PIC_L_T1_SPKR_OUT = %X'80';
literal EISA$M_PIC_L_T1_CTRL_BCD = %X'1';
literal EISA$M_PIC_L_T1_CTRL_MODE = %X'E';
literal EISA$M_PIC_L_T1_CTRL_CNTLAT = %X'30';
literal EISA$M_PIC_L_T1_CTRL_CNTSEL = %X'C0';
literal EISA$M_PIC_L_T2_FLSF_BCD = %X'1';
literal EISA$M_PIC_L_T2_FLSF_MODE = %X'E';
literal EISA$M_PIC_L_T2_FLSF_RW = %X'30';
literal EISA$M_PIC_L_T2_FLSF_STAT = %X'40';
literal EISA$M_PIC_L_T2_FLSF_OUT = %X'80';
literal EISA$M_PIC_L_T2_CPUSPD_BCD = %X'1';
literal EISA$M_PIC_L_T2_CPUSPD_MODE = %X'E';
literal EISA$M_PIC_L_T2_CPUSPD_RW = %X'30';
literal EISA$M_PIC_L_T2_CPUSPD_STAT = %X'40';
literal EISA$M_PIC_L_T2_CPUSPD_OUT = %X'80';
literal EISA$M_PIC_L_T2_CTRL_BCD = %X'1';
literal EISA$M_PIC_L_T2_CTRL_MODE = %X'E';
literal EISA$M_PIC_L_T2_CTRL_CNTLAT = %X'30';
literal EISA$M_PIC_L_T2_CTRL_CNTSEL = %X'C0';
literal EISA$M_PIC_L_NMICSR_T1 = %X'1';
literal EISA$M_PIC_L_NMICSR_SPKR = %X'2';
literal EISA$M_PIC_L_NMICSR_PE = %X'4';
literal EISA$M_PIC_L_NMICSR_IOCHK = %X'8';
literal EISA$M_PIC_L_NMICSR_REF = %X'10';
literal EISA$M_PIC_L_NMICSR_INTM1 = %X'20';
literal EISA$M_PIC_L_NMICSR_NMIINT = %X'40';
literal EISA$M_PIC_L_NMICSR_PAR = %X'80';
literal EISA$M_PIC_L_NMIRTC_CLKADR = %X'7F';
literal EISA$M_PIC_L_NMIRTC_ENDIS = %X'80';
literal EISA$M_PIC_H_ICW1_ICW4 = %X'1';
literal EISA$M_PIC_H_ICW1_SNGL = %X'2';
literal EISA$M_PIC_H_OCW2_L0 = %X'1';
literal EISA$M_PIC_H_OCW2_L1 = %X'2';
literal EISA$M_PIC_H_OCW2_L2 = %X'4';
literal EISA$M_PIC_H_OCW2_EOI = %X'20';
literal EISA$M_PIC_H_OCW2_SL = %X'40';
literal EISA$M_PIC_H_OCW2_R = %X'80';
literal EISA$M_PIC_H_OCW3_RIS = %X'1';
literal EISA$M_PIC_H_OCW3_RR = %X'2';
literal EISA$M_PIC_H_OCW3_P = %X'4';
literal EISA$M_PIC_H_OCW3_SMM = %X'20';
literal EISA$M_PIC_H_OCW3_ESMM = %X'40';
literal EISA$M_PIC_H_ICW2_ZEROES = %X'7';
literal EISA$M_PIC_H_ICW2_VEC = %X'F8';
literal EISA$M_PIC_H_ICW3_IRQ0_SLAVE = %X'1';
literal EISA$M_PIC_H_ICW3_IRQ1_SLAVE = %X'2';
literal EISA$M_PIC_H_ICW3_IRQ2_SLAVE = %X'4';
literal EISA$M_PIC_H_ICW3_IRQ3_SLAVE = %X'8';
literal EISA$M_PIC_H_ICW3_IRQ4_SLAVE = %X'10';
literal EISA$M_PIC_H_ICW3_IRQ5_SLAVE = %X'20';
literal EISA$M_PIC_H_ICW3_IRQ6_SLAVE = %X'40';
literal EISA$M_PIC_H_ICW3_IRQ7_SLAVE = %X'80';
literal EISA$M_PIC_H_ICW4_MODE = %X'1';
literal EISA$M_PIC_H_ICW4_AEOI = %X'2';
literal EISA$M_PIC_H_ICW4_BUFF = %X'18';
literal EISA$M_PIC_H_ICW4_NEST = %X'20';
literal EISA$M_PIC_H_OCW1_MASK = %X'FF';
literal EISA$M_PIC_EXNMICSR_BUSRST = %X'1';
literal EISA$M_PIC_EXNMICSR_ENIO = %X'2';
literal EISA$M_PIC_EXNMICSR_FSEN = %X'4';
literal EISA$M_PIC_EXNMICSR_TOEN = %X'8';
literal EISA$M_PIC_EXNMICSR_IOP = %X'20';
literal EISA$M_PIC_EXNMICSR_BT = %X'40';
literal EISA$M_PIC_EXNMICSR_FSINT = %X'80';
literal EISA$M_PIC_EISA_BUSMAS_SL1 = %X'1';
literal EISA$M_PIC_EISA_BUSMAS_SL2 = %X'2';
literal EISA$M_PIC_EISA_BUSMAS_SL3 = %X'4';
literal EISA$M_PIC_EISA_BUSMAS_SL4 = %X'8';
literal EISA$M_PIC_EISA_BUSMAS_SL5 = %X'10';
literal EISA$M_PIC_EISA_BUSMAS_SL6 = %X'20';
literal EISA$M_PIC_EISA_BUSMAS_SL7 = %X'40';
literal EISA$M_PIC_CTRL1_EDGE_INT3 = %X'8';
literal EISA$M_PIC_CTRL1_EDGE_INT4 = %X'10';
literal EISA$M_PIC_CTRL1_EDGE_INT5 = %X'20';
literal EISA$M_PIC_CTRL1_EDGE_INT6 = %X'40';
literal EISA$M_PIC_CTRL1_EDGE_INT7 = %X'80';
literal EISA$M_PIC_CTRL2_EDGE_INT9 = %X'2';
literal EISA$M_PIC_CTRL2_EDGE_INT10 = %X'4';
literal EISA$M_PIC_CTRL2_EDGE_INT11 = %X'8';
literal EISA$M_PIC_CTRL2_EDGE_INT12 = %X'10';
literal EISA$M_PIC_CTRL2_EDGE_INT14 = %X'40';
literal EISA$M_PIC_CTRL2_EDGE_INT15 = %X'80';
literal EISA$M_SLOT1_PID_CHAR2 = %X'3';
literal EISA$M_SLOT1_PID_CHAR1 = %X'7C';
literal EISA$M_SLOT1_PID_CHAR3 = %X'1F00';
literal EISA$M_SLOT1_PID_CHAR2_CONT = %X'E000';
literal EISA$M_SLOT1_PID_PROD_NUM1 = %X'F0000';
literal EISA$M_SLOT1_PID_PROD_NUM2 = %X'F00000';
literal EISA$M_SLOT1_PID_REV_NUM1 = %X'F000000';
literal EISA$M_SLOT1_PID_PROD_NUM3 = %X'F0000000';
literal EISA$M_SLOT2_PID_CHAR2 = %X'3';
literal EISA$M_SLOT2_PID_CHAR1 = %X'7C';
literal EISA$M_SLOT2_PID_CHAR3 = %X'1F00';
literal EISA$M_SLOT2_PID_CHAR2_CONT = %X'E000';
literal EISA$M_SLOT2_PID_PROD_NUM1 = %X'F0000';
literal EISA$M_SLOT2_PID_PROD_NUM2 = %X'F00000';
literal EISA$M_SLOT2_PID_REV_NUM1 = %X'F000000';
literal EISA$M_SLOT2_PID_PROD_NUM3 = %X'F0000000';
literal EISA$M_SLOT3_PID_CHAR2 = %X'3';
literal EISA$M_SLOT3_PID_CHAR1 = %X'7C';
literal EISA$M_SLOT3_PID_CHAR3 = %X'1F00';
literal EISA$M_SLOT3_PID_CHAR2_CONT = %X'E000';
literal EISA$M_SLOT3_PID_PROD_NUM1 = %X'F0000';
literal EISA$M_SLOT3_PID_PROD_NUM2 = %X'F00000';
literal EISA$M_SLOT3_PID_REV_NUM1 = %X'F000000';
literal EISA$M_SLOT3_PID_PROD_NUM3 = %X'F0000000';
literal EISA$M_SLOT4_PID_CHAR2 = %X'3';
literal EISA$M_SLOT4_PID_CHAR1 = %X'7C';
literal EISA$M_SLOT4_PID_CHAR3 = %X'1F00';
literal EISA$M_SLOT4_PID_CHAR2_CONT = %X'E000';
literal EISA$M_SLOT4_PID_PROD_NUM1 = %X'F0000';
literal EISA$M_SLOT4_PID_PROD_NUM2 = %X'F00000';
literal EISA$M_SLOT4_PID_REV_NUM1 = %X'F000000';
literal EISA$M_SLOT4_PID_PROD_NUM3 = %X'F0000000';
literal EISA$M_SLOT5_PID_CHAR2 = %X'3';
literal EISA$M_SLOT5_PID_CHAR1 = %X'7C';
literal EISA$M_SLOT5_PID_CHAR3 = %X'1F00';
literal EISA$M_SLOT5_PID_CHAR2_CONT = %X'E000';
literal EISA$M_SLOT5_PID_PROD_NUM1 = %X'F0000';
literal EISA$M_SLOT5_PID_PROD_NUM2 = %X'F00000';
literal EISA$M_SLOT5_PID_REV_NUM1 = %X'F000000';
literal EISA$M_SLOT5_PID_PROD_NUM3 = %X'F0000000';
literal EISA$M_SLOT6_PID_CHAR2 = %X'3';
literal EISA$M_SLOT6_PID_CHAR1 = %X'7C';
literal EISA$M_SLOT6_PID_CHAR3 = %X'1F00';
literal EISA$M_SLOT6_PID_CHAR2_CONT = %X'E000';
literal EISA$M_SLOT6_PID_PROD_NUM1 = %X'F0000';
literal EISA$M_SLOT6_PID_PROD_NUM2 = %X'F00000';
literal EISA$M_SLOT6_PID_REV_NUM1 = %X'F000000';
literal EISA$M_SLOT6_PID_PROD_NUM3 = %X'F0000000';
literal EISA$M_SLOT7_PID_CHAR2 = %X'3';
literal EISA$M_SLOT7_PID_CHAR1 = %X'7C';
literal EISA$M_SLOT7_PID_CHAR3 = %X'1F00';
literal EISA$M_SLOT7_PID_CHAR2_CONT = %X'E000';
literal EISA$M_SLOT7_PID_PROD_NUM1 = %X'F0000';
literal EISA$M_SLOT7_PID_PROD_NUM2 = %X'F00000';
literal EISA$M_SLOT7_PID_REV_NUM1 = %X'F000000';
literal EISA$M_SLOT7_PID_PROD_NUM3 = %X'F0000000';
literal EISA$M_SLOT8_PID_CHAR2 = %X'3';
literal EISA$M_SLOT8_PID_CHAR1 = %X'7C';
literal EISA$M_SLOT8_PID_CHAR3 = %X'1F00';
literal EISA$M_SLOT8_PID_CHAR2_CONT = %X'E000';
literal EISA$M_SLOT8_PID_PROD_NUM1 = %X'F0000';
literal EISA$M_SLOT8_PID_PROD_NUM2 = %X'F00000';
literal EISA$M_SLOT8_PID_REV_NUM1 = %X'F000000';
literal EISA$M_SLOT8_PID_PROD_NUM3 = %X'F0000000';
literal EISA$M_SLOT9_PID_CHAR2 = %X'3';
literal EISA$M_SLOT9_PID_CHAR1 = %X'7C';
literal EISA$M_SLOT9_PID_CHAR3 = %X'1F00';
literal EISA$M_SLOT9_PID_CHAR2_CONT = %X'E000';
literal EISA$M_SLOT9_PID_PROD_NUM1 = %X'F0000';
literal EISA$M_SLOT9_PID_PROD_NUM2 = %X'F00000';
literal EISA$M_SLOT9_PID_REV_NUM1 = %X'F000000';
literal EISA$M_SLOT9_PID_PROD_NUM3 = %X'F0000000';
literal EISA$M_SLOT10_PID_CHAR2 = %X'3';
literal EISA$M_SLOT10_PID_CHAR1 = %X'7C';
literal EISA$M_SLOT10_PID_CHAR3 = %X'1F00';
literal EISA$M_SLOT10_PID_CHAR2_CONT = %X'E000';
literal EISA$M_SLOT10_PID_PROD_NUM1 = %X'F0000';
literal EISA$M_SLOT10_PID_PROD_NUM2 = %X'F00000';
literal EISA$M_SLOT10_PID_REV_NUM1 = %X'F000000';
literal EISA$M_SLOT10_PID_PROD_NUM3 = %X'F0000000';
literal EISA$M_SLOT11_PID_CHAR2 = %X'3';
literal EISA$M_SLOT11_PID_CHAR1 = %X'7C';
literal EISA$M_SLOT11_PID_CHAR3 = %X'1F00';
literal EISA$M_SLOT11_PID_CHAR2_CONT = %X'E000';
literal EISA$M_SLOT11_PID_PROD_NUM1 = %X'F0000';
literal EISA$M_SLOT11_PID_PROD_NUM2 = %X'F00000';
literal EISA$M_SLOT11_PID_REV_NUM1 = %X'F000000';
literal EISA$M_SLOT11_PID_PROD_NUM3 = %X'F0000000';
literal EISA$M_SLOT12_PID_CHAR2 = %X'3';
literal EISA$M_SLOT12_PID_CHAR1 = %X'7C';
literal EISA$M_SLOT12_PID_CHAR3 = %X'1F00';
literal EISA$M_SLOT12_PID_CHAR2_CONT = %X'E000';
literal EISA$M_SLOT12_PID_PROD_NUM1 = %X'F0000';
literal EISA$M_SLOT12_PID_PROD_NUM2 = %X'F00000';
literal EISA$M_SLOT12_PID_REV_NUM1 = %X'F000000';
literal EISA$M_SLOT12_PID_PROD_NUM3 = %X'F0000000';
literal EISA$M_SLOT13_PID_CHAR2 = %X'3';
literal EISA$M_SLOT13_PID_CHAR1 = %X'7C';
literal EISA$M_SLOT13_PID_CHAR3 = %X'1F00';
literal EISA$M_SLOT13_PID_CHAR2_CONT = %X'E000';
literal EISA$M_SLOT13_PID_PROD_NUM1 = %X'F0000';
literal EISA$M_SLOT13_PID_PROD_NUM2 = %X'F00000';
literal EISA$M_SLOT13_PID_REV_NUM1 = %X'F000000';
literal EISA$M_SLOT13_PID_PROD_NUM3 = %X'F0000000';
literal EISA$M_SLOT14_PID_CHAR2 = %X'3';
literal EISA$M_SLOT14_PID_CHAR1 = %X'7C';
literal EISA$M_SLOT14_PID_CHAR3 = %X'1F00';
literal EISA$M_SLOT14_PID_CHAR2_CONT = %X'E000';
literal EISA$M_SLOT14_PID_PROD_NUM1 = %X'F0000';
literal EISA$M_SLOT14_PID_PROD_NUM2 = %X'F00000';
literal EISA$M_SLOT14_PID_REV_NUM1 = %X'F000000';
literal EISA$M_SLOT14_PID_PROD_NUM3 = %X'F0000000';
literal EISA$M_SLOT15_PID_CHAR2 = %X'3';
literal EISA$M_SLOT15_PID_CHAR1 = %X'7C';
literal EISA$M_SLOT15_PID_CHAR3 = %X'1F00';
literal EISA$M_SLOT15_PID_CHAR2_CONT = %X'E000';
literal EISA$M_SLOT15_PID_PROD_NUM1 = %X'F0000';
literal EISA$M_SLOT15_PID_PROD_NUM2 = %X'F00000';
literal EISA$M_SLOT15_PID_REV_NUM1 = %X'F000000';
literal EISA$M_SLOT15_PID_PROD_NUM3 = %X'F0000000';
literal EISA$k_NODE_SPACE_LENGTH = 131072;
literal EISA$S_EISABUSDEF = 131072;     !  Old size name - synonym
literal EISA$S_EISABUS = 131072;
macro EISA$B_DMA1_CH0_BASE_ADDR = 0,0,8,0 %;
macro EISA$B_DMA1_CH0_BASE_CNT = 1,0,8,0 %;
macro EISA$B_DMA1_CH1_BASE_ADDR = 2,0,8,0 %;
macro EISA$B_DMA1_CH1_BASE_CNT = 3,0,8,0 %;
macro EISA$B_DMA1_CH2_BASE_ADDR = 4,0,8,0 %;
macro EISA$B_DMA1_CH2_BASE_CNT = 5,0,8,0 %;
macro EISA$B_DMA1_CH3_BASE_ADDR = 6,0,8,0 %;
macro EISA$B_DMA1_CH3_BASE_CNT = 7,0,8,0 %;
macro EISA$B_DMA1_STAT_CMD = 8,0,8,0 %;
macro EISA$B_DMA1_WRREQ = 9,0,8,0 %;
macro EISA$B_DMA1_WRMASK = 10,0,8,0 %;
macro EISA$B_DMA1_WRMODE = 11,0,8,0 %;
macro EISA$B_DMA1_CLRBYT = 12,0,8,0 %;
macro EISA$B_DMA1_MASTER_CLR = 13,0,8,0 %;
macro EISA$B_DMA1_CLR_MASK = 14,0,8,0 %;
macro EISA$B_DMA1_MASK_REG = 15,0,8,0 %;
macro EISA$b_fill4 = 16,0,0,1 %;
literal EISA$s_fill4 = 16;
macro EISA$B_PIC_L_ICW1 = 32,0,8,0 %;
macro EISA$V_PIC_L_ICW1_ICW4 = 32,0,1,0 %;
macro EISA$V_PIC_L_ICW1_SNGL = 32,1,1,0 %;
macro EISA$V_PIC_L_OCW2_L0 = 32,0,1,0 %;
macro EISA$V_PIC_L_OCW2_L1 = 32,1,1,0 %;
macro EISA$V_PIC_L_OCW2_L2 = 32,2,1,0 %;
macro EISA$V_PIC_L_OCW2_EOI = 32,5,1,0 %;
macro EISA$V_PIC_L_OCW2_SL = 32,6,1,0 %;
macro EISA$V_PIC_L_OCW2_R = 32,7,1,0 %;
macro EISA$V_PIC_L_OCW3_RIS = 32,0,1,0 %;
macro EISA$V_PIC_L_OCW3_RR = 32,1,1,0 %;
macro EISA$V_PIC_L_OCW3_P = 32,2,1,0 %;
macro EISA$V_PIC_L_OCW3_SMM = 32,5,1,0 %;
macro EISA$V_PIC_L_OCW3_ESMM = 32,6,1,0 %;
macro EISA$B_PIC_L_ICW2 = 33,0,8,0 %;
macro EISA$V_PIC_L_ICW2_ZEROES = 33,0,3,0 %;
literal EISA$S_PIC_L_ICW2_ZEROES = 3;
macro EISA$V_PIC_L_ICW2_VEC = 33,3,5,0 %;
literal EISA$S_PIC_L_ICW2_VEC = 5;
macro EISA$V_PIC_L_ICW3_IRQ0_SLAVE = 33,0,1,0 %;
macro EISA$V_PIC_L_ICW3_IRQ1_SLAVE = 33,1,1,0 %;
macro EISA$V_PIC_L_ICW3_IRQ2_SLAVE = 33,2,1,0 %;
macro EISA$V_PIC_L_ICW3_IRQ3_SLAVE = 33,3,1,0 %;
macro EISA$V_PIC_L_ICW3_IRQ4_SLAVE = 33,4,1,0 %;
macro EISA$V_PIC_L_ICW3_IRQ5_SLAVE = 33,5,1,0 %;
macro EISA$V_PIC_L_ICW3_IRQ6_SLAVE = 33,6,1,0 %;
macro EISA$V_PIC_L_ICW3_IRQ7_SLAVE = 33,7,1,0 %;
macro EISA$V_PIC_L_ICW4_MODE = 33,0,1,0 %;
macro EISA$V_PIC_L_ICW4_AEOI = 33,1,1,0 %;
macro EISA$V_PIC_L_ICW4_BUFF = 33,3,2,0 %;
literal EISA$S_PIC_L_ICW4_BUFF = 2;
macro EISA$V_PIC_L_ICW4_NEST = 33,5,1,0 %;
macro EISA$V_PIC_L_OCW1_MASK = 33,0,8,0 %;
literal EISA$S_PIC_L_OCW1_MASK = 8;
macro EISA$b_fill5 = 35,0,0,1 %;
literal EISA$s_fill5 = 29;
macro EISA$B_PIC_L_T1_SYSTIM = 64,0,8,0 %;
macro EISA$V_PIC_L_T1_SYSTIM_BCD = 64,0,1,0 %;
macro EISA$V_PIC_L_T1_SYSTIM_MODE = 64,1,3,0 %;
literal EISA$S_PIC_L_T1_SYSTIM_MODE = 3;
macro EISA$V_PIC_L_T1_SYSTIM_RW = 64,4,2,0 %;
literal EISA$S_PIC_L_T1_SYSTIM_RW = 2;
macro EISA$V_PIC_L_T1_SYSTIM_STAT = 64,6,1,0 %;
macro EISA$V_PIC_L_T1_SYSTIM_OUT = 64,7,1,0 %;
macro EISA$B_PIC_L_T1_REF = 65,0,8,0 %;
macro EISA$V_PIC_L_T1_REF_BCD = 65,0,1,0 %;
macro EISA$V_PIC_L_T1_REF_MODE = 65,1,3,0 %;
literal EISA$S_PIC_L_T1_REF_MODE = 3;
macro EISA$V_PIC_L_T1_REF_RW = 65,4,2,0 %;
literal EISA$S_PIC_L_T1_REF_RW = 2;
macro EISA$V_PIC_L_T1_REF_STAT = 65,6,1,0 %;
macro EISA$V_PIC_L_T1_REF_OUT = 65,7,1,0 %;
macro EISA$B_PIC_L_T1_SPKR = 66,0,8,0 %;
macro EISA$V_PIC_L_T1_SPKR_BCD = 66,0,1,0 %;
macro EISA$V_PIC_L_T1_SPKR_MODE = 66,1,3,0 %;
literal EISA$S_PIC_L_T1_SPKR_MODE = 3;
macro EISA$V_PIC_L_T1_SPKR_RW = 66,4,2,0 %;
literal EISA$S_PIC_L_T1_SPKR_RW = 2;
macro EISA$V_PIC_L_T1_SPKR_STAT = 66,6,1,0 %;
macro EISA$V_PIC_L_T1_SPKR_OUT = 66,7,1,0 %;
macro EISA$B_PIC_L_T1_CTRL = 67,0,8,0 %;
macro EISA$V_PIC_L_T1_CTRL_BCD = 67,0,1,0 %;
macro EISA$V_PIC_L_T1_CTRL_MODE = 67,1,3,0 %;
literal EISA$S_PIC_L_T1_CTRL_MODE = 3;
macro EISA$V_PIC_L_T1_CTRL_CNTLAT = 67,4,2,0 %;
literal EISA$S_PIC_L_T1_CTRL_CNTLAT = 2;
macro EISA$V_PIC_L_T1_CTRL_CNTSEL = 67,6,2,0 %;
literal EISA$S_PIC_L_T1_CTRL_CNTSEL = 2;
macro EISA$b_fill6 = 68,0,32,1 %;
literal EISA$s_fill6 = 4;
macro EISA$B_PIC_L_T2_FLSF = 72,0,8,0 %;
macro EISA$V_PIC_L_T2_FLSF_BCD = 72,0,1,0 %;
macro EISA$V_PIC_L_T2_FLSF_MODE = 72,1,3,0 %;
literal EISA$S_PIC_L_T2_FLSF_MODE = 3;
macro EISA$V_PIC_L_T2_FLSF_RW = 72,4,2,0 %;
literal EISA$S_PIC_L_T2_FLSF_RW = 2;
macro EISA$V_PIC_L_T2_FLSF_STAT = 72,6,1,0 %;
macro EISA$V_PIC_L_T2_FLSF_OUT = 72,7,1,0 %;
macro EISA$b_fill7 = 73,0,8,1 %;
literal EISA$s_fill7 = 1;
macro EISA$B_PIC_L_T2_CPUSPD = 74,0,8,0 %;
macro EISA$V_PIC_L_T2_CPUSPD_BCD = 74,0,1,0 %;
macro EISA$V_PIC_L_T2_CPUSPD_MODE = 74,1,3,0 %;
literal EISA$S_PIC_L_T2_CPUSPD_MODE = 3;
macro EISA$V_PIC_L_T2_CPUSPD_RW = 74,4,2,0 %;
literal EISA$S_PIC_L_T2_CPUSPD_RW = 2;
macro EISA$V_PIC_L_T2_CPUSPD_STAT = 74,6,1,0 %;
macro EISA$V_PIC_L_T2_CPUSPD_OUT = 74,7,1,0 %;
macro EISA$B_PIC_L_T2_CTRL = 75,0,8,0 %;
macro EISA$V_PIC_L_T2_CTRL_BCD = 75,0,1,0 %;
macro EISA$V_PIC_L_T2_CTRL_MODE = 75,1,3,0 %;
literal EISA$S_PIC_L_T2_CTRL_MODE = 3;
macro EISA$V_PIC_L_T2_CTRL_CNTLAT = 75,4,2,0 %;
literal EISA$S_PIC_L_T2_CTRL_CNTLAT = 2;
macro EISA$V_PIC_L_T2_CTRL_CNTSEL = 75,6,2,0 %;
literal EISA$S_PIC_L_T2_CTRL_CNTSEL = 2;
macro EISA$b_fill8 = 76,0,0,1 %;
literal EISA$s_fill8 = 21;
macro EISA$B_PIC_L_NMICSR = 97,0,8,0 %;
macro EISA$V_PIC_L_NMICSR_T1 = 97,0,1,0 %;
macro EISA$V_PIC_L_NMICSR_SPKR = 97,1,1,0 %;
macro EISA$V_PIC_L_NMICSR_PE = 97,2,1,0 %;
macro EISA$V_PIC_L_NMICSR_IOCHK = 97,3,1,0 %;
macro EISA$V_PIC_L_NMICSR_REF = 97,4,1,0 %;
macro EISA$V_PIC_L_NMICSR_INTM1 = 97,5,1,0 %;
macro EISA$V_PIC_L_NMICSR_NMIINT = 97,6,1,0 %;
macro EISA$V_PIC_L_NMICSR_PAR = 97,7,1,0 %;
macro EISA$b_fill9 = 98,0,0,1 %;
literal EISA$s_fill9 = 14;
macro EISA$B_PIC_L_NMIRTC = 112,0,8,0 %;
macro EISA$V_PIC_L_NMIRTC_CLKADR = 112,0,7,0 %;
literal EISA$S_PIC_L_NMIRTC_CLKADR = 7;
macro EISA$V_PIC_L_NMIRTC_ENDIS = 112,7,1,0 %;
macro EISA$b_fill10 = 113,0,0,1 %;
literal EISA$s_fill10 = 16;
macro EISA$B_DMA_PAGE_CH2 = 129,0,8,0 %;
macro EISA$B_DMA_PAGE_CH3 = 130,0,8,0 %;
macro EISA$B_DMA_PAGE_CH1 = 131,0,8,0 %;
macro EISA$b_fill10a = 132,0,24,1 %;
literal EISA$s_fill10a = 3;
macro EISA$B_DMA_PAGE_CH0 = 135,0,8,0 %;
macro EISA$b_fill10b = 136,0,8,1 %;
literal EISA$s_fill10b = 1;
macro EISA$B_DMA_PAGE_CH6 = 137,0,8,0 %;
macro EISA$B_DMA_PAGE_CH7 = 138,0,8,0 %;
macro EISA$B_DMA_PAGE_CH5 = 139,0,8,0 %;
macro EISA$b_fill10c = 140,0,24,1 %;
literal EISA$s_fill10c = 3;
macro EISA$B_DMA_PAGE_REF = 143,0,8,0 %;
macro EISA$b_fill10d = 144,0,0,1 %;
literal EISA$s_fill10d = 16;
macro EISA$B_PIC_H_ICW1 = 160,0,8,0 %;
macro EISA$V_PIC_H_ICW1_ICW4 = 160,0,1,0 %;
macro EISA$V_PIC_H_ICW1_SNGL = 160,1,1,0 %;
macro EISA$V_PIC_H_OCW2_L0 = 160,0,1,0 %;
macro EISA$V_PIC_H_OCW2_L1 = 160,1,1,0 %;
macro EISA$V_PIC_H_OCW2_L2 = 160,2,1,0 %;
macro EISA$V_PIC_H_OCW2_EOI = 160,5,1,0 %;
macro EISA$V_PIC_H_OCW2_SL = 160,6,1,0 %;
macro EISA$V_PIC_H_OCW2_R = 160,7,1,0 %;
macro EISA$V_PIC_H_OCW3_RIS = 160,0,1,0 %;
macro EISA$V_PIC_H_OCW3_RR = 160,1,1,0 %;
macro EISA$V_PIC_H_OCW3_P = 160,2,1,0 %;
macro EISA$V_PIC_H_OCW3_SMM = 160,5,1,0 %;
macro EISA$V_PIC_H_OCW3_ESMM = 160,6,1,0 %;
macro EISA$B_PIC_H_ICW2 = 161,0,8,0 %;
macro EISA$V_PIC_H_ICW2_ZEROES = 161,0,3,0 %;
literal EISA$S_PIC_H_ICW2_ZEROES = 3;
macro EISA$V_PIC_H_ICW2_VEC = 161,3,5,0 %;
literal EISA$S_PIC_H_ICW2_VEC = 5;
macro EISA$V_PIC_H_ICW3_IRQ0_SLAVE = 161,0,1,0 %;
macro EISA$V_PIC_H_ICW3_IRQ1_SLAVE = 161,1,1,0 %;
macro EISA$V_PIC_H_ICW3_IRQ2_SLAVE = 161,2,1,0 %;
macro EISA$V_PIC_H_ICW3_IRQ3_SLAVE = 161,3,1,0 %;
macro EISA$V_PIC_H_ICW3_IRQ4_SLAVE = 161,4,1,0 %;
macro EISA$V_PIC_H_ICW3_IRQ5_SLAVE = 161,5,1,0 %;
macro EISA$V_PIC_H_ICW3_IRQ6_SLAVE = 161,6,1,0 %;
macro EISA$V_PIC_H_ICW3_IRQ7_SLAVE = 161,7,1,0 %;
macro EISA$V_PIC_H_ICW4_MODE = 161,0,1,0 %;
macro EISA$V_PIC_H_ICW4_AEOI = 161,1,1,0 %;
macro EISA$V_PIC_H_ICW4_BUFF = 161,3,2,0 %;
literal EISA$S_PIC_H_ICW4_BUFF = 2;
macro EISA$V_PIC_H_ICW4_NEST = 161,5,1,0 %;
macro EISA$V_PIC_H_OCW1_MASK = 161,0,8,0 %;
literal EISA$S_PIC_H_OCW1_MASK = 8;
macro EISA$b_fill10e = 162,0,0,1 %;
literal EISA$s_fill10e = 30;
macro EISA$B_DMA2_CH0_BASE_ADDR = 192,0,8,0 %;
macro EISA$b_fill010 = 193,0,8,1 %;
literal EISA$s_fill010 = 1;
macro EISA$B_DMA2_CH0_BASE_CNT = 194,0,8,0 %;
macro EISA$b_fill010a = 195,0,8,1 %;
literal EISA$s_fill010a = 1;
macro EISA$B_DMA2_CH1_BASE_ADDR = 196,0,8,0 %;
macro EISA$b_fill010b = 197,0,8,1 %;
literal EISA$s_fill010b = 1;
macro EISA$B_DMA2_CH1_BASE_CNT = 198,0,8,0 %;
macro EISA$b_fill110 = 199,0,8,1 %;
literal EISA$s_fill110 = 1;
macro EISA$B_DMA2_CH2_BASE_ADDR = 200,0,8,0 %;
macro EISA$b_fill210 = 201,0,8,1 %;
literal EISA$s_fill210 = 1;
macro EISA$B_DMA2_CH2_BASE_CNT = 202,0,8,0 %;
macro EISA$b_fill210a = 203,0,8,1 %;
literal EISA$s_fill210a = 1;
macro EISA$B_DMA2_CH3_BASE_ADDR = 204,0,8,0 %;
macro EISA$b_fill310 = 205,0,8,1 %;
literal EISA$s_fill310 = 1;
macro EISA$B_DMA2_CH3_BASE_CNT = 206,0,8,0 %;
macro EISA$b_fill310a = 207,0,8,1 %;
literal EISA$s_fill310a = 1;
macro EISA$B_DMA2_STAT_WR = 208,0,8,0 %;
macro EISA$b_fill410 = 209,0,8,1 %;
literal EISA$s_fill410 = 1;
macro EISA$B_DMA2_WR_REQ = 210,0,8,0 %;
macro EISA$b_fill410a = 211,0,8,1 %;
literal EISA$s_fill410a = 1;
macro EISA$B_DMA2_SMASK = 212,0,8,0 %;
macro EISA$b_fill410b = 213,0,8,1 %;
literal EISA$s_fill410b = 1;
macro EISA$B_DMA2_WRMODE = 214,0,8,0 %;
macro EISA$b_fill510 = 215,0,8,1 %;
literal EISA$s_fill510 = 1;
macro EISA$B_DMA2_CLRBYT = 216,0,8,0 %;
macro EISA$b_fill610 = 217,0,8,1 %;
literal EISA$s_fill610 = 1;
macro EISA$B_DMA2_MASTER_CLR = 218,0,8,0 %;
macro EISA$b_fill710 = 219,0,8,1 %;
literal EISA$s_fill710 = 1;
macro EISA$B_DMA2_CLR_MASK = 220,0,8,0 %;
macro EISA$b_fill810 = 221,0,8,1 %;
literal EISA$s_fill810 = 1;
macro EISA$B_DMA2_MASK_REG = 222,0,8,0 %;
macro EISA$b_fill910 = 223,0,0,1 %;
literal EISA$s_fill910 = 802;
macro EISA$B_DMA1_CH0_CNT = 1025,0,8,0 %;
macro EISA$b_fillabc = 1026,0,8,1 %;
literal EISA$s_fillabc = 1;
macro EISA$B_DMA1_CH1_CNT = 1027,0,8,0 %;
macro EISA$b_fillabc1 = 1028,0,8,1 %;
literal EISA$s_fillabc1 = 1;
macro EISA$B_DMA1_CH2_CNT = 1029,0,8,0 %;
macro EISA$b_fillabc2 = 1030,0,8,1 %;
literal EISA$s_fillabc2 = 1;
macro EISA$B_DMA1_CH3_CNT = 1031,0,8,0 %;
macro EISA$b_fillabc21 = 1032,0,16,1 %;
literal EISA$s_fillabc21 = 2;
macro EISA$B_DMA1_CHN_MODE = 1034,0,8,0 %;
macro EISA$B_DMA1_WRT_MODE = 1035,0,8,0 %;
macro EISA$B_DMA1_BUF_CTRL = 1036,0,8,0 %;
macro EISA$B_DMA1_STP_LVL = 1037,0,8,0 %;
macro EISA$b_fillabc3 = 1038,0,0,1 %;
literal EISA$s_fillabc3 = 83;
macro EISA$B_PIC_EXNMICSR = 1121,0,8,0 %;
macro EISA$V_PIC_EXNMICSR_BUSRST = 1121,0,1,0 %;
macro EISA$V_PIC_EXNMICSR_ENIO = 1121,1,1,0 %;
macro EISA$V_PIC_EXNMICSR_FSEN = 1121,2,1,0 %;
macro EISA$V_PIC_EXNMICSR_TOEN = 1121,3,1,0 %;
macro EISA$V_PIC_EXNMICSR_IOP = 1121,5,1,0 %;
macro EISA$V_PIC_EXNMICSR_BT = 1121,6,1,0 %;
macro EISA$V_PIC_EXNMICSR_FSINT = 1121,7,1,0 %;
macro EISA$B_PIC_NMIGEN = 1122,0,8,0 %;
macro EISA$b_fill11 = 1123,0,8,1 %;
literal EISA$s_fill11 = 1;
macro EISA$B_PIC_EISA_BUSMAS = 1124,0,8,0 %;
macro EISA$V_PIC_EISA_BUSMAS_SL1 = 1124,0,1,0 %;
macro EISA$V_PIC_EISA_BUSMAS_SL2 = 1124,1,1,0 %;
macro EISA$V_PIC_EISA_BUSMAS_SL3 = 1124,2,1,0 %;
macro EISA$V_PIC_EISA_BUSMAS_SL4 = 1124,3,1,0 %;
macro EISA$V_PIC_EISA_BUSMAS_SL5 = 1124,4,1,0 %;
macro EISA$V_PIC_EISA_BUSMAS_SL6 = 1124,5,1,0 %;
macro EISA$V_PIC_EISA_BUSMAS_SL7 = 1124,6,1,0 %;
macro EISA$b_fill12 = 1125,0,0,1 %;
literal EISA$s_fill12 = 28;
macro EISA$B_DMA_CH2_PAGE_HIGH = 1153,0,8,0 %;
macro EISA$B_DMA_CH3_PAGE_HIGH = 1154,0,8,0 %;
macro EISA$B_DMA_CH1_PAGE_HIGH = 1155,0,8,0 %;
macro EISA$b_fill12a = 1156,0,24,1 %;
literal EISA$s_fill12a = 3;
macro EISA$B_DMA_CH0_PAGE_HIGH = 1159,0,8,0 %;
macro EISA$b_fill12b = 1160,0,8,1 %;
literal EISA$s_fill12b = 1;
macro EISA$B_DMA_CH6_PAGE_HIGH = 1161,0,8,0 %;
macro EISA$B_DMA_CH7_PAGE_HIGH = 1162,0,8,0 %;
macro EISA$B_DMA_CH5_PAGE_HIGH = 1163,0,8,0 %;
macro EISA$b_fill12c = 1164,0,24,1 %;
literal EISA$s_fill12c = 3;
macro EISA$B_DMA_REG_REF_HIGH = 1167,0,8,0 %;
macro EISA$b_fill12d = 1168,0,0,1 %;
literal EISA$s_fill12d = 54;
macro EISA$B_DMA2_CH5_CNT = 1222,0,8,0 %;
macro EISA$b_fill12e = 1223,0,24,1 %;
literal EISA$s_fill12e = 3;
macro EISA$B_DMA2_CH6_CNT = 1226,0,8,0 %;
macro EISA$b_fill12e1 = 1227,0,24,1 %;
literal EISA$s_fill12e1 = 3;
macro EISA$B_DMA2_CH7_CNT = 1230,0,8,0 %;
macro EISA$b_fill12f = 1231,0,8,1 %;
literal EISA$s_fill12f = 1;
macro EISA$B_PIC_CTRL1_EDGE = 1232,0,8,0 %;
macro EISA$V_PIC_CTRL1_EDGE_INT3 = 1232,3,1,0 %;
macro EISA$V_PIC_CTRL1_EDGE_INT4 = 1232,4,1,0 %;
macro EISA$V_PIC_CTRL1_EDGE_INT5 = 1232,5,1,0 %;
macro EISA$V_PIC_CTRL1_EDGE_INT6 = 1232,6,1,0 %;
macro EISA$V_PIC_CTRL1_EDGE_INT7 = 1232,7,1,0 %;
macro EISA$B_PIC_CTRL2_EDGE = 1233,0,8,0 %;
macro EISA$V_PIC_CTRL2_EDGE_INT9 = 1233,1,1,0 %;
macro EISA$V_PIC_CTRL2_EDGE_INT10 = 1233,2,1,0 %;
macro EISA$V_PIC_CTRL2_EDGE_INT11 = 1233,3,1,0 %;
macro EISA$V_PIC_CTRL2_EDGE_INT12 = 1233,4,1,0 %;
macro EISA$V_PIC_CTRL2_EDGE_INT14 = 1233,6,1,0 %;
macro EISA$V_PIC_CTRL2_EDGE_INT15 = 1233,7,1,0 %;
macro EISA$b_fill13 = 1234,0,16,1 %;
literal EISA$s_fill13 = 2;
macro EISA$B_DMA2_CHN_MODE = 1236,0,8,0 %;
macro EISA$b_fill13a = 1237,0,8,1 %;
literal EISA$s_fill13a = 1;
macro EISA$B_DMA2_WRT_MODE = 1238,0,8,0 %;
macro EISA$b_fill13b = 1239,0,0,1 %;
literal EISA$s_fill13b = 9;
macro EISA$B_DMA_CH0_SRB7_2 = 1248,0,8,0 %;
macro EISA$B_DMA_CH0_SRB15_8 = 1249,0,8,0 %;
macro EISA$B_DMA_CH0_SRB23_16 = 1250,0,8,0 %;
macro EISA$b_fill13c = 1251,0,8,1 %;
literal EISA$s_fill13c = 1;
macro EISA$B_DMA_CH1_SRB7_2 = 1252,0,8,0 %;
macro EISA$B_DMA_CH1_SRB15_8 = 1253,0,8,0 %;
macro EISA$B_DMA_CH1_SRB23_16 = 1254,0,8,0 %;
macro EISA$b_fill13d = 1255,0,8,1 %;
literal EISA$s_fill13d = 1;
macro EISA$B_DMA_CH2_SRB7_2 = 1256,0,8,0 %;
macro EISA$B_DMA_CH2_SRB15_8 = 1257,0,8,0 %;
macro EISA$B_DMA_CH2_SRB23_16 = 1258,0,8,0 %;
macro EISA$b_fill13e = 1259,0,8,1 %;
literal EISA$s_fill13e = 1;
macro EISA$B_DMA_CH3_SRB7_2 = 1260,0,8,0 %;
macro EISA$B_DMA_CH3_SRB15_8 = 1261,0,8,0 %;
macro EISA$B_DMA_CH3_SRB23_16 = 1262,0,8,0 %;
macro EISA$b_fill13f = 1263,0,0,1 %;
literal EISA$s_fill13f = 5;
macro EISA$B_DMA_CH5_SRB7_2 = 1268,0,8,0 %;
macro EISA$B_DMA_CH5_SRB15_8 = 1269,0,8,0 %;
macro EISA$B_DMA_CH5_SRB23_16 = 1270,0,8,0 %;
macro EISA$b_fill13f1 = 1271,0,8,1 %;
literal EISA$s_fill13f1 = 1;
macro EISA$B_DMA_CH6_SRB7_2 = 1272,0,8,0 %;
macro EISA$B_DMA_CH6_SRB15_8 = 1273,0,8,0 %;
macro EISA$B_DMA_CH6_SRB23_16 = 1274,0,8,0 %;
macro EISA$b_fill13f2 = 1275,0,8,1 %;
literal EISA$s_fill13f2 = 1;
macro EISA$B_DMA_CH7_SRB7_2 = 1276,0,8,0 %;
macro EISA$B_DMA_CH7_SRB15_8 = 1277,0,8,0 %;
macro EISA$B_DMA_CH7_SRB23_16 = 1278,0,8,0 %;
macro EISA$b_fill13g = 1279,0,0,1 %;
literal EISA$s_fill13g = 6913;
macro EISA$B_SLOT1_BASE = 8192,0,8,0 %;
macro EISA$b_fill14 = 8193,0,0,1 %;
literal EISA$s_fill14 = 3199;
macro EISA$L_SLOT1_PID = 11392,0,32,0 %;
macro EISA$V_SLOT1_PID_CHAR2 = 11392,0,2,0 %;
literal EISA$S_SLOT1_PID_CHAR2 = 2;
macro EISA$V_SLOT1_PID_CHAR1 = 11392,2,5,0 %;
literal EISA$S_SLOT1_PID_CHAR1 = 5;
macro EISA$V_SLOT1_PID_CHAR3 = 11392,8,5,0 %;
literal EISA$S_SLOT1_PID_CHAR3 = 5;
macro EISA$V_SLOT1_PID_CHAR2_CONT = 11392,13,3,0 %;
literal EISA$S_SLOT1_PID_CHAR2_CONT = 3;
macro EISA$V_SLOT1_PID_PROD_NUM1 = 11392,16,4,0 %;
literal EISA$S_SLOT1_PID_PROD_NUM1 = 4;
macro EISA$V_SLOT1_PID_PROD_NUM2 = 11392,20,4,0 %;
literal EISA$S_SLOT1_PID_PROD_NUM2 = 4;
macro EISA$V_SLOT1_PID_REV_NUM1 = 11392,24,4,0 %;
literal EISA$S_SLOT1_PID_REV_NUM1 = 4;
macro EISA$V_SLOT1_PID_PROD_NUM3 = 11392,28,4,0 %;
literal EISA$S_SLOT1_PID_PROD_NUM3 = 4;
macro EISA$b_fill14a = 11396,0,0,1 %;
literal EISA$s_fill14a = 4988;
macro EISA$B_SLOT2_BASE = 16384,0,8,0 %;
macro EISA$b_fill15 = 16385,0,0,1 %;
literal EISA$s_fill15 = 3199;
macro EISA$L_SLOT2_PID = 19584,0,32,0 %;
macro EISA$V_SLOT2_PID_CHAR2 = 19584,0,2,0 %;
literal EISA$S_SLOT2_PID_CHAR2 = 2;
macro EISA$V_SLOT2_PID_CHAR1 = 19584,2,5,0 %;
literal EISA$S_SLOT2_PID_CHAR1 = 5;
macro EISA$V_SLOT2_PID_CHAR3 = 19584,8,5,0 %;
literal EISA$S_SLOT2_PID_CHAR3 = 5;
macro EISA$V_SLOT2_PID_CHAR2_CONT = 19584,13,3,0 %;
literal EISA$S_SLOT2_PID_CHAR2_CONT = 3;
macro EISA$V_SLOT2_PID_PROD_NUM1 = 19584,16,4,0 %;
literal EISA$S_SLOT2_PID_PROD_NUM1 = 4;
macro EISA$V_SLOT2_PID_PROD_NUM2 = 19584,20,4,0 %;
literal EISA$S_SLOT2_PID_PROD_NUM2 = 4;
macro EISA$V_SLOT2_PID_REV_NUM1 = 19584,24,4,0 %;
literal EISA$S_SLOT2_PID_REV_NUM1 = 4;
macro EISA$V_SLOT2_PID_PROD_NUM3 = 19584,28,4,0 %;
literal EISA$S_SLOT2_PID_PROD_NUM3 = 4;
macro EISA$b_fill15a = 19588,0,0,1 %;
literal EISA$s_fill15a = 4988;
macro EISA$B_SLOT3_BASE = 24576,0,8,0 %;
macro EISA$b_fill16 = 24577,0,0,1 %;
literal EISA$s_fill16 = 3199;
macro EISA$L_SLOT3_PID = 27776,0,32,0 %;
macro EISA$V_SLOT3_PID_CHAR2 = 27776,0,2,0 %;
literal EISA$S_SLOT3_PID_CHAR2 = 2;
macro EISA$V_SLOT3_PID_CHAR1 = 27776,2,5,0 %;
literal EISA$S_SLOT3_PID_CHAR1 = 5;
macro EISA$V_SLOT3_PID_CHAR3 = 27776,8,5,0 %;
literal EISA$S_SLOT3_PID_CHAR3 = 5;
macro EISA$V_SLOT3_PID_CHAR2_CONT = 27776,13,3,0 %;
literal EISA$S_SLOT3_PID_CHAR2_CONT = 3;
macro EISA$V_SLOT3_PID_PROD_NUM1 = 27776,16,4,0 %;
literal EISA$S_SLOT3_PID_PROD_NUM1 = 4;
macro EISA$V_SLOT3_PID_PROD_NUM2 = 27776,20,4,0 %;
literal EISA$S_SLOT3_PID_PROD_NUM2 = 4;
macro EISA$V_SLOT3_PID_REV_NUM1 = 27776,24,4,0 %;
literal EISA$S_SLOT3_PID_REV_NUM1 = 4;
macro EISA$V_SLOT3_PID_PROD_NUM3 = 27776,28,4,0 %;
literal EISA$S_SLOT3_PID_PROD_NUM3 = 4;
macro EISA$b_fill16a = 27780,0,0,1 %;
literal EISA$s_fill16a = 4988;
macro EISA$B_SLOT4_BASE = 32768,0,8,0 %;
macro EISA$b_fill17 = 32769,0,0,1 %;
literal EISA$s_fill17 = 3199;
macro EISA$L_SLOT4_PID = 35968,0,32,0 %;
macro EISA$V_SLOT4_PID_CHAR2 = 35968,0,2,0 %;
literal EISA$S_SLOT4_PID_CHAR2 = 2;
macro EISA$V_SLOT4_PID_CHAR1 = 35968,2,5,0 %;
literal EISA$S_SLOT4_PID_CHAR1 = 5;
macro EISA$V_SLOT4_PID_CHAR3 = 35968,8,5,0 %;
literal EISA$S_SLOT4_PID_CHAR3 = 5;
macro EISA$V_SLOT4_PID_CHAR2_CONT = 35968,13,3,0 %;
literal EISA$S_SLOT4_PID_CHAR2_CONT = 3;
macro EISA$V_SLOT4_PID_PROD_NUM1 = 35968,16,4,0 %;
literal EISA$S_SLOT4_PID_PROD_NUM1 = 4;
macro EISA$V_SLOT4_PID_PROD_NUM2 = 35968,20,4,0 %;
literal EISA$S_SLOT4_PID_PROD_NUM2 = 4;
macro EISA$V_SLOT4_PID_REV_NUM1 = 35968,24,4,0 %;
literal EISA$S_SLOT4_PID_REV_NUM1 = 4;
macro EISA$V_SLOT4_PID_PROD_NUM3 = 35968,28,4,0 %;
literal EISA$S_SLOT4_PID_PROD_NUM3 = 4;
macro EISA$b_fill17a = 35972,0,0,1 %;
literal EISA$s_fill17a = 4988;
macro EISA$B_SLOT5_BASE = 40960,0,8,0 %;
macro EISA$b_fill18 = 40961,0,0,1 %;
literal EISA$s_fill18 = 3199;
macro EISA$L_SLOT5_PID = 44160,0,32,0 %;
macro EISA$V_SLOT5_PID_CHAR2 = 44160,0,2,0 %;
literal EISA$S_SLOT5_PID_CHAR2 = 2;
macro EISA$V_SLOT5_PID_CHAR1 = 44160,2,5,0 %;
literal EISA$S_SLOT5_PID_CHAR1 = 5;
macro EISA$V_SLOT5_PID_CHAR3 = 44160,8,5,0 %;
literal EISA$S_SLOT5_PID_CHAR3 = 5;
macro EISA$V_SLOT5_PID_CHAR2_CONT = 44160,13,3,0 %;
literal EISA$S_SLOT5_PID_CHAR2_CONT = 3;
macro EISA$V_SLOT5_PID_PROD_NUM1 = 44160,16,4,0 %;
literal EISA$S_SLOT5_PID_PROD_NUM1 = 4;
macro EISA$V_SLOT5_PID_PROD_NUM2 = 44160,20,4,0 %;
literal EISA$S_SLOT5_PID_PROD_NUM2 = 4;
macro EISA$V_SLOT5_PID_REV_NUM1 = 44160,24,4,0 %;
literal EISA$S_SLOT5_PID_REV_NUM1 = 4;
macro EISA$V_SLOT5_PID_PROD_NUM3 = 44160,28,4,0 %;
literal EISA$S_SLOT5_PID_PROD_NUM3 = 4;
macro EISA$b_fill18a = 44164,0,0,1 %;
literal EISA$s_fill18a = 4988;
macro EISA$B_SLOT6_BASE = 49152,0,8,0 %;
macro EISA$b_fill19 = 49153,0,0,1 %;
literal EISA$s_fill19 = 3199;
macro EISA$L_SLOT6_PID = 52352,0,32,0 %;
macro EISA$V_SLOT6_PID_CHAR2 = 52352,0,2,0 %;
literal EISA$S_SLOT6_PID_CHAR2 = 2;
macro EISA$V_SLOT6_PID_CHAR1 = 52352,2,5,0 %;
literal EISA$S_SLOT6_PID_CHAR1 = 5;
macro EISA$V_SLOT6_PID_CHAR3 = 52352,8,5,0 %;
literal EISA$S_SLOT6_PID_CHAR3 = 5;
macro EISA$V_SLOT6_PID_CHAR2_CONT = 52352,13,3,0 %;
literal EISA$S_SLOT6_PID_CHAR2_CONT = 3;
macro EISA$V_SLOT6_PID_PROD_NUM1 = 52352,16,4,0 %;
literal EISA$S_SLOT6_PID_PROD_NUM1 = 4;
macro EISA$V_SLOT6_PID_PROD_NUM2 = 52352,20,4,0 %;
literal EISA$S_SLOT6_PID_PROD_NUM2 = 4;
macro EISA$V_SLOT6_PID_REV_NUM1 = 52352,24,4,0 %;
literal EISA$S_SLOT6_PID_REV_NUM1 = 4;
macro EISA$V_SLOT6_PID_PROD_NUM3 = 52352,28,4,0 %;
literal EISA$S_SLOT6_PID_PROD_NUM3 = 4;
macro EISA$b_fill19a = 52356,0,0,1 %;
literal EISA$s_fill19a = 4988;
macro EISA$B_SLOT7_BASE = 57344,0,8,0 %;
macro EISA$b_fill19a01 = 57345,0,0,1 %;
literal EISA$s_fill19a01 = 3199;
macro EISA$L_SLOT7_PID = 60544,0,32,0 %;
macro EISA$V_SLOT7_PID_CHAR2 = 60544,0,2,0 %;
literal EISA$S_SLOT7_PID_CHAR2 = 2;
macro EISA$V_SLOT7_PID_CHAR1 = 60544,2,5,0 %;
literal EISA$S_SLOT7_PID_CHAR1 = 5;
macro EISA$V_SLOT7_PID_CHAR3 = 60544,8,5,0 %;
literal EISA$S_SLOT7_PID_CHAR3 = 5;
macro EISA$V_SLOT7_PID_CHAR2_CONT = 60544,13,3,0 %;
literal EISA$S_SLOT7_PID_CHAR2_CONT = 3;
macro EISA$V_SLOT7_PID_PROD_NUM1 = 60544,16,4,0 %;
literal EISA$S_SLOT7_PID_PROD_NUM1 = 4;
macro EISA$V_SLOT7_PID_PROD_NUM2 = 60544,20,4,0 %;
literal EISA$S_SLOT7_PID_PROD_NUM2 = 4;
macro EISA$V_SLOT7_PID_REV_NUM1 = 60544,24,4,0 %;
literal EISA$S_SLOT7_PID_REV_NUM1 = 4;
macro EISA$V_SLOT7_PID_PROD_NUM3 = 60544,28,4,0 %;
literal EISA$S_SLOT7_PID_PROD_NUM3 = 4;
macro EISA$b_fill19a1 = 60548,0,0,1 %;
literal EISA$s_fill19a1 = 4988;
macro EISA$B_SLOT8_BASE = 65536,0,8,0 %;
macro EISA$b_fill19b = 65537,0,0,1 %;
literal EISA$s_fill19b = 3199;
macro EISA$L_SLOT8_PID = 68736,0,32,0 %;
macro EISA$V_SLOT8_PID_CHAR2 = 68736,0,2,0 %;
literal EISA$S_SLOT8_PID_CHAR2 = 2;
macro EISA$V_SLOT8_PID_CHAR1 = 68736,2,5,0 %;
literal EISA$S_SLOT8_PID_CHAR1 = 5;
macro EISA$V_SLOT8_PID_CHAR3 = 68736,8,5,0 %;
literal EISA$S_SLOT8_PID_CHAR3 = 5;
macro EISA$V_SLOT8_PID_CHAR2_CONT = 68736,13,3,0 %;
literal EISA$S_SLOT8_PID_CHAR2_CONT = 3;
macro EISA$V_SLOT8_PID_PROD_NUM1 = 68736,16,4,0 %;
literal EISA$S_SLOT8_PID_PROD_NUM1 = 4;
macro EISA$V_SLOT8_PID_PROD_NUM2 = 68736,20,4,0 %;
literal EISA$S_SLOT8_PID_PROD_NUM2 = 4;
macro EISA$V_SLOT8_PID_REV_NUM1 = 68736,24,4,0 %;
literal EISA$S_SLOT8_PID_REV_NUM1 = 4;
macro EISA$V_SLOT8_PID_PROD_NUM3 = 68736,28,4,0 %;
literal EISA$S_SLOT8_PID_PROD_NUM3 = 4;
macro EISA$b_fill19b1 = 68740,0,0,1 %;
literal EISA$s_fill19b1 = 4988;
macro EISA$B_SLOT9_BASE = 73728,0,8,0 %;
macro EISA$b_fill19c = 73729,0,0,1 %;
literal EISA$s_fill19c = 3199;
macro EISA$L_SLOT9_PID = 76928,0,32,0 %;
macro EISA$V_SLOT9_PID_CHAR2 = 76928,0,2,0 %;
literal EISA$S_SLOT9_PID_CHAR2 = 2;
macro EISA$V_SLOT9_PID_CHAR1 = 76928,2,5,0 %;
literal EISA$S_SLOT9_PID_CHAR1 = 5;
macro EISA$V_SLOT9_PID_CHAR3 = 76928,8,5,0 %;
literal EISA$S_SLOT9_PID_CHAR3 = 5;
macro EISA$V_SLOT9_PID_CHAR2_CONT = 76928,13,3,0 %;
literal EISA$S_SLOT9_PID_CHAR2_CONT = 3;
macro EISA$V_SLOT9_PID_PROD_NUM1 = 76928,16,4,0 %;
literal EISA$S_SLOT9_PID_PROD_NUM1 = 4;
macro EISA$V_SLOT9_PID_PROD_NUM2 = 76928,20,4,0 %;
literal EISA$S_SLOT9_PID_PROD_NUM2 = 4;
macro EISA$V_SLOT9_PID_REV_NUM1 = 76928,24,4,0 %;
literal EISA$S_SLOT9_PID_REV_NUM1 = 4;
macro EISA$V_SLOT9_PID_PROD_NUM3 = 76928,28,4,0 %;
literal EISA$S_SLOT9_PID_PROD_NUM3 = 4;
macro EISA$b_fill19c1 = 76932,0,0,1 %;
literal EISA$s_fill19c1 = 4988;
macro EISA$B_SLOT10_BASE = 81920,0,8,0 %;
macro EISA$b_fill19d = 81921,0,0,1 %;
literal EISA$s_fill19d = 3199;
macro EISA$L_SLOT10_PID = 85120,0,32,0 %;
macro EISA$V_SLOT10_PID_CHAR2 = 85120,0,2,0 %;
literal EISA$S_SLOT10_PID_CHAR2 = 2;
macro EISA$V_SLOT10_PID_CHAR1 = 85120,2,5,0 %;
literal EISA$S_SLOT10_PID_CHAR1 = 5;
macro EISA$V_SLOT10_PID_CHAR3 = 85120,8,5,0 %;
literal EISA$S_SLOT10_PID_CHAR3 = 5;
macro EISA$V_SLOT10_PID_CHAR2_CONT = 85120,13,3,0 %;
literal EISA$S_SLOT10_PID_CHAR2_CONT = 3;
macro EISA$V_SLOT10_PID_PROD_NUM1 = 85120,16,4,0 %;
literal EISA$S_SLOT10_PID_PROD_NUM1 = 4;
macro EISA$V_SLOT10_PID_PROD_NUM2 = 85120,20,4,0 %;
literal EISA$S_SLOT10_PID_PROD_NUM2 = 4;
macro EISA$V_SLOT10_PID_REV_NUM1 = 85120,24,4,0 %;
literal EISA$S_SLOT10_PID_REV_NUM1 = 4;
macro EISA$V_SLOT10_PID_PROD_NUM3 = 85120,28,4,0 %;
literal EISA$S_SLOT10_PID_PROD_NUM3 = 4;
macro EISA$b_fill19d1 = 85124,0,0,1 %;
literal EISA$s_fill19d1 = 4988;
macro EISA$B_SLOT11_BASE = 90112,0,8,0 %;
macro EISA$b_fill19e = 90113,0,0,1 %;
literal EISA$s_fill19e = 3199;
macro EISA$L_SLOT11_PID = 93312,0,32,0 %;
macro EISA$V_SLOT11_PID_CHAR2 = 93312,0,2,0 %;
literal EISA$S_SLOT11_PID_CHAR2 = 2;
macro EISA$V_SLOT11_PID_CHAR1 = 93312,2,5,0 %;
literal EISA$S_SLOT11_PID_CHAR1 = 5;
macro EISA$V_SLOT11_PID_CHAR3 = 93312,8,5,0 %;
literal EISA$S_SLOT11_PID_CHAR3 = 5;
macro EISA$V_SLOT11_PID_CHAR2_CONT = 93312,13,3,0 %;
literal EISA$S_SLOT11_PID_CHAR2_CONT = 3;
macro EISA$V_SLOT11_PID_PROD_NUM1 = 93312,16,4,0 %;
literal EISA$S_SLOT11_PID_PROD_NUM1 = 4;
macro EISA$V_SLOT11_PID_PROD_NUM2 = 93312,20,4,0 %;
literal EISA$S_SLOT11_PID_PROD_NUM2 = 4;
macro EISA$V_SLOT11_PID_REV_NUM1 = 93312,24,4,0 %;
literal EISA$S_SLOT11_PID_REV_NUM1 = 4;
macro EISA$V_SLOT11_PID_PROD_NUM3 = 93312,28,4,0 %;
literal EISA$S_SLOT11_PID_PROD_NUM3 = 4;
macro EISA$b_fill19e1 = 93316,0,0,1 %;
literal EISA$s_fill19e1 = 4988;
macro EISA$B_SLOT12_BASE = 98304,0,8,0 %;
macro EISA$b_fill19f = 98305,0,0,1 %;
literal EISA$s_fill19f = 3199;
macro EISA$L_SLOT12_PID = 101504,0,32,0 %;
macro EISA$V_SLOT12_PID_CHAR2 = 101504,0,2,0 %;
literal EISA$S_SLOT12_PID_CHAR2 = 2;
macro EISA$V_SLOT12_PID_CHAR1 = 101504,2,5,0 %;
literal EISA$S_SLOT12_PID_CHAR1 = 5;
macro EISA$V_SLOT12_PID_CHAR3 = 101504,8,5,0 %;
literal EISA$S_SLOT12_PID_CHAR3 = 5;
macro EISA$V_SLOT12_PID_CHAR2_CONT = 101504,13,3,0 %;
literal EISA$S_SLOT12_PID_CHAR2_CONT = 3;
macro EISA$V_SLOT12_PID_PROD_NUM1 = 101504,16,4,0 %;
literal EISA$S_SLOT12_PID_PROD_NUM1 = 4;
macro EISA$V_SLOT12_PID_PROD_NUM2 = 101504,20,4,0 %;
literal EISA$S_SLOT12_PID_PROD_NUM2 = 4;
macro EISA$V_SLOT12_PID_REV_NUM1 = 101504,24,4,0 %;
literal EISA$S_SLOT12_PID_REV_NUM1 = 4;
macro EISA$V_SLOT12_PID_PROD_NUM3 = 101504,28,4,0 %;
literal EISA$S_SLOT12_PID_PROD_NUM3 = 4;
macro EISA$b_fill19f1 = 101508,0,0,1 %;
literal EISA$s_fill19f1 = 4988;
macro EISA$B_SLOT13_BASE = 106496,0,8,0 %;
macro EISA$b_fill19aa = 106497,0,0,1 %;
literal EISA$s_fill19aa = 3199;
macro EISA$L_SLOT13_PID = 109696,0,32,0 %;
macro EISA$V_SLOT13_PID_CHAR2 = 109696,0,2,0 %;
literal EISA$S_SLOT13_PID_CHAR2 = 2;
macro EISA$V_SLOT13_PID_CHAR1 = 109696,2,5,0 %;
literal EISA$S_SLOT13_PID_CHAR1 = 5;
macro EISA$V_SLOT13_PID_CHAR3 = 109696,8,5,0 %;
literal EISA$S_SLOT13_PID_CHAR3 = 5;
macro EISA$V_SLOT13_PID_CHAR2_CONT = 109696,13,3,0 %;
literal EISA$S_SLOT13_PID_CHAR2_CONT = 3;
macro EISA$V_SLOT13_PID_PROD_NUM1 = 109696,16,4,0 %;
literal EISA$S_SLOT13_PID_PROD_NUM1 = 4;
macro EISA$V_SLOT13_PID_PROD_NUM2 = 109696,20,4,0 %;
literal EISA$S_SLOT13_PID_PROD_NUM2 = 4;
macro EISA$V_SLOT13_PID_REV_NUM1 = 109696,24,4,0 %;
literal EISA$S_SLOT13_PID_REV_NUM1 = 4;
macro EISA$V_SLOT13_PID_PROD_NUM3 = 109696,28,4,0 %;
literal EISA$S_SLOT13_PID_PROD_NUM3 = 4;
macro EISA$b_fill19aa1 = 109700,0,0,1 %;
literal EISA$s_fill19aa1 = 4988;
macro EISA$B_SLOT14_BASE = 114688,0,8,0 %;
macro EISA$b_fill19ab = 114689,0,0,1 %;
literal EISA$s_fill19ab = 3199;
macro EISA$L_SLOT14_PID = 117888,0,32,0 %;
macro EISA$V_SLOT14_PID_CHAR2 = 117888,0,2,0 %;
literal EISA$S_SLOT14_PID_CHAR2 = 2;
macro EISA$V_SLOT14_PID_CHAR1 = 117888,2,5,0 %;
literal EISA$S_SLOT14_PID_CHAR1 = 5;
macro EISA$V_SLOT14_PID_CHAR3 = 117888,8,5,0 %;
literal EISA$S_SLOT14_PID_CHAR3 = 5;
macro EISA$V_SLOT14_PID_CHAR2_CONT = 117888,13,3,0 %;
literal EISA$S_SLOT14_PID_CHAR2_CONT = 3;
macro EISA$V_SLOT14_PID_PROD_NUM1 = 117888,16,4,0 %;
literal EISA$S_SLOT14_PID_PROD_NUM1 = 4;
macro EISA$V_SLOT14_PID_PROD_NUM2 = 117888,20,4,0 %;
literal EISA$S_SLOT14_PID_PROD_NUM2 = 4;
macro EISA$V_SLOT14_PID_REV_NUM1 = 117888,24,4,0 %;
literal EISA$S_SLOT14_PID_REV_NUM1 = 4;
macro EISA$V_SLOT14_PID_PROD_NUM3 = 117888,28,4,0 %;
literal EISA$S_SLOT14_PID_PROD_NUM3 = 4;
macro EISA$b_fill19ab1 = 117892,0,0,1 %;
literal EISA$s_fill19ab1 = 4988;
macro EISA$B_SLOT15_BASE = 122880,0,8,0 %;
macro EISA$b_fill19ac = 122881,0,0,1 %;
literal EISA$s_fill19ac = 3199;
macro EISA$L_SLOT15_PID = 126080,0,32,0 %;
macro EISA$V_SLOT15_PID_CHAR2 = 126080,0,2,0 %;
literal EISA$S_SLOT15_PID_CHAR2 = 2;
macro EISA$V_SLOT15_PID_CHAR1 = 126080,2,5,0 %;
literal EISA$S_SLOT15_PID_CHAR1 = 5;
macro EISA$V_SLOT15_PID_CHAR3 = 126080,8,5,0 %;
literal EISA$S_SLOT15_PID_CHAR3 = 5;
macro EISA$V_SLOT15_PID_CHAR2_CONT = 126080,13,3,0 %;
literal EISA$S_SLOT15_PID_CHAR2_CONT = 3;
macro EISA$V_SLOT15_PID_PROD_NUM1 = 126080,16,4,0 %;
literal EISA$S_SLOT15_PID_PROD_NUM1 = 4;
macro EISA$V_SLOT15_PID_PROD_NUM2 = 126080,20,4,0 %;
literal EISA$S_SLOT15_PID_PROD_NUM2 = 4;
macro EISA$V_SLOT15_PID_REV_NUM1 = 126080,24,4,0 %;
literal EISA$S_SLOT15_PID_REV_NUM1 = 4;
macro EISA$V_SLOT15_PID_PROD_NUM3 = 126080,28,4,0 %;
literal EISA$S_SLOT15_PID_PROD_NUM3 = 4;
macro EISA$b_fill19ac1 = 126084,0,0,1 %;
literal EISA$s_fill19ac1 = 4988;
!  the following constants are useful for bus probing.
literal EISA$k_NODE0_BASE_CSR = 0;      !  this is the system
!  board slot.
literal EISA$k_NODE1_BASE_CSR = 4096;   !  this is slot 1
literal EISA$k_NODE2_BASE_CSR = 8192;   !  this is slot 2
literal EISA$k_NODE3_BASE_CSR = 12288;  !  this is slot 3
literal EISA$k_NODE4_BASE_CSR = 16384;  !  this is slot 4
literal EISA$k_NODE5_BASE_CSR = 20480;  !  this is slot 5
literal EISA$k_NODE6_BASE_CSR = 24576;  !  this is slot 6
literal EISA$k_NODE7_BASE_CSR = 28672;  !  this is slot 7
literal EISA$k_NODE8_BASE_CSR = 32768;  !  this is slot 8
literal EISA$k_NODE9_BASE_CSR = 36864;  !  this is slot 9
literal EISA$k_NODE10_BASE_CSR = 40960; !  this is slot 10
literal EISA$k_NODE11_BASE_CSR = 45056; !  this is slot 11
literal EISA$k_NODE12_BASE_CSR = 49152; !  this is slot 12
literal EISA$k_NODE13_BASE_CSR = 53248; !  this is slot 13
literal EISA$k_NODE14_BASE_CSR = 57344; !  this is slot 14
literal EISA$k_NODE15_BASE_CSR = 61440; !  this is slot 15
literal EISA$k_PRODUCT_ID_REG_OFFSET = 3200; !  offset from the slot base
!  to the PID reg
literal EISA$k_MAX_NODE_NUMBER = 15;    !  max slots is 15
literal EISA$k_DIGITAL_VENDOR_ID = 524331; !  enet prefix
literal EISACFGHDR$S_CONFIGDATAHEADER = 20;
macro EISACFGHDR$W_VERSION = 0,0,16,0 %;
macro EISACFGHDR$W_REVISION = 2,0,16,0 %;
macro EISACFGHDR$L_PTYPE = 4,0,32,1 %;
macro EISACFGHDR$L_PVENDOR = 8,0,32,1 %;
macro EISACFGHDR$L_PNAME = 12,0,32,1 %;
macro EISACFGHDR$L_PSERIAL_NUM = 16,0,32,1 %;
literal EISASLOTINFO$M_CFG_REV = %X'F';
literal EISASLOTINFO$M_SLOT_TYPE = %X'30';
literal EISASLOTINFO$M_READ_ID = %X'40';
literal EISASLOTINFO$M_DUP_ID = %X'80';
literal EISASLOTINFO$M_TYPE_ENTRY = %X'1';
literal EISASLOTINFO$M_MEM_ENTRY = %X'2';
literal EISASLOTINFO$M_IRQ_ENTRY = %X'4';
literal EISASLOTINFO$M_DMA_ENTRY = %X'8';
literal EISASLOTINFO$M_PORT_RANGE_ENTRY = %X'10';
literal EISASLOTINFO$M_PORT_INIT_ENTRY = %X'20';
literal EISASLOTINFO$m_char_2_msb = %X'3';
literal EISASLOTINFO$m_char_1 = %X'7C';
literal EISASLOTINFO$m_char_3_msb = %X'1F';
literal EISASLOTINFO$m_char_2_lsb = %X'E0';
literal EISASLOTINFO$m_hex_2 = %X'F';
literal EISASLOTINFO$m_hex_1 = %X'F0';
literal EISASLOTINFO$m_hex_4 = %X'F';
literal EISASLOTINFO$m_hex_3 = %X'F0';
literal EISASLOTINFO$S_EISASLOTINFO = 11;
macro EISASLOTINFO$B_SLOTID = 0,0,8,0 %;
macro EISASLOTINFO$V_CFG_REV = 0,0,4,0 %;
literal EISASLOTINFO$S_CFG_REV = 4;
macro EISASLOTINFO$V_SLOT_TYPE = 0,4,2,0 %;
literal EISASLOTINFO$S_SLOT_TYPE = 2;
macro EISASLOTINFO$V_READ_ID = 0,6,1,0 %;
macro EISASLOTINFO$V_DUP_ID = 0,7,1,0 %;
macro EISASLOTINFO$B_MAJOR_CFG_REV = 1,0,8,0 %;
macro EISASLOTINFO$B_MINOR_CFG_REV = 2,0,8,0 %;
macro EISASLOTINFO$B_CFG_CHKSUM_1 = 3,0,8,0 %;
macro EISASLOTINFO$B_CFG_CHKSUM_2 = 4,0,8,0 %;
macro EISASLOTINFO$B_NUM_DEV_FUNC = 5,0,8,0 %;
macro EISASLOTINFO$b_func_info = 6,0,8,0 %;
macro EISASLOTINFO$V_TYPE_ENTRY = 6,0,1,0 %;
macro EISASLOTINFO$V_MEM_ENTRY = 6,1,1,0 %;
macro EISASLOTINFO$V_IRQ_ENTRY = 6,2,1,0 %;
macro EISASLOTINFO$V_DMA_ENTRY = 6,3,1,0 %;
macro EISASLOTINFO$V_PORT_RANGE_ENTRY = 6,4,1,0 %;
macro EISASLOTINFO$V_PORT_INIT_ENTRY = 6,5,1,0 %;
macro EISASLOTINFO$B_PID_byte = 7,0,8,0 %;
macro EISASLOTINFO$v_char_2_msb = 7,0,2,0 %;
literal EISASLOTINFO$s_char_2_msb = 2;  !  bits <1:0> (2 msb's)
macro EISASLOTINFO$v_char_1 = 7,2,5,0 %;
literal EISASLOTINFO$s_char_1 = 5;      !  bits <6:2>
macro EISASLOTINFO$B_PID_byte1 = 8,0,8,0 %;
macro EISASLOTINFO$v_char_3_msb = 8,0,5,0 %;
literal EISASLOTINFO$s_char_3_msb = 5;  !  bits <4:0> 
macro EISASLOTINFO$v_char_2_lsb = 8,5,3,0 %;
literal EISASLOTINFO$s_char_2_lsb = 3;  !  bits <7:5>
macro EISASLOTINFO$B_PID_byte2 = 9,0,8,0 %;
macro EISASLOTINFO$v_hex_2 = 9,0,4,0 %;
literal EISASLOTINFO$s_hex_2 = 4;
macro EISASLOTINFO$v_hex_1 = 9,4,4,0 %;
literal EISASLOTINFO$s_hex_1 = 4;
macro EISASLOTINFO$B_PID_byte3 = 10,0,8,0 %;
macro EISASLOTINFO$v_hex_4 = 10,0,4,0 %;
literal EISASLOTINFO$s_hex_4 = 4;
macro EISASLOTINFO$v_hex_3 = 10,4,4,0 %;
literal EISASLOTINFO$s_hex_3 = 4;
literal EISACONFIG$m_char_2_msb = %X'3';
literal EISACONFIG$m_char_1 = %X'7C';
literal EISACONFIG$m_char_3_msb = %X'1F';
literal EISACONFIG$m_char_2_lsb = %X'E0';
literal EISACONFIG$m_hex_2 = %X'F';
literal EISACONFIG$m_hex_1 = %X'F0';
literal EISACONFIG$m_hex_4 = %X'F';
literal EISACONFIG$m_hex_3 = %X'F0';
literal EISACONFIG$M_CFG_REV = %X'F';
literal EISACONFIG$M_SLOT_TYPE = %X'30';
literal EISACONFIG$M_READ_ID = %X'40';
literal EISACONFIG$M_DUP_ID = %X'80';
literal EISACONFIG$M_EISA_ENABLE = %X'1';
literal EISACONFIG$M_IOCHKERR = %X'2';
literal EISACONFIG$M_CFG_DONE = %X'80';
literal EISACONFIG$M_TYPE_ENTRY = %X'1';
literal EISACONFIG$M_MEM_ENTRY = %X'2';
literal EISACONFIG$M_IRQ_ENTRY = %X'4';
literal EISACONFIG$M_DMA_ENTRY = %X'8';
literal EISACONFIG$M_PORT_RANGE_ENTRY = %X'10';
literal EISACONFIG$M_PORT_INIT_ENTRY = %X'20';
literal EISACONFIG$M_CFG_FREE_FORM = %X'40';
literal EISACONFIG$M_FUNC_ENB = %X'80';
literal EISACONFIG$m_rom_ram = %X'1';
literal EISACONFIG$m_mem_cached = %X'2';
literal EISACONFIG$m_mem_type = %X'18';
literal EISACONFIG$m_shared_mem = %X'20';
literal EISACONFIG$m_more_mem_entries = %X'80';
literal EISACONFIG$m_mem_access_size = %X'3';
literal EISACONFIG$m_mem_decode_size = %X'C';
literal EISACONFIG$m_int_0_F = %X'F';
literal EISACONFIG$M_INT_EDGE_LVL = %X'20';
literal EISACONFIG$M_INT_SHARED = %X'40';
literal EISACONFIG$M_INT_LAST_ENTRY = %X'80';
literal EISACONFIG$M_DMA_LAST_ENTRY = %X'1';
literal EISACONFIG$M_DMA_SHARED = %X'2';
literal EISACONFIG$M_DMA_CHAN = %X'E0';
literal EISACONFIG$M_DMA_TIMING = %X'C';
literal EISACONFIG$M_DMA_XFER_SIZE = %X'30';
literal EISACONFIG$M_PORT_IO_LAST_ENTRY = %X'1';
literal EISACONFIG$M_PORT_IO_SHARED = %X'2';
literal EISACONFIG$M_NUM_IO_PORT_BYTES = %X'F8';
literal EISACONFIG$S_EISACONFIGDEF = 320;
macro EISACONFIG$B_PID_byte = 0,0,8,0 %;
macro EISACONFIG$v_char_2_msb = 0,0,2,0 %;
literal EISACONFIG$s_char_2_msb = 2;    !  bits <1:0> (2 msb's)
macro EISACONFIG$v_char_1 = 0,2,5,0 %;
literal EISACONFIG$s_char_1 = 5;        !  bits <6:2>
macro EISACONFIG$B_PID_byte1 = 1,0,8,0 %;
macro EISACONFIG$v_char_3_msb = 1,0,5,0 %;
literal EISACONFIG$s_char_3_msb = 5;    !  bits <4:0> 
macro EISACONFIG$v_char_2_lsb = 1,5,3,0 %;
literal EISACONFIG$s_char_2_lsb = 3;    !  bits <7:5>
macro EISACONFIG$B_PID_byte2 = 2,0,8,0 %;
macro EISACONFIG$v_hex_2 = 2,0,4,0 %;
literal EISACONFIG$s_hex_2 = 4;
macro EISACONFIG$v_hex_1 = 2,4,4,0 %;
literal EISACONFIG$s_hex_1 = 4;
macro EISACONFIG$B_PID_byte3 = 3,0,8,0 %;
macro EISACONFIG$v_hex_4 = 3,0,4,0 %;
literal EISACONFIG$s_hex_4 = 4;
macro EISACONFIG$v_hex_3 = 3,4,4,0 %;
literal EISACONFIG$s_hex_3 = 4;
macro EISACONFIG$B_SLOTID = 4,0,8,0 %;
macro EISACONFIG$V_CFG_REV = 4,0,4,0 %;
literal EISACONFIG$S_CFG_REV = 4;
macro EISACONFIG$V_SLOT_TYPE = 4,4,2,0 %;
literal EISACONFIG$S_SLOT_TYPE = 2;
macro EISACONFIG$V_READ_ID = 4,6,1,0 %;
macro EISACONFIG$V_DUP_ID = 4,7,1,0 %;
macro EISACONFIG$B_CONFIG_ERR = 5,0,8,0 %;
macro EISACONFIG$V_EISA_ENABLE = 5,0,1,0 %;
macro EISACONFIG$V_IOCHKERR = 5,1,1,0 %;
macro EISACONFIG$V_CFG_DONE = 5,7,1,0 %;
macro EISACONFIG$B_MINOR_CFG_REV = 6,0,8,0 %;
macro EISACONFIG$B_MAJOR_CFG_REV = 7,0,8,0 %;
macro EISACONFIG$B_SELECTION_FIELD = 8,0,0,1 %;
literal EISACONFIG$S_SELECTION_FIELD = 26;
macro EISACONFIG$B_FUNC_INFO = 34,0,8,0 %;
macro EISACONFIG$V_TYPE_ENTRY = 34,0,1,0 %;
macro EISACONFIG$V_MEM_ENTRY = 34,1,1,0 %;
macro EISACONFIG$V_IRQ_ENTRY = 34,2,1,0 %;
macro EISACONFIG$V_DMA_ENTRY = 34,3,1,0 %;
macro EISACONFIG$V_PORT_RANGE_ENTRY = 34,4,1,0 %;
macro EISACONFIG$V_PORT_INIT_ENTRY = 34,5,1,0 %;
macro EISACONFIG$V_CFG_FREE_FORM = 34,6,1,0 %;
macro EISACONFIG$V_FUNC_ENB = 34,7,1,0 %;
macro EISACONFIG$B_TYPE_STYPE_STRING = 35,0,0,0 %;
literal EISACONFIG$S_TYPE_STYPE_STRING = 80;
!  the memory config region can contain up to 9 7 byte descriptions of
!  assigned memory regions.  In general, only
!  one of the regions is used, but, for instance, some VGA cards require 
!  4 buffers.  These buffers would be specified in the first 4 7-byte blocks.
!  Only one of the 7 byte regions has offsets defined here, the remaining 56
!  bytes of memory config information should be accessed using the defined offsets
!  plus an offset of 7*#mem_config_block_being_returned.  ie, to access the 1st byte
!  of the ith config block being returned for this card, the bliss code would be 
!  mem_config_byte = .ptr_to_1st_mem_config_block[$byteoffset(eisaconfig$b_mem_config)+(i*7),0,8,0];
!  In order to reference the interior bits of these bytes, use the $bitposition macro similarly.
!  these macros are all defined in starlet. 
!  
macro EISACONFIG$B_MEM_CONFIG = 115,0,8,0 %;
macro EISACONFIG$v_rom_ram = 115,0,1,0 %;
macro EISACONFIG$v_mem_cached = 115,1,1,0 %;
macro EISACONFIG$v_mem_type = 115,3,2,0 %;
literal EISACONFIG$s_mem_type = 2;
macro EISACONFIG$v_shared_mem = 115,5,1,0 %;
macro EISACONFIG$v_more_mem_entries = 115,7,1,0 %;
macro EISACONFIG$B_MEM_DATA_SIZE = 116,0,8,0 %;
macro EISACONFIG$v_mem_access_size = 116,0,2,0 %;
literal EISACONFIG$s_mem_access_size = 2;
macro EISACONFIG$v_mem_decode_size = 116,2,2,0 %;
literal EISACONFIG$s_mem_decode_size = 2;
macro EISACONFIG$B_MEM_ADDR_BYTE1 = 117,0,8,0 %; ! this 3 byte field should be multiplied 
macro EISACONFIG$B_MEM_ADDR_BYTE2 = 118,0,8,0 %; ! by 100h to get the true starting address
macro EISACONFIG$B_MEM_ADDR_BYTE3 = 119,0,8,0 %;
macro EISACONFIG$B_MEM_SIZE_BYTE1 = 120,0,8,0 %; ! this field needs to be multiplied by 400h
macro EISACONFIG$B_MEM_SIZE_BYTE2 = 121,0,8,0 %; !  to get the true size, if byte1=0, size = 64M
!  now we need the fill to leave space for the remaining 56 bytes of mem config data
macro EISACONFIG$b_fill3a = 122,0,0,1 %;
literal EISACONFIG$s_fill3a = 56;
!  the following byte specifies the interrupt request information needed by the device
!  each block is 2 bytes long, and there can be up to 7 blocks.  Apparently some cards can
!  have a function which needs several irq's.  Again, the offsets for a single
!  interrupt definition are defined here, to access multiple interrupt definitions, use the 
!  starlet macros $byteoffset, $bitposition, $fieldwidth, $extension and an index into the
!  interrupt definition blocks.  See the mem config block example above.
macro EISACONFIG$B_INTERR = 178,0,8,0 %;
macro EISACONFIG$v_int_0_F = 178,0,4,0 %;
literal EISACONFIG$s_int_0_F = 4;
macro EISACONFIG$V_INT_EDGE_LVL = 178,5,1,0 %;
macro EISACONFIG$V_INT_SHARED = 178,6,1,0 %;
macro EISACONFIG$V_INT_LAST_ENTRY = 178,7,1,0 %;
!  now leave the space for the remaining 13 potential blocks of IRQ info.
macro EISACONFIG$b_fill3b = 179,0,0,1 %;
literal EISACONFIG$s_fill3b = 13;
!  the following byte specifies the dma channel information needed by the device
!  each block is 2 bytes long, and there can be up to 4 blocks.  Apparently some cards can
!  have a function which needs several dma channels.  Again, the offsets for a single
!  block definition are defined here, to access multiple blocks, use the 
!  starlet macros $byteoffset, $bitposition, $fieldwidth, $extension and an index into the
!  definition blocks.  See the mem config block example above.
macro EISACONFIG$B_DMA_BYTE0 = 192,0,8,0 %;
macro EISACONFIG$V_DMA_LAST_ENTRY = 192,0,1,0 %;
macro EISACONFIG$V_DMA_SHARED = 192,1,1,0 %;
macro EISACONFIG$V_DMA_CHAN = 192,5,3,0 %;
literal EISACONFIG$S_DMA_CHAN = 3;
macro EISACONFIG$B_DMA_BYTE1 = 193,0,8,0 %;
macro EISACONFIG$V_DMA_TIMING = 193,2,2,0 %;
literal EISACONFIG$S_DMA_TIMING = 2;
macro EISACONFIG$V_DMA_XFER_SIZE = 193,4,2,0 %;
literal EISACONFIG$S_DMA_XFER_SIZE = 2;
macro EISACONFIG$b_fill6 = 194,0,0,1 %;
literal EISACONFIG$s_fill6 = 6;
!  the following block contains the necessary information specifying which IO ports
!  a board has been assigned to use.  Each entry consists of 3 bytes, and there can be
!  as many as 20 entries, for a total size of 60 bytes.  The first byte specifies if there
!  are more entries to follow, and the number of ports-1 defined.(ie how many sequential bytes
!  has the board been reserved)
!  the second and third bytes specify the starting address.  As per the above blocks, there are
!  not 60 entries defined here.  Instead a single entry is defined and the user needs to use the
!  starlett macros $byteoffset, $bitposition, etc. and an index into the IO port config data to
!  reference IO port block definitions 2-20.  See mem config example above.
macro EISACONFIG$B_PORT_IO_BYTE0 = 200,0,8,0 %;
macro EISACONFIG$V_PORT_IO_LAST_ENTRY = 200,0,1,0 %;
macro EISACONFIG$V_PORT_IO_SHARED = 200,1,1,0 %;
macro EISACONFIG$V_NUM_IO_PORT_BYTES = 200,3,5,0 %;
literal EISACONFIG$S_NUM_IO_PORT_BYTES = 5;
macro EISACONFIG$B_PORT_IO_ADDR_L = 201,0,8,0 %;
macro EISACONFIG$B_PORT_IO_ADDR_H = 202,0,8,0 %;
macro EISACONFIG$b_fill7 = 203,0,0,1 %;
literal EISACONFIG$s_fill7 = 57;        !  now leave space for the remaining port io blocks
!  a major contribution of the ECU is it's ability to initialize board CSR with predefined
!  information.  This aspect of the ECU is utilized before boot, and the following information
!  is not of importance to the VMS Bus Support code, so nothing is defined for it, space is simply
!  reserved.
macro EISACONFIG$B_INIT_DATA = 260,0,0,1 %;
literal EISACONFIG$S_INIT_DATA = 60;
literal eisa_hw_id_mask_lo = -1;
literal eisa_hw_id_mask_hi = 0;
 
!*** MODULE $EISDDEF ***
! +
!  EXTENDED IMAGE SECTION DESCRIPTOR DEFINITIONS
! -
literal EISD$K_MAJORID = 1;
literal EISD$K_MINORID = 1;
literal EISD$M_GBL = %X'1';
literal EISD$M_CRF = %X'2';
literal EISD$M_DZRO = %X'4';
literal EISD$M_WRT = %X'8';
literal EISD$M_INITALCODE = %X'10';
literal EISD$M_BASED = %X'20';
literal EISD$M_FIXUPVEC = %X'40';
literal EISD$M_RESIDENT = %X'80';
literal EISD$M_VECTOR = %X'100';
literal EISD$M_PROTECT = %X'200';
literal EISD$M_LASTCLU = %X'400';
literal EISD$M_EXE = %X'800';
literal EISD$M_NONSHRADR = %X'1000';
literal EISD$K_LENDZRO = 36;            ! LENGTH OF DEMAND ZERO ISD (OR STACK ISD)
literal EISD$C_LENDZRO = 36;            ! LENGTH OF DEMAND ZERO ISD (OR STACK ISD)
literal EISD$K_LENPRIV = 36;            ! LENGTH OF PRIVATE ISD 
literal EISD$C_LENPRIV = 36;            ! LENGTH OF PRIVATE ISD 
literal EISD$K_LENGLBL = 56;            ! LENGTH OF OLD GLOBAL ISD 
literal EISD$C_LENGLBL = 56;            ! LENGTH OF OLD GLOBAL ISD 
literal EISD$K_MAXLENGLBL = 84;         ! MAX LENGTH OF NEW GLOBAL ISD 
literal EISD$C_MAXLENGLBL = 84;         ! MAX LENGTH OF NEW GLOBAL ISD 
! +
literal EISD$K_MATALL = 0;              ! MATCH ALWAYS, USE GLOBAL SECTION 
literal EISD$K_MATEQU = 1;              ! MATCH IF ISD$L_IDENT EQU GBL ID 
literal EISD$K_MATLEQ = 2;              ! MATCH IF ISD$L_IDENT LEQ GBL ID 
literal EISD$K_MATNEV = 3;              ! MATCH NEVER, USE PRIVATE COPY 
! +
literal EISD$K_NORMAL = 0;              ! NORMAL PROGRAM IMAGE SECTION 
! NO SPECIAL ACTION REQUIRED
literal EISD$K_SHRFXD = 1;              ! SHAREABLE FIXED SECTION 
literal EISD$K_PRVFXD = 2;              ! PRIVATE FIXED SECTION 
literal EISD$K_SHRPIC = 3;              ! SHAREABLE PIC SECTION 
literal EISD$K_PRVPIC = 4;              ! PRIVATE PIC SECTION 
literal EISD$K_USRSTACK = 253;          ! USER STACK SECTION 
literal EISD$S_EISDDEF = 84;            !  Old size name - synonym
literal EISD$S_EISD = 84;
macro EISD$R_VERSION = 0,0,0,0 %;
literal EISD$S_VERSION = 8;             !  Version of this EISD
macro EISD$L_MAJORID = 0,0,32,0 %;      !  Major ID
macro EISD$L_MINORID = 4,0,32,0 %;      !  Minor ID
macro EISD$L_EISDSIZE = 8,0,32,0 %;     ! SIZE IN BYTES OF THIS EISD 
macro EISD$L_SECSIZE = 12,0,32,0 %;     ! SIZE OF SECTION IN BYTES DESCRIBED BY THIS ISD 
macro EISD$Q_VIRT_ADDR = 16,0,0,0 %;
literal EISD$S_VIRT_ADDR = 8;           !  Virtual address of section 
macro EISD$L_VIRT_ADDR = 16,0,32,1 %;   !  low 32 bits of virtual address
macro EISD$V_VADDR = 16,0,30,0 %;
literal EISD$S_VADDR = 30;              !  Virtual address in region 
macro EISD$V_P1 = 16,30,1,0 %;          !  P1 SPACE 
macro EISD$V_SYSTEM = 16,31,1,0 %;      !  SYSTEM SPACE 
macro EISD$L_FLAGS = 24,0,32,0 %;       ! FLAGS AND ISD TYPE 
macro EISD$V_GBL = 24,0,1,0 %;          !  GLOBAL 
macro EISD$V_CRF = 24,1,1,0 %;          !  COPY ON REFERENCE 
macro EISD$V_DZRO = 24,2,1,0 %;         !  DEMAND ZERO PAGE 
macro EISD$V_WRT = 24,3,1,0 %;          !  WRITABLE 
macro EISD$V_INITALCODE = 24,4,1,0 %;   !  ISD IS PART OF INITIALIZATION CODE
macro EISD$V_BASED = 24,5,1,0 %;        !  ISECT IS BASED 
macro EISD$V_FIXUPVEC = 24,6,1,0 %;     !  ISECT IS FIXUP SECTION 
macro EISD$V_RESIDENT = 24,7,1,0 %;     !  ISECT IS MEMORY-RESIDENT
macro EISD$V_VECTOR = 24,8,1,0 %;       !  VECTOR CONTAINED IN IMAGE SECTION 
macro EISD$V_PROTECT = 24,9,1,0 %;      !  IMAGE SECTION IS PROTECTED
macro EISD$V_LASTCLU = 24,10,1,0 %;     !  LAST CLUSTER 
macro EISD$V_EXE = 24,11,1,0 %;         !  IF SET, THIS IS A CODE IMAGE SECTION
macro EISD$V_NONSHRADR = 24,12,1,0 %;   !  IF SET, SECTION CONTAINS NON-SHAREABLE ADDRESS DATA
macro EISD$L_VBN = 28,0,32,0 %;         ! BASE VIRTUAL BLOCK NUMBER 
macro EISD$B_PFC = 32,0,8,0 %;          ! Page faule cluster
macro EISD$B_MATCHCTL = 33,0,8,0 %;     ! Linker match control
macro EISD$B_TYPE = 34,0,8,0 %;         ! Section type
macro EISD$B_FILL_1 = 35,0,8,0 %;       ! filler
macro EISD$L_IDENT = 36,0,32,0 %;       ! IDENT FOR GLOBAL SECTION 
macro EISD$T_GBLNAM = 40,0,0,0 %;
literal EISD$S_GBLNAM = 44;             ! GLOBAL NAME COUNTED STRING 
!  MATCH CONTROL VIELD VALUES
! -
! BASE OF ZERO , INCR 1 
!  ISD TYPE FIELD DEFINITIONS
! -
 
!*** MODULE $EMBHDDEF ***
! 
!  ERROR MESSAGE BUFFER HEADER
! 
!                 ******        CAUTION  ******
! 
!         ALL OF THE EMBxxDEF STRUCTURES ASSUME THAT THE HEADER IS
!         EXACTLY ONE LONGWORD IN LENGTH.  IF THIS FIELD CHANGES,
!         IF EFFECTS ALL OF THE OTHER STRUCTURES.
!         ALL MESSAGES HAVE TYPE, TIME, SYSTEM ID, AND ERROR SEQUENCE IN THE
!         SAME RELATIVE LOCATIONS.
! 
!  HDR REVISIONS
literal EMB$K_HD_REV_V50 = 2;
literal EMB$K_HD_REV_V51 = 3;
literal EMB$K_HD_REV_HICKORY = 4;
literal EMB$K_HD_REV_V10 = 5;
literal EMB$K_HD_REV_V20 = 6;
!  HDR REVISIONS
literal EMB$C_HD_REV_V50 = 2;
literal EMB$C_HD_REV_V51 = 3;
literal EMB$C_HD_REV_HICKORY = 4;
literal EMB$C_HD_REV_V10 = 5;
literal EMB$C_HD_REV_V20 = 6;
!  OS ID's
literal EMB$C_OS_RESERVED = 0;
literal EMB$C_OS_VAXVMS = 1;
literal EMB$C_OS_VAXELN = 2;
literal EMB$C_OS_ALPHAVMS = 3;
!  OS ID's
literal EMB$K_OS_RESERVED = 0;
literal EMB$K_OS_VAXVMS = 1;
literal EMB$K_OS_VAXELN = 2;
literal EMB$K_OS_ALPHAVMS = 3;
!  This determines the SCS node name  buffer size
macro SCS_NAME_LEN = 0,0,0,0 %;
literal S_SCS_NAME_LEN = 16;            !  Define type so other EMBxxxDEF files can use it.
literal EMB$C_SCS_NAME_LENGTH = 16;     !  Buffer size for SCS name
literal EMB$K_SCS_NAME_LENGTH = 16;     !  Buffer size for SCS name
literal EMB$K_HD_LENGTH = 96;           ! LENGTH OF PART COMMON TO ALL MESSAGES 
literal EMB$C_HD_LENGTH = 96;           ! LENGTH OF PART COMMON TO ALL MESSAGES 
literal EMB$S_EMBHD_NONFIXED = 96;
! 
!  Changes to offsets starting with HD_SID, the origin of this aggregate,
!  require the Header Revision to be increased. Each error message is
!  logged to the error log file in an RMS record that contains the
!  error packet, starting from offset HD_SID. The remainder of the packet
!  format is known to ERF and must be kept in synch with ERF via the
!  revision level.
! 
macro EMB$L_HD_SID = 0,0,32,0 %;        !  SYSTEM ID
macro EMB$W_HD_HDR_REV = 4,0,16,0 %;    !  HEADER REVISION (IN 1's COMPLEMENT)
macro EMB$L_HD_SYSTYPE = 6,0,32,0 %;    !  SYSTEM TYPE REGISTER
macro EMB$W_HD_XSID_RSV = 6,0,16,0 %;   !  RESERVED FOR TYPE-DEPENDENT INFO
macro EMB$B_HD_XSID_REV = 8,0,8,0 %;    !  REVISION LEVEL OF CPU
macro EMB$B_HD_XSID_TYP = 9,0,8,0 %;    !  SYS_TYPE, CPU TYPE
macro EMB$L_CPUID = 10,0,32,0 %;        !  UNIQUE CPU ID
macro EMB$B_DEV_CLASS = 14,0,8,0 %;     !  DEVICE CLASS
macro EMB$B_DEV_TYPE = 15,0,8,0 %;      !  DEVICE TYPE
macro EMB$T_SCS_NAME = 16,0,0,0 %;
literal EMB$S_SCS_NAME = 16;            !  SCS Node name ASCIC
macro EMB$W_FLAGS = 32,0,16,0 %;        !  MISC. FLAGS
macro EMB$B_OS_ID = 34,0,8,0 %;         !  LOGGING OP SYS ID
macro EMB$B_HDRSZ = 35,0,8,0 %;         !  SIZE OF HEADER
macro EMB$W_HD_ENTRY = 36,0,16,0 %;     ! ERROR MESSAGE ENTRY TYPE 
macro EMB$B_DEVTYP = 36,0,8,0 %;        ! DEVICE TYPE 
macro EMB$B_DEVCLS = 37,0,8,0 %;        ! DEVICE CLASS 
macro EMB$Q_HD_TIME = 38,0,0,0 %;
literal EMB$S_HD_TIME = 8;              ! TIME OF MESSAGE ENTRY 
macro EMB$W_HD_ERRSEQ = 46,0,16,0 %;    ! ERROR SEQUENCE FOR MESSAGE 
macro EMB$Q_HD_SWVERS = 48,0,0,0 %;
literal EMB$S_HD_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_HD_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_HD_ABSTIM = 60,0,32,0 %;    !  LOGGED CONTENTS OF EXE$GL_ABSTIM
macro EMB$B_HD_HW_NAME_LEN = 64,0,8,0 %; !  Length of marketing name of this system
macro EMB$T_HD_HW_NAME = 65,0,0,0 %;
literal EMB$S_HD_HW_NAME = 31;          !  marketing name of this system
literal EMB$K_LENGTH = 12;              ! LENGTH OF FIXED PART OF MESSAGE HEADER 
literal EMB$S_EMBHDDEF = 108;           !  Old size name - synonym
literal EMB$S_EMBHD = 108;
macro EMB$W_SIZE = -12,0,16,0 %;        ! SIZE OF ERROR MESSAGE IN BYTES 
macro EMB$W_BUFIND = -10,0,16,0 %;      ! ALLOCATION BUFFER INDICATOR
macro EMB$L_CHKSUM = -8,0,32,0 %;       !  HEADER CHECKSUM
macro EMB$B_VALID = -4,0,8,0 %;         ! ERROR MESSAGE VALID INDICATOR 
macro EMB$B_SPARE1 = -3,0,8,0 %;        !  SPARE
macro EMB$B_SPARE2 = -2,0,8,0 %;        !  SPARE
macro EMB$B_SPARE3 = -1,0,8,0 %;        !  SPARE
literal EMB$M_EM_BUS = %X'1';
literal EMB$M_EM_CPU = %X'2';
literal EMB$M_EM_MEMORY = %X'4';
literal EMB$M_EM_ADAPTER = %X'8';
literal EMB$M_EM_CACHE = %X'10';
literal EMB$M_EM_VECTOR = %X'20';
literal EMB$M_RSRVD1 = %X'40';
literal EMB$S_ERRMSK_FIELDS = 4;
macro EMB$V_EM_BUS = 0,0,1,0 %;         !  bus error
macro EMB$V_EM_CPU = 0,1,1,0 %;         !  cpu error
macro EMB$V_EM_MEMORY = 0,2,1,0 %;      !  memory error
macro EMB$V_EM_ADAPTER = 0,3,1,0 %;     !  adapter error
macro EMB$V_EM_CACHE = 0,4,1,0 %;       !  cache error
macro EMB$V_EM_VECTOR = 0,5,1,0 %;      !  VECTOR error
macro EMB$V_RSRVD1 = 0,6,1,0 %;         !  Reserved
literal EMB$M_FL_DDR = %X'1';
literal EMB$S_FLAGS_FIELDS = 4;
macro EMB$V_FL_DDR = 0,0,1,0 %;         !  DDR packet flag
 
!*** MODULE $EMBINFODEF ***
! 
!  INFORMATIONAL MESSAGE BUFFER FORMAT 
! 
literal EMB$S_EMBINFODEF = 101;         !  Old size name - synonym
literal EMB$S_EMBINFO = 101;
macro EMB$L_INFO_MSG_TYPE = 96,0,32,0 %; !  Informational msg type
macro EMB$B_INFO_MSG_DATA = 100,0,8,0 %; !  Device dependent data
 
!*** MODULE $EMBBCDEF ***
! 
!  BUGCHECK ERROR MESSAGE BUFFER FORMAT (SYSTEM AND USER)
! 
literal EMB$K_BC_LENGTH = 416;          ! SIZE OF FIXED PART OF BUGCHECK MESSAGE 
literal EMB$C_BC_LENGTH = 416;          ! SIZE OF FIXED PART OF BUGCHECK MESSAGE 
literal EMB$S_EMBBCDEF = 416;           ! Old size name - synonym
literal EMB$S_EMBBC = 416;
macro EMB$L_BC_SID = 0,0,32,0 %;        ! SYSTEM ID 
macro EMB$W_BC_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_BC_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_BC_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_BC_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_BC_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$R_BC_SCS_NAME = 16,0,0,0 %;
literal EMB$S_BC_SCS_NAME = 16;         !  SCS node name ASCIC
macro EMB$W_BC_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_BC_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_BC_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_BC_ENTRY = 36,0,16,0 %;     ! ENTRY TYPE 
macro EMB$Q_BC_TIME = 38,0,0,0 %;
literal EMB$S_BC_TIME = 8;              ! TIME IN 64 BITS 
macro EMB$W_BC_ERRSEQ = 46,0,16,0 %;    ! ERROR SEQUENCE NUMBER 
macro EMB$Q_BC_SWVERS = 48,0,0,0 %;
literal EMB$S_BC_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_BC_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_BC_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$B_BC_HW_NAME_LEN = 64,0,8,0 %; !  Length of marketing name of this system
macro EMB$T_BC_HW_NAME = 65,0,0,0 %;
literal EMB$S_BC_HW_NAME = 31;          !  marketing name of this system
macro EMB$Q_BC_KSP = 96,0,0,0 %;
literal EMB$S_BC_KSP = 8;               ! KERNEL STACK POINTER 
macro EMB$Q_BC_ESP = 104,0,0,0 %;
literal EMB$S_BC_ESP = 8;               ! EXECUTIVE STACK POINTER 
macro EMB$Q_BC_SSP = 112,0,0,0 %;
literal EMB$S_BC_SSP = 8;               ! SUPERVISOR STACK POINTER 
macro EMB$Q_BC_USP = 120,0,0,0 %;
literal EMB$S_BC_USP = 8;               ! USER STACK POINTER 
macro EMB$Q_BC_R0 = 128,0,0,0 %;
literal EMB$S_BC_R0 = 8;                ! REGISTER R0 
macro EMB$Q_BC_R1 = 136,0,0,0 %;
literal EMB$S_BC_R1 = 8;                ! REGISTER R1 
macro EMB$Q_BC_R2 = 144,0,0,0 %;
literal EMB$S_BC_R2 = 8;                ! REGISTER R2 
macro EMB$Q_BC_R3 = 152,0,0,0 %;
literal EMB$S_BC_R3 = 8;                ! REGISTER R3 
macro EMB$Q_BC_R4 = 160,0,0,0 %;
literal EMB$S_BC_R4 = 8;                ! REGISTER R4 
macro EMB$Q_BC_R5 = 168,0,0,0 %;
literal EMB$S_BC_R5 = 8;                ! REGISTER R5 
macro EMB$Q_BC_R6 = 176,0,0,0 %;
literal EMB$S_BC_R6 = 8;                ! REGISTER R6 
macro EMB$Q_BC_R7 = 184,0,0,0 %;
literal EMB$S_BC_R7 = 8;                ! REGISTER R7 
macro EMB$Q_BC_R8 = 192,0,0,0 %;
literal EMB$S_BC_R8 = 8;                ! REGISTER R8 
macro EMB$Q_BC_R9 = 200,0,0,0 %;
literal EMB$S_BC_R9 = 8;                ! REGISTER R9 
macro EMB$Q_BC_R10 = 208,0,0,0 %;
literal EMB$S_BC_R10 = 8;               ! REGISTER R10 
macro EMB$Q_BC_R11 = 216,0,0,0 %;
literal EMB$S_BC_R11 = 8;               ! REGISTER R11 
macro EMB$Q_BC_R12 = 224,0,0,0 %;
literal EMB$S_BC_R12 = 8;               ! REGISTER R12 
macro EMB$Q_BC_R13 = 232,0,0,0 %;
literal EMB$S_BC_R13 = 8;               ! REGISTER R13 
macro EMB$Q_BC_R14 = 240,0,0,0 %;
literal EMB$S_BC_R14 = 8;               ! REGISTER R14 
macro EMB$Q_BC_R15 = 248,0,0,0 %;
literal EMB$S_BC_R15 = 8;               ! REGISTER R15 
macro EMB$Q_BC_R16 = 256,0,0,0 %;
literal EMB$S_BC_R16 = 8;               ! REGISTER R16 
macro EMB$Q_BC_R17 = 264,0,0,0 %;
literal EMB$S_BC_R17 = 8;               ! REGISTER R17 
macro EMB$Q_BC_R18 = 272,0,0,0 %;
literal EMB$S_BC_R18 = 8;               ! REGISTER R18 
macro EMB$Q_BC_R19 = 280,0,0,0 %;
literal EMB$S_BC_R19 = 8;               ! REGISTER R19 
macro EMB$Q_BC_R20 = 288,0,0,0 %;
literal EMB$S_BC_R20 = 8;               ! REGISTER R20 
macro EMB$Q_BC_R21 = 296,0,0,0 %;
literal EMB$S_BC_R21 = 8;               ! REGISTER R21 
macro EMB$Q_BC_R22 = 304,0,0,0 %;
literal EMB$S_BC_R22 = 8;               ! REGISTER R22 
macro EMB$Q_BC_R23 = 312,0,0,0 %;
literal EMB$S_BC_R23 = 8;               ! REGISTER R23 
macro EMB$Q_BC_R24 = 320,0,0,0 %;
literal EMB$S_BC_R24 = 8;               ! REGISTER R24 
macro EMB$Q_BC_R25 = 328,0,0,0 %;
literal EMB$S_BC_R25 = 8;               ! REGISTER R25 
macro EMB$Q_BC_R26 = 336,0,0,0 %;
literal EMB$S_BC_R26 = 8;               ! REGISTER R26 
macro EMB$Q_BC_R27 = 344,0,0,0 %;
literal EMB$S_BC_R27 = 8;               ! REGISTER R27 
macro EMB$Q_BC_R28 = 352,0,0,0 %;
literal EMB$S_BC_R28 = 8;               ! REGISTER R28 
macro EMB$Q_BC_FP = 360,0,0,0 %;
literal EMB$S_BC_FP = 8;                ! FRAME POINTER 
macro EMB$Q_BC_SP = 368,0,0,0 %;
literal EMB$S_BC_SP = 8;                ! CURRENT STACK POINTER 
macro EMB$Q_BC_PC = 376,0,0,0 %;
literal EMB$S_BC_PC = 8;                ! PROGRAM COUNTER 
macro EMB$Q_BC_PSL = 384,0,0,0 %;
literal EMB$S_BC_PSL = 8;               ! PROCESSOR STATUS 
macro EMB$L_BC_CODE = 392,0,32,0 %;     ! BUGCHECK CODE 
macro EMB$L_BC_PID = 396,0,32,0 %;      ! CURRENT PROCESS ID 
macro EMB$T_BC_LNAME = 400,0,0,0 %;
literal EMB$S_BC_LNAME = 16;            ! CURRENT PROCESS NAME 
 
!*** MODULE $EMBCRDEF ***
! 
!  CRASH-RESTART ERROR MESSAGE BUFFER FORMAT
! 
literal EMB$K_CR_LENGTH = 480;
literal EMB$C_CR_LENGTH = 480;
literal EMB$S_EMBCRBUF = 480;
macro EMB$L_CR_SID = 0,0,32,0 %;        ! SYSTEM ID 
macro EMB$W_CR_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_CR_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_CR_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_CR_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_CR_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$B_CR_SCS_NAME = 16,0,0,0 %;
literal EMB$S_CR_SCS_NAME = 16;         !  SCS node name in ASCIC
macro EMB$W_CR_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_CR_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_CR_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_CR_ENTRY = 36,0,16,0 %;     ! ENTRY TYPE 
macro EMB$Q_CR_TIME = 38,0,0,0 %;
literal EMB$S_CR_TIME = 8;              ! TIME IN 64 BITS 
macro EMB$W_CR_ERRSEQ = 46,0,16,0 %;    ! ERROR SEQUENCE NUMBER 
macro EMB$Q_CR_SWVERS = 48,0,0,0 %;
literal EMB$S_CR_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_CR_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_CR_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$B_CR_HW_NAME_LEN = 64,0,8,0 %; !  Length of marketing name of this system
macro EMB$T_CR_HW_NAME = 65,0,0,0 %;
literal EMB$S_CR_HW_NAME = 31;          !  marketing name of this system
macro EMB$Q_CR_KSP = 96,0,0,0 %;
literal EMB$S_CR_KSP = 8;               ! KERNEL STACK POINTER 
macro EMB$Q_CR_ESP = 104,0,0,0 %;
literal EMB$S_CR_ESP = 8;               ! EXECUTIVE STACK POINTER 
macro EMB$Q_CR_SSP = 112,0,0,0 %;
literal EMB$S_CR_SSP = 8;               ! SUPERVISOR STACK POINTER 
macro EMB$Q_CR_USP = 120,0,0,0 %;
literal EMB$S_CR_USP = 8;               ! USER STACK POINTER 
macro EMB$Q_CR_R0 = 128,0,0,0 %;
literal EMB$S_CR_R0 = 8;                ! REGISTER R0 
macro EMB$Q_CR_R1 = 136,0,0,0 %;
literal EMB$S_CR_R1 = 8;                ! REGISTER R1 
macro EMB$Q_CR_R2 = 144,0,0,0 %;
literal EMB$S_CR_R2 = 8;                ! REGISTER R2 
macro EMB$Q_CR_R3 = 152,0,0,0 %;
literal EMB$S_CR_R3 = 8;                ! REGISTER R3 
macro EMB$Q_CR_R4 = 160,0,0,0 %;
literal EMB$S_CR_R4 = 8;                ! REGISTER R4 
macro EMB$Q_CR_R5 = 168,0,0,0 %;
literal EMB$S_CR_R5 = 8;                ! REGISTER R5 
macro EMB$Q_CR_R6 = 176,0,0,0 %;
literal EMB$S_CR_R6 = 8;                ! REGISTER R6 
macro EMB$Q_CR_R7 = 184,0,0,0 %;
literal EMB$S_CR_R7 = 8;                ! REGISTER R7 
macro EMB$Q_CR_R8 = 192,0,0,0 %;
literal EMB$S_CR_R8 = 8;                ! REGISTER R8 
macro EMB$Q_CR_R9 = 200,0,0,0 %;
literal EMB$S_CR_R9 = 8;                ! REGISTER R9 
macro EMB$Q_CR_R10 = 208,0,0,0 %;
literal EMB$S_CR_R10 = 8;               ! REGISTER R10 
macro EMB$Q_CR_R11 = 216,0,0,0 %;
literal EMB$S_CR_R11 = 8;               ! REGISTER R11 
macro EMB$Q_CR_R12 = 224,0,0,0 %;
literal EMB$S_CR_R12 = 8;               ! REGISTER R12 
macro EMB$Q_CR_R13 = 232,0,0,0 %;
literal EMB$S_CR_R13 = 8;               ! REGISTER R13 
macro EMB$Q_CR_R14 = 240,0,0,0 %;
literal EMB$S_CR_R14 = 8;               ! REGISTER R14 
macro EMB$Q_CR_R15 = 248,0,0,0 %;
literal EMB$S_CR_R15 = 8;               ! REGISTER R15 
macro EMB$Q_CR_R16 = 256,0,0,0 %;
literal EMB$S_CR_R16 = 8;               ! REGISTER R16 
macro EMB$Q_CR_R17 = 264,0,0,0 %;
literal EMB$S_CR_R17 = 8;               ! REGISTER R17 
macro EMB$Q_CR_R18 = 272,0,0,0 %;
literal EMB$S_CR_R18 = 8;               ! REGISTER R18 
macro EMB$Q_CR_R19 = 280,0,0,0 %;
literal EMB$S_CR_R19 = 8;               ! REGISTER R19 
macro EMB$Q_CR_R20 = 288,0,0,0 %;
literal EMB$S_CR_R20 = 8;               ! REGISTER R20 
macro EMB$Q_CR_R21 = 296,0,0,0 %;
literal EMB$S_CR_R21 = 8;               ! REGISTER R21 
macro EMB$Q_CR_R22 = 304,0,0,0 %;
literal EMB$S_CR_R22 = 8;               ! REGISTER R22 
macro EMB$Q_CR_R23 = 312,0,0,0 %;
literal EMB$S_CR_R23 = 8;               ! REGISTER R23 
macro EMB$Q_CR_R24 = 320,0,0,0 %;
literal EMB$S_CR_R24 = 8;               ! REGISTER R24 
macro EMB$Q_CR_R25 = 328,0,0,0 %;
literal EMB$S_CR_R25 = 8;               ! REGISTER R25 
macro EMB$Q_CR_R26 = 336,0,0,0 %;
literal EMB$S_CR_R26 = 8;               ! REGISTER R26 
macro EMB$Q_CR_R27 = 344,0,0,0 %;
literal EMB$S_CR_R27 = 8;               ! REGISTER R27 
macro EMB$Q_CR_R28 = 352,0,0,0 %;
literal EMB$S_CR_R28 = 8;               ! REGISTER R28 
macro EMB$Q_CR_FP = 360,0,0,0 %;
literal EMB$S_CR_FP = 8;                ! FRAME POINTER 
macro EMB$Q_CR_SP = 368,0,0,0 %;
literal EMB$S_CR_SP = 8;                ! CURRENT STACK POINTER 
macro EMB$Q_CR_PC = 376,0,0,0 %;
literal EMB$S_CR_PC = 8;                ! PROGRAM COUNTER 
macro EMB$Q_CR_PSL = 384,0,0,0 %;
literal EMB$S_CR_PSL = 8;               ! PROCESSOR STATUS 
macro EMB$Q_CR_PTBR = 392,0,0,0 %;
literal EMB$S_CR_PTBR = 8;              ! PAGE TABLE BASE REGISTER
macro EMB$Q_CR_PCBB = 400,0,0,0 %;
literal EMB$S_CR_PCBB = 8;              ! PRIVILEGED CONTEXT BLOCK BASE
macro EMB$Q_CR_PRBR = 408,0,0,0 %;
literal EMB$S_CR_PRBR = 8;              ! PROCESSOR BASE REGISTER
macro EMB$Q_CR_VPTB = 416,0,0,0 %;
literal EMB$S_CR_VPTB = 8;              ! VIRTUAL PAGE TABLE BASE REGISTER
macro EMB$Q_CR_SCBB = 424,0,0,0 %;
literal EMB$S_CR_SCBB = 8;              ! SYSTEM CONTROL BLOCK BASE
macro EMB$Q_CR_SISR = 432,0,0,0 %;
literal EMB$S_CR_SISR = 8;              ! SOFTWARE INTERRUPT SUMMARY REG
macro EMB$Q_CR_ASN = 440,0,0,0 %;
literal EMB$S_CR_ASN = 8;               ! ADDRESS SPACE NUMBER
macro EMB$Q_CR_ASTSR_ASTEN = 448,0,0,0 %;
literal EMB$S_CR_ASTSR_ASTEN = 8;       ! AST SUMMARY AND ENABLE REGS
macro EMB$Q_CR_FEN = 456,0,0,0 %;
literal EMB$S_CR_FEN = 8;               ! FLOATING ENABLE
macro EMB$Q_CR_IPL = 464,0,0,0 %;
literal EMB$S_CR_IPL = 8;               ! INTERRUPT PRIORITY LEVEL
macro EMB$Q_CR_MCES = 472,0,0,0 %;
literal EMB$S_CR_MCES = 8;              ! MACHINE CHECK ERROR SUMMARY REG
!  Remember start of CPU-dependent info
literal EMB$S_EMBCRDEF = 484;           !  Old size name - synonym
literal EMB$S_EMBCR = 484;
macro EMB$L_CR_CPUREG = 480,0,32,0 %;   ! START OF CPU-SPECIFIC IPR'S 
!  CPU-specific registers for the 11/780:
literal EMB$K_CR1_LENGTH = 576;
literal EMB$C_CR1_LENGTH = 576;
literal EMB$S_EMBCRDEF1 = 576;          !  Old size name - synonym
literal EMB$S_EMBCR1 = 576;
macro EMB$L_CR_ICR = 480,0,32,0 %;      ! INTERVAL COUNT REGISTER 
macro EMB$L_CR_TODR = 484,0,32,0 %;     ! TIME OF DAY REGISTER 
macro EMB$L_CR_ACCS = 488,0,32,0 %;     ! ACCELERATOR CONTROL REGISTER 
macro EMB$L_CR_SBIFS = 492,0,32,0 %;    !  SBI FAULT STATUS 
macro EMB$L_CR_SBISC = 496,0,32,0 %;    !  SBI COMPARATOR REGISTER 
macro EMB$L_CR_SBIMT = 500,0,32,0 %;    !  SBI MAINT REGISTER 
macro EMB$L_CR_SBIER = 504,0,32,0 %;    !  SBI ERROR REGISTER 
macro EMB$L_CR_SBITA = 508,0,32,1 %;    !  SBI TIMEOUT ADDR REGISTER 
macro EMB$L_CR_SBIS = 512,0,0,0 %;
literal EMB$S_CR_SBIS = 64;             !  SBI SILO 
!  CPU-specific registers for the 11/750:
literal EMB$K_CR2_LENGTH = 512;
literal EMB$C_CR2_LENGTH = 512;
literal EMB$S_EMBCRDEF2 = 512;          !  Old size name - synonym
literal EMB$S_EMBCR2 = 512;
macro EMB$L_CR_TBDR = 492,0,32,0 %;     !  TB DISABLE REGISTER 
macro EMB$L_CR_CADR = 496,0,32,0 %;     !  CACHE DISABLE REGISTER 
macro EMB$L_CR_MCESR = 500,0,32,0 %;    !  MACHINE CHECK ERROR SUMMARY 
macro EMB$L_CR_CAER = 504,0,32,0 %;     !  CACHE ERROR REGISTER 
macro EMB$L_CR_CMIERR = 508,0,32,0 %;   !  CMI ERROR SUMMARY REGISTER 
!  16 UNUSED LONGWDS IN EMB
literal EMB$K_CR3_LENGTH = 600;         ! SIZE OF FIXED PART OF BUGCHECK MESSAGE 
literal EMB$C_CR3_LENGTH = 600;         ! SIZE OF FIXED PART OF BUGCHECK MESSAGE 
literal EMB$S_EMBCRDEF3 = 600;          !  Old size name - synonym
literal EMB$S_EMBCR3 = 600;
macro EMB$L_CR_CODE = 576,0,32,0 %;     ! BUGCHECK/CRASH CODE 
macro EMB$L_CR_PID = 580,0,32,0 %;      ! CURRENT PROCESS ID 
macro EMB$T_CR_LNAME = 584,0,0,0 %;
literal EMB$S_CR_LNAME = 16;            ! CURRENT PROCESS NAME 
 
!*** MODULE $EMBDVDEF ***
! 
!  DEVICE ERROR MESSAGE BUFFER FORMAT (ERROR AND TIMEOUT)
! 
literal EMB$K_DV_LENGTH = 222;
literal EMB$C_DV_LENGTH = 222;
literal EMB$S_EMBDVDEF = 222;           ! Old size name - synonym
literal EMB$S_EMBDV = 222;
macro EMB$L_DV_SID = 0,0,32,0 %;        ! SYSTEM ID 
macro EMB$W_DV_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_DV_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_DV_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_DV_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_DV_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$B_DV_SCS_NAME = 16,0,0,0 %;
literal EMB$S_DV_SCS_NAME = 16;         !  SCS node name in ASCIC
macro EMB$W_DV_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_DV_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_DV_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_DV_ENTRY = 36,0,16,0 %;     ! ENTRY TYPE (1=ERROR, 96=TIMEOUT) 
macro EMB$Q_DV_TIME = 38,0,0,0 %;
literal EMB$S_DV_TIME = 8;              ! TIME OF ERROR 
macro EMB$W_DV_ERRSEQ = 46,0,16,0 %;    ! ERROR SEQUENCE NUMBER 
macro EMB$Q_DV_SWVERS = 48,0,0,0 %;
literal EMB$S_DV_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_DV_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_DV_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$B_DV_HW_NAME_LEN = 64,0,8,0 %; !  Length of marketing name of this system
macro EMB$T_DV_HW_NAME = 65,0,0,0 %;
literal EMB$S_DV_HW_NAME = 31;          !  marketing name of this system
macro EMB$L_DV_ERTCNT = 96,0,32,0 %;    ! REMAINING NUMBER OF ERROR RETRIES 
macro EMB$L_DV_ERTMAX = 100,0,32,0 %;   ! MAXIMUM NUMBER OF ERROR RETRIES 
macro EMB$Q_DV_IOSB = 104,0,0,0 %;
literal EMB$S_DV_IOSB = 8;              ! FINAL I/O STATUS 
macro EMB$L_DV_STS = 112,0,32,0 %;      ! FINAL DEVICE STATUS 
macro EMB$B_DV_CLASS = 116,0,8,0 %;     ! DEVICE CLASS 
macro EMB$B_DV_TYPE = 117,0,8,0 %;      ! DEVICE TYPE 
macro EMB$L_DV_RQPID = 118,0,32,0 %;    ! REQUESTER PROCESS ID 
macro EMB$L_DV_BOFF = 122,0,32,0 %;     ! BYTE OFFSET IN PAGE 
macro EMB$L_DV_BCNT = 126,0,32,0 %;     ! TRANSFER BYTE COUNT 
macro EMB$L_DV_MEDIA = 130,0,32,1 %;    ! STARTING MEDIA ADDRESS 
macro EMB$W_DV_UNIT = 134,0,16,0 %;     ! PHYSICAL UNIT NUMBER 
macro EMB$L_DV_ERRCNT = 136,0,32,0 %;   ! UNIT ERROR COUNT 
macro EMB$L_DV_OPCNT = 140,0,32,0 %;    ! UNIT OPERATION COUNT 
macro EMB$L_DV_OWNUIC = 144,0,32,0 %;   ! VOLUME OWNER UIC 
macro EMB$L_DV_CHAR = 148,0,32,0 %;     ! DEVICE CHARACTERISTICS 
macro EMB$B_DV_SLAVE = 152,0,8,0 %;     ! SLAVE CONTROLLER NUMBER 
macro EMB$L_DV_FUNC = 154,0,32,0 %;     ! I/O FUNCTION VALUE 
macro EMB$T_DV_NAME = 158,0,0,0 %;
literal EMB$S_DV_NAME = 32;             ! DEVICE NAME 
macro EMB$T_DV_DTNAME = 190,0,0,0 %;
literal EMB$S_DV_DTNAME = 28;           ! Device type name
! counted string
macro EMB$L_DV_REGSAV = 218,0,32,1 %;   ! START OF REGISTER SAVE AREA 
!  EMB$K_PWR layout:
! 
!  0:	+----------------------+
!  	|		       |
!  	| Standard EMB header  |
!  	|         64 bytes     |
!  	+----------------------+
!  64:	|		       |
!  	| Power regulator      |
!      	|     summary 4 bytes  |
!   	+----------------------+
!  68:	|		       |
!  	| LASER_POWER version  |
!  	|	 8 bytes       |
!  	+----------------------+
!  76:	|		       |
!  	|   Record sub-type    |
!      	|       4 bytes	       |
!   	+----------------------+
! 
!  Sub-type=EMB$K_pwr_state_event  Sub-type=EMB$K_pwr_history_event  Sub-type=EMB$K_pwr_bad_event      Sub-type=EMB$K_pwr_gbus
! 
!       +----------------------+        +---------------------+       +-------------------------+      +---------------------+
!  80:  |     Center cabinet   |   80:  |    Center Cabinet   |   80: |                         |  80: |                     |
!       |Regulator A time-stamp|        | Regulator A "H" msg |       |      Regulator id       |      |  GBUS$HALT register |
!       |       8 bytes        |        |      54 bytes       |       |         8 bytes         |      |      4 bytes        |
!       +----------------------+        +---------------------+       +-------------------------+      +---------------------+
!  88:  |     Center cabinet   |   134: |                     |   88: |                         |  84: |     previous        |
!       |Regulator B time-stamp|        |  2 bytes padding    |       |     Problem type        |      |  GBUS$HALT register |
!       |       8 bytes        |        |                     |       |         4 bytes         |      |      4 bytes        |
!       +----------------------+        +---------------------+       +-------------------------+      +---------------------+
!  96:  |     Center cabinet   |   136: |    Center Cabinet   |   92: |                         |  88:
!       |Regulator C time-stamp|        | Regulator B "H" msg |       |  Regulator "B" msg      |
!       |       8 bytes        |        |      54 bytes       |       |         9 bytes         |
!       +----------------------+        +---------------------+       +-------------------------+
!  104: |     Left cabinet     |   190: |                     |   101:
!       |Regulator A time-stamp|        |   2 bytes padding   |
!       |       8 bytes        |        |                     |
!       +----------------------+        +---------------------+
!  112: |     Left cabinet     |   192: |    Center Cabinet   |
!       |Regulator B time-stamp|        | Regulator C "H" msg |
!       |       8 bytes        |        |      54 bytes       |
!       +----------------------+        +---------------------+
!  120: |     Left cabinet     |   246: |                     |
!       |Regulator C time-stamp|        |   2 bytes padding   |
!       |       8 bytes        |        |                     |
!       +----------------------+        +---------------------+
!  128: |     Right cabinet    |   248: |    Left Cabinet     |
!       |Regulator A time-stamp|        | Regulator A "H" msg |
!       |       8 bytes        |        |      54 bytes       |
!       +----------------------+        +---------------------+
!  136: |     Right cabinet    |   302: |                     |
!       |Regulator B time-stamp|        |   2 bytes padding   |
!       |       8 bytes        |        |                     |
!       +----------------------+        +---------------------+
!  144: |     Right cabinet    |   304: |    Left Cabinet     |
!       |Regulator C time-stamp|        | Regulator B "H" msg |
!       |       8 bytes        |        |      54 bytes       |
!       +----------------------+        +---------------------+
!  152: |     Center cabinet   |   358: |                     |
!       | Regulator A "B" msg  |        |   2 bytes padding   |
!       |       9 bytes        |        |                     |
!       +----------------------+        +---------------------+
!  161: |                      |   360: |    Left Cabinet     |
!       |   3 bytes padding    |        | Regulator C "H" msg |
!       |                      |        |      54 bytes       |
!       +----------------------+        +---------------------+
!  164: |     Center cabinet   |   414: |                     |
!       | Regulator B "B" msg  |        |   2 bytes padding   |
!       |        9 bytes       |        |                     |
!       +----------------------+        +---------------------+
!  173: |                      |   416: |    Right Cabinet    |
!       |   3 bytes padding    |        | Regulator A "H" msg |
!       |                      |        |      54 bytes       |
!       +----------------------+        +---------------------+
!  176: |     Center cabinet   |   470: |                     |
!       | Regulator C "B" msg  |        |   2 bytes padding   |
!       |        9 bytes       |        |                     |
!       +----------------------+        +---------------------+
!  185: |                      |   472: |    Right Cabinet    |
!       |   3 bytes padding    |        | Regulator B "H" msg |
!       |                      |        |      54 bytes       |
!       +----------------------+        +---------------------+
!  188: |     Center cabinet   |   526: |                     |
!       | Regulator A "B" msg  |        |   2 bytes padding   |
!       |        9 bytes       |        |                     |
!       +----------------------+        +---------------------+
!  197: |                      |   528: |     Right Cabinet   |
!       |   3 bytes padding    |        | Regulator C "H" msg |
!       |                      |        |      54 bytes       |
!       +----------------------+        +---------------------+
!  200: |     Center cabinet   |   582: |                     |
!       | Regulator B "B" msg  |        |   2 bytes padding   |
!       |        9 bytes       |        |                     |
!       +----------------------+        +---------------------+
!  209: |                      |   584:
!       |   3 bytes padding    |
!       |                      |
!       +----------------------+
!  212: |     Center cabinet   |
!       | Regulator C "B" msg  |
!       |        9 bytes       |
!       +----------------------+
!  221: |                      |
!       |   3 bytes padding    |
!       |                      |
!       +----------------------+
!  224: |     Center cabinet   |
!       | Regulator A "B" msg  |
!       |        9 bytes       |
!       +----------------------+
!  233: |                      |
!       |   3 bytes padding    |
!       |                      |
!       +----------------------+
!  236: |     Center cabinet   |
!       | Regulator B "B" msg  |
!       |        9 bytes       |
!       +----------------------+
!  245: |                      |
!       |   3 bytes padding    |
!       |                      |
!       +----------------------+
!  248: |     Center cabinet   |
!       | Regulator C "B" msg  |
!       |        9 bytes       |
!       +----------------------+
!  257: |                      |
!       |   3 bytes padding    |
!       |                      |
!       +----------------------+
!  260: |    Event regulator   |
!       |           Id         |
!       |        8 bytes       |
!       +----------------------+
!  268: |    Event regulator   |
!       |     "S" messages     |
!       |       54 bytes       |
!       +----------------------+
!  322:
! 
 
!*** MODULE $EMBPWRDEF ***
! 
!  Power event message
! 
literal EMB$K_PWR_STATE_LENGTH = 354;
literal EMB$C_PWR_STATE_LENGTH = 354;
literal EMB$K_PWR_HISTORY_LENGTH = 616;
literal EMB$C_PWR_HISTORY_LENGTH = 616;
literal EMB$K_PWR_BAD_LENGTH = 133;
literal EMB$C_PWR_BAD_LENGTH = 133;
literal EMB$K_PWR_GBUS_LENGTH = 120;
literal EMB$C_PWR_GBUS_LENGTH = 120;
literal EMB$S_EMBPWRDEF = 616;          !  Old size name - synonym
literal EMB$S_EMBPWR = 616;
macro EMB$L_PWR_SID = 0,0,32,0 %;       ! SYSTEM ID
macro EMB$W_PWR_HDR_REV = 4,0,16,0 %;   !  HEADER REV LEVEL
macro EMB$L_PWR_XSID = 6,0,32,0 %;      !  SYS_TYPE REGISTER
macro EMB$L_PWR_CPUID = 10,0,32,0 %;    !  UNIQUE CPU ID
macro EMB$B_PWR_DEV_CLASS = 14,0,8,0 %; !  DEVICE CLASS
macro EMB$B_PWR_DEV_TYPE = 15,0,8,0 %;  !  DEVICE TYPE
macro EMB$B_PWR_SCS_NAME = 16,0,0,0 %;
literal EMB$S_PWR_SCS_NAME = 16;        !  SCS node name in ASCIC
macro EMB$W_PWR_FLAGS = 32,0,16,0 %;    !  MISC. FLAGS
macro EMB$B_PWR_OS_ID = 34,0,8,0 %;     !  LOGGING OS ID
macro EMB$B_PWR_HDRSZ = 35,0,8,0 %;     !  HEADER SIZE
macro EMB$W_PWR_ENTRY = 36,0,16,0 %;    !  ENTRY TYPE
macro EMB$Q_PWR_TIME = 38,0,0,0 %;
literal EMB$S_PWR_TIME = 8;             !  TIME IN 64 BITS
macro EMB$W_PWR_ERRSEQ = 46,0,16,0 %;   !  ERROR SEQ !
macro EMB$Q_PWR_SWVERS = 48,0,0,0 %;
literal EMB$S_PWR_SWVERS = 8;           !  SOFTWARE VERSION
macro EMB$L_PWR_ERRMSK = 56,0,32,0 %;   !  ERROR MASK
macro EMB$L_PWR_ABSTIM = 60,0,32,0 %;   !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$B_PWR_HW_NAME_LEN = 64,0,8,0 %; !  Length of marketing name of this system
macro EMB$T_PWR_HW_NAME = 65,0,0,0 %;
literal EMB$S_PWR_HW_NAME = 31;         !  marketing name of this system
! 
!   Header common to all power events
! 
macro EMB$L_PWR_SUMMARY = 96,0,32,0 %;  !  Summary of regulators found
macro EMB$Q_PWR_VERSION = 100,0,0,0 %;
literal EMB$S_PWR_VERSION = 8;          !  The version of laser_power.bli
macro EMB$L_PWR_TYPE = 108,0,32,0 %;    !  Type of power event
! 
!   4 possible sub typers in the union
! 
! 
!   This is the type EMB$K_pwr_state_event specific layout
! 
macro EMB$Q_PWR_STATE_TIME_CENTER_A = 112,0,0,0 %;
literal EMB$S_PWR_STATE_TIME_CENTER_A = 8; !  Timestamp regulator A center cabinet
macro EMB$Q_PWR_STATE_TIME_CENTER_B = 120,0,0,0 %;
literal EMB$S_PWR_STATE_TIME_CENTER_B = 8; !  Timestamp regulator B center cabinet
macro EMB$Q_PWR_STATE_TIME_CENTER_C = 128,0,0,0 %;
literal EMB$S_PWR_STATE_TIME_CENTER_C = 8; !  Timestamp regulator C center cabinet
macro EMB$Q_PWR_STATE_TIME_LEFT_A = 136,0,0,0 %;
literal EMB$S_PWR_STATE_TIME_LEFT_A = 8; !  Timestamp regulator A left cabinet
macro EMB$Q_PWR_STATE_TIME_LEFT_B = 144,0,0,0 %;
literal EMB$S_PWR_STATE_TIME_LEFT_B = 8; !  Timestamp regulator B left cabinet
macro EMB$Q_PWR_STATE_TIME_LEFT_C = 152,0,0,0 %;
literal EMB$S_PWR_STATE_TIME_LEFT_C = 8; !  Timestamp regulator C left cabinet
macro EMB$Q_PWR_STATE_TIME_RIGHT_A = 160,0,0,0 %;
literal EMB$S_PWR_STATE_TIME_RIGHT_A = 8; !  Timestamp regulator A right cabinet
macro EMB$Q_PWR_STATE_TIME_RIGHT_B = 168,0,0,0 %;
literal EMB$S_PWR_STATE_TIME_RIGHT_B = 8; !  Timestamp regulator B right cabinet
macro EMB$Q_PWR_STATE_TIME_RIGHT_C = 176,0,0,0 %;
literal EMB$S_PWR_STATE_TIME_RIGHT_C = 8; !  Timestamp regulator C right cabinet
macro EMB$T_PWR_STATE_BMSG_CENTER_A = 184,0,0,0 %;
literal EMB$S_PWR_STATE_BMSG_CENTER_A = 9; !  B message regulator A center cabinet
macro EMB$T_PWR_STATE_BMSG_CENTER_B = 196,0,0,0 %;
literal EMB$S_PWR_STATE_BMSG_CENTER_B = 9; !  B message regulator B center cabinet
macro EMB$T_PWR_STATE_BMSG_CENTER_C = 208,0,0,0 %;
literal EMB$S_PWR_STATE_BMSG_CENTER_C = 9; !  B message regulator C center cabinet
macro EMB$T_PWR_STATE_BMSG_LEFT_A = 220,0,0,0 %;
literal EMB$S_PWR_STATE_BMSG_LEFT_A = 9; !  B message regulator A left cabinet
macro EMB$T_PWR_STATE_BMSG_LEFT_B = 232,0,0,0 %;
literal EMB$S_PWR_STATE_BMSG_LEFT_B = 9; !  B message regulator B left cabinet
macro EMB$T_PWR_STATE_BMSG_LEFT_C = 244,0,0,0 %;
literal EMB$S_PWR_STATE_BMSG_LEFT_C = 9; !  B message regulator C left cabinet
macro EMB$T_PWR_STATE_BMSG_RIGHT_A = 256,0,0,0 %;
literal EMB$S_PWR_STATE_BMSG_RIGHT_A = 9; !  B message regulator A right cabinet
macro EMB$T_PWR_STATE_BMSG_RIGHT_B = 268,0,0,0 %;
literal EMB$S_PWR_STATE_BMSG_RIGHT_B = 9; !  B message regulator B right cabinet
macro EMB$T_PWR_STATE_BMSG_RIGHT_C = 280,0,0,0 %;
literal EMB$S_PWR_STATE_BMSG_RIGHT_C = 9; !  B message regulator C right cabinet
macro EMB$R_PWR_STATE_ID = 292,0,0,0 %;
literal EMB$S_PWR_STATE_ID = 8;
macro EMB$L_PWR_STATE_ID_CABINET = 292,0,32,0 %; !  Event cabinet id
macro EMB$L_PWR_STATE_ID_REGULATOR = 296,0,32,0 %; !  Event regulator id
macro EMB$T_PWR_STATE_SMSG = 300,0,0,0 %;
literal EMB$S_PWR_STATE_SMSG = 54;      !  S message from event regulator
! 
!   This is the type EMB$K_pwr_history_event specific layout
! 
macro EMB$R_HISTORY = 112,0,0,0 %;
literal EMB$S_HISTORY = 504;
macro EMB$T_PWR_HISTORY_HMSG_CENTER_A = 112,0,0,0 %;
literal EMB$S_PWR_HISTORY_HMSG_CENTER_A = 54; !  H message regulator A center cabinet
macro EMB$T_PWR_HISTORY_HMSG_CENTER_B = 168,0,0,0 %;
literal EMB$S_PWR_HISTORY_HMSG_CENTER_B = 54; !  H message regulator B center cabinet
macro EMB$T_PWR_HISTORY_HMSG_CENTER_C = 224,0,0,0 %;
literal EMB$S_PWR_HISTORY_HMSG_CENTER_C = 54; !  H message regulator C center cabinet
macro EMB$T_PWR_HISTORY_HMSG_LEFT_A = 280,0,0,0 %;
literal EMB$S_PWR_HISTORY_HMSG_LEFT_A = 54; !  H message regulator A left cabinet
macro EMB$T_PWR_HISTORY_HMSG_LEFT_B = 336,0,0,0 %;
literal EMB$S_PWR_HISTORY_HMSG_LEFT_B = 54; !  H message regulator B left cabinet
macro EMB$T_PWR_HISTORY_HMSG_LEFT_C = 392,0,0,0 %;
literal EMB$S_PWR_HISTORY_HMSG_LEFT_C = 54; !  H message regulator C left cabinet
macro EMB$T_PWR_HISTORY_HMSG_RIGHT_A = 448,0,0,0 %;
literal EMB$S_PWR_HISTORY_HMSG_RIGHT_A = 54; !  H message regulator A right cabinet
macro EMB$T_PWR_HISTORY_HMSG_RIGHT_B = 504,0,0,0 %;
literal EMB$S_PWR_HISTORY_HMSG_RIGHT_B = 54; !  H message regulator B right cabinet
macro EMB$T_PWR_HISTORY_HMSG_RIGHT_C = 560,0,0,0 %;
literal EMB$S_PWR_HISTORY_HMSG_RIGHT_C = 54; !  H message regulator C right cabinet
! 
!   This is the type EMB$K_pwr_bad_event specific layout
! 
macro EMB$R_BAD = 112,0,0,0 %;
literal EMB$S_BAD = 21;
macro EMB$R_PWR_BAD_ID = 112,0,0,0 %;
literal EMB$S_PWR_BAD_ID = 8;
macro EMB$L_PWR_BAD_ID_CABINET = 112,0,32,0 %; !  Event cabinet id
macro EMB$L_PWR_BAD_ID_REGULATOR = 116,0,32,0 %; !  Event regulator id
macro EMB$L_PWR_BAD_TYPE = 120,0,32,0 %; !  Bad event type
macro EMB$T_PWR_BAD_BMSG = 124,0,0,0 %;
literal EMB$S_PWR_BAD_BMSG = 9;         !  B message from event regulator
! 
!   This is the type EMB$K_gbus specific layout
! 
macro EMB$R_GBUS = 112,0,0,0 %;
literal EMB$S_GBUS = 8;
macro EMB$L_PWR_GBUS_HALT = 112,0,32,0 %; !  current GBUS$HALT register
macro EMB$L_PWR_LAST_GBUS = 116,0,32,0 %; !  previous GBUS$HALT register
! 
!  Values in PWR_TYPE.
! 
literal EMB$K_PWR_state_event = 1;      !  State change event
literal EMB$K_PWR_history_event = 2;    !  Initial history event
literal EMB$K_PWR_bad_event = 3;        !  Bad checksum or no ans
literal EMB$K_PWR_GBUS_event = 4;       !  GBUS had some bits set
 
!*** MODULE $EMBTSDEF ***
! 
!  TIME STAMP MSG FORMAT
! 
literal EMB$K_TS_LENGTH = 96;           ! LENGTH OF TIME STAMP MSG 
literal EMB$C_TS_LENGTH = 96;           ! LENGTH OF TIME STAMP MSG 
literal EMB$S_EMBTSDEF = 96;            !  Old size name - synonym
literal EMB$S_EMBTS = 96;
macro EMB$L_TS_SID = 0,0,32,0 %;        ! SYSTEM ID 
macro EMB$W_TS_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_TS_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_TS_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_TS_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_TS_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$B_TS_SCS_NAME = 16,0,0,0 %;
literal EMB$S_TS_SCS_NAME = 16;         !  SCS node name in ASCIC
macro EMB$W_TS_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_TS_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_TS_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_TS_ENTRY = 36,0,16,0 %;     ! ENTRY TYPE 
macro EMB$Q_TS_TIME = 38,0,0,0 %;
literal EMB$S_TS_TIME = 8;              ! TIME IN 64 BITS 
macro EMB$W_TS_ERRSEQ = 46,0,16,0 %;    ! ERROR SEQ ! 
macro EMB$Q_TS_SWVERS = 48,0,0,0 %;
literal EMB$S_TS_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_TS_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_TS_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$B_TS_HW_NAME_LEN = 64,0,8,0 %; !  Length of marketing name of this system
macro EMB$T_TS_HW_NAME = 65,0,0,0 %;
literal EMB$S_TS_HW_NAME = 31;          !  marketing name of this system
 
!*** MODULE $EMBSSDEF ***
! 
!  SYSTEM SERVICE MESSAGE
! 
!         NOTE:        SYSTEM SERVICE MESSAGE COVERS:
! 
!                 1) THE MESSAGES FROM THE SERVICE
!                 2) OPERATOR MESSAGES
!                 3) NETWORK MESSAGES
! 
!         ONLY THE TYPE FIELD IS DIFERENT
! 
literal EMB$K_SS_LENGTH = 98;           ! LENGTH OF CONSTANT PART 
literal EMB$C_SS_LENGTH = 98;           ! LENGTH OF CONSTANT PART 
literal EMB$S_EMBSSDEF = 99;            !  Old size name - synonym
literal EMB$S_EMBSS = 99;
macro EMB$L_SS_SID = 0,0,32,0 %;        ! SYSTEM ID 
macro EMB$W_SS_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_SS_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_SS_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_SS_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_SS_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$B_SS_SCS_NAME = 16,0,0,0 %;
literal EMB$S_SS_SCS_NAME = 16;         !  SCS node name in ASCIC
macro EMB$W_SS_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_SS_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_SS_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_SS_ENTRY = 36,0,16,0 %;     ! ENTRY TYPE 
macro EMB$Q_SS_TIME = 38,0,0,0 %;
literal EMB$S_SS_TIME = 8;              ! TIME IN 64 BITS 
macro EMB$W_SS_ERRSEQ = 46,0,16,0 %;    ! ERROR SEQUENCE NUMBER 
macro EMB$Q_SS_SWVERS = 48,0,0,0 %;
literal EMB$S_SS_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_SS_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_SS_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$B_SS_HW_NAME_LEN = 64,0,8,0 %; !  Length of marketing name of this system
macro EMB$T_SS_HW_NAME = 65,0,0,0 %;
literal EMB$S_SS_HW_NAME = 31;          !  marketing name of this system
macro EMB$W_SS_MSGSZ = 96,0,16,0 %;     ! MESSAGE TEXT SIZE IN BYTES 
macro EMB$B_SS_MSGTXT = 98,0,8,0 %;     ! FIRST BYTE OF MESSAGE TEXT 
 
!*** MODULE $EMBVMDEF ***
! 
!  VOLUME MOUNT/DISMOUNT MESSAGE TYPE
! 
literal EMB$K_VM_LENGTH = 158;          ! LENGTH OF BUFFER 
literal EMB$C_VM_LENGTH = 158;          ! LENGTH OF BUFFER 
literal EMB$S_EMBVMDEF = 158;           !  Old size name - synonym
literal EMB$S_EMBVM = 158;
macro EMB$L_VM_SID = 0,0,32,0 %;        ! SYSTEM ID 
macro EMB$W_VM_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_VM_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_VM_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_VM_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_VM_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$B_VM_SCS_NAME = 16,0,0,0 %;
literal EMB$S_VM_SCS_NAME = 16;         !  SCS node name in ASCIC
macro EMB$W_VM_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_VM_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_VM_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_VM_ENTRY = 36,0,16,0 %;     ! ENTRY TYPE = EMB$K_VM OR EMB$K_VD 
macro EMB$Q_VM_TIME = 38,0,0,0 %;
literal EMB$S_VM_TIME = 8;              ! TIME IN 64 BIT FORMAT 
macro EMB$W_VM_ERRSEQ = 46,0,16,0 %;    ! ERROR SEQUENCE NUMBER 
macro EMB$Q_VM_SWVERS = 48,0,0,0 %;
literal EMB$S_VM_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_VM_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_VM_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$B_VM_HW_NAME_LEN = 64,0,8,0 %; !  Length of marketing name of this system
macro EMB$T_VM_HW_NAME = 65,0,0,0 %;
literal EMB$S_VM_HW_NAME = 31;          !  marketing name of this system
macro EMB$L_VM_OWNUIC = 96,0,32,0 %;    ! OWNER UIC OF THE VOLUME 
macro EMB$L_VM_ERRCNT = 100,0,32,0 %;   ! UNIT ERROR COUNT FROM UCB 
macro EMB$L_VM_OPRCNT = 104,0,32,0 %;   ! UNIT OPERATION COUNT FROM UCB 
macro EMB$W_VM_UNIT = 108,0,16,0 %;     ! DEVICE UNIT NUMBER 
macro EMB$B_VM_NAMLNG = 110,0,8,0 %;    ! LENGTH OF DEVICE GENERIC NAME 
macro EMB$T_VM_NAMTXT = 111,0,0,0 %;
literal EMB$S_VM_NAMTXT = 31;           ! DEVICE GENERIC NAME 
macro EMB$W_VM_VOLNUM = 142,0,16,0 %;   ! VOLUME NUMBER WITHIN SET 
macro EMB$W_VM_NUMSET = 144,0,16,0 %;   ! NUMBER OF VOLUMES WITHIN SET 
macro EMB$T_VM_LABEL = 146,0,0,0 %;
literal EMB$S_VM_LABEL = 12;            ! VOLUME LABEL 
 
!*** MODULE $EMBSUDEF ***
! 
!  SYSTEM STARTUP MESSAGE
! 
literal EMB$K_SU_LENGTH = 100;          ! LENGTH OF MESSAGE 
literal EMB$C_SU_LENGTH = 100;          ! LENGTH OF MESSAGE 
literal EMB$S_EMBSUDEF = 100;           !  Old size name - synonym
literal EMB$S_EMBSU = 100;
macro EMB$L_SU_SID = 0,0,32,0 %;        ! SYSTEM ID 
macro EMB$W_SU_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_SU_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_SU_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_SU_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_SU_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$B_SU_SCS_NAME = 16,0,0,0 %;
literal EMB$S_SU_SCS_NAME = 16;         !  SCS node name in ASCIC
macro EMB$W_SU_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_SU_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_SU_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_SU_ENTRY = 36,0,16,0 %;     ! ENTRY TYPE (IE: BOOT OR POWER RECOVERY) 
macro EMB$Q_SU_TIME = 38,0,0,0 %;
literal EMB$S_SU_TIME = 8;              ! CONTENTS OF SYSTEM TIME QUADWORD 
macro EMB$W_SU_ERRSEQ = 46,0,16,0 %;    ! ERROR SEQUENCE NUMBER 
macro EMB$Q_SU_SWVERS = 48,0,0,0 %;
literal EMB$S_SU_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_SU_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_SU_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$B_SU_HW_NAME_LEN = 64,0,8,0 %; !  Length of marketing name of this system
macro EMB$T_SU_HW_NAME = 65,0,0,0 %;
literal EMB$S_SU_HW_NAME = 31;          !  marketing name of this system
macro EMB$L_SU_DAYTIM = 96,0,32,0 %;    ! CONTENTS OF TIME OF DAY CLOCK 
 
!*** MODULE $EMBMCDEF ***
! 
!  MACHINE CHECK LOG BUFFER FORMAT
! 
literal EMB$K_MC_LENGTH = 144;          ! LENGTH OF MACHINE CHECK FRAME 
literal EMB$C_MC_LENGTH = 144;          ! LENGTH OF MACHINE CHECK FRAME 
literal EMB$S_EMBMCDEF = 144;           !  Old size name - synonym
literal EMB$S_EMBMC = 144;
macro EMB$L_MC_SID = 0,0,32,0 %;        ! SYSTEM ID 
macro EMB$W_MC_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_MC_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_MC_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_MC_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_MC_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$B_MC_SCS_NAME = 16,0,0,0 %;
literal EMB$S_MC_SCS_NAME = 16;         !  SCS node name in ASCIC
macro EMB$W_MC_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_MC_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_MC_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_MC_ENTRY = 36,0,16,0 %;     ! ENTRY TYPE 
macro EMB$Q_MC_TIME = 38,0,0,0 %;
literal EMB$S_MC_TIME = 8;              ! TIME IN 64 BITS 
macro EMB$W_MC_ERRSEQ = 46,0,16,0 %;    ! ERROR SEQUENCE NUMBER 
macro EMB$Q_MC_SWVERS = 48,0,0,0 %;
literal EMB$S_MC_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_MC_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_MC_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$B_MC_HW_NAME_LEN = 64,0,8,0 %; !  Length of marketing name of this system
macro EMB$T_MC_HW_NAME = 65,0,0,0 %;
literal EMB$S_MC_HW_NAME = 31;          !  marketing name of this system
macro EMB$B_MC_SUMCOD = 96,0,8,0 %;     ! SUMMARY CODE 
macro EMB$B_MC_TOPF = 97,0,8,0 %;       ! TIME OUT PENDING FLAG 
macro EMB$B_MC_OPCODE = 98,0,8,0 %;     ! OPCODE OF INSTRUCTION CAUSING CHECK 
macro EMB$B_MC_CACHEF = 99,0,8,0 %;     ! CACHE DISABLE FLAG, 1=GROUP 0, 2=G 1 
macro EMB$L_MC_CES = 100,0,32,0 %;      ! CPU ERROR STATUS 
macro EMB$L_MC_UPC = 104,0,32,1 %;      ! MICRO-PC AT FAULT TIME 
macro EMB$L_MC_VA = 108,0,32,1 %;       ! VIRTUAL ADDRESS AT FAULT TIME 
macro EMB$L_MC_D = 112,0,32,0 %;        ! CPU D REGISTER AT FAULT TIME 
macro EMB$L_MC_TBER0 = 116,0,32,0 %;    ! TRANSLATION BUFFER STATUS REG 0 
macro EMB$L_MC_TBER1 = 120,0,32,0 %;    ! TRANSLATION BUFFER STATUS REG 1 
macro EMB$L_MC_TIMOAD = 124,0,32,1 %;   ! PHYSICAL ADDRESS CAUSING SBI TIMEOUT 
macro EMB$L_MC_PARITY = 128,0,32,0 %;   ! CACHE STATUS REGISTER 
macro EMB$L_MC_SBIERR = 132,0,32,0 %;   ! SBI ERROR REGISTER 
macro EMB$L_MC_PC = 136,0,32,1 %;       ! PC OF INSTRUCTION CAUSING CHECK 
macro EMB$L_MC_PSL = 140,0,32,0 %;      ! PSL OF MACHINE AT FAULT TIME 
! ++
!  
! 		+---------------------+ <- R2, after call to ALLOCEMB
! 		|                     |  ^
! 		|  EMB Header         |  |
! 		|                     |  v
! 		+---------------------+  - #EMB$K_HD_LENGTH
! 		|(user portion of EMB)|
! 		|                     |
! 		|   EMBSE header      |
! 		|                     |
! 		+- - - - - - - - - - -+ 
! 		|           XXX       | <- EMB$L_SE_MEMDSC_OFFSET
! 		+- - - - - - - - - - -+
! 		|                     |
! 		|                     |
! 		+- - - - - - - - - - -+
! 		|           YYY       | <- EMB$L_SE_FPRINT_OFFSET
! 		+---------------------+ <- #EMB$K_SE_FIXED_HD_LENGTH
! 		|  memory descriptor  | <- Start of memdsc = XXX(R2)
! 		|                     |
! 		+---------------------+ <- Start of fprints = YYY(R2)
! 		|  footprints         |
! 		|                     |
! 		|                     |
! 		|                     |
! 		+---------------------+
! 
! 
!  Depending on the entry that is logged, it is possible that one or both of the
!  memory descriptor and footprints are absent from the errorlog entry.  If 
!  EMB$L_SE_MEMDSC_OFFSET is zero, this indicates there is no memory descriptor
!  in this errorlog entry.  Likewise, if EMB$L_SE_FPRINT_OFFSET is zero, there
!  is no footprint section.
! 
!   The memory descriptor is system-dependent and represent the
!   memory configuration unique to each system.  For example, VAX 6000 systems
!   use a memory descriptor that describes each memory controller (MS62A, MS65A)
!   in the system.  Eight longwords of descriptor may be used to describe EACH
!   controller in the system.
! 
!   See note in header comments, but note that it is possible that the memory
!   descriptor and/or the footprint sections are not present in the errorlog
!   entry.  SE$L_MEMDSC_OFFSET = 0 indicates there is no memory
!   descriptor present -- likewise if SE$L_FPRINT_OFFSET = 0, there
!   are no footprints supplied.
! --
 
!*** MODULE $EMBSEDEF ***
! 
!  SOFT ECC DETECTED ERRORS
! 
literal EMB$K_SE_REVISION = 2;          !  Revision field
literal EMB$C_SE_REVISION = 2;          !  Revision field
literal EMB$M_SE_CRD_FLG_DISABLED = %X'1';
literal EMB$M_SE_CRD_FLG_LOST_INFO = %X'2';
literal EMB$M_SE_RSN_INIT_ERR = %X'1';
literal EMB$M_SE_RSN_FPRINTS_FULL = %X'2';
literal EMB$M_SE_RSN_SHUTDOWN = %X'4';
literal EMB$M_SE_RSN_DOMAIN_GREW = %X'8';
literal EMB$M_SE_RSN_BADPGS = %X'10';
literal EMB$K_SE_FIXED_HD_LENGTH = 128; !  Size of FIXED ERL HEADER
literal EMB$C_SE_FIXED_HD_LENGTH = 128; !  Size of FIXED ERL HEADER
literal EMB$S_EMBSEDEF = 128;           !  Old size name - synonym
! ++
literal EMB$S_EMBSE = 128;
macro EMB$L_SE_SID = 0,0,32,0 %;        ! SYSTEM ID 
macro EMB$W_SE_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_SE_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_SE_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_SE_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_SE_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$B_SE_SCS_NAME = 16,0,0,0 %;
literal EMB$S_SE_SCS_NAME = 16;         !  SCS node name in ASCIC
macro EMB$W_SE_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_SE_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_SE_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_SE_ENTRY = 36,0,16,0 %;     ! ENTRY TYPE 
macro EMB$Q_SE_TIME = 38,0,0,0 %;
literal EMB$S_SE_TIME = 8;              ! TIME IN 64 BITS 
macro EMB$W_SE_ERRSEQ = 46,0,16,0 %;    ! ERROR SEQUENCE NUMBER 
macro EMB$Q_SE_SWVERS = 48,0,0,0 %;
literal EMB$S_SE_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_SE_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_SE_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$B_SE_HW_NAME_LEN = 64,0,8,0 %; !  Length of marketing name of this system
macro EMB$T_SE_HW_NAME = 65,0,0,0 %;
literal EMB$S_SE_HW_NAME = 31;          !  marketing name of this system
! 
!  Start of CRD info
! 
macro EMB$W_SE_REVISION = 96,0,16,0 %;  !  ERL revision field
macro EMB$W_SE_CRD_FLAGS = 98,0,16,0 %; !  ERL flags
macro EMB$V_SE_CRD_FLG_DISABLED = 98,0,1,0 %; !  Indicates CRD init processing is not complete.
!   No scrubbing/replacement til flag is cleared
macro EMB$V_SE_CRD_FLG_LOST_INFO = 98,1,1,0 %; !  Lost information
! 
!  LOG_REASON corresponds to the field CRD_FOOT$W_LOG_REASON defined in
!  $CRD_FOOT.  If this field is ever changed, appropriate action must
!  be taken in CRD_FOOT as well.
!  
macro EMB$W_SE_LOG_REASON = 100,0,16,0 %; !  Reason for this ERL entry
macro EMB$V_SE_RSN_INIT_ERR = 100,0,1,0 %; !  Error occurred during CRDERR initialization
macro EMB$V_SE_RSN_FPRINTS_FULL = 100,1,1,0 %; !  Entries logged because all footprints in use
macro EMB$V_SE_RSN_SHUTDOWN = 100,2,1,0 %; !  Entries logged at shutdown
macro EMB$V_SE_RSN_DOMAIN_GREW = 100,3,1,0 %; !  Set when ADDR_CUM in a fprint goes non-zero
macro EMB$V_SE_RSN_BADPGS = 100,4,1,0 %; !  Indicates a non-zero RPB bad page count
macro EMB$W_SE_N_OF_M = 102,0,16,0 %;   !  "N of M" field.  Ie., packet "1" of "3"
macro EMB$L_SE_HWRPB_BADPGS = 104,0,32,0 %; !  RPB bad page count
macro EMB$L_SE_MEMDSC_SIZE = 108,0,32,0 %; !  variable SYSLOA memdsc size
macro EMB$L_SE_MEMDSC_OFFSET = 112,0,32,0 %; !  Offset from beg. of EMB to start of memdsc
macro EMB$L_SE_NUM_FPRINTS = 116,0,32,0 %; !  Number of footprints in this EMB
macro EMB$L_SE_FPRINT_SIZE = 120,0,32,0 %; !  Size, in bytes, of each fprint
macro EMB$L_SE_FPRINT_OFFSET = 124,0,32,0 %; !  Offset from beg. of EMB to start of fprints
!  End of *Fixed portion* of the SE$ header
! --
literal CRD_FOOT$K_MAX_FOOTPRINTS = 16; !  Max # of fprints
literal CRD_FOOT$M_SFLAGS_BUSY = %X'1';
literal CRD_FOOT$M_SFLAGS_SW_SCRUBBED = %X'2';
literal CRD_FOOT$M_CALLER_NOSCRUB = %X'1';
literal CRD_FOOT$M_CALLER_NOREPLACE = %X'2';
literal CRD_FOOT$M_CALLER_MULE = %X'4';
literal CRD_FOOT$M_SCRMSK_PFNTOOBIG = %X'1';
literal CRD_FOOT$M_SCRMSK_MCHK = %X'2';
literal CRD_FOOT$M_SCRMSK_MAPFAILED = %X'4';
literal CRD_FOOT$M_SCRMSK_UNMAPFAILED = %X'8';
literal CRD_FOOT$M_SCRMSK_TOOMANYRETRY = %X'10';
literal CRD_FOOT$K_LENGTH = 80;         !  Length of argument area
literal CRD_FOOT$C_LENGTH = 80;         !  Length of argument area
literal CRD_FOOT$S_CRD_FOOTDEF = 80;    !  Old size name - synonym
literal CRD_FOOT$S_CRD_FOOT = 80;
macro CRD_FOOT$Q_FOOTPRINT = 0,0,0,0 %;
literal CRD_FOOT$S_FOOTPRINT = 8;       !  64-bits of error syndrome
macro CRD_FOOT$Q_SYSTIME = 8,0,0,0 %;
literal CRD_FOOT$S_SYSTIME = 8;         !  System time of the CRD
macro CRD_FOOT$Q_ADDR_LOW = 16,0,0,0 %;
literal CRD_FOOT$S_ADDR_LOW = 8;        !  64-bit lowest address associated with this CRD
macro CRD_FOOT$Q_ADDR_HIGH = 24,0,0,0 %;
literal CRD_FOOT$S_ADDR_HIGH = 8;       !  64-bit highest address associated with this CRD
macro CRD_FOOT$Q_ADDR_CUM = 32,0,0,0 %;
literal CRD_FOOT$S_ADDR_CUM = 8;        !  64-bit bitmask of lowest address XORed, then ORed with all new addresses
macro CRD_FOOT$L_SCRUB_BLKSIZ = 40,0,32,0 %; !  Size, in bytes, of area to scrub
macro CRD_FOOT$W_STATIC_FLAGS = 44,0,16,0 %; !  Footprint flags
macro CRD_FOOT$V_SFLAGS_BUSY = 44,0,1,0 %; !  Indicates this CRD_FOOT in use
macro CRD_FOOT$V_SFLAGS_SW_SCRUBBED = 44,1,1,0 %; !  CRD scrubbed
!  The CRD_FOOT$W_LOG_REASON contains a bitmask of reasons for logging a
!  particular footprint.  These bit definitions must line up with those in
!  $CRD_EMBDEF.  In particular, the field CRD_EMB$W_LOG_REASON defines the
!  acceptable log reason bits.  [LIB]CRD_EMBDEF.SDL should be updated if new
!  reasons need to be defined.
! 
macro CRD_FOOT$W_LOG_REASON = 46,0,16,0 %; !  Reasons for logging this fprint
macro CRD_FOOT$L_CALLER_FLAGS = 48,0,32,0 %; !  Status bits for this CALLER
macro CRD_FOOT$V_CALLER_NOSCRUB = 48,0,1,0 %; !  Only update the footprint info - do not attempt scrub
macro CRD_FOOT$V_CALLER_NOREPLACE = 48,1,1,0 %; !  Only update the footprint info - do not attempt replace
macro CRD_FOOT$V_CALLER_MULE = 48,2,1,0 %; !  multiple error found
macro CRD_FOOT$L_SCRUB_FAILMSK = 52,0,32,0 %; !  Contains collective reasons why page couldn't be scrubbed
macro CRD_FOOT$V_SCRMSK_PFNTOOBIG = 52,0,1,0 %; !  Footprint PFN was greater than the system maximum.
macro CRD_FOOT$V_SCRMSK_MCHK = 52,1,1,0 %; !  Machine check occurred during scrub
macro CRD_FOOT$V_SCRMSK_MAPFAILED = 52,2,1,0 %; !  Mapping the physical addr failed
macro CRD_FOOT$V_SCRMSK_UNMAPFAILED = 52,3,1,0 %; !  Unmapping the physical addr failed
macro CRD_FOOT$V_SCRMSK_TOOMANYRETRY = 52,4,1,0 %; !  Too many retries
macro CRD_FOOT$L_MATCH_CNT = 56,0,32,0 %; !  Total CRDs which match this footprint
macro CRD_FOOT$L_SCRUB_CNT = 60,0,32,0 %; !  Number of times a page was scrubbed
macro CRD_FOOT$Q_FIRSTSCRUB_TIME = 64,0,0,0 %;
literal CRD_FOOT$S_FIRSTSCRUB_TIME = 8; !  Time at which first scrubbed CRD matched footprint
macro CRD_FOOT$Q_LASTSCRUB_TIME = 72,0,0,0 %;
literal CRD_FOOT$S_LASTSCRUB_TIME = 8;  !  Time at which last CRD matched footprint after scrubbing
literal CRD_ARG$K_LENGTH = 32;
literal CRD_ARG$C_LENGTH = 32;
literal CRD_ARG$S_CRD_ARGDEF = 32;      !  Old size name - synonym
literal CRD_ARG$S_CRD_ARG = 32;
macro CRD_ARG$Q_FOOTPRINT = 0,0,0,0 %;
literal CRD_ARG$S_FOOTPRINT = 8;        !  64-bits of error syndrome
macro CRD_ARG$Q_SYSTIME = 8,0,0,0 %;
literal CRD_ARG$S_SYSTIME = 8;          !  System time of the CRD
macro CRD_ARG$Q_ADDRESS = 16,0,0,0 %;
literal CRD_ARG$S_ADDRESS = 8;          !  64-bit address
macro CRD_ARG$L_FLAGS = 24,0,32,0 %;    !  flags
macro CRD_ARG$L_SCRUB_BLKSIZ = 28,0,32,0 %; !  Size, in bytes, of area to scrub
literal CRD$K_SCRUB_RETRY = 3;          !  Number of retries
 
!*** MODULE $EMBSBDEF ***
! 
!  SBI FAULT BUFFER FORMAT AND ASYNCHRONOUS WRITE ERROR FORMAT
! 
literal EMB$K_SB_LENGTH = 252;          ! LENGTH OF SBI ERROR BUFFER 
literal EMB$C_SB_LENGTH = 252;          ! LENGTH OF SBI ERROR BUFFER 
literal EMB$S_EMBSBDEF = 252;           !  Old size name - synonym
literal EMB$S_EMBSB = 252;
macro EMB$L_SB_SID = 0,0,32,0 %;        ! SYSTEM ID 
macro EMB$W_SB_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_SB_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_SB_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_SB_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_SB_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$B_SB_SCS_NAME = 16,0,0,0 %;
literal EMB$S_SB_SCS_NAME = 16;         !  SCS node name in ASCIC
macro EMB$W_SB_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_SB_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_SB_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_SB_ENTRY = 36,0,16,0 %;     ! ENTRY TYPE 
macro EMB$Q_SB_TIME = 38,0,0,0 %;
literal EMB$S_SB_TIME = 8;              ! TIME IN 64 BITS 
macro EMB$W_SB_ERRSEQ = 46,0,16,0 %;    ! ERROR SEQUENCE NUMBER 
macro EMB$Q_SB_SWVERS = 48,0,0,0 %;
literal EMB$S_SB_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_SB_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_SB_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$B_SB_HW_NAME_LEN = 64,0,8,0 %; !  Length of marketing name of this system
macro EMB$T_SB_HW_NAME = 65,0,0,0 %;
literal EMB$S_SB_HW_NAME = 31;          !  marketing name of this system
macro EMB$L_SB_FAULT = 96,0,32,0 %;     ! SBI FAULT/STATUS REGISTER 
macro EMB$L_SB_SILCMP = 100,0,32,0 %;   ! SBI SILO COMPARATOR 
macro EMB$L_SB_MAINT = 104,0,32,0 %;    ! SBI MAINTENANCE 
macro EMB$L_SB_ERROR = 108,0,32,0 %;    ! SBI ERROR REG 
macro EMB$L_SB_TIMOUT = 112,0,32,0 %;   ! SBI TIMEOUT REG 
macro EMB$L_SB_SILO = 116,0,0,0 %;
literal EMB$S_SB_SILO = 64;             ! SBI SILO REG 
macro EMB$L_SB_SBIRGS = 180,0,0,0 %;
literal EMB$S_SB_SBIRGS = 64;           ! REGISTER A'S ON BUS (OR 0) 
macro EMB$L_SB_PC = 244,0,32,1 %;       ! PC OF INSTRUCTION AT FAULT TIME 
macro EMB$L_SB_PSL = 248,0,32,0 %;      ! PSL OF MACHINE AT FAULT TIME 
 
!*** MODULE $EMBUIDEF ***
! 
!  UNDEFINED ADAPTER INTERRUPT BUFFER FORMAT
! 
literal EMB$K_UI_LENGTH = 104;          ! LENGTH OF MESSAGE 
literal EMB$C_UI_LENGTH = 104;          ! LENGTH OF MESSAGE 
literal EMB$S_EMBUIDEF = 104;           !  Old size name - synonym
literal EMB$S_EMBUI = 104;
macro EMB$L_UI_SID = 0,0,32,0 %;        ! SYSTEM ID 
macro EMB$W_UI_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_UI_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_UI_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_UI_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_UI_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$B_UI_SCS_NAME = 16,0,0,0 %;
literal EMB$S_UI_SCS_NAME = 16;         !  SCS node name in ASCIC
macro EMB$W_UI_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_UI_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_UI_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_UI_ENTRY = 36,0,16,0 %;     ! ENTRY TYPE 
macro EMB$Q_UI_TIME = 38,0,0,0 %;
literal EMB$S_UI_TIME = 8;              ! TIME IN 64 BITS 
macro EMB$W_UI_ERRSEQ = 46,0,16,0 %;    ! ERROR SEQUENCE NUMBER 
macro EMB$Q_UI_SWVERS = 48,0,0,0 %;
literal EMB$S_UI_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_UI_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_UI_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$B_UI_HW_NAME_LEN = 64,0,8,0 %; !  Length of marketing name of this system
macro EMB$T_UI_HW_NAME = 65,0,0,0 %;
literal EMB$S_UI_HW_NAME = 31;          !  marketing name of this system
macro EMB$L_UI_TR = 96,0,32,0 %;        ! ADAPTER TR NUMBER 
macro EMB$L_UI_CSR = 100,0,32,0 %;      ! ADAPTER CONGIGURATION STATUS REGISTER 
 
!*** MODULE $EMBUEDEF ***
! 
!  ERROR BUFFER FORMAT FOR UNIBUS ERROR SUMMARY REGISTER
!         ***** USED ONLY BY 11/730 ****
! 
literal EMB$K_UE_LENGTH = 100;          ! LENGTH OF MESSAGE 
literal EMB$C_UE_LENGTH = 100;          ! LENGTH OF MESSAGE 
literal EMB$S_EMBUEDEF = 100;           !  Old size name - synonym
literal EMB$S_EMBUE = 100;
macro EMB$L_UE_SID = 0,0,32,0 %;        ! SYSTEM ID 
macro EMB$W_UE_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_UE_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_UE_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_UE_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_UE_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$B_UE_SCS_NAME = 16,0,0,0 %;
literal EMB$S_UE_SCS_NAME = 16;         !  SCS node name in ASCIC
macro EMB$W_UE_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_UE_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_UE_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_UE_ENTRY = 36,0,16,0 %;     ! ENTRY TYPE 
macro EMB$Q_UE_TIME = 38,0,0,0 %;
literal EMB$S_UE_TIME = 8;              ! TIME IN 64 BITS 
macro EMB$W_UE_ERRSEQ = 46,0,16,0 %;    ! ERROR SEQUENCE NUMBER 
macro EMB$Q_UE_SWVERS = 48,0,0,0 %;
literal EMB$S_UE_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_UE_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_UE_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$B_UE_HW_NAME_LEN = 64,0,8,0 %; !  Length of marketing name of this system
macro EMB$T_UE_HW_NAME = 65,0,0,0 %;
literal EMB$S_UE_HW_NAME = 31;          !  marketing name of this system
macro EMB$L_UE_UBERR = 96,0,32,0 %;     ! UNIBUS ERROR REGISTER 
 
!*** MODULE $EMBSPDEF ***
! 
!  ERROR BUFFER FORMAT FOR SAVING SOFTWARE PARAMETERS FOR CLASS DRIVER THAT
!         CORRESPOND TO A LOGGED MESSAGE (SEE EMBLMDEF BELOW) ORIGINATING
!         IN AN INTELLIGENT MASS STORAGE CONTROLLER.
! 
literal EMB$K_SP_LENGTH = 184;
literal EMB$C_SP_LENGTH = 184;
literal EMB$S_EMBSPDEF = 184;           !  Old size name - synonym
literal EMB$S_EMBSP = 184;
macro EMB$L_SP_SID = 0,0,32,0 %;        !  System ID 
macro EMB$W_SP_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_SP_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_SP_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_SP_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_SP_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$B_SP_SCS_NAME = 16,0,0,0 %;
literal EMB$S_SP_SCS_NAME = 16;         !  SCS node name in ASCIC
macro EMB$W_SP_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_SP_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_SP_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_SP_ENTRY = 36,0,16,0 %;     !  Entry type (of this errorlog buffer) 
macro EMB$Q_SP_TIME = 38,0,0,0 %;
literal EMB$S_SP_TIME = 8;              !  Time this entry created 
macro EMB$W_SP_ERRSEQ = 46,0,16,0 %;    !  Error Sequence Number 
macro EMB$Q_SP_SWVERS = 48,0,0,0 %;
literal EMB$S_SP_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_SP_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_SP_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$B_SP_HW_NAME_LEN = 64,0,8,0 %; !  Length of marketing name of this system
macro EMB$T_SP_HW_NAME = 65,0,0,0 %;
literal EMB$S_SP_HW_NAME = 31;          !  marketing name of this system
macro EMB$B_SP_CLASS = 96,0,8,0 %;      !  Device Class 
macro EMB$B_SP_TYPE = 97,0,8,0 %;       !  Device Type 
macro EMB$L_SP_BOFF = 98,0,32,0 %;      !  Byte OFFset of data transfer 
macro EMB$L_SP_BCNT = 102,0,32,0 %;     !  Byte Count of data transfer 
macro EMB$L_SP_MEDIA = 106,0,32,0 %;    !  Media address (LBN) of data transfer 
macro EMB$L_SP_RQPID = 110,0,32,0 %;    !  Requesting PID 
macro EMB$Q_SP_IOSB = 114,0,0,0 %;
literal EMB$S_SP_IOSB = 8;              !  Final I/O status 
macro EMB$L_SP_FUNC = 122,0,32,0 %;     !  I/O function code 
macro EMB$W_SP_UNIT = 126,0,16,0 %;     !  Unit number of drive 
macro EMB$L_SP_OPCNT = 128,0,32,0 %;    !  Cummulative operation count this unit 
macro EMB$L_SP_ERRCNT = 132,0,32,0 %;   !  Cummulative error count for this unit 
macro EMB$L_SP_UCBSTS = 136,0,32,0 %;   !  Copy of UCB$W_STS field 
macro EMB$L_SP_OWNUIC = 140,0,32,0 %;   !  Unit's owner's UIC 
macro EMB$L_SP_CHAR = 144,0,32,0 %;     !  Device Characteristics 
macro EMB$L_SP_CMDREF = 148,0,32,0 %;   !  Command Reference number (RSPID) 
macro EMB$T_SP_DEVNAM = 152,0,0,0 %;
literal EMB$S_SP_DEVNAM = 32;           !  Device name 
 
!*** MODULE $EMBLMDEF ***
! 
!  LOGGED MESSAGE (DEVICE DEPENDENT CONTENTS).  DRIVER LOGS MESSAGE
!         WHICH MAY COME DIRECT FROM INTELLIGENT MASS STORAGE CONTROLLER.
! 
literal EMB$K_LM_LENGTH = 162;
literal EMB$C_LM_LENGTH = 162;
literal EMB$S_EMBLMDEF = 162;           !  Old size name - synonym
literal EMB$S_EMBLM = 162;
macro EMB$L_LM_SID = 0,0,32,0 %;        !  System ID 
macro EMB$W_LM_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_LM_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_LM_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_LM_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_LM_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$B_LM_SCS_NAME = 16,0,0,0 %;
literal EMB$S_LM_SCS_NAME = 16;         !  SCS node name in ASCIC
macro EMB$W_LM_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_LM_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_LM_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_LM_ENTRY = 36,0,16,0 %;     !  Entry type (i.e. Logged Message) 
macro EMB$Q_LM_TIME = 38,0,0,0 %;
literal EMB$S_LM_TIME = 8;              !  Time this entry created 
macro EMB$W_LM_ERRSEQ = 46,0,16,0 %;    !  Error sequence number 
macro EMB$Q_LM_SWVERS = 48,0,0,0 %;
literal EMB$S_LM_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_LM_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_LM_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$B_LM_HW_NAME_LEN = 64,0,8,0 %; !  Length of marketing name of this system
macro EMB$T_LM_HW_NAME = 65,0,0,0 %;
literal EMB$S_LM_HW_NAME = 31;          !  marketing name of this system
macro EMB$B_LM_CLASS = 96,0,8,0 %;      !  Device Class 
macro EMB$B_LM_TYPE = 97,0,8,0 %;       !  Device Type 
macro EMB$W_LM_UNIT = 98,0,16,0 %;      !  Device unit number 
macro EMB$T_LM_DEVNAM = 100,0,0,0 %;
literal EMB$S_LM_DEVNAM = 32;           !  Device name 
macro EMB$W_LM_MSGTYP = 132,0,16,0 %;   !  Type of logged message 
macro EMB$T_LM_DTNAME = 134,0,0,0 %;
literal EMB$S_LM_DTNAME = 28;           !  Device type name
!  counted string
 
!*** MODULE $EMBLTDEF ***
! 
!  LOGGED MESSAGE MESSAGE TYPES
! 
literal EMB$C_DM = 1;                   !  Disk MSCP message 
literal EMB$K_DM = 1;                   !  Disk MSCP message 
literal EMB$C_TM = 2;                   !  Tape MSCP message 
literal EMB$K_TM = 2;                   !  Tape MSCP message 
literal EMB$C_PM = 3;                   !  Port (CI) message 
literal EMB$K_PM = 3;                   !  Port (CI) message 
literal EMB$C_UM = 4;                   !  Port (UDA) message 
literal EMB$K_UM = 4;                   !  Port (UDA) message 
literal EMB$C_AVATN = 5;                !  Available Attention Message 
literal EMB$K_AVATN = 5;                !  Available Attention Message 
literal EMB$C_DUPUN = 6;                !  Duplicate Unit ! Attention Message 
literal EMB$K_DUPUN = 6;                !  Duplicate Unit ! Attention Message 
literal EMB$C_IVCMD = 7;                !  Invalid Command Log message. 
literal EMB$K_IVCMD = 7;                !  Invalid Command Log message. 
literal EMB$C_ACPTH = 8;                !  Access Path Attention Message 
literal EMB$K_ACPTH = 8;                !  Access Path Attention Message 
literal EMB$C_INVSTS = 9;               !  Invalid Status in End Message
literal EMB$K_INVSTS = 9;               !  Invalid Status in End Message
literal EMB$C_INVATT = 10;              !  Invalid Attention Message
literal EMB$K_INVATT = 10;              !  Invalid Attention Message
literal EMB$C_NOUNIT_DG = 11;           !  No unit in Datagram
literal EMB$K_NOUNIT_DG = 11;           !  No unit in Datagram
literal EMB$C_SSTFAIL = 12;             !  Self test failed.
literal EMB$K_SSTFAIL = 12;             !  Self test failed.
literal EMB$C_KDB50 = 13;               !  KDB50 error detected.
literal EMB$K_KDB50 = 13;               !  KDB50 error detected.
! 
!  The CTLRES_x fields below indicate that an MSCP controller was
!  told to reset itself by a class driver because the controller
!  is broken or confused.  (To an HSC, this will cause a reboot.)
!  The first three (INIT, INVMSG and IMTMO) do not have an MSCP end
!  message logged with them.
! 
literal EMB$C_CTLRES_INIT = 14;         !  An error occurred during or the connection vanished before completing
literal EMB$K_CTLRES_INIT = 14;         !    the initial handshake with the class driver.
literal EMB$C_CTLRES_INVMSG = 15;       !  An invalid message was received from the controller.  The offending
literal EMB$K_CTLRES_INVMSG = 15;       !    message has been previously logged as INVATT or INVSTS.
literal EMB$C_CTLRES_IMTMO = 16;        !  An immediate mode command has failed to complete within the timeout
literal EMB$K_CTLRES_IMTMO = 16;        !    period, indicating a broken or wedged controller.
literal EMB$C_CTLRES_TMO = 17;          !  No progress was made on a command during the timeout period.  The MSCP
literal EMB$K_CTLRES_TMO = 17;          !    GET COMMAND STATUS end message which determined this is included.
! 
literal EMB$C_BADRSPID = 18;            !  A message with an invalid RSPID was received by the class driver.
literal EMB$K_BADRSPID = 18;            !    The offending MSCP message is included.
! 
literal EMB$C_BVPSSP = 19;              !  Port message for BVP Storage Systems Port
literal EMB$K_BVPSSP = 19;              !  Port message for BVP Storage Systems Port
literal EMB$C_NIPM = 20;                !  Port (NI) message 
literal EMB$K_NIPM = 20;                !  Port (NI) message 
literal EMB$C_LDR_ERR = 21;             !  Media Loader error message
literal EMB$K_LDR_ERR = 21;             !  Media Loader error message
 
!*** MODULE $EMBETDEF ***
! 
!  ERROR MESSAGE ENTRY TYPE DEFINITIONS
! 
literal EMB$C_DE = 1;                   ! DEVICE ERROR 
literal EMB$K_DE = 1;                   ! DEVICE ERROR 
literal EMB$C_MC = 2;                   ! MACHINE CHECK 
literal EMB$K_MC = 2;                   ! MACHINE CHECK 
literal EMB$C_MCHECK_670 = 2;           ! Processor MACHINE CHECK 
literal EMB$K_MCHECK_670 = 2;           ! Processor MACHINE CHECK 
literal EMB$C_SYNERR = 3;               ! Syndrome Error
literal EMB$K_SYNERR = 3;               ! Syndrome Error
literal EMB$C_BE = 4;                   ! BUS ERROR 
literal EMB$K_BE = 4;                   ! BUS ERROR 
literal EMB$C_SA = 5;                   ! SBI ALERT 
literal EMB$K_SA = 5;                   ! SBI ALERT 
literal EMB$C_SE = 6;                   ! SOFT ECC ERROR 
literal EMB$K_SE = 6;                   ! SOFT ECC ERROR 
literal EMB$C_MCHECK_620 = 6;           ! System correctable
literal EMB$K_MCHECK_620 = 6;           ! System correctable
literal EMB$C_AW = 7;                   ! ASYNCHRONOUS WRITE ERROR 
literal EMB$K_AW = 7;                   ! ASYNCHRONOUS WRITE ERROR 
literal EMB$C_HE = 8;                   ! HARD ECC ERROR 
literal EMB$K_HE = 8;                   ! HARD ECC ERROR 
literal EMB$C_UBA = 9;                  !  11/780 Unibus Adapter error 
literal EMB$K_UBA = 9;                  !  11/780 Unibus Adapter error 
literal EMB$C_SI = 10;                  !  11/750 Fault through SBI vector 
literal EMB$K_SI = 10;                  !  11/750 Fault through SBI vector 
literal EMB$C_UE = 11;                  !  11/730 Unibus Error 
literal EMB$K_UE = 11;                  !  11/730 Unibus Error 
literal EMB$C_MBA = 12;                 !  11/780 Massbus Adapter Error 
literal EMB$K_MBA = 12;                 !  11/780 Massbus Adapter Error 
literal EMB$C_SBIA = 13;                !  11/790 SBIA error
literal EMB$K_SBIA = 13;                !  11/790 SBIA error
literal EMB$C_CRD = 14;                 !  11/790 CRD log
literal EMB$K_CRD = 14;                 !  11/790 CRD log
literal EMB$C_EMM = 15;                 !  11/790 Environmental MOnitor
literal EMB$K_EMM = 15;                 !  11/790 Environmental MOnitor
literal EMB$C_HLT = 16;                 !  11/790 Processor Error Halt
literal EMB$K_HLT = 16;                 !  11/790 Processor Error Halt
literal EMB$C_CRBT = 17;                !  11/790 Console Reboot
literal EMB$K_CRBT = 17;                !  11/790 Console Reboot
literal EMB$C_BIADPERR = 18;            !  BI ADAPTER ERROR
literal EMB$K_BIADPERR = 18;            !  BI ADAPTER ERROR
literal EMB$C_BIBUSERR = 19;            !  BI BUS ERROR
literal EMB$K_BIBUSERR = 19;            !  BI BUS ERROR
literal EMB$C_NMIFLT = 20;              !  NMI FAULT 
literal EMB$K_NMIFLT = 20;              !  NMI FAULT 
literal EMB$C_CTO = 21;                 !  Console Timeout
literal EMB$K_CTO = 21;                 !  Console Timeout
literal EMB$C_NBW = 22;                 !  NBW
literal EMB$K_NBW = 22;                 !  NBW
literal EMB$C_CACHERR = 23;             !  CACHE ERROR
literal EMB$K_CACHERR = 23;             !  CACHE ERROR
literal EMB$C_CVAX_CB = 24;             !  CVAX CACHE/BUS ERROR
literal EMB$K_CVAX_CB = 24;             !  CVAX CACHE/BUS ERROR
literal EMB$C_MEMSCAN = 25;             !  Calypso memory error found by scanning
literal EMB$K_MEMSCAN = 25;             !  Calypso memory error found by scanning
literal EMB$C_INT54 = 26;               !  Calypso SCB 54 error
literal EMB$K_INT54 = 26;               !  Calypso SCB 54 error
literal EMB$C_MCHECK_630 = 26;          !  Calypso SCB 54 error
literal EMB$K_MCHECK_630 = 26;          !  Calypso SCB 54 error
literal EMB$C_INT60 = 27;               !  Calypso SCB 60 error
literal EMB$K_INT60 = 27;               !  Calypso SCB 60 error
literal EMB$C_MCHECK_660 = 27;          !  System machine check
literal EMB$K_MCHECK_660 = 27;          !  system machine check
literal EMB$C_ADPERR = 28;              !  adapter error
literal EMB$K_ADPERR = 28;              !  adapter error
literal EMB$C_LASTFAIL = 29;            !  Calypso lastfail
literal EMB$K_LASTFAIL = 29;            !  Calypso lastfail
literal EMB$C_CONSOLE = 30;             !  Console entry
literal EMB$K_CONSOLE = 30;             !  Console entry
literal EMB$C_INFO = 31;                !  Informational entry
literal EMB$K_INFO = 31;                !  Informational entry
literal EMB$C_CS = 32;                  ! COLD START (IE: SYSTEM BOOT) 
literal EMB$K_CS = 32;                  ! COLD START (IE: SYSTEM BOOT) 
literal EMB$C_CLKERR = 33;              !  Clock module error
literal EMB$K_CLKERR = 33;              !  Clock module error
literal EMB$C_SCAN = 34;                !  SCAN error (eg. Aquarius)
literal EMB$K_SCAN = 34;                !  SCAN error (eg. Aquarius)
literal EMB$K_NF = 35;                  ! NEW FILE CREATED 
literal EMB$C_NF = 35;                  ! NEW FILE CREATED 
literal EMB$C_WS = 36;                  ! WARM START (IE: SYSTEM POWER RECOVERY) 
literal EMB$K_WS = 36;                  ! WARM START (IE: SYSTEM POWER RECOVERY) 
literal EMB$C_CR = 37;                  ! CRASH RE-START 
literal EMB$K_CR = 37;                  ! CRASH RE-START 
literal EMB$C_TS = 38;                  ! TIME STAMP ENTRY 
literal EMB$K_TS = 38;                  ! TIME STAMP ENTRY 
literal EMB$C_SS = 39;                  ! SYSTEM SERVICE MESSAGE 
literal EMB$K_SS = 39;                  ! SYSTEM SERVICE MESSAGE 
literal EMB$C_SBC = 40;                 ! SYSTEM BUGCHECK 
literal EMB$K_SBC = 40;                 ! SYSTEM BUGCHECK 
literal EMB$C_OM = 41;                  ! OPERATOR MESSAGE 
literal EMB$K_OM = 41;                  ! OPERATOR MESSAGE 
literal EMB$C_NM = 42;                  ! NETWORK MESSAGE 
literal EMB$K_NM = 42;                  ! NETWORK MESSAGE 
literal EMB$C_CONFIG = 43;              ! CONFIGURATION entry
literal EMB$K_CONFIG = 43;              ! CONFIGURATION entry
literal EMB$C_POLL_ERR = 44;            ! Polled error entry
literal EMB$K_POLL_ERR = 44;            ! Polled error entry
literal EMB$C_VM = 64;                  ! VOLUME MOUNT 
literal EMB$K_VM = 64;                  ! VOLUME MOUNT 
literal EMB$C_VD = 65;                  ! VOLUME DISMOUNT 
literal EMB$K_VD = 65;                  ! VOLUME DISMOUNT 
literal EMB$C_DT = 96;                  ! DEVICE TIMEOUT 
literal EMB$K_DT = 96;                  ! DEVICE TIMEOUT 
literal EMB$C_UI = 97;                  ! UNDEFINED INTERRUPT 
literal EMB$K_UI = 97;                  ! UNDEFINED INTERRUPT 
literal EMB$C_DA = 98;                  !  Asynchronous Device Attention 
literal EMB$K_DA = 98;                  !  Asynchronous Device Attention 
literal EMB$C_SP = 99;                  !  Software Parameters 
literal EMB$K_SP = 99;                  !  Software Parameters 
literal EMB$C_LM = 100;                 !  Logged Message 
literal EMB$K_LM = 100;                 !  Logged Message 
literal EMB$C_LOGMSCP = 101;            !  Logged MSCP Message
literal EMB$K_LOGMSCP = 101;            !  Logged MSCP Message 
literal EMB$C_PWR = 102;                !  Laser power event
literal EMB$K_PWR = 102;                !  Laser power event
literal EMB$C_UBC = 112;                ! USER BUGCHECK 
literal EMB$K_UBC = 112;                ! USER BUGCHECK 
 
!*** MODULE $EO1DEF ***
! +
!  EOF1 ANSI MAGNETIC TAPE LABEL
!  THIS IS THE FIRST LABEL IN FILE TRAILER LABEL SET.  IT IS EQUIVALENT TO
!  HDR1 EXCEPT FOR THE FOLLOWING FIELDS.
! -
literal EO1$S_EO1DEF = 60;
literal EO1$S_EO1 = 60;
macro EO1$L_EO1LID = 0,0,32,0 %;        ! LABEL IDENTIFIER AND NUMBER 'EOF1' 
macro EO1$T_BLOCKCNT = 54,0,0,0 %;
literal EO1$S_BLOCKCNT = 6;             ! BLOCK COUNT 
 
!*** MODULE $EO2DEF ***
! +
!  EOF2 ANSI MAGNETIC TAPE LABEL
!  THIS IS THE SECOND LABEL IN THE FILE TRAILER LABEL SET.  IT IS EQUIVALENT
!  TO HDR2 EXCEPT FOR THE FOLLOWING FIELDS.
! -
literal EO2$S_EO2DEF = 4;
literal EO2$S_EO2 = 4;
macro EO2$L_EO2LID = 0,0,32,0 %;        ! LABEL IDENTIFIER AND NUMBER 'EOF2' 
 
!*** MODULE $EO3DEF ***
! +
!  EOF3 ANSI MAGNETIC TAPE LABEL
!  THIS IS THE THIRD LABEL IN THE FILE TRAILER LABEL SET.  IT IS EQUIVALENT
!  TO HDR3 EXCEPT FOR THE FOLLOWING FIELDS.
! -
literal EO3$S_EO3DEF = 4;
literal EO3$S_EO3 = 4;
macro EO3$L_EO3LID = 0,0,32,0 %;        ! LABEL IDENTIFIER AND NUMBER 'EOF3' 
 
!*** MODULE $EO4DEF ***
! +
!  EOF4 ANSI MAGNETIC TAPE LABEL
!  THIS IS THE FOURTH LABEL IN THE FILE TRAILER LABEL SET.  IT IS EQUIVALENT
!  TO HDR4 EXCEPT FOR THE FOLLOWING FIELDS.
! -
literal EO4$S_EO4DEF = 4;
literal EO4$S_EO4 = 4;
macro EO4$L_EO4LID = 0,0,32,0 %;        ! LABEL IDENTIFIER AND NUMBER 'EOF4' 
 
!*** MODULE $ERBDEF ***
! 
!  ERROR LOGGING MESSAGE RECOVERY BLOCK
! 
literal ERB$C_HDR_LENGTH = 24;          !  0th BUFF. STARTS HERE
literal ERB$K_HDR_LENGTH = 24;          !  0th BUFF. STARTS HERE
literal ERB$S_ERBDEF = 24;
literal ERB$S_ERB = 24;
macro ERB$L_FILLER0 = 0,0,32,1 %;       !  POSSIBLE FLNK
macro ERB$L_FILLER4 = 4,0,32,1 %;       !  POSSIBLE BLNK
macro ERB$W_BLOCK_SIZE = 8,0,16,0 %;    !  RETURNED BY ALLOCATION
macro ERB$B_BUFPAGES = 10,0,8,0 %;      !  V5.1 and + : PAGES / BUFFER
macro ERB$B_FILLERB = 11,0,8,0 %;       !  UNUSED
macro ERB$L_ALLOCATED = 12,0,32,0 %;    !  BYTES ALLOC'D FOR THIS BLOCK
macro ERB$L_BUFCNT = 16,0,32,0 %;       !  # BUFFERS, NOT INCL CRASH BUF
macro ERB$W_HEAD = 20,0,16,0 %;         !  RING HEAD INDEX AT CRASH
macro ERB$W_TAIL = 22,0,16,0 %;         !  RING TAIL AT CRASH
 
!*** MODULE $ERLDEF ***
! 
!  ERROR LOG ALLOCATION BUFFER HEADER
! 
literal ERL$K_LENGTH = 12;              ! LENGTH OF ALLOCATION BUFFER HEADER 
literal ERL$C_LENGTH = 12;              ! LENGTH OF ALLOCATION BUFFER HEADER 
literal ERL$M_LOCK = %X'1';
literal ERL$M_TIMER = %X'2';
literal ERL$S_ERLDEF = 12;
literal ERL$S_ERL = 12;
macro ERL$B_BUSY = 0,0,8,0 %;           ! NUMBER OF BUSY MESSAGES IN BUFFER 
macro ERL$B_MSGCNT = 1,0,8,0 %;         ! NUMBER OF COMPLETED MESSAGES IN BUFFER 
macro ERL$B_BUFIND = 2,0,8,0 %;         ! BUFFER INDICATOR OF RESPECTIVE BUFFER 
macro ERL$B_FLAGS = 3,0,8,0 %;          ! BUFFER CONTROL FLAGS 
macro ERL$L_NEXT = 4,0,32,1 %;          ! ADDRESS OF NEXT AVAILABLE SPACE IN BUFFER 
macro ERL$L_END = 8,0,32,1 %;           ! ADDRESS OF END OF BUFFER + 1 
macro ERL$V_LOCK = 8,0,1,0 %;           ! BUFFER ALLOCATION INTERLOCK 
macro ERL$V_TIMER = 8,1,1,0 %;          ! TIMER ACTIVE 
 
!*** MODULE $ERLMBXDEF ***
! 
!  ERROR LOG MAILBOX SYSTEM DATA CELL STRUCTURE AND MAILBOX COUNT
! 
literal ERL$K_MAILBOX_COUNT = 5;        !  NUMBER OF MAILBOXES
literal ERL$C_MAILBOX_COUNT = 5;        !  NUMBER OF MAILBOXES
literal ERL$K_MBX_LENGTH = 8;           !  LENGTH OF STRUCTURE
literal ERL$C_MBX_LENGTH = 8;           !  LENGTH OF STRUCTURE
literal ERL$S_ERLMBX = 8;
macro ERL$W_MBX_UNIT = 0,0,16,0 %;      !  MAILBOX UNIT NUMBER
macro ERL$W_MBX_FILLER_0 = 2,0,16,0 %;
macro ERL$L_MBX_PID = 4,0,32,0 %;       !  MBX OWNER PID
 
!*** MODULE $ERFMBXDEF ***
! 
!  COMPLEMENTARY STRUCTURES FOR ERRFMT DIAGNOSTIC MAILBOX CONTROL
! 
literal ERF$K_MBX_LENGTH = 6;           !  LENGTH OF STRUCTURE
literal ERF$C_MBX_LENGTH = 6;           !  LENGTH OF STRUCTURE
literal ERF$S_ERFMBX = 6;
macro ERF$W_MBX_CHANNEL = 0,0,16,0 %;   !  MBX CHANNEL NUMBER
macro ERF$W_MBX_SIZE = 2,0,16,0 %;      !  MBX SIZE
macro ERF$W_MBX_UNIT = 4,0,16,0 %;      !  MBX UNIT NUMBER
 
!*** MODULE $EV4DEF ***
literal EV4$M_SWC = %X'4';
literal EV4$M_INV = %X'8';
literal EV4$M_DZE = %X'10';
literal EV4$M_FOV = %X'20';
literal EV4$M_UNF = %X'40';
literal EV4$M_INE = %X'80';
literal EV4$M_IOV = %X'100';
literal EV4$M_MSK = %X'200000000';
literal EV4$M_WR = %X'1';
literal EV4$M_ACV = %X'2';
literal EV4$M_FOR = %X'4';
literal EV4$M_FOW = %X'8';
literal EV4$M_RA_OPERAND = %X'1F0';
literal EV4$M_OPCODE = %X'7E00';
literal EV4$M_BIU_HERR = %X'1';
literal EV4$M_BIU_SERR = %X'2';
literal EV4$M_BC_TPERR = %X'4';
literal EV4$M_BC_TCPERR = %X'8';
literal EV4$M_BIU_CMD = %X'70';
literal EV4$M_BIU_SEO = %X'80';
literal EV4$M_FILL_ECC = %X'100';
literal EV4$M_BIU_DPERR = %X'400';
literal EV4$M_FILL_IRD = %X'800';
literal EV4$M_FILL_QW = %X'3000';
literal EV4$M_FILL_SEO = %X'4000';
literal EV4$M_DC_HIT = %X'8';
literal EV4$M_DC_ERR = %X'10';
literal EV4$M_IC_ERR = %X'20';
literal EV4$S_EV4DEF = 8;               !  Old size name - synonym
literal EV4$S_EV4 = 8;
macro EV4$Q_EXC_SUM = 0,0,0,0 %;
literal EV4$S_EXC_SUM = 8;
macro EV4$v_fill_1 = 0,0,2,0 %;
literal EV4$s_fill_1 = 2;
macro EV4$V_SWC = 0,2,1,0 %;
macro EV4$V_INV = 0,3,1,0 %;
macro EV4$V_DZE = 0,4,1,0 %;
macro EV4$V_FOV = 0,5,1,0 %;
macro EV4$V_UNF = 0,6,1,0 %;
macro EV4$V_INE = 0,7,1,0 %;
macro EV4$V_IOV = 0,8,1,0 %;
macro EV4$v_fill_2 = 0,9,24,0 %;
literal EV4$s_fill_2 = 24;
macro EV4$V_MSK = 4,1,1,0 %;
macro EV4$v_fill_3 = 4,2,30,0 %;
literal EV4$s_fill_3 = 30;
macro EV4$Q_MM_CSR = 0,0,0,0 %;
literal EV4$S_MM_CSR = 8;
macro EV4$V_WR = 0,0,1,0 %;
macro EV4$V_ACV = 0,1,1,0 %;
macro EV4$V_FOR = 0,2,1,0 %;
macro EV4$V_FOW = 0,3,1,0 %;
macro EV4$V_RA_OPERAND = 0,4,5,0 %;
literal EV4$S_RA_OPERAND = 5;
macro EV4$V_OPCODE = 0,9,6,0 %;
literal EV4$S_OPCODE = 6;
macro EV4$Q_BIU_STAT = 0,0,0,0 %;
literal EV4$S_BIU_STAT = 8;
macro EV4$V_BIU_HERR = 0,0,1,0 %;
macro EV4$V_BIU_SERR = 0,1,1,0 %;
macro EV4$V_BC_TPERR = 0,2,1,0 %;
macro EV4$V_BC_TCPERR = 0,3,1,0 %;
macro EV4$V_BIU_CMD = 0,4,3,0 %;
literal EV4$S_BIU_CMD = 3;
macro EV4$V_BIU_SEO = 0,7,1,0 %;
macro EV4$V_FILL_ECC = 0,8,1,0 %;
macro EV4$v_fill_5 = 0,9,1,0 %;
macro EV4$V_BIU_DPERR = 0,10,1,0 %;
macro EV4$V_FILL_IRD = 0,11,1,0 %;
macro EV4$V_FILL_QW = 0,12,2,0 %;
literal EV4$S_FILL_QW = 2;
macro EV4$V_FILL_SEO = 0,14,1,0 %;
macro EV4$Q_DC_STAT = 0,0,0,0 %;
literal EV4$S_DC_STAT = 8;
macro EV4$V_CHIP_ID = 0,0,3,0 %;
literal EV4$S_CHIP_ID = 3;
macro EV4$V_DC_HIT = 0,3,1,0 %;
macro EV4$V_DC_ERR = 0,4,1,0 %;
macro EV4$V_IC_ERR = 0,5,1,0 %;
 
!*** MODULE $EV5DEF ***
literal ev5$M_SWC = %X'400';
literal ev5$M_INV = %X'800';
literal ev5$M_DZE = %X'1000';
literal ev5$M_FOV = %X'2000';
literal ev5$M_UNF = %X'4000';
literal ev5$M_INE = %X'8000';
literal ev5$M_IOV = %X'10000';
literal ev5$M_WR = %X'1';
literal ev5$M_ACV = %X'2';
literal ev5$M_FOR = %X'4';
literal ev5$M_FOW = %X'8';
literal ev5$M_DTB_MISS = %X'10';
literal ev5$M_BAD_VA = %X'20';
literal ev5$M_RA_OPERAND = %X'7C0';
literal ev5$M_OPCODE = %X'1F800';
literal ev5$M_CHIP_ID = %X'F000000';
literal ev5$M_BC_TPERR = %X'10000000';
literal ev5$M_BC_TC_PERR = %X'20000000';
literal ev5$M_EI_ES = %X'40000000';
literal ev5$M_COR_ECC_ERR = %X'80000000';
literal ev5$M_UNC_ECC_ERR = %X'1';
literal ev5$M_EI_PAR_ERR = %X'2';
literal ev5$M_FIL_IRD = %X'4';
literal ev5$M_SEO_HRD_ERR = %X'8';
literal ev5$M_DPE = %X'800';
literal ev5$M_TPE = %X'1000';
literal ev5$M_TMR = %X'2000';
literal ev5$M_SEO = %X'1';
literal ev5$M_LOCK = %X'2';
literal ev5$M_DP0 = %X'4';
literal ev5$M_DP1 = %X'8';
literal ev5$M_TP0 = %X'10';
literal ev5$M_TP1 = %X'20';
literal ev5$S_ev5DEF = 8;               !  Old size name - synonym
literal ev5$S_ev5 = 8;
macro ev5$Q_EXC_SUM = 0,0,0,0 %;
literal ev5$S_EXC_SUM = 8;
macro ev5$V_SWC = 0,10,1,0 %;
macro ev5$V_INV = 0,11,1,0 %;
macro ev5$V_DZE = 0,12,1,0 %;
macro ev5$V_FOV = 0,13,1,0 %;
macro ev5$V_UNF = 0,14,1,0 %;
macro ev5$V_INE = 0,15,1,0 %;
macro ev5$V_IOV = 0,16,1,0 %;
macro ev5$Q_MM_STAT = 0,0,0,0 %;
literal ev5$S_MM_STAT = 8;
macro ev5$V_WR = 0,0,1,0 %;
macro ev5$V_ACV = 0,1,1,0 %;
macro ev5$V_FOR = 0,2,1,0 %;
macro ev5$V_FOW = 0,3,1,0 %;
macro ev5$V_DTB_MISS = 0,4,1,0 %;
macro ev5$V_BAD_VA = 0,5,1,0 %;
macro ev5$V_RA_OPERAND = 0,6,5,0 %;
literal ev5$S_RA_OPERAND = 5;
macro ev5$V_OPCODE = 0,11,6,0 %;
literal ev5$S_OPCODE = 6;
macro ev5$Q_EI_STAT = 0,0,0,0 %;
literal ev5$S_EI_STAT = 8;
macro ev5$L_L = 0,0,32,1 %;
macro ev5$V_CHIP_ID = 0,24,4,0 %;
literal ev5$S_CHIP_ID = 4;
macro ev5$V_BC_TPERR = 0,28,1,0 %;
macro ev5$V_BC_TC_PERR = 0,29,1,0 %;
macro ev5$V_EI_ES = 0,30,1,0 %;
macro ev5$V_COR_ECC_ERR = 0,31,1,0 %;
macro ev5$L_H = 4,0,32,1 %;
macro ev5$V_UNC_ECC_ERR = 4,0,1,0 %;
macro ev5$V_EI_PAR_ERR = 4,1,1,0 %;
macro ev5$V_FIL_IRD = 4,2,1,0 %;
macro ev5$V_SEO_HRD_ERR = 4,3,1,0 %;
macro ev5$Q_ICPERR_STAT = 0,0,0,1 %;
literal ev5$S_ICPERR_STAT = 8;
macro ev5$V_DPE = 0,11,1,0 %;
macro ev5$V_TPE = 0,12,1,0 %;
macro ev5$V_TMR = 0,13,1,0 %;
macro ev5$Q_DCPERR_STAT = 0,0,0,1 %;
literal ev5$S_DCPERR_STAT = 8;
macro ev5$V_SEO = 0,0,1,0 %;
macro ev5$V_LOCK = 0,1,1,0 %;
macro ev5$V_DP0 = 0,2,1,0 %;
macro ev5$V_DP1 = 0,3,1,0 %;
macro ev5$V_TP0 = 0,4,1,0 %;
macro ev5$V_TP1 = 0,5,1,0 %;
 
!*** MODULE $EVTDEF ***
! 
!  EVENT CODE DEFINITIONS
! 
literal EVT$_AST = 0;
literal EVT$_EVENT = 1;
literal EVT$_CEF = 2;
literal EVT$_LEFO = 3;
literal EVT$_FPGA = 4;
literal EVT$_WAKE = 5;
literal EVT$_RESUME = 6;
literal EVT$_PFCOM = 7;
literal EVT$_SETPRI = 8;
literal EVT$_SWPOUT = 9;
literal EVT$_SWPOUTE = 10;
literal EVT$_MAXEVT = 11;
literal EVT$_COLPGA = 0;
 
!*** MODULE $EWDATADEF ***
! +
!  $EWDATADEF - Symbolic offsets within the exec-writable page
! 
!  An exec-writable page is allocated when the system is bootstrapped.
!  The fields within this page are being defined below. These data cells
!  were originally defined in the system (i.e. in SYS.EXE) with the form:
! 
! 	PMS$xL_cellname. 
! 
!  Now that this cell resides in a seperate exec-writable page that is 
!  pointed by a cell in the system's base image, the symbolic offset from 
!  the base of the exec-writable page to this cell has the form:
! 
! 	EW_PMS$xL_cellname.
! 
! 
!  NOTE: The PMS Arrays (COUNT, MCNT, WRITE, CACHE, CPU, PFA) must immediately
!  follow FCP and FCP2 fields.
! 
! -
literal EW$K_LENGTH = 378;
literal EW$C_LENGTH = 378;
literal EW$S_EWDATADEF = 378;           !  Old size name - synonym
literal EW$S_EWDATA = 378;
macro EW$R_PMSEWDATA = 0,0,0,0 %;
literal EW_PMS$S_PMSEWDATA = 376;
macro EW_PMS$GL_FCP = 0,0,0,0 %;        !  start of the FCP counters
macro EW_PMS$GL_FCP2 = 0,0,0,0 %;       !  start of the FCP2 counters
macro EW_PMS$AL_COUNT = 0,0,0,0 %;
literal EW_PMS$S_COUNT = 40;            !  number of operations
macro EW_PMS$AL_MCNT = 40,0,0,0 %;
literal EW_PMS$S_MCNT = 40;             !  number of modifiers
macro EW_PMS$AL_READ = 80,0,0,0 %;
literal EW_PMS$S_READ = 40;             !  number of disk reads
macro EW_PMS$AL_WRITE = 120,0,0,0 %;
literal EW_PMS$S_WRITE = 40;            !  number of disk writes
macro EW_PMS$AL_CACHE = 160,0,0,0 %;
literal EW_PMS$S_CACHE = 40;            !  number of cache hits
macro EW_PMS$AL_CPU = 200,0,0,0 %;
literal EW_PMS$S_CPU = 40;              !  accumulated cpu times
macro EW_PMS$AL_PFA = 240,0,0,0 %;
literal EW_PMS$S_PFA = 40;              !  accumulated page faults
macro EW_PMS$GL_TURN = 280,0,32,0 %;    !  number of window turns
macro EW_PMS$GL_DIRHIT = 284,0,32,0 %;  !  count of directory LRU hits
macro EW_PMS$GL_DIRMISS = 288,0,32,0 %; !  count of directory LRU misses
macro EW_PMS$GL_QUOHIT = 292,0,32,0 %;  !  count of quota cache hits
macro EW_PMS$GL_QUOMISS = 296,0,32,0 %; !  count of quota cache misses
macro EW_PMS$GL_FIDHIT = 300,0,32,0 %;  !  count of file ID cache hits
macro EW_PMS$GL_FIDMISS = 304,0,32,0 %; !  count of file ID cache misses
macro EW_PMS$GL_EXTHIT = 308,0,32,0 %;  !  count of extent cache hits
macro EW_PMS$GL_EXTMISS = 312,0,32,0 %; !  count of extent cache misses
macro EW_PMS$GL_FILHDR_HIT = 316,0,32,0 %; !  count of file header cache hits
macro EW_PMS$GL_FILHDR_MISS = 320,0,32,0 %; !  count of file header cache misses
macro EW_PMS$GL_DIRDATA_HIT = 324,0,32,0 %; !  count of directory data block hits
macro EW_PMS$GL_DIRDATA_MISS = 328,0,32,0 %; !  count of directory data block misses
macro EW_PMS$GL_STORAGMAP_HIT = 332,0,32,0 %; !  count of storage bit map cache hits
macro EW_PMS$GL_STORAGMAP_MISS = 336,0,32,0 %; !  count of storage bit map cache misses
macro EW_PMS$GL_OPEN = 340,0,32,0 %;    !  number of currently open files
macro EW_PMS$GL_OPENS = 344,0,32,0 %;   !  total count of opens
macro EW_PMS$GL_ERASEIO = 348,0,32,0 %; !  total count of erase QIO's issued
macro EW_PMS$GL_VOLLCK = 352,0,32,0 %;  !  count of XQP volume synch locks
macro EW_PMS$GL_VOLWAIT = 356,0,32,0 %; !  # of times XQP had to wait for a 
!  volume synch lock
macro EW_PMS$GL_SYNCHLCK = 360,0,32,0 %; !  count of XQP directory and 
!  file synch locks
macro EW_PMS$GL_SYNCHWAIT = 364,0,32,0 %; !  # of times XQP had to wait for a 
!  directory or file synch lock
macro EW_PMS$GL_ACCLCK = 368,0,32,0 %;  !  count of XQP access locks
macro EW_PMS$GL_XQPCACHEWAIT = 372,0,32,0 %; !  # of times XQP had to wait for free
!  space in a cache
macro EW$R_RMSEWDATA = 376,0,16,0 %;
literal EW_RMS$S_RMSEWDATA = 2;
macro EW_RMS$GW_GBLBUFQUO = 376,0,16,0 %; !  current global buffer quota remaining
 
!*** MODULE $EXEDEF ***
literal EXE$C_SYSEFN = 31;              !  Common system event flag
literal EXE$C_CMSTKSZ = 20;             !  Number of longwords in dispatch call frame
literal EXE$M_NPAGGRNMSK = 63;          !  Allocation granularity mask for nonpaged pool
literal EXE$M_PAGGRNMSK = 15;           !  Allocation granularity mask for paged pool
literal EXE$M_P1GRNMSK = 15;            !  Allocation granularity mask for P1 region
literal EXE$M_DEFGRNMSK = 15;           !  Allocation granularity mask default
 
!*** MODULE $F11BCDEF ***
! +
!  F11BC - Files 11 Block Cache
! 
!  Header area which describes block cache used by F11BXQP.
! 
! -
!  
!  The next four constants are to do with minimum cache allowances for XQP activity
!  per process.  These minima control not ionly minimum cache size but also
!  stalling for XQP activity.
! 
literal F11BC$K_MAPCACHE_MIN = 1;       !  Bitmap.sys buffers per process
literal F11BC$K_HDRCACHE_MIN = 4;       !  Indexf.sys buffers per process
literal F11BC$K_DIRCACHE_MIN = 2;       !  Dir/quota buffers per process
literal F11BC$K_DINDXCACHE_MIN = 1;     !  Directory index `buffers' per process
!  The next four constants are to control the minimum number of fluid buffers a
!  process can hold in the XQP cache. (Fluid buffers == buffers that are not pinned in cache)
! 
literal F11BC$K_MAPCACHE_FLUIDMIN = 1;  !  Bitmap.sys buffers per process
literal F11BC$K_HDRCACHE_FLUIDMIN = 3;  !  Indexf.sys buffers per process
literal F11BC$K_DIRCACHE_FLUIDMIN = 2;  !  Dir/quota buffers per process
literal F11BC$K_DINDXCACHE_FLUIDMIN = 1; !  Directory index `buffers' per process
literal F11BC$K_NUM_POOLS = 4;          !  Number of buffer pools.
literal F11BC$S_F11BCDEF = 232;         !  Old size name - synonym
literal F11BC$S_F11BC = 232;
macro F11BC$L_BUFBASE = 0,0,32,1 %;     !  Base address of buffer area.
macro F11BC$L_BUFSIZE = 4,0,32,0 %;     !  Size of buffer area in bytes.
macro F11BC$W_SIZE = 8,0,16,0 %;        !  Standard size field.
macro F11BC$B_TYPE = 10,0,8,0 %;        !  Standard type field.
macro F11BC$B_SUBTYPE = 11,0,8,0 %;     !  Standard subtype field.
macro F11BC$L_REALSIZE = 12,0,32,0 %;   !  Structure size as a longword.
macro F11BC$L_LBNHSHBAS = 16,0,32,1 %;  !  Base of LBN hash table.
macro F11BC$L_LBNHSHCNT = 20,0,32,0 %;  !  Count of entries in LBN hash tbl.
macro F11BC$L_BFRCNT = 24,0,32,0 %;     !  Total buffer count.
macro F11BC$L_BFRDBAS = 28,0,32,1 %;    !  Buffer descriptor base address.
macro F11BC$L_BFRLDBAS = 32,0,32,1 %;   !  Buffer lock descriptor base addr.
macro F11BC$L_BLHSHBAS = 36,0,32,1 %;   !  Base addr of buffer lock hash tbl.
macro F11BC$L_BLHSHCNT = 40,0,32,0 %;   !  Num entries in buff lock hash tbl.
macro F11BC$A_FREEBFRL = 44,0,32,0 %;   !  Address of first free buffer lock block.
macro F11BC$Q_POOL_LRU = 48,0,0,1 %;
literal F11BC$S_POOL_LRU = 32;          !  Per pool LRU listhead.
macro F11BC$Q_POOL_WAITQ = 80,0,0,1 %;
literal F11BC$S_POOL_WAITQ = 32;        !  Per pool cache wait listhead.
macro F11BC$L_WAITCNT = 112,0,0,1 %;
literal F11BC$S_WAITCNT = 16;           !  Count of waiters per pool.
macro F11BC$L_POOLAVAIL = 128,0,0,1 %;
literal F11BC$S_POOLAVAIL = 16;         !  Available buffers per pool.
macro F11BC$L_POOLCNT = 144,0,0,1 %;
literal F11BC$S_POOLCNT = 16;           !  Count of buffers per pool.
macro F11BC$L_AMBIGQFL = 160,0,32,1 %;  !  Ambiguity queue forward link.
macro F11BC$L_AMBIGQBL = 164,0,32,1 %;  !  Ambiguity queue back link.
! 
!  Cache performance counters.
! 
macro F11BC$L_PROCESS_HITS = 168,0,32,0 %; !  In-process buffer hits.
macro F11BC$L_VALID_HITS = 172,0,32,0 %; !  Valid buffer cache hits.
macro F11BC$L_INVALID_HITS = 176,0,32,0 %; !  Buffer found but invalid contents.
macro F11BC$L_MISSES = 180,0,32,0 %;    !  Buffer not in cache at all.
macro F11BC$L_DISK_READS = 184,0,32,0 %; !  Buffer reads from disk.
macro F11BC$L_DISK_WRITES = 188,0,32,0 %; !  Buffer writes to disk.
macro F11BC$L_CACHE_SERIAL = 192,0,32,0 %; !  Cache serialization calls.
macro F11BC$L_CACHE_STALLS = 196,0,32,0 %; !  Cache serialization stalls.
macro F11BC$L_BUFFER_STALLS = 200,0,32,0 %; !  Stalls for lack of buffers.
macro F11BC$T_CACHENAME = 204,0,0,0 %;
literal F11BC$S_CACHENAME = 24;         !  Name of this cache (display only).
macro F11BC$L_LOG_BUFFER = 228,0,32,1 %; !  Pointer to activity log buffer
! 
!  Buffer descriptors.
! 
literal BFRD$M_DIRTY = %X'4';
literal BFRD$M_VALID = %X'8';
literal BFRD$M_NOPURGE = %X'10';
literal BFRD$M_ASYNCH_IN_PROG = %X'20';
literal BFRD$M_PINNED = %X'40';
literal BFRD$S_BFRDDEF = 48;            !  Old size name - synonym
literal BFRD$S_BFRD = 48;
macro BFRD$L_QFL = 0,0,32,1 %;          !  Queue forward link.
macro BFRD$L_QBL = 4,0,32,1 %;          !  Queue back link.
macro BFRD$L_LBN = 8,0,32,0 %;          !  LBN of buffer.
macro BFRD$L_UCB = 12,0,32,1 %;         !  UCB of buffer.
macro BFRD$L_LOCKBASIS = 16,0,32,0 %;   !  Unique file identifier.
macro BFRD$L_SEQNUM = 20,0,32,0 %;      !  Buffer validation sequence number.
macro BFRD$B_FLAGS = 24,0,8,0 %;        !  Status flags.
macro BFRD$V_POOL = 24,0,2,0 %;
literal BFRD$S_POOL = 2;                !  Pool number of this buffer.
macro BFRD$V_DIRTY = 24,2,1,0 %;        !  Buffer has been modified.
macro BFRD$V_VALID = 24,3,1,0 %;        !  Buffer has been read from disk.
macro BFRD$V_NOPURGE = 24,4,1,0 %;      !  Do not purge from process cache 
macro BFRD$V_ASYNCH_IN_PROG = 24,5,1,0 %; !  This buffer has an outstanding deferred write
macro BFRD$V_PINNED = 24,6,1,0 %;       !  Buffer is pinned in cache
macro BFRD$B_BTYPE = 25,0,8,0 %;        !  Buffer type.
macro BFRD$L_CURPID = 28,0,32,0 %;      !  Index of current process.
macro BFRD$L_NXTBFRD = 32,0,32,0 %;     !  Index of next BFRD (hash chain).
macro BFRD$A_BFRL = 36,0,32,0 %;        !  Address of buffer lock descriptor.
macro BFRD$L_SAME_BFRL = 40,0,32,0 %;   !  Index to next BFRD under same BFRL
macro BFRD$L_THREAD = 44,0,32,0 %;      !  Thread number
! 
!  Buffer lock descriptor blocks.
! 
literal BFRL$S_BFRLDEF = 24;            !  Old size name - synonym
literal BFRL$S_BFRL = 24;
macro BFRL$A_NXTBFRL = 0,0,32,0 %;      !  Address of next BFRL in hash chain.
macro BFRL$L_BFRD = 4,0,32,0 %;         !  Index to first BFRD under this lock
macro BFRL$L_REFCNT = 8,0,32,0 %;       !  Number of buffers backed by this lock.
macro BFRL$L_LKID = 12,0,32,0 %;        !  Lock ID of buffer lock.
macro BFRL$L_LCKBASIS = 16,0,32,0 %;    !  Unique file identifier.
macro BFRL$L_PARLKID = 20,0,32,0 %;     !  Unique volume set identifier.
 
!*** MODULE $FBICDEF ***
! ++
! 	Define FBIC offsets and registers for Firefox systems
! --
literal FBIC$L_MODTYPE = 508;           ! Module type
literal FBIC$L_BUSCSR = 504;            ! MBUS error status
literal FBIC$L_BUSCTL = 500;            ! MBUS error control signal log
literal FBIC$L_BUSADR = 496;            ! MBUS error address signal log
literal FBIC$L_BUSDAT = 492;            ! MBUS error data signal log
literal FBIC$L_FBICSR = 488;            ! FBIC CSR
literal FBIC$L_RANGE = 484;             ! I/O Space range deco=e
literal FBIC$L_IPDVINT = 480;           ! IP/Device interrupt
literal FBIC$L_WHAMI = 476;             ! Unique software ID
literal FBIC$L_CPUID = 472;             ! Unique hardware ID
literal FBIC$L_IADR1 = 468;             ! Interlock 1 address
literal FBIC$L_IADR2 = 464;             ! Interlock 2 address
literal FBIC$L_SAVGPR = 452;            ! Scratch register
literal FMDC$L_FMDCSR = 488;            ! FMDC CSR
literal FMDC$L_BASEADDR = 484;          ! Memory space base address
literal FMDC$L_ECCADDR0 = 480;          ! ECC error address (QW0)
literal FMDC$L_ECCADDR1 = 476;          ! ECC error address (QW1)
literal FMDC$L_ECCSYND0 = 472;          ! ECC error status (QW0)
literal FMDC$L_ECCSYND1 = 468;          ! ECC error status (QW1)
literal FMDC$L_MSECTERR = 464;          ! Memory section
literal FMDC$L_MBUSSIG = 460;           ! MBUS control signature
literal FMDC$L_DRAMSIG = 456;           ! DRAM control signature
literal FMDC$L_SELFSIG = 452;           ! Self test signature
literal FMDC$L_LEDLATCH = 448;          ! Diagnostic LED latch
literal FBIC$S_MODTYPE = 4;
macro FBIC$V_MODTYPE_CLASS = 0,0,8,0 %;
literal FBIC$S_MODTYPE_CLASS = 8;       !  Class of module
macro FBIC$V_MODTYPE_SUBCLASS = 0,8,8,0 %;
literal FBIC$S_MODTYPE_SUBCLASS = 8;    !  Low bit echoes TYPDUAL
macro FBIC$V_MODTYPE_INTERFACE = 0,16,8,0 %;
literal FBIC$S_MODTYPE_INTERFACE = 8;   !  FBIC interface  == 1
macro FBIC$V_MODTYPE_REVISION = 0,24,8,0 %;
literal FBIC$S_MODTYPE_REVISION = 8;    !  FBIC hardware revision
literal KA60$K_MODTYPE_FBIC = 1;        !  1 FBIC interface
literal KA60$K_MODTYPE_FMDC = 2;        !  2 FMDC interface
literal KA60$K_MODTYPE_FMCM = 254;
literal FBIC$M_BUSCSR_DBLE = %X'10000';
literal FBIC$M_BUSCSR_SERR = %X'20000';
literal FBIC$M_BUSCSR_CTPE = %X'40000';
literal FBIC$M_BUSCSR_CDPE = %X'80000';
literal FBIC$M_BUSCSR_CTO = %X'100000';
literal FBIC$M_BUSCSR_NOS = %X'200000';
literal FBIC$M_BUSCSR_MTO = %X'400000';
literal FBIC$M_BUSCSR_ILCK = %X'800000';
literal FBIC$M_BUSCSR_MCPE = %X'1000000';
literal FBIC$M_BUSCSR_MSPE = %X'2000000';
literal FBIC$M_BUSCSR_MDPE = %X'4000000';
literal FBIC$M_BUSCSR_MTPE = %X'8000000';
literal FBIC$M_BUSCSR_IDAT = %X'10000000';
literal FBIC$M_BUSCSR_ICMD = %X'20000000';
literal FBIC$M_BUSCSR_ARB = %X'40000000';
literal FBIC$M_BUSCSR_FRZN = %X'80000000';
literal FBIC$S_BUSCSR = 4;
macro FBIC$V_BUSCSR_DBLE = 0,16,1,0 %;  ! MBUS double error bit
macro FBIC$V_BUSCSR_SERR = 0,17,1,0 %;  ! SERR
macro FBIC$V_BUSCSR_CTPE = 0,18,1,0 %;  ! CDAL tag store parity error
macro FBIC$V_BUSCSR_CDPE = 0,19,1,0 %;  ! CDAL parity error
macro FBIC$V_BUSCSR_CTO = 0,20,1,0 %;   ! CDAL timeout
macro FBIC$V_BUSCSR_NOS = 0,21,1,0 %;   ! MBUS no slave response
macro FBIC$V_BUSCSR_MTO = 0,22,1,0 %;   ! MBUS slave timeout
macro FBIC$V_BUSCSR_ILCK = 0,23,1,0 %;  ! MBUS interlock violation
macro FBIC$V_BUSCSR_MCPE = 0,24,1,0 %;  ! MBUS MCMD parity error
macro FBIC$V_BUSCSR_MSPE = 0,25,1,0 %;  ! MBUS MSTATUS parity error
macro FBIC$V_BUSCSR_MDPE = 0,26,1,0 %;  ! MBUS MDAL parity error
macro FBIC$V_BUSCSR_MTPE = 0,27,1,0 %;  ! MBUS tag parity error
macro FBIC$V_BUSCSR_IDAT = 0,28,1,0 %;  ! MBUS invalid data supplied
macro FBIC$V_BUSCSR_ICMD = 0,29,1,0 %;  ! MBUS invalid MCMD encoding
macro FBIC$V_BUSCSR_ARB = 0,30,1,0 %;   ! MBUS arbitration error
macro FBIC$V_BUSCSR_FRZN = 0,31,1,0 %;  ! MBUS error logging frozen
literal FBIC$M_BUSCTL_MBRM = %X'7F';
literal FBIC$M_BUSCTL_MBRP = %X'80';
literal FBIC$M_BUSCTL_MBRQ = %X'100';
literal FBIC$M_BUSCTL_MCMD = %X'1E00';
literal FBIC$M_BUSCTL_MCPAR = %X'2000';
literal FBIC$M_BUSCTL_MSTATUS = %X'C000';
literal FBIC$M_BUSCTL_MSPAR = %X'10000';
literal FBIC$M_BUSCTL_MDPAR = %X'20000';
literal FBIC$M_BUSCTL_MBUSY = %X'40000';
literal FBIC$M_BUSCTL_MSHARED = %X'80000';
literal FBIC$M_BUSCTL_MDATINV = %X'100000';
literal FBIC$M_BUSCTL_MABORT = %X'200000';
literal FBIC$M_BUSCTL_MHALT = %X'400000';
literal FBIC$M_BUSCTL_PHASE = %X'3800000';
literal FBIC$M_BUSCTL_SLAVE = %X'4000000';
literal FBIC$M_BUSCTL_MASTER = %X'8000000';
literal FBIC$M_BUSCTL_SVDMCMD = %X'F0000000';
literal FBIC$S_BUSCTL = 4;
macro FBIC$V_BUSCTL_MBRM = 0,0,7,0 %;
literal FBIC$S_BUSCTL_MBRM = 7;         !  MBRM signals
macro FBIC$V_BUSCTL_MBRP = 0,7,1,0 %;   !  MBRP signal
macro FBIC$V_BUSCTL_MBRQ = 0,8,1,0 %;   !  MBRQ signal
macro FBIC$V_BUSCTL_MCMD = 0,9,4,0 %;
literal FBIC$S_BUSCTL_MCMD = 4;         !  MCMD signals
macro FBIC$V_BUSCTL_MCPAR = 0,13,1,0 %; !  MCPAR signal
macro FBIC$V_BUSCTL_MSTATUS = 0,14,2,0 %;
literal FBIC$S_BUSCTL_MSTATUS = 2;      !  MSTATUS signal
macro FBIC$V_BUSCTL_MSPAR = 0,16,1,0 %; !  MSPAR
macro FBIC$V_BUSCTL_MDPAR = 0,17,1,0 %; !  MDPAR
macro FBIC$V_BUSCTL_MBUSY = 0,18,1,0 %; !  MBUSY
macro FBIC$V_BUSCTL_MSHARED = 0,19,1,0 %; !  MSHARED
macro FBIC$V_BUSCTL_MDATINV = 0,20,1,0 %; !  MDATINV
macro FBIC$V_BUSCTL_MABORT = 0,21,1,0 %; !  MABORT
macro FBIC$V_BUSCTL_MHALT = 0,22,1,0 %; !  MHALT
macro FBIC$V_BUSCTL_PHASE = 0,23,3,0 %;
literal FBIC$S_BUSCTL_PHASE = 3;        !  BUS PHASE
macro FBIC$V_BUSCTL_SLAVE = 0,26,1,0 %; !  SLAVE
macro FBIC$V_BUSCTL_MASTER = 0,27,1,0 %; !  MASTER
macro FBIC$V_BUSCTL_SVDMCMD = 0,28,4,0 %;
literal FBIC$S_BUSCTL_SVDMCMD = 4;      !  MCMD signal
literal FBIC$M_FBICSR_CDPE = %X'1';
literal FBIC$M_FBICSR_TSTFNC = %X'3E';
literal FBIC$M_FBICSR_HALTEN = %X'80';
literal FBIC$M_FBICSR_LEDS = %X'3F00';
literal FBIC$M_FBICSR_IRQC2M = %X'F0000';
literal FBIC$M_FBICSR_IRQEN = %X'F00000';
literal FBIC$M_FBICSR_RESET = %X'1000000';
literal FBIC$M_FBICSR_HALTCPU = %X'2000000';
literal FBIC$M_FBICSR_EXCAEN = %X'4000000';
literal FBIC$M_FBICSR_CMISS = %X'8000000';
literal FBIC$M_FBICSR_MFMD = %X'C0000000';
literal FBIC$S_FBICSR = 4;
macro FBIC$V_FBICSR_CDPE = 0,0,1,0 %;   ! CBUS parity check enable
macro FBIC$V_FBICSR_TSTFNC = 0,1,5,0 %;
literal FBIC$S_FBICSR_TSTFNC = 5;       ! Diagnostic test function
macro FBIC$V_FBICSR_HALTEN = 0,7,1,0 %; ! Enable CPU halts
macro FBIC$V_FBICSR_LEDS = 0,8,6,0 %;
literal FBIC$S_FBICSR_LEDS = 6;         ! FBIC LED output
macro FBIC$V_FBICSR_IRQC2M = 0,16,4,0 %;
literal FBIC$S_FBICSR_IRQC2M = 4;       ! Interrupt request direction
macro FBIC$V_FBICSR_IRQEN = 0,20,4,0 %;
literal FBIC$S_FBICSR_IRQEN = 4;        ! Interrupt request enable
macro FBIC$V_FBICSR_RESET = 0,24,1,0 %; ! CBUS RESET
macro FBIC$V_FBICSR_HALTCPU = 0,25,1,0 %; ! CBUS halt control
macro FBIC$V_FBICSR_EXCAEN = 0,26,1,0 %; ! External cache enable
macro FBIC$V_FBICSR_CMISS = 0,27,1,0 %; ! CBUS cache miss occurred
macro FBIC$V_FBICSR_MFMD = 0,30,2,0 %;
literal FBIC$S_FBICSR_MFMD = 2;         ! Manufacturing mode
literal FBIC$M_RANGE_MASK = %X'7FFF';
literal FBIC$M_RANGE_ENABLE = %X'8000';
literal FBIC$M_RANGE_MATCH = %X'FFFF0000';
literal FBIC$S_RANGE = 4;
macro FBIC$V_RANGE_MASK = 0,0,15,0 %;
literal FBIC$S_RANGE_MASK = 15;         ! I/O space address range mask
macro FBIC$V_RANGE_ENABLE = 0,15,1,0 %; ! I/O space address range enable
macro FBIC$V_RANGE_MATCH = 0,16,16,0 %;
literal FBIC$S_RANGE_MATCH = 16;        ! I/O space address range match
literal FBIC$M_IPDVINT_VECTOR = %X'FFFF';
literal FBIC$M_IPDVINT_DEVUNIT = %X'10000';
literal FBIC$M_IPDVINT_IPUNIT = %X'20000';
literal FBIC$M_IPDVINT_IPL14 = %X'1000000';
literal FBIC$M_IPDVINT_IPL15 = %X'2000000';
literal FBIC$M_IPDVINT_IPL16 = %X'4000000';
literal FBIC$M_IPDVINT_IPL17 = %X'8000000';
literal FBIC$S_IPDVINT = 4;
macro FBIC$V_IPDVINT_VECTOR = 0,0,16,0 %;
literal FBIC$S_IPDVINT_VECTOR = 16;     ! Interrupt vector
macro FBIC$V_IPDVINT_DEVUNIT = 0,16,1,0 %; ! Device interrupt unit
macro FBIC$V_IPDVINT_IPUNIT = 0,17,1,0 %; ! I/P interrupt unit
macro FBIC$V_IPDVINT_IPL14 = 0,24,1,0 %; ! Generate IPL 14 interrupt
macro FBIC$V_IPDVINT_IPL15 = 0,25,1,0 %; ! Generate IPL 15 interrupt
macro FBIC$V_IPDVINT_IPL16 = 0,26,1,0 %; ! Generate IPL 16 interrupt
macro FBIC$V_IPDVINT_IPL17 = 0,27,1,0 %; ! Generate IPL 17 interrupt
literal FBIC$M_CPUID_PROC = %X'3';
literal FBIC$M_CPUID_MID = %X'C';
literal FBIC$S_CPUID = 1;
macro FBIC$V_CPUID_PROC = 0,0,2,0 %;
literal FBIC$S_CPUID_PROC = 2;          ! Processor identifier
macro FBIC$V_CPUID_MID = 0,2,2,0 %;
literal FBIC$S_CPUID_MID = 2;           ! Module slot identifier
literal FMDC$M_FMDCSR_RAS_CNT = %X'FF';
literal FMDC$M_FMDCSR_ST_START = %X'100';
literal FMDC$M_FMDCSR_ST_DONE = %X'200';
literal FMDC$M_FMDCSR_DTCB = %X'400';
literal FMDC$M_FMDCSR_DIS_REFRESH = %X'1000';
literal FMDC$M_FMDCSR_RPS = %X'2000';
literal FMDC$M_FMDCSR_DRS = %X'4000';
literal FMDC$M_FMDCSR_EDM = %X'18000';
literal FMDC$M_FMDCSR_FESC = %X'60000';
literal FMDC$M_FMDCSR_FEC = %X'380000';
literal FMDC$M_FMDCSR_ISR = %X'400000';
literal FMDC$M_FMDCSR_ISML = %X'800000';
literal FMDC$M_FMDCSR_MOL = %X'40000000';
literal FMDC$M_FMDCSR_EFS = %X'80000000';
literal FMDC$S_FMDCSR = 4;
macro FMDC$V_FMDCSR_RAS_CNT = 0,0,8,0 %;
literal FMDC$S_FMDCSR_RAS_CNT = 8;      !  Refresh counter
macro FMDC$V_FMDCSR_ST_START = 0,8,1,0 %; !  Self test start
macro FMDC$V_FMDCSR_ST_DONE = 0,9,1,0 %; !  Self test complete
macro FMDC$V_FMDCSR_DTCB = 0,10,1,0 %;  !  Data to check bits
macro FMDC$V_FMDCSR_DIS_REFRESH = 0,12,1,0 %; !  Disable refresh
macro FMDC$V_FMDCSR_RPS = 0,13,1,0 %;   !  Refresh period select
macro FMDC$V_FMDCSR_DRS = 0,14,1,0 %;   !  Diagnostic refresh start
macro FMDC$V_FMDCSR_EDM = 0,15,2,0 %;
literal FMDC$S_FMDCSR_EDM = 2;          !  ECC diagnostic mode
macro FMDC$V_FMDCSR_FESC = 0,17,2,0 %;
literal FMDC$S_FMDCSR_FESC = 2;         !  Force error sub category
macro FMDC$V_FMDCSR_FEC = 0,19,3,0 %;
literal FMDC$S_FMDCSR_FEC = 3;          !  Force error category
macro FMDC$V_FMDCSR_ISR = 0,22,1,0 %;   !  Inhibit SBE reporting
macro FMDC$V_FMDCSR_ISML = 0,23,1,0 %;  !  Inhibit SBE MSECTERR log
macro FMDC$V_FMDCSR_MOL = 0,30,1,0 %;   !  Module on-line
macro FMDC$V_FMDCSR_EFS = 0,31,1,0 %;   !  Error flag summary
literal FMDC$M_BASEADDR_STARTADDR = %X'7FF00000';
literal FMDC$M_BASEADDR_MEMSPEN = %X'80000000';
literal FMDC$S_BASEADDR = 4;
macro FMDC$V_BASEADDR_STARTADDR = 0,20,11,0 %;
literal FMDC$S_BASEADDR_STARTADDR = 11; !  Starting memory address
macro FMDC$V_BASEADDR_MEMSPEN = 0,31,1,0 %; !  Memory space enable
literal FMDC$M_ECCADDR_RAMERRADDR0 = %X'7FFFFF0';
literal FMDC$S_ECCADDR = 4;
macro FMDC$V_ECCADDR_RAMERRADDR0 = 0,4,23,0 %;
literal FMDC$S_ECCADDR_RAMERRADDR0 = 23; !  ECC Error address
literal FMDC$M_ECCSYND_SYND0 = %X'FF';
literal FMDC$M_ECCSYND_SBE = %X'100';
literal FMDC$M_ECCSYND_MBE = %X'200';
literal FMDC$M_ECCSYND_ERROVFL = %X'1C00';
literal FMDC$M_ECCSYND_SUBCB = %X'FF0000';
literal FMDC$M_ECCSYND_READCB = %X'FF000000';
literal FMDC$S_ECCSYND = 4;
macro FMDC$V_ECCSYND_SYND0 = 0,0,8,0 %;
literal FMDC$S_ECCSYND_SYND0 = 8;       !  ECC syndronme
macro FMDC$V_ECCSYND_SBE = 0,8,1,0 %;   !  Single bit error
macro FMDC$V_ECCSYND_MBE = 0,9,1,0 %;   !  Multiple bit error
macro FMDC$V_ECCSYND_ERROVFL = 0,10,3,0 %;
literal FMDC$S_ECCSYND_ERROVFL = 3;     !  Error overflow field
macro FMDC$V_ECCSYND_SUBCB = 0,16,8,0 %;
literal FMDC$S_ECCSYND_SUBCB = 8;       !  Substitute check bits
macro FMDC$V_ECCSYND_READCB = 0,24,8,0 %;
literal FMDC$S_ECCSYND_READCB = 8;      !  Read check bits
 
!*** MODULE $FBUSDEF ***
! +
!  This file describes the layout of Futurebus CSR space.  The information is
!  based on the IEEE Futurebus specification 896.2 and IEEE CSR Architecture
!  specification P1212.
! -
literal FBUS$M_TEST_STATUS_FAILED = %X'1';
literal FBUS$M_TEST_STATUS_TIMEOUT = %X'2';
literal FBUS$M_TEST_STATUS_IMPLEMENTED = %X'4';
literal FBUS$M_TEST_STATUS_LOOPING = %X'8';
literal FBUS$M_TEST_STATUS_ACTIVE = %X'10';
literal FBUS$M_TEST_STATUS_reserved = %X'20';
literal FBUS$M_TEST_STATUS_STEP = %X'3FFFC0';
literal FBUS$M_TEST_STATUS_FRU = %X'FC00000';
literal FBUS$M_TEST_STATUS_CAT = %X'F0000000';
literal FBUS$M_ROM_BASE_CRC_VALUE = %X'FFFF';
literal FBUS$M_ROM_BASE_CRC_LENGTH = %X'FF0000';
literal FBUS$M_ROM_BASE_BUS_INFO_LENGTH = %X'FF000000';
literal FBUS$M_ROOT_DIR_BASE_CRC = %X'FFFF';
literal FBUS$M_ROOT_DIR_BASE_LENGTH = %X'FFFF0000';
literal FBUS$K_NODE_SPACE_LENGTH = 4096;
literal FBUS$S_FBUSDEF = 4096;          !  Old size name, synonym for  FBUS$S_FBUS
literal FBUS$S_FBUS = 4096;
!  The following definitions are for CORE CSR space, required by a all Futurebus
!  nodes.
macro FBUS$L_CSR_CORE = 0,0,0,0 %;      !  CSR Core base offset
macro FBUS$L_STATE_CLEAR = 0,0,32,0 %;
macro FBUS$L_STATE_SET = 4,0,32,0 %;
macro FBUS$L_NODE_IDS = 8,0,32,0 %;
macro FBUS$L_RESET_START = 12,0,32,0 %;
macro FBUS$L_INDIRECT_ADDRESS = 16,0,32,0 %;
macro FBUS$L_INDIRECT_DATA = 20,0,32,0 %;
macro FBUS$L_SPLIT_TIMEOUT_HI = 24,0,32,0 %;
macro FBUS$L_SPLIT_TIMEOUT_LO = 28,0,32,0 %;
macro FBUS$L_ARGUMENT_HI = 32,0,32,0 %;
macro FBUS$L_ARGUMENT_LO = 36,0,32,0 %;
macro FBUS$L_TEST_START = 40,0,32,0 %;
macro FBUS$L_TEST_STATUS = 44,0,32,0 %;
macro FBUS$V_TEST_STATUS_FAILED = 44,0,1,0 %;
macro FBUS$V_TEST_STATUS_TIMEOUT = 44,1,1,0 %;
macro FBUS$V_TEST_STATUS_IMPLEMENTED = 44,2,1,0 %;
macro FBUS$V_TEST_STATUS_LOOPING = 44,3,1,0 %;
macro FBUS$V_TEST_STATUS_ACTIVE = 44,4,1,0 %;
macro FBUS$V_TEST_STATUS_reserved = 44,5,1,0 %;
macro FBUS$V_TEST_STATUS_STEP = 44,6,16,0 %;
literal FBUS$S_TEST_STATUS_STEP = 16;
macro FBUS$V_TEST_STATUS_FRU = 44,22,6,0 %;
literal FBUS$S_TEST_STATUS_FRU = 6;
macro FBUS$V_TEST_STATUS_CAT = 44,28,4,0 %;
literal FBUS$S_TEST_STATUS_CAT = 4;
macro FBUS$L_UNITS_BASE_HI = 48,0,32,0 %;
macro FBUS$L_UNITS_BASE_LO = 52,0,32,0 %;
macro FBUS$L_UNITS_BOUND_HI = 56,0,32,0 %;
macro FBUS$L_UNITS_BOUND_LO = 60,0,32,0 %;
macro FBUS$L_MEMORY_BASE_HI = 64,0,32,0 %;
macro FBUS$L_MEMORY_BASE_LO = 68,0,32,0 %;
macro FBUS$L_MEMORY_BOUND_HI = 72,0,32,0 %;
macro FBUS$L_MEMORY_BOUND_LO = 76,0,32,0 %;
macro FBUS$L_INTERRUPT_TARGET = 80,0,32,0 %;
macro FBUS$L_INTERRUPT_MASK = 84,0,32,0 %;
macro FBUS$L_CLOCK_VALUE_HI = 88,0,32,0 %;
macro FBUS$L_CLOCK_VALUE_MID = 92,0,32,0 %;
macro FBUS$L_CLOCK_TICK_PERIOD_MID = 96,0,32,0 %;
macro FBUS$L_CLOCK_TICK_PERIOD_LO = 100,0,32,0 %;
macro FBUS$L_CLOCK_STROBE_ARRIVED_HI = 104,0,32,0 %;
macro FBUS$L_CLOCK_STROBE_ARRIVED_MID = 108,0,32,0 %;
macro FBUS$L_CLOCK_STROBE = 112,0,32,0 %;
macro FBUS$L_CLOCK_INFO1 = 116,0,32,0 %;
macro FBUS$L_CLOCK_REFERENCE = 120,0,32,0 %;
macro FBUS$L_CLOCK_INFO3 = 124,0,32,0 %;
macro FBUS$L_MESSAGE_REQUEST = 128,0,0,0 %;
literal FBUS$S_MESSAGE_REQUEST = 64;    !  Message Request area
macro FBUS$L_MESSAGE_RESPONSE = 192,0,0,0 %;
literal FBUS$S_MESSAGE_RESPONSE = 64;   !  Message Response area
macro FBUS$L_P1212_RESERVED = 256,0,0,0 %;
literal FBUS$S_P1212_RESERVED = 128;    !  Reserved by P1212
macro FBUS$L_ERROR_HI = 384,0,32,0 %;
macro FBUS$L_ERROR_LO = 388,0,32,0 %;
macro FBUS$L_FADR_HI = 392,0,32,0 %;
macro FBUS$L_FADR_LO = 396,0,32,0 %;
macro FBUS$L_ERROR_LOG_BUFFER = 400,0,0,0 %;
literal FBUS$S_ERROR_LOG_BUFFER = 112;
!  The following definitions describe the Futurebus dependent CSR area
macro FBUS$L_BUS_DEPENDENT = 512,0,0,0 %; !  Bus Dependent CSR base offset
macro FBUS$L_LOGICAL_COMMON_CONTROL = 512,0,32,0 %;
macro FBUS$L_LOGICAL_MODULE_CONTROL = 516,0,32,0 %;
macro FBUS$L_BUS_PROP_DELAY = 520,0,32,0 %;
macro FBUS$L_COMP_SETTLING_TIME = 524,0,32,0 %;
macro FBUS$L_TRANSACTION_TIMEOUT = 528,0,32,0 %;
macro FBUS$L_MSG_SELECT_MASK_HI = 532,0,32,0 %;
macro FBUS$L_MSG_SELECT_MASK_LO = 536,0,32,0 %;
macro FBUS$L_BSY_RTRY_COUNTER = 540,0,32,0 %;
macro FBUS$L_BSY_RTRY_DELAY = 544,0,32,0 %;
macro FBUS$L_ERR_RTRY_COUNTER = 548,0,32,0 %;
macro FBUS$L_ERR_RTRY_DELAY = 552,0,32,0 %;
macro FBUS$L_BUS_DEPENDENT_RESERVED = 556,0,0,0 %;
literal FBUS$S_BUS_DEPENDENT_RESERVED = 212;
macro FBUS$L_VENDOR_DEPENDENT = 768,0,0,0 %;
literal FBUS$S_VENDOR_DEPENDENT = 256;
!  The following definitions describe the Futurebus ROM area.
macro FBUS$L_ROM_BASE = 1024,0,32,0 %;
macro FBUS$V_ROM_BASE_CRC_VALUE = 1024,0,16,0 %;
literal FBUS$S_ROM_BASE_CRC_VALUE = 16;
macro FBUS$V_ROM_BASE_CRC_LENGTH = 1024,16,8,0 %;
literal FBUS$S_ROM_BASE_CRC_LENGTH = 8;
macro FBUS$V_ROM_BASE_BUS_INFO_LENGTH = 1024,24,8,0 %;
literal FBUS$S_ROM_BASE_BUS_INFO_LENGTH = 8;
macro FBUS$L_BUS_ID = 1028,0,32,0 %;
macro FBUS$L_PROFILE_ID_HI = 1032,0,32,0 %;
macro FBUS$L_PROFILE_ID_LO = 1036,0,32,0 %;
macro FBUS$L_MOD_LOG_CAP = 1040,0,32,0 %;
macro FBUS$L_NODE_CAP_EXT = 1044,0,32,0 %;
macro FBUS$L_COMP_INT_DELAY = 1048,0,32,0 %;
macro FBUS$L_PACKET_SPEED = 1052,0,32,0 %;
macro FBUS$L_MSG_FRAME_SIZE = 1056,0,32,0 %;
macro FBUS$L_BSY_RTRY_COUNTER_CAP = 1060,0,32,0 %;
macro FBUS$L_BSY_RTRY_DELAY_CAP = 1064,0,32,0 %;
macro FBUS$L_ERR_RTRY_COUNTER_CAP = 1068,0,32,0 %;
macro FBUS$L_ERR_RTRY_DELAY_CAP = 1072,0,32,0 %;
macro FBUS$L_BUS_INFO_RESERVED = 1076,0,0,0 %;
literal FBUS$S_BUS_INFO_RESERVED = 12;
macro FBUS$L_ROOT_DIR_BASE = 1088,0,32,0 %;
macro FBUS$V_ROOT_DIR_BASE_CRC = 1088,0,16,0 %;
literal FBUS$S_ROOT_DIR_BASE_CRC = 16;
macro FBUS$V_ROOT_DIR_BASE_LENGTH = 1088,16,16,0 %;
literal FBUS$S_ROOT_DIR_BASE_LENGTH = 16;
macro FBUS$L_INITIAL_UNITS_SPACE_BASE = 2048,0,0,0 %; !  Initial Units Space base offset
macro FBUS$L_INITIAL_UNITS_SPACE_fill = 2048,0,0,0 %;
literal FBUS$S_INITIAL_UNITS_SPACE_fill = 2048;
!  The following definitions describe the format of entries in root directories,
!  subdirectories, and leaves.  Root directories, subdirectories, and leaves are
!  basically all the same thing -- an area of ROM space containing information
!  about the module, node, or unit.  See P1212 for the gory details on directory entry
!  specification.  Briefly, each type of directory contains an initial entry which
!  indicates the size of the directory followed by one or more entries.
!  All entries in a directory contain a key in byte 0, which identifies
!  the type of entry, and a value in bytes 1, 2, and 3.  The value can be an
!  immediate value or a pointer, depending on the key value.
!  Directory base entry format
literal FBUS$M_DIR_BASE_CRC = %X'FFFF';
literal FBUS$M_DIR_BASE_LENGTH = %X'FFFF0000';
literal FBUS$S_DIR_BASE_DEF = 4;        !  Old size name, synonym for  FBUS$S_DIR_BASE
literal FBUS$S_DIR_BASE = 4;
macro FBUS$L_DIR_BASE = 0,0,32,0 %;
macro FBUS$V_DIR_BASE_CRC = 0,0,16,0 %;
literal FBUS$S_DIR_BASE_CRC = 16;
macro FBUS$V_DIR_BASE_LENGTH = 0,16,16,0 %;
literal FBUS$S_DIR_BASE_LENGTH = 16;
literal FBUS$M_DIR_ENTRY_VALUE = %X'FFFFFF';
literal FBUS$M_DIR_ENTRY_KEY = %X'FF000000';
literal FBUS$S_DIR_ENTRY_DEF = 4;       !  Old size name, synonym for  FBUS$S_DIR_ENTRY
literal FBUS$S_DIR_ENTRY = 4;           !  Directory entry format
macro FBUS$L_DIR_ENTRY = 0,0,32,0 %;
macro FBUS$V_DIR_ENTRY_VALUE = 0,0,24,0 %;
literal FBUS$S_DIR_ENTRY_VALUE = 24;
macro FBUS$V_DIR_ENTRY_KEY = 0,24,8,0 %;
literal FBUS$S_DIR_ENTRY_KEY = 8;
!  The following definition describes the Digital implementation of ROM
!  directory entry MODULE_SW_VERSION
literal FBUS$M_DIGITAL_SW_VERSION_NODE = %X'1';
literal FBUS$M_DIGITAL_SW_VERSION_UNIT = %X'3E';
literal FBUS$M_DIGITAL_SW_VERSION_VAR = %X'3FC0';
literal FBUS$M_DIGITAL_SW_VERSION_NUM = %X'FFC000';
literal FBUS$M_DIGITAL_SW_VERSION_KEY = %X'FF000000';
literal FBUS$S_DIGITAL_SW_VERSION_DEF = 4; !  Old size name, synonym for  FBUS$S_DIGITAL_SW_VERSION
literal FBUS$S_DIGITAL_SW_VERSION = 4;
macro FBUS$L_DIGITAL_SW_VERSION = 0,0,32,0 %;
macro FBUS$V_DIGITAL_SW_VERSION_NODE = 0,0,1,0 %;
macro FBUS$V_DIGITAL_SW_VERSION_UNIT = 0,1,5,0 %;
literal FBUS$S_DIGITAL_SW_VERSION_UNIT = 5;
macro FBUS$V_DIGITAL_SW_VERSION_VAR = 0,6,8,0 %;
literal FBUS$S_DIGITAL_SW_VERSION_VAR = 8;
macro FBUS$V_DIGITAL_SW_VERSION_NUM = 0,14,10,0 %;
literal FBUS$S_DIGITAL_SW_VERSION_NUM = 10;
macro FBUS$V_DIGITAL_SW_VERSION_KEY = 0,24,8,0 %;
literal FBUS$S_DIGITAL_SW_VERSION_KEY = 8;
!  Format of Bus Array entry hardware_id quadword.  When we probe the
!  Futurebus, we concatenate the vendor_id and the sw_version (which are both
!  read from the Fbus ROM area) and store the resulting quadword in a bus array 
!  entry.  The following structure defines the format of the hardware id
!  quadword in the bus array entry.
literal DEC_FBUS$S_HW_ID_DEF = 8;       !  Old size name, synonym for  DEC_FBUS$S_HW_ID
literal DEC_FBUS$S_FBUS_HW_ID = 8;
macro DEC_FBUS$Q_HW_ID = 0,0,0,0 %;
literal DEC_FBUS$S_HW_ID = 8;
macro DEC_FBUS$L_HW_ID_SW_VERSION = 0,0,32,0 %;
macro DEC_FBUS$L_HW_ID_VENDOR_ID = 4,0,32,0 %;
!  The following key types are defined by IEEE 1212.
literal FBUS_KEY$K_TEX_LEAF = 129;
literal FBUS_KEY$K_TEX_SUBD = 193;
literal FBUS_KEY$K_BUS_DEP_INFO_LEAF = 130;
literal FBUS_KEY$K_BUS_DEP_INFO_SUBD = 194;
literal FBUS_KEY$K_MODULE_VENDOR_ID = 3;
literal FBUS_KEY$K_MODULE_HW_VERSION = 4;
literal FBUS_KEY$K_MODULE_SPEC_ID = 5;
literal FBUS_KEY$K_MODULE_SW_VERSION = 6;
literal FBUS_KEY$K_MODULE_DEP_INFO_LEAF = 135;
literal FBUS_KEY$K_MODULE_DEP_INFO_SUBD = 199;
literal FBUS_KEY$K_NODE_VENDOR_ID = 8;
literal FBUS_KEY$K_NODE_HW_VERSION = 9;
literal FBUS_KEY$K_NODE_SPEC_ID = 10;
literal FBUS_KEY$K_NODE_SW_VERSION = 11;
literal FBUS_KEY$K_NODE_CAPABILITIES = 12;
literal FBUS_KEY$K_NODE_UNIQUE_ID_LEAF = 141;
literal FBUS_KEY$K_NODE_UNITS_EXTENT = 14;
literal FBUS_KEY$K_NODE_UNITS_EXTENT_OF = 78;
literal FBUS_KEY$K_NODE_MEM_EXTENT = 15;
literal FBUS_KEY$K_NODE_MEM_EXTENT_OF = 79;
literal FBUS_KEY$K_NODE_DEP_INFO_LEAF = 144;
literal FBUS_KEY$K_NODE_DEP_INFO_SUBD = 208;
literal FBUS_KEY$K_UNIT_SUB = 209;
literal FBUS_KEY$K_UNIT_SPEC_ID = 18;
literal FBUS_KEY$K_UNIT_SW_VERSION = 19;
literal FBUS_KEY$K_UNIT_DEP_INFO_LEAF = 148;
literal FBUS_KEY$K_UNIT_DEP_INFO_SUBD = 212;
literal FBUS_KEY$K_UNIT_LOCATION = 149;
literal FBUS_KEY$K_UNIT_POLL_MASK = 149;
!  The following constants are useful for bus probing
literal FBUS$K_NODE0_BASE_CSR = -262144;
literal FBUS$K_MAX_NODE_NUMBER = 63;
literal FBUS$K_DIGITAL_VENDOR_ID = 524331;
!  Create constants to represent Futurebus commands.  These are the
!  values that will be copied to the command field of the hardware mailbox
!  for Futurebus register access.
!  
!  The following encodings for the Futurebus command field are taken
!  from the Cobra I/O Module spec.  These encodings should be the same 
!  for a Futurebus on any platform.
! 
!      7   6   5   4   3   2   1  0
!    +---+---+---+---+---+---+---+---+
!    |AW | 0 |DW |WR | transaction   |
!    +---+---+---+---+---+---+---+---+
! 
!        Bit                     Meaning
!        ---                     -------
!        AW = 0                  32 bit addressing
!        AW = 1                  64 bit addressing
!        DW = 0                  32 bit data width
!        DW = 1                  64 bit data width
!        WR = 0                  read transaction
!        WR = 1                  write transaction
!        transaction = 0         unlocked transaction
!        transaction = 2         partial (masked) transaction
! 
!  Bit 31 of the mailbox command field is defined by the Alpha SRM to
!  mean that the command is a write.  This bit is not passed onto the 
!  Futurebus--it is intended as a performance assist for a local side
!  module.
! 
literal FBUS$K_RDQUAD32 = 32;           !  Read, unlocked, AW=32, DW=64
literal FBUS$K_RDLONG32 = 0;            !  Read, unlocked, AW=32, DW=32
literal FBUS$K_RDWORD32 = 2;            !  Read, partial,  AW=32, DW=32
literal FBUS$K_RDBYTE32 = 2;            !  Read, partial,  AW=32, DW=32
literal FBUS$K_WTQUAD32 = 48;           !  write, unlocked, AW=32, DW=64
literal FBUS$K_WTLONG32 = 16;           !  write, unlocked, AW=32, DW=32
literal FBUS$K_WTWORD32 = 18;           !  write, partial,  AW=32, DW=32
literal FBUS$K_WTBYTE32 = 18;           !  write, partial,  AW=32, DW=32
literal FBUS$K_RDQUAD64 = 160;          !  Read, unlocked, AW=64, DW=64
literal FBUS$K_RDLONG64 = 128;          !  Read, unlocked, AW=64, DW=32
literal FBUS$K_RDWORD64 = 130;          !  Read, partial,  AW=64, DW=32
literal FBUS$K_RDBYTE64 = 130;          !  Read, partial,  AW=64, DW=32
literal FBUS$K_WTQUAD64 = 176;          !  Write, unlocked, AW=64, DW=64
literal FBUS$K_WTLONG64 = 144;          !  Write, unlocked, AW=64, DW=32
literal FBUS$K_WTWORD64 = 146;          !  Write, partial,  AW=64, DW=32 
literal FBUS$K_WTBYTE64 = 146;          !  Write, partial , AW=64, DW=32
 
!*** MODULE $FCBDEF ***
! +
!  FCB - FILE CONTROL BLOCK
! 
!  THERE IS ONE FILE CONTROL BLOCK FOR EACH UNIQUELY ACCESSED FILE ON A
!  VOLUME. THE FILE CONTROL BLOCK PROVIDES THE VEHICLE WHEREBY SHARED
!  ACCESS TO A FILE MAY BE CONTROLLED.
! -
literal FCB$K_LENGTH = 320;             !  LENGTH OF STANDARD FCB 
literal FCB$C_LENGTH = 320;             !  LENGTH OF STANDARD FCB 
literal FCB$S_FCBDEF = 320;             !  Old size name - synonym
literal FCB$S_FCB = 320;
macro FCB$L_FCBFL = 0,0,32,1 %;         !  FCB LIST FORWARD LINK 
macro FCB$L_FCBBL = 4,0,32,1 %;         !  FCB LIST BACKWARD LINK 
macro FCB$W_SIZE = 8,0,16,0 %;          !  SIZE OF FCB IN BYTES 
macro FCB$B_TYPE = 10,0,8,0 %;          !  STRUCTURE TYPE OF FCB 
macro FCB$B_ACCLKMODE = 11,0,8,0 %;     !  Access lock mode.
macro FCB$L_EXFCB = 12,0,32,1 %;        !  ADDRESS OF EXTENSION FCB 
macro FCB$L_WLFL = 16,0,32,1 %;         !  WINDOW LISTHEAD FORWARD LINK 
macro FCB$L_WLBL = 20,0,32,1 %;         !  WINDOW LISTHEAD BACKWARD LINK 
macro FCB$L_REFCNT = 24,0,32,0 %;       !  Total references to this FCB.
macro FCB$L_ACNT = 28,0,32,0 %;         !  FILE ACCESS COUNT 
macro FCB$L_WCNT = 32,0,32,0 %;         !  FILE WRITER COUNT 
macro FCB$L_LCNT = 36,0,32,0 %;         !  FILE LOCK COUNT 
macro FCB$L_TCNT = 40,0,32,0 %;         !  COUNT OF TRUNCATE LOCKS 
macro FCB$L_STATUS = 44,0,32,0 %;       !  FILE STATUS 
macro FCB$V_DIR = 44,0,1,0 %;           !  FCB IS A DIRECTORY LRU ENTRY 
macro FCB$V_MARKDEL = 44,1,1,0 %;       !  FILE IS MARKED FOR DELETE 
macro FCB$V_BADBLK = 44,2,1,0 %;        !  BAD BLOCK ENCOUNTERED IN FILE 
macro FCB$V_EXCL = 44,3,1,0 %;          !  FILE IS EXCLUSIVELY ACCESSED 
macro FCB$V_SPOOL = 44,4,1,0 %;         !  FILE IS AN INTERMEDIATE SPOOL FILE 
macro FCB$V_RMSLOCK = 44,5,1,0 %;       !  FILE IS OPEN WITH RMS RECORD LOCKING 
macro FCB$V_ERASE = 44,6,1,0 %;         !  ERASE DATA WHEN BLOCKS REMOVED FROM FILE
macro FCB$V_BADACL = 44,7,1,0 %;        !  ACL IS CORRUPT
macro FCB$V_STALE = 44,8,1,0 %;         !  Reconstruct FCB from header.
macro FCB$V_DELAYTRNC = 44,9,1,0 %;     !  Delay truncation.
macro FCB$V_LIMBO = 44,10,1,0 %;        !  FCB is linked into the LIMBO queue
macro FCB$V_ISDIR = 44,11,1,0 %;        !  This FCB is a directory FCB
macro FCB$V_NOMOVE = 44,12,1,0 %;       !  This file is NOT to be MOVEFILE'ed
macro FCB$V_SHELVED = 44,13,1,0 %;      !  This file is shelved
macro FCB$V_NOSHELVABLE = 44,14,1,0 %;  !  This file is NOT to be SHELVED'ed
macro FCB$W_FID = 48,0,0,0 %;
literal FCB$S_FID = 6;                  !  FILE IDENTIFICATION 
macro FCB$W_FID_NUM = 48,0,16,0 %;      !  FILE NUMBER 
macro FCB$W_FID_SEQ = 50,0,16,0 %;      !  FILE SEQUENCE NUMBER 
macro FCB$W_FID_RVN = 52,0,16,0 %;      !  RELATIVE VOLUME NUMBER 
macro FCB$B_FID_RVN = 52,0,8,0 %;       !  SHORT FORM RVN 
macro FCB$B_FID_NMX = 53,0,8,0 %;       !  EXTENDED FILE NUMBER 
macro FCB$W_FID_DIRNUM = 48,0,16,0 %;   !       Directory number of File-Id
macro FCB$L_FID_RECNUM = 50,0,32,0 %;   !       Record number of File-ID
macro FCB$W_SEGN = 54,0,16,0 %;         !  FILE SEGMENT NUMBER 
macro FCB$L_STVBN = 56,0,32,0 %;        !  STARTING VIRTUAL BLOCK NUMBER 
macro FCB$L_STLBN = 60,0,32,0 %;        !  STARTING LOGICAL BLOCK NUMBER 
macro FCB$L_HDLBN = 64,0,32,0 %;        !  LBN OF FILE HEADER 
macro FCB$L_FILESIZE = 68,0,32,0 %;     !  FILE SIZE IN BLOCKS 
macro FCB$L_EFBLK = 72,0,32,0 %;        !  END OF FILE VBN 
macro FCB$L_VERSIONS = 76,0,32,0 %;     !  MAXIMUM NUMBER OF VERSIONS IN DIRECTORY 
macro FCB$L_DIRSEQ = 80,0,32,0 %;       !  DIRECTORY USE SEQUENCE NUMBER 
macro FCB$L_DIRINDX = 84,0,32,0 %;      !  Directory index pointer
macro FCB$L_ACCLKID = 88,0,32,0 %;      !  Access lock ID.
macro FCB$L_LOCKBASIS = 92,0,32,0 %;    !  Lock basis for this FCB.
macro FCB$L_TRUNCVBN = 96,0,32,0 %;     !  VBN for delayed truncation. (Files-11 B)
macro FCB$L_NUMEXTENTS = 96,0,32,0 %;   !  Number of extents recorded  (Files-11 C/D)
macro FCB$L_CACHELKID = 100,0,32,0 %;   !  Cache interlock lock ID
macro FCB$L_HIGHWATER = 104,0,32,0 %;   !  HIGH WATER MARK IN FILE
macro FCB$L_NEWHIGHWATER = 108,0,32,0 %; !  Highwater mark of pending writes
macro FCB$L_HWM_UPDATE = 112,0,32,0 %;  !  Count of writes past highwater mark
macro FCB$L_HWM_ERASE = 116,0,32,0 %;   !  Count of writes starting past highwater mark
macro FCB$L_HWM_PARTIAL = 120,0,32,0 %; !  Count of partially validated erase operations
macro FCB$L_REVISION = 124,0,32,0 %;    !  File revision
macro FCB$Q_HWMQHD = 128,0,0,0 %;
literal FCB$S_HWMQHD = 8;               !  High water mark queue header
macro FCB$L_HWM_WAITFL = 128,0,32,1 %;  !  Highwater mark update queue
macro FCB$L_HWM_WAITBL = 132,0,32,1 %;  !  Highwater mark update queue
macro FCB$Q_LIMBOQHD = 128,0,0,0 %;
literal FCB$S_LIMBOQHD = 8;             !  LIMBO queue header
macro FCB$L_LIMBOFL = 128,0,32,1 %;     !  Highwater mark update queue
macro FCB$L_LIMBOBL = 132,0,32,1 %;     !  Highwater mark update queue
! 
!  NOTA BENE:
! 
!   The following is an embedded ORB.  This structure should only be referenced
!   through the FCB$L_ORB pointer (using ORB$ field names).  The existing (FCB)
!   fields are left for source code and binary compatibility in privileged
!   software that thinks it knows what an FCB and its ORB look like.
!   
!   Third-party developers would be well advised to remove all references to
!   these FCB symbols as soon as possible.  You have been warned!
!   
macro FCB$R_ORB = 136,0,0,0 %;
literal FCB$S_ORB = 124;                !  Object's Rights Block
macro FCB$L_FILEOWNER = 136,0,32,0 %;   !  FILE OWNER UIC 
macro FCB$W_UICMEMBER = 136,0,16,0 %;   !  MEMBER NUMBER 
macro FCB$W_UICGROUP = 138,0,16,0 %;    !  GROUP NUMBER 
macro FCB$Q_ACMODE = 152,0,0,0 %;
literal FCB$S_ACMODE = 8;               !  Access mode protection vector
macro FCB$L_SYS_PROT = 160,0,32,0 %;    !  Protection word/vector
macro FCB$W_FILEPROT = 160,0,16,0 %;    !  FILE PROTECTION MASK 
macro FCB$L_OWN_PROT = 164,0,32,0 %;    !  Owner protection
macro FCB$L_GRP_PROT = 168,0,32,0 %;    !  Group protection
macro FCB$L_WOR_PROT = 172,0,32,0 %;    !  World protection
macro FCB$L_ACLFL = 176,0,32,1 %;       !  ACCESS CONTROL LIST FORWARD LINK 
macro FCB$L_ACLBL = 180,0,32,1 %;       !  ACCESS CONTROL LIST BACKWARD LINK 
macro FCB$R_MIN_CLASS_PROT = 184,0,0,0 %;
literal FCB$S_MIN_CLASS_PROT = 20;      !  Minimum security classification mask
macro FCB$R_MAX_CLASS_PROT = 204,0,0,0 %;
literal FCB$S_MAX_CLASS_PROT = 20;      !  Maximum security classification mask
! 
!  We now return you to your regularly scheduled file control block.
! 
macro FCB$L_ORB = 304,0,32,1 %;         !  Address of file ORB
macro FCB$L_CFCB = 308,0,32,1 %;        !  VBN Cache pointer
macro FCB$L_PRIMFCB = 312,0,32,1 %;     !  Pointer to Primary FCB if
!   this is an extension FCB
!   else zero
macro FCB$L_DIRLCKID = 316,0,32,0 %;    !  Support for directory
!  cache invalidation
 
!*** MODULE $FDTDEF ***
! +
!  FDT - FUNCTION DECSION TABEL FOR STEP 2 I/O DEVICE DRIVERS
! 
!  EACH I/O DEVICE DRIVER HAS A FUNCTION DECISION TABLE.
! -
literal FDT$S_FDT = 264;
macro FDT$Q_BUFFERED = 0,0,0,1 %;
literal FDT$S_BUFFERED = 8;             !  64 bit map set for buffered I/O function codes
macro FDT$PS_FUNC_RTN = 8,0,0,1 %;
literal FDT$S_FUNC_RTN = 256;           !  Pointers to upper level FDT routines
literal FDT$K_LENGTH = 264;             !  Length constant
 
!*** MODULE $FDT_CONTEXTDEF ***
! +
!  FDT_CONTEXT - FUNCTION DECISION TABLE CONTEXT STRUCTURE FOR STEP 2 I/O 
!                DEVICE DRIVERS
! 
!  EACH $QIO INVOCATION HAS A FUNCTION DECISION TABLE CONTEXT STRUCTURE
!  THAT IS ALLOCATED ON THE STACK.
! -
literal FDT_CONTEXT$S_FDT_CONTEXT = 16;
macro FDT_CONTEXT$L_QIO_STATUS = 0,0,32,0 %; !  Final $QIO system service status
macro FDT_CONTEXT$L_QIO_R1_VALUE = 4,0,32,1 %; !  VA of faulting page if SS$QIO_CROCK set
macro FDT_CONTEXT$W_SIZE = 8,0,16,0 %;  !  FDT_CONTEXT$K_LENGTH
macro FDT_CONTEXT$B_TYPE = 10,0,8,0 %;  !  DYN$C_MISC
macro FDT_CONTEXT$B_SUBTYPE = 11,0,8,0 %; !  DYN$C_FDT_CONTEXT
!  Pad size to quadword multiple so  
!   EXE$QIO stack is QW aligned. This
!   structure is the first to be
!   allocated on the $QIO stack.
literal FDT_CONTEXT$K_LENGTH = 16;
 
!*** MODULE $FKBDEF ***
! +
!  FKB - FORK BLOCK
! 
!  A FORK BLOCK DESCRIBES THE CONTEXT OF A FORK PROCESS. EACH UNIT CONTROL
!  BLOCK CONTAINS A FORK BLOCK AS ITS FIRST SIX LONGWORDS.
! -
literal FKB$S_FKB = 32;
macro FKB$L_FQFL = 0,0,32,1 %;          ! FORK QUEUE FORWARD LINK 
macro FKB$L_FQBL = 4,0,32,1 %;          ! FORK QUEUE BACKWARD LINK 
macro FKB$W_SIZE = 8,0,16,0 %;          ! SIZE OF FKB IN BYTES 
macro FKB$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE OF FKB 
macro FKB$B_FLCK = 11,0,8,0 %;          ! FORK LOCK NUMBER
macro FKB$L_FPC = 12,0,32,1 %;          ! FORK PC 
macro FKB$Q_FR3 = 16,0,0,1 %;
literal FKB$S_FR3 = 8;                  ! FORK R3 
macro FKB$Q_FR4 = 24,0,0,1 %;
literal FKB$S_FR4 = 8;                  ! FORK R4 
literal FKB$K_LENGTH = 32;              ! STANDARD LENGTH OF FKB 
literal FKB$C_LENGTH = 32;              ! STANDARD LENGTH OF FKB 
literal FKB$S_FKBDEF = 32;              !  Old size name, synonym for FKB$S_FKB
 
!*** MODULE $FQAMDEF ***
! ++
! 	Define FQAM CSR offsets and registers for Firefox systems
! --
literal FQAM$L_CSR = 0;                 ! FQAM II CSR
literal FQAM$M_CSR_QBUSARB = %X'1';
literal FQAM$M_CSR_DUMPERROR = %X'2';
literal FQAM$M_CSR_TESTMODE = %X'4';
literal FQAM$S_CSR = 4;
macro FQAM$V_CSR_QBUSARB = 0,0,1,0 %;   ! QBUS arbitration enable
macro FQAM$V_CSR_DUMPERROR = 0,1,1,0 %; ! Dump error
macro FQAM$V_CSR_TESTMODE = 0,2,1,0 %;  ! Test mode enable diags
 
!*** MODULE $FTRDDEF ***
! +
! 
!  FTRD - Read request packet for FTDRIVER
! 
!  The FTRD packet is very similar to an IRP but much smaller.  It has an 
!  ACB at the front, the EFN, and some information about the read buffer.
! 
! -
literal FTRD$K_LENGTH = 40;             !  Size of read packet
literal FTRD$C_LENGTH = 40;             ! 
literal FTRD$S_FTRDDEF = 40;
literal FTRD$S_FTRD = 40;
macro FTRD$L_ASTQFL = 0,0,32,1 %;       !  Read and AST queue forward link
macro FTRD$L_ASTQBL = 4,0,32,1 %;       !  Read and AST queue backward link
macro FTRD$W_SIZE = 8,0,16,0 %;         !  Size of structure
macro FTRD$B_TYPE = 10,0,8,0 %;         !  Type of structure
macro FTRD$B_RMOD = 11,0,8,0 %;         !  RMOD bits used by AST delivery code
macro FTRD$L_PID = 12,0,32,0 %;         !  Internal PID of process to receive AST
macro FTRD$L_AST = 16,0,32,1 %;         !  AST routine address
macro FTRD$L_ASTPRM = 20,0,32,0 %;      !  AST parameter
macro FTRD$B_EFN = 24,0,8,0 %;          !  EFN to be set
macro FTRD$B_UNUSED = 25,0,8,0 %;       !  Spare byte
macro FTRD$W_READ_SIZE = 26,0,16,0 %;   !  Size of read request in bytes
macro FTRD$L_BUFF_ADDR = 28,0,32,1 %;   !  Address of I/O buffer
macro FTRD$L_CHAR_ADDR = 32,0,32,1 %;   !  Address of next character 
macro FTRD$L_CHARS_READ = 36,0,32,0 %;  !  Number of characters in read buffer
 
!*** MODULE $GSDDEF ***
! +
!  Global Section Descriptor Block
! -
literal GSD$K_LENGTH = 49;              ! LENGTH OF LOCAL MEMORY GSD 
literal GSD$C_LENGTH = 49;              ! LENGTH OF LOCAL MEMORY GSD 
literal GSD$K_EXTGSDLNG = 61;           ! MINIMUM EXTENDED GSD LENGTH 
literal GSD$C_EXTGSDLNG = 61;           ! MINIMUM EXTENDED GSD LENGTH 
literal GSD$S_GSDDEF = 61;
literal GSD$S_GSD = 61;
macro GSD$L_GSDFL = 0,0,32,1 %;         ! POINTER TO NEXT GSD 
macro GSD$L_GSDBL = 4,0,32,1 %;         ! POINTER TO PREVIOUS GSD 
macro GSD$W_SIZE = 8,0,16,0 %;          ! SIZE OF GSD IN BYTES 
macro GSD$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE CODE FOR GSD 
macro GSD$L_HASH = 12,0,32,0 %;         ! HASH FOR GSD NAME
macro GSD$L_PCBUIC = 16,0,32,0 %;       ! UIC OF CREATOR OF SECTION, FROM PCB 
macro GSD$W_PCBGRP = 18,0,16,0 %;       ! GROUP OF CREATOR OF SECTION, FROM PCB 
macro GSD$L_FILUIC = 20,0,32,0 %;       ! OWNER OF FILE, UIC FROM FCB 
macro GSD$L_PROT = 24,0,32,0 %;         ! PROTECTION MASK 
macro GSD$L_GSTX = 28,0,32,0 %;         ! GLOBAL SECTION TABLE INDEX 
macro GSD$L_IDENT = 32,0,32,0 %;        ! IDENTIFICATION OF GLOBAL SECTION 
macro GSD$L_ORB = 36,0,32,1 %;          ! OBJECT RIGHTS BLOCK LOCATOR
macro GSD$L_IPID = 40,0,32,0 %;         ! IPID of nominal owner -- only defined while GSD is being deleted 
macro GSD$L_FLAGS = 44,0,32,0 %;        ! SECTION FLAGS 
macro GSD$T_GSDNAM = 48,0,8,0 %;        ! LOCAL MEMORY SECTION NAME
! 
!  The following fields are only found in extended GSDs. These are used
!  whenever a GSD is needed without a section table entry, i.e., for pages
!  mapped by PFN.
! 
macro GSD$L_BASEPFN = 48,0,32,1 %;      ! FIRST RELATIVE BASE PFN
macro GSD$L_PAGES = 52,0,32,0 %;        ! COUNT OF PAGES AT FIRST BASE PFN 
macro GSD$L_REFCNT = 56,0,32,0 %;       ! FIRST PROCESSOR PTE REF COUNT 
macro GSD$T_PFNGSDNAM = 60,0,8,0 %;     ! PFN-MAPPED SECTION NAME
 
!*** MODULE $HD1DEF ***
! +
!  HDR1 ANDSI MAGNETIC TAPE LABEL
!  THIS IS THE FIRST LABEL IN THE FILE LABEL HEADER SET.  IF IDENTIFIES THE FILE.
! -
literal HD1$S_HD1DEF = 80;
literal HD1$S_HD1 = 80;
macro HD1$L_HD1LID = 0,0,32,0 %;        ! LABEL IDENTIFIER AND NUMBER 'HDR1' 
macro HD1$T_FILEID = 4,0,0,0 %;
literal HD1$S_FILEID = 17;              ! FILE IDENTIFIER 
macro HD1$T_FILESETID = 21,0,0,0 %;
literal HD1$S_FILESETID = 6;            ! FILE SET IDENTIFIER 
macro HD1$T_FILESECNO = 27,0,32,0 %;
literal HD1$S_FILESECNO = 4;            ! FILE SECTION NUMBER 
macro HD1$T_FILESEQNO = 31,0,32,0 %;
literal HD1$S_FILESEQNO = 4;            ! FILE SEQUENCE NUMBER 
macro HD1$T_GENNO = 35,0,32,0 %;
literal HD1$S_GENNO = 4;                ! FILE GENERATION NUMBER 
macro HD1$T_GENVER = 39,0,16,0 %;
literal HD1$S_GENVER = 2;               ! FILE GENERATION VERSION NUMBER 
macro HD1$T_CREATEDT = 41,0,0,0 %;
literal HD1$S_CREATEDT = 6;             ! CREATION DATE ( YYDDD) 
macro HD1$T_EXPIREDT = 47,0,0,0 %;
literal HD1$S_EXPIREDT = 6;             ! EXPIRATION DATE 
macro HD1$B_FILACCESS = 53,0,8,0 %;     ! FILE ACCESS 
macro HD1$T_BLOCKCNT = 54,0,0,0 %;
literal HD1$S_BLOCKCNT = 6;             ! BLOCK COUNT 
macro HD1$T_SYSCODE = 60,0,0,0 %;
literal HD1$S_SYSCODE = 13;             ! SYSTEM CODE 
 
!*** MODULE $HD2DEF ***
! +
!  HDR2 ANSI MAGNETIC TAPE LABEL
!  THIS IS THE SECOND LABEL IN FILE LABEL HEADER SET.
!  THE FILE ATTRIBUTES HAVE BEEN REMOVED FROM HDR2, AND PLACED IN HDR3.
!  THE FIELDS REMAIN IN THE DEFINITION TO SUPPORT OLD TAPES.
! -
literal HD2$S_HD2DEF = 72;
literal HD2$S_HD2 = 72;
macro HD2$L_HD2LID = 0,0,32,0 %;        ! LABEL IDENTIFIER AND NUMBER 'HDR2' 
macro HD2$B_RECFORMAT = 4,0,8,0 %;      ! RECORD FORMAT 
macro HD2$T_BLOCKLEN = 5,0,0,0 %;
literal HD2$S_BLOCKLEN = 5;             ! BLOCK LENGTH 
macro HD2$T_RECLEN = 10,0,0,0 %;
literal HD2$S_RECLEN = 5;               ! RECORD LENGTH 
macro HD2$T_RECATR1 = 15,0,0,0 %;
literal HD2$S_RECATR1 = 20;             ! FIRST 20 BYTES OF FILES-11 RECORD ATTRIBUTES 
macro HD2$B_FORMCNTRL = 36,0,8,0 %;     ! FORMS CONTROL 
macro HD2$T_RECATR2 = 37,0,0,0 %;
literal HD2$S_RECATR2 = 12;             ! LAST 12 BYTES OF FILES-11 RECORD ATTRIBUTES 
macro HD2$T_BUFOFF = 50,0,16,0 %;
literal HD2$S_BUFOFF = 2;               ! BUFFER OFFSET 
 
!*** MODULE $HD3DEF ***
! +
!  HDR3 ANSI MAGNETIC TAPE LABEL
!  THIS IS THE THIRD LABEL IN FILE LABEL HEADER SET.
!  IT IDENTIFIES THE FILE ATTRIBUTES.
! -
literal HD3$S_HD3DEF = 80;
literal HD3$S_HD3 = 80;
macro HD3$L_HD3LID = 0,0,32,0 %;        ! LABEL IDENTIFIES AND NUMBER 'HDR3' 
macro HD3$T_RECATR = 4,0,0,0 %;
literal HD3$S_RECATR = 64;              ! 64 BYTES OF FILES-11 RECORD ATTRIBUTES 
 
!*** MODULE $HD4DEF ***
! +
!  HDR4 ANSI MAGNETIC TAPE LABEL
!  THIS IS THE FOURTH LABEL IN FILE LABEL HEADER SET.
!  IT CONTAINS THE LONG FILENAME EXTENSION TO THE HDR1 FILE IDENTIFIER
!  FOR VMS LONG FILE NAMES
! -
literal HD4$S_HD4DEF = 82;
literal HD4$S_HD4 = 82;
macro HD4$L_HD4LID = 0,0,32,0 %;        ! LABEL IDENTIFIER AND NUMBER 'HDR4' 
macro HD4$B_FILEID_EXT_SIZE = 4,0,8,0 %; ! SIZE OF FILE ID EXT FOR ANSI 4 VOLUMES
macro HD4$T_FILEID_EXT = 5,0,0,0 %;
literal HD4$S_FILEID_EXT = 62;          ! EXTENSION OF HDR1 FILEID
macro HD4$T_FILEID_EXT_V3 = 67,0,16,0 %;
literal HD4$S_FILEID_EXT_V3 = 2;        ! SIZE OF FILE ID EXT FOR ANSI 3 VOLUMES
 
!*** MODULE $HPCDEF ***
literal HPC$S_HPC = 6168;
macro HPC$b_f00 = 0,0,0,0 %;
literal HPC$s_f00 = 24;
macro HPC$L_CTL = 24,0,32,0 %;
macro HPC$b_f10 = 28,0,0,0 %;
literal HPC$s_f10 = 124;
macro HPC$L_MRETRY = 152,0,32,0 %;
macro HPC$b_f20 = 156,0,0,0 %;
literal HPC$s_f20 = 124;
macro HPC$L_GPR = 280,0,32,0 %;
macro HPC$b_f30 = 284,0,0,0 %;
literal HPC$s_f30 = 124;
macro HPC$L_ERR = 408,0,32,0 %;
macro HPC$b_f40 = 412,0,0,0 %;
literal HPC$s_f40 = 124;
macro HPC$L_FADR = 536,0,32,0 %;
macro HPC$b_f50 = 540,0,0,0 %;
literal HPC$s_f50 = 124;
macro HPC$L_IMASK = 664,0,32,0 %;
macro HPC$b_f60 = 668,0,0,0 %;
literal HPC$s_f60 = 124;
macro HPC$L_DIAG = 792,0,32,0 %;
macro HPC$b_f70 = 796,0,0,0 %;
literal HPC$s_f70 = 124;
macro HPC$L_IPEND = 920,0,32,0 %;
macro HPC$b_f80 = 924,0,0,0 %;
literal HPC$s_f80 = 124;
macro HPC$L_IPROG = 1048,0,32,0 %;
macro HPC$b_f90 = 1052,0,0,0 %;
literal HPC$s_f90 = 124;
macro HPC$L_WMASK_A = 1176,0,32,0 %;
macro HPC$b_f100 = 1180,0,0,0 %;
literal HPC$s_f100 = 124;
macro HPC$L_WBASE_A = 1304,0,32,0 %;
macro HPC$b_f110 = 1308,0,0,0 %;
literal HPC$s_f110 = 124;
macro HPC$L_TBASE_A = 1432,0,32,0 %;
macro HPC$b_f120 = 1436,0,0,0 %;
literal HPC$s_f120 = 124;
macro HPC$L_WMASK_B = 1560,0,32,0 %;
macro HPC$b_f130 = 1564,0,0,0 %;
literal HPC$s_f130 = 124;
macro HPC$L_WBASE_B = 1688,0,32,0 %;
macro HPC$b_f140 = 1692,0,0,0 %;
literal HPC$s_f140 = 124;
macro HPC$L_TBASE_B = 1816,0,32,0 %;
macro HPC$b_f150 = 1820,0,0,0 %;
literal HPC$s_f150 = 124;
macro HPC$L_WMASK_C = 1944,0,32,0 %;
macro HPC$b_f160 = 1948,0,0,0 %;
literal HPC$s_f160 = 124;
macro HPC$L_WBASE_C = 2072,0,32,0 %;
macro HPC$b_f170 = 2076,0,0,0 %;
literal HPC$s_f170 = 124;
macro HPC$L_TBASE_C = 2200,0,32,0 %;
macro HPC$b_f180 = 2204,0,0,0 %;
literal HPC$s_f180 = 124;
macro HPC$L_ERRVEC = 2328,0,32,0 %;
macro HPC$b_f190 = 2332,0,0,0 %;
literal HPC$s_f190 = 1788;
macro HPC$L_D_INTA = 4120,0,32,0 %;
macro HPC$L_D_INT_FILL1 = 4124,0,0,0 %;
literal HPC$S_D_INT_FILL1 = 124;
macro HPC$L_D_INTB = 4248,0,32,0 %;
macro HPC$L_D_INT_FILL2 = 4252,0,0,0 %;
literal HPC$S_D_INT_FILL2 = 124;
macro HPC$L_D_INTC = 4376,0,32,0 %;
macro HPC$L_D_INT_FILL3 = 4380,0,0,0 %;
literal HPC$S_D_INT_FILL3 = 124;
macro HPC$L_D_INTD = 4504,0,32,0 %;
macro HPC$L_D_INT_FILL4 = 4508,0,0,0 %;
literal HPC$S_D_INT_FILL4 = 124;
literal IACK$S_IACK = 32;
macro IACK$b_f210 = 0,0,0,0 %;
literal IACK$s_f210 = 24;
macro IACK$L_IACK = 24,0,32,0 %;
literal HPC$S_HPC_CTL = 8;
macro HPC$L_REG_CTL = 0,0,32,0 %;
macro HPC$V_CONFIG_CYCLE_TYPE = 0,0,2,0 %;
literal HPC$S_CONFIG_CYCLE_TYPE = 2;
macro HPC$V_MEMORY_BLOCK_SIZE = 0,2,1,0 %;
macro HPC$V_PCI_RESET = 0,3,1,0 %;
macro HPC$V_PCI_CT_THRESHOLD = 0,4,4,0 %;
literal HPC$S_PCI_CT_THRESHOLD = 4;
macro HPC$V_PCI_CT_ENABLE = 0,8,1,0 %;
macro HPC$V_IO_HAE = 0,9,5,0 %;
literal HPC$S_IO_HAE = 5;
macro HPC$V_MEMORY_HAE = 0,14,5,0 %;
literal HPC$S_MEMORY_HAE = 5;
macro HPC$V_HAE_DISABLE = 0,19,1,0 %;
macro HPC$V_MRM_ARB = 0,20,1,0 %;
macro HPC$V_MRM_ENABLE = 0,21,1,0 %;
macro HPC$V_MRM_PREFETCH_SIZE = 0,22,1,0 %;
macro HPC$V_IO_UPHOSE_BUFF = 0,23,2,0 %;
literal HPC$S_IO_UPHOSE_BUFF = 2;
macro HPC$V_SGM_RAM_SIZE = 0,25,2,0 %;
literal HPC$S_SGM_RAM_SIZE = 2;
macro HPC$V_PCI_ARB_CONTROL = 0,27,2,0 %;
literal HPC$S_PCI_ARB_CONTROL = 2;
literal HPC$S_HPC_IMASK = 8;
macro HPC$L_REG_IMASK = 0,0,32,0 %;
macro HPC$W_INT = 0,0,16,0 %;
macro HPC$V_ENABLE_ERRINT = 0,16,1,0 %;
macro HPC$V_DEVICE_PRIORITY = 0,17,4,0 %;
literal HPC$S_DEVICE_PRIORITY = 4;
macro HPC$V_ERROR_PRIORITY = 0,21,4,0 %;
literal HPC$S_ERROR_PRIORITY = 4;
macro HPC$V_MBZ = 0,25,7,0 %;
literal HPC$S_MBZ = 7;
 
!*** MODULE $HQBDEF ***
! +
!  HQB  (Host Queue Block)  Definitions
! 
! 	This data structure contains information pertaining
! 	to a host that has established a connection to the 
! 	server.
! -
literal HQB$M_VC_FAILED = %X'1';
literal HQB$M_DISCON_INIT = %X'2';
literal HQB$M_PATHMOVE = %X'4';
literal HQB$M_UNIT_ONLINE = %X'1';
literal HQB$M_V5CL = %X'2';
literal HQB$K_LENGTH = 72;
literal HQB$S_HQBDEF = 72;
literal HQB$S_HQB = 72;
macro HQB$L_FLINK = 0,0,32,1 %;         !  Used to link together all
macro HQB$L_BLINK = 4,0,32,1 %;         !    host HQBs using the server
macro HQB$W_SIZE = 8,0,16,0 %;          !  Structure size in bytes
macro HQB$B_TYPE = 10,0,8,0 %;          !  MSCP type structure
macro HQB$B_SUBTYPE = 11,0,8,0 %;       !   with a HQB subtype 	     (2)
macro HQB$B_HOSTNO = 12,0,8,0 %;        !  Assigned host number
macro HQB$B_STATE = 13,0,8,0 %;         !  State of this host
macro HQB$V_VC_FAILED = 13,0,1,0 %;     !   The VC to this host has failed
macro HQB$V_DISCON_INIT = 13,1,1,0 %;   !   Disconnect being processed
macro HQB$V_PATHMOVE = 13,2,1,0 %;      !   Closing connection for port load balancing
macro HQB$W_CNT_FLGS = 14,0,16,0 %;     !  Host settable controller flags
macro HQB$W_HTIMO = 16,0,16,0 %;        !  Host access timeout interval
macro HQB$W_FLAGS = 18,0,16,0 %;
macro HQB$V_UNIT_ONLINE = 18,0,1,0 %;   !  This host had units online
macro HQB$V_V5CL = 18,1,1,0 %;          !  This is the V5 class driver
!   when the link was broken
macro HQB$Q_TIME = 20,0,0,0 %;
literal HQB$S_TIME = 8;                 !  Time host issued set-ctrl-chr
macro HQB$W_NUM_QUE = 28,0,16,0 %;      !  Requests outstanding
macro HQB$W_MAX_QUE = 30,0,16,0 %;      !  Most requests ever out
macro HQB$L_HRB_FL = 32,0,32,1 %;       !  HRB queue listhead for 
macro HQB$L_HRB_BL = 36,0,32,1 %;       !   this host
macro HQB$L_CDT = 40,0,32,1 %;          !  Connection Desc Table addr
macro HQB$L_DSRV = 44,0,32,1 %;         !  DSRV address
macro HQB$B_SYSTEMID = 48,0,0,0 %;
literal HQB$S_SYSTEMID = 6;             !  SCS system ID of host
macro HQB$W_MAX_HULB = 54,0,16,0 %;     !  Size of HULB vector
macro HQB$L_HULB_VECTOR = 56,0,32,1 %;  !  HULB vector address
macro HQB$L_TSRV = 60,0,32,1 %;         !  TSRV address
macro HQB$L_ACK_TIME = 64,0,32,0 %;     !  Time stamp form last remote request
macro HQB$L_ARR_TIME = 68,0,32,0 %;     !  Round trip time from server to host
 
!*** MODULE $HRBDEF ***
! +
!  HRB  (Host Request Block)  Definitions
! 
! 	These definitions describe the format of a data structure
! 	that is used in the MSCP server to represent the context
! 	of a request from one of the served hosts.
! -
literal HRB$M_STATE_INVALID = %X'8000';
literal HRB$M_ABORT = %X'1';
literal HRB$M_ABORTWS = %X'2';
literal HRB$M_DEQUEUED = %X'4';
literal HRB$M_ENDMSG = %X'8';
literal HRB$M_MAP = %X'10';
literal HRB$M_UNBLOCK = %X'20';
literal HRB$M_VCFAILED = %X'40';
literal HRB$M_OLDBUF = %X'80';
literal HRB$M_WBC_IMMED = %X'100';
literal HRB$M_FIRST = %X'200';
literal HRB$M_FLUSH = %X'400';
literal HRB$K_LENGTH = 136;
!  request state definitions
literal HRB$K_ST_MSG_WAIT = 1;          !  Atn msg buffer/credit wait
literal HRB$K_ST_SEQ_WAIT = 2;          !  Waiting for sequential cmd
literal HRB$K_ST_BUF_WAIT = 3;          !  Waiting for server buffer
literal HRB$K_ST_SNDAT_WAIT = 4;        !  Sending or receiving data
literal HRB$K_ST_DRV_WAIT = 5;          !  Driver queue
literal HRB$K_ST_MAP_WAIT = 6;          !  Mapping a data buffer
literal HRB$K_ST_UNMAP_WAIT = 7;        !  Returning mapping resources
literal HRB$K_ST_SNDMS_WAIT = 8;        !  Sending message
literal HRB$K_ST_MEM_WAIT = 9;          !  Local buffer wait
literal HRB$K_ST_FLUSHED = 10;          !  Flushed from cache
literal HRB$K_ST_CACHED = 11;           !  In local host cache
literal HRB$S_HRBDEF = 136;             !  Old size name - synonym
literal HRB$S_HRB = 136;
macro HRB$L_FLINK = 0,0,32,1 %;         !  Used to link this request
macro HRB$L_BLINK = 4,0,32,1 %;         !   into the HQB data styructure
macro HRB$W_SIZE = 8,0,16,0 %;          !  Data structure size in bytes
macro HRB$B_TYPE = 10,0,8,0 %;          !  This is an MSCP type struct
macro HRB$B_SUBTYPE = 11,0,8,0 %;       !   with a HRB subtype       (3)
macro HRB$L_RESPC = 12,0,32,1 %;        !  PC to resume on restart
macro HRB$L_SAVD_RTN = 16,0,32,1 %;     !  Saved address of caller
macro HRB$W_STATE = 20,0,16,0 %;        !  State of the request
macro HRB$V_STATE_INVALID = 20,15,1,0 %; !  State is current but previous
!   state was (bits 0-15)
macro HRB$W_FLAGS = 22,0,16,0 %;        !  Status flags
macro HRB$V_ABORT = 22,0,1,0 %;         !  Abort
macro HRB$V_ABORTWS = 22,1,1,0 %;       !  Abort with status
macro HRB$V_DEQUEUED = 22,2,1,0 %;      !  Removed from resource queues
macro HRB$V_ENDMSG = 22,3,1,0 %;        !  End message needs to be sent
macro HRB$V_MAP = 22,4,1,0 %;           !  Map resources allocated
macro HRB$V_UNBLOCK = 22,5,1,0 %;       !  Unblock needs to be called
macro HRB$V_VCFAILED = 22,6,1,0 %;      !  The VC for this host failed
macro HRB$V_OLDBUF = 22,7,1,0 %;        !  The buffer allocated for this
!   rqst is out of the old buffer
macro HRB$V_WBC_IMMED = 22,8,1,0 %;     !  Write-back caching command
macro HRB$V_FIRST = 22,9,1,0 %;         !  First in burst sequence for tapes
macro HRB$V_FLUSH = 22,10,1,0 %;        !  This is a flush type command
macro HRB$L_MSGBUF = 24,0,32,1 %;       !  Addr of MSCP request packet
macro HRB$L_IRP_CDRP = 28,0,32,1 %;     !  CDRP for I/O requests
macro HRB$B_LBUFF = 32,0,0,0 %;
literal HRB$S_LBUFF = 12;               !  Local buffer descriptor
macro HRB$L_BD_ADDR = 44,0,32,1 %;      !  Buffer Descriptor Address
macro HRB$L_BUFLEN = 48,0,32,0 %;       !  Length of buffer allocated
macro HRB$L_BUFADR = 52,0,32,1 %;       !  Buffer starting address
macro HRB$L_LBN = 56,0,32,0 %;          !  LBN place holder for xfr
macro HRB$L_OBCNT = 60,0,32,0 %;        !  Original request byte count
macro HRB$L_ABCNT = 64,0,32,0 %;        !  Number of bytes already sent
macro HRB$L_SVAPTE = 68,0,32,0 %;       !  Page table entry for lcl bufr
macro HRB$L_BCNT = 72,0,32,0 %;         !  Temp storage for current xfr
macro HRB$W_BOFF = 76,0,16,0 %;         !  Offset within page of sob
macro HRB$L_WAIT_FL = 80,0,32,1 %;      !  Pointers to link HRB into
macro HRB$L_WAIT_BL = 84,0,32,1 %;      !   wait queues in UQB
macro HRB$L_HQB = 88,0,32,1 %;          !  Host Queue Block address
macro HRB$L_UQB = 92,0,32,1 %;          !  Unit Queue Block address
macro HRB$L_PDT = 96,0,32,1 %;          !  Port Desc Table for requestor
macro HRB$L_CMD_STS = 100,0,32,0 %;     !  Measure of work to be done
macro HRB$L_OBJECT_SKIP = 104,0,32,0 %; !  Objects requested for skipfile
macro HRB$L_CURRENT_SKIP = 108,0,32,0 %; !  Placemarker during REPOS
macro HRB$L_IO_TIME = 112,0,32,0 %;     !  Time for I/O to go from
!   server to tape and back
macro HRB$L_CACHE_FL = 116,0,32,1 %;    !  Cache queue
macro HRB$L_CACHE_BL = 120,0,32,1 %;    ! 
macro HRB$L_MEMW_FL = 124,0,32,1 %;     !  Waiting on more memory
macro HRB$L_MEMW_BL = 128,0,32,1 %;     ! 
macro HRB$L_RECORD = 132,0,32,0 %;      !  Record position on tape
 
!*** MODULE $HULBDEF ***
! +
!  HULB  (Host/Unit Load Block) Definitions
! 
! 	These definitions describe the format of a data structure
! 	that is used in the MSCP server to record traffic and status
! 	information used by server load balancing. Time fields are in
! 	EXE$GL_ABSTIM format.
! -
literal HULB$M_LB_REQ = %X'1';
literal HULB$M_DELETE = %X'2';
literal HULB$M_LB_DISABLED = %X'4';
literal HULB$K_LENGTH = 28;
literal HULB$K_VECLEN = 256;
literal HULB$S_HULBDEF = 28;
literal HULB$S_HULB = 28;
macro HULB$L_FLINK = 0,0,32,1 %;        !  Used to link this request
macro HULB$L_BLINK = 4,0,32,1 %;        !   into the DSRV data styructure
macro HULB$W_SIZE = 8,0,16,0 %;         !  Data structure size in bytes
macro HULB$B_TYPE = 10,0,8,0 %;         !  This is an MSCP type struct
macro HULB$B_SUBTYPE = 11,0,8,0 %;      !   with a HULB subtype (4)
macro HULB$W_HOSTNO = 12,0,16,0 %;      !  Assigned host number
macro HULB$W_UNITNO = 14,0,16,0 %;      !  Assigned unit number
macro HULB$W_OPCOUNT = 16,0,16,0 %;     !  Current operation count
macro HULB$W_PREV_OPC = 18,0,16,0 %;    !  Operation count for prev interval
macro HULB$L_TIME = 20,0,32,0 %;        !  Time of last LB request
macro HULB$W_STATUS = 24,0,16,0 %;      !  LB status bits
macro HULB$V_LB_REQ = 24,0,1,0 %;       !  This unit has been asked to LB
macro HULB$V_DELETE = 24,1,1,0 %;       !  This unit is offline and the HULB can be deleted
macro HULB$V_LB_DISABLED = 24,2,1,0 %;  !  This unit is not available for load balancing
 
!*** MODULE $HWPRTDEF ***
! +
!  Protection field definitions. These encodings are specific
!  to the Alpha architecture and should only be used for
!  privileged interfaces.
! -
literal HWPRT$C_NA = 0;                 !  No Access
literal HWPRT$C_KR = 1;                 !  Kernel Read only
literal HWPRT$C_KW = 17;                !  Kernel Write
literal HWPRT$C_ER = 3;                 !  Exec Read only
literal HWPRT$C_EW = 51;                !  Exec Write
literal HWPRT$C_SR = 7;                 !  Super Read only
literal HWPRT$C_SW = 119;               !  Super Write
literal HWPRT$C_UR = 15;                !  User Read only
literal HWPRT$C_UW = 255;               !  User Write
literal HWPRT$C_ERKW = 19;              !  Exec Read Kernel Write
literal HWPRT$C_SRKW = 23;              !  Super Read Kernel Write
literal HWPRT$C_SREW = 55;              !  Super Read Exec Write
literal HWPRT$C_URKW = 31;              !  User Read Kernel Write
literal HWPRT$C_UREW = 63;              !  User Read Exec Write
literal HWPRT$C_URSW = 127;             !  User Read Super Write
 
!*** MODULE $HWRPBDEF ***
literal EXE$K_SECBOOT = 0;              !  Address of secondary boot
literal EXE$K_HWRPB = 268435456;        !  Address of HWRPB = 256Mb
literal EXE$K_PRIMBOOT = 536870912;     !  Address of primary bootstrap
literal EXE$K_NETBOOT = 805306368;      !  Address of network bootstrap
literal EXE$K_DEBUGBOOT = 939524096;    !  Address of debug bootstrap
literal EXE$K_BOOTPT = 1073741824;      !  Fixed addr. of page tbl =1Gb 
literal HWRPB_SYSTYPE$K_ADU = 1;        !  Alpha Demonstation Unit-proto
literal HWRPB_SYSTYPE$K_COBRA = 2;      !  Similar to MicroVAX
literal HWRPB_SYSTYPE$K_LASER = 3;      !  Similar to Calypso
literal HWRPB_SYSTYPE$K_FLAMINGO = 4;   !  Similar to PV2 workstation
literal HWRPB_SYSTYPE$K_MANNEQUIN = 5;  !  Manniquin simulator
literal HWRPB_SYSTYPE$K_JENSEN = 6;     !  EISA PC/Server
literal HWRPB_SYSTYPE$K_PELICAN = 7;    !  Turbochannel workstation
literal HWRPB_SYSTYPE$K_MORGAN = 8;     !  PCI based system
literal HWRPB_SYSTYPE$K_SABLE = 9;      !  PCI server follow-on to Cobra
literal HWRPB_SYSTYPE$K_MEDULLA = 10;   !  Single board computer
literal HWRPB_SYSTYPE$K_WHITEGABLES = 11; !  Single board computer
literal HWRPB_SYSTYPE$K_TURBOLASER = 12; !  Next generation laser
literal HWRPB_SYSTYPE$K_AVANTI = 13;    !  PCI-ISA EV4
literal HWRPB_SYSTYPE$K_MUSTANG = 14;   !  PCI-ISA LCA
literal HWRPB_SYSTYPE$K_ALCOR = 15;     !  EV5,PCI workstation
literal HWRPB_SYSTYPE$K_TRADEWIND = 16; !  EV4 based system
literal HWRPB_SYSTYPE$K_MIKASA = 17;    !  PCI-EISA EV4 based server
literal HWRPB_SYSTYPE$K_EB64 = 18;      !  EV4 single-board system	
literal HWRPB_SYSTYPE$K_EB66 = 19;      !  LCA Single-board system
literal HWRPB_SYSTYPE$K_EB64P = 20;     !  Enhanced single-board system
literal HWRPB_SYSTYPE$K_BURNS = 21;     !  LCA Laptop system
literal HWRPB_SYSTYPE$K_RAWHIDE = 22;   !  EV5 Based SMP Server
literal HWRPB_SYSTYPE$K_K2 = 23;        !  EV45 PCI/ISA SBC
literal HWRPB_SYSTYPE$K_MAX_SYSTYPE = 23;
literal HWRPB$M_MPCAP = %X'1';
literal HWRPB$M_CNSLE = %X'2';
literal HWRPB$M_PWRFL = %X'20';
literal HWRPB$M_PWRFL_RESTART = %X'100';
literal HWRPB$M_GRAPHICS = %X'200';
literal HWRPB$M_BIGCONFIG = %X'400';
literal HWRPB$C_LENGTH = 320;           !  Length of HWRPB
literal HWRPB$K_LENGTH = 320;           !  Length of HWRPB
literal HWRPB$S_HWRPBDEF = 320;         !  Old size name - synonym
literal HWRPB$S_HWRPB = 320;
macro HWRPB$PQ_BASE = 0,0,0,1 %;
literal HWRPB$S_BASE = 8;               !  Physical address of HWRPB
macro HWRPB$PL_BASE_L = 0,0,32,1 %;
macro HWRPB$L_BASE_H = 4,0,32,1 %;
macro HWRPB$IQ_IDENT = 8,0,0,0 %;
literal HWRPB$S_IDENT = 8;              !  Contains ASCIZ "HWRPB"
macro HWRPB$IL_IDENT_L = 8,0,32,0 %;
macro HWRPB$IL_IDENT_H = 12,0,32,0 %;
macro HWRPB$IQ_REVISION = 16,0,0,0 %;
literal HWRPB$S_REVISION = 8;           !  HWRPB revision number
macro HWRPB$IL_REVISION_L = 16,0,32,0 %;
macro HWRPB$IL_REVISION_H = 20,0,32,0 %;
macro HWRPB$IQ_SIZE = 24,0,0,0 %;
literal HWRPB$S_SIZE = 8;               !  HWRPB Size
macro HWRPB$IL_SIZE_L = 24,0,32,0 %;
macro HWRPB$IL_SIZE_H = 28,0,32,0 %;
macro HWRPB$IQ_PRIMARY = 32,0,0,0 %;
literal HWRPB$S_PRIMARY = 8;            !  Primary CPU ID
macro HWRPB$IL_PRIMARY_L = 32,0,32,0 %;
macro HWRPB$IL_PRIMARY_H = 36,0,32,0 %;
macro HWRPB$IQ_PAGESIZE = 40,0,0,0 %;
literal HWRPB$S_PAGESIZE = 8;           !  Page size in bytes
macro HWRPB$IL_PAGESIZE_L = 40,0,32,0 %;
macro HWRPB$IL_PAGESIZE_H = 44,0,32,0 %;
macro HWRPB$IQ_PA_SIZE = 48,0,0,0 %;
literal HWRPB$S_PA_SIZE = 8;            !  Number of Phys. addr. bits
macro HWRPB$IL_PA_SIZE_L = 48,0,32,0 %;
macro HWRPB$IL_PA_SIZE_H = 52,0,32,0 %;
macro HWRPB$IQ_ASN_MAX = 56,0,0,0 %;
literal HWRPB$S_ASN_MAX = 8;            !  Maximum ASN
macro HWRPB$IL_ASN_MAX_L = 56,0,32,0 %;
macro HWRPB$IL_ASN_MAX_H = 60,0,32,0 %;
! ** Revision info still TBD by the FMA
macro HWRPB$B_SYS_SERIALNUM = 64,0,0,0 %;
literal HWRPB$S_SYS_SERIALNUM = 16;     !  System Serial number
macro HWRPB$IQ_SYSTYPE = 80,0,0,0 %;
literal HWRPB$S_SYSTYPE = 8;            !  System type
macro HWRPB$IL_SYSTYPE_L = 80,0,32,0 %;
macro HWRPB$IL_SYSTYPE_H = 84,0,32,0 %;
macro HWRPB$IQ_SYSVAR = 88,0,0,0 %;
literal HWRPB$S_SYSVAR = 8;             !  System variation
macro HWRPB$IL_SYSVAR_L = 88,0,32,0 %;
macro HWRPB$V_MPCAP = 88,0,1,0 %;       !  Capable of Multi-Processors
macro HWRPB$V_CNSLE = 88,1,1,0 %;
literal HWRPB$S_CNSLE = 4;              !  Console Type
macro HWRPB$V_PWRFL = 88,5,1,0 %;
literal HWRPB$S_PWRFL = 3;              !  Powerfail Type
macro HWRPB$V_PWRFL_RESTART = 88,8,1,0 %; !  Powerfail Restart
macro HWRPB$V_GRAPHICS = 88,9,1,0 %;    !  Imbedded graphics processor
macro HWRPB$V_BIGCONFIG = 88,10,1,0 %;  !  Blazer (vs. Laser)
macro HWRPB$IL_SYSVAR_H = 92,0,32,0 %;
macro HWRPB$IQ_SYSREV = 96,0,0,0 %;
literal HWRPB$S_SYSREV = 8;             !  System revision
macro HWRPB$IL_SYSREV_L = 96,0,32,0 %;
macro HWRPB$IL_SYSREV_H = 100,0,32,0 %;
macro HWRPB$IQ_CLOCK_INT_FREQ = 104,0,0,0 %;
literal HWRPB$S_CLOCK_INT_FREQ = 8;     !  Clock interrupt frequency
macro HWRPB$IL_CLOCK_INT_FREQ_L = 104,0,32,0 %;
macro HWRPB$IL_CLOCK_INT_FREQ_H = 108,0,32,0 %;
macro HWRPB$IQ_CYCLE_COUNT_FREQ = 112,0,0,0 %;
literal HWRPB$S_CYCLE_COUNT_FREQ = 8;   !  Cycle counter frequency
macro HWRPB$IL_CYCLE_COUNT_FREQ_L = 112,0,32,0 %;
macro HWRPB$IL_CYCLE_COUNT_FREQ_H = 116,0,32,0 %;
macro HWRPB$IQ_VPTB = 120,0,0,0 %;
literal HWRPB$S_VPTB = 8;               !  Virtual Page Table Base
macro HWRPB$IL_VPTB_L = 120,0,32,0 %;
macro HWRPB$IL_VPTB_H = 124,0,32,0 %;
macro HWRPB$IQ_TB_HINT_OFFSET = 136,0,0,0 %;
literal HWRPB$S_TB_HINT_OFFSET = 8;     !  TB Hint Offset
macro HWRPB$IL_TB_HINT_OFFSET_L = 136,0,32,0 %;
macro HWRPB$IL_TB_HINT_OFFSET_H = 140,0,32,0 %;
macro HWRPB$IQ_NPROC = 144,0,0,0 %;
literal HWRPB$S_NPROC = 8;              !  Number of Per-CPU slots
macro HWRPB$IL_NPROC_L = 144,0,32,0 %;
macro HWRPB$IL_NPROC_H = 148,0,32,0 %;
macro HWRPB$IQ_SLOT_SIZE = 152,0,0,0 %;
literal HWRPB$S_SLOT_SIZE = 8;          !  Size of Per-CPU slots
macro HWRPB$IL_SLOT_SIZE_L = 152,0,32,0 %;
macro HWRPB$IL_SLOT_SIZE_H = 156,0,32,0 %;
macro HWRPB$IQ_SLOT_OFFSET = 160,0,0,0 %;
literal HWRPB$S_SLOT_OFFSET = 8;        !  Offset to Per-CPU slots
macro HWRPB$IL_SLOT_OFFSET_L = 160,0,32,0 %;
macro HWRPB$IL_SLOT_OFFSET_H = 164,0,32,0 %;
macro HWRPB$IQ_CTB_QUANTITY = 168,0,0,0 %;
literal HWRPB$S_CTB_QUANTITY = 8;       !  Number of CTB's
macro HWRPB$IL_CTB_QUANTITY_L = 168,0,32,0 %;
macro HWRPB$IL_CTB_QUANTITY_H = 172,0,32,0 %;
macro HWRPB$IQ_CTB_SIZE = 176,0,0,0 %;
literal HWRPB$S_CTB_SIZE = 8;           !  Size of CTB
macro HWRPB$IL_CTB_SIZE_L = 176,0,32,0 %;
macro HWRPB$IL_CTB_SIZE_H = 180,0,32,0 %;
macro HWRPB$IQ_CTB_OFFSET = 184,0,0,0 %;
literal HWRPB$S_CTB_OFFSET = 8;         !  Offset to CTB
macro HWRPB$IL_CTB_OFFSET_L = 184,0,32,0 %;
macro HWRPB$IL_CTB_OFFSET_H = 188,0,32,0 %;
macro HWRPB$IQ_CRB_OFFSET = 192,0,0,0 %;
literal HWRPB$S_CRB_OFFSET = 8;         !  Offset to Console routine blk
macro HWRPB$IL_CRB_OFFSET_L = 192,0,32,0 %;
macro HWRPB$IL_CRB_OFFSET_H = 196,0,32,0 %;
macro HWRPB$IQ_MEM_OFFSET = 200,0,0,0 %;
literal HWRPB$S_MEM_OFFSET = 8;         !  Offset to memory descriptor
macro HWRPB$IL_MEM_OFFSET_L = 200,0,32,0 %;
macro HWRPB$IL_MEM_OFFSET_H = 204,0,32,0 %;
macro HWRPB$IQ_CDB_OFFSET = 208,0,0,0 %;
literal HWRPB$S_CDB_OFFSET = 8;         !  Offset to Config Data Block
macro HWRPB$IL_CDB_OFFSET_L = 208,0,32,0 %;
macro HWRPB$IL_CDB_OFFSET_H = 212,0,32,0 %;
macro HWRPB$IQ_FRU_OFFSET = 216,0,0,0 %;
literal HWRPB$S_FRU_OFFSET = 8;         !  Offset to FRU table
macro HWRPB$IL_FRU_OFFSET_L = 216,0,32,0 %;
macro HWRPB$IL_FRU_OFFSET_H = 220,0,32,0 %;
macro HWRPB$IQ_SAVE_TERM = 224,0,0,0 %;
literal HWRPB$S_SAVE_TERM = 8;          !  VA of term save state routine 
macro HWRPB$IL_SAVE_TERM_L = 224,0,32,1 %;
macro HWRPB$IL_SAVE_TERM_H = 228,0,32,0 %;
macro HWRPB$IQ_SAVE_PD = 232,0,0,0 %;
literal HWRPB$S_SAVE_PD = 8;            !  Proc. value of save state rout.
macro HWRPB$IL_SAVE_PD_L = 232,0,32,1 %;
macro HWRPB$IL_SAVE_PD_H = 236,0,32,0 %;
macro HWRPB$IQ_RESTORE_TERM = 240,0,0,0 %;
literal HWRPB$S_RESTORE_TERM = 8;       !  VA of term restore state routine 
macro HWRPB$IL_RESTORE_TERM_L = 240,0,32,1 %;
macro HWRPB$IL_RESTORE_TERM_H = 244,0,32,0 %;
macro HWRPB$IQ_RESTORE_PD = 248,0,0,0 %;
literal HWRPB$S_RESTORE_PD = 8;         !  Proc. value of restore state rout.
macro HWRPB$IL_RESTORE_PD_L = 248,0,32,1 %;
macro HWRPB$IL_RESTORE_PD_H = 252,0,32,0 %;
macro HWRPB$IQ_RESTART = 256,0,0,0 %;
literal HWRPB$S_RESTART = 8;            !  VA of restart routine
macro HWRPB$IL_RESTART_L = 256,0,32,1 %;
macro HWRPB$IL_RESTART_H = 260,0,32,0 %;
macro HWRPB$IQ_RESTART_PD = 264,0,0,0 %;
literal HWRPB$S_RESTART_PD = 8;         !  Restart Procedure Descriptor
macro HWRPB$IL_RESTART_PD_L = 264,0,32,0 %;
macro HWRPB$IL_RESTART_PD_H = 268,0,32,0 %;
macro HWRPB$PQ_SWRPB = 272,0,0,1 %;
literal HWRPB$S_SWRPB = 8;              !  Resevered for software
macro HWRPB$PL_SWRPB_L = 272,0,32,1 %;
macro HWRPB$IL_SWRPB_H = 276,0,32,1 %;
macro HWRPB$IQ_HARDWARE1 = 280,0,0,0 %;
literal HWRPB$S_HARDWARE1 = 8;          !  Resevered for hardware
macro HWRPB$IL_HARDWARE1_L = 280,0,32,0 %;
macro HWRPB$IL_HARDWARE1_H = 284,0,32,0 %;
macro HWRPB$IQ_CHKSUM = 288,0,0,0 %;
literal HWRPB$S_CHKSUM = 8;             !  Checksum of HWRPB
macro HWRPB$IL_CHKSUM_L = 288,0,32,0 %;
macro HWRPB$IL_CHKSUM_H = 292,0,32,0 %;
macro HWRPB$IQ_RXRDY = 296,0,0,0 %;
literal HWRPB$S_RXRDY = 8;              !  Offset to RXRDY bitmask
macro HWRPB$IL_RXRDY_L = 296,0,32,0 %;
macro HWRPB$IL_RXRDY_H = 300,0,32,0 %;
macro HWRPB$IQ_TXRDY = 304,0,0,0 %;
literal HWRPB$S_TXRDY = 8;              !  Offset to TXRDY bitmask
macro HWRPB$IL_TXRDY_L = 304,0,32,0 %;
macro HWRPB$IL_TXRDY_H = 308,0,32,0 %;
macro HWRPB$IQ_DSRDB_OFFSET = 312,0,0,0 %;
literal HWRPB$S_DSRDB_OFFSET = 8;       !  Offset to DSR D.B.
macro HWRPB$IL_DSRDB_OFFSET_L = 312,0,32,0 %;
macro HWRPB$IL_DSRDB_OFFSET_H = 316,0,32,0 %;
!  DSR data block
literal DSRDB$S_DSRDBDEF = 24;          !  Old size name - synonym
literal DSRDB$S_DSRDB = 24;
macro DSRDB$IQ_SMM = 0,0,0,0 %;
literal DSRDB$S_SMM = 8;                !  SMM value
macro DSRDB$IL_SMM_L = 0,0,32,0 %;
macro DSRDB$IL_SMM_H = 4,0,32,0 %;
macro DSRDB$IQ_LURT_OFFSET = 8,0,0,0 %;
literal DSRDB$S_LURT_OFFSET = 8;        !  Offset to LURT count field
macro DSRDB$IL_LURT_OFFSET_L = 8,0,32,0 %;
macro DSRDB$IL_LURT_OFFSET_H = 12,0,32,0 %;
macro DSRDB$IQ_NAME_CT_OFFSET = 16,0,0,0 %;
literal DSRDB$S_NAME_CT_OFFSET = 8;     !  Offset to Name count field
macro DSRDB$IL_NAME_CT_OFFSET_L = 16,0,32,0 %;
macro DSRDB$IL_NAME_CT_OFFSET_H = 20,0,32,0 %;
!  Per-CPU slot definitions
literal SLOT$M_BIP = %X'1';
literal SLOT$M_RC = %X'2';
literal SLOT$M_PA = %X'4';
literal SLOT$M_PP = %X'8';
literal SLOT$M_OH = %X'10';
literal SLOT$M_CV = %X'20';
literal SLOT$M_PV = %X'40';
literal SLOT$M_PMV = %X'80';
literal SLOT$M_PL = %X'100';
literal SLOT$M_HLTREQ = %X'FF0000';
literal HWRPB_HALT$K_NO_ACTION = 0;     !  Just Halt
literal HWRPB_HALT$K_SAVE_RESTORE_TERM = 1; !  Save or restore term
literal HWRPB_HALT$K_COLD_REBOOT = 2;   !  Cold bootstrap request
literal HWRPB_HALT$K_WARM_REBOOT = 3;   !  Warm bootstrap request
literal HWRPB_HALT$K_REMAIN_HALTED = 4; !  Don't restart
literal HWRPB_PAL_REV$K_STANDARD = 0;   !  Standard PAL code
literal HWRPB_PAL_REV$K_ULTRIX = 1;     !  ULTRIX varient of PAL code
literal HWRPB_CPU_TYPE$K_EV3 = 1;       !  Reduced functionality EVAX
literal HWRPB_CPU_TYPE$K_EV4 = 2;       !  First fully functional EVAX
literal HWRPB_CPU_TYPE$K_MANNEQUIN = 3; !  Mannequin simulator
literal HWRPB_CPU_TYPE$K_LCA = 4;       !  Low Cost Alpha
literal HWRPB_CPU_TYPE$K_EV5 = 5;       !  CMOS 5 EVAX
literal HWRPB_CPU_TYPE$K_EV45 = 6;      !  EV4 shrink on CMOS 5 process
literal HWRPB_CPU_TYPE$K_MAX_CPU_TYPE = 6;
literal SLOT$M_VAX_FP = %X'1';
literal SLOT$M_IEEE_FP = %X'2';
literal SLOT$M_PE = %X'4';
literal HWRPB$K_RESTART = 0;            !  Btstrap,procr strt, or pwrfl.
literal HWRPB$K_CRASH_CMD = 1;          !  Crash via cosole request
literal HWRPB$K_KSP_NOT_VALID = 2;      !  Kernel stack not valid halt
literal HWRPB$K_INVALID_SCBB = 3;       !  Invalid SCB Base register
literal HWRPB$K_INVALID_PTBR = 4;       !  Invalid Page Table Base Reg.
literal HWRPB$K_CALL_PAL_HALT = 5;      !  Processor executed in ker. mode
literal HWRPB$K_DOUBLE_ERROR = 6;       !  Double error abort
literal SLOT$C_LENGTH = 768;
literal SLOT$K_LENGTH = 768;
literal SLOT$S_SLOTDEF = 648;           !  Old size name, synonym
literal SLOT$S_CPU_SLOT = 648;
macro SLOT$IQ_HWPCB = 0,0,0,0 %;
literal SLOT$S_HWPCB = 128;             !  Restart/Boot HWPCB
macro SLOT$IQ_STATE = 128,0,0,0 %;
literal SLOT$S_STATE = 8;               !  Per-CPU state bits
macro SLOT$IL_STATE = 128,0,32,0 %;
macro SLOT$V_BIP = 128,0,1,0 %;         !  Bootstrap in progress
macro SLOT$V_RC = 128,1,1,0 %;          !  Restart capable
macro SLOT$V_PA = 128,2,1,0 %;          !  Processor available
macro SLOT$V_PP = 128,3,1,0 %;          !  Processor present
macro SLOT$V_OH = 128,4,1,0 %;          !  Operator halted
macro SLOT$V_CV = 128,5,1,0 %;          !  Context valid
macro SLOT$V_PV = 128,6,1,0 %;          !  PAL code valid
macro SLOT$V_PMV = 128,7,1,0 %;         !  PAL code memory valid
macro SLOT$V_PL = 128,8,1,0 %;          !  PAL code loaded
macro SLOT$V_HLTREQ = 128,16,8,0 %;
literal SLOT$S_HLTREQ = 8;
macro SLOT$IL_STATE_H = 132,0,32,0 %;
macro SLOT$IQ_PAL_MEM_LEN = 136,0,0,0 %;
literal SLOT$S_PAL_MEM_LEN = 8;         !  PALcode Memory Length
macro SLOT$IL_PAL_MEM_LEN_L = 136,0,32,0 %;
macro SLOT$IL_PAL_MEM_LEN_H = 140,0,32,0 %;
macro SLOT$IQ_PAL_SCR_LEN = 144,0,0,0 %;
literal SLOT$S_PAL_SCR_LEN = 8;         !  PALcode Scratch Length
macro SLOT$IL_PAL_SCR_LEN_L = 144,0,32,0 %;
macro SLOT$IL_PAL_SCR_LEN_H = 148,0,32,0 %;
macro SLOT$IQ_PAL_MEM_PA = 152,0,0,0 %;
literal SLOT$S_PAL_MEM_PA = 8;          !  Phy addr of PAL code memory
macro SLOT$IL_PAL_MEM_PA_L = 152,0,32,0 %;
macro SLOT$IL_PAL_MEM_PA_H = 156,0,32,0 %;
macro SLOT$IQ_PAL_SCR_ADR = 160,0,0,0 %;
literal SLOT$S_PAL_SCR_ADR = 8;         !  Phys addr of PAL scratch sp
macro SLOT$IL_PAL_SCR_ADR_L = 160,0,32,0 %;
macro SLOT$IL_PAL_SCR_ADR_H = 164,0,32,0 %;
macro SLOT$IQ_PAL_REV = 168,0,0,0 %;
literal SLOT$S_PAL_REV = 8;             !  Revision of PAL code required
macro SLOT$IL_PAL_REV_L = 168,0,32,0 %;
macro SLOT$B_PAL_MIN_REV = 168,0,8,0 %; !  PAL code minor revision
macro SLOT$B_PAL_MAJ_REV = 169,0,8,0 %; !  PAL code major revision
macro SLOT$B_PAL_VAR = 170,0,8,0 %;     !  PAL code variation
macro SLOT$IL_PAL_REV_H = 172,0,32,0 %;
macro SLOT$IW_PAL_COMPT = 172,0,16,0 %; !  PAL code compatibility
macro SLOT$IW_MAX_SHARE = 174,0,16,0 %; !  Max number CPUs to share
macro SLOT$IQ_CPU_TYPE = 176,0,0,0 %;
literal SLOT$S_CPU_TYPE = 8;            !  Processor type
macro SLOT$IL_CPU_TYPE_L = 176,0,32,0 %;
macro SLOT$IL_CPU_TYPE_H = 180,0,32,0 %;
macro SLOT$IQ_CPU_VAR = 184,0,0,0 %;
literal SLOT$S_CPU_VAR = 8;             !  Processor variation
macro SLOT$IL_CPU_VAR_L = 184,0,32,0 %;
macro SLOT$V_VAX_FP = 184,0,1,0 %;      !  VAX  floating point
macro SLOT$V_IEEE_FP = 184,1,1,0 %;     !  IEEE floating point
macro SLOT$V_PE = 184,2,1,0 %;          !  Processor Eligibility
macro SLOT$IL_CPU_VAR_H = 188,0,32,0 %;
macro SLOT$IQ_CPU_REV = 192,0,0,0 %;
literal SLOT$S_CPU_REV = 8;             !  Processor revision
macro SLOT$IL_CPU_REV_L = 192,0,32,0 %;
macro SLOT$IL_CPU_REV_H = 196,0,32,0 %;
macro SLOT$B_CPU_SERIALNUM = 200,0,0,0 %;
literal SLOT$S_CPU_SERIALNUM = 16;      !  CPU Serial number
macro SLOT$IQ_LOGOUT_PA = 216,0,0,0 %;
literal SLOT$S_LOGOUT_PA = 8;           !  Physical Addr of logout area
macro SLOT$IL_LOGOUT_PA_L = 216,0,32,0 %;
macro SLOT$IL_LOGOUT_PA_H = 220,0,32,0 %;
macro SLOT$IQ_LOGOUT_LEN = 224,0,0,0 %;
literal SLOT$S_LOGOUT_LEN = 8;          !  Size of logout area
macro SLOT$IL_LOGOUT_LEN_L = 224,0,32,0 %;
macro SLOT$IL_LOGOUT_LEN_H = 228,0,32,0 %;
macro SLOT$IQ_HALT_PCBB = 232,0,0,0 %;
literal SLOT$S_HALT_PCBB = 8;           !  Halt PCBB
macro SLOT$IL_HALT_PCBB_L = 232,0,32,0 %;
macro SLOT$IL_HALT_PCBB_H = 236,0,32,0 %;
macro SLOT$IQ_HALT_PC = 240,0,0,0 %;
literal SLOT$S_HALT_PC = 8;             !  Halt PC
macro SLOT$IL_HALT_PC_L = 240,0,32,0 %;
macro SLOT$IL_HALT_PC_H = 244,0,32,0 %;
macro SLOT$IQ_HALT_PS = 248,0,0,0 %;
literal SLOT$S_HALT_PS = 8;             !  Halt PS
macro SLOT$IL_HALT_PS_L = 248,0,32,0 %;
macro SLOT$IL_HALT_PS_H = 252,0,32,0 %;
macro SLOT$IQ_HALT_ARG = 256,0,0,0 %;
literal SLOT$S_HALT_ARG = 8;            !  Halt Argument List
macro SLOT$IL_HALT_ARG_L = 256,0,32,0 %;
macro SLOT$IL_HALT_ARG_H = 260,0,32,0 %;
macro SLOT$IQ_HALT_RET = 264,0,0,0 %;
literal SLOT$S_HALT_RET = 8;            !  Halt Return Address
macro SLOT$IL_HALT_RET_L = 264,0,32,0 %;
macro SLOT$IL_HALT_RET_H = 268,0,32,0 %;
macro SLOT$IQ_HALT_PV = 272,0,0,0 %;
literal SLOT$S_HALT_PV = 8;             !  Halt PV
macro SLOT$IL_HALT_PV_L = 272,0,32,0 %;
macro SLOT$IL_HALT_PV_H = 276,0,32,0 %;
macro SLOT$IQ_HALTCODE = 280,0,0,0 %;
literal SLOT$S_HALTCODE = 8;            !  Halt code
macro SLOT$IL_HALTCODE_L = 280,0,32,0 %;
macro SLOT$IL_HALTCODE_H = 284,0,32,0 %;
macro SLOT$IQ_SOFT_FLAGS = 288,0,0,0 %;
literal SLOT$S_SOFT_FLAGS = 8;          !  Reserved to software
macro SLOT$IL_SOFT_FLAGS_L = 288,0,32,0 %;
macro SLOT$IL_SOFT_FLAGS_H = 292,0,32,0 %;
macro SLOT$B_INCON_BUF_AREA = 296,0,0,0 %;
literal SLOT$S_INCON_BUF_AREA = 168;    !  SMP Console Buf Area
macro SLOT$IL_RXLEN = 296,0,32,0 %;
macro SLOT$IL_TXLEN = 300,0,32,0 %;
macro SLOT$B_RXBUFFER = 304,0,0,0 %;
literal SLOT$S_RXBUFFER = 80;
macro SLOT$B_TXBUFFER = 384,0,0,0 %;
literal SLOT$S_TXBUFFER = 80;
!  The next 16 quadwords are reserved for the 
!  "PALcode Revisions Available Block".
!  The format of the first quadword is platform specific.
!  The format of each subsequent quadword follows the 
!  PALcode revision field (SLOT[168])
macro SLOT$Q_PAL_REV_AVAIL = 464,0,0,0 %;
literal SLOT$S_PAL_REV_AVAIL = 128;     !  PALcode Revisions Available Block
macro SLOT$IQ_CPU_SW_COMP = 592,0,0,0 %;
literal SLOT$S_CPU_SW_COMP = 8;         !  Processor software compatibility
macro SLOT$IL_CPU_SW_COMP_L = 592,0,32,0 %;
macro SLOT$IL_CPU_SW_COMP_H = 596,0,32,0 %;
!  The rest is reserved for architecture use.
!  Length of SLOT$ is defined to be rounded to nearest 128 bytes
!  HWPCB structure in Per-CPU slot definitions - zero relative
literal HWPCB$M_ASTEN = %X'F';
literal HWPCB$M_ASTSR = %X'F0';
literal HWPCB$M_ASTEN_KEN = %X'1';
literal HWPCB$M_ASTEN_EEN = %X'2';
literal HWPCB$M_ASTEN_SEN = %X'4';
literal HWPCB$M_ASTEN_UEN = %X'8';
literal HWPCB$M_ASTSR_KPD = %X'10';
literal HWPCB$M_ASTSR_EPD = %X'20';
literal HWPCB$M_ASTSR_SPD = %X'40';
literal HWPCB$M_ASTSR_UPD = %X'80';
literal HWPCB$M_FEN = %X'1';
literal HWPCB$M_PME = %X'4000000000000000';
literal HWPCB$M_DATFX = %X'8000000000000000';
literal HWPCB$C_LENGTH = 128;           !  Length of HWPCB$
literal HWPCB$K_LENGTH = 128;           !  Length of HWPCB$
literal HWPCB$S_HWPCBDEF = 128;         !  Old size name - synonym
literal HWPCB$S_HWPCB = 128;
macro HWPCB$IQ_HWPCB_BASE = 0,0,0,0 %;
literal HWPCB$S_HWPCB_BASE = 8;         !  Base of HWPCB
macro HWPCB$IQ_KSP = 0,0,0,0 %;
literal HWPCB$S_KSP = 8;                !  Kernel stack pointer
macro HWPCB$IL_KSP_L = 0,0,32,0 %;
macro HWPCB$IL_KSP_H = 4,0,32,0 %;
macro HWPCB$IQ_ESP = 8,0,0,0 %;
literal HWPCB$S_ESP = 8;                !  Executive stack pointer
macro HWPCB$IL_ESP_L = 8,0,32,0 %;
macro HWPCB$IL_ESP_H = 12,0,32,0 %;
macro HWPCB$IQ_SSP = 16,0,0,0 %;
literal HWPCB$S_SSP = 8;                !  Supervisor stack pointer
macro HWPCB$IL_SSP_L = 16,0,32,0 %;
macro HWPCB$IL_SSP_H = 20,0,32,0 %;
macro HWPCB$IQ_USP = 24,0,0,0 %;
literal HWPCB$S_USP = 8;                !  User stack pointer
macro HWPCB$IL_USP_L = 24,0,32,0 %;
macro HWPCB$IL_USP_H = 28,0,32,0 %;
macro HWPCB$IQ_PTBR = 32,0,0,0 %;
literal HWPCB$S_PTBR = 8;               !  Page Table Base Register
macro HWPCB$IL_PTBR_L = 32,0,32,0 %;
macro HWPCB$IL_PTBR_H = 36,0,32,0 %;
macro HWPCB$IQ_ASN = 40,0,0,0 %;
literal HWPCB$S_ASN = 8;                !  Address space number
macro HWPCB$IL_ASN_L = 40,0,32,0 %;
macro HWPCB$IL_ASN_H = 44,0,32,0 %;
macro HWPCB$IQ_ASTSR_ASTEN = 48,0,0,0 %;
literal HWPCB$S_ASTSR_ASTEN = 8;        !  ASTSR / ASTEN quadword
macro HWPCB$IL_AST_L = 48,0,32,0 %;
macro HWPCB$IL_AST_H = 52,0,32,0 %;
macro HWPCB$V_ASTEN = 48,0,4,0 %;
literal HWPCB$S_ASTEN = 4;              !  AST Enable Register
macro HWPCB$V_ASTSR = 48,4,4,0 %;
literal HWPCB$S_ASTSR = 4;              !  AST Pending Summary Register
macro HWPCB$V_ASTEN_KEN = 48,0,1,0 %;   !  Kernel AST Enable = 1
macro HWPCB$V_ASTEN_EEN = 48,1,1,0 %;   !  Executive AST Enable = 1
macro HWPCB$V_ASTEN_SEN = 48,2,1,0 %;   !  Supervisor AST Enable = 1
macro HWPCB$V_ASTEN_UEN = 48,3,1,0 %;   !  User AST Enable = 1
macro HWPCB$V_ASTSR_KPD = 48,4,1,0 %;   !  Kernel AST Pending = 1
macro HWPCB$V_ASTSR_EPD = 48,5,1,0 %;   !  Executive AST Pending = 1
macro HWPCB$V_ASTSR_SPD = 48,6,1,0 %;   !  Supervisor AST Pending = 1
macro HWPCB$V_ASTSR_UPD = 48,7,1,0 %;   !  User AST Pending = 1
macro HWPCB$IQ_FEN = 56,0,0,0 %;
literal HWPCB$S_FEN = 8;                !  Floating Point Enable / PME / DATFX
macro HWPCB$IL_FEN_L = 56,0,32,0 %;
macro HWPCB$IL_FEN_H = 60,0,32,0 %;
macro HWPCB$V_FEN = 56,0,1,0 %;         !  Floating Point Enable = 1
macro HWPCB$V_PME = 60,30,1,0 %;        !  Performance Monitor Enable
macro HWPCB$V_DATFX = 60,31,1,0 %;      !  Data Alignment Trap Fixup
macro HWPCB$IQ_CC = 64,0,0,0 %;
literal HWPCB$S_CC = 8;                 !  Cycle Counter
macro HWPCB$IL_CC_L = 64,0,32,0 %;
macro HWPCB$IL_CC_H = 68,0,32,0 %;
macro HWPCB$IQ_UNQ = 72,0,0,0 %;
literal HWPCB$S_UNQ = 8;                !  Process Unique Value
macro HWPCB$IL_UNQ_L = 72,0,32,0 %;
macro HWPCB$IL_UNQ_H = 76,0,32,0 %;
macro HWPCB$IQ_PAL_RSVD = 80,0,0,1 %;
literal HWPCB$S_PAL_RSVD = 48;          !  Reserved for PAL scratch
macro HWPCB$IL_PAL_RSVD_L = 80,0,32,0 %;
macro HWPCB$IL_PAL_RSVD_H = 84,0,32,0 %;
!  Physical memory descriptor
literal HWRPB_PMD$C_LENGTH = 24;        !  Length of HWRPB_PMD$
literal HWRPB_PMD$K_LENGTH = 24;        !  Length of HWRPB_PMD$
!  For system with PHYSICALLY DIS-CONTIGUOUS memory, PMR points to 
literal HWRPB_PMD$S_PMDDEF = 136;       !  Old size name - synonym
literal HWRPB_PMD$S_PMD = 136;
macro HWRPB_PMD$IQ_CHKSUM = 0,0,0,0 %;
literal HWRPB_PMD$S_CHKSUM = 8;         !  Checksum of PMD+8 to PMD+end
macro HWRPB_PMD$IL_CHKSUM_L = 0,0,32,0 %;
macro HWRPB_PMD$IL_CHKSUM_H = 4,0,32,0 %;
macro HWRPB_PMD$IQ_OPT_DATA = 8,0,0,0 %;
literal HWRPB_PMD$S_OPT_DATA = 8;       !  Optional data
macro HWRPB_PMD$IL_OPT_DATA_L = 8,0,32,0 %;
macro HWRPB_PMD$IL_OPT_DATA_H = 12,0,32,0 %;
macro HWRPB_PMD$IQ_CLUSTER_COUNT = 16,0,0,0 %;
literal HWRPB_PMD$S_CLUSTER_COUNT = 8;  !  Count of clusters present
macro HWRPB_PMD$IL_CLUSTER_COUNT_L = 16,0,32,0 %;
macro HWRPB_PMD$IL_CLUSTER_COUNT_H = 20,0,32,0 %;
!  an array of Physical Memory Regions (PMR). 
macro HWRPB_PMD$IQ_PMR = 24,0,0,0 %;
literal HWRPB_PMD$S_PMR = 8;            !  Start of first region
macro HWRPB_PMD$IL_PMR_L = 24,0,32,0 %;
macro HWRPB_PMD$IL_PMR_H = 28,0,32,0 %;
!  For system with PHYSICALLY CONTIGUOUS memory, there are only two regions
!  defined.  The first region describes memory in use by the console, and the
!  second region describes memory for use by the system.
macro HWRPB_PMD$IQ_CN_PFN_START = 24,0,0,0 %;
literal HWRPB_PMD$S_CN_PFN_START = 8;   !  Start PFN of console region
macro HWRPB_PMD$IL_CN_PFN_START_L = 24,0,32,0 %;
macro HWRPB_PMD$IL_CN_PFN_START_H = 28,0,32,0 %;
macro HWRPB_PMD$IQ_CN_PFN_COUNT = 32,0,0,0 %;
literal HWRPB_PMD$S_CN_PFN_COUNT = 8;   !  Number of PFNs in region
macro HWRPB_PMD$IL_CN_PFN_COUNT_L = 32,0,32,0 %;
macro HWRPB_PMD$IL_CN_PFN_COUNT_H = 36,0,32,0 %;
macro HWRPB_PMD$IQ_CN_TEST_COUNT = 40,0,0,0 %;
literal HWRPB_PMD$S_CN_TEST_COUNT = 8;  !  Num. of tested PFNs in region
macro HWRPB_PMD$IL_CN_TEST_COUNT_L = 40,0,32,0 %;
macro HWRPB_PMD$IL_CN_TEST_COUNT_H = 44,0,32,0 %;
macro HWRPB_PMD$IQ_CN_BITMAP_VA = 48,0,0,0 %;
literal HWRPB_PMD$S_CN_BITMAP_VA = 8;   !  VA of bitmap
macro HWRPB_PMD$IL_CN_BITMAP_VA_L = 48,0,32,0 %;
macro HWRPB_PMD$IL_CN_BITMAP_VA_H = 52,0,32,0 %;
macro HWRPB_PMD$IQ_CN_BITMAP_PA = 56,0,0,0 %;
literal HWRPB_PMD$S_CN_BITMAP_PA = 8;   !  PA of bitmap
macro HWRPB_PMD$IL_CN_BITMAP_PA_L = 56,0,32,0 %;
macro HWRPB_PMD$IL_CN_BITMAP_PA_H = 60,0,32,0 %;
macro HWRPB_PMD$IQ_CN_BITMAP_CHKSUM = 64,0,0,0 %;
literal HWRPB_PMD$S_CN_BITMAP_CHKSUM = 8; !  Checksum of bitmap
macro HWRPB_PMD$IL_CN_BITMAP_CHKSUM_L = 64,0,32,0 %;
macro HWRPB_PMD$IL_CN_BITMAP_CHKSUM_H = 68,0,32,0 %;
macro HWRPB_PMD$IQ_CN_USAGE = 72,0,0,0 %;
literal HWRPB_PMD$S_CN_USAGE = 8;       !  Cluster usage flags
macro HWRPB_PMD$IL_CN_USAGE_L = 72,0,32,0 %;
macro HWRPB_PMD$IL_CN_USAGE_H = 76,0,32,0 %;
macro HWRPB_PMD$IQ_SY_PFN_START = 80,0,0,0 %;
literal HWRPB_PMD$S_SY_PFN_START = 8;   !  Start PFN of system region
macro HWRPB_PMD$IL_SY_PFN_START_L = 80,0,32,0 %;
macro HWRPB_PMD$IL_SY_PFN_START_H = 84,0,32,0 %;
macro HWRPB_PMD$IQ_SY_PFN_COUNT = 88,0,0,0 %;
literal HWRPB_PMD$S_SY_PFN_COUNT = 8;   !  Number of PFNs in region
macro HWRPB_PMD$IL_SY_PFN_COUNT_L = 88,0,32,0 %;
macro HWRPB_PMD$IL_SY_PFN_COUNT_H = 92,0,32,0 %;
macro HWRPB_PMD$IQ_SY_TEST_COUNT = 96,0,0,0 %;
literal HWRPB_PMD$S_SY_TEST_COUNT = 8;  !  Num. of tested PFNs in region
macro HWRPB_PMD$IL_SY_TEST_COUNT_L = 96,0,32,0 %;
macro HWRPB_PMD$IL_SY_TEST_COUNT_H = 100,0,32,0 %;
macro HWRPB_PMD$IQ_SY_BITMAP_VA = 104,0,0,0 %;
literal HWRPB_PMD$S_SY_BITMAP_VA = 8;   !  VA of bitmap
macro HWRPB_PMD$IL_SY_BITMAP_VA_L = 104,0,32,0 %;
macro HWRPB_PMD$IL_SY_BITMAP_VA_H = 108,0,32,0 %;
macro HWRPB_PMD$IQ_SY_BITMAP_PA = 112,0,0,0 %;
literal HWRPB_PMD$S_SY_BITMAP_PA = 8;   !  PA of bitmap
macro HWRPB_PMD$IL_SY_BITMAP_PA_L = 112,0,32,0 %;
macro HWRPB_PMD$IL_SY_BITMAP_PA_H = 116,0,32,0 %;
macro HWRPB_PMD$IQ_SY_BITMAP_CHKSUM = 120,0,0,0 %;
literal HWRPB_PMD$S_SY_BITMAP_CHKSUM = 8; !  Checksum of bitmap
macro HWRPB_PMD$IL_SY_BITMAP_CHKSUM_L = 120,0,32,0 %;
macro HWRPB_PMD$IL_SY_BITMAP_CHKSUM_H = 124,0,32,0 %;
macro HWRPB_PMD$IQ_SY_USAGE = 128,0,0,0 %;
literal HWRPB_PMD$S_SY_USAGE = 8;       !  Cluster usage flags
macro HWRPB_PMD$IL_SY_USAGE_L = 128,0,32,0 %;
macro HWRPB_PMD$IL_SY_USAGE_H = 132,0,32,0 %;
!  Physical memory region descriptor
literal HWRPB_PMR$M_CONSOLE = %X'1';
literal HWRPB_PMR$C_LENGTH = 56;        !  Size of region entry
literal HWRPB_PMR$K_LENGTH = 56;        !  Size of region entry
literal HWRPB_PMR$S_PMREGDEF = 56;      !  Old size name - synonym
literal HWRPB_PMR$S_PMREG = 56;
macro HWRPB_PMR$IQ_PFN_START = 0,0,0,0 %;
literal HWRPB_PMR$S_PFN_START = 8;      !  Starting PFN in region
macro HWRPB_PMR$IL_PFN_START_L = 0,0,32,0 %;
macro HWRPB_PMR$IL_PFN_START_H = 4,0,32,0 %;
macro HWRPB_PMR$IQ_PFN_COUNT = 8,0,0,0 %;
literal HWRPB_PMR$S_PFN_COUNT = 8;      !  Number of PFNs in region
macro HWRPB_PMR$IL_PFN_COUNT_L = 8,0,32,0 %;
macro HWRPB_PMR$IL_PFN_COUNT_H = 12,0,32,0 %;
macro HWRPB_PMR$IQ_TEST_COUNT = 16,0,0,0 %;
literal HWRPB_PMR$S_TEST_COUNT = 8;     !  Num. of tested PFNs in region
macro HWRPB_PMR$IL_TEST_COUNT_L = 16,0,32,0 %;
macro HWRPB_PMR$IL_TEST_COUNT_H = 20,0,32,0 %;
macro HWRPB_PMR$PQ_BITMAP_VA = 24,0,0,1 %;
literal HWRPB_PMR$S_BITMAP_VA = 8;      !  VA of bitmap
macro HWRPB_PMR$PL_BITMAP_VA_L = 24,0,32,1 %;
macro HWRPB_PMR$IL_BITMAP_VA_H = 28,0,32,0 %;
macro HWRPB_PMR$PQ_BITMAP_PA = 32,0,0,1 %;
literal HWRPB_PMR$S_BITMAP_PA = 8;      !  PA of bitmap
macro HWRPB_PMR$PL_BITMAP_PA_L = 32,0,32,1 %;
macro HWRPB_PMR$IL_BITMAP_PA_H = 36,0,32,0 %;
macro HWRPB_PMR$IQ_BITMAP_CHKSUM = 40,0,0,0 %;
literal HWRPB_PMR$S_BITMAP_CHKSUM = 8;  !  Checksum of bitmap
macro HWRPB_PMR$IL_BITMAP_CHKSUM_L = 40,0,32,0 %;
macro HWRPB_PMR$IL_BITMAP_CHKSUM_H = 44,0,32,0 %;
macro HWRPB_PMR$IQ_USAGE = 48,0,0,0 %;
literal HWRPB_PMR$S_USAGE = 8;          !  Cluster usage flags
macro HWRPB_PMR$IL_USAGE_L = 48,0,32,0 %;
macro HWRPB_PMR$V_CONSOLE = 48,0,1,0 %; !  Cluster reserved by console
macro HWRPB_PMR$IL_USAGE_H = 52,0,32,0 %;
!  Console languages
literal HWRPB_LANG$k_UNKNOWN = 0;
literal HWRPB_LANG$k_DANISH = 48;
literal HWRPB_LANG$k_GERMAN = 50;
literal HWRPB_LANG$k_SWISS = 52;
literal HWRPB_LANG$k_AMERICAN = 54;
literal HWRPB_LANG$k_BRITISH = 56;
literal HWRPB_LANG$k_SPANISH = 58;
literal HWRPB_LANG$k_FRENCH = 60;
literal HWRPB_LANG$k_CANADIAN = 62;
literal HWRPB_LANG$k_ROMANDE = 64;
literal HWRPB_LANG$k_ITALIAN = 66;
literal HWRPB_LANG$k_NETHERLANDS = 68;
literal HWRPB_LANG$k_NORSK = 70;
literal HWRPB_LANG$k_PORTUGUESE = 72;
literal HWRPB_LANG$k_SUOMI = 74;
literal HWRPB_LANG$k_SWEDISH = 76;
literal HWRPB_LANG$k_VLAAMS = 78;
! 
!  Console Routine Block
! 
literal HWRPB_CRB$C_LENGTH = 56;        !  Length of CRB
literal HWRPB_CRB$K_LENGTH = 56;        !  Length of CRB
literal HWRPB_CRB$S_CRBDEF = 56;        !  Old size name - synonym
literal HWRPB_CRB$S_HWRPB_CRB = 56;
macro HWRPB_CRB$IQ_VA_DISPATCH_PD = 0,0,0,0 %;
literal HWRPB_CRB$S_VA_DISPATCH_PD = 8; !  Virt. Addr of Procedure Desc.
macro HWRPB_CRB$IL_VA_DISPATCH_PD_L = 0,0,32,0 %;
macro HWRPB_CRB$IL_VA_DISPATCH_PD_H = 4,0,32,0 %;
macro HWRPB_CRB$IQ_PA_DISPATCH_PD = 8,0,0,0 %;
literal HWRPB_CRB$S_PA_DISPATCH_PD = 8; !  Phy. Addr of Procedure Desc.
macro HWRPB_CRB$IL_PA_DISPATCH_PD_L = 8,0,32,0 %;
macro HWRPB_CRB$IL_PA_DISPATCH_PD_H = 12,0,32,0 %;
macro HWRPB_CRB$IQ_VA_FIXUP_PD = 16,0,0,0 %;
literal HWRPB_CRB$S_VA_FIXUP_PD = 8;    !  Virt. Addr of Procedure Desc.
macro HWRPB_CRB$IL_VA_FIXUP_PD_L = 16,0,32,0 %;
macro HWRPB_CRB$IL_VA_FIXUP_PD_H = 20,0,32,0 %;
macro HWRPB_CRB$IQ_PA_FIXUP_PD = 24,0,0,0 %;
literal HWRPB_CRB$S_PA_FIXUP_PD = 8;    !  Phy. Addr of Procedure Desc.
macro HWRPB_CRB$IL_PA_FIXUP_PD_L = 24,0,32,0 %;
macro HWRPB_CRB$IL_PA_FIXUP_PD_H = 28,0,32,0 %;
macro HWRPB_CRB$IQ_MAP_COUNT = 32,0,0,0 %;
literal HWRPB_CRB$S_MAP_COUNT = 8;      !  Num. of entries in VA/PA map
macro HWRPB_CRB$IL_MAP_COUNT_L = 32,0,32,0 %;
macro HWRPB_CRB$IL_MAP_COUNT_H = 36,0,32,0 %;
macro HWRPB_CRB$IQ_PAGE_COUNT = 40,0,0,0 %;
literal HWRPB_CRB$S_PAGE_COUNT = 8;     !  Num. of pages to be map
macro HWRPB_CRB$IL_PAGE_COUNT_L = 40,0,32,0 %;
macro HWRPB_CRB$IL_PAGE_COUNT_H = 44,0,32,0 %;
macro HWRPB_CRB$IQ_VAPA_MAP = 48,0,0,0 %;
literal HWRPB_CRB$S_VAPA_MAP = 8;       !  Console VA/PA map
macro HWRPB_CRB$IL_VAPA_MAP_L = 48,0,32,0 %;
macro HWRPB_CRB$IL_VAPA_MAP_H = 52,0,32,0 %;
literal HWRPB_VAPAMAP$S_VAPAMAPDEF = 24; !  Old size name synonym
literal HWRPB_VAPAMAP$S_VAPAMAP = 24;
macro HWRPB_VAPAMAP$IQ_VA = 0,0,0,0 %;
literal HWRPB_VAPAMAP$S_VA = 8;         !  Console VA
macro HWRPB_VAPAMAP$IL_VA_L = 0,0,32,0 %;
macro HWRPB_VAPAMAP$IL_VA_H = 4,0,32,0 %;
macro HWRPB_VAPAMAP$IQ_PA = 8,0,0,0 %;
literal HWRPB_VAPAMAP$S_PA = 8;         !  Console PA
macro HWRPB_VAPAMAP$IL_PA_L = 8,0,32,0 %;
macro HWRPB_VAPAMAP$IL_PA_H = 12,0,32,0 %;
macro HWRPB_VAPAMAP$IQ_PAGE_COUNT = 16,0,0,0 %;
literal HWRPB_VAPAMAP$S_PAGE_COUNT = 8; !  Page count of entry
macro HWRPB_VAPAMAP$IL_PAGE_COUNT_L = 16,0,32,0 %;
macro HWRPB_VAPAMAP$IL_PAGE_COUNT_H = 20,0,32,0 %;
!  Console terminal routines	
literal HWRPB_CRB$K_GETC = 1;           !  Get a character from console
literal HWRPB_CRB$K_PUTS = 2;           !  Put a string to console term
literal HWRPB_CRB$K_RESET_TERM = 3;     !  Reset console terminal
literal HWRPB_CRB$K_SET_TERM_INTR = 4;  !  Set console terminal int.
literal HWRPB_CRB$K_SET_TERM_CTL = 5;   !  Set console terminal controls
literal HWRPB_CRB$K_PROCESS_KEYCODE = 6; !  Process and translate keycode
!  Console Generic IO routines
literal HWRPB_CRB$k_OPEN = 16;          !  Open access to I/O device
literal HWRPB_CRB$k_CLOSE = 17;         !  Close access to I/O device
literal HWRPB_CRB$k_IOCTL = 18;
literal HWRPB_CRB$k_READ = 19;          !  Perform read operation
literal HWRPB_CRB$k_WRITE = 20;         !  Perform write operation
!  Console Env. Variable Routines 	
literal HWRPB_CRB$k_SET_ENV = 32;       !  Set an environment varible
literal HWRPB_CRB$k_RESET_ENV = 33;     !  Reset an environment variable
literal HWRPB_CRB$k_GET_ENV = 34;       !  Fetch an environment varible
literal HWRPB_CRB$k_SAVE_ENV = 35;      !  Save  an environment varible
!  Required Environment Variables
literal HWRPB_CRB$k_AUTO_ACTION = 1;
literal HWRPB_CRB$k_BOOT_DEV = 2;
literal HWRPB_CRB$k_BOOTCMD_DEV = 3;
literal HWRPB_CRB$k_BOOTED_DEV = 4;
literal HWRPB_CRB$k_BOOT_FILE = 5;
literal HWRPB_CRB$k_BOOTED_FILE = 6;
literal HWRPB_CRB$k_BOOT_OSFLAGS = 7;
literal HWRPB_CRB$k_BOOTED_OSFLAGS = 8;
literal HWRPB_CRB$k_BOOT_RESET = 9;
literal HWRPB_CRB$k_DUMP_DEV = 10;
literal HWRPB_CRB$k_ENABLE_AUDIT = 11;
literal HWRPB_CRB$k_LICENSE = 12;
literal HWRPB_CRB$k_CHAR_SET = 13;
literal HWRPB_CRB$k_LANGUAGE = 14;
literal HWRPB_CRB$k_TTY_DEV = 15;
literal HWRPB_CRB$k_PSWITCH = 48;
! 
!  Console Terminal Block
! 
literal HWRPB_CTBG$K_LENGTH = 256;
literal HWRPB_CTBG$C_LENGTH = 256;
literal HWRPB_CTBT$K_LENGTH = 144;
literal HWRPB_CTBT$C_LENGTH = 144;
literal HWRPB_CTBWS$K_LENGTH = 352;
literal HWRPB_CTBWS$C_LENGTH = 352;
literal HWRPB_CTB$K_LENGTH = 352;
literal HWRPB_CTB$C_LENGTH = 352;
literal HWRPB_CTB$S_CTBDEF = 352;       !  Old size name - synonym
literal HWRPB_CTB$S_CTB = 352;
! 
!   CTB - Common Section                                          
! 
macro HWRPB_CTB$IQ_TYPE = 0,0,0,0 %;
literal HWRPB_CTB$S_TYPE = 8;           !  Device Type
macro HWRPB_CTB$IL_TYPE_L = 0,0,32,0 %;
macro HWRPB_CTB$IL_TYPE_H = 4,0,32,0 %;
macro HWRPB_CTB$IQ_DEVICE_ID = 8,0,0,0 %;
literal HWRPB_CTB$S_DEVICE_ID = 8;      !  Device ID
macro HWRPB_CTB$IL_DEVICE_ID_CHANNEL = 8,0,32,0 %;
macro HWRPB_CTB$IL_DEVICE_ID_WIDGET = 12,0,32,0 %;
macro HWRPB_CTB$IQ_DEV_SPEC = 24,0,0,0 %;
literal HWRPB_CTB$S_DEV_SPEC = 8;       !  Len of dev specific data
macro HWRPB_CTB$IL_DEV_SPEC_L = 24,0,32,0 %;
macro HWRPB_CTB$IL_DEV_SPEC_H = 28,0,32,0 %;
! 
!   CTB - Device dependent section
! 
!      - Graphics device portion
! 
macro HWRPB_CTB$R_DEV_DEPEND = 32,0,0,0 %;
literal HWRPB_CTB$S_DEV_DEPEND = 320;
macro HWRPB_CTB$Q_CTBGDEF = 32,0,0,0 %;
literal HWRPB_CTBG$S_CTBGDEF = 224;
macro HWRPB_CTBG$IQ_ROW = 32,0,0,0 %;
literal HWRPB_CTBG$S_ROW = 8;           !  Current Row
macro HWRPB_CTBG$IL_ROW_L = 32,0,32,0 %;
macro HWRPB_CTBG$IL_ROW_H = 36,0,32,0 %;
macro HWRPB_CTBG$IQ_COLUMN = 40,0,0,0 %;
literal HWRPB_CTBG$S_COLUMN = 8;        !  Current Column
macro HWRPB_CTBG$IL_COLUMN_L = 40,0,32,0 %;
macro HWRPB_CTBG$IL_COLUMN_H = 44,0,32,0 %;
macro HWRPB_CTBG$IQ_MAX_ROW = 48,0,0,0 %;
literal HWRPB_CTBG$S_MAX_ROW = 8;       !  Maximum Row
macro HWRPB_CTBG$IL_MAX_ROW_L = 48,0,32,0 %;
macro HWRPB_CTBG$IL_MAX_ROW_H = 52,0,32,0 %;
macro HWRPB_CTBG$IQ_CHAR_HEIGHT = 56,0,0,0 %;
literal HWRPB_CTBG$S_CHAR_HEIGHT = 8;   !  Character Cell Height
macro HWRPB_CTBG$IL_CHAR_HEIGHT_L = 56,0,32,0 %;
macro HWRPB_CTBG$IL_CHAR_HEIGHT_H = 60,0,32,0 %;
macro HWRPB_CTBG$IQ_CHAR_WIDTH = 64,0,0,0 %;
literal HWRPB_CTBG$S_CHAR_WIDTH = 8;    !  Character Cell Width
macro HWRPB_CTBG$IL_CHAR_WIDTH_L = 64,0,32,0 %;
macro HWRPB_CTBG$IL_CHAR_WIDTH_H = 68,0,32,0 %;
macro HWRPB_CTBG$IQ_DISPLAY_CSR = 72,0,0,0 %;
literal HWRPB_CTBG$S_DISPLAY_CSR = 8;   !  CSR addr. of Display
macro HWRPB_CTBG$IL_DISPLAY_CSR_L = 72,0,32,0 %;
macro HWRPB_CTBG$IL_DISPLAY_CSR_H = 76,0,32,0 %;
macro HWRPB_CTBG$IQ_KEYB_CSR = 80,0,0,0 %;
literal HWRPB_CTBG$S_KEYB_CSR = 8;      !  CSR addr. of keyboard
macro HWRPB_CTBG$IL_KEYB_CSR_L = 80,0,32,0 %;
macro HWRPB_CTBG$IL_KEYB_CSR_H = 84,0,32,0 %;
macro HWRPB_CTBG$IQ_KEYB_VECTOR = 88,0,0,0 %;
literal HWRPB_CTBG$S_KEYB_VECTOR = 8;   !  Lk keyboard inter. SCB offset
macro HWRPB_CTBG$IL_KEYB_VECTOR_L = 88,0,32,0 %;
macro HWRPB_CTBG$IL_KEYB_VECTOR_H = 92,0,32,0 %;
macro HWRPB_CTBG$IQ_KEYB_STATE = 96,0,0,0 %;
literal HWRPB_CTBG$S_KEYB_STATE = 8;    !  Keyboard state
macro HWRPB_CTBG$IL_KEYB_STATE_L = 96,0,32,0 %;
macro HWRPB_CTBG$IL_KEYB_STATE_H = 100,0,32,0 %;
macro HWRPB_CTBG$IQ_KEYC_BUFFER = 104,0,0,0 %;
literal HWRPB_CTBG$S_KEYC_BUFFER = 48;
macro HWRPB_CTBG$IL_KEYC_BUFFER_L = 104,0,32,0 %;
macro HWRPB_CTBG$IL_KEYC_BUFFER_H = 108,0,32,0 %;
! 
!      - Terminal device portion
! 
macro HWRPB_CTB$R_CTBTDEF = 32,0,0,0 %;
literal HWRPB_CTBT$S_CTBTDEF = 112;
macro HWRPB_CTBT$IQ_CSR_ADDR = 32,0,0,0 %;
literal HWRPB_CTBT$S_CSR_ADDR = 8;      !  CSR address
macro HWRPB_CTBT$IL_CSR_ADDR_L = 32,0,32,0 %;
macro HWRPB_CTBT$IL_CSR_ADDR_H = 36,0,32,0 %;
macro HWRPB_CTBT$IQ_XMIT_VECTOR = 40,0,0,0 %;
literal HWRPB_CTBT$S_XMIT_VECTOR = 8;   !  SCB vec of Xmit interrupts
macro HWRPB_CTBT$IL_XMIT_VECTOR_L = 40,0,32,0 %;
macro HWRPB_CTBT$IL_XMIT_VECTOR_H = 44,0,32,0 %;
macro HWRPB_CTBT$IQ_RCV_VECTOR = 48,0,0,0 %;
literal HWRPB_CTBT$S_RCV_VECTOR = 8;    !  SCB vec of Receive interrupts
macro HWRPB_CTBT$IL_RCV_VECTOR_L = 48,0,32,0 %;
macro HWRPB_CTBT$IL_RCV_VECTOR_H = 52,0,32,0 %;
macro HWRPB_CTBT$IQ_BAUD = 56,0,0,0 %;
literal HWRPB_CTBT$S_BAUD = 8;          !  Terminal Baud Rate in decimal
macro HWRPB_CTBT$IL_BAUD_L = 56,0,32,0 %;
macro HWRPB_CTBT$IL_BAUD_H = 60,0,32,0 %;
macro HWRPB_CTBT$IQ_PUTS_STATUS = 64,0,0,0 %;
literal HWRPB_CTBT$S_PUTS_STATUS = 8;   !  Extended Error status on last PUTS
macro HWRPB_CTBT$IL_PUTS_STATUS_L = 64,0,32,0 %;
macro HWRPB_CTBT$IL_PUTS_STATUS_H = 68,0,32,0 %;
macro HWRPB_CTBT$IQ_GETC_STATUS = 72,0,0,0 %;
literal HWRPB_CTBT$S_GETC_STATUS = 8;   !  Extended Error status on last GETC
macro HWRPB_CTBT$IL_GETC_STATUS_L = 72,0,32,0 %;
macro HWRPB_CTBT$IL_GETC_STATUS_H = 76,0,32,0 %;
! 
!      - Workstation portion
! 
macro HWRPB_CTB$R_CTBWSDEF = 32,0,0,0 %;
literal HWRPB_CTBWS$S_CTBWSDEF = 320;
macro HWRPB_CTBWS$IQ_IPL = 32,0,0,0 %;
literal HWRPB_CTBWS$S_IPL = 8;          !  IPL
macro HWRPB_CTBWS$IL_IPL_L = 32,0,32,0 %;
macro HWRPB_CTBWS$IL_IPL_H = 36,0,32,0 %;
macro HWRPB_CTBWS$IQ_XMIT_VECTOR = 40,0,0,0 %;
literal HWRPB_CTBWS$S_XMIT_VECTOR = 8;  !  Transmit SCB vector
macro HWRPB_CTBWS$IL_XMIT_VECTOR_L = 40,0,32,0 %;
macro HWRPB_CTBWS$IL_XMIT_VECTOR_H = 44,0,32,0 %;
macro HWRPB_CTBWS$IQ_REC_VECTOR = 48,0,0,0 %;
literal HWRPB_CTBWS$S_REC_VECTOR = 8;   !  Recieve SCB vector
macro HWRPB_CTBWS$IL_REC_VECTOR_L = 48,0,32,0 %;
macro HWRPB_CTBWS$IL_REC_VECTOR_H = 52,0,32,0 %;
macro HWRPB_CTBWS$IQ_TERM_TYPE = 56,0,0,0 %;
literal HWRPB_CTBWS$S_TERM_TYPE = 8;    !  Terminal Type
macro HWRPB_CTBWS$IL_TERM_TYPE_L = 56,0,32,0 %;
macro HWRPB_CTBWS$IL_TERM_TYPE_H = 60,0,32,0 %;
macro HWRPB_CTBWS$IQ_KB_TYPE = 64,0,0,0 %;
literal HWRPB_CTBWS$S_KB_TYPE = 8;      !  Keyboard type
macro HWRPB_CTBWS$IL_KB_TYPE_L = 64,0,32,0 %;
macro HWRPB_CTBWS$IL_KB_TYPE_H = 68,0,32,0 %;
macro HWRPB_CTBWS$IQ_KB_TRN_TABLE = 72,0,0,0 %;
literal HWRPB_CTBWS$S_KB_TRN_TABLE = 8; !  Keyboard Translation
macro HWRPB_CTBWS$IL_KB_TRN_TABLE_L = 72,0,32,0 %;
macro HWRPB_CTBWS$IL_KB_TRN_TABLE_H = 76,0,32,0 %;
macro HWRPB_CTBWS$IQ_KB_MAP_TABLE = 80,0,0,0 %;
literal HWRPB_CTBWS$S_KB_MAP_TABLE = 8; !  Keyboard Map Table 
macro HWRPB_CTBWS$IL_KB_MAP_TABLE_L = 80,0,32,0 %;
macro HWRPB_CTBWS$IL_KB_MAP_TABLE_H = 84,0,32,0 %;
macro HWRPB_CTBWS$IQ_KEYB_STATE = 88,0,0,0 %;
literal HWRPB_CTBWS$S_KEYB_STATE = 8;   !  Keyboard state
macro HWRPB_CTBWS$IL_KEYB_STATE_L = 88,0,32,0 %;
macro HWRPB_CTBWS$IL_KEYB_STATE_H = 92,0,32,0 %;
macro HWRPB_CTBWS$IQ_LAST_KEY = 96,0,0,0 %;
literal HWRPB_CTBWS$S_LAST_KEY = 8;     !  Last key down
macro HWRPB_CTBWS$IL_LAST_KEY_L = 96,0,32,0 %;
macro HWRPB_CTBWS$IL_LAST_KEY_H = 100,0,32,0 %;
macro HWRPB_CTBWS$IQ_USFNT_PTR = 104,0,0,0 %;
literal HWRPB_CTBWS$S_USFNT_PTR = 8;    !  US font table pointer
macro HWRPB_CTBWS$IL_USFNT_PTR_L = 104,0,32,0 %;
macro HWRPB_CTBWS$IL_USFNT_PTR_H = 108,0,32,0 %;
macro HWRPB_CTBWS$IQ_DMFNT_PTR = 112,0,0,0 %;
literal HWRPB_CTBWS$S_DMFNT_PTR = 8;    !  DMCS font table pointer
macro HWRPB_CTBWS$IL_DMFNT_PTR_L = 112,0,32,0 %;
macro HWRPB_CTBWS$IL_DMFNT_PTR_H = 116,0,32,0 %;
macro HWRPB_CTBWS$IQ_FONT_WIDTH = 120,0,0,0 %;
literal HWRPB_CTBWS$S_FONT_WIDTH = 8;   !  Font width in pixels
macro HWRPB_CTBWS$IL_FONT_WIDTH_L = 120,0,32,0 %;
macro HWRPB_CTBWS$IL_FONT_WIDTH_H = 124,0,32,0 %;
macro HWRPB_CTBWS$IQ_FONT_HGHT = 128,0,0,0 %;
literal HWRPB_CTBWS$S_FONT_HGHT = 8;    !  Font height in pixels
macro HWRPB_CTBWS$IL_FONT_HGHT_L = 128,0,32,0 %;
macro HWRPB_CTBWS$IL_FONT_HGHT_H = 132,0,32,0 %;
macro HWRPB_CTBWS$IQ_MON_WIDTH = 136,0,0,0 %;
literal HWRPB_CTBWS$S_MON_WIDTH = 8;    !  Monitor width in pixels -1
macro HWRPB_CTBWS$IL_MON_WIDTH_L = 136,0,32,0 %;
macro HWRPB_CTBWS$IL_MON_WIDTH_H = 140,0,32,0 %;
macro HWRPB_CTBWS$IQ_MON_HGHT = 144,0,0,0 %;
literal HWRPB_CTBWS$S_MON_HGHT = 8;     !  Monitor height in scanlines -1
macro HWRPB_CTBWS$IL_MON_HGHT_L = 144,0,32,0 %;
macro HWRPB_CTBWS$IL_MON_HGHT_H = 148,0,32,0 %;
macro HWRPB_CTBWS$IQ_MON_DENS = 152,0,0,0 %;
literal HWRPB_CTBWS$S_MON_DENS = 8;     !  Monitor density in pixels -1
macro HWRPB_CTBWS$IL_MON_DENS_L = 152,0,32,0 %;
macro HWRPB_CTBWS$IL_MON_DENS_H = 156,0,32,0 %;
macro HWRPB_CTBWS$IQ_PLANE_COUNT = 160,0,0,0 %;
literal HWRPB_CTBWS$S_PLANE_COUNT = 8;  !  Number of planes 
macro HWRPB_CTBWS$IL_PLANE_COUNT_L = 160,0,32,0 %;
macro HWRPB_CTBWS$IL_PLANE_COUNT_H = 164,0,32,0 %;
macro HWRPB_CTBWS$IQ_CURSOR_WIDTH = 168,0,0,0 %;
literal HWRPB_CTBWS$S_CURSOR_WIDTH = 8; !  Character Cell Width
macro HWRPB_CTBWS$IL_CURSOR_WIDTH_L = 168,0,32,0 %;
macro HWRPB_CTBWS$IL_CURSOR_WIDTH_H = 172,0,32,0 %;
macro HWRPB_CTBWS$IQ_CURSOR_HGHT = 176,0,0,0 %;
literal HWRPB_CTBWS$S_CURSOR_HGHT = 8;  !  Character Cell Height
macro HWRPB_CTBWS$IL_CURSOR_HGHT_L = 176,0,32,0 %;
macro HWRPB_CTBWS$IL_CURSOR_HGHT_H = 180,0,32,0 %;
macro HWRPB_CTBWS$IQ_HEAD_COUNT = 184,0,0,0 %;
literal HWRPB_CTBWS$S_HEAD_COUNT = 8;   !  Number of heads supported 
macro HWRPB_CTBWS$IL_HEAD_COUNT_L = 184,0,32,0 %;
macro HWRPB_CTBWS$IL_HEAD_COUNT_H = 188,0,32,0 %;
macro HWRPB_CTBWS$IQ_WIN_UPDWN = 192,0,0,0 %;
literal HWRPB_CTBWS$S_WIN_UPDWN = 8;    !  window up/down 
macro HWRPB_CTBWS$IL_WIN_UPDWN_L = 192,0,32,0 %;
macro HWRPB_CTBWS$IL_WIN_UPDWN_H = 196,0,32,0 %;
macro HWRPB_CTBWS$IQ_HEAD_OFFSET = 200,0,0,0 %;
literal HWRPB_CTBWS$S_HEAD_OFFSET = 8;  !  Offset to heads 
macro HWRPB_CTBWS$IL_HEAD_OFFSET_L = 200,0,32,0 %;
macro HWRPB_CTBWS$IL_HEAD_OFFSET_H = 204,0,32,0 %;
macro HWRPB_CTBWS$IQ_PUT_CHAR_RTN = 208,0,0,0 %;
literal HWRPB_CTBWS$S_PUT_CHAR_RTN = 8; !  pointer to putchar routine
macro HWRPB_CTBWS$IL_PUT_CHAR_RTN_L = 208,0,32,0 %;
macro HWRPB_CTBWS$IL_PUT_CHAR_RTN_H = 212,0,32,0 %;
macro HWRPB_CTBWS$IQ_IO_STATE = 216,0,0,0 %;
literal HWRPB_CTBWS$S_IO_STATE = 8;     !  console I/O state 
macro HWRPB_CTBWS$IL_IO_STATE_L = 216,0,32,0 %;
macro HWRPB_CTBWS$IL_IO_STATE_H = 220,0,32,0 %;
macro HWRPB_CTBWS$IQ_LSTNR_STATE = 224,0,0,0 %;
literal HWRPB_CTBWS$S_LSTNR_STATE = 8;  !  listener state 
macro HWRPB_CTBWS$IL_LSTNR_STATE_L = 224,0,32,0 %;
macro HWRPB_CTBWS$IL_LSTNR_STATE_H = 228,0,32,0 %;
macro HWRPB_CTBWS$IQ_INFO_EXT = 232,0,0,0 %;
literal HWRPB_CTBWS$S_INFO_EXT = 8;     !  address of Extended information 
macro HWRPB_CTBWS$IL_INFO_EXT_L = 232,0,32,0 %;
macro HWRPB_CTBWS$IL_INFO_EXT_H = 236,0,32,0 %;
macro HWRPB_CTBWS$IQ_OPT_CONS_LOC = 240,0,0,0 %;
literal HWRPB_CTBWS$S_OPT_CONS_LOC = 8; !  option console location
macro HWRPB_CTBWS$IL_OPT_CONS_LOC_L = 240,0,32,0 %;
macro HWRPB_CTBWS$IL_OPT_CONS_LOC_H = 244,0,32,0 %;
macro HWRPB_CTBWS$IQ_SERVER_OFFSET = 248,0,0,0 %;
literal HWRPB_CTBWS$S_SERVER_OFFSET = 8; !  server offset
macro HWRPB_CTBWS$IL_SERVER_OFFSET_L = 248,0,32,0 %;
macro HWRPB_CTBWS$IL_SERVER_OFFSET_H = 252,0,32,0 %;
macro HWRPB_CTBWS$IQ_LINE_PARAM = 256,0,0,0 %;
literal HWRPB_CTBWS$S_LINE_PARAM = 8;   !  line parameter
macro HWRPB_CTBWS$IL_LINE_PARAM_L = 256,0,32,0 %;
macro HWRPB_CTBWS$IL_LINE_PARAM_H = 260,0,32,0 %;
!  as the previous ctbws type def (rev x-21)
!  Console types
literal HWRPB_CTB$K_NO_CONSOLE = 0;     !  No console is present
literal HWRPB_CTB$K_SERVICE_CPU = 1;    !  Service processor	
literal HWRPB_CTB$K_TERMINAL = 2;       !  Serial line UART
literal HWRPB_CTB$K_GRAPHIC = 3;        !  Graphic processor
literal HWRPB_CTB$K_WORKSTATION = 4;    !  Integrated Workstation
literal HWRPB_CTB$K_MAXTYPE = 4;
! 
!  Define data structures for Cobra (02) configuration data block
! 
literal CONFIG_02$K_CONFIG_VERSION = 1;
literal CONFIG_02$K_MAX_DEVICES = 16;   !   in device block
literal CONFIG_02$K_LENGTH = 24;        !  Length of CONFIG block
literal CONFIG_02$S_CONFIG_02 = 24;
macro CONFIG_02$Q_SIZE = 0,0,0,0 %;
literal CONFIG_02$S_SIZE = 8;           !  Size of CONFIG block
macro CONFIG_02$Q_CHECKSUM = 8,0,0,0 %;
literal CONFIG_02$S_CHECKSUM = 8;       !  Checksum of CONFIG block
macro CONFIG_02$L_VERSION = 16,0,32,0 %; !  Version
macro CONFIG_02$L_NUM_DEVICES = 20,0,32,0 %; !  Number of devices present
macro CONFIG_02$B_DEVICE_02 = 24,0,0,0 %; !  First byte of DEVICE block
! 
!  Define data structures for Cobra (02) device block
! 
literal DEVICE_02$K_TYPE_NONE = 0;
literal DEVICE_02$K_TYPE_NCR53C710_SCSI = 1;
literal DEVICE_02$K_TYPE_TGEC = 2;
literal DEVICE_02$K_TYPE_PCD8584 = 9;
literal DEVICE_02$K_TYPE_NCR53C710_DSSI = 10;
literal DEVICE_02$M_SA = %X'1';
literal DEVICE_02$M_SE = %X'2';
literal DEVICE_02$M_HW = %X'4';
literal DEVICE_02$K_LENGTH = 32;
literal DEVICE_02$S_DEVICE_02 = 32;
macro DEVICE_02$B_HOSE = 0,0,8,0 %;     !  Hose number of this device
macro DEVICE_02$B_SLOT = 1,0,8,0 %;     !  Slot number of this device
macro DEVICE_02$W_NUM_VECTOR = 2,0,16,0 %; !  Number of vector for device
macro DEVICE_02$W_VMS_VECTOR = 4,0,16,0 %; !  VMS SCB vector for device
macro DEVICE_02$W_OSF_VECTOR = 6,0,16,0 %; !  OSF SCB vector for device
macro DEVICE_02$L_TYPE = 8,0,32,0 %;    !  Type of device
macro DEVICE_02$L_VERSION = 12,0,32,0 %; !  Version of device block
macro DEVICE_02$Q_SPECIFIC_MAX = 16,0,0,0 %;
literal DEVICE_02$S_SPECIFIC_MAX = 16;
macro DEVICE_02$B_SCSI_ID = 16,0,8,0 %; !  SCSI bus id of controller
macro DEVICE_02$B_FAST = 17,0,8,0 %;    !  Fast SCSI enable
macro DEVICE_02$B_DSSI_ID = 16,0,8,0 %; !  DSSI bus id of controller
macro DEVICE_02$B_SA = 16,0,0,0 %;
literal DEVICE_02$S_SA = 6;             !  Ethernet hardware address
macro DEVICE_02$V_SA = 22,0,1,0 %;      !  Sync/Async enable
macro DEVICE_02$V_SE = 22,1,1,0 %;      !  Single cycle enable
macro DEVICE_02$V_HW = 22,2,1,0 %;      !  Hexaword enable
macro DEVICE_02$B_BURST = 23,0,8,0 %;   !  Burst length in bytes
 
!*** MODULE $HWSCBDEF ***
! 
!  System Control Block Entry Definitions.  The system control block (SCB)
!  specifies the entry points for exception and interrupt service routines.
!  The first quadword is the virtual address of the service routine associated
!  with that entry.  The second quadword is an arbitrary parameter to be passed
!  to the service routine.  The parameter for EVMS for most exceptions and 
!  interrupts is the virtual address of the procedure descrtor for the service
!  routine.
!  
literal HWSCB$K_VECTOR = 0;             !  Entry point address
literal HWSCB$K_PARAMETER = 8;          !  Arbitrary parameter
literal HWSCB$Q_UNUSED_00 = 0;          !  %X00 Unused vector
literal HWSCB$Q_FLOAT_FAULT = 16;       !  %X10 Floating disabled fault
literal HWSCB$Q_UNUSED_20 = 32;         !  %X20 Unused vector 
literal HWSCB$Q_UNUSED_30 = 48;         !  %X30 Unused vector 
literal HWSCB$Q_UNUSED_40 = 64;         !  %X40 Unused vector 
literal HWSCB$Q_UNUSED_50 = 80;         !  %X50 Unused vector 
literal HWSCB$Q_UNUSED_60 = 96;         !  %X60 Unused vector 
literal HWSCB$Q_UNUSED_70 = 112;        !  %X70 Unused vector 
literal HWSCB$Q_ACCVIO = 128;           !  %X80 Access control violation fault
literal HWSCB$Q_TRANSLATION_FAULT = 144; !  %X90 Translation not valid fault
literal HWSCB$Q_READ_FAULT = 160;       !  %XA0 Fault on read fault
literal HWSCB$Q_WRITE_FAULT = 176;      !  %XB0 Fault on write fault
literal HWSCB$Q_EXECUTE_FAULT = 192;    !  %XC0 Fault on execute fault
literal HWSCB$Q_ARITHMETIC_TRAP = 512;  !  %X200 Arithmetic trap
literal HWSCB$Q_KERNEL_AST = 576;       !  %X240 Kernel mode AST
literal HWSCB$Q_EXEC_AST = 592;         !  %X250 Exec mode AST
literal HWSCB$Q_SUPER_AST = 608;        !  %X260 Super mode AST
literal HWSCB$Q_USER_AST = 624;         !  %X270 User mode AST
literal HWSCB$Q_REPORT_ALIGN_FAULT = 640; !  %X280 Report alignment fault
literal HWSCB$Q_UNUSED_290 = 656;       !  %X290 Unused vector 
literal HWSCB$Q_UNUSED_2A0 = 672;       !  %X2A0 Unused vector
literal HWSCB$Q_UNUSED_2B0 = 688;       !  %X2B0 Unused vector
literal HWSCB$Q_UNUSED_2C0 = 704;       !  %X2C0 Unused vector
literal HWSCB$Q_UNUSED_2D0 = 720;       !  %X2D0 Unused vector
literal HWSCB$Q_UNUSED_2E0 = 736;       !  %X2E0 Unused vector
literal HWSCB$Q_UNUSED_2F0 = 752;       !  %X2F0 Unused vector
literal HWSCB$Q_LOAD_F_FLOAT = 768;     !  %X300 Load F floating
literal HWSCB$Q_LOAD_D_FLOAT = 784;     !  %X310 Load D floating
literal HWSCB$Q_LOAD_S_FLOAT = 800;     !  %X320 Load S floating
literal HWSCB$Q_LOAD_T_FLOAT = 816;     !  %X330 Load T floating
literal HWSCB$Q_STORE_F_FLOAT = 832;    !  %X340 Store F floating
literal HWSCB$Q_STORE_D_FLOAT = 848;    !  %X350 Store D floating
literal HWSCB$Q_STORE_S_FLOAT = 864;    !  %X360 Store S floating
literal HWSCB$Q_STORE_T_FLOAT = 880;    !  %X370 Store T floating
literal HWSCB$Q_LOAD_SEXT_LONG = 896;   !  %X380 Load sign-extended longword
literal HWSCB$Q_LOAD_QUAD = 912;        !  %X390 Load quadword
literal HWSCB$Q_LOAD_SEXT_LONG_L = 928; !  %X3A0 Load sign-extended longword locked
literal HWSCB$Q_LOAD_QUAD_L = 944;      !  %X3B0 Load quadword locked
literal HWSCB$Q_STORE_LONG = 960;       !  %X3C0 Store longword
literal HWSCB$Q_STORE_QUAD = 976;       !  %X3D0 Store quadword
literal HWSCB$Q_STORE_LONG_C = 992;     !  %X3E0 Store longword conditional
literal HWSCB$Q_STORE_QUAD_C = 1008;    !  %X3F0 Store quadword conditional
literal HWSCB$Q_BREAK_POINT = 1024;     !  %X400 Break point trap
literal HWSCB$Q_BUG_CHECK = 1040;       !  %X410 Bug check trap
literal HWSCB$Q_ILLEGAL_INSTRUCTION = 1056; !  %X420 Illegal instruction trap
literal HWSCB$Q_ILLEGAL_PAL_OPERAND = 1072; !  %X430 Illegal call PAL operand
literal HWSCB$Q_GENTRAP = 1088;         !  %X440 Software generated trap
literal HWSCB$Q_UNUSED_450 = 1104;      !  %X450 Unused vector
literal HWSCB$Q_UNUSED_460 = 1120;      !  %X460 Unused vector
literal HWSCB$Q_UNUSED_470 = 1136;      !  %X470 Unused vector
literal HWSCB$Q_CHANGE_MODE_KERNEL = 1152; !  %X480 Change mode to kernel
literal HWSCB$Q_CHANGE_MODE_EXEC = 1168; !  %X490 Change mode to exec
literal HWSCB$Q_CHANGE_MODE_SUPER = 1184; !  %X4A0 Change mode to super
literal HWSCB$Q_CHANGE_MODE_USER = 1200; !  %X4B0 Change mode to user
literal HWSCB$Q_DIGITAL_1 = 1216;       !  %X4C0 Reserved for Digital
literal HWSCB$Q_DIGITAL_2 = 1232;       !  %X4D0 Reserved for Digital
literal HWSCB$Q_DIGITAL_3 = 1248;       !  %X4E0 Reserved for Digital
literal HWSCB$Q_DIGITAL_4 = 1264;       !  %X4F0 Reserved for Digital
literal HWSCB$Q_UNUSED_500 = 1280;      !  %X500 Unused
literal HWSCB$Q_SOFT_INTERRUPT_1 = 1296; !  %X510 Software level 1 interrupt
literal HWSCB$Q_SOFT_INTERRUPT_2 = 1312; !  %x520 Software level 2 interrupt
literal HWSCB$Q_SOFT_INTERRUPT_3 = 1328; !  %X530 Software level 3 interrupt
literal HWSCB$Q_SOFT_INTERRUPT_4 = 1344; !  %X540 Software level 4 interrupt
literal HWSCB$Q_SOFT_INTERRUPT_5 = 1360; !  %X550 Software level 5 interrupt
literal HWSCB$Q_SOFT_INTERRUPT_6 = 1376; !  %X560 Software level 6 interrupt
literal HWSCB$Q_SOFT_INTERRUPT_7 = 1392; !  %X570 Software level 7 interrupt
literal HWSCB$Q_SOFT_INTERRUPT_8 = 1408; !  %X580 Software level 8 interrupt
literal HWSCB$Q_SOFT_INTERRUPT_9 = 1424; !  %X590 Software level 9 interrupt
literal HWSCB$Q_SOFT_INTERRUPT_10 = 1440; !  %X5A0 Software level 10 interrupt
literal HWSCB$Q_SOFT_INTERRUPT_11 = 1456; !  %X5B0 Software level 11 interrupt
literal HWSCB$Q_SOFT_INTERRUPT_12 = 1472; !  %X5C0 Software level 12 interrupt
literal HWSCB$Q_SOFT_INTERRUPT_13 = 1488; !  %X5D0 Software level 13 interrupt
literal HWSCB$Q_SOFT_INTERRUPT_14 = 1504; !  %X5E0 Software level 14 interrupt
literal HWSCB$Q_SOFT_INTERRUPT_15 = 1520; !  %X5F0 Software level 15 interrupt
literal HWSCB$Q_RESCHEDULE = 1328;      !  Reschedule interrupt
literal HWSCB$Q_IO_POST = 1344;         !  I/O post interrupt
literal HWSCB$Q_SW_TIMER_INTERRUPT = 1392; !  Software timer interrupt
literal HWSCB$Q_IP_CONTROL = 1472;      !  IP control
literal HWSCB$Q_XDELTA = 1504;          !  Xdelta
literal HWSCB$Q_INTERVAL_CLOCK = 1536;  !  %X600 Interval clock interrupt
literal HWSCB$Q_INTERPROCESSOR = 1552;  !  %X610 Interprocessor interrupt
literal HWSCB$Q_SYSTEM_CORRECTED_ERROR = 1568; !  %X620 System corrected error interrupt
literal HWSCB$Q_PROCESS_CORRECTED_ERROR = 1584; !  %X630 Processor corrected error interrupt
literal HWSCB$Q_POWER_FAIL = 1600;      !  %X640 Power fail interrupt
literal HWSCB$Q_PERF_MONITOR = 1616;    !  %X650 Reserved for performance monitor
literal HWSCB$Q_SYSTEM_MACHINE_CHECK = 1632; !  %X660 System machine check abort
literal HWSCB$Q_PROCESSOR_MACHINE_CHECK = 1648; !  %X670 Processor machine check abort
literal HWSCB$Q_PROCESSOR_SPECIFIC_1 = 1664; !  %X680 Reserved - processor specific
literal HWSCB$Q_PROCESSOR_SPECIFIC_2 = 1680; !  %X690 Reserved - processor specific
literal HWSCB$Q_PROCESSOR_SPECIFIC_3 = 1696; !  %X6A0 Reserved - processor specific
literal HWSCB$Q_PROCESSOR_SPECIFIC_4 = 1712; !  %X6B0 Reserved - processor specific
literal HWSCB$Q_IO_INTERRUPT_BASE = 2048; !  %X800 
 
!*** MODULE $IAFDEF ***
! +
!  IAF - IMAGE ACTIVATOR FIXUP SECTION
! 
!  THE IMAGE ACTIVATOR FIXUP SECTION IS AN IMAGE SECTION THAT IS CREATED
!  BY THE LINKER AND USED BY THE IMAGE ACTIVATOR TO MODIFY THE IMAGE AS
!  IT IS ACTIVATED.  THIS IS DONE TO MAINTAIN THE POSITION INDEPENDENCE
!  OF EXTERNAL REFERENCES.
! -
literal IAF$K_LENGTH = 64;              !  Length of fixed area 
literal IAF$C_LENGTH = 64;              !  Length of fixed area 
literal IAF$S_IAFDEF = 64;
literal IAF$S_IAF = 64;
macro IAF$L_IAFLINK = 0,0,32,1 %;       !  Link for image activator use 
macro IAF$L_FIXUPLNK = 4,0,32,1 %;      !  Link for shareable image fixups 
macro IAF$W_SIZE = 8,0,16,0 %;          !  Size of fixed part of IAF 
macro IAF$W_FLAGS = 10,0,16,0 %;        !  Flags 
macro IAF$V_SHR = 10,0,1,0 %;           !  This is in a shareable image 
macro IAF$L_G_FIXOFF = 12,0,32,0 %;     !  Offset to g^ address data 
macro IAF$L_DOTADROFF = 16,0,32,0 %;    !  Offset to .address fixup data 
macro IAF$L_CHGPRTOFF = 20,0,32,0 %;    !  Offset to isect change prot. data 
macro IAF$L_SHLSTOFF = 24,0,32,0 %;     !  Offset to shareable image list 
macro IAF$L_SHRIMGCNT = 28,0,32,0 %;    !  Number of shareable images in shlst 
macro IAF$L_SHLEXTRA = 32,0,32,0 %;     !  Number of extra shareable images allowed 
macro IAF$L_PERMCTX = 36,0,32,1 %;      !  Permanent sharable image context 
 
!*** MODULE $ICPDEF ***
! +
!  ICP - CHANGE IMAGE SECTION PROTECTION DATA
! 
!  THIS STRUCTURE IS USED IN THE IMAGE FIXUP SECTION BY THE LINKER
!  TO INFORM THE IMAGE ACTIVATOR OF THE IMAGE SECTIONS THAT NEED
!  THEIR PROTECTION CHANGED.
! -
literal ICP$K_LENGTH = 8;               !  size of one section's data 
literal ICP$C_LENGTH = 8;               !  size of one section's data 
literal ICP$S_ICPDEF = 8;
literal ICP$S_ICP = 8;
macro ICP$L_BASEVA = 0,0,32,1 %;        !  virtual address of start of section 
macro ICP$W_NPAGES = 4,0,16,0 %;        !  number of pages to change protection on 
macro ICP$W_NEWPRT = 6,0,16,0 %;        !  new protection 
 
!*** MODULE $IDBDEF ***
! +
!  IDB - INTERRUPT DISPATCH BLOCK
! 
!  AN INTERRUPT DISPATCH BLOCK PROVIDES THE INFORMATION NECESSARY FOR A
!  UNIT INDEPENDENT, BUT CONTROLLER SPECIFIC, INTERRUPT DISPATCHER TO
!  DISPATCH INTERRUPTS TO THE PROPER DRIVER TO HANDLE AN INTERRUPT ON
!  A DEVICE UNIT.
! -
literal IDB$M_CRAM_ALLOC = %X'1';
literal IDB$M_VLE = %X'2';
literal IDB$M_NORESIZE = %X'4';
literal IDB$M_MCJ = %X'8';
literal IDB$K_BASE_LENGTH = 56;         ! length without UCBLST
literal IDB$C_BASE_LENGTH = 56;         ! length without UCBLST
literal IDB$S_IDB = 88;
macro IDB$Q_CSR = 0,0,0,0 %;
literal IDB$S_CSR = 8;                  ! CONTROLLER CSR "ADDRESS"
macro IDB$W_SIZE = 8,0,16,0 %;          ! SIZE OF IDB IN BYTES 
macro IDB$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE OF IDB 
macro IDB$W_UNITS = 12,0,16,0 %;        ! NUMBER OF UNITS (SIZE OF UCBLST) 
macro IDB$W_TT_ENABLE = 14,0,16,0 %;    !  DZ32 line enable field
macro IDB$PS_OWNER = 16,0,32,1 %;       ! OWNER UCB ADDRESS 
macro IDB$PS_CRAM = 20,0,32,1 %;        ! Per-controller CRAM list
macro IDB$PS_SPL = 24,0,32,1 %;         ! ADDRESS OF DEVICE SPINLOCK
macro IDB$PS_ADP = 28,0,32,1 %;         ! ADDRESS OF ADAPTER CONTROL BLOCK 
macro IDB$L_FLAGS = 32,0,32,0 %;        !  IDB flags
macro IDB$V_CRAM_ALLOC = 32,0,1,0 %;    !  $LOAD_DRIVER has done CRAM allocation for this IDB
macro IDB$V_VLE = 32,1,1,0 %;           !  IDB$L_VECTOR points to a VLE
macro IDB$V_NORESIZE = 32,2,1,0 %;      !  IDB isn't in pool and shouldn't be resized
macro IDB$V_MCJ = 32,3,1,0 %;           !  IDB$Q_CSR points to an MCJ
macro IDB$L_DEVICE_SPECIFIC = 36,0,32,0 %; ! Available to device drivers
macro IDB$L_VECTOR = 40,0,32,1 %;       ! SCB offset for interrupts
macro IDB$PS_AUXSTRUC = 44,0,32,1 %;    ! driver specific data
macro IDB$Q_RESERVED = 48,0,0,0 %;
literal IDB$S_RESERVED = 8;             ! ...for future expansion
macro IDB$L_UCBLST = 56,0,0,1 %;
literal IDB$S_UCBLST = 32;              ! UCB OR SECONDARY IDB ADDRESSES 
! (DEFAULT OF 8)
literal IDB$K_LENGTH = 88;              ! LENGTH OF STANDARD IDB 
literal IDB$C_LENGTH = 88;              ! LENGTH OF STANDARD IDB 
literal IDB$S_IDBDEF = 88;              ! OLD IDB SIZE FOR COMPATIBILITY
 
!*** MODULE $IFDDEF ***
! +
!  IMAGE FILE DESCRIPTOR BLOCK - RETURNED BY IMAGE ACTIVATOR
! -
literal IFD$M_EXEONLY = %X'1';
literal IFD$M_PRIV = %X'2';
literal IFD$M_SETVECTOR = %X'4';
literal IFD$K_LENGTH = 28;              ! LENGTH OF FIXED AREA OF IFD 
literal IFD$C_LENGTH = 28;              ! LENGTH OF FIXED AREA OF IFD 
literal IFD$S_IFDDEF = 28;
literal IFD$S_IFD = 28;
macro IFD$W_SIZE = 0,0,16,0 %;          ! SIZE IN BYTES OF IMAGE FILE DESCRIPTOR 
macro IFD$W_FILNAMOFF = 2,0,16,0 %;     ! OFFSET TO ASCIC
! FULLY QUALIFIED FILE SPEC
macro IFD$W_CHAN = 8,0,16,0 %;          ! CHANNEL ON WHICH IMAGE FILE IS OPEN 
macro IFD$W_CMCHAN = 10,0,16,0 %;       ! COMPATIBILITY MODE CHANNEL 
macro IFD$L_CMKFIADR = 12,0,32,1 %;     ! COMPATIBILITY MODE IMAGE 
! KNOWN FILE ENTRY ADDRESS OR 0
macro IFD$W_FLAGS = 16,0,16,0 %;        ! IMAGE FILE DESCRIPTOR FLAGS 
macro IFD$V_EXEONLY = 16,0,1,0 %;       ! EXECUTE ONLY FILE 
macro IFD$V_PRIV = 16,1,1,0 %;          ! IMAGE INSTALLED WITH ENHANCED PRIVILEGE 
macro IFD$V_SETVECTOR = 16,2,1,0 %;     ! PRIVILEGED VECTORS TO BE INSTALLED 
macro IFD$Q_CURPROG = 20,0,0,0 %;
literal IFD$S_CURPROG = 8;              ! STRING DESCRIPTOR FOR 
! FULLY QUALIFIED FILE SPEC OF
! RUNNING PROGRAM
 
!*** MODULE $IHDDEF ***
! +
!  IMAGE HEADER RECORD DEFINITIONS - FIRST RECORD OF IMAGE HEADER
! -
literal IHD$K_MAJORID = 12848;          !  Major id value 
literal IHD$K_MINORID = 13616;          !  Minor id value 
literal IHD$K_EXE = 1;                  !  Executable image 
literal IHD$K_LIM = 2;                  !  Linkable image 
literal IHD$M_LNKDEBUG = %X'1';
literal IHD$M_LNKNOTFR = %X'2';
literal IHD$M_NOP0BUFS = %X'4';
literal IHD$M_PICIMG = %X'8';
literal IHD$M_P0IMAGE = %X'10';
literal IHD$M_DBGDMT = %X'20';
literal IHD$M_INISHR = %X'40';
literal IHD$M_IHSLONG = %X'80';
literal IHD$M_MATCHCTL = %X'7000000';
literal IHD$K_LENGTH = 48;              !  Length of fixed area 
literal IHD$C_LENGTH = 48;              !  Length of fixed area 
literal IHD$C_MINCODE = -1;             !  Low bound of ALIAS values
literal IHD$C_NATIVE = -1;              !  Native mode image
literal IHD$C_RSX = 0;                  !  RSX image produced by TKB
literal IHD$C_BPA = 1;                  !  BASIC plus analog
literal IHD$C_ALIAS = 2;                !  Last 126 bytes contains ASCIC of image to activate
literal IHD$C_CLI = 3;                  !  Image is a CLI, run LOGINOUT
literal IHD$C_PMAX = 4;                 !  PMAX system image
literal IHD$C_ALPHA = 5;                !  ALPHA image
literal IHD$C_MAXCODE = 5;              !  High bound of ALIAS values
! 
literal IHD$C_GEN_XLNKR = 1;            !  Cross linker
literal IHD$C_GEN_NATIVE = 2;           !  First native mode image header.
!   does not have LNKFLAGS, SYSVER and IAFVA fields
literal IHD$C_GEN_LNKFLG = 3;           !  Native with LNKFLAGS longword added
!   does not have SYSVER and IAFVA fields
literal IHD$C_GEN_SYSVER = 4;           !  Native with LNKFLAGS and SYSVER added
!   does not have IAFVA field
literal IHD$C_GEN_FIXUP = 5;            !  Version III image
!   contains LNKFLAGS, SYSVER, and IAFVA fields
literal IHD$C_GEN_NEWISD = 6;           !  ISD size field is a byte
literal IHD$S_IHDDEF = 512;             !  Old size name - synonym
literal IHD$S_IHD = 512;
macro IHD$W_SIZE = 0,0,16,0 %;          !  Size in bytes of Image Header record 
macro IHD$W_ACTIVOFF = 2,0,16,0 %;      !  Byte offset to activation data 
macro IHD$W_SYMDBGOFF = 4,0,16,0 %;     !  Byte offset to symbol table and debug data 
macro IHD$W_IMGIDOFF = 6,0,16,0 %;      !  Byte offset to image ident data 
macro IHD$W_PATCHOFF = 8,0,16,0 %;      !  Byte offset to patch data 
macro IHD$W_VERSION_ARRAY_OFF = 10,0,16,0 %; !  Byte offset to version number array
macro IHD$W_MAJORID = 12,0,16,0 %;      !  Major id 
macro IHD$W_MINORID = 14,0,16,0 %;      !  Minor id 
macro IHD$B_HDRBLKCNT = 16,0,8,0 %;     !  Count of header blocks 
macro IHD$B_IMGTYPE = 17,0,8,0 %;       !  Image type 
! 
!  IMAGE TYPE CODES
! 
macro IHD$Q_PRIVREQS = 20,0,0,0 %;
literal IHD$S_PRIVREQS = 8;             !  Requested privilege mask 
macro IHD$W_IOCHANCNT = 28,0,16,0 %;    ! ! of channels requested 
! 0 if default
macro IHD$W_IMGIOCNT = 30,0,16,0 %;     ! ! of pages of image i/o section requested 
! 0 if default
macro IHD$R_LNKFLAGS_OVERLAY = 32,0,32,0 %;
macro IHD$L_LNKFLAGS = 32,0,32,0 %;     !  Linker produced image flags 
macro IHD$R_LNKFLAGS_BITS = 32,0,32,0 %;
macro IHD$V_LNKDEBUG = 32,0,1,0 %;      !  Full debugging requested 
macro IHD$V_LNKNOTFR = 32,1,1,0 %;      !  First transfer address missing 
macro IHD$V_NOP0BUFS = 32,2,1,0 %;      !  RMS use of P0 for image i/o disabled 
macro IHD$V_PICIMG = 32,3,1,0 %;        !  Image is position independent 
macro IHD$V_P0IMAGE = 32,4,1,0 %;       !  Image is in P0 space only 
macro IHD$V_DBGDMT = 32,5,1,0 %;        !  Image header has dmt fields
macro IHD$V_INISHR = 32,6,1,0 %;        !  Transfer array contains valid IHA$L_INISHR
macro IHD$V_IHSLONG = 32,7,1,0 %;       !  Longword DSTBLKS and GSTRECS valid in IHS$
macro IHD$V_MATCHCTL = 32,24,3,0 %;
literal IHD$S_MATCHCTL = 3;             !  Match control for linkable image
macro IHD$L_IDENT = 36,0,32,0 %;        !  GBL SEC ident value for linkable image 
macro IHD$L_SYSVER = 40,0,32,0 %;       !  SYS$K_VERSION or 0 if not linked with exec 
macro IHD$L_IAFVA = 44,0,32,1 %;        !  Relative virtual address of fixup info 
macro IHD$T_SKIP = 48,0,0,0 %;
literal IHD$S_SKIP = 462;               !  ALIAS should be last word in 512 byte block
macro IHD$W_ALIAS = 510,0,16,0 %;       !  Code to use secondary image name
! *****************************************
! 
!   Define legal range of ALIAS constants. MINCODE must be equal to the
! 	lowest value and MAXCODE must be equal to the highest value.
! 
! ******************************************
! 
! 	Generation number returned by IMGSHR IMG$GET_IHD to SYSIMGACT.
! 	These do not appear in the image header but are inferred from the 
! 	contents of the image header
! 
 
!*** MODULE $IHADEF ***
! +
!  IMAGE HEADER ACTIVATION SECTION OFFSETS
! -
literal IHA$K_LENGTH = 20;              ! SIZE OF ACTIVATION SECTION 
literal IHA$C_LENGTH = 20;              ! SIZE OF ACTIVATION SECTION 
literal IHA$S_IHADEF = 20;
literal IHA$S_IHA = 20;
macro IHA$L_TFRADR1 = 0,0,32,0 %;       ! FIRST TRANSFER ADDRESS 
macro IHA$L_TFRADR2 = 4,0,32,0 %;       ! SECOND TRANSFER ADDRESS 
macro IHA$L_TFRADR3 = 8,0,32,0 %;       ! THIRD TRANSFER ADDRESS 
macro IHA$L_INISHR = 16,0,32,0 %;       ! SHARED IMAGE INITIALIZATION
! (valid if IHD$V_INISHR set)
 
!*** MODULE $IHPDEF ***
! +
!  IMAGE HEADER PATCH SECTION OFFSETS
! -
literal IHP$K_LENGTH = 44;              ! LENGTH OF PATCH HEADER SECTION 
literal IHP$C_LENGTH = 44;              ! LENGTH OF PATCH HEADER SECTION 
literal IHP$S_IHPDEF = 44;
literal IHP$S_IHP = 44;
macro IHP$L_ECO1 = 0,0,32,0 %;          ! DEC ECO LEVELS 1-32 
macro IHP$L_ECO2 = 4,0,32,0 %;          ! DEC ECO LEVELS 33-64 
macro IHP$L_ECO3 = 8,0,32,0 %;          ! DEC ECO LEVELS 65-98 
macro IHP$L_ECO4 = 12,0,32,0 %;         ! USER ECO LEVELS 99-132 
macro IHP$L_RW_PATSIZ = 16,0,32,0 %;    ! SIZE OF FREE RW PATCH AREA 
macro IHP$L_RW_PATADR = 20,0,32,1 %;    ! VIR ADDR OF NEXT FREE RW PATCH AREA 
macro IHP$L_RO_PATSIZ = 24,0,32,0 %;    ! SIZE OF FREE RO PATCH AREA 
macro IHP$L_RO_PATADR = 28,0,32,1 %;    ! VIR ADDR OF NEXT FREE RO PATCH AREA 
macro IHP$L_PATCOMTXT = 32,0,32,0 %;    ! PATCH COMMAND TEXT VIRTUAL BLOCK NUMBER 
macro IHP$Q_PATDATE = 36,0,0,0 %;
literal IHP$S_PATDATE = 8;              ! DATE OF MOST RECENT PATCH 
 
!*** MODULE $IHSDEF ***
! +
!  IMAGE HEADER SYMBOL TABLE AND DEBUG SECTION OFFSETS
! -
literal IHS$K_LENGTH = 28;              ! LENGTH OF SYMBOL TABLE SECTION 
literal IHS$C_LENGTH = 28;              ! LENGTH OF SYMBOL TABLE SECTION 
literal IHS$S_IHSDEF = 28;
literal IHS$S_IHS = 28;
macro IHS$L_DSTVBN = 0,0,32,0 %;        ! DEBUG SYMBOL TABLE VIRTUAL BLOCK NUMBER 
macro IHS$L_GSTVBN = 4,0,32,0 %;        ! GLOBAL SYMBOL TABLE VIRTUAL BLOCK NUMBER 
macro IHS$W_DSTBLKS = 8,0,16,0 %;       ! DEBUG SYMBOL TABLE BLOCK COUNT 
macro IHS$W_GSTRECS = 10,0,16,0 %;      ! GLOBAL SYMBOL TABLE RECORD COUNT 
macro IHS$L_DMTVBN = 12,0,32,0 %;       ! VBN OF DMT INFORMATION
macro IHS$L_DMTBYTES = 16,0,32,0 %;     ! LENGTH OF DMT INFO
macro IHS$L_DSTBLKS = 20,0,32,1 %;      ! Debug symbol table block count -- LONGWORD
macro IHS$L_GSTRECS = 24,0,32,1 %;      ! Global symbol table record count -- LONGWORD
 
!*** MODULE $IHIDEF ***
! +
!  IMAGE HEADER IDENTIFICATION SECTION OFFSETS
! -
literal IHI$K_LENGTH = 80;              ! LENGTH OF IMAGE HEADER IDENT SECTION 
literal IHI$C_LENGTH = 80;              ! LENGTH OF IMAGE HEADER IDENT SECTION 
literal IHI$S_IHIDEF = 80;
literal IHI$S_IHI = 80;
macro IHI$T_IMGNAM = 0,0,0,0 %;
literal IHI$S_IMGNAM = 40;              ! IMAGE NAME STRING 
macro IHI$T_IMGID = 40,0,0,0 %;
literal IHI$S_IMGID = 16;               ! IMAGE IDENT STRING 
macro IHI$Q_LINKTIME = 56,0,0,0 %;
literal IHI$S_LINKTIME = 8;             ! DATE AND TIME THIS IMAGE WAS LINKED 
! STANDARD SYSTEM QUADWORD FORMAT
macro IHI$T_LINKID = 64,0,0,0 %;
literal IHI$S_LINKID = 16;              ! LINKER IDENT STRING 
 
!*** MODULE $IHVNDEF ***
literal IHVN$M_SUBVERSION_MINOR_ID = %X'FFFF';
literal IHVN$M_SUBVERSION_MAJOR_ID = %X'FFFF0000';
literal IHVN$S_IMG_VERSION_ARRAY = 8;
macro IHVN$L_SUBSYSTEM_MASK = 0,0,32,0 %; !  Bit mask of nonzero version numbers
macro IHVN$L_SUBVERSION_ARRAY = 4,0,32,0 %; !  First array element
macro IHVN$V_SUBVERSION_MINOR_ID = 4,0,16,0 %;
literal IHVN$S_SUBVERSION_MINOR_ID = 16; !  Minor ID for each component
macro IHVN$V_SUBVERSION_MAJOR_ID = 4,16,16,0 %;
literal IHVN$S_SUBVERSION_MAJOR_ID = 16; !  Major ID for each component
literal IHVN$M_VERSION_MINOR_ID = %X'FFFFFF';
literal IHVN$M_VERSION_MAJOR_ID = %X'FF000000';
literal IHVN$S_IMG_OVERALL_VERSION = 4;
macro IHVN$V_VERSION_MINOR_ID = 0,0,24,0 %;
literal IHVN$S_VERSION_MINOR_ID = 24;   !  Minor ID of SYS.STB
macro IHVN$V_VERSION_MAJOR_ID = 0,24,8,0 %;
literal IHVN$S_VERSION_MAJOR_ID = 8;    !  Major ID of SYS.STB
literal IHVN$K_LENGTH = 132;
literal IHVN$C_LENGTH = 132;
 
!*** MODULE $IHXDEF ***
! +
!  IMAGE HEADER RECORD DEFINITIONS - CROSS LINKER - MAJORID = "01"
!          1ST RECORD OF IMAGE HEADER BLOCK
! -
literal IHX$K_MAJORID = 12592;          ! ^A/01/ MAJOR ID VALUE FOR CROSS LINKER 
literal IHX$K_MINORID = 12592;          ! ^A/01/ MINOR ID VALUE FOR CROSS LINKER 
literal IHX$K_MINORID1 = 12592;         ! ^A/01/ MINOR ID VALUE FOR CROSS LINKER WITH 
! SYMBOL TABLE AND 3RD TRANSFER ADR
literal IHX$K_LENGTH = 56;              ! LENGTH OF CROSS LINKER HEADER 
literal IHX$C_LENGTH = 56;              ! LENGTH OF CROSS LINKER HEADER 
literal IHX$S_IHXDEF = 56;
literal IHX$S_IHX = 56;
macro IHX$W_SIZE = 0,0,16,0 %;          ! SIZE IN BYTE OF IMAGE HEADER RECORD 
macro IHX$B_HDRBLKCNT = 2,0,8,0 %;      ! COUNT OF BLOCKS IN IMAGE HEADER 
macro IHX$Q_STARTADR = 4,0,0,0 %;
literal IHX$S_STARTADR = 8;             ! START ADDRESS 
macro IHX$W_MAJORID = 12,0,16,0 %;      ! MAJOR ID OF IMAGE HEADER 
macro IHX$W_MINORID = 14,0,16,0 %;      ! MINOR ID OF IMAGE HEADER 
macro IHX$T_IMGNAM = 16,0,0,0 %;
literal IHX$S_IMGNAM = 24;              ! IMAGE NAME 
! 
!  THE FOLLOWING FIELDS ARE PRESENT FOR MINOR ID'S GREATER OR EQUAL TO "03"
! 
macro IHX$L_DSTVBN = 40,0,32,0 %;       ! DEBUG SYMBOL TABLE VBN 
macro IHX$L_GSTVBN = 44,0,32,0 %;       ! GLOBAL SYMBOL TABLE VBN 
macro IHX$W_DSTBLKS = 48,0,16,0 %;      ! DEBUG SYMBOL TABLE BLOCKS 
macro IHX$W_GSTRECS = 50,0,16,0 %;      ! GLOBAL SYMBOL TABLE RECORD COUNT 
macro IHX$L_TFRADR3 = 52,0,32,0 %;      ! THIRD TRANSFER ADDRESS 
 
!*** MODULE $IMCBDEF ***
literal IMCB$K_IMCB_TYPE_CODE = 127;
literal IMCB$K_MAIN_PROGRAM = 1;        !  Object of RUN command
literal IMCB$K_MERGED_IMAGE = 2;        !  Additional image mapped
literal IMCB$K_GLOBAL_IMAGE_SECTION = 3; !  Image described by global ISD
literal IMCB$M_EXPREG = %X'1';
literal IMCB$M_SHAREABLE = %X'2';
literal IMCB$M_OPEN_FOR_WRITE = %X'4';
literal IMCB$M_RES_HEADER = %X'8';
literal IMCB$M_LOAD_IMAGE = %X'10';
literal IMCB$M_INITIALIZE = %X'20';
literal IMCB$M_DONE = %X'40';
literal IMCB$M_SYS_STB = %X'80';
literal IMCB$M_IN_CIRCULARITY = %X'100';
literal IMCB$M_MAPPED = %X'200';
literal IMCB$M_PROTECTED = %X'400';
literal IMCB$M_PARENT_PROT = %X'800';
literal IMCB$M_CMOD_VECTOR_MAPPED = %X'1000';
literal IMCB$M_XLATED = %X'2000';
literal IMCB$M_PROTSECT = %X'4000';
literal IMCB$M_NOTPROTSECT = %X'8000';
literal IMCB$M_DISCONTIGUOUS = %X'10000';
literal IMCB$M_FORKABLE = %X'20000';
literal IMCB$M_COMPRESS_DATASEC = %X'40000';
literal IMCB$M_VERSION_SAFE = %X'80000';
literal IMCB$M_PRIMARY_FIX = %X'100000';
literal IMCB$M_DATA_RESIDENT = %X'200000';
literal IMCB$M_SHARE_LINK = %X'400000';
literal IMCB$M_AUTOACT = %X'800000';
literal IMCB$M_MATCH_CONTROL = %X'7';
literal IMCB$M_MINOR_ID = %X'FFFFFF';
literal IMCB$M_MAJOR_ID = %X'FF000000';
literal IMCB$C_LENGTH = 218;            !  Length of IMCB
literal IMCB$K_LENGTH = 218;            !  Length of IMCB
literal IMCB$S_IMCB$DEF = 218;          !  Old size name - synonym
literal IMCB$S_IMCB = 218;
macro IMCB$L_FLINK = 0,0,32,1 %;        !  Forward link in list
macro IMCB$L_BLINK = 4,0,32,1 %;        !  Backward link in list
macro IMCB$W_SIZE = 8,0,16,0 %;         !  Size of IMCB in bytes
macro IMCB$B_TYPE = 10,0,8,0 %;         !  Structure type for IMCB
macro IMCB$B_ACCESS_MODE = 12,0,8,0 %;  !  Access mode of image
macro IMCB$B_ACT_CODE = 13,0,8,0 %;     !  Activation code
macro IMCB$W_CHAN = 14,0,16,0 %;        !  Channel on which image file is opened
macro IMCB$L_FLAGS = 16,0,32,0 %;       !  Name attributes
macro IMCB$V_EXPREG = 16,0,1,0 %;       !  Image mapped at end of address space
macro IMCB$V_SHAREABLE = 16,1,1,0 %;    !  Image installed /SHAREABLE
macro IMCB$V_OPEN_FOR_WRITE = 16,2,1,0 %; !  Image will be opened for write
macro IMCB$V_RES_HEADER = 16,3,1,0 %;   !  Image header already decoded
macro IMCB$V_LOAD_IMAGE = 16,4,1,0 %;   !  Load image from sequential device
macro IMCB$V_INITIALIZE = 16,5,1,0 %;   !  Image contains initialization code
macro IMCB$V_DONE = 16,6,1,0 %;         !  Image is completely activated
macro IMCB$V_SYS_STB = 16,7,1,0 %;      !  Image is linked against SYS.STB
macro IMCB$V_IN_CIRCULARITY = 16,8,1,0 %; !  Image is involved in an image circularity
macro IMCB$V_MAPPED = 16,9,1,0 %;       !  Image is mapped in address space
macro IMCB$V_PROTECTED = 16,10,1,0 %;   !  Image installed protected
macro IMCB$V_PARENT_PROT = 16,11,1,0 %; !  Parent image installed protected
macro IMCB$V_CMOD_VECTOR_MAPPED = 16,12,1,0 %; !  Change mode vectors already mapped
macro IMCB$V_XLATED = 16,13,1,0 %;      !  Image is a translated VAX image
macro IMCB$V_PROTSECT = 16,14,1,0 %;    !  Image contains some protected sections
macro IMCB$V_NOTPROTSECT = 16,15,1,0 %; !  Image does not contain some protected sections
macro IMCB$V_DISCONTIGUOUS = 16,16,1,0 %; !  Some  image sections are resident
macro IMCB$V_FORKABLE = 16,17,1,0 %;    !  Protected image allows POSIX fork()
macro IMCB$V_COMPRESS_DATASEC = 16,18,1,0 %; !  Data sections will be laid out one after another
!  Flag is only meaningful if DISCONTIGUOUS bit is set
macro IMCB$V_VERSION_SAFE = 16,19,1,0 %; !  Image is exempt from system version checks
macro IMCB$V_PRIMARY_FIX = 16,20,1,0 %; !  Image has had primary fixups performed on it
macro IMCB$V_DATA_RESIDENT = 16,21,1,0 %; !  Image has it's read-only data sections placed in 
!  the data granularity hint region.
macro IMCB$V_SHARE_LINK = 16,22,1,0 %;  !  Image was installed with shareable linkage
macro IMCB$V_AUTOACT = 16,23,1,0 %;     !  Image is being automatically activated (currently
!  this is just SYS$SSISHR). Certain errors in 
!  activation can, and should, be ignored.
!  The image name is stored as a counted ASCII string. 
macro IMCB$T_IMAGE_NAME = 20,0,0,0 %;
literal IMCB$S_IMAGE_NAME = 40;         !  Name string (counted ASCII)
macro IMCB$L_SYMBOL_VECTOR_SIZE = 60,0,32,0 %; !  Entries in symbol vector.
macro IMCB$Q_IDENT = 64,0,0,0 %;
literal IMCB$S_IDENT = 8;
macro IMCB$L_MATCH_CONTROL = 64,0,32,0 %;
macro IMCB$V_MATCH_CONTROL = 64,0,3,0 %;
literal IMCB$S_MATCH_CONTROL = 3;
macro IMCB$L_VERSION = 68,0,32,0 %;
macro IMCB$V_MINOR_ID = 68,0,24,0 %;
literal IMCB$S_MINOR_ID = 24;
macro IMCB$V_MAJOR_ID = 68,24,8,0 %;
literal IMCB$S_MAJOR_ID = 8;
macro IMCB$Q_ADDRESS_RANGE = 72,0,0,0 %;
literal IMCB$S_ADDRESS_RANGE = 8;
macro IMCB$L_STARTING_ADDRESS = 72,0,32,1 %;
macro IMCB$L_END_ADDRESS = 76,0,32,1 %;
macro IMCB$L_IHD = 80,0,32,1 %;         !  Address of IHD for image
macro IMCB$L_KFE = 84,0,32,1 %;         !  Address of KFE for image
macro IMCB$L_CONTEXT = 88,0,32,1 %;     !  Address of context block
macro IMCB$L_BASE_ADDRESS = 92,0,32,1 %; !  Base address at which image is mapped
macro IMCB$L_INITIALIZE = 96,0,32,1 %;  !  Address of initialization code
macro IMCB$L_ACTIVE_SONS = 100,0,32,0 %; !  Count of not yet mapped son images
!  Valid only during activation
macro IMCB$PS_FIXUP_VECTOR_ADDRESS = 104,0,32,1 %;
macro IMCB$PS_SYMBOL_VECTOR_ADDRESS = 112,0,32,1 %;
macro IMCB$PS_PLV_ADDRESS = 120,0,32,1 %;
macro IMCB$PS_CMOD_KERNEL_ADDRESS = 128,0,32,1 %;
macro IMCB$PS_CMOD_EXEC_ADDRESS = 136,0,32,1 %;
macro IMCB$PS_SSI_PLV = 144,0,32,1 %;
macro IMCB$L_KFERES_PTR = 152,0,32,1 %; !  Pointer to resident section description
!  The global section name of a shareable image is stored as a counted ASCII string. 
macro IMCB$T_LOG_IMAGE_NAME = 156,0,0,0 %;
literal IMCB$S_LOG_IMAGE_NAME = 40;     !  Name string (counted ASCII)
macro IMCB$T_DVI = 196,0,0,0 %;
literal IMCB$S_DVI = 16;                !  device id
macro IMCB$W_FID = 212,0,0,0 %;
literal IMCB$S_FID = 6;                 !  file id
 
!*** MODULE $IMPDEF ***
! +
!         RMS32 IMPURE AREA OFFSET DEFINITIONS
! 
! -
literal IMP$C_ASYEFN = 30;              !  EFN FOR ASYNC WAITS 
literal IMP$C_IOREFN = 30;              !  EFN FOR IO RUNDOWN SYNCHRONIZATION 
literal IMP$C_ASYQIOEFN = 31;           !  EFN FOR ASYNC QIOS 
literal IMP$C_SYNCEFN = 27;             !  BASE EFN FOR SYNCHRONOUS QIO'S 
!  (28, 29 ALSO USED)
literal IMP$C_MBXEFN = 26;              !  EFN FOR QIOS TO NETWORK MAILBOXES 
! 
literal IMP$C_NPIOFILES = 63;           !  ! OF PIO SEGMENT FILES 
literal IMP$C_ENTPERSEG = 15;           !  ! OF IIO SEGMENT SLOTS 
!  PER INDEX TABLE SEGMENT
literal IMP$S_IMPDEF = 104;
literal IMP$S_IMP = 104;
macro IMP$W_RMSSTATUS = 0,0,16,0 %;     !  RMS OVERALL STATUS 
macro IMP$V_IIOS = 0,0,1,0 %;           !  SET IF THIS IS THE IMAGE 
!  I.O SEGMENT
macro IMP$V_AST = 0,1,1,0 %;            !  SET IF RUNNING AT EXEC AST LEVEL 
macro IMP$V_TEMP1 = 0,2,1,0 %;          !  TEMPORARY FLAG 
macro IMP$V_TEMP2 = 0,3,1,0 %;          !  " 
macro IMP$V_IORUNDOWN = 0,4,1,0 %;      !  SET IF IO RUNDOWN IN PROGRESS 
macro IMP$V_NOP0BUFS = 0,5,1,0 %;       !  SET IF RMS USE OF P0 FOR IMAGE I/O DISABLED 
macro IMP$V_RUH = 0,6,1,0 %;            !  Set if within RMS RU Handler 
macro IMP$V_RECOVERY = 0,7,1,0 %;       !  SET IF RECOVERY IN PROGRESS
macro IMP$V_RUH_SYNCH = 0,8,1,0 %;      !  SET IF RMS IO MUST SYNCH
!  WITH THE RU HANDLER
! 
macro IMP$B_PROT = 2,0,8,0 %;           !  PROTECTION FOR I/O BUFFER PAGES 
macro IMP$L_IOSEGADDR = 4,0,32,1 %;     !  ADDRESS OF FIRST FREE PAGE 
!  IN THIS (IMAGE OR PROCESS)
!  I/O SEGMENT
macro IMP$L_IOSEGLEN = 8,0,32,0 %;      !  ! OF FREE BYTES AT ABOVE ADDR 
macro IMP$L_FREEPGLH = 12,0,0,1 %;
literal IMP$S_FREEPGLH = 8;             !  FREE PAGE LIST HEAD 
macro IMP$L_SAVED_SP = 20,0,32,0 %;     !  SAVED VALUE OF SP AT ENTRY 
macro IMP$L_IFABTBL = 24,0,32,1 %;      !  IFAB TABLE ADDR 
macro IMP$L_IRABTBL = 28,0,32,1 %;      !  IRAB TABLE ADDR 
macro IMP$W_ENTPERSEG = 32,0,16,0 %;    !  ! OF SLOTS PER TABLE SEGMENT 
macro IMP$W_NUM_IFABS = 34,0,16,0 %;    !  NUMBER OF IFABS & IRABS CURRENTLY ALLOCATED 
macro IMP$L_IFBTBLINK = 36,0,32,1 %;    !  START OF IFAB TABLE (LINK TO NEXT SEGMENT) 
macro IMP$L_IRBTBLINK = 100,0,32,1 %;   !  START OF IRAB TABLE (LINK TO NEXT SEGMENT) 
 
!*** MODULE INIRTNDEF ***
literal INIRTN$M_CALLED = %X'1';
literal INIRTN$M_NO_RECALL = %X'2';
literal INIRTN$S_INIRTNDEF = 4;         !  Old size name - synonym
literal INIRTN$S_INIRTN = 4;
macro INIRTN$V_CALLED = 0,0,1,0 %;      !  Routine has been called already
macro INIRTN$V_NO_RECALL = 0,1,1,0 %;   !  Routine is not to be recalled 
 
!*** MODULE $INTSTKDEF ***
! 
!  Interrupt stackk - this defines the architected stack contents on
!  interrupts and exceptions.
! 
literal INTSTK$S_INTSTK = 64;
macro INTSTK$Q_R2 = 0,0,0,0 %;
literal INTSTK$S_R2 = 8;
macro INTSTK$Q_R3 = 8,0,0,0 %;
literal INTSTK$S_R3 = 8;
macro INTSTK$Q_R4 = 16,0,0,0 %;
literal INTSTK$S_R4 = 8;
macro INTSTK$Q_R5 = 24,0,0,0 %;
literal INTSTK$S_R5 = 8;
macro INTSTK$Q_R6 = 32,0,0,0 %;
literal INTSTK$S_R6 = 8;
macro INTSTK$Q_R7 = 40,0,0,0 %;
literal INTSTK$S_R7 = 8;
macro INTSTK$Q_PC = 48,0,0,0 %;
literal INTSTK$S_PC = 8;
macro INTSTK$Q_PS = 56,0,0,0 %;
literal INTSTK$S_PS = 8;
literal INTSTK$K_LENGTH = 64;
literal INTSTK$C_LENGTH = 64;
literal INTSTK$S_INTSTKDEF = 64;        !  Old size name, synonym for  INTSTK$S_INTSTK
 
!*** MODULE $IO_ROUTINES_DATA ***
! +
!  DEFINITION OF IO_ROUTINES IMAGE LOCAL DATA
! -
literal S_IO_ROUTINES_DATA = 8;
macro IOC_GL_PSFL = 0,0,32,1 %;         !  I/O POST QUEUE FORWARD LINK
macro IOC_GL_PSBL = 4,0,32,1 %;         !  I/O POST QUEUE BACKWARD LINK
 
!*** MODULE $IO0202DEF ***
literal IO0202$Q_IOCSR_H = 2;           !  High nibble of address
literal IO0202$Q_IOCSR = 268435456;     !  I/O control/status register
literal IO0202$Q_CPU0CSR = 0;           !  CPU0 control/status register
literal IO0202$Q_CPU1CSR = 134217728;   !  CPU1 control/status register
literal IO0202$Q_CMM0CSR = 1073741824;  !  MEM0 control/status register
literal IO0202$Q_CMM1CSR = 1342177280;  !  MEM1 control/status register
literal IO0202$Q_CMM2CSR = 1610612736;  !  MEM2 control/status register
literal IO0202$Q_CMM3CSR = 1879048192;  !  MEM3 control/status register
literal IO0202$Q_CERR1 = 268435488;     !  Cbus error register 1
literal IO0202$Q_CERR2 = 268435520;     !  Cbus error register 2
literal IO0202$Q_CERR3 = 268435552;     !  Cbus error register 3
literal IO0202$Q_LMBPR = 268435584;     !  Lbus mailbos pointer register
literal IO0202$Q_FMBPR = 268435616;     !  Futurebus mailbos pointer register
literal IO0202$Q_DIAGCSR = 268435648;   !  Diagnostic control/status register 
literal IO0202$Q_FIVECT = 268435680;    !  Futurebus interrupt vector register
literal IO0202$Q_FHVECT = 268435712;    !  Futurebus halt vector register
literal IO0202$Q_FERRI = 268435744;     !  Futurebus error register 1
literal IO0202$Q_FERR2 = 268435776;     !  Futurebus error register 2
literal IO0202$Q_LINT = 268435808;      !  Local interrupt register
literal IO0202$Q_LERR1 = 268435840;     !  Lbus error register 1
literal IO0202$Q_LERR2 = 268435872;     !  Lbus error register 1
 
!*** MODULE $IO0302DEF ***
literal IO0302$L_UART0A_RR0 = -201326592;
literal IO0302$L_UART0A_RR8 = -201326528;
literal IO0302$L_UART0B_RR0 = -201326464;
literal IO0302$L_UART0B_RR8 = -201326400;
literal IO0302$L_UART1B_RR0 = -192937984;
literal IO0302$L_UART1B_RR8 = -192937920;
literal IO0302$L_UART1A_RR0 = -192937856;
literal IO0302$L_UART1A_RR8 = -192937792;
literal IO0302$L_UART2B_RR0 = -184549376;
literal IO0302$L_UART2B_RR8 = -184549312;
literal IO0302$L_UART2A_RR0 = -184549248;
literal IO0302$L_UART2A_RR8 = -184549184;
literal IO0302$L_WATCH_SECONDS = -167772160;
literal IO0302$L_WATCH_MINUTES = -167772032;
literal IO0302$L_WATCH_HOURS = -167771904;
literal IO0302$L_WATCH_DAY_OF_MONTH = -167771712;
literal IO0302$L_WATCH_MONTH = -167771648;
literal IO0302$L_WATCH_YEAR = -167771584;
literal IO0302$L_WATCH_CSRA = -167771520;
literal IO0302$L_WATCH_CSRB = -167771456;
literal IO0302$L_WATCH_CSRC = -167771392;
literal IO0302$L_WATCH_CSRD = -167771328;
literal IO0302$L_WATCH_RAM = -167771264;
literal IO0302$L_GBUS_WHAMI = -150994944;
literal IO0302$L_GBUS_LEDS = -150994880;
literal IO0302$L_GBUS_PMASK = -150994816;
literal IO0302$L_GBUS_INTR = -150994752;
literal IO0302$L_GBUS_HALT = -150994688;
literal IO0302$L_GBUS_LSBRST = -150994624;
literal IO0302$L_GBUS_MISC = -150994560;
literal IO0302$L_GBUS_RMODE_ENA = -142606336;
literal IO0302$L_SLOT0_LDEV = -134217728; !  DEVICE
literal IO0302$L_SLOT0_LBER = -134217664; !  ERROR
literal IO0302$L_SLOT0_LCNF = -134217600; !  CONFIGURATION
literal IO0302$L_SLOT0_IBR = -134217536; !  REPAIR
literal IO0302$L_SLOT0_LMMR0 = -134217216; !  MEM MAPPING 0
literal IO0302$L_SLOT0_LMMR1 = -134217152; !  MEM MAPPING 1
literal IO0302$L_SLOT0_LMMR2 = -134217088; !  MEM MAPPING 2
literal IO0302$L_SLOT0_LMMR3 = -134217024; !  MEM MAPPING 3
literal IO0302$L_SLOT0_LMMR4 = -134216960; !  MEM MAPPING 4
literal IO0302$L_SLOT0_LMMR5 = -134216896; !  MEM MAPPING 5
literal IO0302$L_SLOT0_LMMR6 = -134216832; !  MEM MAPPING 6
literal IO0302$L_SLOT0_LMMR7 = -134216768; !  MEM MAPPING 7
literal IO0302$L_SLOT0_LBESR0 = -134216192; !  BUS ERROR SYNDROME 0
literal IO0302$L_SLOT0_LBESR1 = -134216128; !  BUS ERROR SYNDROME 1
literal IO0302$L_SLOT0_LBESR2 = -134216064; !  BUS ERROR SYNDROME 2
literal IO0302$L_SLOT0_LBESR3 = -134216000; !  BUS ERROR SYNDROME 3
literal IO0302$L_SLOT0_LBECR0 = -134215936; !  BUS ERROR COMMAND 0
literal IO0302$L_SLOT0_LBECR1 = -134215872; !  BUS ERROR COMMAND 1
literal IO0302$L_SLOT1_LDEV = -130023424; !  DEVICE REG
literal IO0302$L_SLOT1_LBER = -130023360; !  ERROR
literal IO0302$L_SLOT1_LCNF = -130023296; !  CONFIGURATION
literal IO0302$L_SLOT1_IBR = -130023232; !  REPAIR
literal IO0302$L_SLOT1_LMMR0 = -130022912; !  MEM MAPPING 0
literal IO0302$L_SLOT1_LMMR1 = -130022848; !  MEM MAPPING 1
literal IO0302$L_SLOT1_LMMR2 = -130022784; !  MEM MAPPING 2
literal IO0302$L_SLOT1_LMMR3 = -130022720; !  MEM MAPPING 3
literal IO0302$L_SLOT1_LMMR4 = -130022656; !  MEM MAPPING 4
literal IO0302$L_SLOT1_LMMR5 = -130022592; !  MEM MAPPING 5
literal IO0302$L_SLOT1_LMMR6 = -130022528; !  MEM MAPPING 6
literal IO0302$L_SLOT1_LMMR7 = -130022464; !  MEM MAPPING 7
literal IO0302$L_SLOT1_LBESR0 = -130021888; !  BUS ERROR SYNDROME 0
literal IO0302$L_SLOT1_LBESR1 = -130021824; !  BUS ERROR SYNDROME 1
literal IO0302$L_SLOT1_LBESR2 = -130021760; !  BUS ERROR SYNDROME 2
literal IO0302$L_SLOT1_LBESR3 = -130021696; !  BUS ERROR SYNDROME 3
literal IO0302$L_SLOT1_LBECR0 = -130021632; !  BUS ERROR COMMAND 0
literal IO0302$L_SLOT1_LBECR1 = -130021568; !  BUS ERROR COMMAND 1
literal IO0302$L_SLOT2_LDEV = -125829120; !  DEVICE REG
literal IO0302$L_SLOT2_LBER = -125829056; !  ERROR
literal IO0302$L_SLOT2_LCNF = -125828992; !  CONFIGURATION
literal IO0302$L_SLOT2_IBR = -125828928; !  REPAIR
literal IO0302$L_SLOT2_LMMR0 = -125828608; !  MEM MAPPING 0
literal IO0302$L_SLOT2_LMMR1 = -125828544; !  MEM MAPPING 1
literal IO0302$L_SLOT2_LMMR2 = -125828480; !  MEM MAPPING 2
literal IO0302$L_SLOT2_LMMR3 = -125828416; !  MEM MAPPING 3
literal IO0302$L_SLOT2_LMMR4 = -125828352; !  MEM MAPPING 4
literal IO0302$L_SLOT2_LMMR5 = -125828288; !  MEM MAPPING 5
literal IO0302$L_SLOT2_LMMR6 = -125828224; !  MEM MAPPING 6
literal IO0302$L_SLOT2_LMMR7 = -125828160; !  MEM MAPPING 7
literal IO0302$L_SLOT2_LBESR0 = -125827584; !  BUS ERROR SYNDROME 0
literal IO0302$L_SLOT2_LBESR1 = -125827520; !  BUS ERROR SYNDROME 1
literal IO0302$L_SLOT2_LBESR2 = -125827456; !  BUS ERROR SYNDROME 2
literal IO0302$L_SLOT2_LBESR3 = -125827392; !  BUS ERROR SYNDROME 3
literal IO0302$L_SLOT2_LBECR0 = -125827328; !  BUS ERROR COMMAND 0
literal IO0302$L_SLOT2_LBECR1 = -125827264; !  BUS ERROR COMMAND 1
literal IO0302$L_SLOT3_LDEV = -121634816; !  DEVICE REG
literal IO0302$L_SLOT3_LBER = -121634752; !  ERROR
literal IO0302$L_SLOT3_LCNF = -121634688; !  CONFIGURATION
literal IO0302$L_SLOT3_IBR = -121634624; !  REPAIR
literal IO0302$L_SLOT3_LMMR0 = -121634304; !  MEM MAPPING 0
literal IO0302$L_SLOT3_LMMR1 = -121634240; !  MEM MAPPING 1
literal IO0302$L_SLOT3_LMMR2 = -121634176; !  MEM MAPPING 2
literal IO0302$L_SLOT3_LMMR3 = -121634112; !  MEM MAPPING 3
literal IO0302$L_SLOT3_LMMR4 = -121634048; !  MEM MAPPING 4
literal IO0302$L_SLOT3_LMMR5 = -121633984; !  MEM MAPPING 5
literal IO0302$L_SLOT3_LMMR6 = -121633920; !  MEM MAPPING 6
literal IO0302$L_SLOT3_LMMR7 = -121633856; !  MEM MAPPING 7
literal IO0302$L_SLOT3_LBESR0 = -121633280; !  BUS ERROR SYNDROME 0
literal IO0302$L_SLOT3_LBESR1 = -121633216; !  BUS ERROR SYNDROME 1
literal IO0302$L_SLOT3_LBESR2 = -121633152; !  BUS ERROR SYNDROME 2
literal IO0302$L_SLOT3_LBESR3 = -121633088; !  BUS ERROR SYNDROME 3
literal IO0302$L_SLOT3_LBECR0 = -121633024; !  BUS ERROR COMMAND 0
literal IO0302$L_SLOT3_LBECR1 = -121632960; !  BUS ERROR COMMAND 1
literal IO0302$L_SLOT4_LDEV = -117440512; !  DEVICE REG
literal IO0302$L_SLOT4_LBER = -117440448; !  ERROR
literal IO0302$L_SLOT4_LCNF = -117440384; !  CONFIGURATION
literal IO0302$L_SLOT4_IBR = -117440320; !  REPAIR
literal IO0302$L_SLOT4_LMMR0 = -117440000; !  MEM MAPPING 0
literal IO0302$L_SLOT4_LMMR1 = -117439936; !  MEM MAPPING 1
literal IO0302$L_SLOT4_LMMR2 = -117439872; !  MEM MAPPING 2
literal IO0302$L_SLOT4_LMMR3 = -117439808; !  MEM MAPPING 3
literal IO0302$L_SLOT4_LMMR4 = -117439744; !  MEM MAPPING 4
literal IO0302$L_SLOT4_LMMR5 = -117439680; !  MEM MAPPING 5
literal IO0302$L_SLOT4_LMMR6 = -117439616; !  MEM MAPPING 6
literal IO0302$L_SLOT4_LMMR7 = -117439552; !  MEM MAPPING 7
literal IO0302$L_SLOT4_LBESR0 = -117438976; !  BUS ERROR SYNDROME 0
literal IO0302$L_SLOT4_LBESR1 = -117438912; !  BUS ERROR SYNDROME 1
literal IO0302$L_SLOT4_LBESR2 = -117438848; !  BUS ERROR SYNDROME 2
literal IO0302$L_SLOT4_LBESR3 = -117438784; !  BUS ERROR SYNDROME 3
literal IO0302$L_SLOT4_LBECR0 = -117438720; !  BUS ERROR COMMAND 0
literal IO0302$L_SLOT4_LBECR1 = -117438656; !  BUS ERROR COMMAND 1
literal IO0302$L_SLOT5_LDEV = -113246208; !  DEVICE REG
literal IO0302$L_SLOT5_LBER = -113246144; !  ERROR
literal IO0302$L_SLOT5_LCNF = -113246080; !  CONFIGURATION
literal IO0302$L_SLOT5_IBR = -113246016; !  REPAIR
literal IO0302$L_SLOT5_LMMR0 = -113245696; !  MEM MAPPING 0
literal IO0302$L_SLOT5_LMMR1 = -113245632; !  MEM MAPPING 1
literal IO0302$L_SLOT5_LMMR2 = -113245568; !  MEM MAPPING 2
literal IO0302$L_SLOT5_LMMR3 = -113245504; !  MEM MAPPING 3
literal IO0302$L_SLOT5_LMMR4 = -113245440; !  MEM MAPPING 4
literal IO0302$L_SLOT5_LMMR5 = -113245376; !  MEM MAPPING 5
literal IO0302$L_SLOT5_LMMR6 = -113245312; !  MEM MAPPING 6
literal IO0302$L_SLOT5_LMMR7 = -113245248; !  MEM MAPPING 7
literal IO0302$L_SLOT5_LBESR0 = -113244672; !  BUS ERROR SYNDROME 0
literal IO0302$L_SLOT5_LBESR1 = -113244608; !  BUS ERROR SYNDROME 1
literal IO0302$L_SLOT5_LBESR2 = -113244544; !  BUS ERROR SYNDROME 2
literal IO0302$L_SLOT5_LBESR3 = -113244480; !  BUS ERROR SYNDROME 3
literal IO0302$L_SLOT5_LBECR0 = -113244416; !  BUS ERROR COMMAND 0
literal IO0302$L_SLOT5_LBECR1 = -113244352; !  BUS ERROR COMMAND 1
literal IO0302$L_SLOT6_LDEV = -109051904; !  DEVICE REG
literal IO0302$L_SLOT6_LBER = -109051840; !  ERROR
literal IO0302$L_SLOT6_LCNF = -109051776; !  CONFIGURATION
literal IO0302$L_SLOT6_IBR = -109051712; !  REPAIR
literal IO0302$L_SLOT6_LMMR0 = -109051392; !  MEM MAPPING 0
literal IO0302$L_SLOT6_LMMR1 = -109051328; !  MEM MAPPING 1
literal IO0302$L_SLOT6_LMMR2 = -109051264; !  MEM MAPPING 2
literal IO0302$L_SLOT6_LMMR3 = -109051200; !  MEM MAPPING 3
literal IO0302$L_SLOT6_LMMR4 = -109051136; !  MEM MAPPING 4
literal IO0302$L_SLOT6_LMMR5 = -109051072; !  MEM MAPPING 5
literal IO0302$L_SLOT6_LMMR6 = -109051008; !  MEM MAPPING 6
literal IO0302$L_SLOT6_LMMR7 = -109050944; !  MEM MAPPING 7
literal IO0302$L_SLOT6_LBESR0 = -109050368; !  BUS ERROR SYNDROME 0
literal IO0302$L_SLOT6_LBESR1 = -109050304; !  BUS ERROR SYNDROME 1
literal IO0302$L_SLOT6_LBESR2 = -109050240; !  BUS ERROR SYNDROME 2
literal IO0302$L_SLOT6_LBESR3 = -109050176; !  BUS ERROR SYNDROME 3
literal IO0302$L_SLOT6_LBECR0 = -109050112; !  BUS ERROR COMMAND 0
literal IO0302$L_SLOT6_LBECR1 = -109050048; !  BUS ERROR COMMAND 1
literal IO0302$L_SLOT7_LDEV = -104857600; !  DEVICE REG
literal IO0302$L_SLOT7_LBER = -104857536; !  ERROR
literal IO0302$L_SLOT7_LCNF = -104857472; !  CONFIGURATION
literal IO0302$L_SLOT7_IBR = -104857408; !  REPAIR
literal IO0302$L_SLOT7_LMMR0 = -104857088; !  MEM MAPPING 0
literal IO0302$L_SLOT7_LMMR1 = -104857024; !  MEM MAPPING 1
literal IO0302$L_SLOT7_LMMR2 = -104856960; !  MEM MAPPING 2
literal IO0302$L_SLOT7_LMMR3 = -104856896; !  MEM MAPPING 3
literal IO0302$L_SLOT7_LMMR4 = -104856832; !  MEM MAPPING 4
literal IO0302$L_SLOT7_LMMR5 = -104856768; !  MEM MAPPING 5
literal IO0302$L_SLOT7_LMMR6 = -104856704; !  MEM MAPPING 6
literal IO0302$L_SLOT7_LMMR7 = -104856640; !  MEM MAPPING 7
literal IO0302$L_SLOT7_LBESR0 = -104856064; !  BUS ERROR SYNDROME 0
literal IO0302$L_SLOT7_LBESR1 = -104856000; !  BUS ERROR SYNDROME 1
literal IO0302$L_SLOT7_LBESR2 = -104855936; !  BUS ERROR SYNDROME 2
literal IO0302$L_SLOT7_LBESR3 = -104855872; !  BUS ERROR SYNDROME 3
literal IO0302$L_SLOT7_LBECR0 = -104855808; !  BUS ERROR COMMAND 0
literal IO0302$L_SLOT7_LBECR1 = -104855744; !  BUS ERROR COMMAND 1
literal IO0302$L_SLOT8_LDEV = -100663296; !  DEVICE REG
literal IO0302$L_SLOT8_LBER = -100663232; !  ERROR
literal IO0302$L_SLOT8_LCNF = -100663168; !  CONFIGURATION
literal IO0302$L_SLOT8_IBR = -100663104; !  REPAIR
literal IO0302$L_SLOT8_LMMR0 = -100662784; !  MEM MAPPING 0
literal IO0302$L_SLOT8_LMMR1 = -100662720; !  MEM MAPPING 1
literal IO0302$L_SLOT8_LMMR2 = -100662656; !  MEM MAPPING 2
literal IO0302$L_SLOT8_LMMR3 = -100662592; !  MEM MAPPING 3
literal IO0302$L_SLOT8_LMMR4 = -100662528; !  MEM MAPPING 4
literal IO0302$L_SLOT8_LMMR5 = -100662464; !  MEM MAPPING 5
literal IO0302$L_SLOT8_LMMR6 = -100662400; !  MEM MAPPING 6
literal IO0302$L_SLOT8_LMMR7 = -100662336; !  MEM MAPPING 7
literal IO0302$L_SLOT8_LBESR0 = -100661760; !  BUS ERROR SYNDROME 0
literal IO0302$L_SLOT8_LBESR1 = -100661696; !  BUS ERROR SYNDROME 1
literal IO0302$L_SLOT8_LBESR2 = -100661632; !  BUS ERROR SYNDROME 2
literal IO0302$L_SLOT8_LBESR3 = -100661568; !  BUS ERROR SYNDROME 3
literal IO0302$L_SLOT8_LBECR0 = -100661504; !  BUS ERROR COMMAND 0
literal IO0302$L_SLOT8_LBECR1 = -100661440; !  BUS ERROR COMMAND 1
literal IO0302$L_LILID0 = -100660736;   !  INTERRUPT LEVEL0 IDENT
literal IO0302$L_LILID1 = -100660672;   !  INTERRUPT LEVEL1 IDENT
literal IO0302$L_LILID2 = -100660608;   !  INTERRUPT LEVEL2 IDENT
literal IO0302$L_LILID3 = -100660544;   !  INTERRUPT LEVEL3 IDENT
literal IO0302$L_LCPUMASK = -100660480; !  CPU INTERRUPT MASK
literal IO0302$L_LMBPR = -100660224;    !  MAILBOX POINTER
literal IO0302$L_IPCNSE = -100655104;   !  IO Port Chip Error
literal IO0302$L_IPCVR = -100655040;    !  IO Port Chip Vector
literal IO0302$L_IPCMSR = -100654976;   !  IO Port Chip Mode Select
literal IO0302$L_IPCHST = -100654912;   !  IO Port Chip Hose Status
literal IO0302$L_IPCDR = -100654848;    !  IO Port Chip Diagnostic
literal IO0302$L_LIOINTR = -33554432;   !  IO Interrupt reg
literal IO0302$L_LIPINTR = -33554368;   !  IP Interrupt reg
 
!*** MODULE $IO0402DEF ***
literal IO0402$Q_TC_NUMBER = 1;         !  Turbochannel number.
!  Upper lw of physical
!  address
literal IO0402$Q_SCSI_CIR = -804782080; !  SCSI Control Interrupts   
literal IO0402$Q_SCSI_IMER = -804782072; !  SCSI Interrupt Mask Enable
literal IO0402$Q_SCSI0_SDA = -804773888; !  SCSI DMA Address
literal IO0402$Q_SCSI0_SDIC = -804773880; !  SCSI DMA Interrupt Control
literal IO0402$Q_SCSI0_DMA_UNAL0 = -804773872; !  SCSI DMA Unaligned Data 0
literal IO0402$Q_SCSI0_DMA_UNAL1 = -804773864; !  SCSI DMA Unaligned Data 1
literal IO0402$Q_SCSI1_SDA = -804773376; !  SCSI DMA Address
literal IO0402$Q_SCSI1_SDIC = -804773368; !  SCSI DMA Interrupt Control
literal IO0402$Q_SCSI1_DMA_UNAL0 = -804773360; !  SCSI DMA Unaligned Data 0 
literal IO0402$Q_SCSI1_DMA_UNAL1 = -804773352; !  SCSI DMA Unaligned Data 1 
literal IO0402$Q_SCSI0_TC_LSB = -804257792; !  SCSI Transfer Counter LSB
literal IO0402$Q_SCSI0_TC_MSB = -804257784; !  SCSI Transfer Counter MSB 
literal IO0402$Q_SCSI0_FIFO = -804257776; !  SCSI FIFO                 
literal IO0402$Q_SCSI0_CMD = -804257768; !  SCSI Command              
literal IO0402$Q_SCSI0_STATUS = -804257760; !  SCSI Status
literal IO0402$Q_SCSI0_INTR = -804257752; !  SCSI Interrupt/Timeout    
literal IO0402$Q_SCSI0_SEQ = -804257744; !  SCSI Sequence Step
literal IO0402$Q_SCSI0_FF = -804257736; !  SCSI FIFO Flags           
literal IO0402$Q_SCSI0_CONFIG1 = -804257728; !  SCSI Configuration 1
literal IO0402$Q_SCSI0_CC = -804257720; !  SCSI reserved/Clock Conversion
literal IO0402$Q_SCSI0_TM = -804257712; !  SCSI reserved/Test Mode
literal IO0402$Q_SCSI0_CONFIG2 = -804257704; !  SCSI Configuration 2
literal IO0402$Q_SCSI0_CONFIG3 = -804257696; !  SCSI Configuration 3
literal IO0402$Q_SCSI1_TC_LSB = -804257280; !  SCSI Transfer Counter LSB
literal IO0402$Q_SCSI1_TC_MSB = -804257272; !  SCSI Transfer Counter MSB 
literal IO0402$Q_SCSI1_FIFO = -804257264; !  SCSI FIFO
literal IO0402$Q_SCSI1_CMD = -804257256; !  SCSI Command
literal IO0402$Q_SCSI1_STATUS = -804257248; !  SCSI Status
literal IO0402$Q_SCSI1_INTR = -804257240; !  SCSI Interrupt
literal IO0402$Q_SCSI1_SEQ = -804257232; !  SCSI Sequence Step
literal IO0402$Q_SCSI1_FF = -804257224; !  SCSI FIFO Flags
literal IO0402$Q_SCSI1_CONFIG1 = -804257216; !  SCSI Configuration 1
literal IO0402$Q_SCSI1_CC = -804257208; !  SCSI reserved/Clock Conversion
literal IO0402$Q_SCSI1_TM = -804257200; !  SCSI reserved/Test Mode
literal IO0402$Q_SCSI1_CONFIG2 = -804257192; !  SCSI Configuration 2
literal IO0402$Q_SCSI1_CONFIG3 = -804257184; !  SCSI Configuration 3
literal IO0402$Q_SCSI0_DMA = -803733504; !  SCSI DMA Buffer
literal IO0402$Q_SCSI1_DMA = -803732992; !  SCSI DMA Buffer
literal IO0402$Q_IOSLOT = -738197504;   !  IO Slot Configuration
literal IO0402$Q_TCCONFIG = -738197488; !  TC Configuration
literal IO0402$Q_FADR = -738197472;     !  Failing Address 
literal IO0402$Q_TCEREG = -738197456;   !  Turbochannel Error Register
literal IO0402$Q_MCR0 = -734003200;     !  Memory Configuration 0
literal IO0402$Q_MCR1 = -733872128;     !  Memory Configuration 1
literal IO0402$Q_MCR2 = -733741056;     !  Memory Configuration 2
literal IO0402$Q_MCR3 = -733609984;     !  Memory Configuration 3
literal IO0402$Q_MCR4 = -733478912;     !  Memory Configuration 4
literal IO0402$Q_MCR5 = -733347840;     !  Memory Configuration 5
literal IO0402$Q_MCR6 = -733216768;     !  Memory Configuration 6
literal IO0402$Q_MCR7 = -733085696;     !  Memory Configuration 7
literal IO0402$Q_IR = -729808896;       !  Interrupt Register
literal IO0402$Q_IC = -725614592;       !  Interrupt Cause   
literal IO0402$Q_SG_MAP = -721420288;   !  Scatter/Gather
literal IO0402$Q_TCRESET = -717225984;  !  Turbochannel Reset
literal IO0402$Q_FLASH_EEPROM = -268435456; !  CORE I/O ASIC registers - system ROM, part 2
literal IO0402$Q_IOCTL_CSR = -267911168; !  CORE I/O base CSR address
literal IO0402$Q_LDP = -267911104;      !  Ethernet DMA pointer
literal IO0402$Q_SCOMM_TR = -267911072; !  Serial comm transmit port 1 DMA pointer
literal IO0402$Q_SCOMM_RC = -267911040; !  Serial comm receive port 1 DMA pointer
literal IO0402$Q_PRINTER_TR = -267911008; !  Serial comm transmit port 2 DMA pointer
literal IO0402$Q_PRINTER_RC = -267910976; !  Serial comm receive port 2 DMA pointer
literal IO0402$Q_ISDN_TR = -267910912;  !  ISDN transmit DMA pointer
literal IO0402$Q_ISDN_TR_BUF = -267910880; !  ISDN transmit DMA buffer pointer
literal IO0402$Q_ISDN_RC = -267910848;  !  ISDN receive DMA pointer 
literal IO0402$Q_ISDN_RC_BUF = -267910816; !  ISDN receive DMA buffer pointer 
literal IO0402$Q_DATA0 = -267910784;    !  System Data Buffer 0
literal IO0402$Q_DATA1 = -267910752;    !  System Data Buffer 1
literal IO0402$Q_DATA2 = -267910720;    !  System Data Buffer 2
literal IO0402$Q_DATA3 = -267910688;    !  System Data Buffer 3
literal IO0402$Q_SSR = -267910656;      !  System support register
literal IO0402$Q_SIR = -267910624;      !  System interrupt register
literal IO0402$Q_SIMR = -267910592;     !  System interrupt mask register
literal IO0402$Q_SADR = -267910560;     !  System address register
literal IO0402$Q_ISDN_DATA_TR = -267910528; !  ISDN Data Transmit
literal IO0402$Q_ISDN_DATA_RC = -267910496; !  ISDN Data Receive
literal IO0402$Q_LANCE_SLOT = -267910464; !  Lance slot register
literal IO0402$Q_SCC0_SLOT = -267910400; !  SCC1 slot register
literal IO0402$Q_SCC1_SLOT = -267910368; !  SCC0 slot register
literal IO0402$Q_NI_ADR_ROM = -267386880; !  Ethernet address ROM
literal IO0402$Q_LANCE_RDP = -266862592; !  Lance ethernet CSR
literal IO0402$Q_LANCE_RAP = -266862584; !  Lance ethernet CSR
literal IO0402$Q_SCC0B_COMM_RAP = -266338304; !  Comm Port 1 RAP
literal IO0402$Q_SCC0B_COMM_DATA = -266338296; !  Comm Port 1 data
literal IO0402$Q_SCC0A_MOUSE_RAP = -266338288; !  Mouse RAP
literal IO0402$Q_SCC0A_MOUSE_DATA = -266338280; !  Mouse port data register
literal IO0402$Q_SCC1B_PRINTER_RAP = -265289728; !  Comm Port 2 RAP
literal IO0402$Q_SCC1B_PRINTER_DATA = -265289720; !  Comm Port 2 data
literal IO0402$Q_SCC1A_KEY_RAP = -265289712; !  Keyboard RAP
literal IO0402$Q_SCC1A_KEY_DATA = -265289704; !  Keyboard port data register
literal IO0402$Q_RTC_SEC = -264241152;  !  TOY clock CSR--seconds
literal IO0402$Q_RTC_ALMS = -264241144; !  TOY clock CSR--seconds alarm
literal IO0402$Q_RTC_MIN = -264241136;  !  TOY clock CSR--minutes
literal IO0402$Q_RTC_ALMN = -264241128; !  TOY clock CSR--minutes alarm
literal IO0402$Q_RTC_HOUR = -264241120; !  TOY clock CSR--hours
literal IO0402$Q_RTC_ALMH = -264241112; !  TOY clock CSR--hours alarm
literal IO0402$Q_RTC_DOW = -264241104;  !  TOY clock CSR--day of week
literal IO0402$Q_RTC_DAY = -264241096;  !  TOY clock CSR--date of month
literal IO0402$Q_RTC_MON = -264241088;  !  TOY clock CSR--month
literal IO0402$Q_RTC_YEAR = -264241080; !  TOY clock CSR--year
literal IO0402$Q_RTC_REGA = -264241072; !  TOY clock CSR--register A 
literal IO0402$Q_RTC_REGB = -264241064; !  TOY clock CSR--register B 
literal IO0402$Q_RTC_REGC = -264241056; !  TOY clock CSR--register C 
literal IO0402$Q_RTC_REGD = -264241048; !  TOY clock CSR--register D 
literal IO0402$Q_RTC_RAM = -264241040;  !  TOY clock CSR--base of BBU RAM
literal IO0402$Q_ISDN_AUDIO = -263716864; !  ISDN audio chip CSR
literal IO0402$Q_SYSTEM_EEPROM = -201326592; !  base of system ROM, part 1
literal IO0402$Q_CPYBUF0 = -199229440;
literal IO0402$Q_CPYBUF1 = -199229432;
literal IO0402$Q_CPYBUF2 = -199229424;
literal IO0402$Q_CPYBUF3 = -199229416;
literal IO0402$Q_CPYBUF4 = -199229408;
literal IO0402$Q_CPYBUF5 = -199229400;
literal IO0402$Q_CPYBUF6 = -199229392;
literal IO0402$Q_CPYBUF7 = -199229384;
literal IO0402$Q_FG = -199229376;
literal IO0402$Q_BG = -199229368;
literal IO0402$Q_PLANEMASK = -199229360;
literal IO0402$Q_PIXMASK = -199229352;
literal IO0402$Q_MODE = -199229344;
literal IO0402$Q_BOOLOP = -199229336;
literal IO0402$Q_PIXSHIFT = -199229328;
literal IO0402$Q_ADDR_REG = -199229320;
literal IO0402$Q_BRES1 = -199229312;
literal IO0402$Q_BRES2 = -199229304;
literal IO0402$Q_BRES3 = -199229296;
literal IO0402$Q_BCONT = -199229288;
literal IO0402$Q_DEEP = -199229280;
literal IO0402$Q_START = -199229272;
literal IO0402$Q_CI = -199229264;
literal IO0402$Q_V_REF_COUNT = -199229248;
literal IO0402$Q_V_HOR = -199229240;
literal IO0402$Q_V_VER = -199229232;
literal IO0402$Q_VV = -199229216;
literal IO0402$Q_EI = -199229208;
literal IO0402$Q_TCCLK_COUNT = -199229200;
literal IO0402$Q_VIDCLK_COUNT = -199229192;
literal IO0402$Q_RAMDAC_ADDR_LO = -197656576;
literal IO0402$Q_RAMDAC_ADDR_HI = -197656568;
literal IO0402$Q_RAMDAC_REG_ADDR = -197656560;
literal IO0402$Q_RAMDAC_MAP_LOC = -197656552;
literal IO0402$Q_FB = -501219328;
literal IO0402$Q_SLOT0_DENSE_BASE = 0;
literal IO0402$Q_SLOT1_DENSE_BASE = 536870912;
literal IO0402$Q_SLOT2_DENSE_BASE = 1073741824;
literal IO0402$Q_SLOT3_DENSE_BASE = 1610612736;
literal IO0402$Q_SLOT4_DENSE_BASE = -2147483648;
literal IO0402$Q_SLOT5_DENSE_BASE = -1610612736;
literal IO0402$Q_SLOT6_DENSE_BASE = -1073741824;
literal IO0402$Q_SLOT7_DENSE_BASE = -536870912;
literal IO0402$Q_CXTURBO_DENSE_BASE = -503316480;
literal IO0402$Q_SLOT0_SPARSE_BASE = 268435456;
literal IO0402$Q_SLOT1_SPARSE_BASE = 805306368;
literal IO0402$Q_SLOT2_SPARSE_BASE = 1342177280;
literal IO0402$Q_SLOT3_SPARSE_BASE = 1879048192;
literal IO0402$Q_SLOT4_SPARSE_BASE = -1879048192;
literal IO0402$Q_SLOT5_SPARSE_BASE = -1342177280;
literal IO0402$Q_SLOT6_SPARSE_BASE = -805306368;
literal IO0402$Q_SLOT7_SPARSE_BASE = -268435456;
literal IO0402$Q_LDP_DENSE = -536608736; !  Ethernet DMA pointer
literal IO0402$Q_NI_ADR_ROM_DENSE = -536346624; !  Ethernet address ROM
literal IO0402$Q_LANCE_RDP_DENSE = -536084480; !  Lance ethernet CSR
literal IO0402$Q_IMASK_READ = -1035993088; !  IR dense space
literal IO0402$Q_SG_DENSE = -1031675904; !  Base of last page of SG dense space
 
!*** MODULE $IO0602DEF ***
literal IO0602$K_EISA_LOCAL = 1;
literal IO0602$K_EISA_MEM = 2;
literal IO0602$K_EISA_IO = 3;
literal IO0602$Q_EISA_INTA_CYCLE = 0;
literal IO0602$Q_EISA_COMBO_CHIP = -1073741824; !  base address of COMBO ADDR space
literal IO0602$Q_EISA_COMBO_CHIP_RTC = -1073553408; !  base address of COMBO ADDR space, RTC
literal IO0602$B_KBD_PS2 = -1073696768; !  PS2 keyboard register, read
literal IO0602$B_KBD_DBB = -1073696768; !  PS2 keyboard register, write
literal IO0602$B_KBD_PS2S = -1073694720; !  PS2 status register
literal IO0602$B_TOY_R_INDX_REG = -1073684480; !  address of index register for read addr.
literal IO0602$B_TOY_R_DATA_REG = -1073683968; !  address of data register for read data.
literal IO0602$B_TOY_W_INDX_REG = -1073553408; !  address of index register for write addr.
literal IO0602$B_TOY_W_DATA_REG = -1073552896; !  address of data register for write data.
literal IO0602$K_TOY_SECS = 0;          !  seconds of TOY clock.
literal IO0602$K_TOY_ASECS = 1;         !  seconds of TOY clock, alarm func.
literal IO0602$K_TOY_MINS = 2;          !  minutes of TOY clock.
literal IO0602$K_TOY_AMINS = 3;         !  minutes of TOY clock, alarm func.
literal IO0602$K_TOY_HOURS = 4;         !  hours of TOY clock.
literal IO0602$K_TOY_AHOURS = 5;        !  hours of TOY clock, alarm func.
literal IO0602$K_TOY_DAY = 6;           !  day of week, 1-7
literal IO0602$K_TOY_DATE = 7;          !  date of month
literal IO0602$K_TOY_MONTH = 8;         !  month
literal IO0602$K_TOY_YEAR = 9;          !  year
literal IO0602$K_TOY_CNTRLA = 10;       !  control register A
literal IO0602$K_TOY_CNTRLB = 11;       !  control register B
literal IO0602$K_TOY_CNTRLC = 12;       !  control register C
literal IO0602$K_TOY_CNTRLD = 13;       !  control register D
literal IO0602$B_COMB_RBR = -1073352704; !  Recieve Buffer Register
literal IO0602$B_COMB_THR = -1073352704; !  Transmitter Holding Register
literal IO0602$B_COMB_DLL = -1073352704; !  Divisor Latch Register(LSB)
literal IO0602$B_COMB_DLM = -1073352192; !  Divisor Latch Register(MSB)
literal IO0602$B_COMB_IER = -1073352192; !  Interrupt Enable Register
literal IO0602$B_COMB_FCR = -1073351680; !  
literal IO0602$B_COMB_IIR = -1073351680; !  Interrupt Identification Register
literal IO0602$B_COMB_LCR = -1073351168; !  Line Control Register
literal IO0602$B_COMB_MCR = -1073350656; !  Modem Control Register
literal IO0602$B_COMB_LSR = -1073350144; !  Line Status Register
literal IO0602$B_COMB_MSR = -1073349632; !  Modem Status Register
literal IO0602$B_COMB_SCR = -1073349120; !  Scratch Register
literal IO0602$B_LPT_REG0 = -1073252352; !  Data Register
literal IO0602$B_LPT_REG1 = -1073251840; !  Status Register
literal IO0602$B_LPT_REG2 = -1073251328; !  Control Register
literal IO0602$B_COMA_RBR = -1073221632; !  Recieve Buffer Register
literal IO0602$B_COMA_THR = -1073221632; !  Transmitter Holding Register
literal IO0602$B_COMA_DLL = -1073221632; !  Divisor Latch Register(LSB)
literal IO0602$B_COMA_DLM = -1073221120; !  Divisor Latch Register(MSB)
literal IO0602$B_COMA_IER = -1073221120; !  Interrupt Enable Register
literal IO0602$B_COMA_FCR = -1073220608; !  
literal IO0602$B_COMA_IIR = -1073220608; !  Interrupt Identification Register
literal IO0602$B_COMA_LCR = -1073220096; !  Line Control Register
literal IO0602$B_COMA_MCR = -1073219584; !  Modem Control Register
literal IO0602$B_COMA_LSR = -1073219072; !  Line Status Register
literal IO0602$B_COMA_MSR = -1073218560; !  Modem Status Register
literal IO0602$B_COMA_SCR = -1073218048; !  Scratch Register
literal IO0602$Q_EISA_CONFIG_DATA = -1409286144;
literal IO0602$Q_EISA_CONFIG_IRQ = 107520;
literal IO0602$Q_EISA_CONFIG_DMA = 114688;
literal IO0602$Q_EISA_CONFIG_MEM = 76288;
literal IO0602$Q_EISA_CONFIG_IO_PORT = 102912;
literal IO0602$Q_HOST_ADDR_EXT = -805306368;
literal IO0602$Q_SYS_CNTRL_REG = -536870912;
literal IO0602$Q_SPARE_REG = -268435456;
literal IO0602$Q_EISA_MEM_BASE = 0;
literal IO0602$Q_EISA_IO_BASE = 0;
literal IO0602$Q_EISA_IO_ISP = 0;       !  base addr of ISP chip(82357)
literal IO0602$B_DMA1_CH0_ADDR = 0;     !  0 addr of DMA1 CH-0 Base and Current Address
literal IO0602$B_DMA1_CH0_CNT = 128;    !  1 addr of DMA1 CH-0 Base and Current Address
literal IO0602$B_DMA1_CH1_ADDR = 256;   !  2 addr of DMA1 CH-1 Base and Current Address
literal IO0602$B_DMA1_CH1_CNT = 384;    !  3 addr of DMA1 CH-1 Base and Current Address
literal IO0602$B_DMA1_CH2_ADDR = 512;   !  4 addr of DMA1 CH-2 Base and Current Address
literal IO0602$B_DMA1_CH2_CNT = 640;    !  5 addr of DMA1 CH-2 Base and Current Address
literal IO0602$B_DMA1_CH3_ADDR = 768;   !  6 addr of DMA1 CH-3 Base and Current Address
literal IO0602$B_DMA1_CH3_CNT = 896;    !  7 addr of DMA1 CH-3 Base and Current Address
literal IO0602$B_DMA1_STATUS = 1024;    !  8 addr of DMA1 status
literal IO0602$B_DMA1_WR_REQ = 1152;    !  9 addr of DMA1 write request
literal IO0602$B_DMA1_WR_MASK = 1280;   !  A addr of DMA1 write single mask bit
literal IO0602$B_DMA1_WR_MODE = 1408;   !  B addr of DMA1 write mode register
literal IO0602$B_DMA1_CL_BYTE = 1536;   !  C addr of DMA1 clear byte pointer
literal IO0602$B_DMA1_MASTER_CLR = 1664; !  D addr of DMA1 master clear
literal IO0602$B_DMA1_CLR_MASK = 1792;  !  E addr of DMA1 clear mask reg
literal IO0602$B_DMA1_RW_MASK_REG = 1920; !  F addr of DMA1 read/write all mask reg bits
literal IO0602$B_INT_1_CNTRL = 4096;    !  20 INT1 control register
literal IO0602$B_INT_1_MASK = 4224;     !  21 INT1 mask register
literal IO0602$B_INTV_TIMER1 = 8192;    !  40 Interval Timer 1
literal IO0602$B_REF_REQ = 8320;        !  41 Refresh Request Register
literal IO0602$B_SKR_TONE = 8448;       !  42 Speaker Tone Register
literal IO0602$B_CMD_MODE = 8576;       !  43 Command Mode Register
literal IO0602$B_INTV_TIMER2 = 9216;    !  48 Interval Timer 2
literal IO0602$B_SPD_CNTRL = 9472;      !  4A CPU Speed Control
literal IO0602$B_CMD_MODE2 = 9600;      !  4B Command Mode Register
literal IO0602$B_NMI_STATUS = 12416;    !  61 NMI Status
literal IO0602$B_NMI_ENABLE = 14336;    !  70 NMI Enable Register
literal IO0602$B_DMA_PAGE_R1 = 16384;   !  80 DMA PAGE Register(reserved)
literal IO0602$B_DMA_PAGE_CH2 = 16512;  !  81 DMA PAGE Register CH 2
literal IO0602$B_DMA_PAGE_CH3 = 16640;  !  82 DMA PAGE Register Ch 3
literal IO0602$B_DMA_PAGE_CH1 = 16768;  !  83 DMA PAGE Register Ch 1
literal IO0602$B_DMA_PAGE_R2 = 16896;   !  84 DMA PAGE Register(reserved)
literal IO0602$B_DMA_PAGE_R3 = 17024;   !  85 DMA PAGE Register(reserved)
literal IO0602$B_DMA_PAGE_R4 = 17152;   !  86 DMA PAGE Register(reserved)
literal IO0602$B_DMA_PAGE_CH0 = 17280;  !  87 DMA PAGE Register CH 0
literal IO0602$B_DMA_PAGE_R5 = 17408;   !  88 DMA PAGE Register(reserved)
literal IO0602$B_DMA_PAGE_CH6 = 17536;  !  89 DMA PAGE Register CH 6
literal IO0602$B_DMA_PAGE_CH7 = 17664;  !  8A DMA PAGE Register CH 7
literal IO0602$B_DMA_PAGE_CH5 = 17792;  !  8B DMA PAGE Register CH 5
literal IO0602$B_DMA_PAGE_R6 = 17920;   !  8C DMA PAGE Register(reserved)
literal IO0602$B_DMA_PAGE_R7 = 18048;   !  8D DMA PAGE Register(reserved)
literal IO0602$B_DMA_PAGE_R8 = 18176;   !  8E DMA PAGE Register(reserved)
literal IO0602$B_DMA_PAGE_REF = 18304;  !  8F DMA PAGE Register Refresh Page
literal IO0602$B_INT2_CNTRL = 20480;    !  A0 INT-2 control register
literal IO0602$B_INT2_MASK = 20608;     !  A1 INT-2 mask register
literal IO0602$B_DMA2_CH0_ADDR = 24576; !  C0 addr of DMA2 CH-0 Base and Current Address
literal IO0602$B_DMA2_CH0_CNT = 24832;  !  C2 addr of DMA2 CH-0 Base and Current Address
literal IO0602$B_DMA2_CH1_ADDR = 25088; !  C4 addr of DMA2 CH-1 Base and Current Address
literal IO0602$B_DMA2_CH1_CNT = 25344;  !  C6 addr of DMA2 CH-1 Base and Current Address
literal IO0602$B_DMA2_CH2_ADDR = 25600; !  C8 addr of DMA2 CH-2 Base and Current Address
literal IO0602$B_DMA2_CH2_CNT = 25856;  !  CA addr of DMA2 CH-2 Base and Current Address
literal IO0602$B_DMA2_CH3_ADDR = 26112; !  CC addr of DMA2 CH-3 Base and Current Address
literal IO0602$B_DMA2_CH3_CNT = 26368;  !  CE addr of DMA2 CH-3 Base and Current Address
literal IO0602$B_DMA2_STATUS = 26624;   !  D0 addr of DMA2 status
literal IO0602$B_DMA2_WR_REQ = 26880;   !  D2 addr of DMA2 write request
literal IO0602$B_DMA2_WR_MASK = 27136;  !  D4 addr of DMA2 write single mask bit
literal IO0602$B_DMA2_WR_MODE = 27392;  !  D6 addr of DMA2 write mode register
literal IO0602$B_DMA2_CL_BYTE = 27648;  !  D8 addr of DMA2 clear byte pointer
literal IO0602$B_DMA2_MASTER_CLR = 27904; !  DA addr of DMA2 master clear
literal IO0602$B_DMA2_CLR_MASK = 28160; !  DC addr of DMA2 clear mask reg
literal IO0602$B_DMA2_RW_MASK_REG = 28416; !  DE addr of DMA2 read/write all mask reg bits
literal IO0602$B_DMA1_CH0_CNT_HIGH = 131200; !  401 DMA1 Ch0 base/current count high
literal IO0602$B_DMA1_CH1_CNT_HIGH = 131456; !  403 DMA1 Ch1 base/current count high
literal IO0602$B_DMA1_CH2_CNT_HIGH = 131712; !  405 DMA1 Ch2 base/current count high
literal IO0602$B_DMA1_CH3_CNT_HIGH = 131968; !  407 DMA1 Ch3 base/current count high
literal IO0602$B_DMA1_CHN_MODE = 132352; !  40A DMA1 Set Chaining Mode(w), Int status (r)
literal IO0602$B_DMA1_WRT_MODE = 132480; !  40B DMA1 Ext Write Mode Reg
literal IO0602$B_DMA1_CHN_BUF_CNTRL = 132608; !  40C DMA1 Chain Buf Control
literal IO0602$B_DMA1_STEP_LVL = 132736; !  40D DMA1 Stepping LEvel Reg
literal IO0602$B_EXNMI_CNTRL = 143488;  !  461 Extended NMI and reset control
literal IO0602$B_NMI_IO_INT_PORT = 143616; !  462 NMI IO Int Port(casual)
literal IO0602$B_LAST_BUS_MSTR = 143872; !  464 LAst Bus MAster Granted
literal IO0602$B_DMA_CH2_HIGH_PAGE = 147584; !  481 DMA High Page Resgister CH-2 PAge
literal IO0602$B_DMA_CH3_HIGH_PAGE = 147712; !  482 DMA High Page Resgister CH-3 PAge
literal IO0602$B_DMA_CH1_HIGH_PAGE = 147840; !  483 DMA High Page Resgister CH-1 PAge
literal IO0602$B_DMA_CH0_HIGH_PAGE = 148352; !  487 DMA High Page Resgister CH-0 PAge
literal IO0602$B_DMA_CH6_HIGH_PAGE = 148608; !  489 DMA High Page Resgister CH-6 PAge
literal IO0602$B_DMA_CH7_HIGH_PAGE = 148736; !  48A DMA High Page Resgister CH-7 PAge
literal IO0602$B_DMA_CH5_HIGH_PAGE = 148864; !  48B DMA High Page Resgister CH-5 PAge
literal IO0602$B_DMA_REG_REFRESH = 149376; !  48F DMA High Page Resgister Refresh
literal IO0602$B_DMA2_CH5_CNT_HIGH = 156416; !  4C6 DMA2 Ch 5 base/current count high
literal IO0602$B_DMA2_CH6_CNT_HIGH = 156928; !  4CA DMA2 Ch 6 base/current count high
literal IO0602$B_DMA2_CH7_CNT_HIGH = 157440; !  4CE DMA2 Ch 7 base/current count high
literal IO0602$B_INT1_LVL_CTRL = 157696; !  4D0 INT-1 Edge LEvel Control Reg
literal IO0602$B_INT2_LVL_CTRL = 157824; !  4D1 INT-2 Edge LEvel Control Reg
literal IO0602$B_DMA2_CHN_MODE = 158208; !  4D4 DMA2 Set chaining mode
literal IO0602$B_DMA2_EXT_WRT_MODE = 158464; !  4D6 DMA2 Ext Write Mode Reg
literal IO0602$B_DMA_CH0_STOP_7_2 = 159744; !  4E0 DMA CH0 Stop Reg Bits<7:2>
literal IO0602$B_DMA_CH0_STOP_15_8 = 159872; !  4E1 DMA CH0 Stop Reg Bits<15:8>
literal IO0602$B_DMA_CH0_STOP_23_16 = 160000; !  4E2 DMA CH0 Stop Reg Bits<23:16>
literal IO0602$B_DMA_CH1_STOP_7_2 = 160256; !  4E4 DMA CH1 Stop Reg Bits<7:2>
literal IO0602$B_DMA_CH1_STOP_15_8 = 160384; !  4E5 DMA CH1 Stop Reg Bits<15:8>
literal IO0602$B_DMA_CH1_STOP_23_16 = 160512; !  4E6 DMA CH1 Stop Reg Bits<23:16>
literal IO0602$B_DMA_CH2_STOP_7_2 = 160768; !  4E8 DMA CH2 Stop Reg Bits<7:2>
literal IO0602$B_DMA_CH2_STOP_15_8 = 160896; !  4E9 DMA CH2 Stop Reg Bits<15:8>
literal IO0602$B_DMA_CH2_STOP_23_16 = 161024; !  4EA DMA CH2 Stop Reg Bits<23:16>
literal IO0602$B_DMA_CH3_STOP_7_2 = 161280; !  4EC DMA CH3 Stop Reg Bits<7:2>
literal IO0602$B_DMA_CH3_STOP_15_8 = 161408; !  4ED DMA CH3 Stop Reg Bits<15:8>
literal IO0602$B_DMA_CH3_STOP_23_16 = 161536; !  4EE DMA CH3 Stop Reg Bits<23:16>
literal IO0602$B_DMA_CH5_STOP_7_2 = 162304; !  4F4 DMA CH5 Stop Reg Bits<7:2>
literal IO0602$B_DMA_CH5_STOP_15_8 = 162432; !  4F5 DMA CH5 Stop Reg Bits<15:8>
literal IO0602$B_DMA_CH5_STOP_23_16 = 162560; !  4F6 DMA CH5 Stop Reg Bits<23:16>
literal IO0602$B_DMA_CH6_STOP_7_2 = 162816; !  4F8 DMA CH6 Stop Reg Bits<7:2>
literal IO0602$B_DMA_CH6_STOP_15_8 = 162944; !  4F9 DMA CH6 Stop Reg Bits<15:8>
literal IO0602$B_DMA_CH6_STOP_23_16 = 163072; !  4FA DMA CH6 Stop Reg Bits<23:16>
literal IO0602$B_DMA_CH7_STOP_7_2 = 163328; !  4FC DMA CH7 Stop Reg Bits<7:2>
literal IO0602$B_DMA_CH7_STOP_15_8 = 163456; !  4FD DMA CH7 Stop Reg Bits<15:8>
literal IO0602$B_DMA_CH7_STOP_23_16 = 163584; !  4FE DMA CH7 Stop Reg Bits<23:16>
literal IO0602$Q_EISA_SLOT1_BASE = 524288; !  1000
literal IO0602$Q_EISA_SLOT2_BASE = 1048576; !  2000
literal IO0602$Q_EISA_SLOT3_BASE = 1572864; !  3000
literal IO0602$Q_EISA_SLOT4_BASE = 2097152; !  4000
literal IO0602$Q_EISA_SLOT5_BASE = 2621440; !  5000
literal IO0602$Q_EISA_SLOT6_BASE = 3145728; !  6000
 
!*** MODULE $IO0702DEF ***
literal IO0702$Q_TC_NUMBER = 1;         !  Turbochannel number.
!  Upper lw of physical
!  address
literal IO0702$Q_SCSI_CIR = -1878523904; !  SCSI Control Interrupts   
literal IO0702$Q_SCSI_IMER = -1878523896; !  SCSI Interrupt Mask Enable
literal IO0702$Q_SCSI0_SDA = -1878515712; !  SCSI DMA Address
literal IO0702$Q_SCSI0_SDIC = -1878515704; !  SCSI DMA Interrupt Control
literal IO0702$Q_SCSI0_DMA_UNAL0 = -1878515696; !  SCSI DMA Unaligned Data 0
literal IO0702$Q_SCSI0_DMA_UNAL1 = -1878515688; !  SCSI DMA Unaligned Data 1
literal IO0702$Q_SCSI0_TC_LSB = -1877999616; !  SCSI Transfer Counter LSB
literal IO0702$Q_SCSI0_TC_MSB = -1877999608; !  SCSI Transfer Counter MSB 
literal IO0702$Q_SCSI0_FIFO = -1877999600; !  SCSI FIFO                 
literal IO0702$Q_SCSI0_CMD = -1877999592; !  SCSI Command              
literal IO0702$Q_SCSI0_STATUS = -1877999584; !  SCSI Status
literal IO0702$Q_SCSI0_INTR = -1877999576; !  SCSI Interrupt/Timeout    
literal IO0702$Q_SCSI0_SEQ = -1877999568; !  SCSI Sequence Step
literal IO0702$Q_SCSI0_FF = -1877999560; !  SCSI FIFO Flags           
literal IO0702$Q_SCSI0_CONFIG1 = -1877999552; !  SCSI Configuration 1
literal IO0702$Q_SCSI0_CC = -1877999544; !  SCSI reserved/Clock Conversion
literal IO0702$Q_SCSI0_TM = -1877999536; !  SCSI reserved/Test Mode
literal IO0702$Q_SCSI0_CONFIG2 = -1877999528; !  SCSI Configuration 2
literal IO0702$Q_SCSI0_CONFIG3 = -1877999520; !  SCSI Configuration 3
literal IO0702$Q_SCSI0_DMA = -1877475328; !  SCSI DMA Buffer
literal IO0702$Q_IR = -268435456;       !  Interrupt Register
literal IO0702$Q_TCSR = -268435440;     !  TC Control & Status Register
literal IO0702$Q_MCR = -268435424;      !  Memory Config Register
literal IO0702$Q_FLASH_EEPROM = -1342177280; !  CORE I/O ASIC registers - system ROM, part 2
literal IO0702$Q_IOCTL_CSR = -1341652992; !  CORE I/O base CSR address
literal IO0702$Q_LDP = -1341652928;     !  Ethernet DMA pointer
literal IO0702$Q_SCOMM_TR = -1341652896; !  Serial comm transmit port 1 DMA pointer
literal IO0702$Q_SCOMM_RC = -1341652864; !  Serial comm receive port 1 DMA pointer
literal IO0702$Q_PRINTER_TR = -1341652832; !  Serial comm transmit port 2 DMA pointer
literal IO0702$Q_PRINTER_RC = -1341652800; !  Serial comm receive port 2 DMA pointer
literal IO0702$Q_ISDN_TR = -1341652736; !  ISDN transmit DMA pointer
literal IO0702$Q_ISDN_TR_BUF = -1341652704; !  ISDN transmit DMA buffer pointer
literal IO0702$Q_ISDN_RC = -1341652672; !  ISDN receive DMA pointer 
literal IO0702$Q_ISDN_RC_BUF = -1341652640; !  ISDN receive DMA buffer pointer 
literal IO0702$Q_DATA0 = -1341652608;   !  System Data Buffer 0
literal IO0702$Q_DATA1 = -1341652576;   !  System Data Buffer 1
literal IO0702$Q_DATA2 = -1341652544;   !  System Data Buffer 2
literal IO0702$Q_DATA3 = -1341652512;   !  System Data Buffer 3
literal IO0702$Q_SSR = -1341652480;     !  System support register
literal IO0702$Q_SIR = -1341652448;     !  System interrupt register
literal IO0702$Q_SIMR = -1341652416;    !  System interrupt mask register
literal IO0702$Q_SADR = -1341652384;    !  System address register
literal IO0702$Q_ISDN_DATA_TR = -1341652352; !  ISDN Data Transmit
literal IO0702$Q_ISDN_DATA_RC = -1341652320; !  ISDN Data Receive
literal IO0702$Q_LANCE_SLOT = -1341652288; !  Lance slot register
literal IO0702$Q_SCC0_SLOT = -1341652224; !  SCC1 slot register
literal IO0702$Q_SCC1_SLOT = -1341652192; !  SCC0 slot register
literal IO0702$Q_NI_ADR_ROM = -1341128704; !  Ethernet address ROM
literal IO0702$Q_LANCE_RDP = -1340604416; !  Lance ethernet CSR
literal IO0702$Q_LANCE_RAP = -1340604408; !  Lance ethernet CSR
literal IO0702$Q_SCC0B_COMM_RAP = -1340080128; !  Comm Port 1 RAP
literal IO0702$Q_SCC0B_COMM_DATA = -1340080120; !  Comm Port 1 data
literal IO0702$Q_SCC0A_MOUSE_RAP = -1340080112; !  Mouse RAP
literal IO0702$Q_SCC0A_MOUSE_DATA = -1340080104; !  Mouse port data register
literal IO0702$Q_SCC1B_PRINTER_RAP = -1339031552; !  Comm Port 2 RAP
literal IO0702$Q_SCC1B_PRINTER_DATA = -1339031544; !  Comm Port 2 data
literal IO0702$Q_SCC1A_KEY_RAP = -1339031536; !  Keyboard RAP
literal IO0702$Q_SCC1A_KEY_DATA = -1339031528; !  Keyboard port data register
literal IO0702$Q_RTC_SEC = -1337982976; !  TOY clock CSR--seconds
literal IO0702$Q_RTC_ALMS = -1337982968; !  TOY clock CSR--seconds alarm
literal IO0702$Q_RTC_MIN = -1337982960; !  TOY clock CSR--minutes
literal IO0702$Q_RTC_ALMN = -1337982952; !  TOY clock CSR--minutes alarm
literal IO0702$Q_RTC_HOUR = -1337982944; !  TOY clock CSR--hours
literal IO0702$Q_RTC_ALMH = -1337982936; !  TOY clock CSR--hours alarm
literal IO0702$Q_RTC_DOW = -1337982928; !  TOY clock CSR--day of week
literal IO0702$Q_RTC_DAY = -1337982920; !  TOY clock CSR--date of month
literal IO0702$Q_RTC_MON = -1337982912; !  TOY clock CSR--month
literal IO0702$Q_RTC_YEAR = -1337982904; !  TOY clock CSR--year
literal IO0702$Q_RTC_REGA = -1337982896; !  TOY clock CSR--register A 
literal IO0702$Q_RTC_REGB = -1337982888; !  TOY clock CSR--register B 
literal IO0702$Q_RTC_REGC = -1337982880; !  TOY clock CSR--register C 
literal IO0702$Q_RTC_REGD = -1337982872; !  TOY clock CSR--register D 
literal IO0702$Q_RTC_RAM = -1337982864; !  TOY clock CSR--base of BBU RAM
literal IO0702$Q_ISDN_AUDIO = -1337458688; !  ISDN audio chip CSR
literal IO0702$Q_SYSTEM_EEPROM = -1073741824; !  base of system ROM, part 1
literal IO0702$Q_CPYBUF0 = -1072693248;
literal IO0702$Q_CPYBUF1 = -1072693244;
literal IO0702$Q_CPYBUF2 = -1072693240;
literal IO0702$Q_CPYBUF3 = -1072693236;
literal IO0702$Q_CPYBUF4 = -1072693232;
literal IO0702$Q_CPYBUF5 = -1072693228;
literal IO0702$Q_CPYBUF6 = -1072693224;
literal IO0702$Q_CPYBUF7 = -1072693220;
literal IO0702$Q_FG = -1072693216;
literal IO0702$Q_BG = -1072693212;
literal IO0702$Q_PLANEMASK = -1072693208;
literal IO0702$Q_PIXMASK = -1072693204;
literal IO0702$Q_MODE = -1072693200;
literal IO0702$Q_BOOLOP = -1072693196;
literal IO0702$Q_PIXSHIFT = -1072693192;
literal IO0702$Q_ADDR_REG = -1072693188;
literal IO0702$Q_BRES1 = -1072693184;
literal IO0702$Q_BRES2 = -1072693180;
literal IO0702$Q_BRES3 = -1072693176;
literal IO0702$Q_BCONT = -1072693172;
literal IO0702$Q_DEEP = -1072693168;
literal IO0702$Q_START = -1072693164;
literal IO0702$Q_CI = -1072693160;
literal IO0702$Q_V_REF_COUNT = -1072693152;
literal IO0702$Q_V_HOR = -1072693148;
literal IO0702$Q_V_VER = -1072693144;
literal IO0702$Q_V_BASE_ADDR = -1072693140;
literal IO0702$Q_VV = -1072693136;
literal IO0702$Q_EI = -1072693132;
literal IO0702$Q_TCCLK_COUNT = -1072693128;
literal IO0702$Q_VIDCLK_COUNT = -1072693124;
literal IO0702$Q_RAMDAC_ADDR_LO = -1071906816;
literal IO0702$Q_RAMDAC_ADDR_HI = -1071906812;
literal IO0702$Q_RAMDAC_REG_ADDR = -1071906808;
literal IO0702$Q_RAMDAC_MAP_LOC = -1071906804;
literal IO0702$Q_FB = -1071644672;
literal IO0702$Q_SLOT0_DENSE_BASE = 0;
literal IO0702$Q_SLOT1_DENSE_BASE = 536870912;
literal IO0702$Q_SLOT4_DENSE_BASE = -2147483648;
literal IO0702$Q_SLOT5_DENSE_BASE = -1610612736;
literal IO0702$Q_SLOT6_DENSE_BASE = -1073741824;
literal IO0702$Q_SLOT0_SPARSE_BASE = 268435456;
literal IO0702$Q_SLOT1_SPARSE_BASE = 805306368;
literal IO0702$Q_SLOT4_SPARSE_BASE = -1879048192;
literal IO0702$Q_SLOT5_SPARSE_BASE = -1342177280;
literal IO0702$Q_LDP_DENSE = -1610350560; !  Ethernet DMA pointer
literal IO0702$Q_NI_ADR_ROM_DENSE = -1610088448; !  Ethernet address ROM
literal IO0702$Q_LANCE_RDP_DENSE = -1609826304; !  Lance ethernet CSR
 
!*** MODULE $IO0802DEF ***
literal IO0802$Q_PCI_IO = -2147483648;  !  1 8000 0000
!  One 8 KB page can map the following APC control registers
literal IO0802$Q_APC_CONTROL = -805306368; !  1 D000 0000
literal IO0802$Q_APC_HAE = -805306368;  !  1 D000 0000
literal IO0802$Q_APC_INTERVAL_TIMER = -805306240; !  1 D000 0080
literal IO0802$Q_APC_BUFFER_STATUS = -805306176; !  1 D000 00C0
literal IO0802$Q_APC_ERROR_STATUS = -805306112; !  1 D000 0100
literal IO0802$Q_APC_ERROR_MASK = -805306048; !  1 D000 0140
literal IO0802$Q_APC_LAST_PREFIX = -805305984; !  1 D000 0180
literal IO0802$Q_APC_LOCK_ADDRESS = -805305920; !  1 D000 01C0
literal IO0802$Q_APC_LOCAL_DEVICE_PORT = -805305856; !  1 D000 0200
literal IO0802$Q_APC_MISC_DATA0 = -805305728; !  1 D000 0280
literal IO0802$Q_APC_MISC_DATA1 = -805305664; !  1 D000 02C0
!  The prefix registers occupy 16 KB.  Use 2 8 KB pages to map.
literal IO0802$Q_APC_PREFIX = -788529152; !  1 d100 0000
!  One 8 KB page can map the APC configuration and diagnostic registers
literal IO0802$Q_APC_CONFIG = -536870912; !  1 e000 0000
literal IO0802$Q_APC_CACHE_CONTROL = -536870912; !  1 e000 0000
literal IO0802$Q_APC_PCI_CONFIG = -536870784; !  1 e000 0080
literal IO0802$Q_APC_PCI_STATUS = -536870720; !  1 e000 00C0
literal IO0802$Q_APC_MEM_BANK_01 = -536870656; !  1 e000 0100
literal IO0802$Q_APC_MEM_BANK_23 = -536870624; !  1 e000 0120
literal IO0802$Q_APC_MEM_BANK_45 = -536870592; !  1 e000 0140
literal IO0802$Q_APC_MEM_BANK_67 = -536870560; !  1 e000 0160
literal IO0802$Q_APC_MEM_CONTROL = -536870528; !  1 e000 0180
literal IO0802$Q_APC_EXT_PC_HOLE = -536870464; !  1 e000 01C0
literal IO0802$Q_APC_EXT_PROG_HOLE = -536870432; !  1 e000 01E0
literal IO0802$Q_APC_DIAG_CONTROL = -536870400; !  1 e000 0200
literal IO0802$Q_APC_DIAG_DATA0 = -536870272; !  1 e000 0280
literal IO0802$Q_APC_DIAG_DATA1 = -536870208; !  1 e000 02C0
literal IO0802$Q_APC_REV_LEVEL = -536870144; !  1 e000 0300
literal IO0802$Q_APC_PARITY_CONTROL = -536870080; !  1 e000 0340
literal IO0802$Q_APC_SM_ADDRESS = -536869888; !  1 e000 0400
literal IO0802$Q_APC_SM_DATA = -536869824; !  1 e000 0440
literal IO0802$Q_PCI_SPARSE_MEM = 0;    !  2 0000 0000
literal IO0802$Q_PCI_DENSE_MEM = 0;     !  3 0000 0000
 
!*** MODULE $IO0902DEF ***
literal IO0902$Q_CPU0_PA_L = -2147483648;
literal IO0902$Q_CPU0_PA_H = 131;
literal IO0902$Q_CPU1_PA_L = -2130706432;
literal IO0902$Q_CPU1_PA_H = 131;
literal IO0902$Q_CPU2_PA_L = -2113929216;
literal IO0902$Q_CPU2_PA_H = 131;
literal IO0902$Q_CPU3_PA_L = -2097152000;
literal IO0902$Q_CPU3_PA_H = 131;
literal IO0902$Q_SMM0_PA_L = -2013265920;
literal IO0902$Q_SMM0_PA_H = 131;
literal IO0902$Q_SMM1_PA_L = -1996488704;
literal IO0902$Q_SMM1_PA_H = 131;
literal IO0902$Q_SMM2_PA_L = -1979711488;
literal IO0902$Q_SMM2_PA_H = 131;
literal IO0902$Q_SMM3_PA_L = -1962934272;
literal IO0902$Q_SMM3_PA_H = 131;
literal IO0902$Q_T2IO_PA_L = -1912602624;
literal IO0902$Q_T2IO_PA_H = 131;
literal IO0902$Q_EIO_PA_L = -1895825408;
literal IO0902$Q_EIO_PA_H = 131;
literal IO0902$Q_IIC_PA_L = -1610570240;
literal IO0902$Q_IIC_PA_H = 131;
literal IO0902$Q_DS1287_PA_L = -1610609152;
literal IO0902$Q_DS1287_PA_H = 131;
literal IO0902$Q_MASTER_ICR_L = -1610570112;
literal IO0902$Q_MASTER_ICR_H = 131;
literal IO0902$Q_SLAVE0_ICR_L = -1610570048;
literal IO0902$Q_SLAVE0_ICR_H = 131;
literal IO0902$Q_SLAVE1_ICR_L = -1610569920;
literal IO0902$Q_SLAVE1_ICR_H = 131;
literal IO0902$Q_SLAVE2_ICR_L = -1610569856;
literal IO0902$Q_SLAVE2_ICR_H = 131;
literal IO0902$L_MASTER_ICR_PCI = 1332;
literal IO0902$L_SLAVE0_ICR_PCI = 1334;
literal IO0902$L_SLAVE1_ICR_PCI = 1338;
literal IO0902$L_SLAVE2_ICR_PCI = 1340;
literal IO0902$L_SLAVE3_ICR_PCI = 1342;
literal IO0902$L_SLAVE4_ICR_PCI = 1336;
literal IO0902$L_ESC_INT1_ICR = 32;
literal IO0902$L_ESC_INT2_ICR = 160;
literal IO0902$Q_MASTER_IMR_L = -1610570080;
literal IO0902$Q_MASTER_IMR_H = 131;
literal IO0902$Q_SLAVE0_IMR_L = -1610570016;
literal IO0902$Q_SLAVE0_IMR_H = 131;
literal IO0902$Q_SLAVE1_IMR_L = -1610569888;
literal IO0902$Q_SLAVE1_IMR_H = 131;
literal IO0902$Q_SLAVE2_IMR_L = -1610569824;
literal IO0902$Q_SLAVE2_IMR_H = 131;
literal IO0902$L_MASTER_IMR_PCI = 1333;
literal IO0902$L_SLAVE0_IMR_PCI = 1335;
literal IO0902$L_SLAVE1_IMR_PCI = 1339;
literal IO0902$L_SLAVE2_IMR_PCI = 1341;
literal IO0902$L_SLAVE3_IMR_PCI = 1343;
literal IO0902$L_SLAVE4_IMR_PCI = 1337;
literal IO0902$L_ESC_INT1_IMR = 33;
literal IO0902$L_ESC_INT2_IMR = 161;
literal IO0902$Q_SLU0_RCV_BUF_L = -1610580224;
literal IO0902$Q_SLU0_RCV_BUF_H = 131;
literal IO0902$Q_SLU0_IER_L = -1610580192;
literal IO0902$Q_SLU0_IER_H = 131;
literal IO0902$Q_SLU0_IIR_L = -1610580160;
literal IO0902$Q_SLU0_IIR_H = 131;
literal IO0902$Q_SLU0_L_CTL_L = -1610580128;
literal IO0902$Q_SLU0_L_CTL_H = 131;
literal IO0902$Q_SLU0_M_CTL_L = -1610580096;
literal IO0902$Q_SLU0_M_CTL_H = 131;
literal IO0902$Q_SLU0_L_STAT_L = -1610580064;
literal IO0902$Q_SLU0_L_STAT_H = 131;
literal IO0902$Q_SLU0_M_STAT_L = -1610580032;
literal IO0902$Q_SLU0_M_STAT_H = 131;
literal IO0902$L_SLU0_RCV_BUF_PCI = 1016;
literal IO0902$L_SLU0_IER_PCI = 1017;
literal IO0902$L_SLU0_IIR_PCI = 1018;
literal IO0902$L_SLU0_L_CTL_PCI = 1019;
literal IO0902$L_SLU0_M_CTL_PCI = 1020;
literal IO0902$L_SLU0_L_STAT_PCI = 1021;
literal IO0902$L_SLU0_M_STAT_PCI = 1022;
literal IO0902$Q_SLU1_RCV_BUF_L = -1610588416;
literal IO0902$Q_SLU1_RCV_BUF_H = 131;
literal IO0902$Q_SLU1_IER_L = -1610588384;
literal IO0902$Q_SLU1_IER_H = 131;
literal IO0902$Q_SLU1_IIR_L = -1610588352;
literal IO0902$Q_SLU1_IIR_H = 131;
literal IO0902$Q_SLU1_L_CTL_L = -1610588320;
literal IO0902$Q_SLU1_L_CTL_H = 131;
literal IO0902$Q_SLU1_M_CTL_L = -1610588288;
literal IO0902$Q_SLU1_M_CTL_H = 131;
literal IO0902$Q_SLU1_L_STAT_L = -1610588256;
literal IO0902$Q_SLU1_L_STAT_H = 131;
literal IO0902$Q_SLU1_M_STAT_L = -1610588224;
literal IO0902$Q_SLU1_M_STAT_H = 131;
literal IO0902$L_SLU1_RCV_BUF_PCI = 760;
literal IO0902$L_SLU1_IER_PCI = 761;
literal IO0902$L_SLU1_IIR_PCI = 762;
literal IO0902$L_SLU1_L_CTL_PCI = 763;
literal IO0902$L_SLU1_M_CTL_PCI = 764;
literal IO0902$L_SLU1_L_STAT_PCI = 765;
literal IO0902$L_SLU1_M_STAT_PCI = 766;
literal IO0902$B_KBD_CMD_PCI = 100;
literal IO0902$B_KBD_DATA_PCI = 96;
literal IO0902$Q_KBD_CMD_L = -1610609536;
literal IO0902$Q_KBD_CMD_H = 131;
literal IO0902$Q_KBD_DATA_L = -1610609664;
literal IO0902$Q_KBD_DATA_H = 131;
literal IO0902$Q_PCI_SLOT0_CFG_PA_L = -1878982656;
literal IO0902$Q_PCI_SLOT0_CFG_PA_H = 131;
literal IO0902$Q_PCI_SLOT1_CFG_PA_L = -1878917120;
literal IO0902$Q_PCI_SLOT1_CFG_PA_H = 131;
literal IO0902$Q_PCI_SLOT2_CFG_PA_L = -1878786048;
literal IO0902$Q_PCI_SLOT2_CFG_PA_H = 131;
literal IO0902$Q_PCI_SLOT3_CFG_PA_L = -1878523904;
literal IO0902$Q_PCI_SLOT3_CFG_PA_H = 131;
literal IO0902$Q_PCI_SLOT4_CFG_PA_L = -1877999616;
literal IO0902$Q_PCI_SLOT4_CFG_PA_H = 131;
literal IO0902$Q_PCI_SLOT5_CFG_PA_L = -1876951040;
literal IO0902$Q_PCI_SLOT5_CFG_PA_H = 131;
literal IO0902$Q_PCI_SLOT6_CFG_PA_L = -1874853888;
literal IO0902$Q_PCI_SLOT6_CFG_PA_H = 131;
literal IO0902$Q_PCI_SLOT7_CFG_PA_L = -1870659584;
literal IO0902$Q_PCI_SLOT7_CFG_PA_H = 131;
literal IO0902$Q_PCI_SLOT8_CFG_PA_L = -1862270976;
literal IO0902$Q_PCI_SLOT8_CFG_PA_H = 131;
literal IO0902$Q_PCI_SLOT9_CFG_PA_L = -1845493760;
literal IO0902$Q_PCI_SLOT9_CFG_PA_H = 131;
literal IO0902$Q_PCI_SLOT10_CFG_PA_L = -1811939328;
literal IO0902$Q_PCI_SLOT10_CFG_PA_H = 131;
literal IO0902$Q_PCI_SPARSE_IO_L = -1610612736;
literal IO0902$Q_PCI_SPARSE_IO_H = 131;
literal IO0902$Q_PCI_SPARSE_MEM_L = 0;
literal IO0902$Q_PCI_SPARSE_MEM_H = 130;
literal IO0902$Q_PCI_DENSE_MEM_L = -1073741824;
literal IO0902$Q_PCI_DENSE_MEM_H = 131;
literal IO0902$Q_PCI_CONFIG_SPACE_L = -1879048192;
literal IO0902$Q_PCI_CONFIG_SPACE_H = 131;
literal IO0902$Q_PCI_EIO_SPARSE_IO_L = -1073741824;
literal IO0902$Q_PCI_EIO_SPARSE_IO_H = 129;
literal IO0902$Q_PCI_EIO_SPARSE_MEM_L = 0;
literal IO0902$Q_PCI_EIO_SPARSE_MEM_H = 131;
literal IO0902$Q_PCI_EIO_DENSE_MEM_L = -2147483648;
literal IO0902$Q_PCI_EIO_DENSE_MEM_H = 129;
literal IO0902$Q_PCI_EIO_CONFIG_SPACE_L = -1744830464;
literal IO0902$Q_PCI_EIO_CONFIG_SPACE_H = 131;
literal IO0902$Q_T4MASTER_ICR_L = -1073699200;
literal IO0902$Q_T4MASTER_ICR_H = 129;
literal IO0902$Q_T4SLAVE0_ICR_L = -1073699136;
literal IO0902$Q_T4SLAVE0_ICR_H = 129;
literal IO0902$Q_T4MASTER_IMR_L = -1073699168;
literal IO0902$Q_T4MASTER_IMR_H = 129;
literal IO0902$Q_T4SLAVE0_IMR_L = -1073699104;
literal IO0902$Q_T4SLAVE0_IMR_H = 129;
literal STDIO_VECTOR_COUNT = 56;
literal EXTIO_VECTOR_COUNT = 16;
 
!*** MODULE $IO0C05DEF ***
literal IO0C05$L_NODE_PA_H = 255;       !  High order word
literal IO0C05$L_NODE0_PA_L = -2013265920;
literal IO0C05$L_NODE1_PA_L = -2009071616;
literal IO0C05$L_NODE2_PA_L = -2004877312;
literal IO0C05$L_NODE3_PA_L = -2000683008;
literal IO0C05$L_NODE4_PA_L = -1996488704;
literal IO0C05$L_NODE5_PA_L = -1992294400;
literal IO0C05$L_NODE6_PA_L = -1988100096;
literal IO0C05$L_NODE7_PA_L = -1983905792;
literal IO0C05$L_NODE8_PA_L = -1979711488;
literal IO0C05$L_TLIPINTR_L = -1912602560; !  IP INTR REG
literal IO0C05$L_TLIOINTR4_L = -1912602368; !  I/O INT REG 4
literal IO0C05$L_TLIOINTR5_L = -1912602304; !  I/O INT REG 5
literal IO0C05$L_TLIOINTR6_L = -1912602240; !  I/O INT REG 6
literal IO0C05$L_TLIOINTR7_L = -1912602176; !  I/O INT REG 4
literal IO0C05$L_TLIOINTR8_L = -1912602112; !  I/O INT REG 7
literal IO0C05$L_TLWSDQR4_L = -1912601600; !  WIND SPACE DC4
literal IO0C05$L_TLWSDQR5_L = -1912601536; !  WIND SPACE DC5
literal IO0C05$L_TLWSDQR6_L = -1912601472; !  WIND SPACE DC6
literal IO0C05$L_TLWSDQR7_L = -1912601408; !  WIND SPACE DC7
literal IO0C05$L_TLWSDQR8_L = -1912601344; !  WIND SPACE DC8
literal IO0C05$L_TLRMDQRX_L = -1912601088; !  RM DEC CNT X
literal IO0C05$L_TLRMDQR8_L = -1912601024; !  RM DEC CNT 8
literal IO0C05$L_TLRDRD_L = -1912600576; !  WIND SP RD DATA DATA
literal IO0C05$L_TLRDRE_L = -1912600512; !  WIND SP RD DATA ERR
literal IO0C05$L_TLMCR_L = -1912596352; !  MEMORY CNTRL REG
literal IO0C05$L_UART0B_RR0_L = -1610612736;
literal IO0C05$L_UART0B_RR8_L = -1610612672;
literal IO0C05$L_UART0A_RR0_L = -1610612608;
literal IO0C05$L_UART0A_RR8_L = -1610612544;
literal IO0C05$L_UART1B_RR0_L = -1593835520;
literal IO0C05$L_UART1B_RR8_L = -1593835456;
literal IO0C05$L_UART1A_RR0_L = -1593835392;
literal IO0C05$L_UART1A_RR8_L = -1593835328;
literal IO0C05$L_WATCH_SECONDS_L = -1342177280;
literal IO0C05$L_WATCH_MINUTES_L = -1342177152;
literal IO0C05$L_WATCH_HOURS_L = -1342177024;
literal IO0C05$L_WATCH_DAY_OF_MONTH_L = -1342176832;
literal IO0C05$L_WATCH_MONTH_L = -1342176768;
literal IO0C05$L_WATCH_YEAR_L = -1342176704;
literal IO0C05$L_WATCH_CSRA_L = -1342176640;
literal IO0C05$L_WATCH_CSRB_L = -1342176576;
literal IO0C05$L_WATCH_CSRC_L = -1342176512;
literal IO0C05$L_WATCH_CSRD_L = -1342176448;
literal IO0C05$L_WATCH_RAM_L = -1342176384;
literal IO0C05$L_GBUS_WHAMI_L = -1073741824;
literal IO0C05$L_GBUS_LED0_L = -1056964608;
literal IO0C05$L_GBUS_LED1_L = -1040187392;
literal IO0C05$L_GBUS_LED2_L = -1023410176;
literal IO0C05$L_GBUS_MISCR_L = -1006632960;
literal IO0C05$L_GBUS_MISCW_L = -989855744;
literal IO0C05$L_GBUS_TLSBRST_L = -973078528;
literal IO0C05$L_GBUS_SERNUM_L = -956301312;
literal IO0C05$L_GBUS_TEST_L = -939524096;
literal IO0C05$L_SLOT0_TLDEV_L = -2013265920; !  DEVICE
literal IO0C05$L_SLOT0_TLBER_L = -2013265856; !  ERROR
literal IO0C05$L_SLOT0_TLCNR_L = -2013265792; !  CONFIGURATION
literal IO0C05$L_SLOT0_TLVID_L = -2013265728; !  VIRT ID
literal IO0C05$L_SLOT0_TLMMR0_L = -2013265408; !  MEM MAPPING 0
literal IO0C05$L_SLOT0_TLMMR1_L = -2013265344; !  MEM MAPPING 1
literal IO0C05$L_SLOT0_TLMMR2_L = -2013265280; !  MEM MAPPING 2
literal IO0C05$L_SLOT0_TLMMR3_L = -2013265216; !  MEM MAPPING 3
literal IO0C05$L_SLOT0_TLMMR4_L = -2013265152; !  MEM MAPPING 4
literal IO0C05$L_SLOT0_TLMMR5_L = -2013265088; !  MEM MAPPING 5
literal IO0C05$L_SLOT0_TLMMR6_L = -2013265024; !  MEM MAPPING 6
literal IO0C05$L_SLOT0_TLMMR7_L = -2013264960; !  MEM MAPPING 7
literal IO0C05$L_SLOT0_TLFADR0_L = -2013264384; !  FAILING ADDR 0
literal IO0C05$L_SLOT0_TLFADR1_L = -2013264320; !  FAILING ADDR 1
literal IO0C05$L_SLOT0_TLESR0_L = -2013264256; !  BUS ERROR SYNDROME 0
literal IO0C05$L_SLOT0_TLESR1_L = -2013264192; !  BUS ERROR SYNDROME 1
literal IO0C05$L_SLOT0_TLESR2_L = -2013264128; !  BUS ERROR SYNDROME 2
literal IO0C05$L_SLOT0_TLESR3_L = -2013264064; !  BUS ERROR SYNDROME 3
literal IO0C05$L_SLOT0_TLDIAG_L = -2013261824; !  TLEP DIAG SETUP
literal IO0C05$L_SLOT0_TLDTAGDATA_L = -2013261760; !  TLEP DTAG DATA
literal IO0C05$L_SLOT0_TLDTAGSTAT_L = -2013261696; !  TLEP DTAG STAT
literal IO0C05$L_SLOT0_TLMODCONFIG_L = -2013261632; !  TLEP MOD CONFIG
literal IO0C05$L_SLOT0_TLINTRMASK0_L = -2013261568; !  TLEP INT MASK 0
literal IO0C05$L_SLOT0_TLINTRMASK1_L = -2013261504; !  TLEP INT MASK 1
literal IO0C05$L_SLOT0_TLINTRSUM0_L = -2013261440; !  TLEP INT SUM 0
literal IO0C05$L_SLOT0_TLINTRSUM1_L = -2013261376; !  TLEP INT SUM 1
literal IO0C05$L_SLOT0_TLCON00_L = -2013261312; !  TLEP CONS COMM
literal IO0C05$L_SLOT0_TLCON00A_L = -2013261248; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT0_TLCON00B_L = -2013261184; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT0_TLCON00C_L = -2013261120; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT0_TLCON10_L = -2013261056; !  TLEP CONS COMM
literal IO0C05$L_SLOT0_TLCON10A_L = -2013260992; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT0_TLCON10B_L = -2013260928; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT0_TLCON10C_L = -2013260864; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT0_TLCON01_L = -2013260800; !  TLEP CONS COMM
literal IO0C05$L_SLOT0_TLCON11_L = -2013260736; !  TLEP CONS COMM
literal IO0C05$L_SLOT0_TLEPAERR_L = -2013260544; !  TLEP ADG ERROR
literal IO0C05$L_SLOT0_TLEPDERR_L = -2013260480; !  TLEP DIGA ERROR
literal IO0C05$L_SLOT0_TLEPMERR_L = -2013260416; !  TLEP MMG ERROR
literal IO0C05$L_SLOT0_TLEP_VMG_L = -2013260352; !  TLEP VOLT MARG
literal IO0C05$L_SLOT0_TLDMCMD_L = -2013260288; !  TLEP DM CMD 
literal IO0C05$L_SLOT0_TLDMADRA_L = -2013260160; !  TLEP DM A
literal IO0C05$L_SLOT0_TLDMADRB_L = -2013260096; !  TLEP DM B
literal IO0C05$L_SLOT0_TLPM_CMD_L = -2013259776; !  TLEP PERF MON CMD
literal IO0C05$L_SLOT0_TLSECR_L = -2013259776; !  TLMEM SECR EEPROM CNTL
literal IO0C05$L_SLOT0_TLPM_TOT_CYC_L = -2013259712; !  TLEP # OF CYCLES
literal IO0C05$L_SLOT0_TLMIR_L = -2013259712; !  TLMEM MEM INTERLEAVE
literal IO0C05$L_SLOT0_TLPM_EV5_LAT_L = -2013259648; !  TLEP EV5 RD LAT
literal IO0C05$L_SLOT0_TLMCR_L = -2013259648; !  TLMEM MEM CONFIG 
literal IO0C05$L_SLOT0_TLPM_READ_LAT_L = -2013259584; !  TLEP AV RD LAT
literal IO0C05$L_SLOT0_TLSTAIR_L = -2013259584; !  TLMEM SELFTEST ADR ISOL
literal IO0C05$L_SLOT0_TLPM_SYS_OWNER_L = -2013259520; !  TLEP # CYC OF SYS OWNER
literal IO0C05$L_SLOT0_TLSTER_L = -2013259520; !  TLMEM SELFTEST ERR REG
literal IO0C05$L_SLOT0_TLPM_CMD_SILO_L = -2013259456; !  TLEP CMD SILO
literal IO0C05$L_SLOT0_TLMER_L = -2013259456; !  TLMEM MEM ERROR REG
literal IO0C05$L_SLOT0_TLPM_LOCK_L = -2013259392; !  TLEP # LOCK ACKS
literal IO0C05$L_SLOT0_TLMDRA_L = -2013259392; !  TLMEM MEM DIAG REG A
literal IO0C05$L_SLOT0_TLPM_MB_L = -2013259328; !  TLEP # MB ACKS
literal IO0C05$L_SLOT0_TLMDRB_L = -2013259328; !  TLMEM MEM DIAG REG B
literal IO0C05$L_SLOT0_TLPM_SD_TOTAL_L = -2013259264; !  TLEP # SD
literal IO0C05$L_SLOT0_TLPM_SD_ACKED_L = -2013259200; !  TLEP # SD ACKS
literal IO0C05$L_SLOT0_TLPM_RD_CSR_L = -2013259136; !  TLEP # CSR RDS
literal IO0C05$L_SLOT0_TLPM_RD_L = -2013259072; !  TLEP # MEM RD MISS
literal IO0C05$L_SLOT0_TLPM_RD_MOD_L = -2013259008; !  TLEP # RD MISS MODS
literal IO0C05$L_SLOT0_TLPM_RD_STC_L = -2013258944; !  TLEP # RD MISS STXC
literal IO0C05$L_SLOT0_TLPM_VICTIM_L = -2013258880; !  TLEP # BC VICTIMS
literal IO0C05$L_SLOT0_TLPM_WR_CSR_L = -2013258816; !  TLEP # CSR WR CMDS
literal IO0C05$L_SLOT0_TLPM_WR_L = -2013258752; !  TLEP # WR BLK CMDS ACKED
literal IO0C05$L_SLOT0_TLPM_WR_LOCK_L = -2013258688; !  TLEP # WR BLK LK CMDS ACKED
literal IO0C05$L_SLOT0_TLPM_INVAL_L = -2013258624; !  TLEP # INVAL 
literal IO0C05$L_SLOT0_TLPM_SET_SHRD_L = -2013258560; !  TLEP # SET SHRDS
literal IO0C05$L_SLOT0_TLPM_RD_DIRTY_L = -2013258496; !  TLEP # RD DIRTYS
literal IO0C05$L_SLOT0_TLPM_ADR_SILO_L = -2013258432; !  TLEP ADR SILO REG
literal IO0C05$L_SLOT0_RM_RANG_REG0A_L = -2013258240; !  TLEP RM MR CHAN0A
literal IO0C05$L_SLOT0_RM_RANG_REG0B_L = -2013258176; !  TLEP RM MR CHAN0B
literal IO0C05$L_SLOT0_RM_RANG_REG1A_L = -2013258112; !  TLEP RM MR CHAN1A
literal IO0C05$L_SLOT0_RM_RANG_REG1B_L = -2013258048; !  TLEP RM MR CHAN1B
literal IO0C05$L_SLOT0_TLSTDERA_0_L = -2013200384; !  TLMEM SELFTEST DATA ERR REG A0
literal IO0C05$L_SLOT0_TLSTDERB_0_L = -2013200320; !  TLMEM SELFTEST DATA ERR REG B0
literal IO0C05$L_SLOT0_TLSTDERC_0_L = -2013200256; !  TLMEM SELFTEST DATA ERR REG C0
literal IO0C05$L_SLOT0_TLSTDERD_0_L = -2013200192; !  TLMEM SELFTEST DATA ERR REG D0
literal IO0C05$L_SLOT0_TLSTDERE_0_L = -2013200128; !  TLMEM SELFTEST DATA ERR REG E0
literal IO0C05$L_SLOT0_TLDDR0_L = -2013200064; !  TLMEM DATA DIAG REG 0
literal IO0C05$L_SLOT0_TLSTDERA_1_L = -2013184000; !  TLMEM SELFTEST DATA ERR REG A1
literal IO0C05$L_SLOT0_TLSTDERB_1_L = -2013183936; !  TLMEM SELFTEST DATA ERR REG B1
literal IO0C05$L_SLOT0_TLSTDERC_1_L = -2013183872; !  TLMEM SELFTEST DATA ERR REG C1
literal IO0C05$L_SLOT0_TLSTDERD_1_L = -2013183808; !  TLMEM SELFTEST DATA ERR REG D1
literal IO0C05$L_SLOT0_TLSTDERE_1_L = -2013183744; !  TLMEM SELFTEST DATA ERR REG E1
literal IO0C05$L_SLOT0_TLDDR1_L = -2013183680; !  TLMEM DATA DIAG REG 1
literal IO0C05$L_SLOT0_TLSTDERA_2_L = -2013167616; !  TLMEM SELFTEST DATA ERR REG A2
literal IO0C05$L_SLOT0_TLSTDERB_2_L = -2013167552; !  TLMEM SELFTEST DATA ERR REG B2
literal IO0C05$L_SLOT0_TLSTDERC_2_L = -2013167488; !  TLMEM SELFTEST DATA ERR REG C2
literal IO0C05$L_SLOT0_TLSTDERD_2_L = -2013167424; !  TLMEM SELFTEST DATA ERR REG D2
literal IO0C05$L_SLOT0_TLSTDERE_2_L = -2013167360; !  TLMEM SELFTEST DATA ERR REG E2
literal IO0C05$L_SLOT0_TLDDR2_L = -2013167296; !  TLMEM DATA DIAG REG 2
literal IO0C05$L_SLOT0_TLSTDERA_3_L = -2013151232; !  TLMEM SELFTEST DATA ERR REG A3
literal IO0C05$L_SLOT0_TLSTDERB_3_L = -2013151168; !  TLMEM SELFTEST DATA ERR REG B3
literal IO0C05$L_SLOT0_TLSTDERC_3_L = -2013151104; !  TLMEM SELFTEST DATA ERR REG C3
literal IO0C05$L_SLOT0_TLSTDERD_3_L = -2013151040; !  TLMEM SELFTEST DATA ERR REG D3
literal IO0C05$L_SLOT0_TLSTDERE_3_L = -2013150976; !  TLMEM SELFTEST DATA ERR REG E3
literal IO0C05$L_SLOT0_TLDDR3_L = -2013150912; !  TLMEM DATA DIAG REG 3
literal IO0C05$L_SLOT1_TLDEV_L = -2009071616; !  DEVICE
literal IO0C05$L_SLOT1_TLBER_L = -2009071552; !  ERROR
literal IO0C05$L_SLOT1_TLCNR_L = -2009071488; !  CONFIGURATION
literal IO0C05$L_SLOT1_TLVID_L = -2009071424; !  VIRT ID
literal IO0C05$L_SLOT1_TLMMR0_L = -2009071104; !  MEM MAPPING 0
literal IO0C05$L_SLOT1_TLMMR1_L = -2009071040; !  MEM MAPPING 1
literal IO0C05$L_SLOT1_TLMMR2_L = -2009070976; !  MEM MAPPING 2
literal IO0C05$L_SLOT1_TLMMR3_L = -2009070912; !  MEM MAPPING 3
literal IO0C05$L_SLOT1_TLMMR4_L = -2009070848; !  MEM MAPPING 4
literal IO0C05$L_SLOT1_TLMMR5_L = -2009070784; !  MEM MAPPING 5
literal IO0C05$L_SLOT1_TLMMR6_L = -2009070720; !  MEM MAPPING 6
literal IO0C05$L_SLOT1_TLMMR7_L = -2009070656; !  MEM MAPPING 7
literal IO0C05$L_SLOT1_TLFADR0_L = -2009070080; !  FAILING ADDR 0
literal IO0C05$L_SLOT1_TLFADR1_L = -2009070016; !  FAILING ADDR 1
literal IO0C05$L_SLOT1_TLESR0_L = -2009069952; !  BUS ERROR SYNDROME 0
literal IO0C05$L_SLOT1_TLESR1_L = -2009069888; !  BUS ERROR SYNDROME 1
literal IO0C05$L_SLOT1_TLESR2_L = -2009069824; !  BUS ERROR SYNDROME 2
literal IO0C05$L_SLOT1_TLESR3_L = -2009069760; !  BUS ERROR SYNDROME 3
literal IO0C05$L_SLOT1_TLDIAG_L = -2009067520; !  TLEP DIAG SETUP
literal IO0C05$L_SLOT1_TLDTAGDATA_L = -2009067456; !  TLEP DTAG DATA
literal IO0C05$L_SLOT1_TLDTAGSTAT_L = -2009067392; !  TLEP DTAG STAT
literal IO0C05$L_SLOT1_TLMODCONFIG_L = -2009067328; !  TLEP MOD CONFIG
literal IO0C05$L_SLOT1_TLINTRMASK0_L = -2009067264; !  TLEP INT MASK 0
literal IO0C05$L_SLOT1_TLINTRMASK1_L = -2009067200; !  TLEP INT MASK 1
literal IO0C05$L_SLOT1_TLINTRSUM0_L = -2009067136; !  TLEP INT SUM 0
literal IO0C05$L_SLOT1_TLINTRSUM1_L = -2009067072; !  TLEP INT SUM 1
literal IO0C05$L_SLOT1_TLCON00_L = -2009067008; !  TLEP CONS COMM
literal IO0C05$L_SLOT1_TLCON00A_L = -2009066944; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT1_TLCON00B_L = -2009066880; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT1_TLCON00C_L = -2009066816; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT1_TLCON10_L = -2009066752; !  TLEP CONS COMM
literal IO0C05$L_SLOT1_TLCON10A_L = -2009066688; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT1_TLCON10B_L = -2009066624; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT1_TLCON10C_L = -2009066560; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT1_TLCON01_L = -2009066496; !  TLEP CONS COMM
literal IO0C05$L_SLOT1_TLCON11_L = -2009066432; !  TLEP CONS COMM
literal IO0C05$L_SLOT1_TLEPAERR_L = -2009066240; !  TLEP ADG ERROR
literal IO0C05$L_SLOT1_TLEPDERR_L = -2009066176; !  TLEP DIGA ERROR
literal IO0C05$L_SLOT1_TLEPMERR_L = -2009066112; !  TLEP MMG ERROR
literal IO0C05$L_SLOT1_TLEP_VMG_L = -2009066048; !  TLEP VOLT MARG
literal IO0C05$L_SLOT1_TLDMCMD_L = -2009065984; !  TLEP DM CMD 
literal IO0C05$L_SLOT1_TLDMADRA_L = -2009065856; !  TLEP DM A
literal IO0C05$L_SLOT1_TLDMADRB_L = -2009065792; !  TLEP DM B
literal IO0C05$L_SLOT1_TLPM_CMD_L = -2009065472; !  TLEP PERF MON CMD
literal IO0C05$L_SLOT1_TLSECR_L = -2009065472; !  TLMEM SECR EEPROM CNTL
literal IO0C05$L_SLOT1_TLPM_TOT_CYC_L = -2009065408; !  TLEP # OF CYCLES
literal IO0C05$L_SLOT1_TLMIR_L = -2009065408; !  TLMEM MEM INTERLEAVE
literal IO0C05$L_SLOT1_TLPM_EV5_LAT_L = -2009065344; !  TLEP EV5 RD LAT
literal IO0C05$L_SLOT1_TLMCR_L = -2009065344; !  TLMEM MEM CONFIG 
literal IO0C05$L_SLOT1_TLPM_READ_LAT_L = -2009065280; !  TLEP AV RD LAT
literal IO0C05$L_SLOT1_TLSTAIR_L = -2009065280; !  TLMEM SELFTEST ADR ISOL
literal IO0C05$L_SLOT1_TLPM_SYS_OWNER_L = -2009065216; !  TLEP # CYC OF SYS OWNER
literal IO0C05$L_SLOT1_TLSTER_L = -2009065216; !  TLMEM SELFTEST ERR REG
literal IO0C05$L_SLOT1_TLPM_CMD_SILO_L = -2009065152; !  TLEP CMD SILO
literal IO0C05$L_SLOT1_TLMER_L = -2009065152; !  TLMEM MEM ERROR REG
literal IO0C05$L_SLOT1_TLPM_LOCK_L = -2009065088; !  TLEP # LOCK ACKS
literal IO0C05$L_SLOT1_TLMDRA_L = -2009065088; !  TLMEM MEM DIAG REG A
literal IO0C05$L_SLOT1_TLPM_MB_L = -2009065024; !  TLEP # MB ACKS
literal IO0C05$L_SLOT1_TLMDRB_L = -2009065024; !  TLMEM MEM DIAG REG B
literal IO0C05$L_SLOT1_TLPM_SD_TOTAL_L = -2009064960; !  TLEP # SD
literal IO0C05$L_SLOT1_TLPM_SD_ACKED_L = -2009064896; !  TLEP # SD ACKS
literal IO0C05$L_SLOT1_TLPM_RD_CSR_L = -2009064832; !  TLEP # CSR RDS
literal IO0C05$L_SLOT1_TLPM_RD_L = -2009064768; !  TLEP # MEM RD MISS
literal IO0C05$L_SLOT1_TLPM_RD_MOD_L = -2009064704; !  TLEP # RD MISS MODS
literal IO0C05$L_SLOT1_TLPM_RD_STC_L = -2009064640; !  TLEP # RD MISS STXC
literal IO0C05$L_SLOT1_TLPM_VICTIM_L = -2009064576; !  TLEP # BC VICTIMS
literal IO0C05$L_SLOT1_TLPM_WR_CSR_L = -2009064512; !  TLEP # CSR WR CMDS
literal IO0C05$L_SLOT1_TLPM_WR_L = -2009064448; !  TLEP # WR BLK CMDS ACKED
literal IO0C05$L_SLOT1_TLPM_WR_LOCK_L = -2009064384; !  TLEP # WR BLK LK CMDS ACKED
literal IO0C05$L_SLOT1_TLPM_INVAL_L = -2009064320; !  TLEP # INVAL 
literal IO0C05$L_SLOT1_TLPM_SET_SHRD_L = -2009064256; !  TLEP # SET SHRDS
literal IO0C05$L_SLOT1_TLPM_RD_DIRTY_L = -2009064192; !  TLEP # RD DIRTYS
literal IO0C05$L_SLOT1_TLPM_ADR_SILO_L = -2009064128; !  TLEP ADR SILO REG
literal IO0C05$L_SLOT1_RM_RANG_REG0A_L = -2009063936; !  TLEP RM MR CHAN0A
literal IO0C05$L_SLOT1_RM_RANG_REG0B_L = -2009063872; !  TLEP RM MR CHAN0B
literal IO0C05$L_SLOT1_RM_RANG_REG1A_L = -2009063808; !  TLEP RM MR CHAN1A
literal IO0C05$L_SLOT1_RM_RANG_REG1B_L = -2009063744; !  TLEP RM MR CHAN1B
literal IO0C05$L_SLOT1_TLSTDERA_0_L = -2009006080; !  TLMEM SELFTEST DATA ERR REG A0
literal IO0C05$L_SLOT1_TLSTDERB_0_L = -2009006016; !  TLMEM SELFTEST DATA ERR REG B0
literal IO0C05$L_SLOT1_TLSTDERC_0_L = -2009005952; !  TLMEM SELFTEST DATA ERR REG C0
literal IO0C05$L_SLOT1_TLSTDERD_0_L = -2009005888; !  TLMEM SELFTEST DATA ERR REG D0
literal IO0C05$L_SLOT1_TLSTDERE_0_L = -2009005824; !  TLMEM SELFTEST DATA ERR REG E0
literal IO0C05$L_SLOT1_TLDDR0_L = -2009005760; !  TLMEM DATA DIAG REG 0
literal IO0C05$L_SLOT1_TLSTDERA_1_L = -2008989696; !  TLMEM SELFTEST DATA ERR REG A1
literal IO0C05$L_SLOT1_TLSTDERB_1_L = -2008989632; !  TLMEM SELFTEST DATA ERR REG B1
literal IO0C05$L_SLOT1_TLSTDERC_1_L = -2008989568; !  TLMEM SELFTEST DATA ERR REG C1
literal IO0C05$L_SLOT1_TLSTDERD_1_L = -2008989504; !  TLMEM SELFTEST DATA ERR REG D1
literal IO0C05$L_SLOT1_TLSTDERE_1_L = -2008989440; !  TLMEM SELFTEST DATA ERR REG E1
literal IO0C05$L_SLOT1_TLDDR1_L = -2008989376; !  TLMEM DATA DIAG REG 1
literal IO0C05$L_SLOT1_TLSTDERA_2_L = -2008973312; !  TLMEM SELFTEST DATA ERR REG A2
literal IO0C05$L_SLOT1_TLSTDERB_2_L = -2008973248; !  TLMEM SELFTEST DATA ERR REG B2
literal IO0C05$L_SLOT1_TLSTDERC_2_L = -2008973184; !  TLMEM SELFTEST DATA ERR REG C2
literal IO0C05$L_SLOT1_TLSTDERD_2_L = -2008973120; !  TLMEM SELFTEST DATA ERR REG D2
literal IO0C05$L_SLOT1_TLSTDERE_2_L = -2008973056; !  TLMEM SELFTEST DATA ERR REG E2
literal IO0C05$L_SLOT1_TLDDR2_L = -2008972992; !  TLMEM DATA DIAG REG 2
literal IO0C05$L_SLOT1_TLSTDERA_3_L = -2008956928; !  TLMEM SELFTEST DATA ERR REG A3
literal IO0C05$L_SLOT1_TLSTDERB_3_L = -2008956864; !  TLMEM SELFTEST DATA ERR REG B3
literal IO0C05$L_SLOT1_TLSTDERC_3_L = -2008956800; !  TLMEM SELFTEST DATA ERR REG C3
literal IO0C05$L_SLOT1_TLSTDERD_3_L = -2008956736; !  TLMEM SELFTEST DATA ERR REG D3
literal IO0C05$L_SLOT1_TLSTDERE_3_L = -2008956672; !  TLMEM SELFTEST DATA ERR REG E3
literal IO0C05$L_SLOT1_TLDDR3_L = -2008956608; !  TLMEM DATA DIAG REG 3
literal IO0C05$L_SLOT2_TLDEV_L = -2004877312; !  DEVICE
literal IO0C05$L_SLOT2_TLBER_L = -2004877248; !  ERROR
literal IO0C05$L_SLOT2_TLCNR_L = -2004877184; !  CONFIGURATION
literal IO0C05$L_SLOT2_TLVID_L = -2004877120; !  VIRT ID
literal IO0C05$L_SLOT2_TLMMR0_L = -2004876800; !  MEM MAPPING 0
literal IO0C05$L_SLOT2_TLMMR1_L = -2004876736; !  MEM MAPPING 1
literal IO0C05$L_SLOT2_TLMMR2_L = -2004876672; !  MEM MAPPING 2
literal IO0C05$L_SLOT2_TLMMR3_L = -2004876608; !  MEM MAPPING 3
literal IO0C05$L_SLOT2_TLMMR4_L = -2004876544; !  MEM MAPPING 4
literal IO0C05$L_SLOT2_TLMMR5_L = -2004876480; !  MEM MAPPING 5
literal IO0C05$L_SLOT2_TLMMR6_L = -2004876416; !  MEM MAPPING 6
literal IO0C05$L_SLOT2_TLMMR7_L = -2004876352; !  MEM MAPPING 7
literal IO0C05$L_SLOT2_TLFADR0_L = -2004875776; !  FAILING ADDR 0
literal IO0C05$L_SLOT2_TLFADR1_L = -2004875712; !  FAILING ADDR 1
literal IO0C05$L_SLOT2_TLESR0_L = -2004875648; !  BUS ERROR SYNDROME 0
literal IO0C05$L_SLOT2_TLESR1_L = -2004875584; !  BUS ERROR SYNDROME 1
literal IO0C05$L_SLOT2_TLESR2_L = -2004875520; !  BUS ERROR SYNDROME 2
literal IO0C05$L_SLOT2_TLESR3_L = -2004875456; !  BUS ERROR SYNDROME 3
literal IO0C05$L_SLOT2_TLDIAG_L = -2004873216; !  TLEP DIAG SETUP
literal IO0C05$L_SLOT2_TLDTAGDATA_L = -2004873152; !  TLEP DTAG DATA
literal IO0C05$L_SLOT2_TLDTAGSTAT_L = -2004873088; !  TLEP DTAG STAT
literal IO0C05$L_SLOT2_TLMODCONFIG_L = -2004873024; !  TLEP MOD CONFIG
literal IO0C05$L_SLOT2_TLINTRMASK0_L = -2004872960; !  TLEP INT MASK 0
literal IO0C05$L_SLOT2_TLINTRMASK1_L = -2004872896; !  TLEP INT MASK 1
literal IO0C05$L_SLOT2_TLINTRSUM0_L = -2004872832; !  TLEP INT SUM 0
literal IO0C05$L_SLOT2_TLINTRSUM1_L = -2004872768; !  TLEP INT SUM 1
literal IO0C05$L_SLOT2_TLCON00_L = -2004872704; !  TLEP CONS COMM
literal IO0C05$L_SLOT2_TLCON00A_L = -2004872640; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT2_TLCON00B_L = -2004872576; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT2_TLCON00C_L = -2004872512; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT2_TLCON10_L = -2004872448; !  TLEP CONS COMM
literal IO0C05$L_SLOT2_TLCON10A_L = -2004872384; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT2_TLCON10B_L = -2004872320; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT2_TLCON10C_L = -2004872256; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT2_TLCON01_L = -2004872192; !  TLEP CONS COMM
literal IO0C05$L_SLOT2_TLCON11_L = -2004872128; !  TLEP CONS COMM
literal IO0C05$L_SLOT2_TLEPAERR_L = -2004871936; !  TLEP ADG ERROR
literal IO0C05$L_SLOT2_TLEPDERR_L = -2004871872; !  TLEP DIGA ERROR
literal IO0C05$L_SLOT2_TLEPMERR_L = -2004871808; !  TLEP MMG ERROR
literal IO0C05$L_SLOT2_TLEP_VMG_L = -2004871744; !  TLEP VOLT MARG
literal IO0C05$L_SLOT2_TLDMCMD_L = -2004871680; !  TLEP DM CMD 
literal IO0C05$L_SLOT2_TLDMADRA_L = -2004871552; !  TLEP DM A
literal IO0C05$L_SLOT2_TLDMADRB_L = -2004871488; !  TLEP DM B
literal IO0C05$L_SLOT2_TLPM_CMD_L = -2004871168; !  TLEP PERF MON CMD
literal IO0C05$L_SLOT2_TLSECR_L = -2004871168; !  TLMEM SECR EEPROM CNTL
literal IO0C05$L_SLOT2_TLPM_TOT_CYC_L = -2004871104; !  TLEP # OF CYCLES
literal IO0C05$L_SLOT2_TLMIR_L = -2004871104; !  TLMEM MEM INTERLEAVE
literal IO0C05$L_SLOT2_TLPM_EV5_LAT_L = -2004871040; !  TLEP EV5 RD LAT
literal IO0C05$L_SLOT2_TLMCR_L = -2004871040; !  TLMEM MEM CONFIG 
literal IO0C05$L_SLOT2_TLPM_READ_LAT_L = -2004870976; !  TLEP AV RD LAT
literal IO0C05$L_SLOT2_TLSTAIR_L = -2004870976; !  TLMEM SELFTEST ADR ISOL
literal IO0C05$L_SLOT2_TLPM_SYS_OWNER_L = -2004870912; !  TLEP # CYC OF SYS OWNER
literal IO0C05$L_SLOT2_TLSTER_L = -2004870912; !  TLMEM SELFTEST ERR REG
literal IO0C05$L_SLOT2_TLPM_CMD_SILO_L = -2004870848; !  TLEP CMD SILO
literal IO0C05$L_SLOT2_TLMER_L = -2004870848; !  TLMEM MEM ERROR REG
literal IO0C05$L_SLOT2_TLPM_LOCK_L = -2004870784; !  TLEP # LOCK ACKS
literal IO0C05$L_SLOT2_TLMDRA_L = -2004870784; !  TLMEM MEM DIAG REG A
literal IO0C05$L_SLOT2_TLPM_MB_L = -2004870720; !  TLEP # MB ACKS
literal IO0C05$L_SLOT2_TLMDRB_L = -2004870720; !  TLMEM MEM DIAG REG B
literal IO0C05$L_SLOT2_TLPM_SD_TOTAL_L = -2004870656; !  TLEP # SD
literal IO0C05$L_SLOT2_TLPM_SD_ACKED_L = -2004870592; !  TLEP # SD ACKS
literal IO0C05$L_SLOT2_TLPM_RD_CSR_L = -2004870528; !  TLEP # CSR RDS
literal IO0C05$L_SLOT2_TLPM_RD_L = -2004870464; !  TLEP # MEM RD MISS
literal IO0C05$L_SLOT2_TLPM_RD_MOD_L = -2004870400; !  TLEP # RD MISS MODS
literal IO0C05$L_SLOT2_TLPM_RD_STC_L = -2004870336; !  TLEP # RD MISS STXC
literal IO0C05$L_SLOT2_TLPM_VICTIM_L = -2004870272; !  TLEP # BC VICTIMS
literal IO0C05$L_SLOT2_TLPM_WR_CSR_L = -2004870208; !  TLEP # CSR WR CMDS
literal IO0C05$L_SLOT2_TLPM_WR_L = -2004870144; !  TLEP # WR BLK CMDS ACKED
literal IO0C05$L_SLOT2_TLPM_WR_LOCK_L = -2004870080; !  TLEP # WR BLK LK CMDS ACKED
literal IO0C05$L_SLOT2_TLPM_INVAL_L = -2004870016; !  TLEP # INVAL 
literal IO0C05$L_SLOT2_TLPM_SET_SHRD_L = -2004869952; !  TLEP # SET SHRDS
literal IO0C05$L_SLOT2_TLPM_RD_DIRTY_L = -2004869888; !  TLEP # RD DIRTYS
literal IO0C05$L_SLOT2_TLPM_ADR_SILO_L = -2004869824; !  TLEP ADR SILO REG
literal IO0C05$L_SLOT2_RM_RANG_REG0A_L = -2004869632; !  TLEP RM MR CHAN0A
literal IO0C05$L_SLOT2_RM_RANG_REG0B_L = -2004869568; !  TLEP RM MR CHAN0B
literal IO0C05$L_SLOT2_RM_RANG_REG1A_L = -2004869504; !  TLEP RM MR CHAN1A
literal IO0C05$L_SLOT2_RM_RANG_REG1B_L = -2004869440; !  TLEP RM MR CHAN1B
literal IO0C05$L_SLOT2_TLSTDERA_0_L = -2004811776; !  TLMEM SELFTEST DATA ERR REG A0
literal IO0C05$L_SLOT2_TLSTDERB_0_L = -2004811712; !  TLMEM SELFTEST DATA ERR REG B0
literal IO0C05$L_SLOT2_TLSTDERC_0_L = -2004811648; !  TLMEM SELFTEST DATA ERR REG C0
literal IO0C05$L_SLOT2_TLSTDERD_0_L = -2004811584; !  TLMEM SELFTEST DATA ERR REG D0
literal IO0C05$L_SLOT2_TLSTDERE_0_L = -2004811520; !  TLMEM SELFTEST DATA ERR REG E0
literal IO0C05$L_SLOT2_TLDDR0_L = -2004811456; !  TLMEM DATA DIAG REG 0
literal IO0C05$L_SLOT2_TLSTDERA_1_L = -2004795392; !  TLMEM SELFTEST DATA ERR REG A1
literal IO0C05$L_SLOT2_TLSTDERB_1_L = -2004795328; !  TLMEM SELFTEST DATA ERR REG B1
literal IO0C05$L_SLOT2_TLSTDERC_1_L = -2004795264; !  TLMEM SELFTEST DATA ERR REG C1
literal IO0C05$L_SLOT2_TLSTDERD_1_L = -2004795200; !  TLMEM SELFTEST DATA ERR REG D1
literal IO0C05$L_SLOT2_TLSTDERE_1_L = -2004795136; !  TLMEM SELFTEST DATA ERR REG E1
literal IO0C05$L_SLOT2_TLDDR1_L = -2004795072; !  TLMEM DATA DIAG REG 1
literal IO0C05$L_SLOT2_TLSTDERA_2_L = -2004779008; !  TLMEM SELFTEST DATA ERR REG A2
literal IO0C05$L_SLOT2_TLSTDERB_2_L = -2004778944; !  TLMEM SELFTEST DATA ERR REG B2
literal IO0C05$L_SLOT2_TLSTDERC_2_L = -2004778880; !  TLMEM SELFTEST DATA ERR REG C2
literal IO0C05$L_SLOT2_TLSTDERD_2_L = -2004778816; !  TLMEM SELFTEST DATA ERR REG D2
literal IO0C05$L_SLOT2_TLSTDERE_2_L = -2004778752; !  TLMEM SELFTEST DATA ERR REG E2
literal IO0C05$L_SLOT2_TLDDR2_L = -2004778688; !  TLMEM DATA DIAG REG 2
literal IO0C05$L_SLOT2_TLSTDERA_3_L = -2004762624; !  TLMEM SELFTEST DATA ERR REG A3
literal IO0C05$L_SLOT2_TLSTDERB_3_L = -2004762560; !  TLMEM SELFTEST DATA ERR REG B3
literal IO0C05$L_SLOT2_TLSTDERC_3_L = -2004762496; !  TLMEM SELFTEST DATA ERR REG C3
literal IO0C05$L_SLOT2_TLSTDERD_3_L = -2004762432; !  TLMEM SELFTEST DATA ERR REG D3
literal IO0C05$L_SLOT2_TLSTDERE_3_L = -2004762368; !  TLMEM SELFTEST DATA ERR REG E3
literal IO0C05$L_SLOT2_TLDDR3_L = -2004762304; !  TLMEM DATA DIAG REG 3
literal IO0C05$L_SLOT3_TLDEV_L = -2000683008; !  DEVICE
literal IO0C05$L_SLOT3_TLBER_L = -2000682944; !  ERROR
literal IO0C05$L_SLOT3_TLCNR_L = -2000682880; !  CONFIGURATION
literal IO0C05$L_SLOT3_TLVID_L = -2000682816; !  VIRT ID
literal IO0C05$L_SLOT3_TLMMR0_L = -2000682496; !  MEM MAPPING 0
literal IO0C05$L_SLOT3_TLMMR1_L = -2000682432; !  MEM MAPPING 1
literal IO0C05$L_SLOT3_TLMMR2_L = -2000682368; !  MEM MAPPING 2
literal IO0C05$L_SLOT3_TLMMR3_L = -2000682304; !  MEM MAPPING 3
literal IO0C05$L_SLOT3_TLMMR4_L = -2000682240; !  MEM MAPPING 4
literal IO0C05$L_SLOT3_TLMMR5_L = -2000682176; !  MEM MAPPING 5
literal IO0C05$L_SLOT3_TLMMR6_L = -2000682112; !  MEM MAPPING 6
literal IO0C05$L_SLOT3_TLMMR7_L = -2000682048; !  MEM MAPPING 7
literal IO0C05$L_SLOT3_TLFADR0_L = -2000681472; !  FAILING ADDR 0
literal IO0C05$L_SLOT3_TLFADR1_L = -2000681408; !  FAILING ADDR 1
literal IO0C05$L_SLOT3_TLESR0_L = -2000681344; !  BUS ERROR SYNDROME 0
literal IO0C05$L_SLOT3_TLESR1_L = -2000681280; !  BUS ERROR SYNDROME 1
literal IO0C05$L_SLOT3_TLESR2_L = -2000681216; !  BUS ERROR SYNDROME 2
literal IO0C05$L_SLOT3_TLESR3_L = -2000681152; !  BUS ERROR SYNDROME 3
literal IO0C05$L_SLOT3_TLDIAG_L = -2000678912; !  TLEP DIAG SETUP
literal IO0C05$L_SLOT3_TLDTAGDATA_L = -2000678848; !  TLEP DTAG DATA
literal IO0C05$L_SLOT3_TLDTAGSTAT_L = -2000678784; !  TLEP DTAG STAT
literal IO0C05$L_SLOT3_TLMODCONFIG_L = -2000678720; !  TLEP MOD CONFIG
literal IO0C05$L_SLOT3_TLINTRMASK0_L = -2000678656; !  TLEP INT MASK 0
literal IO0C05$L_SLOT3_TLINTRMASK1_L = -2000678592; !  TLEP INT MASK 1
literal IO0C05$L_SLOT3_TLINTRSUM0_L = -2000678528; !  TLEP INT SUM 0
literal IO0C05$L_SLOT3_TLINTRSUM1_L = -2000678464; !  TLEP INT SUM 1
literal IO0C05$L_SLOT3_TLCON00_L = -2000678400; !  TLEP CONS COMM
literal IO0C05$L_SLOT3_TLCON00A_L = -2000678336; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT3_TLCON00B_L = -2000678272; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT3_TLCON00C_L = -2000678208; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT3_TLCON10_L = -2000678144; !  TLEP CONS COMM
literal IO0C05$L_SLOT3_TLCON10A_L = -2000678080; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT3_TLCON10B_L = -2000678016; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT3_TLCON10C_L = -2000677952; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT3_TLCON01_L = -2000677888; !  TLEP CONS COMM
literal IO0C05$L_SLOT3_TLCON11_L = -2000677824; !  TLEP CONS COMM
literal IO0C05$L_SLOT3_TLEPAERR_L = -2000677632; !  TLEP ADG ERROR
literal IO0C05$L_SLOT3_TLEPDERR_L = -2000677568; !  TLEP DIGA ERROR
literal IO0C05$L_SLOT3_TLEPMERR_L = -2000677504; !  TLEP MMG ERROR
literal IO0C05$L_SLOT3_TLEP_VMG_L = -2000677440; !  TLEP VOLT MARG
literal IO0C05$L_SLOT3_TLDMCMD_L = -2000677376; !  TLEP DM CMD 
literal IO0C05$L_SLOT3_TLDMADRA_L = -2000677248; !  TLEP DM A
literal IO0C05$L_SLOT3_TLDMADRB_L = -2000677184; !  TLEP DM B
literal IO0C05$L_SLOT3_TLPM_CMD_L = -2000676864; !  TLEP PERF MON CMD
literal IO0C05$L_SLOT3_TLSECR_L = -2000676864; !  TLMEM SECR EEPROM CNTL
literal IO0C05$L_SLOT3_TLPM_TOT_CYC_L = -2000676800; !  TLEP # OF CYCLES
literal IO0C05$L_SLOT3_TLMIR_L = -2000676800; !  TLMEM MEM INTERLEAVE
literal IO0C05$L_SLOT3_TLPM_EV5_LAT_L = -2000676736; !  TLEP EV5 RD LAT
literal IO0C05$L_SLOT3_TLMCR_L = -2000676736; !  TLMEM MEM CONFIG 
literal IO0C05$L_SLOT3_TLPM_READ_LAT_L = -2000676672; !  TLEP AV RD LAT
literal IO0C05$L_SLOT3_TLSTAIR_L = -2000676672; !  TLMEM SELFTEST ADR ISOL
literal IO0C05$L_SLOT3_TLPM_SYS_OWNER_L = -2000676608; !  TLEP # CYC OF SYS OWNER
literal IO0C05$L_SLOT3_TLSTER_L = -2000676608; !  TLMEM SELFTEST ERR REG
literal IO0C05$L_SLOT3_TLPM_CMD_SILO_L = -2000676544; !  TLEP CMD SILO
literal IO0C05$L_SLOT3_TLMER_L = -2000676544; !  TLMEM MEM ERROR REG
literal IO0C05$L_SLOT3_TLPM_LOCK_L = -2000676480; !  TLEP # LOCK ACKS
literal IO0C05$L_SLOT3_TLMDRA_L = -2000676480; !  TLMEM MEM DIAG REG A
literal IO0C05$L_SLOT3_TLPM_MB_L = -2000676416; !  TLEP # MB ACKS
literal IO0C05$L_SLOT3_TLMDRB_L = -2000676416; !  TLMEM MEM DIAG REG B
literal IO0C05$L_SLOT3_TLPM_SD_TOTAL_L = -2000676352; !  TLEP # SD
literal IO0C05$L_SLOT3_TLPM_SD_ACKED_L = -2000676288; !  TLEP # SD ACKS
literal IO0C05$L_SLOT3_TLPM_RD_CSR_L = -2000676224; !  TLEP # CSR RDS
literal IO0C05$L_SLOT3_TLPM_RD_L = -2000676160; !  TLEP # MEM RD MISS
literal IO0C05$L_SLOT3_TLPM_RD_MOD_L = -2000676096; !  TLEP # RD MISS MODS
literal IO0C05$L_SLOT3_TLPM_RD_STC_L = -2000676032; !  TLEP # RD MISS STXC
literal IO0C05$L_SLOT3_TLPM_VICTIM_L = -2000675968; !  TLEP # BC VICTIMS
literal IO0C05$L_SLOT3_TLPM_WR_CSR_L = -2000675904; !  TLEP # CSR WR CMDS
literal IO0C05$L_SLOT3_TLPM_WR_L = -2000675840; !  TLEP # WR BLK CMDS ACKED
literal IO0C05$L_SLOT3_TLPM_WR_LOCK_L = -2000675776; !  TLEP # WR BLK LK CMDS ACKED
literal IO0C05$L_SLOT3_TLPM_INVAL_L = -2000675712; !  TLEP # INVAL 
literal IO0C05$L_SLOT3_TLPM_SET_SHRD_L = -2000675648; !  TLEP # SET SHRDS
literal IO0C05$L_SLOT3_TLPM_RD_DIRTY_L = -2000675584; !  TLEP # RD DIRTYS
literal IO0C05$L_SLOT3_TLPM_ADR_SILO_L = -2000675520; !  TLEP ADR SILO REG
literal IO0C05$L_SLOT3_RM_RANG_REG0A_L = -2000675328; !  TLEP RM MR CHAN0A
literal IO0C05$L_SLOT3_RM_RANG_REG0B_L = -2000675264; !  TLEP RM MR CHAN0B
literal IO0C05$L_SLOT3_RM_RANG_REG1A_L = -2000675200; !  TLEP RM MR CHAN1A
literal IO0C05$L_SLOT3_RM_RANG_REG1B_L = -2000675136; !  TLEP RM MR CHAN1B
literal IO0C05$L_SLOT3_TLSTDERA_0_L = -2000617472; !  TLMEM SELFTEST DATA ERR REG A0
literal IO0C05$L_SLOT3_TLSTDERB_0_L = -2000617408; !  TLMEM SELFTEST DATA ERR REG B0
literal IO0C05$L_SLOT3_TLSTDERC_0_L = -2000617344; !  TLMEM SELFTEST DATA ERR REG C0
literal IO0C05$L_SLOT3_TLSTDERD_0_L = -2000617280; !  TLMEM SELFTEST DATA ERR REG D0
literal IO0C05$L_SLOT3_TLSTDERE_0_L = -2000617216; !  TLMEM SELFTEST DATA ERR REG E0
literal IO0C05$L_SLOT3_TLDDR0_L = -2000617152; !  TLMEM DATA DIAG REG 0
literal IO0C05$L_SLOT3_TLSTDERA_1_L = -2000601088; !  TLMEM SELFTEST DATA ERR REG A1
literal IO0C05$L_SLOT3_TLSTDERB_1_L = -2000601024; !  TLMEM SELFTEST DATA ERR REG B1
literal IO0C05$L_SLOT3_TLSTDERC_1_L = -2000600960; !  TLMEM SELFTEST DATA ERR REG C1
literal IO0C05$L_SLOT3_TLSTDERD_1_L = -2000600896; !  TLMEM SELFTEST DATA ERR REG D1
literal IO0C05$L_SLOT3_TLSTDERE_1_L = -2000600832; !  TLMEM SELFTEST DATA ERR REG E1
literal IO0C05$L_SLOT3_TLDDR1_L = -2000600768; !  TLMEM DATA DIAG REG 1
literal IO0C05$L_SLOT3_TLSTDERA_2_L = -2000584704; !  TLMEM SELFTEST DATA ERR REG A2
literal IO0C05$L_SLOT3_TLSTDERB_2_L = -2000584640; !  TLMEM SELFTEST DATA ERR REG B2
literal IO0C05$L_SLOT3_TLSTDERC_2_L = -2000584576; !  TLMEM SELFTEST DATA ERR REG C2
literal IO0C05$L_SLOT3_TLSTDERD_2_L = -2000584512; !  TLMEM SELFTEST DATA ERR REG D2
literal IO0C05$L_SLOT3_TLSTDERE_2_L = -2000584448; !  TLMEM SELFTEST DATA ERR REG E2
literal IO0C05$L_SLOT3_TLDDR2_L = -2000584384; !  TLMEM DATA DIAG REG 2
literal IO0C05$L_SLOT3_TLSTDERA_3_L = -2000568320; !  TLMEM SELFTEST DATA ERR REG A3
literal IO0C05$L_SLOT3_TLSTDERB_3_L = -2000568256; !  TLMEM SELFTEST DATA ERR REG B3
literal IO0C05$L_SLOT3_TLSTDERC_3_L = -2000568192; !  TLMEM SELFTEST DATA ERR REG C3
literal IO0C05$L_SLOT3_TLSTDERD_3_L = -2000568128; !  TLMEM SELFTEST DATA ERR REG D3
literal IO0C05$L_SLOT3_TLSTDERE_3_L = -2000568064; !  TLMEM SELFTEST DATA ERR REG E3
literal IO0C05$L_SLOT3_TLDDR3_L = -2000568000; !  TLMEM DATA DIAG REG 3
literal IO0C05$L_SLOT4_TLDEV_L = -1996488704; !  DEVICE
literal IO0C05$L_SLOT4_TLBER_L = -1996488640; !  ERROR
literal IO0C05$L_SLOT4_TLCNR_L = -1996488576; !  CONFIGURATION
literal IO0C05$L_SLOT4_TLVID_L = -1996488512; !  VIRT ID
literal IO0C05$L_SLOT4_TLMMR0_L = -1996488192; !  MEM MAPPING 0
literal IO0C05$L_SLOT4_TLMMR1_L = -1996488128; !  MEM MAPPING 1
literal IO0C05$L_SLOT4_TLMMR2_L = -1996488064; !  MEM MAPPING 2
literal IO0C05$L_SLOT4_TLMMR3_L = -1996488000; !  MEM MAPPING 3
literal IO0C05$L_SLOT4_TLMMR4_L = -1996487936; !  MEM MAPPING 4
literal IO0C05$L_SLOT4_TLMMR5_L = -1996487872; !  MEM MAPPING 5
literal IO0C05$L_SLOT4_TLMMR6_L = -1996487808; !  MEM MAPPING 6
literal IO0C05$L_SLOT4_TLMMR7_L = -1996487744; !  MEM MAPPING 7
literal IO0C05$L_SLOT4_TLFADR0_L = -1996487168; !  FAILING ADDR 0
literal IO0C05$L_SLOT4_TLFADR1_L = -1996487104; !  FAILING ADDR 1
literal IO0C05$L_SLOT4_TLESR0_L = -1996487040; !  BUS ERROR SYNDROME 0
literal IO0C05$L_SLOT4_TLESR1_L = -1996486976; !  BUS ERROR SYNDROME 1
literal IO0C05$L_SLOT4_TLESR2_L = -1996486912; !  BUS ERROR SYNDROME 2
literal IO0C05$L_SLOT4_TLESR3_L = -1996486848; !  BUS ERROR SYNDROME 3
literal IO0C05$L_SLOT4_TLILID0_L = -1996486144; !  TIOP INT LVL 0
literal IO0C05$L_SLOT4_TLILID1_L = -1996486080; !  TIOP INT LVL 1
literal IO0C05$L_SLOT4_TLILID2_L = -1996486016; !  TIOP INT LVL 2
literal IO0C05$L_SLOT4_TLILID3_L = -1996485952; !  TIOP INT LVL 3
literal IO0C05$L_SLOT4_TLCPUMASK_L = -1996485888; !  TIOP CPU INT MASK
literal IO0C05$L_SLOT4_TLMBPR_L = -1996485632; !  TIOP MBX PNTR REG
literal IO0C05$L_SLOT4_TLDIAG_L = -1996484608; !  TLEP DIAG SETUP
literal IO0C05$L_SLOT4_TLDTAGDATA_L = -1996484544; !  TLEP DTAG DATA
literal IO0C05$L_SLOT4_TLDTAGSTAT_L = -1996484480; !  TLEP DTAG STAT
literal IO0C05$L_SLOT4_TLMODCONFIG_L = -1996484416; !  TLEP MOD CONFIG
literal IO0C05$L_SLOT4_TLINTRMASK0_L = -1996484352; !  TLEP INT MASK 0
literal IO0C05$L_SLOT4_TLINTRMASK1_L = -1996484288; !  TLEP INT MASK 1
literal IO0C05$L_SLOT4_TLINTRSUM0_L = -1996484224; !  TLEP INT SUM 0
literal IO0C05$L_SLOT4_TLINTRSUM1_L = -1996484160; !  TLEP INT SUM 1
literal IO0C05$L_SLOT4_TLCON00_L = -1996484096; !  TLEP CONS COMM
literal IO0C05$L_SLOT4_TLCON00A_L = -1996484032; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT4_TLCON00B_L = -1996483968; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT4_TLCON00C_L = -1996483904; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT4_TLCON10_L = -1996483840; !  TLEP CONS COMM
literal IO0C05$L_SLOT4_TLCON10A_L = -1996483776; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT4_TLCON10B_L = -1996483712; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT4_TLCON10C_L = -1996483648; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT4_TLCON01_L = -1996483584; !  TLEP CONS COMM
literal IO0C05$L_SLOT4_TLCON11_L = -1996483520; !  TLEP CONS COMM
literal IO0C05$L_SLOT4_TLEPAERR_L = -1996483328; !  TLEP ADG ERROR
literal IO0C05$L_SLOT4_TLEPDERR_L = -1996483264; !  TLEP DIGA ERROR
literal IO0C05$L_SLOT4_TLEPMERR_L = -1996483200; !  TLEP MMG ERROR
literal IO0C05$L_SLOT4_TLEP_VMG_L = -1996483136; !  TLEP VOLT MARG
literal IO0C05$L_SLOT4_TLDMCMD_L = -1996483072; !  TLEP DM CMD 
literal IO0C05$L_SLOT4_TLDMADRA_L = -1996482944; !  TLEP DM A
literal IO0C05$L_SLOT4_TLDMADRB_L = -1996482880; !  TLEP DM B
literal IO0C05$L_SLOT4_TLPM_CMD_L = -1996482560; !  TLEP PERF MON CMD
literal IO0C05$L_SLOT4_TLSECR_L = -1996482560; !  TLMEM SECR EEPROM CNTL
literal IO0C05$L_SLOT4_TLPM_TOT_CYC_L = -1996482496; !  TLEP # OF CYCLES
literal IO0C05$L_SLOT4_TLMIR_L = -1996482496; !  TLMEM MEM INTERLEAVE
literal IO0C05$L_SLOT4_TLPM_EV5_LAT_L = -1996482432; !  TLEP EV5 RD LAT
literal IO0C05$L_SLOT4_TLMCR_L = -1996482432; !  TLMEM MEM CONFIG 
literal IO0C05$L_SLOT4_TLPM_READ_LAT_L = -1996482368; !  TLEP AV RD LAT
literal IO0C05$L_SLOT4_TLSTAIR_L = -1996482368; !  TLMEM SELFTEST ADR ISOL
literal IO0C05$L_SLOT4_TLPM_SYS_OWNER_L = -1996482304; !  TLEP # CYC OF SYS OWNER
literal IO0C05$L_SLOT4_TLSTER_L = -1996482304; !  TLMEM SELFTEST ERR REG
literal IO0C05$L_SLOT4_TLPM_CMD_SILO_L = -1996482240; !  TLEP CMD SILO
literal IO0C05$L_SLOT4_TLMER_L = -1996482240; !  TLMEM MEM ERROR REG
literal IO0C05$L_SLOT4_TLPM_LOCK_L = -1996482176; !  TLEP # LOCK ACKS
literal IO0C05$L_SLOT4_TLMDRA_L = -1996482176; !  TLMEM MEM DIAG REG A
literal IO0C05$L_SLOT4_TLPM_MB_L = -1996482112; !  TLEP # MB ACKS
literal IO0C05$L_SLOT4_TLMDRB_L = -1996482112; !  TLMEM MEM DIAG REG B
literal IO0C05$L_SLOT4_TLPM_SD_TOTAL_L = -1996482048; !  TLEP # SD
literal IO0C05$L_SLOT4_TLPM_SD_ACKED_L = -1996481984; !  TLEP # SD ACKS
literal IO0C05$L_SLOT4_TLPM_RD_CSR_L = -1996481920; !  TLEP # CSR RDS
literal IO0C05$L_SLOT4_TLPM_RD_L = -1996481856; !  TLEP # MEM RD MISS
literal IO0C05$L_SLOT4_TLPM_RD_MOD_L = -1996481792; !  TLEP # RD MISS MODS
literal IO0C05$L_SLOT4_TLPM_RD_STC_L = -1996481728; !  TLEP # RD MISS STXC
literal IO0C05$L_SLOT4_TLPM_VICTIM_L = -1996481664; !  TLEP # BC VICTIMS
literal IO0C05$L_SLOT4_TLPM_WR_CSR_L = -1996481600; !  TLEP # CSR WR CMDS
literal IO0C05$L_SLOT4_TLPM_WR_L = -1996481536; !  TLEP # WR BLK CMDS ACKED
literal IO0C05$L_SLOT4_TLPM_WR_LOCK_L = -1996481472; !  TLEP # WR BLK LK CMDS ACKED
literal IO0C05$L_SLOT4_TLPM_INVAL_L = -1996481408; !  TLEP # INVAL 
literal IO0C05$L_SLOT4_TLPM_SET_SHRD_L = -1996481344; !  TLEP # SET SHRDS
literal IO0C05$L_SLOT4_TLPM_RD_DIRTY_L = -1996481280; !  TLEP # RD DIRTYS
literal IO0C05$L_SLOT4_TLPM_ADR_SILO_L = -1996481216; !  TLEP ADR SILO REG
literal IO0C05$L_SLOT4_RM_RANG_REG0A_L = -1996481024; !  TLEP RM MR CHAN0A
literal IO0C05$L_SLOT4_RM_RANG_REG0B_L = -1996480960; !  TLEP RM MR CHAN0B
literal IO0C05$L_SLOT4_RM_RANG_REG1A_L = -1996480896; !  TLEP RM MR CHAN1A
literal IO0C05$L_SLOT4_RM_RANG_REG1B_L = -1996480832; !  TLEP RM MR CHAN1B
literal IO0C05$L_SLOT4_TLICCMSR_L = -1996480512; !  TIOP I/O CNTRL CHIP MODE SEL
literal IO0C05$L_SLOT4_TLICCNSE_L = -1996480448; !  TIOP I/O CNTRL CHIP NODE SPEC ERR
literal IO0C05$L_SLOT4_TLICCDR_L = -1996480384; !  TIOP I/O CNTRL CHIP DIAG REG
literal IO0C05$L_SLOT4_TLICCMTR_L = -1996480320; !  TIOP I/O CNTRL CHIP MBX TRANS REG
literal IO0C05$L_SLOT4_TLICCWRT_L = -1996480256; !  TIOP I/O CNTRL CHIP CSR WIND TRANS
literal IO0C05$L_SLOT4_TLIDPNSE1_L = -1996480192; !  TIOP NODE SPEC DPATH ERROR 1
literal IO0C05$L_SLOT4_TLIDPDR1_L = -1996480128; !  TIOP I/O DPATH DIAG REG 1
literal IO0C05$L_SLOT4_TLIDPNSE2_L = -1996479936; !  TIOP NODE SPEC DPATH ERROR 2
literal IO0C05$L_SLOT4_TLIDPDR2_L = -1996479872; !  TIOP I/O DPATH DIAG REG 2
literal IO0C05$L_SLOT4_TLIDPNSE3_L = -1996479680; !  TIOP NODE SPEC DPATH ERROR 3
literal IO0C05$L_SLOT4_TLIDPDR3_L = -1996479616; !  TIOP I/O DPATH DIAG REG 3
literal IO0C05$L_SLOT4_TLIDPNSE0_L = -1996477888; !  TIOP NODE SPEC DPATH ERROR 0
literal IO0C05$L_SLOT4_TLIDPDR0_L = -1996477824; !  TIOP I/O DPATH DIAG REG 0
literal IO0C05$L_SLOT4_TLIPCPUMASK_L = -1996477760; !  TIOP IP CPU INTR MASK
literal IO0C05$L_SLOT4_TLIDPVR_L = -1996477632; !  TIOP I/O DPATH VECT
literal IO0C05$L_SLOT4_TLIDPMSR_L = -1996477568; !  TIOP I/O DPATH MODE SEL
literal IO0C05$L_SLOT4_TLIBR_L = -1996477504; !  TIOP INFO BASE REPAIR
literal IO0C05$L_SLOT4_TLSTDERA_0_L = -1996423168; !  TLMEM SELFTEST DATA ERR REG A0
literal IO0C05$L_SLOT4_TLSTDERB_0_L = -1996423104; !  TLMEM SELFTEST DATA ERR REG B0
literal IO0C05$L_SLOT4_TLSTDERC_0_L = -1996423040; !  TLMEM SELFTEST DATA ERR REG C0
literal IO0C05$L_SLOT4_TLSTDERD_0_L = -1996422976; !  TLMEM SELFTEST DATA ERR REG D0
literal IO0C05$L_SLOT4_TLSTDERE_0_L = -1996422912; !  TLMEM SELFTEST DATA ERR REG E0
literal IO0C05$L_SLOT4_TLDDR0_L = -1996422848; !  TLMEM DATA DIAG REG 0
literal IO0C05$L_SLOT4_TLSTDERA_1_L = -1996406784; !  TLMEM SELFTEST DATA ERR REG A1
literal IO0C05$L_SLOT4_TLSTDERB_1_L = -1996406720; !  TLMEM SELFTEST DATA ERR REG B1
literal IO0C05$L_SLOT4_TLSTDERC_1_L = -1996406656; !  TLMEM SELFTEST DATA ERR REG C1
literal IO0C05$L_SLOT4_TLSTDERD_1_L = -1996406592; !  TLMEM SELFTEST DATA ERR REG D1
literal IO0C05$L_SLOT4_TLSTDERE_1_L = -1996406528; !  TLMEM SELFTEST DATA ERR REG E1
literal IO0C05$L_SLOT4_TLDDR1_L = -1996406464; !  TLMEM DATA DIAG REG 1
literal IO0C05$L_SLOT4_TLSTDERA_2_L = -1996390400; !  TLMEM SELFTEST DATA ERR REG A2
literal IO0C05$L_SLOT4_TLSTDERB_2_L = -1996390336; !  TLMEM SELFTEST DATA ERR REG B2
literal IO0C05$L_SLOT4_TLSTDERC_2_L = -1996390272; !  TLMEM SELFTEST DATA ERR REG C2
literal IO0C05$L_SLOT4_TLSTDERD_2_L = -1996390208; !  TLMEM SELFTEST DATA ERR REG D2
literal IO0C05$L_SLOT4_TLSTDERE_2_L = -1996390144; !  TLMEM SELFTEST DATA ERR REG E2
literal IO0C05$L_SLOT4_TLDDR2_L = -1996390080; !  TLMEM DATA DIAG REG 2
literal IO0C05$L_SLOT4_TLSTDERA_3_L = -1996374016; !  TLMEM SELFTEST DATA ERR REG A3
literal IO0C05$L_SLOT4_TLSTDERB_3_L = -1996373952; !  TLMEM SELFTEST DATA ERR REG B3
literal IO0C05$L_SLOT4_TLSTDERC_3_L = -1996373888; !  TLMEM SELFTEST DATA ERR REG C3
literal IO0C05$L_SLOT4_TLSTDERD_3_L = -1996373824; !  TLMEM SELFTEST DATA ERR REG D3
literal IO0C05$L_SLOT4_TLSTDERE_3_L = -1996373760; !  TLMEM SELFTEST DATA ERR REG E3
literal IO0C05$L_SLOT4_TLDDR3_L = -1996373696; !  TLMEM DATA DIAG REG 3
literal IO0C05$L_SLOT5_TLDEV_L = -1992294400; !  DEVICE
literal IO0C05$L_SLOT5_TLBER_L = -1992294336; !  ERROR
literal IO0C05$L_SLOT5_TLCNR_L = -1992294272; !  CONFIGURATION
literal IO0C05$L_SLOT5_TLVID_L = -1992294208; !  VIRT ID
literal IO0C05$L_SLOT5_TLMMR0_L = -1992293888; !  MEM MAPPING 0
literal IO0C05$L_SLOT5_TLMMR1_L = -1992293824; !  MEM MAPPING 1
literal IO0C05$L_SLOT5_TLMMR2_L = -1992293760; !  MEM MAPPING 2
literal IO0C05$L_SLOT5_TLMMR3_L = -1992293696; !  MEM MAPPING 3
literal IO0C05$L_SLOT5_TLMMR4_L = -1992293632; !  MEM MAPPING 4
literal IO0C05$L_SLOT5_TLMMR5_L = -1992293568; !  MEM MAPPING 5
literal IO0C05$L_SLOT5_TLMMR6_L = -1992293504; !  MEM MAPPING 6
literal IO0C05$L_SLOT5_TLMMR7_L = -1992293440; !  MEM MAPPING 7
literal IO0C05$L_SLOT5_TLFADR0_L = -1992292864; !  FAILING ADDR 0
literal IO0C05$L_SLOT5_TLFADR1_L = -1992292800; !  FAILING ADDR 1
literal IO0C05$L_SLOT5_TLESR0_L = -1992292736; !  BUS ERROR SYNDROME 0
literal IO0C05$L_SLOT5_TLESR1_L = -1992292672; !  BUS ERROR SYNDROME 1
literal IO0C05$L_SLOT5_TLESR2_L = -1992292608; !  BUS ERROR SYNDROME 2
literal IO0C05$L_SLOT5_TLESR3_L = -1992292544; !  BUS ERROR SYNDROME 3
literal IO0C05$L_SLOT5_TLILID0_L = -1992291840; !  TIOP INT LVL 0
literal IO0C05$L_SLOT5_TLILID1_L = -1992291776; !  TIOP INT LVL 1
literal IO0C05$L_SLOT5_TLILID2_L = -1992291712; !  TIOP INT LVL 2
literal IO0C05$L_SLOT5_TLILID3_L = -1992291648; !  TIOP INT LVL 3
literal IO0C05$L_SLOT5_TLCPUMASK_L = -1992291584; !  TIOP CPU INT MASK
literal IO0C05$L_SLOT5_TLMBPR_L = -1992291328; !  TIOP MBX PNTR REG
literal IO0C05$L_SLOT5_TLDIAG_L = -1992290304; !  TLEP DIAG SETUP
literal IO0C05$L_SLOT5_TLDTAGDATA_L = -1992290240; !  TLEP DTAG DATA
literal IO0C05$L_SLOT5_TLDTAGSTAT_L = -1992290176; !  TLEP DTAG STAT
literal IO0C05$L_SLOT5_TLMODCONFIG_L = -1992290112; !  TLEP MOD CONFIG
literal IO0C05$L_SLOT5_TLINTRMASK0_L = -1992290048; !  TLEP INT MASK 0
literal IO0C05$L_SLOT5_TLINTRMASK1_L = -1992289984; !  TLEP INT MASK 1
literal IO0C05$L_SLOT5_TLINTRSUM0_L = -1992289920; !  TLEP INT SUM 0
literal IO0C05$L_SLOT5_TLINTRSUM1_L = -1992289856; !  TLEP INT SUM 1
literal IO0C05$L_SLOT5_TLCON00_L = -1992289792; !  TLEP CONS COMM
literal IO0C05$L_SLOT5_TLCON00A_L = -1992289728; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT5_TLCON00B_L = -1992289664; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT5_TLCON00C_L = -1992289600; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT5_TLCON10_L = -1992289536; !  TLEP CONS COMM
literal IO0C05$L_SLOT5_TLCON10A_L = -1992289472; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT5_TLCON10B_L = -1992289408; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT5_TLCON10C_L = -1992289344; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT5_TLCON01_L = -1992289280; !  TLEP CONS COMM
literal IO0C05$L_SLOT5_TLCON11_L = -1992289216; !  TLEP CONS COMM
literal IO0C05$L_SLOT5_TLEPAERR_L = -1992289024; !  TLEP ADG ERROR
literal IO0C05$L_SLOT5_TLEPDERR_L = -1992288960; !  TLEP DIGA ERROR
literal IO0C05$L_SLOT5_TLEPMERR_L = -1992288896; !  TLEP MMG ERROR
literal IO0C05$L_SLOT5_TLEP_VMG_L = -1992288832; !  TLEP VOLT MARG
literal IO0C05$L_SLOT5_TLDMCMD_L = -1992288768; !  TLEP DM CMD 
literal IO0C05$L_SLOT5_TLDMADRA_L = -1992288640; !  TLEP DM A
literal IO0C05$L_SLOT5_TLDMADRB_L = -1992288576; !  TLEP DM B
literal IO0C05$L_SLOT5_TLPM_CMD_L = -1992288256; !  TLEP PERF MON CMD
literal IO0C05$L_SLOT5_TLSECR_L = -1992288256; !  TLMEM SECR EEPROM CNTL
literal IO0C05$L_SLOT5_TLPM_TOT_CYC_L = -1992288192; !  TLEP # OF CYCLES
literal IO0C05$L_SLOT5_TLMIR_L = -1992288192; !  TLMEM MEM INTERLEAVE
literal IO0C05$L_SLOT5_TLPM_EV5_LAT_L = -1992288128; !  TLEP EV5 RD LAT
literal IO0C05$L_SLOT5_TLMCR_L = -1992288128; !  TLMEM MEM CONFIG 
literal IO0C05$L_SLOT5_TLPM_READ_LAT_L = -1992288064; !  TLEP AV RD LAT
literal IO0C05$L_SLOT5_TLSTAIR_L = -1992288064; !  TLMEM SELFTEST ADR ISOL
literal IO0C05$L_SLOT5_TLPM_SYS_OWNER_L = -1992288000; !  TLEP # CYC OF SYS OWNER
literal IO0C05$L_SLOT5_TLSTER_L = -1992288000; !  TLMEM SELFTEST ERR REG
literal IO0C05$L_SLOT5_TLPM_CMD_SILO_L = -1992287936; !  TLEP CMD SILO
literal IO0C05$L_SLOT5_TLMER_L = -1992287936; !  TLMEM MEM ERROR REG
literal IO0C05$L_SLOT5_TLPM_LOCK_L = -1992287872; !  TLEP # LOCK ACKS
literal IO0C05$L_SLOT5_TLMDRA_L = -1992287872; !  TLMEM MEM DIAG REG A
literal IO0C05$L_SLOT5_TLPM_MB_L = -1992287808; !  TLEP # MB ACKS
literal IO0C05$L_SLOT5_TLMDRB_L = -1992287808; !  TLMEM MEM DIAG REG B
literal IO0C05$L_SLOT5_TLPM_SD_TOTAL_L = -1992287744; !  TLEP # SD
literal IO0C05$L_SLOT5_TLPM_SD_ACKED_L = -1992287680; !  TLEP # SD ACKS
literal IO0C05$L_SLOT5_TLPM_RD_CSR_L = -1992287616; !  TLEP # CSR RDS
literal IO0C05$L_SLOT5_TLPM_RD_L = -1992287552; !  TLEP # MEM RD MISS
literal IO0C05$L_SLOT5_TLPM_RD_MOD_L = -1992287488; !  TLEP # RD MISS MODS
literal IO0C05$L_SLOT5_TLPM_RD_STC_L = -1992287424; !  TLEP # RD MISS STXC
literal IO0C05$L_SLOT5_TLPM_VICTIM_L = -1992287360; !  TLEP # BC VICTIMS
literal IO0C05$L_SLOT5_TLPM_WR_CSR_L = -1992287296; !  TLEP # CSR WR CMDS
literal IO0C05$L_SLOT5_TLPM_WR_L = -1992287232; !  TLEP # WR BLK CMDS ACKED
literal IO0C05$L_SLOT5_TLPM_WR_LOCK_L = -1992287168; !  TLEP # WR BLK LK CMDS ACKED
literal IO0C05$L_SLOT5_TLPM_INVAL_L = -1992287104; !  TLEP # INVAL 
literal IO0C05$L_SLOT5_TLPM_SET_SHRD_L = -1992287040; !  TLEP # SET SHRDS
literal IO0C05$L_SLOT5_TLPM_RD_DIRTY_L = -1992286976; !  TLEP # RD DIRTYS
literal IO0C05$L_SLOT5_TLPM_ADR_SILO_L = -1992286912; !  TLEP ADR SILO REG
literal IO0C05$L_SLOT5_RM_RANG_REG0A_L = -1992286720; !  TLEP RM MR CHAN0A
literal IO0C05$L_SLOT5_RM_RANG_REG0B_L = -1992286656; !  TLEP RM MR CHAN0B
literal IO0C05$L_SLOT5_RM_RANG_REG1A_L = -1992286592; !  TLEP RM MR CHAN1A
literal IO0C05$L_SLOT5_RM_RANG_REG1B_L = -1992286528; !  TLEP RM MR CHAN1B
literal IO0C05$L_SLOT5_TLICCMSR_L = -1992286208; !  TIOP I/O CNTRL CHIP MODE SEL
literal IO0C05$L_SLOT5_TLICCNSE_L = -1992286144; !  TIOP I/O CNTRL CHIP NODE SPEC ERR
literal IO0C05$L_SLOT5_TLICCDR_L = -1992286080; !  TIOP I/O CNTRL CHIP DIAG REG
literal IO0C05$L_SLOT5_TLICCMTR_L = -1992286016; !  TIOP I/O CNTRL CHIP MBX TRANS REG
literal IO0C05$L_SLOT5_TLICCWRT_L = -1992285952; !  TIOP I/O CNTRL CHIP CSR WIND TRANS
literal IO0C05$L_SLOT5_TLIDPNSE1_L = -1992285888; !  TIOP NODE SPEC DPATH ERROR 1
literal IO0C05$L_SLOT5_TLIDPDR1_L = -1992285824; !  TIOP I/O DPATH DIAG REG 1
literal IO0C05$L_SLOT5_TLIDPNSE2_L = -1992285632; !  TIOP NODE SPEC DPATH ERROR 2
literal IO0C05$L_SLOT5_TLIDPDR2_L = -1992285568; !  TIOP I/O DPATH DIAG REG 2
literal IO0C05$L_SLOT5_TLIDPNSE3_L = -1992285376; !  TIOP NODE SPEC DPATH ERROR 3
literal IO0C05$L_SLOT5_TLIDPDR3_L = -1992285312; !  TIOP I/O DPATH DIAG REG 3
literal IO0C05$L_SLOT5_TLIDPNSE0_L = -1992283584; !  TIOP NODE SPEC DPATH ERROR 0
literal IO0C05$L_SLOT5_TLIDPDR0_L = -1992283520; !  TIOP I/O DPATH DIAG REG 0
literal IO0C05$L_SLOT5_TLIPCPUMASK_L = -1992283456; !  TIOP IP CPU INTR MASK
literal IO0C05$L_SLOT5_TLIDPVR_L = -1992283328; !  TIOP I/O DPATH VECT
literal IO0C05$L_SLOT5_TLIDPMSR_L = -1992283264; !  TIOP I/O DPATH MODE SEL
literal IO0C05$L_SLOT5_TLIBR_L = -1992283200; !  TIOP INFO BASE REPAIR
literal IO0C05$L_SLOT5_TLSTDERA_0_L = -1992228864; !  TLMEM SELFTEST DATA ERR REG A0
literal IO0C05$L_SLOT5_TLSTDERB_0_L = -1992228800; !  TLMEM SELFTEST DATA ERR REG B0
literal IO0C05$L_SLOT5_TLSTDERC_0_L = -1992228736; !  TLMEM SELFTEST DATA ERR REG C0
literal IO0C05$L_SLOT5_TLSTDERD_0_L = -1992228672; !  TLMEM SELFTEST DATA ERR REG D0
literal IO0C05$L_SLOT5_TLSTDERE_0_L = -1992228608; !  TLMEM SELFTEST DATA ERR REG E0
literal IO0C05$L_SLOT5_TLDDR0_L = -1992228544; !  TLMEM DATA DIAG REG 0
literal IO0C05$L_SLOT5_TLSTDERA_1_L = -1992212480; !  TLMEM SELFTEST DATA ERR REG A1
literal IO0C05$L_SLOT5_TLSTDERB_1_L = -1992212416; !  TLMEM SELFTEST DATA ERR REG B1
literal IO0C05$L_SLOT5_TLSTDERC_1_L = -1992212352; !  TLMEM SELFTEST DATA ERR REG C1
literal IO0C05$L_SLOT5_TLSTDERD_1_L = -1992212288; !  TLMEM SELFTEST DATA ERR REG D1
literal IO0C05$L_SLOT5_TLSTDERE_1_L = -1992212224; !  TLMEM SELFTEST DATA ERR REG E1
literal IO0C05$L_SLOT5_TLDDR1_L = -1992212160; !  TLMEM DATA DIAG REG 1
literal IO0C05$L_SLOT5_TLSTDERA_2_L = -1992196096; !  TLMEM SELFTEST DATA ERR REG A2
literal IO0C05$L_SLOT5_TLSTDERB_2_L = -1992196032; !  TLMEM SELFTEST DATA ERR REG B2
literal IO0C05$L_SLOT5_TLSTDERC_2_L = -1992195968; !  TLMEM SELFTEST DATA ERR REG C2
literal IO0C05$L_SLOT5_TLSTDERD_2_L = -1992195904; !  TLMEM SELFTEST DATA ERR REG D2
literal IO0C05$L_SLOT5_TLSTDERE_2_L = -1992195840; !  TLMEM SELFTEST DATA ERR REG E2
literal IO0C05$L_SLOT5_TLDDR2_L = -1992195776; !  TLMEM DATA DIAG REG 2
literal IO0C05$L_SLOT5_TLSTDERA_3_L = -1992179712; !  TLMEM SELFTEST DATA ERR REG A3
literal IO0C05$L_SLOT5_TLSTDERB_3_L = -1992179648; !  TLMEM SELFTEST DATA ERR REG B3
literal IO0C05$L_SLOT5_TLSTDERC_3_L = -1992179584; !  TLMEM SELFTEST DATA ERR REG C3
literal IO0C05$L_SLOT5_TLSTDERD_3_L = -1992179520; !  TLMEM SELFTEST DATA ERR REG D3
literal IO0C05$L_SLOT5_TLSTDERE_3_L = -1992179456; !  TLMEM SELFTEST DATA ERR REG E3
literal IO0C05$L_SLOT5_TLDDR3_L = -1992179392; !  TLMEM DATA DIAG REG 3
literal IO0C05$L_SLOT6_TLDEV_L = -1988100096; !  DEVICE
literal IO0C05$L_SLOT6_TLBER_L = -1988100032; !  ERROR
literal IO0C05$L_SLOT6_TLCNR_L = -1988099968; !  CONFIGURATION
literal IO0C05$L_SLOT6_TLVID_L = -1988099904; !  VIRT ID
literal IO0C05$L_SLOT6_TLMMR0_L = -1988099584; !  MEM MAPPING 0
literal IO0C05$L_SLOT6_TLMMR1_L = -1988099520; !  MEM MAPPING 1
literal IO0C05$L_SLOT6_TLMMR2_L = -1988099456; !  MEM MAPPING 2
literal IO0C05$L_SLOT6_TLMMR3_L = -1988099392; !  MEM MAPPING 3
literal IO0C05$L_SLOT6_TLMMR4_L = -1988099328; !  MEM MAPPING 4
literal IO0C05$L_SLOT6_TLMMR5_L = -1988099264; !  MEM MAPPING 5
literal IO0C05$L_SLOT6_TLMMR6_L = -1988099200; !  MEM MAPPING 6
literal IO0C05$L_SLOT6_TLMMR7_L = -1988099136; !  MEM MAPPING 7
literal IO0C05$L_SLOT6_TLFADR0_L = -1988098560; !  FAILING ADDR 0
literal IO0C05$L_SLOT6_TLFADR1_L = -1988098496; !  FAILING ADDR 1
literal IO0C05$L_SLOT6_TLESR0_L = -1988098432; !  BUS ERROR SYNDROME 0
literal IO0C05$L_SLOT6_TLESR1_L = -1988098368; !  BUS ERROR SYNDROME 1
literal IO0C05$L_SLOT6_TLESR2_L = -1988098304; !  BUS ERROR SYNDROME 2
literal IO0C05$L_SLOT6_TLESR3_L = -1988098240; !  BUS ERROR SYNDROME 3
literal IO0C05$L_SLOT6_TLILID0_L = -1988097536; !  TIOP INT LVL 0
literal IO0C05$L_SLOT6_TLILID1_L = -1988097472; !  TIOP INT LVL 1
literal IO0C05$L_SLOT6_TLILID2_L = -1988097408; !  TIOP INT LVL 2
literal IO0C05$L_SLOT6_TLILID3_L = -1988097344; !  TIOP INT LVL 3
literal IO0C05$L_SLOT6_TLCPUMASK_L = -1988097280; !  TIOP CPU INT MASK
literal IO0C05$L_SLOT6_TLMBPR_L = -1988097024; !  TIOP MBX PNTR REG
literal IO0C05$L_SLOT6_TLDIAG_L = -1988096000; !  TLEP DIAG SETUP
literal IO0C05$L_SLOT6_TLDTAGDATA_L = -1988095936; !  TLEP DTAG DATA
literal IO0C05$L_SLOT6_TLDTAGSTAT_L = -1988095872; !  TLEP DTAG STAT
literal IO0C05$L_SLOT6_TLMODCONFIG_L = -1988095808; !  TLEP MOD CONFIG
literal IO0C05$L_SLOT6_TLINTRMASK0_L = -1988095744; !  TLEP INT MASK 0
literal IO0C05$L_SLOT6_TLINTRMASK1_L = -1988095680; !  TLEP INT MASK 1
literal IO0C05$L_SLOT6_TLINTRSUM0_L = -1988095616; !  TLEP INT SUM 0
literal IO0C05$L_SLOT6_TLINTRSUM1_L = -1988095552; !  TLEP INT SUM 1
literal IO0C05$L_SLOT6_TLCON00_L = -1988095488; !  TLEP CONS COMM
literal IO0C05$L_SLOT6_TLCON00A_L = -1988095424; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT6_TLCON00B_L = -1988095360; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT6_TLCON00C_L = -1988095296; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT6_TLCON10_L = -1988095232; !  TLEP CONS COMM
literal IO0C05$L_SLOT6_TLCON10A_L = -1988095168; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT6_TLCON10B_L = -1988095104; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT6_TLCON10C_L = -1988095040; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT6_TLCON01_L = -1988094976; !  TLEP CONS COMM
literal IO0C05$L_SLOT6_TLCON11_L = -1988094912; !  TLEP CONS COMM
literal IO0C05$L_SLOT6_TLEPAERR_L = -1988094720; !  TLEP ADG ERROR
literal IO0C05$L_SLOT6_TLEPDERR_L = -1988094656; !  TLEP DIGA ERROR
literal IO0C05$L_SLOT6_TLEPMERR_L = -1988094592; !  TLEP MMG ERROR
literal IO0C05$L_SLOT6_TLEP_VMG_L = -1988094528; !  TLEP VOLT MARG
literal IO0C05$L_SLOT6_TLDMCMD_L = -1988094464; !  TLEP DM CMD 
literal IO0C05$L_SLOT6_TLDMADRA_L = -1988094336; !  TLEP DM A
literal IO0C05$L_SLOT6_TLDMADRB_L = -1988094272; !  TLEP DM B
literal IO0C05$L_SLOT6_TLPM_CMD_L = -1988093952; !  TLEP PERF MON CMD
literal IO0C05$L_SLOT6_TLSECR_L = -1988093952; !  TLMEM SECR EEPROM CNTL
literal IO0C05$L_SLOT6_TLPM_TOT_CYC_L = -1988093888; !  TLEP # OF CYCLES
literal IO0C05$L_SLOT6_TLMIR_L = -1988093888; !  TLMEM MEM INTERLEAVE
literal IO0C05$L_SLOT6_TLPM_EV5_LAT_L = -1988093824; !  TLEP EV5 RD LAT
literal IO0C05$L_SLOT6_TLMCR_L = -1988093824; !  TLMEM MEM CONFIG 
literal IO0C05$L_SLOT6_TLPM_READ_LAT_L = -1988093760; !  TLEP AV RD LAT
literal IO0C05$L_SLOT6_TLSTAIR_L = -1988093760; !  TLMEM SELFTEST ADR ISOL
literal IO0C05$L_SLOT6_TLPM_SYS_OWNER_L = -1988093696; !  TLEP # CYC OF SYS OWNER
literal IO0C05$L_SLOT6_TLSTER_L = -1988093696; !  TLMEM SELFTEST ERR REG
literal IO0C05$L_SLOT6_TLPM_CMD_SILO_L = -1988093632; !  TLEP CMD SILO
literal IO0C05$L_SLOT6_TLMER_L = -1988093632; !  TLMEM MEM ERROR REG
literal IO0C05$L_SLOT6_TLPM_LOCK_L = -1988093568; !  TLEP # LOCK ACKS
literal IO0C05$L_SLOT6_TLMDRA_L = -1988093568; !  TLMEM MEM DIAG REG A
literal IO0C05$L_SLOT6_TLPM_MB_L = -1988093504; !  TLEP # MB ACKS
literal IO0C05$L_SLOT6_TLMDRB_L = -1988093504; !  TLMEM MEM DIAG REG B
literal IO0C05$L_SLOT6_TLPM_SD_TOTAL_L = -1988093440; !  TLEP # SD
literal IO0C05$L_SLOT6_TLPM_SD_ACKED_L = -1988093376; !  TLEP # SD ACKS
literal IO0C05$L_SLOT6_TLPM_RD_CSR_L = -1988093312; !  TLEP # CSR RDS
literal IO0C05$L_SLOT6_TLPM_RD_L = -1988093248; !  TLEP # MEM RD MISS
literal IO0C05$L_SLOT6_TLPM_RD_MOD_L = -1988093184; !  TLEP # RD MISS MODS
literal IO0C05$L_SLOT6_TLPM_RD_STC_L = -1988093120; !  TLEP # RD MISS STXC
literal IO0C05$L_SLOT6_TLPM_VICTIM_L = -1988093056; !  TLEP # BC VICTIMS
literal IO0C05$L_SLOT6_TLPM_WR_CSR_L = -1988092992; !  TLEP # CSR WR CMDS
literal IO0C05$L_SLOT6_TLPM_WR_L = -1988092928; !  TLEP # WR BLK CMDS ACKED
literal IO0C05$L_SLOT6_TLPM_WR_LOCK_L = -1988092864; !  TLEP # WR BLK LK CMDS ACKED
literal IO0C05$L_SLOT6_TLPM_INVAL_L = -1988092800; !  TLEP # INVAL 
literal IO0C05$L_SLOT6_TLPM_SET_SHRD_L = -1988092736; !  TLEP # SET SHRDS
literal IO0C05$L_SLOT6_TLPM_RD_DIRTY_L = -1988092672; !  TLEP # RD DIRTYS
literal IO0C05$L_SLOT6_TLPM_ADR_SILO_L = -1988092608; !  TLEP ADR SILO REG
literal IO0C05$L_SLOT6_RM_RANG_REG0A_L = -1988092416; !  TLEP RM MR CHAN0A
literal IO0C05$L_SLOT6_RM_RANG_REG0B_L = -1988092352; !  TLEP RM MR CHAN0B
literal IO0C05$L_SLOT6_RM_RANG_REG1A_L = -1988092288; !  TLEP RM MR CHAN1A
literal IO0C05$L_SLOT6_RM_RANG_REG1B_L = -1988092224; !  TLEP RM MR CHAN1B
literal IO0C05$L_SLOT6_TLICCMSR_L = -1988091904; !  TIOP I/O CNTRL CHIP MODE SEL
literal IO0C05$L_SLOT6_TLICCNSE_L = -1988091840; !  TIOP I/O CNTRL CHIP NODE SPEC ERR
literal IO0C05$L_SLOT6_TLICCDR_L = -1988091776; !  TIOP I/O CNTRL CHIP DIAG REG
literal IO0C05$L_SLOT6_TLICCMTR_L = -1988091712; !  TIOP I/O CNTRL CHIP MBX TRANS REG
literal IO0C05$L_SLOT6_TLICCWRT_L = -1988091648; !  TIOP I/O CNTRL CHIP CSR WIND TRANS
literal IO0C05$L_SLOT6_TLIDPNSE1_L = -1988091584; !  TIOP NODE SPEC DPATH ERROR 1
literal IO0C05$L_SLOT6_TLIDPDR1_L = -1988091520; !  TIOP I/O DPATH DIAG REG 1
literal IO0C05$L_SLOT6_TLIDPNSE2_L = -1988091328; !  TIOP NODE SPEC DPATH ERROR 2
literal IO0C05$L_SLOT6_TLIDPDR2_L = -1988091264; !  TIOP I/O DPATH DIAG REG 2
literal IO0C05$L_SLOT6_TLIDPNSE3_L = -1988091072; !  TIOP NODE SPEC DPATH ERROR 3
literal IO0C05$L_SLOT6_TLIDPDR3_L = -1988091008; !  TIOP I/O DPATH DIAG REG 3
literal IO0C05$L_SLOT6_TLIDPNSE0_L = -1988089280; !  TIOP NODE SPEC DPATH ERROR 0
literal IO0C05$L_SLOT6_TLIDPDR0_L = -1988089216; !  TIOP I/O DPATH DIAG REG 0
literal IO0C05$L_SLOT6_TLIPCPUMASK_L = -1988089152; !  TIOP IP CPU INTR MASK
literal IO0C05$L_SLOT6_TLIDPVR_L = -1988089024; !  TIOP I/O DPATH VECT
literal IO0C05$L_SLOT6_TLIDPMSR_L = -1988088960; !  TIOP I/O DPATH MODE SEL
literal IO0C05$L_SLOT6_TLIBR_L = -1988088896; !  TIOP INFO BASE REPAIR
literal IO0C05$L_SLOT6_TLSTDERA_0_L = -1988034560; !  TLMEM SELFTEST DATA ERR REG A0
literal IO0C05$L_SLOT6_TLSTDERB_0_L = -1988034496; !  TLMEM SELFTEST DATA ERR REG B0
literal IO0C05$L_SLOT6_TLSTDERC_0_L = -1988034432; !  TLMEM SELFTEST DATA ERR REG C0
literal IO0C05$L_SLOT6_TLSTDERD_0_L = -1988034368; !  TLMEM SELFTEST DATA ERR REG D0
literal IO0C05$L_SLOT6_TLSTDERE_0_L = -1988034304; !  TLMEM SELFTEST DATA ERR REG E0
literal IO0C05$L_SLOT6_TLDDR0_L = -1988034240; !  TLMEM DATA DIAG REG 0
literal IO0C05$L_SLOT6_TLSTDERA_1_L = -1988018176; !  TLMEM SELFTEST DATA ERR REG A1
literal IO0C05$L_SLOT6_TLSTDERB_1_L = -1988018112; !  TLMEM SELFTEST DATA ERR REG B1
literal IO0C05$L_SLOT6_TLSTDERC_1_L = -1988018048; !  TLMEM SELFTEST DATA ERR REG C1
literal IO0C05$L_SLOT6_TLSTDERD_1_L = -1988017984; !  TLMEM SELFTEST DATA ERR REG D1
literal IO0C05$L_SLOT6_TLSTDERE_1_L = -1988017920; !  TLMEM SELFTEST DATA ERR REG E1
literal IO0C05$L_SLOT6_TLDDR1_L = -1988017856; !  TLMEM DATA DIAG REG 1
literal IO0C05$L_SLOT6_TLSTDERA_2_L = -1988001792; !  TLMEM SELFTEST DATA ERR REG A2
literal IO0C05$L_SLOT6_TLSTDERB_2_L = -1988001728; !  TLMEM SELFTEST DATA ERR REG B2
literal IO0C05$L_SLOT6_TLSTDERC_2_L = -1988001664; !  TLMEM SELFTEST DATA ERR REG C2
literal IO0C05$L_SLOT6_TLSTDERD_2_L = -1988001600; !  TLMEM SELFTEST DATA ERR REG D2
literal IO0C05$L_SLOT6_TLSTDERE_2_L = -1988001536; !  TLMEM SELFTEST DATA ERR REG E2
literal IO0C05$L_SLOT6_TLDDR2_L = -1988001472; !  TLMEM DATA DIAG REG 2
literal IO0C05$L_SLOT6_TLSTDERA_3_L = -1987985408; !  TLMEM SELFTEST DATA ERR REG A3
literal IO0C05$L_SLOT6_TLSTDERB_3_L = -1987985344; !  TLMEM SELFTEST DATA ERR REG B3
literal IO0C05$L_SLOT6_TLSTDERC_3_L = -1987985280; !  TLMEM SELFTEST DATA ERR REG C3
literal IO0C05$L_SLOT6_TLSTDERD_3_L = -1987985216; !  TLMEM SELFTEST DATA ERR REG D3
literal IO0C05$L_SLOT6_TLSTDERE_3_L = -1987985152; !  TLMEM SELFTEST DATA ERR REG E3
literal IO0C05$L_SLOT6_TLDDR3_L = -1987985088; !  TLMEM DATA DIAG REG 3
literal IO0C05$L_SLOT7_TLDEV_L = -1983905792; !  DEVICE
literal IO0C05$L_SLOT7_TLBER_L = -1983905728; !  ERROR
literal IO0C05$L_SLOT7_TLCNR_L = -1983905664; !  CONFIGURATION
literal IO0C05$L_SLOT7_TLVID_L = -1983905600; !  VIRT ID
literal IO0C05$L_SLOT7_TLMMR0_L = -1983905280; !  MEM MAPPING 0
literal IO0C05$L_SLOT7_TLMMR1_L = -1983905216; !  MEM MAPPING 1
literal IO0C05$L_SLOT7_TLMMR2_L = -1983905152; !  MEM MAPPING 2
literal IO0C05$L_SLOT7_TLMMR3_L = -1983905088; !  MEM MAPPING 3
literal IO0C05$L_SLOT7_TLMMR4_L = -1983905024; !  MEM MAPPING 4
literal IO0C05$L_SLOT7_TLMMR5_L = -1983904960; !  MEM MAPPING 5
literal IO0C05$L_SLOT7_TLMMR6_L = -1983904896; !  MEM MAPPING 6
literal IO0C05$L_SLOT7_TLMMR7_L = -1983904832; !  MEM MAPPING 7
literal IO0C05$L_SLOT7_TLFADR0_L = -1983904256; !  FAILING ADDR 0
literal IO0C05$L_SLOT7_TLFADR1_L = -1983904192; !  FAILING ADDR 1
literal IO0C05$L_SLOT7_TLESR0_L = -1983904128; !  BUS ERROR SYNDROME 0
literal IO0C05$L_SLOT7_TLESR1_L = -1983904064; !  BUS ERROR SYNDROME 1
literal IO0C05$L_SLOT7_TLESR2_L = -1983904000; !  BUS ERROR SYNDROME 2
literal IO0C05$L_SLOT7_TLESR3_L = -1983903936; !  BUS ERROR SYNDROME 3
literal IO0C05$L_SLOT7_TLILID0_L = -1983903232; !  TIOP INT LVL 0
literal IO0C05$L_SLOT7_TLILID1_L = -1983903168; !  TIOP INT LVL 1
literal IO0C05$L_SLOT7_TLILID2_L = -1983903104; !  TIOP INT LVL 2
literal IO0C05$L_SLOT7_TLILID3_L = -1983903040; !  TIOP INT LVL 3
literal IO0C05$L_SLOT7_TLCPUMASK_L = -1983902976; !  TIOP CPU INT MASK
literal IO0C05$L_SLOT7_TLMBPR_L = -1983902720; !  TIOP MBX PNTR REG
literal IO0C05$L_SLOT7_TLDIAG_L = -1983901696; !  TLEP DIAG SETUP
literal IO0C05$L_SLOT7_TLDTAGDATA_L = -1983901632; !  TLEP DTAG DATA
literal IO0C05$L_SLOT7_TLDTAGSTAT_L = -1983901568; !  TLEP DTAG STAT
literal IO0C05$L_SLOT7_TLMODCONFIG_L = -1983901504; !  TLEP MOD CONFIG
literal IO0C05$L_SLOT7_TLINTRMASK0_L = -1983901440; !  TLEP INT MASK 0
literal IO0C05$L_SLOT7_TLINTRMASK1_L = -1983901376; !  TLEP INT MASK 1
literal IO0C05$L_SLOT7_TLINTRSUM0_L = -1983901312; !  TLEP INT SUM 0
literal IO0C05$L_SLOT7_TLINTRSUM1_L = -1983901248; !  TLEP INT SUM 1
literal IO0C05$L_SLOT7_TLCON00_L = -1983901184; !  TLEP CONS COMM
literal IO0C05$L_SLOT7_TLCON00A_L = -1983901120; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT7_TLCON00B_L = -1983901056; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT7_TLCON00C_L = -1983900992; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT7_TLCON10_L = -1983900928; !  TLEP CONS COMM
literal IO0C05$L_SLOT7_TLCON10A_L = -1983900864; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT7_TLCON10B_L = -1983900800; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT7_TLCON10C_L = -1983900736; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT7_TLCON01_L = -1983900672; !  TLEP CONS COMM
literal IO0C05$L_SLOT7_TLCON11_L = -1983900608; !  TLEP CONS COMM
literal IO0C05$L_SLOT7_TLEPAERR_L = -1983900416; !  TLEP ADG ERROR
literal IO0C05$L_SLOT7_TLEPDERR_L = -1983900352; !  TLEP DIGA ERROR
literal IO0C05$L_SLOT7_TLEPMERR_L = -1983900288; !  TLEP MMG ERROR
literal IO0C05$L_SLOT7_TLEP_VMG_L = -1983900224; !  TLEP VOLT MARG
literal IO0C05$L_SLOT7_TLDMCMD_L = -1983900160; !  TLEP DM CMD 
literal IO0C05$L_SLOT7_TLDMADRA_L = -1983900032; !  TLEP DM A
literal IO0C05$L_SLOT7_TLDMADRB_L = -1983899968; !  TLEP DM B
literal IO0C05$L_SLOT7_TLPM_CMD_L = -1983899648; !  TLEP PERF MON CMD
literal IO0C05$L_SLOT7_TLSECR_L = -1983899648; !  TLMEM SECR EEPROM CNTL
literal IO0C05$L_SLOT7_TLPM_TOT_CYC_L = -1983899584; !  TLEP # OF CYCLES
literal IO0C05$L_SLOT7_TLMIR_L = -1983899584; !  TLMEM MEM INTERLEAVE
literal IO0C05$L_SLOT7_TLPM_EV5_LAT_L = -1983899520; !  TLEP EV5 RD LAT
literal IO0C05$L_SLOT7_TLMCR_L = -1983899520; !  TLMEM MEM CONFIG 
literal IO0C05$L_SLOT7_TLPM_READ_LAT_L = -1983899456; !  TLEP AV RD LAT
literal IO0C05$L_SLOT7_TLSTAIR_L = -1983899456; !  TLMEM SELFTEST ADR ISOL
literal IO0C05$L_SLOT7_TLPM_SYS_OWNER_L = -1983899392; !  TLEP # CYC OF SYS OWNER
literal IO0C05$L_SLOT7_TLSTER_L = -1983899392; !  TLMEM SELFTEST ERR REG
literal IO0C05$L_SLOT7_TLPM_CMD_SILO_L = -1983899328; !  TLEP CMD SILO
literal IO0C05$L_SLOT7_TLMER_L = -1983899328; !  TLMEM MEM ERROR REG
literal IO0C05$L_SLOT7_TLPM_LOCK_L = -1983899264; !  TLEP # LOCK ACKS
literal IO0C05$L_SLOT7_TLMDRA_L = -1983899264; !  TLMEM MEM DIAG REG A
literal IO0C05$L_SLOT7_TLPM_MB_L = -1983899200; !  TLEP # MB ACKS
literal IO0C05$L_SLOT7_TLMDRB_L = -1983899200; !  TLMEM MEM DIAG REG B
literal IO0C05$L_SLOT7_TLPM_SD_TOTAL_L = -1983899136; !  TLEP # SD
literal IO0C05$L_SLOT7_TLPM_SD_ACKED_L = -1983899072; !  TLEP # SD ACKS
literal IO0C05$L_SLOT7_TLPM_RD_CSR_L = -1983899008; !  TLEP # CSR RDS
literal IO0C05$L_SLOT7_TLPM_RD_L = -1983898944; !  TLEP # MEM RD MISS
literal IO0C05$L_SLOT7_TLPM_RD_MOD_L = -1983898880; !  TLEP # RD MISS MODS
literal IO0C05$L_SLOT7_TLPM_RD_STC_L = -1983898816; !  TLEP # RD MISS STXC
literal IO0C05$L_SLOT7_TLPM_VICTIM_L = -1983898752; !  TLEP # BC VICTIMS
literal IO0C05$L_SLOT7_TLPM_WR_CSR_L = -1983898688; !  TLEP # CSR WR CMDS
literal IO0C05$L_SLOT7_TLPM_WR_L = -1983898624; !  TLEP # WR BLK CMDS ACKED
literal IO0C05$L_SLOT7_TLPM_WR_LOCK_L = -1983898560; !  TLEP # WR BLK LK CMDS ACKED
literal IO0C05$L_SLOT7_TLPM_INVAL_L = -1983898496; !  TLEP # INVAL 
literal IO0C05$L_SLOT7_TLPM_SET_SHRD_L = -1983898432; !  TLEP # SET SHRDS
literal IO0C05$L_SLOT7_TLPM_RD_DIRTY_L = -1983898368; !  TLEP # RD DIRTYS
literal IO0C05$L_SLOT7_TLPM_ADR_SILO_L = -1983898304; !  TLEP ADR SILO REG
literal IO0C05$L_SLOT7_RM_RANG_REG0A_L = -1983898112; !  TLEP RM MR CHAN0A
literal IO0C05$L_SLOT7_RM_RANG_REG0B_L = -1983898048; !  TLEP RM MR CHAN0B
literal IO0C05$L_SLOT7_RM_RANG_REG1A_L = -1983897984; !  TLEP RM MR CHAN1A
literal IO0C05$L_SLOT7_RM_RANG_REG1B_L = -1983897920; !  TLEP RM MR CHAN1B
literal IO0C05$L_SLOT7_TLICCMSR_L = -1983897600; !  TIOP I/O CNTRL CHIP MODE SEL
literal IO0C05$L_SLOT7_TLICCNSE_L = -1983897536; !  TIOP I/O CNTRL CHIP NODE SPEC ERR
literal IO0C05$L_SLOT7_TLICCDR_L = -1983897472; !  TIOP I/O CNTRL CHIP DIAG REG
literal IO0C05$L_SLOT7_TLICCMTR_L = -1983897408; !  TIOP I/O CNTRL CHIP MBX TRANS REG
literal IO0C05$L_SLOT7_TLICCWRT_L = -1983897344; !  TIOP I/O CNTRL CHIP CSR WIND TRANS
literal IO0C05$L_SLOT7_TLIDPNSE1_L = -1983897280; !  TIOP NODE SPEC DPATH ERROR 1
literal IO0C05$L_SLOT7_TLIDPDR1_L = -1983897216; !  TIOP I/O DPATH DIAG REG 1
literal IO0C05$L_SLOT7_TLIDPNSE2_L = -1983897024; !  TIOP NODE SPEC DPATH ERROR 2
literal IO0C05$L_SLOT7_TLIDPDR2_L = -1983896960; !  TIOP I/O DPATH DIAG REG 2
literal IO0C05$L_SLOT7_TLIDPNSE3_L = -1983896768; !  TIOP NODE SPEC DPATH ERROR 3
literal IO0C05$L_SLOT7_TLIDPDR3_L = -1983896704; !  TIOP I/O DPATH DIAG REG 3
literal IO0C05$L_SLOT7_TLIDPNSE0_L = -1983894976; !  TIOP NODE SPEC DPATH ERROR 0
literal IO0C05$L_SLOT7_TLIDPDR0_L = -1983894912; !  TIOP I/O DPATH DIAG REG 0
literal IO0C05$L_SLOT7_TLIPCPUMASK_L = -1983894848; !  TIOP IP CPU INTR MASK
literal IO0C05$L_SLOT7_TLIDPVR_L = -1983894720; !  TIOP I/O DPATH VECT
literal IO0C05$L_SLOT7_TLIDPMSR_L = -1983894656; !  TIOP I/O DPATH MODE SEL
literal IO0C05$L_SLOT7_TLIBR_L = -1983894592; !  TIOP INFO BASE REPAIR
literal IO0C05$L_SLOT7_TLSTDERA_0_L = -1983840256; !  TLMEM SELFTEST DATA ERR REG A0
literal IO0C05$L_SLOT7_TLSTDERB_0_L = -1983840192; !  TLMEM SELFTEST DATA ERR REG B0
literal IO0C05$L_SLOT7_TLSTDERC_0_L = -1983840128; !  TLMEM SELFTEST DATA ERR REG C0
literal IO0C05$L_SLOT7_TLSTDERD_0_L = -1983840064; !  TLMEM SELFTEST DATA ERR REG D0
literal IO0C05$L_SLOT7_TLSTDERE_0_L = -1983840000; !  TLMEM SELFTEST DATA ERR REG E0
literal IO0C05$L_SLOT7_TLDDR0_L = -1983839936; !  TLMEM DATA DIAG REG 0
literal IO0C05$L_SLOT7_TLSTDERA_1_L = -1983823872; !  TLMEM SELFTEST DATA ERR REG A1
literal IO0C05$L_SLOT7_TLSTDERB_1_L = -1983823808; !  TLMEM SELFTEST DATA ERR REG B1
literal IO0C05$L_SLOT7_TLSTDERC_1_L = -1983823744; !  TLMEM SELFTEST DATA ERR REG C1
literal IO0C05$L_SLOT7_TLSTDERD_1_L = -1983823680; !  TLMEM SELFTEST DATA ERR REG D1
literal IO0C05$L_SLOT7_TLSTDERE_1_L = -1983823616; !  TLMEM SELFTEST DATA ERR REG E1
literal IO0C05$L_SLOT7_TLDDR1_L = -1983823552; !  TLMEM DATA DIAG REG 1
literal IO0C05$L_SLOT7_TLSTDERA_2_L = -1983807488; !  TLMEM SELFTEST DATA ERR REG A2
literal IO0C05$L_SLOT7_TLSTDERB_2_L = -1983807424; !  TLMEM SELFTEST DATA ERR REG B2
literal IO0C05$L_SLOT7_TLSTDERC_2_L = -1983807360; !  TLMEM SELFTEST DATA ERR REG C2
literal IO0C05$L_SLOT7_TLSTDERD_2_L = -1983807296; !  TLMEM SELFTEST DATA ERR REG D2
literal IO0C05$L_SLOT7_TLSTDERE_2_L = -1983807232; !  TLMEM SELFTEST DATA ERR REG E2
literal IO0C05$L_SLOT7_TLDDR2_L = -1983807168; !  TLMEM DATA DIAG REG 2
literal IO0C05$L_SLOT7_TLSTDERA_3_L = -1983791104; !  TLMEM SELFTEST DATA ERR REG A3
literal IO0C05$L_SLOT7_TLSTDERB_3_L = -1983791040; !  TLMEM SELFTEST DATA ERR REG B3
literal IO0C05$L_SLOT7_TLSTDERC_3_L = -1983790976; !  TLMEM SELFTEST DATA ERR REG C3
literal IO0C05$L_SLOT7_TLSTDERD_3_L = -1983790912; !  TLMEM SELFTEST DATA ERR REG D3
literal IO0C05$L_SLOT7_TLSTDERE_3_L = -1983790848; !  TLMEM SELFTEST DATA ERR REG E3
literal IO0C05$L_SLOT7_TLDDR3_L = -1983790784; !  TLMEM DATA DIAG REG 3
literal IO0C05$L_SLOT8_TLDEV_L = -1979711488; !  DEVICE
literal IO0C05$L_SLOT8_TLBER_L = -1979711424; !  ERROR
literal IO0C05$L_SLOT8_TLCNR_L = -1979711360; !  CONFIGURATION
literal IO0C05$L_SLOT8_TLVID_L = -1979711296; !  VIRT ID
literal IO0C05$L_SLOT8_TLMMR0_L = -1979710976; !  MEM MAPPING 0
literal IO0C05$L_SLOT8_TLMMR1_L = -1979710912; !  MEM MAPPING 1
literal IO0C05$L_SLOT8_TLMMR2_L = -1979710848; !  MEM MAPPING 2
literal IO0C05$L_SLOT8_TLMMR3_L = -1979710784; !  MEM MAPPING 3
literal IO0C05$L_SLOT8_TLMMR4_L = -1979710720; !  MEM MAPPING 4
literal IO0C05$L_SLOT8_TLMMR5_L = -1979710656; !  MEM MAPPING 5
literal IO0C05$L_SLOT8_TLMMR6_L = -1979710592; !  MEM MAPPING 6
literal IO0C05$L_SLOT8_TLMMR7_L = -1979710528; !  MEM MAPPING 7
literal IO0C05$L_SLOT8_TLFADR0_L = -1979709952; !  FAILING ADDR 0
literal IO0C05$L_SLOT8_TLFADR1_L = -1979709888; !  FAILING ADDR 1
literal IO0C05$L_SLOT8_TLESR0_L = -1979709824; !  BUS ERROR SYNDROME 0
literal IO0C05$L_SLOT8_TLESR1_L = -1979709760; !  BUS ERROR SYNDROME 1
literal IO0C05$L_SLOT8_TLESR2_L = -1979709696; !  BUS ERROR SYNDROME 2
literal IO0C05$L_SLOT8_TLESR3_L = -1979709632; !  BUS ERROR SYNDROME 3
literal IO0C05$L_SLOT8_TLILID0_L = -1979708928; !  TIOP INT LVL 0
literal IO0C05$L_SLOT8_TLILID1_L = -1979708864; !  TIOP INT LVL 1
literal IO0C05$L_SLOT8_TLILID2_L = -1979708800; !  TIOP INT LVL 2
literal IO0C05$L_SLOT8_TLILID3_L = -1979708736; !  TIOP INT LVL 3
literal IO0C05$L_SLOT8_TLCPUMASK_L = -1979708672; !  TIOP CPU INT MASK
literal IO0C05$L_SLOT8_TLMBPR_L = -1979708416; !  TIOP MBX PNTR REG
literal IO0C05$L_SLOT8_TLDIAG_L = -1979707392; !  TLEP DIAG SETUP
literal IO0C05$L_SLOT8_TLDTAGDATA_L = -1979707328; !  TLEP DTAG DATA
literal IO0C05$L_SLOT8_TLDTAGSTAT_L = -1979707264; !  TLEP DTAG STAT
literal IO0C05$L_SLOT8_TLMODCONFIG_L = -1979707200; !  TLEP MOD CONFIG
literal IO0C05$L_SLOT8_TLINTRMASK0_L = -1979707136; !  TLEP INT MASK 0
literal IO0C05$L_SLOT8_TLINTRMASK1_L = -1979707072; !  TLEP INT MASK 1
literal IO0C05$L_SLOT8_TLINTRSUM0_L = -1979707008; !  TLEP INT SUM 0
literal IO0C05$L_SLOT8_TLINTRSUM1_L = -1979706944; !  TLEP INT SUM 1
literal IO0C05$L_SLOT8_TLCON00_L = -1979706880; !  TLEP CONS COMM
literal IO0C05$L_SLOT8_TLCON00A_L = -1979706816; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT8_TLCON00B_L = -1979706752; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT8_TLCON00C_L = -1979706688; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT8_TLCON10_L = -1979706624; !  TLEP CONS COMM
literal IO0C05$L_SLOT8_TLCON10A_L = -1979706560; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT8_TLCON10B_L = -1979706496; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT8_TLCON10C_L = -1979706432; !  TLEP DIGA COMM TEST
literal IO0C05$L_SLOT8_TLCON01_L = -1979706368; !  TLEP CONS COMM
literal IO0C05$L_SLOT8_TLCON11_L = -1979706304; !  TLEP CONS COMM
literal IO0C05$L_SLOT8_TLEPAERR_L = -1979706112; !  TLEP ADG ERROR
literal IO0C05$L_SLOT8_TLEPDERR_L = -1979706048; !  TLEP DIGA ERROR
literal IO0C05$L_SLOT8_TLEPMERR_L = -1979705984; !  TLEP MMG ERROR
literal IO0C05$L_SLOT8_TLEP_VMG_L = -1979705920; !  TLEP VOLT MARG
literal IO0C05$L_SLOT8_TLDMCMD_L = -1979705856; !  TLEP DM CMD 
literal IO0C05$L_SLOT8_TLDMADRA_L = -1979705728; !  TLEP DM A
literal IO0C05$L_SLOT8_TLDMADRB_L = -1979705664; !  TLEP DM B
literal IO0C05$L_SLOT8_TLPM_CMD_L = -1979705344; !  TLEP PERF MON CMD
literal IO0C05$L_SLOT8_TLSECR_L = -1979705344; !  TLMEM SECR EEPROM CNTL
literal IO0C05$L_SLOT8_TLPM_TOT_CYC_L = -1979705280; !  TLEP # OF CYCLES
literal IO0C05$L_SLOT8_TLMIR_L = -1979705280; !  TLMEM MEM INTERLEAVE
literal IO0C05$L_SLOT8_TLPM_EV5_LAT_L = -1979705216; !  TLEP EV5 RD LAT
literal IO0C05$L_SLOT8_TLMCR_L = -1979705216; !  TLMEM MEM CONFIG 
literal IO0C05$L_SLOT8_TLPM_READ_LAT_L = -1979705152; !  TLEP AV RD LAT
literal IO0C05$L_SLOT8_TLSTAIR_L = -1979705152; !  TLMEM SELFTEST ADR ISOL
literal IO0C05$L_SLOT8_TLPM_SYS_OWNER_L = -1979705088; !  TLEP # CYC OF SYS OWNER
literal IO0C05$L_SLOT8_TLSTER_L = -1979705088; !  TLMEM SELFTEST ERR REG
literal IO0C05$L_SLOT8_TLPM_CMD_SILO_L = -1979705024; !  TLEP CMD SILO
literal IO0C05$L_SLOT8_TLMER_L = -1979705024; !  TLMEM MEM ERROR REG
literal IO0C05$L_SLOT8_TLPM_LOCK_L = -1979704960; !  TLEP # LOCK ACKS
literal IO0C05$L_SLOT8_TLMDRA_L = -1979704960; !  TLMEM MEM DIAG REG A
literal IO0C05$L_SLOT8_TLPM_MB_L = -1979704896; !  TLEP # MB ACKS
literal IO0C05$L_SLOT8_TLMDRB_L = -1979704896; !  TLMEM MEM DIAG REG B
literal IO0C05$L_SLOT8_TLPM_SD_TOTAL_L = -1979704832; !  TLEP # SD
literal IO0C05$L_SLOT8_TLPM_SD_ACKED_L = -1979704768; !  TLEP # SD ACKS
literal IO0C05$L_SLOT8_TLPM_RD_CSR_L = -1979704704; !  TLEP # CSR RDS
literal IO0C05$L_SLOT8_TLPM_RD_L = -1979704640; !  TLEP # MEM RD MISS
literal IO0C05$L_SLOT8_TLPM_RD_MOD_L = -1979704576; !  TLEP # RD MISS MODS
literal IO0C05$L_SLOT8_TLPM_RD_STC_L = -1979704512; !  TLEP # RD MISS STXC
literal IO0C05$L_SLOT8_TLPM_VICTIM_L = -1979704448; !  TLEP # BC VICTIMS
literal IO0C05$L_SLOT8_TLPM_WR_CSR_L = -1979704384; !  TLEP # CSR WR CMDS
literal IO0C05$L_SLOT8_TLPM_WR_L = -1979704320; !  TLEP # WR BLK CMDS ACKED
literal IO0C05$L_SLOT8_TLPM_WR_LOCK_L = -1979704256; !  TLEP # WR BLK LK CMDS ACKED
literal IO0C05$L_SLOT8_TLPM_INVAL_L = -1979704192; !  TLEP # INVAL 
literal IO0C05$L_SLOT8_TLPM_SET_SHRD_L = -1979704128; !  TLEP # SET SHRDS
literal IO0C05$L_SLOT8_TLPM_RD_DIRTY_L = -1979704064; !  TLEP # RD DIRTYS
literal IO0C05$L_SLOT8_TLPM_ADR_SILO_L = -1979704000; !  TLEP ADR SILO REG
literal IO0C05$L_SLOT8_RM_RANG_REG0A_L = -1979703808; !  TLEP RM MR CHAN0A
literal IO0C05$L_SLOT8_RM_RANG_REG0B_L = -1979703744; !  TLEP RM MR CHAN0B
literal IO0C05$L_SLOT8_RM_RANG_REG1A_L = -1979703680; !  TLEP RM MR CHAN1A
literal IO0C05$L_SLOT8_RM_RANG_REG1B_L = -1979703616; !  TLEP RM MR CHAN1B
literal IO0C05$L_SLOT8_TLICCMSR_L = -1979703296; !  TIOP I/O CNTRL CHIP MODE SEL
literal IO0C05$L_SLOT8_TLICCNSE_L = -1979703232; !  TIOP I/O CNTRL CHIP NODE SPEC ERR
literal IO0C05$L_SLOT8_TLICCDR_L = -1979703168; !  TIOP I/O CNTRL CHIP DIAG REG
literal IO0C05$L_SLOT8_TLICCMTR_L = -1979703104; !  TIOP I/O CNTRL CHIP MBX TRANS REG
literal IO0C05$L_SLOT8_TLICCWRT_L = -1979703040; !  TIOP I/O CNTRL CHIP CSR WIND TRANS
literal IO0C05$L_SLOT8_TLIDPNSE1_L = -1979702976; !  TIOP NODE SPEC DPATH ERROR 1
literal IO0C05$L_SLOT8_TLIDPDR1_L = -1979702912; !  TIOP I/O DPATH DIAG REG 1
literal IO0C05$L_SLOT8_TLIDPNSE2_L = -1979702720; !  TIOP NODE SPEC DPATH ERROR 2
literal IO0C05$L_SLOT8_TLIDPDR2_L = -1979702656; !  TIOP I/O DPATH DIAG REG 2
literal IO0C05$L_SLOT8_TLIDPNSE3_L = -1979702464; !  TIOP NODE SPEC DPATH ERROR 3
literal IO0C05$L_SLOT8_TLIDPDR3_L = -1979702400; !  TIOP I/O DPATH DIAG REG 3
literal IO0C05$L_SLOT8_TLIDPNSE0_L = -1979700672; !  TIOP NODE SPEC DPATH ERROR 0
literal IO0C05$L_SLOT8_TLIDPDR0_L = -1979700608; !  TIOP I/O DPATH DIAG REG 0
literal IO0C05$L_SLOT8_TLIPCPUMASK_L = -1979700544; !  TIOP IP CPU INTR MASK
literal IO0C05$L_SLOT8_TLIDPVR_L = -1979700416; !  TIOP I/O DPATH VECT
literal IO0C05$L_SLOT8_TLIDPMSR_L = -1979700352; !  TIOP I/O DPATH MODE SEL
literal IO0C05$L_SLOT8_TLIBR_L = -1979700288; !  TIOP INFO BASE REPAIR
literal IO0C05$L_SLOT8_TLSTDERA_0_L = -1979645952; !  TLMEM SELFTEST DATA ERR REG A0
literal IO0C05$L_SLOT8_TLSTDERB_0_L = -1979645888; !  TLMEM SELFTEST DATA ERR REG B0
literal IO0C05$L_SLOT8_TLSTDERC_0_L = -1979645824; !  TLMEM SELFTEST DATA ERR REG C0
literal IO0C05$L_SLOT8_TLSTDERD_0_L = -1979645760; !  TLMEM SELFTEST DATA ERR REG D0
literal IO0C05$L_SLOT8_TLSTDERE_0_L = -1979645696; !  TLMEM SELFTEST DATA ERR REG E0
literal IO0C05$L_SLOT8_TLDDR0_L = -1979645632; !  TLMEM DATA DIAG REG 0
literal IO0C05$L_SLOT8_TLSTDERA_1_L = -1979629568; !  TLMEM SELFTEST DATA ERR REG A1
literal IO0C05$L_SLOT8_TLSTDERB_1_L = -1979629504; !  TLMEM SELFTEST DATA ERR REG B1
literal IO0C05$L_SLOT8_TLSTDERC_1_L = -1979629440; !  TLMEM SELFTEST DATA ERR REG C1
literal IO0C05$L_SLOT8_TLSTDERD_1_L = -1979629376; !  TLMEM SELFTEST DATA ERR REG D1
literal IO0C05$L_SLOT8_TLSTDERE_1_L = -1979629312; !  TLMEM SELFTEST DATA ERR REG E1
literal IO0C05$L_SLOT8_TLDDR1_L = -1979629248; !  TLMEM DATA DIAG REG 1
literal IO0C05$L_SLOT8_TLSTDERA_2_L = -1979613184; !  TLMEM SELFTEST DATA ERR REG A2
literal IO0C05$L_SLOT8_TLSTDERB_2_L = -1979613120; !  TLMEM SELFTEST DATA ERR REG B2
literal IO0C05$L_SLOT8_TLSTDERC_2_L = -1979613056; !  TLMEM SELFTEST DATA ERR REG C2
literal IO0C05$L_SLOT8_TLSTDERD_2_L = -1979612992; !  TLMEM SELFTEST DATA ERR REG D2
literal IO0C05$L_SLOT8_TLSTDERE_2_L = -1979612928; !  TLMEM SELFTEST DATA ERR REG E2
literal IO0C05$L_SLOT8_TLDDR2_L = -1979612864; !  TLMEM DATA DIAG REG 2
literal IO0C05$L_SLOT8_TLSTDERA_3_L = -1979596800; !  TLMEM SELFTEST DATA ERR REG A3
literal IO0C05$L_SLOT8_TLSTDERB_3_L = -1979596736; !  TLMEM SELFTEST DATA ERR REG B3
literal IO0C05$L_SLOT8_TLSTDERC_3_L = -1979596672; !  TLMEM SELFTEST DATA ERR REG C3
literal IO0C05$L_SLOT8_TLSTDERD_3_L = -1979596608; !  TLMEM SELFTEST DATA ERR REG D3
literal IO0C05$L_SLOT8_TLSTDERE_3_L = -1979596544; !  TLMEM SELFTEST DATA ERR REG E3
literal IO0C05$L_SLOT8_TLDDR3_L = -1979596480; !  TLMEM DATA DIAG REG 3
 
!*** MODULE $IO0E04DEF ***
literal IO0E04$L_IOC_IACK_SC_PA_L = -1073741824;
literal IO0E04$L_IOC_IACK_SC_PA_H = 1;
literal IO0E04$L_CFG_CYCLE_PA_L = -2147483648;
literal IO0E04$L_CFG_CYCLE_PA_H = 1;
literal IO0E04$L_TB_EN_PA_L = -2147483648;
literal IO0E04$L_TB_EN_PA_H = 1;
literal IO0E04$L_PCI_SFT_RST_PA_L = -2147483648;
literal IO0E04$L_PCI_SFT_RST_PA_H = 1;
literal IO0E04$L_PCI_PAR_DISABLE_PA_L = -2147483648;
literal IO0E04$L_PCI_PAR_DISABLE_PA_H = 1;
literal IO0E04$L_PCI_IO_PA_L = 0;
literal IO0E04$L_PCI_IO_PA_H = 3;
literal IO0E04$L_PCI_IO_END_PA_L = 2097152;
literal IO0E04$L_PCI_IO_END_PA_H = 3;
literal IO0E04$L_KBD_DATA_PA_L = 3072;
literal IO0E04$L_KBD_DATA_PA_H = 3;
literal IO0E04$B_KBD_DATA_PCI = 96;
literal IO0E04$L_KBD_CMD_PA_L = 3200;
literal IO0E04$L_KBD_CMD_PA_H = 3;
literal IO0E04$B_KBD_CMD_PCI = 100;
literal IO0E04$L_DS1287_PA_L = 3584;
literal IO0E04$L_DS1287_PA_H = 3;
literal IO0E04$L_COM1_PA_L = 32512;
literal IO0E04$L_COM1_PA_H = 3;
literal IO0E04$L_COM1_RCV_BUF_PCI = 1016;
literal IO0E04$L_COM1_IER_PCI = 1017;
literal IO0E04$L_COM1_IIR_PCI = 1018;
literal IO0E04$L_COM1_L_CTL_PCI = 1019;
literal IO0E04$L_COM1_M_CTL_PCI = 1020;
literal IO0E04$L_COM1_L_STAT_PCI = 1021;
literal IO0E04$L_COM1_M_STAT_PCI = 1022;
literal IO0E04$L_COM2_PA_L = 24320;
literal IO0E04$L_COM2_PA_H = 3;
literal IO0E04$L_COM2_RCV_BUF_PCI = 760;
literal IO0E04$L_COM2_IER_PCI = 761;
literal IO0E04$L_COM2_IIR_PCI = 762;
literal IO0E04$L_COM2_L_CTL_PCI = 763;
literal IO0E04$L_COM2_M_CTL_PCI = 764;
literal IO0E04$L_COM2_L_STAT_PCI = 765;
literal IO0E04$L_COM2_M_STAT_PCI = 766;
literal IO0E04$L_PPORT_PA_L = 28416;
literal IO0E04$L_PPORT_PA_H = 3;
literal IO0E04$L_FLOPPY_PA_L = 32256;
literal IO0E04$L_FLOPPY_PA_H = 3;
literal IO0E04$L_MASTER_ICR_PCI = 32;
literal IO0E04$L_MASTER_IMR_PCI = 33;
literal IO0E04$L_SLAVE_ICR_PCI = 160;
literal IO0E04$L_SLAVE_IMR_PCI = 161;
literal IO0E04$L_PCI_IRR_REG = 38;
literal IO0E04$L_PCI_IMR_REG = 38;
literal IO0E04$L_HAE_PA_L = -2147483648;
literal IO0E04$L_HAE_PA_H = 1;
literal IO0E04$L_IOC_STAT0_PA_L = -2147483584;
literal IO0E04$L_IOC_STAT0_PA_H = 1;
literal IO0E04$L_IOC_STAT1_PA_L = -2147483552;
literal IO0E04$L_IOC_STAT1_PA_H = 1;
literal IO0E04$L_IOC_TBIA_PA_L = -2147483520;
literal IO0E04$L_IOC_TBIA_PA_H = 1;
literal IO0E04$L_IOC_W_BASE_0_PA_L = -2147483392;
literal IO0E04$L_IOC_W_BASE_0_PA_H = 1;
literal IO0E04$L_IOC_W_BASE_1_PA_L = -2147483360;
literal IO0E04$L_IOC_W_BASE_1_PA_H = 1;
literal IO0E04$L_IOC_W_MASK_0_PA_L = -2147483328;
literal IO0E04$L_IOC_W_MASK_0_PA_H = 1;
literal IO0E04$L_IOC_W_MASK_1_PA_L = -2147483296;
literal IO0E04$L_IOC_W_MASK_1_PA_H = 1;
literal IO0E04$L_IOC_T_BASE_0_PA_L = -2147483264;
literal IO0E04$L_IOC_T_BASE_0_PA_H = 1;
literal IO0E04$L_IOC_T_BASE_1_PA_L = -2147483232;
literal IO0E04$L_IOC_T_BASE_1_PA_H = 1;
literal IO0E04$L_IOC_TB_TAG_0_PA_L = -2130706432;
literal IO0E04$L_IOC_TB_TAG_0_PA_H = 1;
literal IO0E04$L_IOC_TB_TAG_1_PA_L = -2130706400;
literal IO0E04$L_IOC_TB_TAG_1_PA_H = 1;
literal IO0E04$L_IOC_TB_TAG_2_PA_L = -2130706368;
literal IO0E04$L_IOC_TB_TAG_2_PA_H = 1;
literal IO0E04$L_IOC_TB_TAG_3_PA_L = -2130706336;
literal IO0E04$L_IOC_TB_TAG_3_PA_H = 1;
literal IO0E04$L_IOC_TB_TAG_4_PA_L = -2130706304;
literal IO0E04$L_IOC_TB_TAG_4_PA_H = 1;
literal IO0E04$L_IOC_TB_TAG_5_PA_L = -2130706272;
literal IO0E04$L_IOC_TB_TAG_5_PA_H = 1;
literal IO0E04$L_IOC_TB_TAG_6_PA_L = -2130706240;
literal IO0E04$L_IOC_TB_TAG_6_PA_H = 1;
literal IO0E04$L_IOC_TB_TAG_7_PA_L = -2130706208;
literal IO0E04$L_IOC_TB_TAG_7_PA_H = 1;
literal IO0E04$L_FLASH_ROM1_PA = 939524096;
literal IO0E04$L_FLASH_ROM2_PA = 941621248;
literal IO0E04$L_FLASH_ROM3_PA = 943718400;
literal IO0E04$L_FLASH_ROM4_PA = 945815552;
literal IO0E04$L_FLASH_ROM1_END_PA = 941621240;
literal IO0E04$L_FLASH_ROM2_END_PA = 943718392;
literal IO0E04$L_FLASH_ROM3_END_PA = 945815544;
literal IO0E04$L_FLASH_ROM4_END_PA = 947912696;
literal IO0E04$L_PCI_SPARSE_MEM_PA_L = 0;
literal IO0E04$L_PCI_SPARSE_MEM_PA_H = 2;
literal IO0E04$L_PCI_SPARSE_MEMEND_PA_L = 536870912;
literal IO0E04$L_PCI_SPARSE_MEMEND_PA_H = 2;
literal IO0E04$L_PCI_DENSE_MEM_PA_L = 0;
literal IO0E04$L_PCI_DENSE_MEM_PA_H = 3;
literal IO0E04$L_PCI_DENSE_MEM_END_PA_L = -1;
literal IO0E04$L_PCI_DENSE_MEM_END_PA_H = 3;
 
!*** MODULE $IO0F05DEF ***
literal IO0F05$L_NODE_PA_H = 135;       !  High order word
literal IO0F05$L_CIA_GENERAL_L = 1073741824;
literal IO0F05$L_CIA_MEMORY_L = 1342177280;
literal IO0F05$L_CIA_PCI_ADDR_L = 1610612736;
literal IO0F05$L_FLASH_AND_GRU_L = -2147483648;
literal IO0F05$L_PCI_REV_L = 128;       ! PCI revision
literal IO0F05$L_PCI_LAT_L = 192;       ! PCI Latency
literal IO0F05$L_CIA_CTRL_L = 256;      ! CIA COntrol
literal IO0F05$L_HAE_MEM_L = 1024;      ! HAE memory
literal IO0F05$L_HAE_IO_L = 1088;       ! HAE I/O
literal IO0F05$L_HAE_CFG_L = 1152;      ! COnfig
literal IO0F05$L_CIA_CACK_EN_L = 1536;  ! Ack control
literal IO0F05$L_CIA_DIAG_L = 8192;     ! Diag control
literal IO0F05$L_CIA_CHECK_L = 12288;   ! Diag check
literal IO0F05$L_PERF_MON_L = 16384;    ! Perf monitor
literal IO0F05$L_PERF_CNTR_L = 16448;   ! Perf control
literal IO0F05$L_CPU_ERR0_L = 32768;    ! Cpu err info 0
literal IO0F05$L_CPU_ERR1_L = 32832;    ! Cpu err info 1
literal IO0F05$L_CIA_ERR_L = 33280;     ! CIA err
literal IO0F05$L_CIA_STAT_L = 33344;    ! CIA status
literal IO0F05$L_CIA_ERR_MSK_L = 33408; ! CIA err mask
literal IO0F05$L_CIA_SYN_L = 33536;     ! CIA syndrome
literal IO0F05$L_CPU_MPSR0_L = 33792;   ! Memport stat0
literal IO0F05$L_CPU_MPSR1_L = 33856;   ! Memport stat1
literal IO0F05$L_PCI_ERR0_L = 34816;    ! PCI Err 0
literal IO0F05$L_PCI_ERR1_L = 34880;    ! PCI Err 1
literal IO0F05$L_PCI_ERR2_L = 34944;    ! PCI Err 1
literal IO0F05$L_MEM_CNFG_L = 0;        ! Memory config
literal IO0F05$L_MEM_BA0_L = 1536;      ! Mem base addr0
literal IO0F05$L_MEM_BA2_L = 1664;      ! Mem base addr2
literal IO0F05$L_MEM_BA4_L = 1792;      ! Mem base addr4
literal IO0F05$L_MEM_BA6_L = 1920;      ! Mem base addr6
literal IO0F05$L_MEM_BA8_L = 2048;      ! Mem base addr8
literal IO0F05$L_MEM_BAA_L = 2176;      ! Mem base addrA
literal IO0F05$L_MEM_BAC_L = 2304;      ! Mem base addrC
literal IO0F05$L_MEM_BAE_L = 2432;      ! Mem base addrE
literal IO0F05$L_MEM_TMG0_L = 2816;     ! Mem timing 0
literal IO0F05$L_MEM_TMG1_L = 2880;     ! Mem timing 1
literal IO0F05$L_MEM_TMG2_L = 2944;     ! Mem timing 2
literal IO0F05$L_PCI_TBIA_L = 256;      ! SG TB inval
literal IO0F05$L_PCI_W0_BASE_L = 1024;  ! Window base0
literal IO0F05$L_PCI_W0_MASK_L = 1088;  ! Window mask0
literal IO0F05$L_PCI_T0_BASE_L = 1152;  ! Trans base0
literal IO0F05$L_PCI_W1_BASE_L = 1280;  ! Window base1
literal IO0F05$L_PCI_W1_MASK_L = 1344;  ! Window mask1
literal IO0F05$L_PCI_T1_BASE_L = 1408;  ! Trans base1
literal IO0F05$L_PCI_W2_BASE_L = 1536;  ! Window base2
literal IO0F05$L_PCI_W2_MASK_L = 1600;  ! Window mask2
literal IO0F05$L_PCI_T2_BASE_L = 1664;  ! Trans base2
literal IO0F05$L_PCI_W3_BASE_L = 1792;  ! Window base3
literal IO0F05$L_PCI_W3_MASK_L = 1856;  ! Window mask3
literal IO0F05$L_PCI_T3_BASE_L = 1920;  ! Trans base3
literal IO0F05$L_PCI_DAC_BASE_L = 1984; ! DAC Base
literal IO0F05$L_PCI_LTB_TAG0_L = 2048; ! Lock TB tag0
literal IO0F05$L_PCI_LTB_TAG1_L = 2112; ! Lock TB tag1
literal IO0F05$L_PCI_LTB_TAG2_L = 2176; ! Lock TB tag2
literal IO0F05$L_PCI_LTB_TAG3_L = 2240; ! Lock TB tag3
literal IO0F05$L_PCI_TB_TAG0_L = 2304;  !  TB tag0
literal IO0F05$L_PCI_TB_TAG1_L = 2368;  !  TB tag1
literal IO0F05$L_PCI_TB_TAG2_L = 2432;  !  TB tag2
literal IO0F05$L_PCI_TB_TAG3_L = 2496;  !  TB tag3
literal IO0F05$L_PCI_TB0_PAGE0_L = 4096; !  TB0 page0
literal IO0F05$L_PCI_TB0_PAGE1_L = 4160; !  TB0 page1
literal IO0F05$L_PCI_TB0_PAGE2_L = 4224; !  TB0 page2
literal IO0F05$L_PCI_TB0_PAGE3_L = 4288; !  TB0 page3
literal IO0F05$L_PCI_TB1_PAGE0_L = 4352; !  TB1 page0
literal IO0F05$L_PCI_TB1_PAGE1_L = 4416; !  TB1 page1
literal IO0F05$L_PCI_TB1_PAGE2_L = 4480; !  TB1 page2
literal IO0F05$L_PCI_TB1_PAGE3_L = 4544; !  TB1 page3
literal IO0F05$L_PCI_TB2_PAGE0_L = 4608; !  TB2 page0
literal IO0F05$L_PCI_TB2_PAGE1_L = 4672; !  TB2 page1
literal IO0F05$L_PCI_TB2_PAGE2_L = 4736; !  TB2 page2
literal IO0F05$L_PCI_TB2_PAGE3_L = 4800; !  TB2 page3
literal IO0F05$L_PCI_TB3_PAGE0_L = 4864; !  TB3 page0
literal IO0F05$L_PCI_TB3_PAGE1_L = 4928; !  TB3 page1
literal IO0F05$L_PCI_TB3_PAGE2_L = 4992; !  TB3 page2
literal IO0F05$L_PCI_TB3_PAGE3_L = 5056; !  TB3 page3
literal IO0F05$L_PCI_TB4_PAGE0_L = 5120; !  TB4 page0
literal IO0F05$L_PCI_TB4_PAGE1_L = 5184; !  TB4 page1
literal IO0F05$L_PCI_TB4_PAGE2_L = 5248; !  TB4 page2
literal IO0F05$L_PCI_TB4_PAGE3_L = 5312; !  TB4 page3
literal IO0F05$L_PCI_TB5_PAGE0_L = 5376; !  TB5 page0
literal IO0F05$L_PCI_TB5_PAGE1_L = 5440; !  TB5 page1
literal IO0F05$L_PCI_TB5_PAGE2_L = 5504; !  TB5 page2
literal IO0F05$L_PCI_TB5_PAGE3_L = 5568; !  TB5 page3
literal IO0F05$L_PCI_TB6_PAGE0_L = 5632; !  TB6 page0
literal IO0F05$L_PCI_TB6_PAGE1_L = 5696; !  TB6 page1
literal IO0F05$L_PCI_TB6_PAGE2_L = 5760; !  TB6 page2
literal IO0F05$L_PCI_TB6_PAGE3_L = 5824; !  TB6 page3
literal IO0F05$L_PCI_TB7_PAGE0_L = 5888; !  TB7 page0
literal IO0F05$L_PCI_TB7_PAGE1_L = 5952; !  TB7 page1
literal IO0F05$L_PCI_TB7_PAGE2_L = 6016; !  TB7 page2
literal IO0F05$L_PCI_TB7_PAGE3_L = 6080; !  TB7 page3
literal IO0F05$L_GRU_INT_REQ_L = 0;     !  Int request
literal IO0F05$L_GRU_INT_MASK_L = 64;   !  Int mask
literal IO0F05$L_GRU_INT_EDGE_L = 128;  !  Level/edge selct
literal IO0F05$L_GRU_INT_HILO_L = 192;  !  Hi/lo irq select
literal IO0F05$L_GRU_INT_CLR_L = 256;   !  Clear Int
literal IO0F05$L_GRU_CACHE_CNFG_L = 512; !  Cache config
literal IO0F05$L_GRU_SET_CNFG_L = 768;  !  Set Cache config
literal IO0F05$L_GRU_LEDS_L = 2048;     !  LEDs
literal IO0F05$L_GRU_RESET_L = 2304;    !  Force system reset
 
!*** MODULE $IO1504DEF ***
literal IO1504$K_IOC_HAE_PA_L = -2147483648;
literal IO1504$K_IOC_HAE_PA_H = 1;
literal IO1504$K_IOC_CONF_PA_L = -2147483648;
literal IO1504$K_IOC_CONF_PA_H = 32;
literal IO1504$K_IOC_STAT0_PA_L = -2147483584;
literal IO1504$K_IOC_STAT0_PA_H = 1;
literal IO1504$K_IOC_STAT1_PA_L = -2147483552;
literal IO1504$K_IOC_STAT1_PA_H = 1;
literal IO1504$K_IOC_TBIA_PA_L = -2147483520;
literal IO1504$K_IOC_TBIA_PA_H = 1;
literal IO1504$K_TB_ENA_PA_L = -2147483648;
literal IO1504$K_TB_ENA_PA_H = 160;
literal IO1504$K_SFT_RST_PA_L = -2147483648;
literal IO1504$K_SFT_RST_PA_H = 192;
literal IO1504$K_PAR_DIS_PA_L = -2147483648;
literal IO1504$K_PAR_DIS_PA_H = 224;
literal IO1504$K_IOC_W_BASE0_PA_L = -2147483392;
literal IO1504$K_IOC_W_BASE0_PA_H = 1;
literal IO1504$K_IOC_W_BASE1_PA_L = -2147483360;
literal IO1504$K_IOC_W_BASE1_PA_H = 1;
literal IO1504$K_IOC_W_MASK0_PA_L = -2147483328;
literal IO1504$K_IOC_W_MASK0_PA_H = 1;
literal IO1504$K_IOC_W_MASK1_PA_L = -2147483296;
literal IO1504$K_IOC_W_MASK1_PA_H = 1;
literal IO1504$K_IOC_T_BASE0_PA_L = -2147483264;
literal IO1504$K_IOC_T_BASE0_PA_H = 1;
literal IO1504$K_IOC_T_BASE1_PA_L = -2147483232;
literal IO1504$K_IOC_T_BASE1_PA_H = 1;
literal IO1504$K_IOC_TB_TAG0_PA_L = -2130706432;
literal IO1504$K_IOC_TB_TAG0_PA_H = 0;
literal IO1504$K_IOC_TB_TAG1_PA_L = -2130706432;
literal IO1504$K_IOC_TB_TAG1_PA_H = 32;
literal IO1504$K_IOC_TB_TAG2_PA_L = -2130706432;
literal IO1504$K_IOC_TB_TAG2_PA_H = 64;
literal IO1504$K_IOC_TB_TAG3_PA_L = -2130706432;
literal IO1504$K_IOC_TB_TAG3_PA_H = 96;
literal IO1504$K_IOC_TB_TAG4_PA_L = -2130706432;
literal IO1504$K_IOC_TB_TAG4_PA_H = 128;
literal IO1504$K_IOC_TB_TAG5_PA_L = -2130706432;
literal IO1504$K_IOC_TB_TAG5_PA_H = 160;
literal IO1504$K_IOC_TB_TAG6_PA_L = -2130706432;
literal IO1504$K_IOC_TB_TAG6_PA_H = 192;
literal IO1504$K_IOC_TB_TAG7_PA_L = -2130706432;
literal IO1504$K_IOC_TB_TAG7_PA_H = 224;
literal IO1504$K_IOC_IACK_SC_PA_L = -1610612736;
literal IO1504$K_IOC_IACK_SC_PA_H = 1;
literal IO1504$K_PCI_IO_PA_L = -1073741824;
literal IO1504$K_PCI_IO_PA_H = 1;
literal IO1504$K_PCI_IO_END_PA_L = -536870913;
literal IO1504$K_PCI_IO_END_PA_H = 1;
literal IO1504$K_PCI_CFG_PA_L = -536870912;
literal IO1504$K_PCI_CFG_PA_H = 1;
literal IO1504$K_PCI_SPARSE_MEM_PA_L = 0;
literal IO1504$K_PCI_SPARSE_MEM_PA_H = 2;
literal IO1504$K_PCI_SPARSE_MEMEND_PA_L = 536870912;
literal IO1504$K_PCI_SPARSE_MEMEND_PA_H = 2;
literal IO1504$K_PCI_DENSE_MEM_PA_L = 0;
literal IO1504$K_PCI_DENSE_MEM_PA_H = 3;
literal IO1504$K_PCI_DENSE_MEM_END_PA_L = -1;
literal IO1504$K_PCI_DENSE_MEM_END_PA_H = 3;
literal IO1504$K_KBD_DATA_PA_L = -1073738752;
literal IO1504$K_KBD_DATA_PA_H = 1;
literal IO1504$B_KBD_DATA_PCI = 96;
literal IO1504$K_KBD_CMD_PA_L = -1073738624;
literal IO1504$K_KBD_CMD_PA_H = 1;
literal IO1504$B_KBD_CMD_PCI = 100;
literal IO1504$K_DS1287_PA_L = -1073738240;
literal IO1504$K_DS1287_PA_H = 1;
literal IO1504$K_COM1_PA_L = -1073709312;
literal IO1504$K_COM1_PA_H = 1;
literal IO1504$K_COM1_RCV_BUF_PCI = 1016;
literal IO1504$K_COM1_IER_PCI = 1017;
literal IO1504$K_COM1_IIR_PCI = 1018;
literal IO1504$K_COM1_L_CTL_PCI = 1019;
literal IO1504$K_COM1_M_CTL_PCI = 1020;
literal IO1504$K_COM1_L_STAT_PCI = 1021;
literal IO1504$K_COM1_M_STAT_PCI = 1022;
literal IO1504$K_COM2_PA_L = -1073717504;
literal IO1504$K_COM2_PA_H = 1;
literal IO1504$K_COM2_RCV_BUF_PCI = 760;
literal IO1504$K_COM2_IER_PCI = 761;
literal IO1504$K_COM2_IIR_PCI = 762;
literal IO1504$K_COM2_L_CTL_PCI = 763;
literal IO1504$K_COM2_M_CTL_PCI = 764;
literal IO1504$K_COM2_L_STAT_PCI = 765;
literal IO1504$K_COM2_M_STAT_PCI = 766;
literal IO1504$K_PPORT_PA_L = -1073713408;
literal IO1504$K_PPORT_PA_H = 1;
literal IO1504$K_FLOPPY_PA_L = -1073709568;
literal IO1504$K_FLOPPY_PA_H = 1;
literal IO1504$K_MASTER_ICR_PCI = 32;
literal IO1504$K_MASTER_IMR_PCI = 33;
literal IO1504$K_SLAVE_ICR_PCI = 160;
literal IO1504$K_SLAVE_IMR_PCI = 161;
literal IO1504$K_PCI_IRR_REG = 38;
literal IO1504$K_PCI_IMR_REG = 38;
literal IO1504$K_FLASH_ROM1_PA = 939524096;
literal IO1504$K_FLASH_ROM2_PA = 941621248;
literal IO1504$K_FLASH_ROM3_PA = 943718400;
literal IO1504$K_FLASH_ROM4_PA = 945815552;
literal IO1504$K_FLASH_ROM1_END_PA = 941621240;
literal IO1504$K_FLASH_ROM2_END_PA = 943718392;
literal IO1504$K_FLASH_ROM3_END_PA = 945815544;
literal IO1504$K_FLASH_ROM4_END_PA = 947912696;
literal IO1504$K_OPDRIVER_XMT_ISR = 3;
literal IO1504$K_OPDRIVER_RCV_ISR = 4;
 
!*** MODULE $IOCDEF ***
! +
! 
!  $IOCDEF - flag bits used in I/O database search routines.
! 
! -
literal IOC$M_PHY = %X'1';
literal IOC$M_TYPE = %X'2';
literal IOC$M_CLASS = %X'4';
literal IOC$M_LOCAL = %X'8';
literal IOC$M_EXISTS = %X'10';
literal IOC$M_2P = %X'20';
literal IOC$M_ANY = %X'40';
literal IOC$M_MOUNT = %X'80';
literal IOC$M_ALT = %X'100';
literal IOC$M_NO_TRANS = %X'200';
literal IOC$M_ALLOC = %X'400';
literal IOC$M_DTN = %X'800';
literal IOC$S_IOCDEF = 2;               !  Old size name, synonym for IOC$S_IOC
literal IOC$S_IOC = 2;
!  IOC$V_PHY must be bit 0!!
macro IOC$V_PHY = 0,0,1,0 %;            !  physical device specified
macro IOC$V_TYPE = 0,1,1,0 %;           !  device type name specified
macro IOC$V_CLASS = 0,2,1,0 %;          !  allocation class present
macro IOC$V_LOCAL = 0,3,1,0 %;          !  search local devices only
macro IOC$V_EXISTS = 0,4,1,0 %;         !  device exists
macro IOC$V_2P = 0,5,1,0 %;             !  device is on UCB secondary path
macro IOC$V_ANY = 0,6,1,0 %;            !  find any matching device
macro IOC$V_MOUNT = 0,7,1,0 %;          !  find only mountable devices
macro IOC$V_ALT = 0,8,1,0 %;            !  alternate UCB found
macro IOC$V_NO_TRANS = 0,9,1,0 %;       !  caller translated logical name
macro IOC$V_ALLOC = 0,10,1,0 %;         !  allocate mountable device
macro IOC$V_DTN = 0,11,1,0 %;           !  search for DDRed device
!  Function codes used by system routine ioc$node_function
literal IOC$K_ENABLE_INTR = 1;
literal IOC$K_DISABLE_INTR = 2;
literal IOC$K_ENABLE_SG = 3;
literal IOC$K_DISABLE_SG = 4;
literal IOC$K_ENABLE_PAR = 5;
literal IOC$K_DISABLE_PAR = 6;
literal IOC$K_ENABLE_BLKM = 7;
literal IOC$K_DISABLE_BLKM = 8;
literal IOC$K_ISSUE_EOI = 9;
!  Function codes used by system routine ioc$node_data
literal IOC$K_TURBO_SLOT_DENSE_PA = 1;
literal IOC$K_TURBO_SLOT_SPARSE_PA = 2;
literal IOC$K_FBUS_INT_LOC = 3;
literal IOC$K_EISA_IRQ = 4;
literal IOC$K_EISA_DMA_CHAN = 5;
literal IOC$K_EISA_CONFIG_BLOCK = 6;
literal IOC$K_EISA_MEM_CONFIG = 7;
literal IOC$K_LBUS_DEV_BLK_PTR = 8;
literal IOC$K_EISA_IO_PORT = 9;
literal IOC$K_SCSI_CLK_PERIOD = 10;
!  The following codes are actually used by the I/O space 
!  mapping routine IOC$MAP_IO.  But, add them anyway to the 
!  IOC$NODE_DATA list as unique codes.
!  Add synonyms for the IOC$MAP_IO function codes until the
!  old ones are legislated out of existence.
literal IOC$K_IO_CSR_BYTE_ACCESS = 11;
literal IOC$K_BUS_IO_BYTE_GRAN = 11;
literal IOC$K_IO_CSR_LONG_ACCESS = 12;
literal IOC$K_IO_MEM_BYTE_ACCESS = 13;
literal IOC$K_BUS_MEM_BYTE_GRAN = 13;
literal IOC$K_IO_MEM_LONG_ACCESS = 14;
literal IOC$K_BUS_MEM_DENSE = 14;
!  The following code is used by drivers to request the address
!  swizzle factor of an I/O bus.
literal IOC$K_IO_ADDRESS_SWIZZLE = 15;
literal IOC$K_DIRECT_DMA_BASE = 16;
literal IOC$K_DIRECT_DMA_SIZE = 17;
!  add an ioc$node_data code for the ISA bus user parameter.
!  also an ioc$node_data code for the dipl problem.
!  these are added here so that it is easy to see what the next
!  number to use will be.  (could be added to node_data list above)
literal IOC$K_ISA_USER_PARAM = 18;
literal IOC$K_DEVICE_IPL = 19;
 
!*** MODULE $IOGENDEF ***
! 
!  Function codes and modifiers for the $LOAD_DRIVER server.
! 
literal IOGEN$_LOAD = 1;                !  LOAD a device driver
literal IOGEN$_RELOAD = 2;              !  RELOAD a device driver
literal IOGEN$_CONNECT = 3;             !  CONNECT unit(s)
literal IOGEN$_INIT_CTRL = 4;           !  call driver ctrl init routine
literal IOGEN$_INIT_UNIT = 5;           !  call driver unit init routine
literal IOGEN$_DELIVER = 6;             !  perform unit delivery
literal IOGEN$K_MINFCODE = 1;
literal IOGEN$K_MAXFCODE = 6;
literal IOGEN$M_NOWAIT = %X'10000';
literal IOGEN$M_LDDB = %X'20000';
literal IOGEN$M_SYSDEVICE = %X'40000';
literal IOGEN$M_NOINIT = %X'80000';
literal IOGEN$S_IOGENDEF = 4;           !  Old size name, synonym for  IOGEN$S_IOGEN
literal IOGEN$S_IOGEN = 4;
macro IOGEN$W_FCODE = 0,0,16,0 %;       !  function codes in range 1-65535
macro IOGEN$W_MODIFIERS = 2,0,16,0 %;   !  16 modifier bits reserved
macro IOGEN$V_NOWAIT = 0,16,1,0 %;      !  asynchronous operation requested
macro IOGEN$V_LDDB = 0,17,1,0 %;        !  preparsed LDDB provided
macro IOGEN$V_SYSDEVICE = 0,18,1,0 %;   !  this is the sysdevice device
macro IOGEN$V_NOINIT = 0,19,1,0 %;      !  don't call init bros (for ordering)
literal IOGEN$_ADAPTER = 16;            !  ADAPTER TR number
literal IOGEN$_NOADAPTER = 17;          !  connect to the NULL adapter
literal IOGEN$_CSR = 18;                !  magic number for CSR accesses
literal IOGEN$_VECTOR = 19;             !  byte offset into SCB/ADP vector table
literal IOGEN$_MAXUNITS = 20;           !  maximum # of units for this controller
literal IOGEN$_SYSID = 21;              !  SCS system id of controller
literal IOGEN$_SYSLOA_CRB = 22;         !  address of preexisting CRB
literal IOGEN$_UNIT = 23;               !  unit number for this device
literal IOGEN$_NUMUNITS = 24;           !  number of consecutive units to create
literal IOGEN$_DELIVER_DATA = 25;       !  scratch space for unit delivery rtn
literal IOGEN$_DDB = 26;                !  return the address of the DDB
literal IOGEN$_CRB = 27;                !  return the address of the CRB
literal IOGEN$_IDB = 28;                !  return the address of the IDB
literal IOGEN$_UCB = 29;                !  return the address of the UCB
literal IOGEN$_SB = 30;                 !  return the address of the SB
literal IOGEN$_NODE = 31;               !  set CRB$L_NODE field
literal IOGEN$K_MINITEM = 16;
literal IOGEN$K_MAXITEM = 31;
literal IOGEN$M_AC_LOG = %X'1';
literal IOGEN$M_AC_SCA = %X'2';
literal IOGEN$M_AC_LAN = %X'4';
literal IOGEN$M_AC_LOG_ALL = %X'8';
literal IOGEN$S_AUTOCFG = 4;
macro IOGEN$L_AUTOCFG_FLAGS = 0,0,32,0 %; !  flags for IOGEN$AUTOCONFIGURE
macro IOGEN$V_AC_LOG = 0,0,1,0 %;       !  log progress of configuration
macro IOGEN$V_AC_SCA = 0,1,1,0 %;       !  configure all SCA ports and friends
macro IOGEN$V_AC_LAN = 0,2,1,0 %;       !  configure all LAN devices
macro IOGEN$V_AC_LOG_ALL = 0,3,1,0 %;   !  log even the "noisy" messages
literal IOGEN$S_ABMDEF = 8;             !  Old size name, synonym for  IOGEN$S_ABM
literal IOGEN$S_ABM = 8;
macro IOGEN$IL_ABM_ADP = 0,0,32,1 %;    !  ADP type code
macro IOGEN$PS_ABM_BSR = 4,0,32,1 %;    !  pointer to BSR's PD
 
!*** MODULE $IOHANDLEDEF ***
! +
!  This data structure contains mapping information for I/O devices.
! -
literal IOHANDLE$S_IOHANDLE = 64;
macro IOHANDLE$PS_FLINK = 0,0,32,1 %;
macro IOHANDLE$PS_BLINK = 4,0,32,1 %;
macro IOHANDLE$W_SIZE = 8,0,16,0 %;
macro IOHANDLE$B_TYPE = 10,0,8,0 %;
macro IOHANDLE$B_SUBTYPE = 11,0,8,0 %;
macro IOHANDLE$L_BOFF = 12,0,32,0 %;
macro IOHANDLE$Q_BASE_VA = 16,0,0,1 %;
literal IOHANDLE$S_BASE_VA = 8;
macro IOHANDLE$L_BASE_VA = 16,0,32,1 %;
macro IOHANDLE$L_BASE_VA_L = 16,0,32,1 %;
macro IOHANDLE$L_BASE_VA_H = 20,0,32,1 %;
macro IOHANDLE$Q_PLATFORM_PA = 24,0,0,1 %;
literal IOHANDLE$S_PLATFORM_PA = 8;
macro IOHANDLE$Q_BUS_PA = 32,0,0,1 %;
literal IOHANDLE$S_BUS_PA = 8;
macro IOHANDLE$L_BUS_REGION_SIZE = 40,0,32,0 %;
macro IOHANDLE$L_MAPPED_REGION_SIZE = 44,0,32,0 %;
macro IOHANDLE$L_ATTRIBUTES = 48,0,32,0 %;
literal IOHANDLE$K_IOHANDLELEN = 64;
 
!*** MODULE $iovecdef ***
literal iovec$c_length = 56;            !  Length Of IOVEC
literal iovec$k_length = 56;            !  Length Of IOVEC
literal iovec$S_iovec = 56;
macro iovec$pq_flink = 0,0,0,1 %;
literal iovec$s_flink = 8;              !  IOVEC forward link 
macro iovec$pl_flink_l = 0,0,32,1 %;
macro iovec$il_flink_h = 4,0,32,0 %;
macro iovec$pq_blink = 8,0,0,1 %;
literal iovec$s_blink = 8;              !  IOVEC backward link 
macro iovec$pl_blink_l = 8,0,32,1 %;
macro iovec$il_blink_h = 12,0,32,0 %;
macro iovec$pq_btadp_flink = 16,0,0,1 %;
literal iovec$s_btadp_flink = 8;        !  BTADP forward link 
macro iovec$pl_btadp_flink_l = 16,0,32,1 %;
macro iovec$il_btadp_flink_h = 20,0,32,0 %;
macro iovec$pq_btadp_blink = 24,0,0,1 %;
literal iovec$s_btadp_blink = 8;        !  BTADP backward link 
macro iovec$pl_btadp_blink_l = 24,0,32,1 %;
macro iovec$il_btadp_blink_h = 28,0,32,0 %;
macro iovec$pq_bdtab = 32,0,0,1 %;
literal iovec$s_bdtab = 8;              !  BDTAB address
macro iovec$pl_bdtab_l = 32,0,32,1 %;   !  Pointer to BDTAB, a type defined in BOOLIB, not LIB
macro iovec$il_bdtab_h = 36,0,32,0 %;
macro iovec$pq_image_base = 40,0,0,1 %;
literal iovec$s_image_base = 8;         !  Adr of image base
macro iovec$pl_image_base_l = 40,0,32,1 %;
macro iovec$il_image_base_h = 44,0,32,0 %;
macro iovec$pq_btadp = 48,0,0,1 %;
literal iovec$s_btadp = 8;              !  Current BTADP adr
macro iovec$pl_btadp_l = 48,0,32,1 %;
macro iovec$il_btadp_h = 52,0,32,0 %;
 
!*** MODULE $IPLDEF ***
! +
!  TEMPORARY PROCESSOR PRIORITY LEVEL DEFINITIONS
! -
!  
literal IPL$_HWCLK = 22;                ! HARDWARE CLOCK LEVEL 
literal IPL$_PERFMON = 15;              ! PERFORMANCE MONITORING SYNCH LEVEL 
literal IPL$_IOPOST = 4;                ! I/O POST PROCESSING LEVEL 
literal IPL$_MAILBOX = 11;              ! WRITE MAILBOX INTERLOCK LEVEL 
literal IPL$_POWER = 31;                ! POWERFAIL INTERLOCK LEVEL 
literal IPL$_QUEUEAST = 6;              ! QUEUE AST LEVEL 
literal IPL$_RESCHED = 3;               ! SCHEDULER LEVEL 
literal IPL$_SYNCH = 8;                 ! SYSTEM DATA BASE SYNCHRONIZATION LEVEL 
literal IPL$_TIMER = 8;                 ! TIME QUEUE PROCESSING LEVEL 
literal IPL$_TIMERFORK = 7;             ! TIMER FORK INTERRUPT LEVEL
literal IPL$_ASTDEL = 2;                ! AST DELIVERY INTERRUPT 
literal IPL$_SCS = 8;                   ! SCS SYNCHRONIZATION IPL 
literal IPL$_IPINTR = 22;               ! IP INTERRUPT SYNCHRONIZATION IPL 
literal IPL$_SCHED = 8;                 ! SCHEDULING DATABASE IPL
literal IPL$_MMG = 8;                   ! MMG DATABASE IPL
literal IPL$_IO_MISC = 8;               ! IO_MISC IPL
literal IPL$_FILSYS = 8;                ! FILSYS DATABASE IPL
literal IPL$_TX_SYNCH = 8;              ! TX_SYNCH IPL
literal IPL$_LCKMGR = 8;                ! LOCK MANAGER IPL
literal IPL$_IOLOCK8 = 8;               ! IOLOCK8 DATABASE IPL
literal IPL$_IOLOCK9 = 9;               ! IOLOCK9 DATABASE IPL
literal IPL$_IOLOCK10 = 10;             ! IOLOCK10 DATABASE IPL
literal IPL$_IOLOCK11 = 11;             ! IOLOCK11 DATABASE IPL
literal IPL$_POOL = 11;                 ! POOL DATABASE IPL
literal IPL$_INVALIDATE = 21;           ! INVALIDATE DATABASE IPL
literal IPL$_VIRTCONS = 22;             ! VIRTCONS DATABASE IPL
literal IPL$_EMB = 31;                  ! EMB DATABASE IPL
literal IPL$_MCHECK = 31;               ! MACHINE CHECK IPL
literal IPL$_MEGA = 31;                 ! IPL FOR KITCHEN SINK LOCK
literal IPL$_FORKABLE_IPL = 3904;       ! Mask of IPL's which are forkable
 
!*** MODULE $IRPDEF ***
! +
!  IRP - I/O REQUEST PACKET
! 
!  I/O REQUEST PACKETS ARE CONSTRUCTED BY THE QUEUE I/O REQUEST SYSTEM
!  SERVICE. THE CONTENT OF AN I/O REQUEST PACKET DESCRIBES A FUNCTION TO
!  BE PERFORMED ON A DEVICE UNIT.
! 
!  NOTE: SEVERAL FIELDS OF THE IRP MUST BE AT THE SAME OFFSETS AS THEIR
!  CORRESPONDING FIELDS IN THE IRPE (SEE NEXT PAGE).
! 
! -
literal IRP$M_WLE_REUSE = %X'1';
literal IRP$M_WLE_SUPWL = %X'2';
literal IRP$M_BUFIO = %X'1';
literal IRP$M_FUNC = %X'2';
literal IRP$M_PAGIO = %X'4';
literal IRP$M_COMPLX = %X'8';
literal IRP$M_VIRTUAL = %X'10';
literal IRP$M_CHAINED = %X'20';
literal IRP$M_SWAPIO = %X'40';
literal IRP$M_DIAGBUF = %X'80';
literal IRP$M_PHYSIO = %X'100';
literal IRP$M_TERMIO = %X'200';
literal IRP$M_MBXIO = %X'400';
literal IRP$M_EXTEND = %X'800';
literal IRP$M_FILACP = %X'1000';
literal IRP$M_MVIRP = %X'2000';
literal IRP$M_SRVIO = %X'4000';
literal IRP$M_CCB_LOOKED_UP = %X'8000';
literal IRP$M_CACHE_PAGIO = %X'10000';
literal IRP$M_FILL_BIT = %X'20000';
literal IRP$M_BUFOBJ = %X'40000';
literal IRP$M_TRUSTED = %X'80000';
literal IRP$M_SRV_ABORT = %X'2000000';
literal IRP$M_START_PAST_HWM = %X'1';
literal IRP$M_END_PAST_HWM = %X'2';
literal IRP$M_ERASE = %X'4';
literal IRP$M_PART_HWM = %X'8';
literal IRP$M_LCKIO = %X'10';
literal IRP$M_SHDIO = %X'20';
literal IRP$M_CACHEIO = %X'40';
literal IRP$M_WLE = %X'80';
literal IRP$M_CACHE_SAFE = %X'100';
literal IRP$M_NOCACHE = %X'200';
literal IRP$M_ABORTIO = %X'400';
literal IRP$M_FORCEMV = %X'800';
literal IRP$M_FCODE = %X'3F';
literal IRP$K_CDRP = 152;               !  Offset to the CDRP within the IRP 
literal IRP$C_CDRP = 152;               !  Offset to the CDRP within the IRP
literal IRP$M_PIO_ERROR = %X'1';
literal IRP$M_PIO_FANOUT = %X'2';
literal IRP$M_PIO_NOQUE = %X'4';
literal IRP$M_PIO_CANCEL = %X'8';
literal IRP$M_PIO_CTHRDOK = %X'10';
literal IRP$M_PIO_PHASEII = %X'20';
literal IRP$M_SHD_EXPEL_REMOVED = %X'1';
literal IRP$M_CLN_READY = %X'1';
literal IRP$M_CLN_DONE = %X'2';
literal IRP$M_CPY_FINI = %X'4';
literal IRP$K_BT_LEN = 240;
literal IRP$C_BT_LEN = 240;
literal IRP$K_CD_LEN = 248;
literal IRP$C_CD_LEN = 248;
literal IRP$S_IRP = 376;
macro IRP$L_IOQFL = 0,0,32,1 %;         ! I/O QUEUE FORWARD LINK 
macro IRP$L_IOQBL = 4,0,32,1 %;         ! I/O QUEUE BACKWARD LINK 
macro IRP$W_SIZE = 8,0,16,0 %;          ! SIZE OF IRP IN BYTES 
macro IRP$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE FOR IRP 
macro IRP$B_RMOD = 11,0,8,0 %;          ! ACCESS MODE OF REQUEST 
macro IRP$V_MODE = 11,0,2,0 %;
literal IRP$S_MODE = 2;                 !  MODE SUBFIELD 
macro IRP$L_PID = 12,0,32,0 %;          ! PROCESS ID OF REQUESTING PROCESS 
macro IRP$Q_PARAM_0 = 16,0,0,1 %;
literal IRP$S_PARAM_0 = 8;              ! For PAGEFAULT and IOCIOPOST
macro IRP$L_AST = 16,0,32,1 %;          ! ADDRESS OF AST ROUTINE 
macro IRP$L_SHD_IOFL = 16,0,32,1 %;     ! LINK TO CLONE IRPS
macro IRP$L_ASTPRM = 20,0,32,1 %;       ! AST PARAMETER 
macro IRP$L_SHAD = 20,0,32,1 %;         ! SHAD ADDRESS
macro IRP$L_HRB = 20,0,32,1 %;          ! HRB ADDRESS
macro IRP$Q_PARAM_1 = 24,0,0,1 %;
literal IRP$S_PARAM_1 = 8;              ! For PAGEFAULT and IOCIOPOST
macro IRP$L_OBOFF = 24,0,32,0 %;        ! Original BOFF, for segmented DIO
macro IRP$L_ABOFF = 28,0,32,0 %;        !  Accumulated BOFF
macro IRP$L_WIND = 32,0,32,1 %;         ! ADDRESS OF WINDOW BLOCK 
macro IRP$L_MIRP = 32,0,32,1 %;         ! LINK TO MASTER IRP
macro IRP$L_KAST = 32,0,32,1 %;         ! PIGGY BACK KERNEL AST ADDRESS
macro IRP$L_UCB = 36,0,32,1 %;          ! ADDRESS OF DEVICE UCB 
macro IRP$B_EFN = 40,0,8,0 %;           ! EVENT FLAG NUMBER AND EVENT GROUP 
macro IRP$B_PRI = 41,0,8,0 %;           ! BASE PRIORITY OF REQUESTING PROCESS 
macro IRP$B_CLN_INDX = 42,0,8,0 %;      ! Shadow Clone membership index
macro IRP$B_WLG_FLAGS = 43,0,8,0 %;     !  These flags are shared by DUDRIVER and SHDRIVER and MSCP.
macro IRP$V_WLE_REUSE = 43,0,1,0 %;     !  Reuse writelog entry
macro IRP$V_WLE_SUPWL = 43,1,1,0 %;     !  Supplementary writelog
! 
! 
macro IRP$L_IOSB = 44,0,32,1 %;         ! ADDRESS OF I/O STATUS DOUBLE LONGWORD 
macro IRP$L_CLN_WLE = 44,0,32,0 %;      !  write log entry
macro IRP$L_CHAN = 48,0,32,0 %;         !  Process I/O channel
macro IRP$L_EXTEND = 52,0,32,1 %;       !  ADDRESS OF IRPE 
macro IRP$Q_STATUS = 56,0,0,0 %;
literal IRP$S_STATUS = 8;               ! Big time REQUEST STATUS
macro IRP$L_STS = 56,0,32,0 %;          !  Status
macro IRP$V_BUFIO = 56,0,1,0 %;         !  BUFFERED I/O FLAG ;THESE BITS 
macro IRP$V_FUNC = 56,1,1,0 %;          !  1=>READ FUNCTION ;MUST BE ADJACENT 
macro IRP$V_PAGIO = 56,2,1,0 %;         !  PAGING I/O FLAG ;AND IN ORDER 
macro IRP$V_COMPLX = 56,3,1,0 %;        !  COMPLEX BUFFERED I/O 
macro IRP$V_VIRTUAL = 56,4,1,0 %;       !  VIRTUAL I/O FUNCTION 
macro IRP$V_CHAINED = 56,5,1,0 %;       !  CHAINED BUFFERED I/O OPERATION 
macro IRP$V_SWAPIO = 56,6,1,0 %;        !  SWAP I/O OPERATION 
macro IRP$V_DIAGBUF = 56,7,1,0 %;       !  DIAGNOSTIC BUFFER ALLOCATED 
macro IRP$V_PHYSIO = 56,8,1,0 %;        !  PHYSICAL I/O 
macro IRP$V_TERMIO = 56,9,1,0 %;        !  TERMINAL I/O (FOR SELECTING PRIORITY INC) 
macro IRP$V_MBXIO = 56,10,1,0 %;        !  MAILBOX BUFFERED READ 
macro IRP$V_EXTEND = 56,11,1,0 %;       !  AN IRPE IS LINKED TO THIS IRP 
macro IRP$V_FILACP = 56,12,1,0 %;       !  FILE ACP I/O (BOTH DIOCNT AND BIOCNT) 
macro IRP$V_MVIRP = 56,13,1,0 %;        !  MOUNT VERIFICATION IRP 
macro IRP$V_SRVIO = 56,14,1,0 %;        !  SERVER TYPE I/O (TRIGGER MOUNTVER ON ERROR BUT DON'T STALL)
macro IRP$V_CCB_LOOKED_UP = 56,15,1,0 %; !  Set if IRP$PS_CCB contains valid CCB address
macro IRP$V_CACHE_PAGIO = 56,16,1,0 %;  !  Cached page i/o
macro IRP$V_FILL_BIT = 56,17,1,0 %;     !  Unused
macro IRP$V_BUFOBJ = 56,18,1,0 %;       !  Set if buffer object I/O
macro IRP$V_TRUSTED = 56,19,1,0 %;      !  Set if trusted Component I/O
macro IRP$V_FILL_BITS = 56,20,5,0 %;    !  Keep variant consistant with mainline
macro IRP$V_SRV_ABORT = 56,25,1,0 %;    !  Server I/O should be aborted
macro IRP$L_STS2 = 60,0,32,0 %;         !  EXTENSION OF STATUS WORD
macro IRP$V_START_PAST_HWM = 60,0,1,0 %; !  I/O STARTS PAST HIGHWATER MARK
macro IRP$V_END_PAST_HWM = 60,1,1,0 %;  !  I/O ENDS PAST HIGHWATER MARK
macro IRP$V_ERASE = 60,2,1,0 %;         !  ERASE I/O FUNCTION
macro IRP$V_PART_HWM = 60,3,1,0 %;      !  PARTIAL HIGHWATER MARK UPDATE
macro IRP$V_LCKIO = 60,4,1,0 %;         !  Locked I/O request (DECnet)
macro IRP$V_SHDIO = 60,5,1,0 %;         !  This is a shadowing IRP
macro IRP$V_CACHEIO = 60,6,1,0 %;       !  uses VBN cache buffers
macro IRP$V_WLE = 60,7,1,0 %;           !  I/O USES A WRITE LOG ENTRY
macro IRP$V_CACHE_SAFE = 60,8,1,0 %;    !  this indicates that
!  the request has been
!  checked as regards
!  caching.
macro IRP$V_NOCACHE = 60,9,1,0 %;       !  IO$M_NOVCACHE was
!  set in QIO function 
macro IRP$V_ABORTIO = 60,10,1,0 %;      !  set in EXE$ABORTIO
macro IRP$V_FORCEMV = 60,11,1,0 %;      !  set to indicate forced MV in progress
macro IRP$L_SVAPTE = 64,0,32,1 %;       ! SYSTEM VIRTUAL ADDRESS OF FIRST PTE 
macro IRP$L_BCNT = 68,0,32,0 %;         ! BYTE COUNT OF TRANSFER 
macro IRP$L_BOFF = 72,0,32,0 %;         !  Byte offset 
macro IRP$PS_KPB = 76,0,32,1 %;         !  Pointer to KP block
macro IRP$L_IOST1 = 80,0,32,0 %;        ! FIRST I/O STATUS LONGWORD (FOR I/O POST) 
macro IRP$L_MEDIA = 80,0,32,0 %;        ! MEDIA ADDRESS 
macro IRP$L_IOST2 = 84,0,32,0 %;        ! SECOND I/O STATUS LONGWORD 
macro IRP$L_TT_TERM = 84,0,32,0 %;      ! ADDRESS OF READ TERMINATORS MASK 
macro IRP$B_CARCON = 84,0,8,0 %;        ! CARRIAGE CONTROL 
macro IRP$W_SHD_COPY_TYPE = 84,0,16,0 %; ! TYPE OF COPY TO PERFORM
macro IRP$W_SHD_VUN = 84,0,16,0 %;      !  VIRTUAL UNIT NUMBER
macro IRP$W_SHD_DEV_TYPE = 86,0,16,0 %; ! DEVICE TYPE
macro IRP$W_SHD_MSCP_DISK_MODIFIER = 86,0,16,0 %; ! FIELD FOR MODIFIERS
macro IRP$Q_NT_PRVMSK = 88,0,0,0 %;
literal IRP$S_NT_PRVMSK = 8;            !  PRIVILEGE MASK FOR DECNET 
macro IRP$Q_STATION = 88,0,0,0 %;
literal IRP$S_STATION = 8;              !  STATION FIELD FOR DECNET DRIVERS
macro IRP$Q_TT_STATE = 88,0,0,0 %;
literal IRP$S_TT_STATE = 8;             !  TERMINAL STATE DEFINITIONS 
macro IRP$L_ABCNT = 88,0,32,0 %;        !  ACCUMULATED BYTES TRANSFERED 
macro IRP$L_OBCNT = 92,0,32,0 %;        !  ORIGINAL TRANSFER BYTE COUNT 
macro IRP$L_FUNC = 96,0,32,0 %;         !  I/O function code
macro IRP$V_FCODE = 96,0,6,0 %;
literal IRP$S_FCODE = 6;                !  FUNCTION CODE FIELD 
macro IRP$V_FMOD = 96,6,10,0 %;
literal IRP$S_FMOD = 10;                !  FUNCTION MODIFIER FIELD 
macro IRP$L_SEGVBN = 100,0,32,0 %;      !  VIRTUAL BLOCK NUMBER OF CURRENT SEGMENT 
macro IRP$L_DIAGBUF = 104,0,32,1 %;     !  DIAGNOSTIC BUFFER ADDRESS 
macro IRP$L_SCB_BUF = 104,0,32,1 %;     !  SCB BUFFER ADDRESS
macro IRP$W_TT_PRMPT = 104,0,16,0 %;    !  PROMPT SIZE 
macro IRP$L_SEQNUM = 108,0,32,0 %;      !  SEQUENCE NUMBER 
macro IRP$L_DCD_SRC_UCB = 108,0,32,0 %; !  DISK COPY DATA SOURCE UCB
macro IRP$L_ARB = 112,0,32,1 %;         !  ACCESS RIGHTS BLOCK ADDRESS 
macro IRP$L_KEYDESC = 116,0,32,1 %;     !  ADDRESS OF ENCRYPTION DESCRIPTOR
macro IRP$L_WLE_PTR = 116,0,32,0 %;     !  Clone Write log index
macro IRP$B_CPY_MODE = 116,0,8,0 %;     !  Copy mode identifier
macro IRP$L_QIO_P1 = 120,0,32,0 %;      !  QIO argument #1
macro IRP$L_QIO_P2 = 124,0,32,0 %;      !  QIO argument #2
macro IRP$L_QIO_P3 = 128,0,32,0 %;      !  QIO argument #3
macro IRP$L_QIO_P4 = 132,0,32,0 %;      !  QIO argument #4
macro IRP$L_QIO_P5 = 136,0,32,0 %;      !  QIO argument #5
macro IRP$L_QIO_P6 = 140,0,32,0 %;      !  QIO argument #6
macro IRP$PS_FDT_CONTEXT = 144,0,32,1 %; !  Contains addr of the 
!   FDT Context structure
macro IRP$PS_CCB = 148,0,32,1 %;        !  Pointer to CCB for this I/O
!  ALL FIELDS INSERTED ABOVE THIS POINT IN THE IRP 		
!  MUST BE CHANGED IN THE CDRPDEF.SDL FILE.			
!  Standard IRP must contain space for Class Driver CDRP fields.
macro IRP$L_FQFL = 152,0,32,1 %;        !  Fork Queue FLINK 
macro IRP$L_FQBL = 156,0,32,1 %;        !  Fork Queue Blink 
macro IRP$W_CDRPSIZE = 160,0,16,0 %;    !  Size field for positive section only 
macro IRP$B_CD_TYPE = 162,0,8,0 %;      !  Type, always of interest 
macro IRP$B_FLCK = 163,0,8,0 %;         !  Fork Lock number
macro IRP$L_FPC = 164,0,32,1 %;         !  Fork PC 
macro IRP$Q_FR3 = 168,0,0,1 %;
literal IRP$S_FR3 = 8;                  !  Fork R3 
macro IRP$Q_FR4 = 176,0,0,1 %;
literal IRP$S_FR4 = 8;                  !  Fork R4 
macro IRP$L_SAVD_RTN = 184,0,32,1 %;    !  Saved return address from level 1 JSB 
macro IRP$L_MSG_BUF = 188,0,32,1 %;     !  Address of allocated MSCP buffer 
macro IRP$L_RSPID = 192,0,32,0 %;       !  Allocated Request ID 
macro IRP$L_CDT = 196,0,32,1 %;         !  Address of Connection Descriptor Table 
macro IRP$Q_RES_WAIT_STATE = 200,0,0,0 %;
literal IRP$S_RES_WAIT_STATE = 8;       !  SCS Resource Wait State
macro IRP$L_SCS_STALL_DATA = 208,0,32,0 %; !  Data cell used by SCS to save data over a stall
macro IRP$L_RWCPTR = 212,0,32,1 %;      !  RWAITCNT pointer 
macro IRP$L_BD_ADDR = 216,0,32,1 %;     !  Address of Buffer Descriptor that maps I/O buffer
macro IRP$L_LBUFH_AD = 220,0,32,1 %;    !  Local BUFfer Handle ADress 
! 	Extensions to the CDRP within the IRP
!  Host-Based Shadowing Extension
macro IRP$B_SHD_PIO_CNT = 224,0,8,0 %;  !  Tot num phys IRPs assoc.
macro IRP$B_SHD_PIO_ACT = 225,0,8,0 %;  !  Tot num phys IRPs active.
!  Note Keep SHD_PIO_FLAGS, SHD_PIO_ERRCNT,  contiguous.
macro IRP$B_SHD_PIO_FLAGS = 226,0,8,0 %; !  Master Flags Byte
macro IRP$V_PIO_ERROR = 226,0,1,0 %;    !  Errant clone in Chain
macro IRP$V_PIO_FANOUT = 226,1,1,0 %;   !  Chained Clones.
macro IRP$V_PIO_NOQUE = 226,2,1,0 %;    !  Don't queue to server
macro IRP$V_PIO_CANCEL = 226,3,1,0 %;   !  This master cancelled
macro IRP$V_PIO_CTHRDOK = 226,4,1,0 %;  !  Copy thread validated.
macro IRP$V_PIO_PHASEII = 226,5,1,0 %;  !  Bi-phasic Phase II write
macro IRP$B_SHD_PIO_ERRCNT = 227,0,8,0 %; !  Number of errors in chain
macro IRP$B_SHD_PIO_ERRINDEX = 228,0,8,0 %; !  Index of erring device
macro IRP$B_SHD_PIO_ERRSEV = 229,0,8,0 %; !  Relative error severity
macro IRP$Q_SHD_LOCK_FR0 = 232,0,0,0 %;
literal IRP$S_SHD_LOCK_FR0 = 8;         !  Lock fork R0
macro IRP$Q_SHD_LOCK_FR1 = 240,0,0,0 %;
literal IRP$S_SHD_LOCK_FR1 = 8;         !  Lock fork R1
macro IRP$Q_SHD_LOCK_FR2 = 248,0,0,0 %;
literal IRP$S_SHD_LOCK_FR2 = 8;         !  Lock fork R2
macro IRP$Q_SHD_LOCK_FR4 = 256,0,0,0 %;
literal IRP$S_SHD_LOCK_FR4 = 8;         !  Lock fork R4
macro IRP$Q_SHD_LOCK_FR5 = 264,0,0,0 %;
literal IRP$S_SHD_LOCK_FR5 = 8;         !  Lock fork R5
macro IRP$L_SHD_LOCK_FPC = 272,0,32,1 %; !  Lock fork PC
macro IRP$L_SHD_PIO_ERROR = 276,0,32,0 %; !  BCNT and Error Status (SS$_)
macro IRP$L_SHD_PIO_LNK = 280,0,32,1 %; !  Link to clone IRP(s)
macro IRP$L_SHDSPC = 284,0,32,0 %;      !  Shadowing return PC
macro IRP$L_SHD_CONTROL_IRP = 288,0,32,0 %; !  address of control IRP
macro IRP$L_SHD_TEMP = 292,0,32,1 %;    !  used for temporary storage
macro IRP$Q_SHD_SAVED_R1 = 296,0,0,0 %;
literal IRP$S_SHD_SAVED_R1 = 8;         !  second save area for WLG
macro IRP$Q_SHD_SAVED_R2 = 304,0,0,0 %;
literal IRP$S_SHD_SAVED_R2 = 8;
macro IRP$Q_SHD_SAVED_R4 = 312,0,0,0 %;
literal IRP$S_SHD_SAVED_R4 = 8;
macro IRP$L_SHD_SVD_CNT_IRP = 320,0,32,0 %; !  save SHD_CONTROL_IRP
macro IRP$L_SHD_SAVED_STATUS = 324,0,32,0 %; !  save area for status
macro IRP$L_SHD_WLG_MODE_FPC = 328,0,32,0 %; !  saved PC for WLG_MODE fork
macro IRP$L_SHD_PERLKID = 332,0,32,0 %; !  holds sublock id for
!  per-disk 
macro IRP$L_SHD_EXPEL_TIMER = 336,0,32,0 %; !  Clone error timer
macro IRP$L_SHD_EXPEL_FLAGS = 340,0,32,0 %; !  Clone IRP flags
macro IRP$V_SHD_EXPEL_REMOVED = 340,0,1,0 %; !  Device is expelled
macro IRP$L_SHD_EXPEL_MASK = 344,0,32,0 %; !  indicate units to be expelled in MIRP
macro IRP$Q_SHD_RESERV_Q8 = 348,0,0,0 %;
literal IRP$S_SHD_RESERV_Q8 = 8;        !  will be needed for 64-bit saves
macro IRP$Q_SHD_RESERV_Q9 = 356,0,0,0 %;
literal IRP$S_SHD_RESERV_Q9 = 8;        !  will be needed for 64-bit saves
macro IRP$Q_SHD_RESERV_Q10 = 364,0,0,0 %;
literal IRP$S_SHD_RESERV_Q10 = 8;       !  will be needed for 64-bit saves
macro IRP$B_SHD_FLAGS = 372,0,8,0 %;    !  Shadow Clone Flags
macro IRP$V_CLN_READY = 372,0,1,0 %;    !  Clone is ready for I/O
macro IRP$V_CLN_DONE = 372,1,1,0 %;     !  Clone has done I/O
macro IRP$V_CPY_FINI = 372,2,1,0 %;     !  Copy is complete.
! 
! 
! 	Block Transfer Extension
macro IRP$L_LBOFF = 224,0,32,0 %;       !  Local Byte OFFset 
macro IRP$L_RBUFH_AD = 228,0,32,1 %;    !  Remote BUFfer Handle ADress 
macro IRP$L_CDRPFL = 228,0,32,1 %;
macro IRP$L_RBOFF = 232,0,32,0 %;       !  Remote Byte OFFset 
macro IRP$L_XCT_LEN = 236,0,32,0 %;     !  Transfer length in bytes 
! 	Class Driver Extension
macro IRP$T_LBUFHNDL = 224,0,0,0 %;
literal IRP$S_LBUFHNDL = 12;            !  Local buffer handle 
macro IRP$L_UBARSRCE = 236,0,32,0 %;    !  Scratch Cell used for DU/TUDRIVER convenience
macro IRP$L_DUTUFLAGS = 240,0,32,0 %;   !  Class driver status flags:
macro IRP$W_DUTUCNTR = 244,0,16,0 %;    !  General purpose counter
macro IRP$W_ENDMSGSIZ = 246,0,16,0 %;   !  Size of most recent MSCP end message
!  File system extensions
macro IRP$L_ERASE_VBN = 224,0,32,0 %;   !  VBN to start HWM erase
literal IRP$K_LENGTH = 376;             !  LENGTH OF STANDARD IRP 
literal IRP$C_LENGTH = 376;             !  LENGTH OF STANDARD IRP 
literal IRP$S_IRPDEF = 376;             !  OLD IRP SIZE FOR COMPATIBILITY
 
!*** MODULE $IRPEDEF ***
! +
!  IRPE - I/O REQUEST PACKET EXTENSION
! 
!  I/O REQUEST PACKET EXTENSIONS ARE USED TO HOLD ADDITIONAL INFORMATION
!  ABOUT I/O REQUESTS FOR DEVICES THAT REQUIRE MORE CONTEXT THAN CAN FIT INTO
!  THE STANDARD IRP.  IRPE'S ARE BUILT AND LINKED ONTO IRP'S BY DEVICE
!  DRIVER FDT ROUTINES.  ANY FIELDS THAT ARE NOT DEFINED IN THIS STRUCTURE
!  MAY BE USED TO HOLD DRIVER DEPENDENT DATA.
! 
!  THE CURRENTLY DEFINED FIELDS IN THE IRPE WERE POSITIONED SO THAT THE
!  PACKET COULD BE USED AS A FORK BLOCK.  THIS SHOULD BE KEPT IN MIND IF
!  AND WHEN NEW FIELDS ARE DEFINED.
! 
!  THE FIELDS DEFINED HERE MUST BE AT THE SAME OFFSETS AS THEIR CORRESPONDING
!  FIELDS IN THE IRP (SEE PREVIOUS PAGE).
! 
! -
literal IRPE$M_EXTEND = %X'800';
literal IRPE$S_IRPE = 88;
macro IRPE$W_SIZE = 8,0,16,0 %;         !  SIZE OF IRPE IN BYTES 
macro IRPE$B_TYPE = 10,0,8,0 %;         !  STRUCTURE TYPE FOR IRPE 
macro IRPE$L_EXTEND = 52,0,32,1 %;      !  ADDRESS OF NEXT IRPE 
macro IRPE$Q_STATUS = 56,0,0,0 %;
literal IRPE$S_STATUS = 8;
macro IRPE$L_STS = 56,0,32,0 %;         !  Status bits
macro IRPE$V_EXTEND = 56,11,1,0 %;      !  ANOTHER IRPE IS LINKED TO THIS ONE 
macro IRPE$L_STS2 = 60,0,32,0 %;
macro IRPE$L_SVAPTE1 = 64,0,32,1 %;     !  SYSTEM VIR. ADDR. OF PTE FOR REGION 1 
macro IRPE$L_BCNT1 = 68,0,32,0 %;       !  BYTE COUNT FOR REGION 1 
macro IRPE$L_BOFF1 = 72,0,32,0 %;       !  BYTE OFFSET (region 1)
macro IRPE$L_SVAPTE2 = 76,0,32,1 %;     !  SYSTEM VIR. ADDR. OF PTE FOR REGION 2 
macro IRPE$L_BCNT2 = 80,0,32,0 %;       !  BYTE COUNT FOR REGION 2 
macro IRPE$L_BOFF2 = 84,0,32,0 %;       !  Byte offset (region 2)
literal IRPE$K_LENGTH = 88;             !  LENGTH OF IRPE 
literal IRPE$C_LENGTH = 88;             !  LENGTH OF IRPE 
literal IRPE$S_IRPEDEF = 88;            !  Old size name, synonym for  IRPE$S_IRPE
 
!*** MODULE $ISACFGDEF ***
! 
!  This file describes the layout of the configuration data blocks
!  for ISA devices.  There are two data structures described in this
!  file.  The first is the ISA_CFG_DATA block that VMS uses to store 
!  ISA configuration information for ISA devices.  There is an
!  ISA_CFG_DATA block for each ISA device in the system.  The second data
!  structure described in this file is the console supplied ISA config
!  information, stored in nvram.  The console ISA configuration
!  information actually consists of a header and a number of entries. 
!  The console ISA config header is defined as ISACFG_HDR and the console
!  ISA config entries are defined as ISACFG_ENTRY.
! 
!  During ISA configuration, data is read from the console ISA config
!  information and stored in ISA_CFG_DATA blocks.  Then, data is also
!  read from the user-editable file SYS$MANAGER:ISA_CONFIG.DAT and stored
!  in ISA_CFG_DATA blocks.  Then the drivers are loaded for the ISA
!  devices.
! 
!  The ISA_CFG_DATA block contains ISA Bus resource information
!  for each device, sych as IRQ, DMA channels, IO Ports, Memory addr, 
!  slot number.
! 
literal ISACFG$S_ISA_CFG_DATA = 208;
macro ISACFG$PS_FLINK = 0,0,32,1 %;
macro ISACFG$PS_BLINK = 4,0,32,1 %;
macro ISACFG$W_SIZE = 8,0,16,0 %;
macro ISACFG$B_TYPE = 10,0,8,0 %;
macro ISACFG$B_SUBTYPE = 11,0,8,0 %;
macro ISACFG$L_IRQ = 12,0,32,0 %;
macro ISACFG$L_MEMBUFF0 = 16,0,32,0 %;
macro ISACFG$L_MEMLEN0 = 20,0,32,0 %;
macro ISACFG$L_MEMBUFF1 = 24,0,32,0 %;
macro ISACFG$L_MEMLEN1 = 28,0,32,0 %;
macro ISACFG$L_MEMBUFF2 = 32,0,32,0 %;
macro ISACFG$L_MEMLEN2 = 36,0,32,0 %;
macro ISACFG$L_MEMBUFF3 = 40,0,32,0 %;
macro ISACFG$L_MEMLEN3 = 44,0,32,0 %;
macro ISACFG$L_DMACHAN0 = 48,0,32,0 %;
macro ISACFG$L_DMACHAN1 = 52,0,32,0 %;
macro ISACFG$L_DMACHAN2 = 56,0,32,0 %;
macro ISACFG$L_DMACHAN3 = 60,0,32,0 %;
macro ISACFG$W_IO_PORT0 = 64,0,16,0 %;
macro ISACFG$W_IO_LEN0 = 66,0,16,0 %;
macro ISACFG$W_IO_PORT1 = 68,0,16,0 %;
macro ISACFG$W_IO_LEN1 = 70,0,16,0 %;
macro ISACFG$W_IO_PORT2 = 72,0,16,0 %;
macro ISACFG$W_IO_LEN2 = 74,0,16,0 %;
macro ISACFG$W_IO_PORT3 = 76,0,16,0 %;
macro ISACFG$W_IO_LEN3 = 78,0,16,0 %;
macro ISACFG$W_IO_PORT4 = 80,0,16,0 %;
macro ISACFG$W_IO_LEN4 = 82,0,16,0 %;
macro ISACFG$W_IO_PORT5 = 84,0,16,0 %;
macro ISACFG$W_IO_LEN5 = 86,0,16,0 %;
macro ISACFG$W_IO_PORT6 = 88,0,16,0 %;
macro ISACFG$W_IO_LEN6 = 90,0,16,0 %;
macro ISACFG$W_IO_PORT7 = 92,0,16,0 %;
macro ISACFG$W_IO_LEN7 = 94,0,16,0 %;
macro ISACFG$W_IO_PORT8 = 96,0,16,0 %;
macro ISACFG$W_IO_LEN8 = 98,0,16,0 %;
macro ISACFG$B_DEV_NAME = 100,0,32,0 %;
literal ISACFG$S_DEV_NAME = 4;
macro ISACFG$B_DRIVER = 104,0,0,0 %;
literal ISACFG$S_DRIVER = 16;
macro ISACFG$L_FLAGS = 120,0,32,0 %;
macro ISACFG$L_NODE = 124,0,32,0 %;
macro ISACFG$B_USER_PARAM = 128,0,0,0 %;
literal ISACFG$S_USER_PARAM = 72;
macro ISACFG$L_RSV1 = 200,0,32,0 %;
macro ISACFG$L_RSV2 = 204,0,32,0 %;
literal ISA$K_ISA_CFG_DATA_LENGTH = 208;
literal ISACFG$K_PORT = 0;
literal ISACFG$K_MEM = 1;
literal ISACFG$K_IRQ = 2;
literal ISACFG$K_NAME = 3;
literal ISACFG$K_NODE = 4;
literal ISACFG$K_DRIVER = 5;
literal ISACFG$K_DMA = 6;
literal ISACFG$K_USER_PARAM = 7;
literal ISACFG_HDR$S_ISACFG_HDR = 32;
macro ISACFG_HDR$B_IDENTIFIER = 0,0,0,0 %;
literal ISACFG_HDR$S_IDENTIFIER = 8;
macro ISACFG_HDR$W_MAJOR_VERSION = 8,0,16,0 %;
macro ISACFG_HDR$W_MINOR_VERSION = 10,0,16,0 %;
macro ISACFG_HDR$l_fill1 = 12,0,32,0 %;
macro ISACFG_HDR$L_NUM_ENTRIES = 16,0,32,0 %;
macro ISACFG_HDR$L_FIRST_ENTRY_OFFSET = 20,0,32,0 %;
macro ISACFG_HDR$L_TABLE_CHECKSUM = 24,0,32,0 %;
macro ISACFG_HDR$L_HEADER_CHECKSUM = 28,0,32,0 %;
literal ISACFG_HDR$K_LENGTH = 32;
literal ISACFG_ENTRY$S_ISACFG_ENTRY = 200;
macro ISACFG_ENTRY$L_ENTRY_TYPE = 0,0,32,0 %;
macro ISACFG_ENTRY$L_RESERVED0 = 4,0,32,0 %;
macro ISACFG_ENTRY$L_ISA_SLOT = 8,0,32,0 %;
macro ISACFG_ENTRY$L_RESERVED1 = 12,0,32,0 %;
macro ISACFG_ENTRY$L_DEV_NUM = 16,0,32,0 %;
macro ISACFG_ENTRY$L_RESERVED2 = 20,0,32,0 %;
macro ISACFG_ENTRY$L_TOTAL_DEVICES = 24,0,32,0 %;
macro ISACFG_ENTRY$L_RESERVED3 = 28,0,32,0 %;
macro ISACFG_ENTRY$Q_IO_BASE_ADDR0 = 32,0,0,0 %;
literal ISACFG_ENTRY$S_IO_BASE_ADDR0 = 8;
macro ISACFG_ENTRY$Q_IO_BASE_ADDR1 = 40,0,0,0 %;
literal ISACFG_ENTRY$S_IO_BASE_ADDR1 = 8;
macro ISACFG_ENTRY$Q_IO_BASE_ADDR2 = 48,0,0,0 %;
literal ISACFG_ENTRY$S_IO_BASE_ADDR2 = 8;
macro ISACFG_ENTRY$Q_IO_BASE_ADDR3 = 56,0,0,0 %;
literal ISACFG_ENTRY$S_IO_BASE_ADDR3 = 8;
macro ISACFG_ENTRY$Q_IO_BASE_ADDR4 = 64,0,0,0 %;
literal ISACFG_ENTRY$S_IO_BASE_ADDR4 = 8;
macro ISACFG_ENTRY$Q_IO_BASE_ADDR5 = 72,0,0,0 %;
literal ISACFG_ENTRY$S_IO_BASE_ADDR5 = 8;
macro ISACFG_ENTRY$Q_MEM0_BASE_ADDR = 80,0,0,0 %;
literal ISACFG_ENTRY$S_MEM0_BASE_ADDR = 8;
macro ISACFG_ENTRY$Q_MEM0_LENGTH = 88,0,0,0 %;
literal ISACFG_ENTRY$S_MEM0_LENGTH = 8;
macro ISACFG_ENTRY$Q_MEM1_BASE_ADDR = 96,0,0,0 %;
literal ISACFG_ENTRY$S_MEM1_BASE_ADDR = 8;
macro ISACFG_ENTRY$Q_MEM1_LENGTH = 104,0,0,0 %;
literal ISACFG_ENTRY$S_MEM1_LENGTH = 8;
macro ISACFG_ENTRY$Q_MEM2_BASE_ADDR = 112,0,0,0 %;
literal ISACFG_ENTRY$S_MEM2_BASE_ADDR = 8;
macro ISACFG_ENTRY$Q_MEM2_LENGTH = 120,0,0,0 %;
literal ISACFG_ENTRY$S_MEM2_LENGTH = 8;
macro ISACFG_ENTRY$Q_ROM_BASE_ADDR = 128,0,0,0 %;
literal ISACFG_ENTRY$S_ROM_BASE_ADDR = 8;
macro ISACFG_ENTRY$Q_ROM_LENGTH = 136,0,0,0 %;
literal ISACFG_ENTRY$S_ROM_LENGTH = 8;
macro ISACFG_ENTRY$L_DEVICE_ENABLE = 144,0,32,0 %;
macro ISACFG_ENTRY$L_RESERVED4 = 148,0,32,0 %;
macro ISACFG_ENTRY$L_DMA0 = 152,0,32,0 %;
macro ISACFG_ENTRY$L_DMA1 = 156,0,32,0 %;
macro ISACFG_ENTRY$L_DMA2 = 160,0,32,0 %;
macro ISACFG_ENTRY$L_DMA3 = 164,0,32,0 %;
macro ISACFG_ENTRY$L_IRQ0_ASSIGNMENT = 168,0,32,0 %;
macro ISACFG_ENTRY$L_IRQ1_ASSIGNMENT = 172,0,32,0 %;
macro ISACFG_ENTRY$L_IRQ2_ASSIGNMENT = 176,0,32,0 %;
macro ISACFG_ENTRY$L_IRQ3_ASSIGNMENT = 180,0,32,0 %;
macro ISACFG_ENTRY$B_HANDLE = 184,0,0,0 %;
literal ISACFG_ENTRY$S_HANDLE = 16;
literal ISACFG_ENTRY$K_LENGTH = 200;
literal ISACFG$K_NOT_USED = 0;
literal ISACFG$K_SINGLE_DEV = 1;
literal ISACFG$K_MULTI_EMBED_DEV = 2;
literal ISACFG$K_MULTI_DEV = 3;
literal ISACFG$K_ISACFG_HDR_SIZE = 32;
 
!*** MODULE $ISDDEF ***
! +
!  IMAGE SECTION DESCRIPTOR DEFINITIONS
! -
literal ISD$K_LENDZRO = 12;             ! LENGTH OF DEMAND ZERO ISD 
literal ISD$C_LENDZRO = 12;             ! LENGTH OF DEMAND ZERO ISD 
literal ISD$M_GBL = %X'1';
literal ISD$M_CRF = %X'2';
literal ISD$M_DZRO = %X'4';
literal ISD$M_WRT = %X'8';
literal ISD$M_MATCHCTL = %X'70';
literal ISD$M_LASTCLU = %X'80';
literal ISD$M_INITALCODE = %X'100';
literal ISD$M_BASED = %X'200';
literal ISD$M_FIXUPVEC = %X'400';
literal ISD$M_RESIDENT = %X'800';
literal ISD$M_VECTOR = %X'20000';
literal ISD$M_PROTECT = %X'40000';
literal ISD$S_FLAGSIZ = 24;             !  NUMBER OF FLAG BITS, ISD TYPE EXCLUDED 
literal ISD$K_LENPRIV = 16;             ! LENGTH OF PRIVATE ISD 
literal ISD$C_LENPRIV = 16;             ! LENGTH OF PRIVATE ISD 
literal ISD$K_LENGLBL = 36;             ! LENGTH OF OLD GLOBAL ISD 
literal ISD$C_LENGLBL = 36;             ! LENGTH OF OLD GLOBAL ISD 
literal ISD$K_MAXLENGLBL = 64;          ! MAX LENGTH OF NEW GLOBAL ISD 
literal ISD$C_MAXLENGLBL = 64;          ! MAX LENGTH OF NEW GLOBAL ISD 
! +
literal ISD$K_MATALL = 0;               ! MATCH ALWAYS, USE GLOBAL SECTION 
literal ISD$K_MATEQU = 1;               ! MATCH IF ISD$L_IDENT EQU GBL ID 
literal ISD$K_MATLEQ = 2;               ! MATCH IF ISD$L_IDENT LEQ GBL ID 
literal ISD$K_MATNEV = 3;               ! MATCH NEVER, USE PRIVATE COPY 
! +
literal ISD$K_NORMAL = 0;               ! NORMAL PROGRAM IMAGE SECTION 
! NO SPECIAL ACTION REQUIRED
literal ISD$K_SHRFXD = 1;               ! SHAREABLE FIXED SECTION 
literal ISD$K_PRVFXD = 2;               ! PRIVATE FIXED SECTION 
literal ISD$K_SHRPIC = 3;               ! SHAREABLE PIC SECTION 
literal ISD$K_PRVPIC = 4;               ! PRIVATE PIC SECTION 
literal ISD$K_USRSTACK = 253;           ! USER STACK SECTION 
literal ISD$S_ISDDEF = 64;              !  Old size name - synonym
literal ISD$S_ISD = 64;
macro ISD$W_SIZE = 0,0,16,0 %;          ! SIZE IN BYTES OF THIS ISD 
macro ISD$W_PAGCNT = 2,0,16,0 %;        ! ! OF PAGES DESCRIBED BY THIS ISD 
macro ISD$L_VPNPFC = 4,0,32,0 %;        ! VPN & PFC VIELDS 
macro ISD$V_VPN = 4,0,21,0 %;
literal ISD$S_VPN = 21;                 !  STARTING VIRTUAL PAGE NUMBER 
macro ISD$V_P1 = 4,21,1,0 %;            !  P1 SPACE 
macro ISD$V_SYSTEM = 4,22,1,0 %;        !  SYSTEM SPACE 
macro ISD$V_PFC = 4,24,8,0 %;
literal ISD$S_PFC = 8;                  !  PAGE FAULT CLUSTER 
macro ISD$V_VPG = 4,0,23,0 %;
literal ISD$S_VPG = 23;                 !  VIRTUAL PAGE INCLUDING P1 & S 
macro ISD$B_PFC = 7,0,8,0 %;            ! PAGE FAULT CLUSTER 
macro ISD$L_FLAGS = 8,0,32,0 %;         ! FLAGS AND ISD TYPE 
macro ISD$V_GBL = 8,0,1,0 %;            !  GLOBAL 
macro ISD$V_CRF = 8,1,1,0 %;            !  COPY ON REFERENCE 
macro ISD$V_DZRO = 8,2,1,0 %;           !  DEMAND ZERO PAGE 
macro ISD$V_WRT = 8,3,1,0 %;            !  WRITABLE 
macro ISD$V_MATCHCTL = 8,4,3,0 %;
literal ISD$S_MATCHCTL = 3;             !  IDENT MATCH CONTROL FIELD 
macro ISD$V_LASTCLU = 8,7,1,0 %;        !  ISD IS PART OF LAST P0 SPACE CLUSTER 
macro ISD$V_INITALCODE = 8,8,1,0 %;     !  ISD IS PART OF INITIALIZATION CODE
macro ISD$V_BASED = 8,9,1,0 %;          !  ISECT IS BASED 
macro ISD$V_FIXUPVEC = 8,10,1,0 %;      !  ISECT IS FIXUP SECTION 
macro ISD$V_RESIDENT = 8,11,1,0 %;      !  ISECT IS MEMORY-RESIDENT
macro ISD$V_VECTOR = 8,17,1,0 %;        !  VECTOR CONTAINED IN IMAGE SECTION 
macro ISD$V_PROTECT = 8,18,1,0 %;       !  IMAGE SECTION IS PROTECTED 
macro ISD$B_TYPE = 11,0,8,0 %;          ! ISD TYPE CODE 
macro ISD$L_VBN = 12,0,32,0 %;          ! BASE VIRTUAL BLOCK NUMBER 
macro ISD$L_IDENT = 16,0,32,0 %;        ! IDENT FOR GLOBAL SECTION 
macro ISD$T_GBLNAM = 20,0,0,0 %;
literal ISD$S_GBLNAM = 44;              ! GLOBAL NAME COUNTED STRING 
!  MATCH CONTROL VIELD VALUES
! -
! BASE OF ZERO , INCR 1 
!  ISD TYPE FIELD DEFINITIONS
! -
 
!*** MODULE ISDOLDDEF ***
! +
!  OLD IMAGE SECTION DESCRIPTOR DEFINITIONS
! -
literal ISD_K_LENDZRO = 12;             ! LENGTH OF DEMAND ZERO ISD 
literal ISD_C_LENDZRO = 12;             ! LENGTH OF DEMAND ZERO ISD 
literal ISD_M_GBL = %X'1';
literal ISD_M_CRF = %X'2';
literal ISD_M_DZRO = %X'4';
literal ISD_M_WRT = %X'8';
literal ISD_M_MATCHCTL = %X'70';
literal ISD_M_LASTCLU = %X'80';
literal ISD_M_COPYALWAY = %X'100';
literal ISD_M_BASED = %X'200';
literal ISD_M_FIXUPVEC = %X'400';
literal ISD_M_VECTOR = %X'20000';
literal ISD_M_PROTECT = %X'40000';
literal ISD_S_FLAGSIZ = 24;             !  NUMBER OF FLAG BITS, ISD TYPE EXCLUDED 
literal ISD_K_LENPRIV = 16;             ! LENGTH OF PRIVATE ISD 
literal ISD_C_LENPRIV = 16;             ! LENGTH OF PRIVATE ISD 
literal ISD_K_LENGLBL = 36;             ! LENGTH OF GLOBAL ISD 
literal ISD_C_LENGLBL = 36;             ! LENGTH OF GLOBAL ISD 
! +
literal ISD_K_MATALL = 0;               ! MATCH ALWAYS, USE GLOBAL SECTION 
literal ISD_K_MATEQU = 1;               ! MATCH IF ISD_L_IDENT EQU GBL ID 
literal ISD_K_MATLEQ = 2;               ! MATCH IF ISD_L_IDENT LEQ GBL ID 
literal ISD_K_MATNEV = 3;               ! MATCH NEVER, USE PRIVATE COPY 
! +
literal ISD_K_NORMAL = 0;               ! NORMAL PROGRAM IMAGE SECTION 
! NO SPECIAL ACTION REQUIRED
literal ISD_K_SHRFXD = 1;               ! SHAREABLE FIXED SECTION 
literal ISD_K_PRVFXD = 2;               ! PRIVATE FIXED SECTION 
literal ISD_K_SHRPIC = 3;               ! SHAREABLE PIC SECTION 
literal ISD_K_PRVPIC = 4;               ! PRIVATE PIC SECTION 
literal ISD_K_USRSTACK = 253;           ! USER STACK SECTION 
literal ISD_S_ISDOLDDEF = 36;           !  Old size name - synonym
literal ISD_S_ISDOLD = 36;
macro ISD_W_SIZE = 0,0,16,0 %;          ! SIZE IN BYTES OF THIS ISD 
macro ISD_W_PAGCNT = 2,0,16,0 %;        ! ! OF PAGES DESCRIBED BY THIS ISD 
macro ISD_R_VPNPFC_OVERLAY = 4,0,32,0 %;
macro ISD_L_VPNPFC = 4,0,32,0 %;        ! VPN & PFC VIELDS 
macro ISD_R_VPNPFC_BITS0 = 4,0,32,0 %;
macro ISD_V_VPN = 4,0,21,0 %;
literal ISD_S_VPN = 21;                 !  STARTING VIRTUAL PAGE NUMBER 
macro ISD_V_P1 = 4,21,1,0 %;            !  P1 SPACE 
macro ISD_V_SYSTEM = 4,22,1,0 %;        !  SYSTEM SPACE 
macro ISD_V_PFC = 4,24,8,0 %;
literal ISD_S_PFC = 8;                  !  PAGE FAULT CLUSTER 
macro ISD_R_VPNPFC_BITS1 = 4,0,24,0 %;
macro ISD_V_VPG = 4,0,23,0 %;
literal ISD_S_VPG = 23;                 !  VIRTUAL PAGE INCLUDING P1 & S 
macro ISD_R_VPNPFC_FIELDS2 = 4,0,32,0 %;
macro ISD_B_PFC = 7,0,8,0 %;            ! PAGE FAULT CLUSTER 
macro ISD_R_FLAGS_OVERLAY = 8,0,32,0 %;
macro ISD_L_FLAGS = 8,0,32,0 %;         ! FLAGS AND ISD TYPE 
macro ISD_R_FLAGS_BITS = 8,0,24,0 %;
macro ISD_V_GBL = 8,0,1,0 %;            !  GLOBAL 
macro ISD_V_CRF = 8,1,1,0 %;            !  COPY ON REFERENCE 
macro ISD_V_DZRO = 8,2,1,0 %;           !  DEMAND ZERO PAGE 
macro ISD_V_WRT = 8,3,1,0 %;            !  WRITABLE 
macro ISD_V_MATCHCTL = 8,4,3,0 %;
literal ISD_S_MATCHCTL = 3;             !  IDENT MATCH CONTROL FIELD 
macro ISD_V_LASTCLU = 8,7,1,0 %;        !  ISD IS PART OF LAST P0 SPACE CLUSTER 
macro ISD_V_COPYALWAY = 8,8,1,0 %;      !  COPY ALWAYS FROM USER IMAGE 
macro ISD_V_BASED = 8,9,1,0 %;          !  ISECT IS BASED 
macro ISD_V_FIXUPVEC = 8,10,1,0 %;      !  ISECT IS FIXUP SECTION 
macro ISD_V_VECTOR = 8,17,1,0 %;        !  VECTOR CONTAINED IN IMAGE SECTION 
macro ISD_V_PROTECT = 8,18,1,0 %;       !  IMAGE SECTION IS PROTECTED 
macro ISD_R_FLAGS_FIELDS = 8,0,32,0 %;
macro ISD_B_TYPE = 11,0,8,0 %;          ! ISD TYPE CODE 
macro ISD_L_VBN = 12,0,32,0 %;          ! BASE VIRTUAL BLOCK NUMBER 
macro ISD_L_IDENT = 16,0,32,0 %;        ! IDENT FOR GLOBAL SECTION 
macro ISD_T_GBLNAM = 20,0,0,0 %;
literal ISD_S_GBLNAM = 16;              ! GLOBAL NAME COUNTED STRING 
!  MATCH CONTROL VIELD VALUES
! -
! BASE OF ZERO , INCR 1 
!  ISD TYPE FIELD DEFINITIONS
! -
 
!*** MODULE $ITEMLDEF IDENT X-1 ***
! 
! 	Structure used by DECnet-VAX internally used itemlists
! 
literal ITEML$K_LENGTH = 12;            !  Length of ItemList Header
literal ITEML$S_ITEM_ALLOC = 12;
macro ITEML$L_ACTLEN = 0,0,32,0 %;      !  Actual length of itemlist
macro ITEML$A_POINTER = 4,0,32,0 %;     !  Pointer to the start of the list
macro ITEML$W_SIZE = 8,0,16,0 %;        !  Allocated size of the structure
macro ITEML$B_TYPE = 10,0,8,0 %;        !  DYN$C_NET
macro ITEML$B_SUBTYPE = 11,0,8,0 %;     !  DYN$C_NET_ITEM
macro ITEML$T_ITEMLIST = 12,0,0,0 %;    !  Start of the itemlist
 
!*** MODULE $JIBDEF ***
! +
!  Job Information Block - Structure containing common context for a set
!                           of related processes.
! 
!  Note: The Executive module SYSCREPRC assumes that the job mount list head
!  preceeds the username field in the JIB.
! 
!  JIB Synchronization:
! 
! 	The JIB is a shared structure across a subprocess tree.  Synchronization
! 	is complex because many of the quota and limit fields have no functional
! 	relationship whatsoever.  So a number of methods of synchronization are
! 	used, based on exactly what is being manipulated.  Below is a list of
! 	fields with their methods of synch.
! 	
! 	Field		   Synchronization Method
! 	-----		   ----------------------
! 	BYTCNT/BYTLM	   Interlocked arithmetic sequences. Should never be manually
! 			      manipulated: use the EXE$DEBIT/CREDIT routines in the
! 			      EXSUBROUT module.
! 
! 	TQCNT/TQLM	   Interlocked arithmetic sequences. When waiting because of a
! 			      lack of TQCNT, the JIB FLAGS bit TQCNT_WAITERS must be set;
! 			      the JIB address is the EFWM and the process should be
! 			      placed in the MWAIT queue.  When TQCNT is incremented,
! 			      the TQCNT_WAITERS bit must be interrogated.  If it is set,
! 			      then waiting process should be made executable via a call
! 			      to EXE$JIB_AVAIL or similar inline code.
! 
! 	PGFLCNT/PGFLQUOTA  MMG spinlock.
! 
! 	MTLFL/MTLBL	   SCH$IOLOCK/UNLOCK.
! 
! 	FILCNT/FILLM,	   Interlocked arithmetic sequences. These fields are never increased
! 	  ENQCNT/ENQLM,       or decreased by more than 1 at a time, and are never waited on.
!         PRCCNT/PRCLM
! -
literal JIB$C_DETACHED = 0;
literal JIB$C_NETWORK = 1;
literal JIB$C_BATCH = 2;
literal JIB$C_LOCAL = 3;
literal JIB$C_DIALUP = 4;
literal JIB$C_REMOTE = 5;
literal JIB$M_BYTCNT_WAITERS = %X'1';
literal JIB$M_TQCNT_WAITERS = %X'2';
literal JIB$K_LENGTH = 140;             !  Structure length 
literal JIB$C_LENGTH = 140;             !  Structure length 
literal JIB$S_JIBDEF = 140;             !  Old JIB sized for compatability
literal JIB$S_JIB = 140;
macro JIB$L_MTLFL = 0,0,32,1 %;         !  Job mounted volume list head forward link
macro JIB$L_MTLBL = 4,0,32,1 %;         !  Job mounted volume list head back link
macro JIB$W_SIZE = 8,0,16,0 %;          !  Size of structure in bytes 
macro JIB$B_TYPE = 10,0,8,0 %;          !  Structure type code 
macro JIB$B_DAYTYPES = 11,0,8,0 %;      !  Set bits 0-6 flag non-prime days of week 
macro JIB$T_USERNAME = 12,0,0,0 %;
literal JIB$S_USERNAME = 12;            !  User name for easy access 
macro JIB$T_ACCOUNT = 24,0,0,0 %;
literal JIB$S_ACCOUNT = 8;              !  Account name for resident access 
macro JIB$L_BYTCNT = 32,0,32,0 %;       !  Buffered I/O byte count avail 
macro JIB$L_BYTLM = 36,0,32,0 %;        !  Original value for Byte count 
macro JIB$L_PBYTCNT = 40,0,32,0 %;      !  Paged pool byte count remaining 
macro JIB$L_PBYTLIM = 44,0,32,0 %;      !  Paged pool byte limit 
macro JIB$L_FILCNT = 48,0,32,0 %;       !  Open File count remaining 
macro JIB$L_FILLM = 52,0,32,0 %;        !  Open file limit 
macro JIB$L_TQCNT = 56,0,32,0 %;        !  Timer queue entry count remaining 
macro JIB$L_TQLM = 60,0,32,0 %;         !  Timer queue entry limit 
macro JIB$L_PGFLQUOTA = 64,0,32,0 %;    !  Paging file quota 
macro JIB$L_PGFLCNT = 68,0,32,0 %;      !  Paging file limit 
macro JIB$L_CPULIM = 72,0,32,0 %;       !  CPU time quota remaining 
macro JIB$L_PRCCNT = 76,0,32,0 %;       !  Count of subprocesses existing 
macro JIB$L_PRCLIM = 80,0,32,0 %;       !  Limit on number of subprocesses 
macro JIB$W_SHRFCNT = 84,0,16,0 %;      !  Shared file block count remaining
macro JIB$W_SHRFLIM = 86,0,16,0 %;      !  Shared file count limit 
macro JIB$L_ENQCNT = 88,0,32,0 %;       !  Enqueue count avail 
macro JIB$L_ENQLM = 92,0,32,0 %;        !  Enqueue limit 
macro JIB$W_MAXJOBS = 96,0,16,0 %;      !  Max jobs limit on user
macro JIB$W_MAXDETACH = 98,0,16,0 %;    !  Max detached processes for user
macro JIB$L_MPID = 100,0,32,0 %;        !  PID of master process 
macro JIB$L_JLNAMFL = 104,0,32,1 %;     !  Forward link for job-wide logical names 
macro JIB$L_JLNAMBL = 108,0,32,1 %;     !  Back link for job-wide logical names 
macro JIB$L_PDAYHOURS = 112,0,32,0 %;   !  Field describing primary day access 
macro JIB$L_ODAYHOURS = 116,0,32,0 %;   !  Field describing off day access 
macro JIB$L_JOBTYPE = 120,0,32,0 %;     !  Job origin type
macro JIB$L_FLAGS = 124,0,32,0 %;       !  FLAG bits
macro JIB$V_BYTCNT_WAITERS = 124,0,1,0 %; !  Processes are waiting on BYTCNT
macro JIB$V_TQCNT_WAITERS = 124,1,1,0 %; !  Processes are waiting on TQCNT
macro JIB$L_ORG_BYTLM = 128,0,32,0 %;   !  Original BYTLM
macro JIB$L_ORG_PBYTLM = 132,0,32,0 %;  !  Original PBYTLM
macro JIB$L_JTQUOTA = 136,0,32,0 %;     !  Job table quota
 
!*** MODULE $KA0202DEF ***
literal KA0202$K_MAX_CPU_MODULES = 2;
literal KA0202$K_MAX_MEMORY_MODULES = 4;
literal KA0202$M_IOCSR_ENET_HLT_ENA = %X'1';
literal KA0202$M_IOCSR_ENET_HLT = %X'2';
literal KA0202$M_IOCSR_FBUS_HLT_ENA = %X'10';
literal KA0202$M_IOCSR_FBUS_HLT = %X'20';
literal KA0202$M_IOCSR_FBUS_INT_STS = %X'40';
literal KA0202$M_IOCSR_FBUS_RESET_L = %X'80';
literal KA0202$M_IOCSR_FBUS_PWR_FAIL = %X'100';
literal KA0202$M_IOCSR_MBX_ENA_L = %X'200';
literal KA0202$M_IOCSR_FBUS_DMA_ENA_L = %X'400';
literal KA0202$M_IOCSR_LBUS_DMA_ENA_L = %X'800';
literal KA0202$M_IOCSR_CA_WWP_0 = %X'1000';
literal KA0202$M_IOCSR_CA_WWP_2 = %X'2000';
literal KA0202$M_IOCSR_DATA_WWP_L = %X'4000';
literal KA0202$M_IOCSR_FMBPR_RESET_L = %X'8000';
literal KA0202$M_IOCSR_LMBPR_RESET_L = %X'10000';
literal KA0202$M_IOCSR_LBUS_RESET_L = %X'20000';
literal KA0202$M_IOCSR_FBUS_COMP_PE_L = %X'40000';
literal KA0202$M_IOCSR_LBUS_COMP_PE_L = %X'80000';
literal KA0202$M_IOCSR_FBUS_RESET_H = %X'8000000000';
literal KA0202$M_IOCSR_MBX_ENA_H = %X'20000000000';
literal KA0202$M_IOCSR_FBUS_DMA_ENA_H = %X'40000000000';
literal KA0202$M_IOCSR_LBUS_DMA_ENA_H = %X'80000000000';
literal KA0202$M_IOCSR_CA_WWP_1 = %X'100000000000';
literal KA0202$M_IOCSR_CA_WWP_3 = %X'200000000000';
literal KA0202$M_IOCSR_DATA_WWP_H = %X'400000000000';
literal KA0202$M_IOCSR_FMBPR_RESET_H = %X'800000000000';
literal KA0202$M_IOCSR_LMBPR_RESET_H = %X'1000000000000';
literal KA0202$M_IOCSR_LBUS_RESET_H = %X'2000000000000';
literal KA0202$M_IOCSR_FBUS_COMP_PE_H = %X'4000000000000';
literal KA0202$M_IOCSR_LBUS_COMP_PE_H = %X'8000000000000';
literal KA0202$M_CERR1_UNCORR_RDERR_L = %X'1';
literal KA0202$M_CERR1_NOACK_L = %X'2';
literal KA0202$M_CERR1_CMDADR_PE_L = %X'4';
literal KA0202$M_CERR1_MCMDADR_PE_L = %X'8';
literal KA0202$M_CERR1_WRTDAT_PE_L = %X'10';
literal KA0202$M_CERR1_MWRTDAT_PE_L = %X'20';
literal KA0202$M_CERR1_RDDAT_PE_L = %X'40';
literal KA0202$M_CERR1_MRDDAT_PE_L = %X'80';
literal KA0202$M_CERR1_CMDADR_PE_LW0 = %X'100';
literal KA0202$M_CERR1_CMDADR_PE_LW2 = %X'200';
literal KA0202$M_CERR1_DAT_PE_LW0 = %X'400';
literal KA0202$M_CERR1_DAT_PE_LW2 = %X'800';
literal KA0202$M_CERR1_DAT_PE_LW4 = %X'1000';
literal KA0202$M_CERR1_DAT_PE_LW6 = %X'2000';
literal KA0202$M_CERR1_CSTALL_SYNC_H = %X'4000';
literal KA0202$M_CERR1_FBUS_MBX_ERR = %X'8000';
literal KA0202$M_CERR1_CMD_WRTDAT_PE_L = %X'10000';
literal KA0202$M_CERR1_BUS_SYNC = %X'20000';
literal KA0202$M_CERR1_UNCORR_RDERR_H = %X'100000000';
literal KA0202$M_CERR1_NOACK_H = %X'200000000';
literal KA0202$M_CERR1_CMDADR_PE_H = %X'400000000';
literal KA0202$M_CERR1_MCMDADR_PE_H = %X'800000000';
literal KA0202$M_CERR1_WRTDAT_PE_H = %X'1000000000';
literal KA0202$M_CERR1_MWRTDAT_PE_H = %X'2000000000';
literal KA0202$M_CERR1_RDDAT_PE_H = %X'4000000000';
literal KA0202$M_CERR1_MRDDAT_PE_H = %X'8000000000';
literal KA0202$M_CERR1_CMDADR_PE_LW1 = %X'10000000000';
literal KA0202$M_CERR1_CMDADR_PE_LW3 = %X'20000000000';
literal KA0202$M_CERR1_DAT_PE_LW1 = %X'40000000000';
literal KA0202$M_CERR1_DAT_PE_LW3 = %X'80000000000';
literal KA0202$M_CERR1_DAT_PE_LW5 = %X'100000000000';
literal KA0202$M_CERR1_DAT_PE_LW7 = %X'200000000000';
literal KA0202$M_CERR1_CSTALL_SYNC_L = %X'400000000000';
literal KA0202$M_CERR1_LBUS_MBX = %X'800000000000';
literal KA0202$M_CERR1_CMD_WRTDAT_PE_H = %X'1000000000000';
literal KA0202$M_CERR2_L = %X'FFFFFFFF';
literal KA0202$M_CERR2_H = %X'FFFFFFFF00000000';
literal KA0202$M_LMBPR_MBX_ADDR = %X'FFFFFFC0';
literal KA0202$M_FMBPR_MBX_ADDR = %X'FFFFFFC0';
literal KA0202$M_FIVECT_VECTOR = %X'FFFF';
literal KA0202$M_FHVECT_VECTOR = %X'FFFF';
literal KA0202$M_FERR1_DATA_PE_L = %X'1';
literal KA0202$M_FERR1_ADDR_PE_L = %X'2';
literal KA0202$M_FERR1_fill1 = %X'FFFFFFFC';
literal KA0202$M_FERR1_DATA_PE_H = %X'100000000';
literal KA0202$M_FERR1_ADDR_PE_H = %X'200000000';
literal KA0202$M_LINT_SCSI0_IRQ = %X'1';
literal KA0202$M_LINT_SCSI1_IRQ = %X'2';
literal KA0202$M_LINT_SCSI2_IRQ = %X'4';
literal KA0202$M_LINT_SCSI3_IRQ = %X'8';
literal KA0202$M_LINT_SCSI4_IRQ = %X'10';
literal KA0202$M_LINT_SLU_IRQ = %X'100000000';
literal KA0202$M_LINT_NI0_IRQ = %X'200000000';
literal KA0202$M_LINT_NI1_IRQ = %X'400000000';
literal KA0202$M_LINT_SBUS_IRQ = %X'800000000';
literal KA0202$M_LERR1_EVEN = %X'1';
literal KA0202$M_LERR1_ODD = %X'100000000';
literal KA0202$K_LENGTH = 57344;
literal KA0202$S_KA0202DEF = 57344;     !  Old size name, synonym for KA0202$S_KA0202
literal KA0202$S_KA0202 = 57344;
macro KA0202$Q_IOCSR = 0,0,0,1 %;
literal KA0202$S_IOCSR = 8;
macro KA0202$V_IOCSR_ENET_HLT_ENA = 0,0,1,0 %; !  Ethernet halt enable
macro KA0202$V_IOCSR_ENET_HLT = 0,1,1,0 %; !  Ethernet halt
macro KA0202$V_IOCSR_FBUS_HLT_ENA = 0,4,1,0 %; !  Futurebus halt enable
macro KA0202$V_IOCSR_FBUS_HLT = 0,5,1,0 %; !  Futurebus halt
macro KA0202$V_IOCSR_FBUS_INT_STS = 0,6,1,0 %; !  Futurebus interrupt status
macro KA0202$V_IOCSR_FBUS_RESET_L = 0,7,1,0 %; !  Fbus reset
macro KA0202$V_IOCSR_FBUS_PWR_FAIL = 0,8,1,0 %; !  Fbus power fail msg
macro KA0202$V_IOCSR_MBX_ENA_L = 0,9,1,0 %; !  Mailbox enable even
macro KA0202$V_IOCSR_FBUS_DMA_ENA_L = 0,10,1,0 %; !  Futurebus DMA enable even
macro KA0202$V_IOCSR_LBUS_DMA_ENA_L = 0,11,1,0 %; !  Lbus DMA enable even
macro KA0202$V_IOCSR_CA_WWP_0 = 0,12,1,0 %; !  Command/address write wrong parity 0
macro KA0202$V_IOCSR_CA_WWP_2 = 0,13,1,0 %; !  Command/address write wrong parity 2
macro KA0202$V_IOCSR_DATA_WWP_L = 0,14,1,0 %; !  Data write wrong parity even
macro KA0202$V_IOCSR_FMBPR_RESET_L = 0,15,1,0 %; !  Reset fbus mbx pointer reg
macro KA0202$V_IOCSR_LMBPR_RESET_L = 0,16,1,0 %; !  Reset lbus mbx pointer reg
macro KA0202$V_IOCSR_LBUS_RESET_L = 0,17,1,0 %; !  Lbus reset
macro KA0202$V_IOCSR_FBUS_COMP_PE_L = 0,18,1,0 %; !  Fbus complement parity even
macro KA0202$V_IOCSR_LBUS_COMP_PE_L = 0,19,1,0 %; !  Lbus complement parity even
macro KA0202$V_IOCSR_FBUS_RESET_H = 4,7,1,0 %; !  Fbus reset
macro KA0202$V_IOCSR_MBX_ENA_H = 4,9,1,0 %; !  Mailbox enable odd
macro KA0202$V_IOCSR_FBUS_DMA_ENA_H = 4,10,1,0 %; !  Futurebus DMA enable odd
macro KA0202$V_IOCSR_LBUS_DMA_ENA_H = 4,11,1,0 %; !  Lbus DMA enable odd
macro KA0202$V_IOCSR_CA_WWP_1 = 4,12,1,0 %; !  Command/address write wrong parity 1
macro KA0202$V_IOCSR_CA_WWP_3 = 4,13,1,0 %; !  Command/address write wrong parity 3
macro KA0202$V_IOCSR_DATA_WWP_H = 4,14,1,0 %; !  Data write wrong parity odd
macro KA0202$V_IOCSR_FMBPR_RESET_H = 4,15,1,0 %; !  Reset fbus mbx pointer reg
macro KA0202$V_IOCSR_LMBPR_RESET_H = 4,16,1,0 %; !  Reset lbus mbx pointer reg
macro KA0202$V_IOCSR_LBUS_RESET_H = 4,17,1,0 %; !  Lbus reset
macro KA0202$V_IOCSR_FBUS_COMP_PE_H = 4,18,1,0 %; !  Fbus complement parity even
macro KA0202$V_IOCSR_LBUS_COMP_PE_H = 4,19,1,0 %; !  Lbus complement parity even
macro KA0202$b_fill1 = 8,0,0,1 %;
literal KA0202$s_fill1 = 24;
macro KA0202$Q_CERR1 = 32,0,0,1 %;
literal KA0202$S_CERR1 = 8;
macro KA0202$V_CERR1_UNCORR_RDERR_L = 32,0,1,0 %; !  Uncorrectable read error
macro KA0202$V_CERR1_NOACK_L = 32,1,1,0 %; !  No acknowledge error
macro KA0202$V_CERR1_CMDADR_PE_L = 32,2,1,0 %; !  Command address parity error even
macro KA0202$V_CERR1_MCMDADR_PE_L = 32,3,1,0 %; !  Missed command address parity error even
macro KA0202$V_CERR1_WRTDAT_PE_L = 32,4,1,0 %; !  Write data parity error even
macro KA0202$V_CERR1_MWRTDAT_PE_L = 32,5,1,0 %; !  Missed write data parity error even
macro KA0202$V_CERR1_RDDAT_PE_L = 32,6,1,0 %; !  Read data parity error even
macro KA0202$V_CERR1_MRDDAT_PE_L = 32,7,1,0 %; !  Missed read data parity error even
macro KA0202$V_CERR1_CMDADR_PE_LW0 = 32,8,1,0 %; !  Command address parity error longword 0
macro KA0202$V_CERR1_CMDADR_PE_LW2 = 32,9,1,0 %; !  Command address parity error longword 2
macro KA0202$V_CERR1_DAT_PE_LW0 = 32,10,1,0 %; !  Data parity error longword 0
macro KA0202$V_CERR1_DAT_PE_LW2 = 32,11,1,0 %; !  Data parity error longword 2
macro KA0202$V_CERR1_DAT_PE_LW4 = 32,12,1,0 %; !  Data parity error longword 4
macro KA0202$V_CERR1_DAT_PE_LW6 = 32,13,1,0 %; !  Data parity error longword 6
macro KA0202$V_CERR1_CSTALL_SYNC_H = 32,14,1,0 %;
macro KA0202$V_CERR1_FBUS_MBX_ERR = 32,15,1,0 %; !  Futurebus mailbox error
macro KA0202$V_CERR1_CMD_WRTDAT_PE_L = 32,16,1,0 %;
macro KA0202$V_CERR1_BUS_SYNC = 32,17,1,0 %;
macro KA0202$V_CERR1_UNCORR_RDERR_H = 36,0,1,0 %; !  Uncorrectable read error
macro KA0202$V_CERR1_NOACK_H = 36,1,1,0 %; !  No acknowledge error
macro KA0202$V_CERR1_CMDADR_PE_H = 36,2,1,0 %; !  Command address parity error even
macro KA0202$V_CERR1_MCMDADR_PE_H = 36,3,1,0 %; !  Missed command address parity error even
macro KA0202$V_CERR1_WRTDAT_PE_H = 36,4,1,0 %; !  Write data parity error even
macro KA0202$V_CERR1_MWRTDAT_PE_H = 36,5,1,0 %; !  Missed write data parity error even
macro KA0202$V_CERR1_RDDAT_PE_H = 36,6,1,0 %; !  Read data parity error even
macro KA0202$V_CERR1_MRDDAT_PE_H = 36,7,1,0 %; !  Missed read data parity error even
macro KA0202$V_CERR1_CMDADR_PE_LW1 = 36,8,1,0 %; !  Command address parity error longword 0
macro KA0202$V_CERR1_CMDADR_PE_LW3 = 36,9,1,0 %; !  Command address parity error longword 2
macro KA0202$V_CERR1_DAT_PE_LW1 = 36,10,1,0 %; !  Data parity error longword 0
macro KA0202$V_CERR1_DAT_PE_LW3 = 36,11,1,0 %; !  Data parity error longword 2
macro KA0202$V_CERR1_DAT_PE_LW5 = 36,12,1,0 %; !  Data parity error longword 4
macro KA0202$V_CERR1_DAT_PE_LW7 = 36,13,1,0 %; !  Data parity error longword 6
macro KA0202$V_CERR1_CSTALL_SYNC_L = 36,14,1,0 %;
macro KA0202$V_CERR1_LBUS_MBX = 36,15,1,0 %; !  Lbus mailbox error
macro KA0202$V_CERR1_CMD_WRTDAT_PE_H = 36,16,1,0 %;
macro KA0202$b_fill2 = 40,0,0,1 %;
literal KA0202$s_fill2 = 24;
macro KA0202$Q_CERR2 = 64,0,0,0 %;
literal KA0202$S_CERR2 = 8;             !  Cobra Error register 2
macro KA0202$V_CERR2_L = 64,0,32,0 %;
literal KA0202$S_CERR2_L = 32;
macro KA0202$V_CERR2_H = 68,0,32,0 %;
literal KA0202$S_CERR2_H = 32;
macro KA0202$b_fill3 = 72,0,0,1 %;
literal KA0202$s_fill3 = 24;
macro KA0202$Q_CERR3 = 96,0,0,1 %;
literal KA0202$S_CERR3 = 8;
macro KA0202$b_fill4 = 104,0,0,1 %;
literal KA0202$s_fill4 = 24;
macro KA0202$Q_LMBPR = 128,0,0,1 %;
literal KA0202$S_LMBPR = 8;
macro KA0202$V_LMBPR_MBX_ADDR = 128,6,26,0 %;
literal KA0202$S_LMBPR_MBX_ADDR = 26;   !  Lbus mailbox address
macro KA0202$b_fill5 = 136,0,0,1 %;
literal KA0202$s_fill5 = 24;
macro KA0202$Q_FMBPR = 160,0,0,1 %;
literal KA0202$S_FMBPR = 8;
macro KA0202$V_FMBPR_MBX_ADDR = 160,6,26,0 %;
literal KA0202$S_FMBPR_MBX_ADDR = 26;   !  Futurebus mailbox address
macro KA0202$b_fill6 = 168,0,0,1 %;
literal KA0202$s_fill6 = 24;
macro KA0202$Q_DIAGCSR = 192,0,0,1 %;
literal KA0202$S_DIAGCSR = 8;
macro KA0202$b_fill7 = 200,0,0,1 %;
literal KA0202$s_fill7 = 24;
macro KA0202$Q_FIVECT = 224,0,0,1 %;
literal KA0202$S_FIVECT = 8;
macro KA0202$V_FIVECT_VECTOR = 224,0,16,0 %;
literal KA0202$S_FIVECT_VECTOR = 16;    !  Futurebus interrupt vector
macro KA0202$b_fill8 = 232,0,0,1 %;
literal KA0202$s_fill8 = 24;
macro KA0202$Q_FHVECT = 256,0,0,1 %;
literal KA0202$S_FHVECT = 8;
macro KA0202$V_FHVECT_VECTOR = 256,0,16,0 %;
literal KA0202$S_FHVECT_VECTOR = 16;    !  Futurebus halt vector
macro KA0202$b_fill9 = 264,0,0,1 %;
literal KA0202$s_fill9 = 24;
macro KA0202$Q_FERR1 = 288,0,0,1 %;
literal KA0202$S_FERR1 = 8;
macro KA0202$V_FERR1_DATA_PE_L = 288,0,1,0 %;
macro KA0202$V_FERR1_ADDR_PE_L = 288,1,1,0 %;
macro KA0202$V_FERR1_fill1 = 288,2,30,0 %;
literal KA0202$S_FERR1_fill1 = 30;
macro KA0202$V_FERR1_DATA_PE_H = 292,0,1,0 %;
macro KA0202$V_FERR1_ADDR_PE_H = 292,1,1,0 %;
macro KA0202$b_fill10 = 296,0,0,1 %;
literal KA0202$s_fill10 = 24;
macro KA0202$Q_FERR2 = 320,0,0,1 %;
literal KA0202$S_FERR2 = 8;
macro KA0202$b_fill11 = 328,0,0,1 %;
literal KA0202$s_fill11 = 24;
macro KA0202$Q_LINT = 352,0,0,1 %;
literal KA0202$S_LINT = 8;
macro KA0202$V_LINT_SCSI0_IRQ = 352,0,1,0 %; !  SCSI bus 0 interrupt request
macro KA0202$V_LINT_SCSI1_IRQ = 352,1,1,0 %; !  SCSI bus 1 interrupt request
macro KA0202$V_LINT_SCSI2_IRQ = 352,2,1,0 %; !  SCSI bus 2 interrupt request
macro KA0202$V_LINT_SCSI3_IRQ = 352,3,1,0 %; !  SCSI bus 3 interrupt request
macro KA0202$V_LINT_SCSI4_IRQ = 352,4,1,0 %; !  SCSI bus 4 interrupt request
macro KA0202$V_LINT_SLU_IRQ = 356,0,1,0 %; !  Seriel line unit interrupt request
macro KA0202$V_LINT_NI0_IRQ = 356,1,1,0 %; !  Ethernet 0 interrupt request
macro KA0202$V_LINT_NI1_IRQ = 356,2,1,0 %; !  Ethernet 1 interrupt request
macro KA0202$V_LINT_SBUS_IRQ = 356,3,1,0 %; !  Serial bus interrupt request
macro KA0202$b_fill12 = 360,0,0,1 %;
literal KA0202$s_fill12 = 24;
macro KA0202$Q_LERR1 = 384,0,0,1 %;
literal KA0202$S_LERR1 = 8;
macro KA0202$V_LERR1_EVEN = 384,0,1,0 %; !  Even error
macro KA0202$V_LERR1_ODD = 388,0,1,0 %; !  Odd error
macro KA0202$b_fill13 = 392,0,0,1 %;
literal KA0202$s_fill13 = 24;
macro KA0202$Q_LERR2 = 416,0,0,1 %;
literal KA0202$S_LERR2 = 8;
macro KA0202$b_fill14 = 424,0,0,1 %;
literal KA0202$s_fill14 = 7768;
macro KA0202$Q_CPU0 = 8192,0,0,1 %;
literal KA0202$S_CPU0 = 8192;
macro KA0202$Q_CPU1 = 16384,0,0,1 %;
literal KA0202$S_CPU1 = 8192;
macro KA0202$Q_CMM0 = 24576,0,0,1 %;
literal KA0202$S_CMM0 = 8192;
macro KA0202$Q_CMM1 = 32768,0,0,1 %;
literal KA0202$S_CMM1 = 8192;
macro KA0202$Q_CMM2 = 40960,0,0,1 %;
literal KA0202$S_CMM2 = 8192;
macro KA0202$Q_CMM3 = 49152,0,0,1 %;
literal KA0202$S_CMM3 = 8192;
literal KA0202_CPU$M_BCC_ENB_ALLOC_L = %X'1';
literal KA0202_CPU$M_BCC_FRC_FILL_SH_L = %X'2';
literal KA0202_CPU$M_BCC_ENB_TPC_L = %X'4';
literal KA0202_CPU$M_BCC_FILL_WTP_L = %X'8';
literal KA0202_CPU$M_BCC_FILL_WCP_L = %X'10';
literal KA0202_CPU$M_BCC_FILL_WDTP_L = %X'20';
literal KA0202_CPU$M_BCC_ENB_CEI_L = %X'40';
literal KA0202_CPU$M_BCC_ENB_EDCC_L = %X'80';
literal KA0202_CPU$M_BCC_ENB_EDC_CHK_L = %X'100';
literal KA0202_CPU$M_BCC_ENB_BC_CIO_L = %X'200';
literal KA0202_CPU$M_BCC_DIS_BLK_W_L = %X'400';
literal KA0202_CPU$M_BCC_ENB_BC_INIT_L = %X'800';
literal KA0202_CPU$M_BCC_FOR_EDCC_L = %X'1000';
literal KA0202_CPU$M_BCC_SH_D_V_L = %X'E000';
literal KA0202_CPU$M_BCC_EDC_L = %X'3FFF0000';
literal KA0202_CPU$M_BCC_CACHE_SIZE_L = %X'C0000000';
literal KA0202_CPU$M_BCC_ENB_ALLOC_H = %X'100000000';
literal KA0202_CPU$M_BCC_FRC_FILL_SH_H = %X'200000000';
literal KA0202_CPU$M_BCC_ENB_TPC_H = %X'400000000';
literal KA0202_CPU$M_BCC_FILL_WTP_H = %X'800000000';
literal KA0202_CPU$M_BCC_FILL_WCP_H = %X'1000000000';
literal KA0202_CPU$M_BCC_FILL_WDTP_H = %X'2000000000';
literal KA0202_CPU$M_BCC_ENB_CEI_H = %X'4000000000';
literal KA0202_CPU$M_BCC_ENB_EDCC_H = %X'8000000000';
literal KA0202_CPU$M_BCC_ENB_EDC_CHK_H = %X'10000000000';
literal KA0202_CPU$M_BCC_ENB_BC_CIO_H = %X'20000000000';
literal KA0202_CPU$M_BCC_DIS_BLK_W_H = %X'40000000000';
literal KA0202_CPU$M_BCC_ENB_BC_INIT_H = %X'80000000000';
literal KA0202_CPU$M_BCC_FOR_EDCC_H = %X'100000000000';
literal KA0202_CPU$M_BCC_SH_D_V_H = %X'E00000000000';
literal KA0202_CPU$M_BCC_EDC_L_H = %X'3FFF000000000000';
literal KA0202_CPU$M_BCC_CACHE_SIZE_H = %X'C000000000000000';
literal KA0202_BCC$K_CACHE_SIZE_512K = 0; !  Cache size is 512Kb
literal KA0202_BCC$K_CACHE_SIZE_1MB = 1; !  Cache size is 1Mb
literal KA0202_BCC$K_CACHE_SIZE_4MB = 2; !  Cache size is 4Mb
literal KA0202_CPU$M_BCCE_MCE = %X'4';
literal KA0202_CPU$M_BCCE_CE = %X'8';
literal KA0202_CPU$M_BCCE_CNTRL_PAR = %X'100';
literal KA0202_CPU$M_BCCE_SH = %X'200';
literal KA0202_CPU$M_BCCE_DIRTY = %X'400';
literal KA0202_CPU$M_BCCE_VALID = %X'800';
literal KA0202_CPU$M_BCCE_BC_EDC_L = %X'20000';
literal KA0202_CPU$M_BCCE_EDC_SYND_0 = %X'1FC0000';
literal KA0202_CPU$M_BCCE_EDC_SYND_2 = %X'FE000000';
literal KA0202_CPU$M_BCCE_MCE_H = %X'100000000';
literal KA0202_CPU$M_BCCE_CE_H = %X'200000000';
literal KA0202_CPU$M_BCCE_READ_ONLY = %X'7FFC00000000';
literal KA0202_CPU$M_BCCE_BC_EDC_H = %X'800000000000';
literal KA0202_CPU$M_BCCE_EDC_SYND_1 = %X'7F000000000000';
literal KA0202_CPU$M_BCCE_EDC_SYND_3 = %X'3F80000000000000';
literal KA0202_CPU$M_BCCEA_BCMAP_OFF = %X'1FFFF';
literal KA0202_CPU$M_BCCEA_TAG_PAR = %X'40000';
literal KA0202_CPU$M_BCCEA_TAG_VALUE = %X'7FF80000';
literal KA0202_CPU$M_BCCEA_BCMAP_OFF_H = %X'1FFFF00000000';
literal KA0202_CPU$M_BCCEA_TAG_PAR_H = %X'4000000000000';
literal KA0202_CPU$M_BCCEA_TAG_VALUE_H = %X'7FF8000000000000';
literal KA0202_CPU$M_BCUE_MPE = %X'1';
literal KA0202_CPU$M_BCUE_PE = %X'2';
literal KA0202_CPU$M_BCUE_MUNCE_L = %X'4';
literal KA0202_CPU$M_BCUE_UNCE_L = %X'8';
literal KA0202_CPU$M_BCUE_CTRL_PAR = %X'100';
literal KA0202_CPU$M_BCUE_SH = %X'200';
literal KA0202_CPU$M_BCUE_DIRTY = %X'400';
literal KA0202_CPU$M_BCUE_VALID = %X'800';
literal KA0202_CPU$M_BCUE_BC_EDC_L = %X'20000';
literal KA0202_CPU$M_BCUE_EDC_SYND_0 = %X'1FC0000';
literal KA0202_CPU$M_BCUE_EDC_SYND_2 = %X'FE000000';
literal KA0202_CPU$M_BCUE_PE_H = %X'100000000';
literal KA0202_CPU$M_BCUE_MUNCE_H = %X'200000000';
literal KA0202_CPU$M_BCUE_UNCE_H = %X'400000000';
literal KA0202_CPU$M_BCUE_BC_EDC_H = %X'1000000000000';
literal KA0202_CPU$M_BCUE_EDC_SYND_1 = %X'FE000000000000';
literal KA0202_CPU$M_BCUE_EDC_SYND_3 = %X'7F00000000000000';
literal KA0202_CPU$M_BCUEA_BCMAP_OFF = %X'1FFFF';
literal KA0202_CPU$M_BCUEA_PTP = %X'20000';
literal KA0202_CPU$M_BCUEA_TP = %X'40000';
literal KA0202_CPU$M_BCUEA_TV = %X'7FF80000';
literal KA0202_CPU$M_BCUEA_BCMAP_OFF_H = %X'FFFF80000000';
literal KA0202_CPU$M_BCUEA_PTP_H = %X'1000000000000';
literal KA0202_CPU$M_BCUEA_TP_H = %X'2000000000000';
literal KA0202_CPU$M_BCUEA_TV_H = %X'3FFC000000000000';
literal KA0202_CPU$M_MDTER_L = %X'1';
literal KA0202_CPU$M_DTER_L = %X'2';
literal KA0202_CPU$M_DTER_TOFF_L = %X'3FC';
literal KA0202_CPU$M_DTER_DUP_TAG_L = %X'3FFFFC00';
literal KA0202_CPU$M_DTER_DTP = %X'40000000';
literal KA0202_CPU$M_MDTER_H = %X'100000000';
literal KA0202_CPU$M_DTER_H = %X'200000000';
literal KA0202_CPU$M_DTER_DT_H = %X'3FC00000000';
literal KA0202_CPU$M_DTER_DUP_TAG_H = %X'3FFFFC0000000000';
literal KA0202_CPU$M_DTER_DTP_H = %X'4000000000000000';
literal KA0202_CPU$M_CBCTL_DWP = %X'1';
literal KA0202_CPU$M_CBCTL_CAWP = %X'6';
literal KA0202_CPU$M_CBCTL_EPC = %X'8';
literal KA0202_CPU$M_CBCTL_FRC_SH = %X'10';
literal KA0202_CPU$M_CBCTL_CMDER_ID = %X'E0';
literal KA0202_CPU$M_CBCTL_ACM = %X'700';
literal KA0202_CPU$M_CBCTL_ENB_CI = %X'800';
literal KA0202_CPU$M_CBCTL_RD = %X'1000';
literal KA0202_CPU$M_CBCTL_QW_2_SEL = %X'2000';
literal KA0202_CPU$M_CBCTL_SEL_DRACK = %X'4000';
literal KA0202_CPU$M_CBCTL_DWP_H = %X'100000000';
literal KA0202_CPU$M_CBCTL_CAWP_H = %X'600000000';
literal KA0202_CPU$M_CBCTL_EPC_H = %X'800000000';
literal KA0202_CPU$M_CBCTL_FRC_SH_H = %X'1000000000';
literal KA0202_CPU$M_CBCTL_CMDER_ID_H = %X'E000000000';
literal KA0202_CPU$M_CBCTL_ACM_H = %X'70000000000';
literal KA0202_CPU$M_CBCTL_ENB_CI_H = %X'80000000000';
literal KA0202_CPU$M_CBCTL_RD_H = %X'100000000000';
literal KA0202_CPU$M_CBCTL_QW_2_SEL_H = %X'200000000000';
literal KA0202_CPU$M_CBCTL_SEL_DRACK_H = %X'400000000000';
literal KA0202_CPU$M_CBE_RD_L = %X'2';
literal KA0202_CPU$M_CBE_CAP_L = %X'4';
literal KA0202_CPU$M_CBE_MCAP_L = %X'8';
literal KA0202_CPU$M_CBE_PE_WRD_L = %X'10';
literal KA0202_CPU$M_CBE_MPE_WRD_L = %X'20';
literal KA0202_CPU$M_CBE_PE_RD_L = %X'40';
literal KA0202_CPU$M_CBE_MPE_RD_L = %X'80';
literal KA0202_CPU$M_CBE_CA_PE_LW0 = %X'100';
literal KA0202_CPU$M_CBE_CA_PE_LW2 = %X'200';
literal KA0202_CPU$M_CBE_D_PE_LW0 = %X'400';
literal KA0202_CPU$M_CBE_D_PE_LW2 = %X'800';
literal KA0202_CPU$M_CBE_D_PE_LW4 = %X'1000';
literal KA0202_CPU$M_CBE_D_PE_LW6 = %X'2000';
literal KA0202_CPU$M_CBE_CA_NACK = %X'4000';
literal KA0202_CPU$M_CBE_WR_DATA_NACK = %X'8000';
literal KA0202_CPU$M_CBE_MCOUNT = %X'7E000000';
literal KA0202_CPU$M_CBE_MADR_VALID = %X'80000000';
literal KA0202_CPU$M_CBE_RD_H = %X'200000000';
literal KA0202_CPU$M_CBE_CAP_H = %X'400000000';
literal KA0202_CPU$M_CBE_MCAP_H = %X'800000000';
literal KA0202_CPU$M_CBE_PE_WRD_H = %X'1000000000';
literal KA0202_CPU$M_CBE_MPE_WRD_H = %X'2000000000';
literal KA0202_CPU$M_CBE_PE_RD_H = %X'4000000000';
literal KA0202_CPU$M_CBE_MPE_RD_H = %X'8000000000';
literal KA0202_CPU$M_CBE_CA_PE_LW1 = %X'10000000000';
literal KA0202_CPU$M_CBE_CA_PE_LW3 = %X'20000000000';
literal KA0202_CPU$M_CBE_D_PE_LW1 = %X'40000000000';
literal KA0202_CPU$M_CBE_D_PE_LW3 = %X'80000000000';
literal KA0202_CPU$M_CBE_D_PE_LW5 = %X'100000000000';
literal KA0202_CPU$M_CBE_D_PE_LW7 = %X'200000000000';
literal KA0202_CPU$M_CBE_UNDEFINED = %X'400000000000';
literal KA0202_CPU$M_CBE_UNDEFINED2 = %X'800000000000';
literal KA0202_CPU$M_CBE_MCOUNT_H = %X'7E00000000000000';
literal KA0202_CPU$M_CBE_MADR_VALID_H = %X'8000000000000000';
literal KA0202_CPU$M_CBEAL_SBO1 = %X'3';
literal KA0202_CPU$M_CBEAL_ADDR_CAD_L = %X'FFFFFFFC';
literal KA0202_CPU$M_CBEAL_SBO2 = %X'300000000';
literal KA0202_CPU$M_CBEAL_ADDR_CAD_H = %X'FFFFFFFC00000000';
literal KA0202_CPU$M_CBEAH_SBO1 = %X'3';
literal KA0202_CPU$M_CBEAH_EA_L = %X'3FFFC';
literal KA0202_CPU$M_CBEAH_T_TYPE_L = %X'1C0000';
literal KA0202_CPU$M_CBEAH_CMDR_ID_L = %X'E00000';
literal KA0202_CPU$M_CBEAH_SBO2 = %X'FF000000';
literal KA0202_CPU$M_CBEAH_SBO3 = %X'300000000';
literal KA0202_CPU$M_CBEAH_EA_H = %X'3FFFC00000000';
literal KA0202_CPU$M_CBEAH_T_TYPE_H = %X'1C000000000000';
literal KA0202_CPU$M_CBEAH_CMDR_ID_H = %X'E0000000000000';
literal KA0202_CPU$M_CBEAH_SBO4 = %X'FF00000000000000';
literal KA0202_CPU$M_IPIR_UNDEFINED = %X'1';
literal KA0202_CPU$M_IPIR_REQ_INT_CPU = %X'100000000';
literal KA0202_CPU$M_SIC_UNDEFINED = %X'1';
literal KA0202_CPU$M_SIC_UNDEFINED1 = %X'2';
literal KA0202_CPU$M_SIC_EIC = %X'4';
literal KA0202_CPU$M_SIC_IT_ICLEAR = %X'100000000';
literal KA0202_CPU$M_SIC_SYS_EVT_CLR = %X'200000000';
literal KA0202_CPU$M_SIC_UNDEFINED2 = %X'400000000';
literal KA0202_CPU$M_ADLK_LA_V_L = %X'1';
literal KA0202_CPU$M_ADLK_LA_L = %X'FFFFFFF8';
literal KA0202_CPU$M_ADLK_LA_V_H = %X'100000000';
literal KA0202_CPU$M_ADLK_LA_H = %X'FFFFFFF800000000';
literal KA0202_CPU$M_MADRL_VALID_L = %X'1';
literal KA0202_CPU$M_MADRL_T_TYPE_L = %X'2';
literal KA0202_CPU$M_MADRL_ADDRESS_L = %X'FFFFFFFC';
literal KA0202_CPU$M_MADRL_VALID_H = %X'100000000';
literal KA0202_CPU$M_MADRL_T_TYPE_H = %X'200000000';
literal KA0202_CPU$M_MADRL_ADDRESS_H = %X'FFFFFFFC00000000';
literal KA0202_CPU$K_LENGTH = 8192;
literal KA0202_CPU$S_CPUDEF = 8192;     !  Old size name, synonym for  KA0202_CPU$$S_KA0202CPU
literal KA0202_CPU$S_KA0202CPU = 8192;
macro KA0202_CPU$Q_BCC = 0,0,0,1 %;
literal KA0202_CPU$S_BCC = 8;
macro KA0202_CPU$V_BCC_ENB_ALLOC_L = 0,0,1,0 %;
macro KA0202_CPU$V_BCC_FRC_FILL_SH_L = 0,1,1,0 %;
macro KA0202_CPU$V_BCC_ENB_TPC_L = 0,2,1,0 %;
macro KA0202_CPU$V_BCC_FILL_WTP_L = 0,3,1,0 %;
macro KA0202_CPU$V_BCC_FILL_WCP_L = 0,4,1,0 %;
macro KA0202_CPU$V_BCC_FILL_WDTP_L = 0,5,1,0 %;
macro KA0202_CPU$V_BCC_ENB_CEI_L = 0,6,1,0 %;
macro KA0202_CPU$V_BCC_ENB_EDCC_L = 0,7,1,0 %;
macro KA0202_CPU$V_BCC_ENB_EDC_CHK_L = 0,8,1,0 %;
macro KA0202_CPU$V_BCC_ENB_BC_CIO_L = 0,9,1,0 %;
macro KA0202_CPU$V_BCC_DIS_BLK_W_L = 0,10,1,0 %;
macro KA0202_CPU$V_BCC_ENB_BC_INIT_L = 0,11,1,0 %;
macro KA0202_CPU$V_BCC_FOR_EDCC_L = 0,12,1,0 %;
macro KA0202_CPU$V_BCC_SH_D_V_L = 0,13,3,0 %;
literal KA0202_CPU$S_BCC_SH_D_V_L = 3;
macro KA0202_CPU$V_BCC_EDC_L = 0,16,14,0 %;
literal KA0202_CPU$S_BCC_EDC_L = 14;
macro KA0202_CPU$V_BCC_CACHE_SIZE_L = 0,30,2,0 %;
literal KA0202_CPU$S_BCC_CACHE_SIZE_L = 2;
macro KA0202_CPU$V_BCC_ENB_ALLOC_H = 4,0,1,0 %;
macro KA0202_CPU$V_BCC_FRC_FILL_SH_H = 4,1,1,0 %;
macro KA0202_CPU$V_BCC_ENB_TPC_H = 4,2,1,0 %;
macro KA0202_CPU$V_BCC_FILL_WTP_H = 4,3,1,0 %;
macro KA0202_CPU$V_BCC_FILL_WCP_H = 4,4,1,0 %;
macro KA0202_CPU$V_BCC_FILL_WDTP_H = 4,5,1,0 %;
macro KA0202_CPU$V_BCC_ENB_CEI_H = 4,6,1,0 %;
macro KA0202_CPU$V_BCC_ENB_EDCC_H = 4,7,1,0 %;
macro KA0202_CPU$V_BCC_ENB_EDC_CHK_H = 4,8,1,0 %;
macro KA0202_CPU$V_BCC_ENB_BC_CIO_H = 4,9,1,0 %;
macro KA0202_CPU$V_BCC_DIS_BLK_W_H = 4,10,1,0 %;
macro KA0202_CPU$V_BCC_ENB_BC_INIT_H = 4,11,1,0 %;
macro KA0202_CPU$V_BCC_FOR_EDCC_H = 4,12,1,0 %;
macro KA0202_CPU$V_BCC_SH_D_V_H = 4,13,3,0 %;
literal KA0202_CPU$S_BCC_SH_D_V_H = 3;
macro KA0202_CPU$V_BCC_EDC_L_H = 4,16,14,0 %;
literal KA0202_CPU$S_BCC_EDC_L_H = 14;
macro KA0202_CPU$V_BCC_CACHE_SIZE_H = 4,30,2,0 %;
literal KA0202_CPU$S_BCC_CACHE_SIZE_H = 2;
macro KA0202_CPU$b_fill13a = 8,0,0,1 %;
literal KA0202_CPU$s_fill13a = 24;
macro KA0202_CPU$Q_BCCE = 32,0,0,1 %;
literal KA0202_CPU$S_BCCE = 8;
macro KA0202_CPU$V_BCCE_MCE = 32,2,1,0 %;
macro KA0202_CPU$V_BCCE_CE = 32,3,1,0 %;
macro KA0202_CPU$V_BCCE_CNTRL_PAR = 32,8,1,0 %;
macro KA0202_CPU$V_BCCE_SH = 32,9,1,0 %;
macro KA0202_CPU$V_BCCE_DIRTY = 32,10,1,0 %;
macro KA0202_CPU$V_BCCE_VALID = 32,11,1,0 %;
macro KA0202_CPU$V_BCCE_BC_EDC_L = 32,17,1,0 %;
macro KA0202_CPU$V_BCCE_EDC_SYND_0 = 32,18,7,0 %;
literal KA0202_CPU$S_BCCE_EDC_SYND_0 = 7;
macro KA0202_CPU$V_BCCE_EDC_SYND_2 = 32,25,7,0 %;
literal KA0202_CPU$S_BCCE_EDC_SYND_2 = 7;
macro KA0202_CPU$V_BCCE_MCE_H = 36,0,1,0 %;
macro KA0202_CPU$V_BCCE_CE_H = 36,1,1,0 %;
macro KA0202_CPU$V_BCCE_READ_ONLY = 36,2,13,0 %;
literal KA0202_CPU$S_BCCE_READ_ONLY = 13;
macro KA0202_CPU$V_BCCE_BC_EDC_H = 36,15,1,0 %;
macro KA0202_CPU$V_BCCE_EDC_SYND_1 = 36,16,7,0 %;
literal KA0202_CPU$S_BCCE_EDC_SYND_1 = 7;
macro KA0202_CPU$V_BCCE_EDC_SYND_3 = 36,23,7,0 %;
literal KA0202_CPU$S_BCCE_EDC_SYND_3 = 7;
macro KA0202_CPU$b_fill13b = 40,0,0,1 %;
literal KA0202_CPU$s_fill13b = 24;
macro KA0202_CPU$Q_BCCEA = 64,0,0,1 %;
literal KA0202_CPU$S_BCCEA = 8;
macro KA0202_CPU$V_BCCEA_BCMAP_OFF = 64,0,17,0 %;
literal KA0202_CPU$S_BCCEA_BCMAP_OFF = 17;
macro KA0202_CPU$V_BCCEA_TAG_PAR = 64,18,1,0 %;
macro KA0202_CPU$V_BCCEA_TAG_VALUE = 64,19,12,0 %;
literal KA0202_CPU$S_BCCEA_TAG_VALUE = 12;
macro KA0202_CPU$V_BCCEA_BCMAP_OFF_H = 68,0,17,0 %;
literal KA0202_CPU$S_BCCEA_BCMAP_OFF_H = 17;
macro KA0202_CPU$V_BCCEA_TAG_PAR_H = 68,18,1,0 %;
macro KA0202_CPU$V_BCCEA_TAG_VALUE_H = 68,19,12,0 %;
literal KA0202_CPU$S_BCCEA_TAG_VALUE_H = 12;
macro KA0202_CPU$b_fill13b1 = 72,0,0,1 %;
literal KA0202_CPU$s_fill13b1 = 24;
macro KA0202_CPU$Q_BCUE = 96,0,0,1 %;
literal KA0202_CPU$S_BCUE = 8;
macro KA0202_CPU$V_BCUE_MPE = 96,0,1,0 %;
macro KA0202_CPU$V_BCUE_PE = 96,1,1,0 %;
macro KA0202_CPU$V_BCUE_MUNCE_L = 96,2,1,0 %;
macro KA0202_CPU$V_BCUE_UNCE_L = 96,3,1,0 %;
macro KA0202_CPU$V_BCUE_CTRL_PAR = 96,8,1,0 %;
macro KA0202_CPU$V_BCUE_SH = 96,9,1,0 %;
macro KA0202_CPU$V_BCUE_DIRTY = 96,10,1,0 %;
macro KA0202_CPU$V_BCUE_VALID = 96,11,1,0 %;
macro KA0202_CPU$V_BCUE_BC_EDC_L = 96,17,1,0 %;
macro KA0202_CPU$V_BCUE_EDC_SYND_0 = 96,18,7,0 %;
literal KA0202_CPU$S_BCUE_EDC_SYND_0 = 7;
macro KA0202_CPU$V_BCUE_EDC_SYND_2 = 96,25,7,0 %;
literal KA0202_CPU$S_BCUE_EDC_SYND_2 = 7;
macro KA0202_CPU$V_BCUE_PE_H = 100,0,1,0 %;
macro KA0202_CPU$V_BCUE_MUNCE_H = 100,1,1,0 %;
macro KA0202_CPU$V_BCUE_UNCE_H = 100,2,1,0 %;
macro KA0202_CPU$V_BCUE_BC_EDC_H = 100,16,1,0 %;
macro KA0202_CPU$V_BCUE_EDC_SYND_1 = 100,17,7,0 %;
literal KA0202_CPU$S_BCUE_EDC_SYND_1 = 7;
macro KA0202_CPU$V_BCUE_EDC_SYND_3 = 100,24,7,0 %;
literal KA0202_CPU$S_BCUE_EDC_SYND_3 = 7;
macro KA0202_CPU$b_fill13c = 104,0,0,1 %;
literal KA0202_CPU$s_fill13c = 24;
macro KA0202_CPU$Q_BCUEA = 128,0,0,1 %;
literal KA0202_CPU$S_BCUEA = 8;
macro KA0202_CPU$V_BCUEA_BCMAP_OFF = 128,0,17,0 %;
literal KA0202_CPU$S_BCUEA_BCMAP_OFF = 17;
macro KA0202_CPU$V_BCUEA_PTP = 128,17,1,0 %;
macro KA0202_CPU$V_BCUEA_TP = 128,18,1,0 %;
macro KA0202_CPU$V_BCUEA_TV = 128,19,12,0 %;
literal KA0202_CPU$S_BCUEA_TV = 12;
macro KA0202_CPU$V_BCUEA_BCMAP_OFF_H = 128,31,17,0 %;
literal KA0202_CPU$S_BCUEA_BCMAP_OFF_H = 17;
macro KA0202_CPU$V_BCUEA_PTP_H = 132,16,1,0 %;
macro KA0202_CPU$V_BCUEA_TP_H = 132,17,1,0 %;
macro KA0202_CPU$V_BCUEA_TV_H = 132,18,12,0 %;
literal KA0202_CPU$S_BCUEA_TV_H = 12;
macro KA0202_CPU$b_fill13d = 136,0,0,1 %;
literal KA0202_CPU$s_fill13d = 24;
macro KA0202_CPU$Q_DTER = 160,0,0,1 %;
literal KA0202_CPU$S_DTER = 8;
macro KA0202_CPU$V_MDTER_L = 160,0,1,0 %;
macro KA0202_CPU$V_DTER_L = 160,1,1,0 %;
macro KA0202_CPU$V_DTER_TOFF_L = 160,2,8,0 %;
literal KA0202_CPU$S_DTER_TOFF_L = 8;
macro KA0202_CPU$V_DTER_DUP_TAG_L = 160,10,20,0 %;
literal KA0202_CPU$S_DTER_DUP_TAG_L = 20;
macro KA0202_CPU$V_DTER_DTP = 160,30,1,0 %;
macro KA0202_CPU$V_MDTER_H = 164,0,1,0 %;
macro KA0202_CPU$V_DTER_H = 164,1,1,0 %;
macro KA0202_CPU$V_DTER_DT_H = 164,2,8,0 %;
literal KA0202_CPU$S_DTER_DT_H = 8;
macro KA0202_CPU$V_DTER_DUP_TAG_H = 164,10,20,0 %;
literal KA0202_CPU$S_DTER_DUP_TAG_H = 20;
macro KA0202_CPU$V_DTER_DTP_H = 164,30,1,0 %;
macro KA0202_CPU$b_fill13e = 168,0,0,1 %;
literal KA0202_CPU$s_fill13e = 24;
macro KA0202_CPU$Q_CBCTL = 192,0,0,1 %;
literal KA0202_CPU$S_CBCTL = 8;
macro KA0202_CPU$V_CBCTL_DWP = 192,0,1,0 %;
macro KA0202_CPU$V_CBCTL_CAWP = 192,1,2,0 %;
literal KA0202_CPU$S_CBCTL_CAWP = 2;
macro KA0202_CPU$V_CBCTL_EPC = 192,3,1,0 %;
macro KA0202_CPU$V_CBCTL_FRC_SH = 192,4,1,0 %;
macro KA0202_CPU$V_CBCTL_CMDER_ID = 192,5,3,0 %;
literal KA0202_CPU$S_CBCTL_CMDER_ID = 3;
macro KA0202_CPU$V_CBCTL_ACM = 192,8,3,0 %;
literal KA0202_CPU$S_CBCTL_ACM = 3;
macro KA0202_CPU$V_CBCTL_ENB_CI = 192,11,1,0 %;
macro KA0202_CPU$V_CBCTL_RD = 192,12,1,0 %;
macro KA0202_CPU$V_CBCTL_QW_2_SEL = 192,13,1,0 %;
macro KA0202_CPU$V_CBCTL_SEL_DRACK = 192,14,1,0 %;
macro KA0202_CPU$V_CBCTL_DWP_H = 196,0,1,0 %;
macro KA0202_CPU$V_CBCTL_CAWP_H = 196,1,2,0 %;
literal KA0202_CPU$S_CBCTL_CAWP_H = 2;
macro KA0202_CPU$V_CBCTL_EPC_H = 196,3,1,0 %;
macro KA0202_CPU$V_CBCTL_FRC_SH_H = 196,4,1,0 %;
macro KA0202_CPU$V_CBCTL_CMDER_ID_H = 196,5,3,0 %;
literal KA0202_CPU$S_CBCTL_CMDER_ID_H = 3;
macro KA0202_CPU$V_CBCTL_ACM_H = 196,8,3,0 %;
literal KA0202_CPU$S_CBCTL_ACM_H = 3;
macro KA0202_CPU$V_CBCTL_ENB_CI_H = 196,11,1,0 %;
macro KA0202_CPU$V_CBCTL_RD_H = 196,12,1,0 %;
macro KA0202_CPU$V_CBCTL_QW_2_SEL_H = 196,13,1,0 %;
macro KA0202_CPU$V_CBCTL_SEL_DRACK_H = 196,14,1,0 %;
macro KA0202_CPU$b_fill13f = 200,0,0,1 %;
literal KA0202_CPU$s_fill13f = 24;
macro KA0202_CPU$Q_CBE = 224,0,0,1 %;
literal KA0202_CPU$S_CBE = 8;
macro KA0202_CPU$V_CBE_RD_L = 224,1,1,0 %;
macro KA0202_CPU$V_CBE_CAP_L = 224,2,1,0 %;
macro KA0202_CPU$V_CBE_MCAP_L = 224,3,1,0 %;
macro KA0202_CPU$V_CBE_PE_WRD_L = 224,4,1,0 %;
macro KA0202_CPU$V_CBE_MPE_WRD_L = 224,5,1,0 %;
macro KA0202_CPU$V_CBE_PE_RD_L = 224,6,1,0 %;
macro KA0202_CPU$V_CBE_MPE_RD_L = 224,7,1,0 %;
macro KA0202_CPU$V_CBE_CA_PE_LW0 = 224,8,1,0 %;
macro KA0202_CPU$V_CBE_CA_PE_LW2 = 224,9,1,0 %;
macro KA0202_CPU$V_CBE_D_PE_LW0 = 224,10,1,0 %;
macro KA0202_CPU$V_CBE_D_PE_LW2 = 224,11,1,0 %;
macro KA0202_CPU$V_CBE_D_PE_LW4 = 224,12,1,0 %;
macro KA0202_CPU$V_CBE_D_PE_LW6 = 224,13,1,0 %;
macro KA0202_CPU$V_CBE_CA_NACK = 224,14,1,0 %;
macro KA0202_CPU$V_CBE_WR_DATA_NACK = 224,15,1,0 %;
macro KA0202_CPU$V_CBE_MCOUNT = 224,25,6,0 %;
literal KA0202_CPU$S_CBE_MCOUNT = 6;
macro KA0202_CPU$V_CBE_MADR_VALID = 224,31,1,0 %;
macro KA0202_CPU$V_CBE_RD_H = 228,1,1,0 %;
macro KA0202_CPU$V_CBE_CAP_H = 228,2,1,0 %;
macro KA0202_CPU$V_CBE_MCAP_H = 228,3,1,0 %;
macro KA0202_CPU$V_CBE_PE_WRD_H = 228,4,1,0 %;
macro KA0202_CPU$V_CBE_MPE_WRD_H = 228,5,1,0 %;
macro KA0202_CPU$V_CBE_PE_RD_H = 228,6,1,0 %;
macro KA0202_CPU$V_CBE_MPE_RD_H = 228,7,1,0 %;
macro KA0202_CPU$V_CBE_CA_PE_LW1 = 228,8,1,0 %;
macro KA0202_CPU$V_CBE_CA_PE_LW3 = 228,9,1,0 %;
macro KA0202_CPU$V_CBE_D_PE_LW1 = 228,10,1,0 %;
macro KA0202_CPU$V_CBE_D_PE_LW3 = 228,11,1,0 %;
macro KA0202_CPU$V_CBE_D_PE_LW5 = 228,12,1,0 %;
macro KA0202_CPU$V_CBE_D_PE_LW7 = 228,13,1,0 %;
macro KA0202_CPU$V_CBE_UNDEFINED = 228,14,1,0 %;
macro KA0202_CPU$V_CBE_UNDEFINED2 = 228,15,1,0 %;
macro KA0202_CPU$V_CBE_MCOUNT_H = 228,25,6,0 %;
literal KA0202_CPU$S_CBE_MCOUNT_H = 6;
macro KA0202_CPU$V_CBE_MADR_VALID_H = 228,31,1,0 %;
macro KA0202_CPU$b_fill13g = 232,0,0,1 %;
literal KA0202_CPU$s_fill13g = 24;
macro KA0202_CPU$Q_CBEAL = 256,0,0,1 %;
literal KA0202_CPU$S_CBEAL = 8;
macro KA0202_CPU$V_CBEAL_SBO1 = 256,0,2,0 %;
literal KA0202_CPU$S_CBEAL_SBO1 = 2;
macro KA0202_CPU$V_CBEAL_ADDR_CAD_L = 256,2,30,0 %;
literal KA0202_CPU$S_CBEAL_ADDR_CAD_L = 30;
macro KA0202_CPU$V_CBEAL_SBO2 = 260,0,2,0 %;
literal KA0202_CPU$S_CBEAL_SBO2 = 2;
macro KA0202_CPU$V_CBEAL_ADDR_CAD_H = 260,2,30,0 %;
literal KA0202_CPU$S_CBEAL_ADDR_CAD_H = 30;
macro KA0202_CPU$b_fill13h = 264,0,0,1 %;
literal KA0202_CPU$s_fill13h = 24;
macro KA0202_CPU$Q_CBEAH = 288,0,0,1 %;
literal KA0202_CPU$S_CBEAH = 8;
macro KA0202_CPU$V_CBEAH_SBO1 = 288,0,2,0 %;
literal KA0202_CPU$S_CBEAH_SBO1 = 2;
macro KA0202_CPU$V_CBEAH_EA_L = 288,2,16,0 %;
literal KA0202_CPU$S_CBEAH_EA_L = 16;
macro KA0202_CPU$V_CBEAH_T_TYPE_L = 288,18,3,0 %;
literal KA0202_CPU$S_CBEAH_T_TYPE_L = 3;
macro KA0202_CPU$V_CBEAH_CMDR_ID_L = 288,21,3,0 %;
literal KA0202_CPU$S_CBEAH_CMDR_ID_L = 3;
macro KA0202_CPU$V_CBEAH_SBO2 = 288,24,8,0 %;
literal KA0202_CPU$S_CBEAH_SBO2 = 8;
macro KA0202_CPU$V_CBEAH_SBO3 = 292,0,2,0 %;
literal KA0202_CPU$S_CBEAH_SBO3 = 2;
macro KA0202_CPU$V_CBEAH_EA_H = 292,2,16,0 %;
literal KA0202_CPU$S_CBEAH_EA_H = 16;
macro KA0202_CPU$V_CBEAH_T_TYPE_H = 292,18,3,0 %;
literal KA0202_CPU$S_CBEAH_T_TYPE_H = 3;
macro KA0202_CPU$V_CBEAH_CMDR_ID_H = 292,21,3,0 %;
literal KA0202_CPU$S_CBEAH_CMDR_ID_H = 3;
macro KA0202_CPU$V_CBEAH_SBO4 = 292,24,8,0 %;
literal KA0202_CPU$S_CBEAH_SBO4 = 8;
macro KA0202_CPU$b_fill13 = 296,0,0,1 %;
literal KA0202_CPU$s_fill13 = 24;
macro KA0202_CPU$Q_PMBX = 320,0,0,1 %;
literal KA0202_CPU$S_PMBX = 8;
macro KA0202_CPU$b_fill13j = 328,0,0,1 %;
literal KA0202_CPU$s_fill13j = 24;
macro KA0202_CPU$Q_IPIR = 352,0,0,1 %;
literal KA0202_CPU$S_IPIR = 8;
macro KA0202_CPU$V_IPIR_UNDEFINED = 352,0,1,0 %;
macro KA0202_CPU$V_IPIR_REQ_INT_CPU = 356,0,1,0 %;
macro KA0202_CPU$b_fill13k = 360,0,0,1 %;
literal KA0202_CPU$s_fill13k = 24;
macro KA0202_CPU$Q_SIC = 384,0,0,1 %;
literal KA0202_CPU$S_SIC = 8;
macro KA0202_CPU$V_SIC_UNDEFINED = 384,0,1,0 %;
macro KA0202_CPU$V_SIC_UNDEFINED1 = 384,1,1,0 %;
macro KA0202_CPU$V_SIC_EIC = 384,2,1,0 %;
macro KA0202_CPU$V_SIC_IT_ICLEAR = 388,0,1,0 %;
macro KA0202_CPU$V_SIC_SYS_EVT_CLR = 388,1,1,0 %;
macro KA0202_CPU$V_SIC_UNDEFINED2 = 388,2,1,0 %;
macro KA0202_CPU$b_fill13l = 392,0,0,1 %;
literal KA0202_CPU$s_fill13l = 24;
macro KA0202_CPU$Q_ADLK = 416,0,0,1 %;
literal KA0202_CPU$S_ADLK = 8;
macro KA0202_CPU$V_ADLK_LA_V_L = 416,0,1,0 %;
macro KA0202_CPU$V_ADLK_LA_L = 416,3,29,0 %;
literal KA0202_CPU$S_ADLK_LA_L = 29;
macro KA0202_CPU$V_ADLK_LA_V_H = 420,0,1,0 %;
macro KA0202_CPU$V_ADLK_LA_H = 420,3,29,0 %;
literal KA0202_CPU$S_ADLK_LA_H = 29;
macro KA0202_CPU$b_fill13m = 424,0,0,1 %;
literal KA0202_CPU$s_fill13m = 24;
macro KA0202_CPU$Q_MADRL = 448,0,0,1 %;
literal KA0202_CPU$S_MADRL = 8;
macro KA0202_CPU$V_MADRL_VALID_L = 448,0,1,0 %;
macro KA0202_CPU$V_MADRL_T_TYPE_L = 448,1,1,0 %;
macro KA0202_CPU$V_MADRL_ADDRESS_L = 448,2,30,0 %;
literal KA0202_CPU$S_MADRL_ADDRESS_L = 30;
macro KA0202_CPU$V_MADRL_VALID_H = 452,0,1,0 %;
macro KA0202_CPU$V_MADRL_T_TYPE_H = 452,1,1,0 %;
macro KA0202_CPU$V_MADRL_ADDRESS_H = 452,2,30,0 %;
literal KA0202_CPU$S_MADRL_ADDRESS_H = 30;
macro KA0202_CPU$b_fill13n = 456,0,0,1 %;
literal KA0202_CPU$s_fill13n = 24;
macro KA0202_CPU$Q_UNIMP = 480,0,0,1 %;
literal KA0202_CPU$S_UNIMP = 8;
macro KA0202_CPU$b_fill15 = 488,0,0,1 %;
literal KA0202_CPU$s_fill15 = 7704;
literal KA0202_CMM$M_CME_ES1 = %X'1';
literal KA0202_CMM$M_CME_SE1 = %X'2';
literal KA0202_CMM$M_CME_CA_PE1 = %X'4';
literal KA0202_CMM$M_CME_MCA_PE1 = %X'8';
literal KA0202_CMM$M_CME_WD_PE1 = %X'10';
literal KA0202_CMM$M_CME_MWD_PE1 = %X'20';
literal KA0202_CMM$M_CME_CA_PE_LW0 = %X'100';
literal KA0202_CMM$M_CME_CA_PE_LW2 = %X'200';
literal KA0202_CMM$M_CME_D_PE_LW0 = %X'400';
literal KA0202_CMM$M_CME_D_PE_LW2 = %X'800';
literal KA0202_CMM$M_CME_D_PE_LW4 = %X'1000';
literal KA0202_CMM$M_CME_D_PE_LW6 = %X'2000';
literal KA0202_CMM$M_CME_EUE1 = %X'10000';
literal KA0202_CMM$M_CME_MEUE1 = %X'20000';
literal KA0202_CMM$M_CME_ECE1 = %X'40000';
literal KA0202_CMM$M_CME_MECE1 = %X'80000';
literal KA0202_CMM$M_CME_ES2 = %X'100000000';
literal KA0202_CMM$M_CME_SE2 = %X'200000000';
literal KA0202_CMM$M_CME_CA_PE2 = %X'400000000';
literal KA0202_CMM$M_CME_MCA_PE2 = %X'800000000';
literal KA0202_CMM$M_CME_WD_PE2 = %X'1000000000';
literal KA0202_CMM$M_CME_MWD_PE2 = %X'2000000000';
literal KA0202_CMM$M_CME_CA_PE_LW1 = %X'10000000000';
literal KA0202_CMM$M_CME_CA_PE_LW3 = %X'20000000000';
literal KA0202_CMM$M_CME_D_PE_LW1 = %X'40000000000';
literal KA0202_CMM$M_CME_D_PE_LW3 = %X'80000000000';
literal KA0202_CMM$M_CME_D_PE_LW5 = %X'100000000000';
literal KA0202_CMM$M_CME_D_PE_LW7 = %X'200000000000';
literal KA0202_CMM$M_CME_EUE2 = %X'1000000000000';
literal KA0202_CMM$M_CME_MEUE2 = %X'2000000000000';
literal KA0202_CMM$M_CME_ECE2 = %X'4000000000000';
literal KA0202_CMM$M_CME_MECE2 = %X'8000000000000';
literal KA0202_CMM$M_CNFG_MOD_ID1 = %X'3';
literal KA0202_CMM$M_CNFG_MOD_SIZE1 = %X'70';
literal KA0202_CMM$M_CNFG_EMD1 = %X'100';
literal KA0202_CMM$M_CNFG_INTR_MODE1 = %X'C0000';
literal KA0202_CMM$M_CNFG_INTR_UNIT1 = %X'300000';
literal KA0202_CMM$M_CNFG_BASE_ADDR1 = %X'7FC00000';
literal KA0202_CMM$M_CNFG_MEM_ENB1 = %X'80000000';
literal KA0202_CMM$M_CNFG_MOD_ID2 = %X'300000000';
literal KA0202_CMM$M_CNFG_MOD_SIZE2 = %X'7000000000';
literal KA0202_CMM$M_CNFG_EMD2 = %X'10000000000';
literal KA0202_CMM$M_CNFG_INTR_MODE2 = %X'C000000000000';
literal KA0202_CMM$M_CNFG_INTR_UNIT2 = %X'30000000000000';
literal KA0202_CMM$M_CNFG_BASE_ADDR2 = %X'7FC0000000000000';
literal KA0202_CMM$M_CNFG_MEM_ENB2 = %X'8000000000000000';
literal KA0202_CMM$M_EDC1_READ_CBITS1 = %X'FFF';
literal KA0202_CMM$M_EDC1_WR_CBITS1 = %X'FFF0000';
literal KA0202_CMM$M_EDC1_READ_CBITS2 = %X'FFF00000000';
literal KA0202_CMM$M_EDC1_WR_CBITS2 = %X'FFF000000000000';
literal KA0202_CMM$M_EDC2_SYNDROME1 = %X'FFF';
literal KA0202_CMM$M_EDC2_SYNDROME2 = %X'FFF00000000';
literal KA0202_CMM$M_EDCTL_SRB1 = %X'FFF';
literal KA0202_CMM$M_EDCTL_USCB1 = %X'1000';
literal KA0202_CMM$M_EDCTL_USWCB1 = %X'2000';
literal KA0202_CMM$M_EDCTL_DIPC1 = %X'4000';
literal KA0202_CMM$M_EDCTL_ENB_ES1 = %X'8000';
literal KA0202_CMM$M_EDCTL_SWCB1 = %X'FFF0000';
literal KA0202_CMM$M_EDCTL_CRDP1 = %X'10000000';
literal KA0202_CMM$M_EDCTL_ENB_CRDR1 = %X'20000000';
literal KA0202_CMM$M_EDCTL_DEDCCORR1 = %X'40000000';
literal KA0202_CMM$M_EDCTL_DEDCREPORT1 = %X'80000000';
literal KA0202_CMM$M_EDCTL_SRB2 = %X'FFF00000000';
literal KA0202_CMM$M_EDCTL_USCB2 = %X'100000000000';
literal KA0202_CMM$M_EDCTL_USWCB2 = %X'200000000000';
literal KA0202_CMM$M_EDCTL_DIPC2 = %X'400000000000';
literal KA0202_CMM$M_EDCTL_ENB_ES2 = %X'800000000000';
literal KA0202_CMM$M_EDCTL_SWCB2 = %X'FFF000000000000';
literal KA0202_CMM$M_EDCTL_CRDP2 = %X'1000000000000000';
literal KA0202_CMM$M_EDCTL_ENB_CRDR2 = %X'2000000000000000';
literal KA0202_CMM$M_EDCTL_DEDCCORR2 = %X'4000000000000000';
literal KA0202_CMM$M_EDCTL_DEDCREPORT2 = %X'8000000000000000';
literal KA0202_CMM$M_SBCTRL_DSD1 = %X'1';
literal KA0202_CMM$M_SBCTRL_DSH1 = %X'2';
literal KA0202_CMM$M_SBCTRL_DSF1 = %X'4';
literal KA0202_CMM$M_SBCTRL_DSI1 = %X'8';
literal KA0202_CMM$M_SBCTRL_ERWD1 = %X'10';
literal KA0202_CMM$M_SBCTRL_FHB1 = %X'20';
literal KA0202_CMM$M_SBCTRL_DSD2 = %X'100000000';
literal KA0202_CMM$M_SBCTRL_DSH2 = %X'200000000';
literal KA0202_CMM$M_SBCTRL_DSF2 = %X'400000000';
literal KA0202_CMM$M_SBCTRL_DSI2 = %X'800000000';
literal KA0202_CMM$M_SBCTRL_ERWD2 = %X'1000000000';
literal KA0202_CMM$M_SBCTRL_FHB2 = %X'2000000000';
literal KA0202_CMM$M_RCTRL_RC1 = %X'FF';
literal KA0202_CMM$M_RCTRL_REF_ENB = %X'100';
literal KA0202_CMM$M_RCTRL_RC2 = %X'FF00000000';
literal KA0202_CMM$M_RCTRL_REF_ENB2 = %X'10000000000';
literal KA0202_CMM$M_CRDCTL_SM1 = %X'FFF';
literal KA0202_CMM$M_CRDCTL_BS1 = %X'3000';
literal KA0202_CMM$M_CRDCTL_CFE1 = %X'4000';
literal KA0202_CMM$M_CRDCTL_SM2 = %X'FFF00000000';
literal KA0202_CMM$M_CRDCTL_BS2 = %X'300000000000';
literal KA0202_CMM$M_CRDCTL_CFE2 = %X'400000000000';
literal KA0202_CMM$K_LENGTH = 8192;
literal KA0202_CMM$S_CMMDEF = 8192;     !  Old size name, synonym for  KA0202_CMM$S_KA0202CMM
literal KA0202_CMM$S_KA0202CMM = 8192;
macro KA0202_CMM$Q_CME = 0,0,0,1 %;
literal KA0202_CMM$S_CME = 8;
macro KA0202_CMM$V_CME_ES1 = 0,0,1,0 %;
macro KA0202_CMM$V_CME_SE1 = 0,1,1,0 %;
macro KA0202_CMM$V_CME_CA_PE1 = 0,2,1,0 %;
macro KA0202_CMM$V_CME_MCA_PE1 = 0,3,1,0 %;
macro KA0202_CMM$V_CME_WD_PE1 = 0,4,1,0 %;
macro KA0202_CMM$V_CME_MWD_PE1 = 0,5,1,0 %;
macro KA0202_CMM$V_CME_CA_PE_LW0 = 0,8,1,0 %;
macro KA0202_CMM$V_CME_CA_PE_LW2 = 0,9,1,0 %;
macro KA0202_CMM$V_CME_D_PE_LW0 = 0,10,1,0 %;
macro KA0202_CMM$V_CME_D_PE_LW2 = 0,11,1,0 %;
macro KA0202_CMM$V_CME_D_PE_LW4 = 0,12,1,0 %;
macro KA0202_CMM$V_CME_D_PE_LW6 = 0,13,1,0 %;
macro KA0202_CMM$V_CME_EUE1 = 0,16,1,0 %;
macro KA0202_CMM$V_CME_MEUE1 = 0,17,1,0 %;
macro KA0202_CMM$V_CME_ECE1 = 0,18,1,0 %;
macro KA0202_CMM$V_CME_MECE1 = 0,19,1,0 %;
macro KA0202_CMM$V_CME_ES2 = 4,0,1,0 %;
macro KA0202_CMM$V_CME_SE2 = 4,1,1,0 %;
macro KA0202_CMM$V_CME_CA_PE2 = 4,2,1,0 %;
macro KA0202_CMM$V_CME_MCA_PE2 = 4,3,1,0 %;
macro KA0202_CMM$V_CME_WD_PE2 = 4,4,1,0 %;
macro KA0202_CMM$V_CME_MWD_PE2 = 4,5,1,0 %;
macro KA0202_CMM$V_CME_CA_PE_LW1 = 4,8,1,0 %;
macro KA0202_CMM$V_CME_CA_PE_LW3 = 4,9,1,0 %;
macro KA0202_CMM$V_CME_D_PE_LW1 = 4,10,1,0 %;
macro KA0202_CMM$V_CME_D_PE_LW3 = 4,11,1,0 %;
macro KA0202_CMM$V_CME_D_PE_LW5 = 4,12,1,0 %;
macro KA0202_CMM$V_CME_D_PE_LW7 = 4,13,1,0 %;
macro KA0202_CMM$V_CME_EUE2 = 4,16,1,0 %;
macro KA0202_CMM$V_CME_MEUE2 = 4,17,1,0 %;
macro KA0202_CMM$V_CME_ECE2 = 4,18,1,0 %;
macro KA0202_CMM$V_CME_MECE2 = 4,19,1,0 %;
macro KA0202_CMM$b_fill_1 = 8,0,0,1 %;
literal KA0202_CMM$s_fill_1 = 24;
macro KA0202_CMM$Q_TRAP1 = 32,0,0,1 %;
literal KA0202_CMM$S_TRAP1 = 8;
macro KA0202_CMM$L_TRAP1_L = 32,0,32,0 %;
macro KA0202_CMM$L_TRAP1_H = 36,0,32,0 %;
macro KA0202_CMM$b_fill_2 = 40,0,0,1 %;
literal KA0202_CMM$s_fill_2 = 24;
macro KA0202_CMM$Q_TRAP2 = 64,0,0,1 %;
literal KA0202_CMM$S_TRAP2 = 8;
macro KA0202_CMM$L_TRAP2_L = 64,0,32,0 %;
macro KA0202_CMM$L_TRAP2_H = 68,0,32,0 %;
macro KA0202_CMM$b_fill_3 = 72,0,0,1 %;
literal KA0202_CMM$s_fill_3 = 24;
macro KA0202_CMM$Q_CNFG = 96,0,0,1 %;
literal KA0202_CMM$S_CNFG = 8;
macro KA0202_CMM$V_CNFG_MOD_ID1 = 96,0,2,0 %;
literal KA0202_CMM$S_CNFG_MOD_ID1 = 2;
macro KA0202_CMM$V_CNFG_MOD_SIZE1 = 96,4,3,0 %;
literal KA0202_CMM$S_CNFG_MOD_SIZE1 = 3;
macro KA0202_CMM$V_CNFG_EMD1 = 96,8,1,0 %;
macro KA0202_CMM$V_CNFG_INTR_MODE1 = 96,18,2,0 %;
literal KA0202_CMM$S_CNFG_INTR_MODE1 = 2;
macro KA0202_CMM$V_CNFG_INTR_UNIT1 = 96,20,2,0 %;
literal KA0202_CMM$S_CNFG_INTR_UNIT1 = 2;
macro KA0202_CMM$V_CNFG_BASE_ADDR1 = 96,22,9,0 %;
literal KA0202_CMM$S_CNFG_BASE_ADDR1 = 9;
macro KA0202_CMM$V_CNFG_MEM_ENB1 = 96,31,1,0 %;
macro KA0202_CMM$V_CNFG_MOD_ID2 = 100,0,2,0 %;
literal KA0202_CMM$S_CNFG_MOD_ID2 = 2;
macro KA0202_CMM$V_CNFG_MOD_SIZE2 = 100,4,3,0 %;
literal KA0202_CMM$S_CNFG_MOD_SIZE2 = 3;
macro KA0202_CMM$V_CNFG_EMD2 = 100,8,1,0 %;
macro KA0202_CMM$V_CNFG_INTR_MODE2 = 100,18,2,0 %;
literal KA0202_CMM$S_CNFG_INTR_MODE2 = 2;
macro KA0202_CMM$V_CNFG_INTR_UNIT2 = 100,20,2,0 %;
literal KA0202_CMM$S_CNFG_INTR_UNIT2 = 2;
macro KA0202_CMM$V_CNFG_BASE_ADDR2 = 100,22,9,0 %;
literal KA0202_CMM$S_CNFG_BASE_ADDR2 = 9;
macro KA0202_CMM$V_CNFG_MEM_ENB2 = 100,31,1,0 %;
macro KA0202_CMM$b_fill_4 = 104,0,0,1 %;
literal KA0202_CMM$s_fill_4 = 24;
macro KA0202_CMM$Q_EDC1 = 128,0,0,1 %;
literal KA0202_CMM$S_EDC1 = 8;
macro KA0202_CMM$V_EDC1_READ_CBITS1 = 128,0,12,0 %;
literal KA0202_CMM$S_EDC1_READ_CBITS1 = 12;
macro KA0202_CMM$V_EDC1_WR_CBITS1 = 128,16,12,0 %;
literal KA0202_CMM$S_EDC1_WR_CBITS1 = 12;
macro KA0202_CMM$V_EDC1_READ_CBITS2 = 132,0,12,0 %;
literal KA0202_CMM$S_EDC1_READ_CBITS2 = 12;
macro KA0202_CMM$V_EDC1_WR_CBITS2 = 132,16,12,0 %;
literal KA0202_CMM$S_EDC1_WR_CBITS2 = 12;
macro KA0202_CMM$b_fill_5 = 136,0,0,1 %;
literal KA0202_CMM$s_fill_5 = 24;
macro KA0202_CMM$Q_EDC2 = 160,0,0,1 %;
literal KA0202_CMM$S_EDC2 = 8;
macro KA0202_CMM$V_EDC2_SYNDROME1 = 160,0,12,0 %;
literal KA0202_CMM$S_EDC2_SYNDROME1 = 12;
macro KA0202_CMM$V_EDC2_SYNDROME2 = 164,0,12,0 %;
literal KA0202_CMM$S_EDC2_SYNDROME2 = 12;
macro KA0202_CMM$b_fill_6 = 168,0,0,1 %;
literal KA0202_CMM$s_fill_6 = 24;
macro KA0202_CMM$Q_EDCTL = 192,0,0,1 %;
literal KA0202_CMM$S_EDCTL = 8;
macro KA0202_CMM$V_EDCTL_SRB1 = 192,0,12,0 %;
literal KA0202_CMM$S_EDCTL_SRB1 = 12;
macro KA0202_CMM$V_EDCTL_USCB1 = 192,12,1,0 %;
macro KA0202_CMM$V_EDCTL_USWCB1 = 192,13,1,0 %;
macro KA0202_CMM$V_EDCTL_DIPC1 = 192,14,1,0 %;
macro KA0202_CMM$V_EDCTL_ENB_ES1 = 192,15,1,0 %;
macro KA0202_CMM$V_EDCTL_SWCB1 = 192,16,12,0 %;
literal KA0202_CMM$S_EDCTL_SWCB1 = 12;
macro KA0202_CMM$V_EDCTL_CRDP1 = 192,28,1,0 %;
macro KA0202_CMM$V_EDCTL_ENB_CRDR1 = 192,29,1,0 %;
macro KA0202_CMM$V_EDCTL_DEDCCORR1 = 192,30,1,0 %;
macro KA0202_CMM$V_EDCTL_DEDCREPORT1 = 192,31,1,0 %;
macro KA0202_CMM$V_EDCTL_SRB2 = 196,0,12,0 %;
literal KA0202_CMM$S_EDCTL_SRB2 = 12;
macro KA0202_CMM$V_EDCTL_USCB2 = 196,12,1,0 %;
macro KA0202_CMM$V_EDCTL_USWCB2 = 196,13,1,0 %;
macro KA0202_CMM$V_EDCTL_DIPC2 = 196,14,1,0 %;
macro KA0202_CMM$V_EDCTL_ENB_ES2 = 196,15,1,0 %;
macro KA0202_CMM$V_EDCTL_SWCB2 = 196,16,12,0 %;
literal KA0202_CMM$S_EDCTL_SWCB2 = 12;
macro KA0202_CMM$V_EDCTL_CRDP2 = 196,28,1,0 %;
macro KA0202_CMM$V_EDCTL_ENB_CRDR2 = 196,29,1,0 %;
macro KA0202_CMM$V_EDCTL_DEDCCORR2 = 196,30,1,0 %;
macro KA0202_CMM$V_EDCTL_DEDCREPORT2 = 196,31,1,0 %;
macro KA0202_CMM$b_fill_7 = 200,0,0,1 %;
literal KA0202_CMM$s_fill_7 = 24;
macro KA0202_CMM$Q_SBCTRL = 224,0,0,1 %;
literal KA0202_CMM$S_SBCTRL = 8;
macro KA0202_CMM$V_SBCTRL_DSD1 = 224,0,1,0 %;
macro KA0202_CMM$V_SBCTRL_DSH1 = 224,1,1,0 %;
macro KA0202_CMM$V_SBCTRL_DSF1 = 224,2,1,0 %;
macro KA0202_CMM$V_SBCTRL_DSI1 = 224,3,1,0 %;
macro KA0202_CMM$V_SBCTRL_ERWD1 = 224,4,1,0 %;
macro KA0202_CMM$V_SBCTRL_FHB1 = 224,5,1,0 %;
macro KA0202_CMM$V_SBCTRL_DSD2 = 228,0,1,0 %;
macro KA0202_CMM$V_SBCTRL_DSH2 = 228,1,1,0 %;
macro KA0202_CMM$V_SBCTRL_DSF2 = 228,2,1,0 %;
macro KA0202_CMM$V_SBCTRL_DSI2 = 228,3,1,0 %;
macro KA0202_CMM$V_SBCTRL_ERWD2 = 228,4,1,0 %;
macro KA0202_CMM$V_SBCTRL_FHB2 = 228,5,1,0 %;
macro KA0202_CMM$b_fill_8 = 232,0,0,1 %;
literal KA0202_CMM$s_fill_8 = 24;
macro KA0202_CMM$Q_RCTRL = 256,0,0,1 %;
literal KA0202_CMM$S_RCTRL = 8;
macro KA0202_CMM$V_RCTRL_RC1 = 256,0,8,0 %;
literal KA0202_CMM$S_RCTRL_RC1 = 8;
macro KA0202_CMM$V_RCTRL_REF_ENB = 256,8,1,0 %;
macro KA0202_CMM$V_RCTRL_RC2 = 260,0,8,0 %;
literal KA0202_CMM$S_RCTRL_RC2 = 8;
macro KA0202_CMM$V_RCTRL_REF_ENB2 = 260,8,1,0 %;
macro KA0202_CMM$b_fill_9 = 264,0,0,1 %;
literal KA0202_CMM$s_fill_9 = 24;
macro KA0202_CMM$Q_CRDCTL = 288,0,0,1 %;
literal KA0202_CMM$S_CRDCTL = 8;
macro KA0202_CMM$V_CRDCTL_SM1 = 288,0,12,0 %;
literal KA0202_CMM$S_CRDCTL_SM1 = 12;
macro KA0202_CMM$V_CRDCTL_BS1 = 288,12,2,0 %;
literal KA0202_CMM$S_CRDCTL_BS1 = 2;
macro KA0202_CMM$V_CRDCTL_CFE1 = 288,14,1,0 %;
macro KA0202_CMM$V_CRDCTL_SM2 = 292,0,12,0 %;
literal KA0202_CMM$S_CRDCTL_SM2 = 12;
macro KA0202_CMM$V_CRDCTL_BS2 = 292,12,2,0 %;
literal KA0202_CMM$S_CRDCTL_BS2 = 2;
macro KA0202_CMM$V_CRDCTL_CFE2 = 292,14,1,0 %;
macro KA0202_CMM$b_fill_10 = 296,0,0,1 %;
literal KA0202_CMM$s_fill_10 = 24;
macro KA0202_CMM$Q_CSR10 = 320,0,0,1 %;
literal KA0202_CMM$S_CSR10 = 8;
macro KA0202_CMM$b_fill_11 = 328,0,0,1 %;
literal KA0202_CMM$s_fill_11 = 24;
macro KA0202_CMM$Q_CSR11 = 352,0,0,1 %;
literal KA0202_CMM$S_CSR11 = 8;
macro KA0202_CMM$b_fill_12 = 360,0,0,1 %;
literal KA0202_CMM$s_fill_12 = 24;
macro KA0202_CMM$Q_CSR12 = 384,0,0,1 %;
literal KA0202_CMM$S_CSR12 = 8;
macro KA0202_CMM$b_fill_13 = 392,0,0,1 %;
literal KA0202_CMM$s_fill_13 = 24;
macro KA0202_CMM$Q_CSR13 = 416,0,0,1 %;
literal KA0202_CMM$S_CSR13 = 8;
macro KA0202_CMM$b_fill_14 = 424,0,0,1 %;
literal KA0202_CMM$s_fill_14 = 24;
macro KA0202_CMM$Q_CSR14 = 448,0,0,1 %;
literal KA0202_CMM$S_CSR14 = 8;
macro KA0202_CMM$b_fill_15 = 456,0,0,1 %;
literal KA0202_CMM$s_fill_15 = 24;
macro KA0202_CMM$Q_CSR15 = 480,0,0,1 %;
literal KA0202_CMM$S_CSR15 = 8;
macro KA0202_CMM$b_fill17 = 488,0,0,1 %;
literal KA0202_CMM$s_fill17 = 7704;
 
!*** MODULE $KA0302DEF ***
literal KA0302$M_SLOT0_LDEV_DTYPE = %X'FFFF';
literal KA0302$M_SLOT0_LDEV_DREV = %X'FFFF0000';
literal KA0302$M_SLOT0_LBER_E = %X'1';
literal KA0302$M_SLOT0_LBER_UCE = %X'2';
literal KA0302$M_SLOT0_LBER_UCE2 = %X'4';
literal KA0302$M_SLOT0_LBER_CE = %X'8';
literal KA0302$M_SLOT0_LBER_CE2 = %X'10';
literal KA0302$M_SLOT0_LBER_CPE = %X'20';
literal KA0302$M_SLOT0_LBER_CPE2 = %X'40';
literal KA0302$M_SLOT0_LBER_CDPE = %X'80';
literal KA0302$M_SLOT0_LBER_CDPE2 = %X'100';
literal KA0302$M_SLOT0_LBER_TDE = %X'200';
literal KA0302$M_SLOT0_LBER_STE = %X'400';
literal KA0302$M_SLOT0_LBER_CNFE = %X'800';
literal KA0302$M_SLOT0_LBER_NXAE = %X'1000';
literal KA0302$M_SLOT0_LBER_CAE = %X'2000';
literal KA0302$M_SLOT0_LBER_SHE = %X'4000';
literal KA0302$M_SLOT0_LBER_DIE = %X'8000';
literal KA0302$M_SLOT0_LBER_DTCE = %X'10000';
literal KA0302$M_SLOT0_LBER_CTCE = %X'20000';
literal KA0302$M_SLOT0_LBER_NSES = %X'40000';
literal KA0302$M_SLOT0_LCNR_CEEN = %X'1';
literal KA0302$M_SLOT0_LCNR_RSTSTAT = %X'10000000';
literal KA0302$M_SLOT0_LCNR_NHALT = %X'20000000';
literal KA0302$M_SLOT0_LCNR_NRST = %X'40000000';
literal KA0302$M_SLOT0_LCNR_STF = %X'80000000';
literal KA0302$M_SLOT0_IBR_RCV_SDAT = %X'1';
literal KA0302$M_SLOT0_IBR_XMT_SDAT = %X'2';
literal KA0302$M_SLOT0_IBR_SCLK = %X'4';
literal KA0302$M_SLOT0_LMMR0_EN = %X'1';
literal KA0302$M_SLOT0_LMMR0_INT = %X'6';
literal KA0302$M_SLOT0_LMMR0_IA = %X'18';
literal KA0302$M_SLOT0_LMMR0_AW = %X'1E0';
literal KA0302$M_SLOT0_LMMR0_NBANKS = %X'600';
literal KA0302$M_SLOT0_LMMR0_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT0_LMMR1_EN = %X'1';
literal KA0302$M_SLOT0_LMMR1_INT = %X'6';
literal KA0302$M_SLOT0_LMMR1_IA = %X'18';
literal KA0302$M_SLOT0_LMMR1_AW = %X'1E0';
literal KA0302$M_SLOT0_LMMR1_NBANKS = %X'600';
literal KA0302$M_SLOT0_LMMR1_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT0_LMMR2_EN = %X'1';
literal KA0302$M_SLOT0_LMMR2_INT = %X'6';
literal KA0302$M_SLOT0_LMMR2_IA = %X'18';
literal KA0302$M_SLOT0_LMMR2_AW = %X'1E0';
literal KA0302$M_SLOT0_LMMR2_NBANKS = %X'600';
literal KA0302$M_SLOT0_LMMR2_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT0_LMMR3_EN = %X'1';
literal KA0302$M_SLOT0_LMMR3_INT = %X'6';
literal KA0302$M_SLOT0_LMMR3_IA = %X'18';
literal KA0302$M_SLOT0_LMMR3_AW = %X'1E0';
literal KA0302$M_SLOT0_LMMR3_NBANKS = %X'600';
literal KA0302$M_SLOT0_LMMR3_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT0_LMMR4_EN = %X'1';
literal KA0302$M_SLOT0_LMMR4_INT = %X'6';
literal KA0302$M_SLOT0_LMMR4_IA = %X'18';
literal KA0302$M_SLOT0_LMMR4_AW = %X'1E0';
literal KA0302$M_SLOT0_LMMR4_NBANKS = %X'600';
literal KA0302$M_SLOT0_LMMR4_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT0_LMMR5_EN = %X'1';
literal KA0302$M_SLOT0_LMMR5_INT = %X'6';
literal KA0302$M_SLOT0_LMMR5_IA = %X'18';
literal KA0302$M_SLOT0_LMMR5_AW = %X'1E0';
literal KA0302$M_SLOT0_LMMR5_NBANKS = %X'600';
literal KA0302$M_SLOT0_LMMR5_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT0_LMMR6_EN = %X'1';
literal KA0302$M_SLOT0_LMMR6_INT = %X'6';
literal KA0302$M_SLOT0_LMMR6_IA = %X'18';
literal KA0302$M_SLOT0_LMMR6_AW = %X'1E0';
literal KA0302$M_SLOT0_LMMR6_NBANKS = %X'600';
literal KA0302$M_SLOT0_LMMR6_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT0_LMMR7_EN = %X'1';
literal KA0302$M_SLOT0_LMMR7_INT = %X'6';
literal KA0302$M_SLOT0_LMMR7_IA = %X'18';
literal KA0302$M_SLOT0_LMMR7_AW = %X'1E0';
literal KA0302$M_SLOT0_LMMR7_NBANKS = %X'600';
literal KA0302$M_SLOT0_LMMR7_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT0_LBESR0_SYNDROME = %X'7F';
literal KA0302$M_SLOT0_LBESR1_SYNDROME = %X'7F';
literal KA0302$M_SLOT0_LBESR2_SYNDROME = %X'7F';
literal KA0302$M_SLOT0_LBESR3_SYNDROME = %X'7F';
literal KA0302$M_SLOT0_LBECR1_CA = %X'7F';
literal KA0302$M_SLOT0_LBECR1_CID = %X'780';
literal KA0302$M_SLOT0_LBECR1_RID = %X'7800';
literal KA0302$M_SLOT0_LBECR1_CNF = %X'8000';
literal KA0302$M_SLOT0_LBECR1_SHARED = %X'10000';
literal KA0302$M_SLOT0_LBECR1_DIRTY = %X'20000';
literal KA0302$M_SLOT0_LBECR1_DCYCLE = %X'C0000';
literal KA0302$M_SLOT0_MCR_DTYPE = %X'1';
literal KA0302$M_SLOT0_MCR_STRN = %X'C';
literal KA0302$M_SLOT0_AMR_E = %X'1';
literal KA0302$M_SLOT0_AMR_INTL = %X'6';
literal KA0302$M_SLOT0_AMR_IA = %X'18';
literal KA0302$M_SLOT0_AMR_AW = %X'1E0';
literal KA0302$M_SLOT0_AMR_NBANKS = %X'600';
literal KA0302$M_SLOT0_AMR_MADR = %X'FFFE0000';
literal KA0302$M_SLOT0_MERA_CER = %X'1';
literal KA0302$M_SLOT0_MERA_UCER = %X'2';
literal KA0302$M_SLOT0_MERA_MULE = %X'4';
literal KA0302$M_SLOT0_MERA_APER = %X'8';
literal KA0302$M_SLOT0_MERA_CERA = %X'10';
literal KA0302$M_SLOT0_MERA_CERB = %X'20';
literal KA0302$M_SLOT0_MERA_FSTR = %X'1C0';
literal KA0302$M_SLOT0_MERA_BNKER = %X'200';
literal KA0302$M_SLOT0_MERA_UCERA = %X'400';
literal KA0302$M_SLOT0_MERA_UCERB = %X'800';
literal KA0302$M_SLOT0_MSYNDA_SYND = %X'FF';
literal KA0302$M_SLOT0_MDRA_FCBS = %X'1';
literal KA0302$M_SLOT0_MDRA_DRDC = %X'2';
literal KA0302$M_SLOT0_MDRA_DWDC = %X'4';
literal KA0302$M_SLOT0_MDRA_BPAS = %X'8';
literal KA0302$M_SLOT0_MDRA_EXST = %X'10';
literal KA0302$M_SLOT0_MDRA_STPM = %X'20';
literal KA0302$M_SLOT0_MDRA_MODE = %X'40';
literal KA0302$M_SLOT0_MDRA_IGSB = %X'80';
literal KA0302$M_SLOT0_MDRA_FRPE = %X'100';
literal KA0302$M_SLOT0_MDRA_FCPE = %X'200';
literal KA0302$M_SLOT0_MDRA_DCRD = %X'8000000';
literal KA0302$M_SLOT0_MDRA_RFR = %X'30000000';
literal KA0302$M_SLOT0_MDRA_BRFSH = %X'40000000';
literal KA0302$M_SLOT0_MDRA_DRFSH = %X'80000000';
literal KA0302$M_SLOT0_MCBSA_SCB = %X'FF';
literal KA0302$M_SLOT0_MERB_CER = %X'1';
literal KA0302$M_SLOT0_MERB_UCER = %X'2';
literal KA0302$M_SLOT0_MERB_MULE = %X'4';
literal KA0302$M_SLOT0_MERB_APER = %X'8';
literal KA0302$M_SLOT0_MSYNDB_SYND = %X'FF';
literal KA0302$M_SLOT0_MDRB_FCBS = %X'1';
literal KA0302$M_SLOT0_MDRB_DRDC = %X'2';
literal KA0302$M_SLOT0_MDRB_DWDC = %X'4';
literal KA0302$M_SLOT0_MDRB_BPAS = %X'8';
literal KA0302$M_SLOT0_MDRB_EXST = %X'10';
literal KA0302$M_SLOT0_MDRB_STPM = %X'20';
literal KA0302$M_SLOT0_MDRB_MODE = %X'40';
literal KA0302$M_SLOT0_MDRB_IGSB = %X'80';
literal KA0302$M_SLOT0_MCBSB_SCB = %X'FF';
literal KA0302$K_LSB_SLOT_SIZE = 24576;
literal KA0302$M_SLOT1_LDEV_DTYPE = %X'FFFF';
literal KA0302$M_SLOT1_LDEV_DREV = %X'FFFF0000';
literal KA0302$M_SLOT1_LBER_E = %X'1';
literal KA0302$M_SLOT1_LBER_UCE = %X'2';
literal KA0302$M_SLOT1_LBER_UCE2 = %X'4';
literal KA0302$M_SLOT1_LBER_CE = %X'8';
literal KA0302$M_SLOT1_LBER_CE2 = %X'10';
literal KA0302$M_SLOT1_LBER_CPE = %X'20';
literal KA0302$M_SLOT1_LBER_CPE2 = %X'40';
literal KA0302$M_SLOT1_LBER_CDPE = %X'80';
literal KA0302$M_SLOT1_LBER_CDPE2 = %X'100';
literal KA0302$M_SLOT1_LBER_TDE = %X'200';
literal KA0302$M_SLOT1_LBER_STE = %X'400';
literal KA0302$M_SLOT1_LBER_CNFE = %X'800';
literal KA0302$M_SLOT1_LBER_NXAE = %X'1000';
literal KA0302$M_SLOT1_LBER_CAE = %X'2000';
literal KA0302$M_SLOT1_LBER_SHE = %X'4000';
literal KA0302$M_SLOT1_LBER_DIE = %X'8000';
literal KA0302$M_SLOT1_LBER_DTCE = %X'10000';
literal KA0302$M_SLOT1_LBER_CTCE = %X'20000';
literal KA0302$M_SLOT1_LBER_NSES = %X'40000';
literal KA0302$M_SLOT1_LCNR_CEEN = %X'1';
literal KA0302$M_SLOT1_LCNR_RSTSTAT = %X'10000000';
literal KA0302$M_SLOT1_LCNR_NHALT = %X'20000000';
literal KA0302$M_SLOT1_LCNR_NRST = %X'40000000';
literal KA0302$M_SLOT1_LCNR_STF = %X'80000000';
literal KA0302$M_SLOT1_IBR_RCV_SDAT = %X'1';
literal KA0302$M_SLOT1_IBR_XMT_SDAT = %X'2';
literal KA0302$M_SLOT1_IBR_SCLK = %X'4';
literal KA0302$M_SLOT1_LMMR0_EN = %X'1';
literal KA0302$M_SLOT1_LMMR0_INT = %X'6';
literal KA0302$M_SLOT1_LMMR0_IA = %X'18';
literal KA0302$M_SLOT1_LMMR0_AW = %X'1E0';
literal KA0302$M_SLOT1_LMMR0_NBANKS = %X'600';
literal KA0302$M_SLOT1_LMMR0_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT1_LMMR1_EN = %X'1';
literal KA0302$M_SLOT1_LMMR1_INT = %X'6';
literal KA0302$M_SLOT1_LMMR1_IA = %X'18';
literal KA0302$M_SLOT1_LMMR1_AW = %X'1E0';
literal KA0302$M_SLOT1_LMMR1_NBANKS = %X'600';
literal KA0302$M_SLOT1_LMMR1_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT1_LMMR2_EN = %X'1';
literal KA0302$M_SLOT1_LMMR2_INT = %X'6';
literal KA0302$M_SLOT1_LMMR2_IA = %X'18';
literal KA0302$M_SLOT1_LMMR2_AW = %X'1E0';
literal KA0302$M_SLOT1_LMMR2_NBANKS = %X'600';
literal KA0302$M_SLOT1_LMMR2_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT1_LMMR3_EN = %X'1';
literal KA0302$M_SLOT1_LMMR3_INT = %X'6';
literal KA0302$M_SLOT1_LMMR3_IA = %X'18';
literal KA0302$M_SLOT1_LMMR3_AW = %X'1E0';
literal KA0302$M_SLOT1_LMMR3_NBANKS = %X'600';
literal KA0302$M_SLOT1_LMMR3_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT1_LMMR4_EN = %X'1';
literal KA0302$M_SLOT1_LMMR4_INT = %X'6';
literal KA0302$M_SLOT1_LMMR4_IA = %X'18';
literal KA0302$M_SLOT1_LMMR4_AW = %X'1E0';
literal KA0302$M_SLOT1_LMMR4_NBANKS = %X'600';
literal KA0302$M_SLOT1_LMMR4_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT1_LMMR5_EN = %X'1';
literal KA0302$M_SLOT1_LMMR5_INT = %X'6';
literal KA0302$M_SLOT1_LMMR5_IA = %X'18';
literal KA0302$M_SLOT1_LMMR5_AW = %X'1E0';
literal KA0302$M_SLOT1_LMMR5_NBANKS = %X'600';
literal KA0302$M_SLOT1_LMMR5_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT1_LMMR6_EN = %X'1';
literal KA0302$M_SLOT1_LMMR6_INT = %X'6';
literal KA0302$M_SLOT1_LMMR6_IA = %X'18';
literal KA0302$M_SLOT1_LMMR6_AW = %X'1E0';
literal KA0302$M_SLOT1_LMMR6_NBANKS = %X'600';
literal KA0302$M_SLOT1_LMMR6_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT1_LMMR7_EN = %X'1';
literal KA0302$M_SLOT1_LMMR7_INT = %X'6';
literal KA0302$M_SLOT1_LMMR7_IA = %X'18';
literal KA0302$M_SLOT1_LMMR7_AW = %X'1E0';
literal KA0302$M_SLOT1_LMMR7_NBANKS = %X'600';
literal KA0302$M_SLOT1_LMMR7_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT1_LBESR0_SYNDROME = %X'7F';
literal KA0302$M_SLOT1_LBESR1_SYNDROME = %X'7F';
literal KA0302$M_SLOT1_LBESR2_SYNDROME = %X'7F';
literal KA0302$M_SLOT1_LBESR3_SYNDROME = %X'7F';
literal KA0302$M_SLOT1_LBECR1_CA = %X'7F';
literal KA0302$M_SLOT1_LBECR1_CID = %X'780';
literal KA0302$M_SLOT1_LBECR1_RID = %X'7800';
literal KA0302$M_SLOT1_LBECR1_CNF = %X'8000';
literal KA0302$M_SLOT1_LBECR1_SHARED = %X'10000';
literal KA0302$M_SLOT1_LBECR1_DIRTY = %X'20000';
literal KA0302$M_SLOT1_LBECR1_DCYCLE = %X'C0000';
literal KA0302$M_SLOT2_LDEV_DTYPE = %X'FFFF';
literal KA0302$M_SLOT2_LDEV_DREV = %X'FFFF0000';
literal KA0302$M_SLOT2_LBER_E = %X'1';
literal KA0302$M_SLOT2_LBER_UCE = %X'2';
literal KA0302$M_SLOT2_LBER_UCE2 = %X'4';
literal KA0302$M_SLOT2_LBER_CE = %X'8';
literal KA0302$M_SLOT2_LBER_CE2 = %X'10';
literal KA0302$M_SLOT2_LBER_CPE = %X'20';
literal KA0302$M_SLOT2_LBER_CPE2 = %X'40';
literal KA0302$M_SLOT2_LBER_CDPE = %X'80';
literal KA0302$M_SLOT2_LBER_CDPE2 = %X'100';
literal KA0302$M_SLOT2_LBER_TDE = %X'200';
literal KA0302$M_SLOT2_LBER_STE = %X'400';
literal KA0302$M_SLOT2_LBER_CNFE = %X'800';
literal KA0302$M_SLOT2_LBER_NXAE = %X'1000';
literal KA0302$M_SLOT2_LBER_CAE = %X'2000';
literal KA0302$M_SLOT2_LBER_SHE = %X'4000';
literal KA0302$M_SLOT2_LBER_DIE = %X'8000';
literal KA0302$M_SLOT2_LBER_DTCE = %X'10000';
literal KA0302$M_SLOT2_LBER_CTCE = %X'20000';
literal KA0302$M_SLOT2_LBER_NSES = %X'40000';
literal KA0302$M_SLOT2_LCNR_CEEN = %X'1';
literal KA0302$M_SLOT2_LCNR_RSTSTAT = %X'10000000';
literal KA0302$M_SLOT2_LCNR_NHALT = %X'20000000';
literal KA0302$M_SLOT2_LCNR_NRST = %X'40000000';
literal KA0302$M_SLOT2_LCNR_STF = %X'80000000';
literal KA0302$M_SLOT2_IBR_RCV_SDAT = %X'1';
literal KA0302$M_SLOT2_IBR_XMT_SDAT = %X'2';
literal KA0302$M_SLOT2_IBR_SCLK = %X'4';
literal KA0302$M_SLOT2_LMMR0_EN = %X'1';
literal KA0302$M_SLOT2_LMMR0_INT = %X'6';
literal KA0302$M_SLOT2_LMMR0_IA = %X'18';
literal KA0302$M_SLOT2_LMMR0_AW = %X'1E0';
literal KA0302$M_SLOT2_LMMR0_NBANKS = %X'600';
literal KA0302$M_SLOT2_LMMR0_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT2_LMMR1_EN = %X'1';
literal KA0302$M_SLOT2_LMMR1_INT = %X'6';
literal KA0302$M_SLOT2_LMMR1_IA = %X'18';
literal KA0302$M_SLOT2_LMMR1_AW = %X'1E0';
literal KA0302$M_SLOT2_LMMR1_NBANKS = %X'600';
literal KA0302$M_SLOT2_LMMR1_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT2_LMMR2_EN = %X'1';
literal KA0302$M_SLOT2_LMMR2_INT = %X'6';
literal KA0302$M_SLOT2_LMMR2_IA = %X'18';
literal KA0302$M_SLOT2_LMMR2_AW = %X'1E0';
literal KA0302$M_SLOT2_LMMR2_NBANKS = %X'600';
literal KA0302$M_SLOT2_LMMR2_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT2_LMMR3_EN = %X'1';
literal KA0302$M_SLOT2_LMMR3_INT = %X'6';
literal KA0302$M_SLOT2_LMMR3_IA = %X'18';
literal KA0302$M_SLOT2_LMMR3_AW = %X'1E0';
literal KA0302$M_SLOT2_LMMR3_NBANKS = %X'600';
literal KA0302$M_SLOT2_LMMR3_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT2_LMMR4_EN = %X'1';
literal KA0302$M_SLOT2_LMMR4_INT = %X'6';
literal KA0302$M_SLOT2_LMMR4_IA = %X'18';
literal KA0302$M_SLOT2_LMMR4_AW = %X'1E0';
literal KA0302$M_SLOT2_LMMR4_NBANKS = %X'600';
literal KA0302$M_SLOT2_LMMR4_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT2_LMMR5_EN = %X'1';
literal KA0302$M_SLOT2_LMMR5_INT = %X'6';
literal KA0302$M_SLOT2_LMMR5_IA = %X'18';
literal KA0302$M_SLOT2_LMMR5_AW = %X'1E0';
literal KA0302$M_SLOT2_LMMR5_NBANKS = %X'600';
literal KA0302$M_SLOT2_LMMR5_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT2_LMMR6_EN = %X'1';
literal KA0302$M_SLOT2_LMMR6_INT = %X'6';
literal KA0302$M_SLOT2_LMMR6_IA = %X'18';
literal KA0302$M_SLOT2_LMMR6_AW = %X'1E0';
literal KA0302$M_SLOT2_LMMR6_NBANKS = %X'600';
literal KA0302$M_SLOT2_LMMR6_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT2_LMMR7_EN = %X'1';
literal KA0302$M_SLOT2_LMMR7_INT = %X'6';
literal KA0302$M_SLOT2_LMMR7_IA = %X'18';
literal KA0302$M_SLOT2_LMMR7_AW = %X'1E0';
literal KA0302$M_SLOT2_LMMR7_NBANKS = %X'600';
literal KA0302$M_SLOT2_LMMR7_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT2_LBESR0_SYNDROME = %X'7F';
literal KA0302$M_SLOT2_LBESR1_SYNDROME = %X'7F';
literal KA0302$M_SLOT2_LBESR2_SYNDROME = %X'7F';
literal KA0302$M_SLOT2_LBESR3_SYNDROME = %X'7F';
literal KA0302$M_SLOT2_LBECR1_CA = %X'7F';
literal KA0302$M_SLOT2_LBECR1_CID = %X'780';
literal KA0302$M_SLOT2_LBECR1_RID = %X'7800';
literal KA0302$M_SLOT2_LBECR1_CNF = %X'8000';
literal KA0302$M_SLOT2_LBECR1_SHARED = %X'10000';
literal KA0302$M_SLOT2_LBECR1_DIRTY = %X'20000';
literal KA0302$M_SLOT2_LBECR1_DCYCLE = %X'C0000';
literal KA0302$M_SLOT3_LDEV_DTYPE = %X'FFFF';
literal KA0302$M_SLOT3_LDEV_DREV = %X'FFFF0000';
literal KA0302$M_SLOT3_LBER_E = %X'1';
literal KA0302$M_SLOT3_LBER_UCE = %X'2';
literal KA0302$M_SLOT3_LBER_UCE2 = %X'4';
literal KA0302$M_SLOT3_LBER_CE = %X'8';
literal KA0302$M_SLOT3_LBER_CE2 = %X'10';
literal KA0302$M_SLOT3_LBER_CPE = %X'20';
literal KA0302$M_SLOT3_LBER_CPE2 = %X'40';
literal KA0302$M_SLOT3_LBER_CDPE = %X'80';
literal KA0302$M_SLOT3_LBER_CDPE2 = %X'100';
literal KA0302$M_SLOT3_LBER_TDE = %X'200';
literal KA0302$M_SLOT3_LBER_STE = %X'400';
literal KA0302$M_SLOT3_LBER_CNFE = %X'800';
literal KA0302$M_SLOT3_LBER_NXAE = %X'1000';
literal KA0302$M_SLOT3_LBER_CAE = %X'2000';
literal KA0302$M_SLOT3_LBER_SHE = %X'4000';
literal KA0302$M_SLOT3_LBER_DIE = %X'8000';
literal KA0302$M_SLOT3_LBER_DTCE = %X'10000';
literal KA0302$M_SLOT3_LBER_CTCE = %X'20000';
literal KA0302$M_SLOT3_LBER_NSES = %X'40000';
literal KA0302$M_SLOT3_LCNR_CEEN = %X'1';
literal KA0302$M_SLOT3_LCNR_RSTSTAT = %X'10000000';
literal KA0302$M_SLOT3_LCNR_NHALT = %X'20000000';
literal KA0302$M_SLOT3_LCNR_NRST = %X'40000000';
literal KA0302$M_SLOT3_LCNR_STF = %X'80000000';
literal KA0302$M_SLOT3_IBR_RCV_SDAT = %X'1';
literal KA0302$M_SLOT3_IBR_XMT_SDAT = %X'2';
literal KA0302$M_SLOT3_IBR_SCLK = %X'4';
literal KA0302$M_SLOT3_LMMR0_EN = %X'1';
literal KA0302$M_SLOT3_LMMR0_INT = %X'6';
literal KA0302$M_SLOT3_LMMR0_IA = %X'18';
literal KA0302$M_SLOT3_LMMR0_AW = %X'1E0';
literal KA0302$M_SLOT3_LMMR0_NBANKS = %X'600';
literal KA0302$M_SLOT3_LMMR0_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT3_LMMR1_EN = %X'1';
literal KA0302$M_SLOT3_LMMR1_INT = %X'6';
literal KA0302$M_SLOT3_LMMR1_IA = %X'18';
literal KA0302$M_SLOT3_LMMR1_AW = %X'1E0';
literal KA0302$M_SLOT3_LMMR1_NBANKS = %X'600';
literal KA0302$M_SLOT3_LMMR1_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT3_LMMR2_EN = %X'1';
literal KA0302$M_SLOT3_LMMR2_INT = %X'6';
literal KA0302$M_SLOT3_LMMR2_IA = %X'18';
literal KA0302$M_SLOT3_LMMR2_AW = %X'1E0';
literal KA0302$M_SLOT3_LMMR2_NBANKS = %X'600';
literal KA0302$M_SLOT3_LMMR2_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT3_LMMR3_EN = %X'1';
literal KA0302$M_SLOT3_LMMR3_INT = %X'6';
literal KA0302$M_SLOT3_LMMR3_IA = %X'18';
literal KA0302$M_SLOT3_LMMR3_AW = %X'1E0';
literal KA0302$M_SLOT3_LMMR3_NBANKS = %X'600';
literal KA0302$M_SLOT3_LMMR3_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT3_LMMR4_EN = %X'1';
literal KA0302$M_SLOT3_LMMR4_INT = %X'6';
literal KA0302$M_SLOT3_LMMR4_IA = %X'18';
literal KA0302$M_SLOT3_LMMR4_AW = %X'1E0';
literal KA0302$M_SLOT3_LMMR4_NBANKS = %X'600';
literal KA0302$M_SLOT3_LMMR4_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT3_LMMR5_EN = %X'1';
literal KA0302$M_SLOT3_LMMR5_INT = %X'6';
literal KA0302$M_SLOT3_LMMR5_IA = %X'18';
literal KA0302$M_SLOT3_LMMR5_AW = %X'1E0';
literal KA0302$M_SLOT3_LMMR5_NBANKS = %X'600';
literal KA0302$M_SLOT3_LMMR5_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT3_LMMR6_EN = %X'1';
literal KA0302$M_SLOT3_LMMR6_INT = %X'6';
literal KA0302$M_SLOT3_LMMR6_IA = %X'18';
literal KA0302$M_SLOT3_LMMR6_AW = %X'1E0';
literal KA0302$M_SLOT3_LMMR6_NBANKS = %X'600';
literal KA0302$M_SLOT3_LMMR6_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT3_LMMR7_EN = %X'1';
literal KA0302$M_SLOT3_LMMR7_INT = %X'6';
literal KA0302$M_SLOT3_LMMR7_IA = %X'18';
literal KA0302$M_SLOT3_LMMR7_AW = %X'1E0';
literal KA0302$M_SLOT3_LMMR7_NBANKS = %X'600';
literal KA0302$M_SLOT3_LMMR7_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT3_LBESR0_SYNDROME = %X'7F';
literal KA0302$M_SLOT3_LBESR1_SYNDROME = %X'7F';
literal KA0302$M_SLOT3_LBESR2_SYNDROME = %X'7F';
literal KA0302$M_SLOT3_LBESR3_SYNDROME = %X'7F';
literal KA0302$M_SLOT3_LBECR1_CA = %X'7F';
literal KA0302$M_SLOT3_LBECR1_CID = %X'780';
literal KA0302$M_SLOT3_LBECR1_RID = %X'7800';
literal KA0302$M_SLOT3_LBECR1_CNF = %X'8000';
literal KA0302$M_SLOT3_LBECR1_SHARED = %X'10000';
literal KA0302$M_SLOT3_LBECR1_DIRTY = %X'20000';
literal KA0302$M_SLOT3_LBECR1_DCYCLE = %X'C0000';
literal KA0302$M_SLOT4_LDEV_DTYPE = %X'FFFF';
literal KA0302$M_SLOT4_LDEV_DREV = %X'FFFF0000';
literal KA0302$M_SLOT4_LBER_E = %X'1';
literal KA0302$M_SLOT4_LBER_UCE = %X'2';
literal KA0302$M_SLOT4_LBER_UCE2 = %X'4';
literal KA0302$M_SLOT4_LBER_CE = %X'8';
literal KA0302$M_SLOT4_LBER_CE2 = %X'10';
literal KA0302$M_SLOT4_LBER_CPE = %X'20';
literal KA0302$M_SLOT4_LBER_CPE2 = %X'40';
literal KA0302$M_SLOT4_LBER_CDPE = %X'80';
literal KA0302$M_SLOT4_LBER_CDPE2 = %X'100';
literal KA0302$M_SLOT4_LBER_TDE = %X'200';
literal KA0302$M_SLOT4_LBER_STE = %X'400';
literal KA0302$M_SLOT4_LBER_CNFE = %X'800';
literal KA0302$M_SLOT4_LBER_NXAE = %X'1000';
literal KA0302$M_SLOT4_LBER_CAE = %X'2000';
literal KA0302$M_SLOT4_LBER_SHE = %X'4000';
literal KA0302$M_SLOT4_LBER_DIE = %X'8000';
literal KA0302$M_SLOT4_LBER_DTCE = %X'10000';
literal KA0302$M_SLOT4_LBER_CTCE = %X'20000';
literal KA0302$M_SLOT4_LBER_NSES = %X'40000';
literal KA0302$M_SLOT4_LCNR_CEEN = %X'1';
literal KA0302$M_SLOT4_LCNR_RSTSTAT = %X'10000000';
literal KA0302$M_SLOT4_LCNR_NHALT = %X'20000000';
literal KA0302$M_SLOT4_LCNR_NRST = %X'40000000';
literal KA0302$M_SLOT4_LCNR_STF = %X'80000000';
literal KA0302$M_SLOT4_IBR_RCV_SDAT = %X'1';
literal KA0302$M_SLOT4_IBR_XMT_SDAT = %X'2';
literal KA0302$M_SLOT4_IBR_SCLK = %X'4';
literal KA0302$M_SLOT4_LMMR0_EN = %X'1';
literal KA0302$M_SLOT4_LMMR0_INT = %X'6';
literal KA0302$M_SLOT4_LMMR0_IA = %X'18';
literal KA0302$M_SLOT4_LMMR0_AW = %X'1E0';
literal KA0302$M_SLOT4_LMMR0_NBANKS = %X'600';
literal KA0302$M_SLOT4_LMMR0_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT4_LMMR1_EN = %X'1';
literal KA0302$M_SLOT4_LMMR1_INT = %X'6';
literal KA0302$M_SLOT4_LMMR1_IA = %X'18';
literal KA0302$M_SLOT4_LMMR1_AW = %X'1E0';
literal KA0302$M_SLOT4_LMMR1_NBANKS = %X'600';
literal KA0302$M_SLOT4_LMMR1_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT4_LMMR2_EN = %X'1';
literal KA0302$M_SLOT4_LMMR2_INT = %X'6';
literal KA0302$M_SLOT4_LMMR2_IA = %X'18';
literal KA0302$M_SLOT4_LMMR2_AW = %X'1E0';
literal KA0302$M_SLOT4_LMMR2_NBANKS = %X'600';
literal KA0302$M_SLOT4_LMMR2_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT4_LMMR3_EN = %X'1';
literal KA0302$M_SLOT4_LMMR3_INT = %X'6';
literal KA0302$M_SLOT4_LMMR3_IA = %X'18';
literal KA0302$M_SLOT4_LMMR3_AW = %X'1E0';
literal KA0302$M_SLOT4_LMMR3_NBANKS = %X'600';
literal KA0302$M_SLOT4_LMMR3_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT4_LMMR4_EN = %X'1';
literal KA0302$M_SLOT4_LMMR4_INT = %X'6';
literal KA0302$M_SLOT4_LMMR4_IA = %X'18';
literal KA0302$M_SLOT4_LMMR4_AW = %X'1E0';
literal KA0302$M_SLOT4_LMMR4_NBANKS = %X'600';
literal KA0302$M_SLOT4_LMMR4_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT4_LMMR5_EN = %X'1';
literal KA0302$M_SLOT4_LMMR5_INT = %X'6';
literal KA0302$M_SLOT4_LMMR5_IA = %X'18';
literal KA0302$M_SLOT4_LMMR5_AW = %X'1E0';
literal KA0302$M_SLOT4_LMMR5_NBANKS = %X'600';
literal KA0302$M_SLOT4_LMMR5_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT4_LMMR6_EN = %X'1';
literal KA0302$M_SLOT4_LMMR6_INT = %X'6';
literal KA0302$M_SLOT4_LMMR6_IA = %X'18';
literal KA0302$M_SLOT4_LMMR6_AW = %X'1E0';
literal KA0302$M_SLOT4_LMMR6_NBANKS = %X'600';
literal KA0302$M_SLOT4_LMMR6_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT4_LMMR7_EN = %X'1';
literal KA0302$M_SLOT4_LMMR7_INT = %X'6';
literal KA0302$M_SLOT4_LMMR7_IA = %X'18';
literal KA0302$M_SLOT4_LMMR7_AW = %X'1E0';
literal KA0302$M_SLOT4_LMMR7_NBANKS = %X'600';
literal KA0302$M_SLOT4_LMMR7_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT4_LBESR0_SYNDROME = %X'7F';
literal KA0302$M_SLOT4_LBESR1_SYNDROME = %X'7F';
literal KA0302$M_SLOT4_LBESR2_SYNDROME = %X'7F';
literal KA0302$M_SLOT4_LBESR3_SYNDROME = %X'7F';
literal KA0302$M_SLOT4_LBECR1_CA = %X'7F';
literal KA0302$M_SLOT4_LBECR1_CID = %X'780';
literal KA0302$M_SLOT4_LBECR1_RID = %X'7800';
literal KA0302$M_SLOT4_LBECR1_CNF = %X'8000';
literal KA0302$M_SLOT4_LBECR1_SHARED = %X'10000';
literal KA0302$M_SLOT4_LBECR1_DIRTY = %X'20000';
literal KA0302$M_SLOT4_LBECR1_DCYCLE = %X'C0000';
literal KA0302$M_SLOT5_LDEV_DTYPE = %X'FFFF';
literal KA0302$M_SLOT5_LDEV_DREV = %X'FFFF0000';
literal KA0302$M_SLOT5_LBER_E = %X'1';
literal KA0302$M_SLOT5_LBER_UCE = %X'2';
literal KA0302$M_SLOT5_LBER_UCE2 = %X'4';
literal KA0302$M_SLOT5_LBER_CE = %X'8';
literal KA0302$M_SLOT5_LBER_CE2 = %X'10';
literal KA0302$M_SLOT5_LBER_CPE = %X'20';
literal KA0302$M_SLOT5_LBER_CPE2 = %X'40';
literal KA0302$M_SLOT5_LBER_CDPE = %X'80';
literal KA0302$M_SLOT5_LBER_CDPE2 = %X'100';
literal KA0302$M_SLOT5_LBER_TDE = %X'200';
literal KA0302$M_SLOT5_LBER_STE = %X'400';
literal KA0302$M_SLOT5_LBER_CNFE = %X'800';
literal KA0302$M_SLOT5_LBER_NXAE = %X'1000';
literal KA0302$M_SLOT5_LBER_CAE = %X'2000';
literal KA0302$M_SLOT5_LBER_SHE = %X'4000';
literal KA0302$M_SLOT5_LBER_DIE = %X'8000';
literal KA0302$M_SLOT5_LBER_DTCE = %X'10000';
literal KA0302$M_SLOT5_LBER_CTCE = %X'20000';
literal KA0302$M_SLOT5_LBER_NSES = %X'40000';
literal KA0302$M_SLOT5_LCNR_CEEN = %X'1';
literal KA0302$M_SLOT5_LCNR_RSTSTAT = %X'10000000';
literal KA0302$M_SLOT5_LCNR_NHALT = %X'20000000';
literal KA0302$M_SLOT5_LCNR_NRST = %X'40000000';
literal KA0302$M_SLOT5_LCNR_STF = %X'80000000';
literal KA0302$M_SLOT5_IBR_RCV_SDAT = %X'1';
literal KA0302$M_SLOT5_IBR_XMT_SDAT = %X'2';
literal KA0302$M_SLOT5_IBR_SCLK = %X'4';
literal KA0302$M_SLOT5_LMMR0_EN = %X'1';
literal KA0302$M_SLOT5_LMMR0_INT = %X'6';
literal KA0302$M_SLOT5_LMMR0_IA = %X'18';
literal KA0302$M_SLOT5_LMMR0_AW = %X'1E0';
literal KA0302$M_SLOT5_LMMR0_NBANKS = %X'600';
literal KA0302$M_SLOT5_LMMR0_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT5_LMMR1_EN = %X'1';
literal KA0302$M_SLOT5_LMMR1_INT = %X'6';
literal KA0302$M_SLOT5_LMMR1_IA = %X'18';
literal KA0302$M_SLOT5_LMMR1_AW = %X'1E0';
literal KA0302$M_SLOT5_LMMR1_NBANKS = %X'600';
literal KA0302$M_SLOT5_LMMR1_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT5_LMMR2_EN = %X'1';
literal KA0302$M_SLOT5_LMMR2_INT = %X'6';
literal KA0302$M_SLOT5_LMMR2_IA = %X'18';
literal KA0302$M_SLOT5_LMMR2_AW = %X'1E0';
literal KA0302$M_SLOT5_LMMR2_NBANKS = %X'600';
literal KA0302$M_SLOT5_LMMR2_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT5_LMMR3_EN = %X'1';
literal KA0302$M_SLOT5_LMMR3_INT = %X'6';
literal KA0302$M_SLOT5_LMMR3_IA = %X'18';
literal KA0302$M_SLOT5_LMMR3_AW = %X'1E0';
literal KA0302$M_SLOT5_LMMR3_NBANKS = %X'600';
literal KA0302$M_SLOT5_LMMR3_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT5_LMMR4_EN = %X'1';
literal KA0302$M_SLOT5_LMMR4_INT = %X'6';
literal KA0302$M_SLOT5_LMMR4_IA = %X'18';
literal KA0302$M_SLOT5_LMMR4_AW = %X'1E0';
literal KA0302$M_SLOT5_LMMR4_NBANKS = %X'600';
literal KA0302$M_SLOT5_LMMR4_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT5_LMMR5_EN = %X'1';
literal KA0302$M_SLOT5_LMMR5_INT = %X'6';
literal KA0302$M_SLOT5_LMMR5_IA = %X'18';
literal KA0302$M_SLOT5_LMMR5_AW = %X'1E0';
literal KA0302$M_SLOT5_LMMR5_NBANKS = %X'600';
literal KA0302$M_SLOT5_LMMR5_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT5_LMMR6_EN = %X'1';
literal KA0302$M_SLOT5_LMMR6_INT = %X'6';
literal KA0302$M_SLOT5_LMMR6_IA = %X'18';
literal KA0302$M_SLOT5_LMMR6_AW = %X'1E0';
literal KA0302$M_SLOT5_LMMR6_NBANKS = %X'600';
literal KA0302$M_SLOT5_LMMR6_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT5_LMMR7_EN = %X'1';
literal KA0302$M_SLOT5_LMMR7_INT = %X'6';
literal KA0302$M_SLOT5_LMMR7_IA = %X'18';
literal KA0302$M_SLOT5_LMMR7_AW = %X'1E0';
literal KA0302$M_SLOT5_LMMR7_NBANKS = %X'600';
literal KA0302$M_SLOT5_LMMR7_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT5_LBESR0_SYNDROME = %X'7F';
literal KA0302$M_SLOT5_LBESR1_SYNDROME = %X'7F';
literal KA0302$M_SLOT5_LBESR2_SYNDROME = %X'7F';
literal KA0302$M_SLOT5_LBESR3_SYNDROME = %X'7F';
literal KA0302$M_SLOT5_LBECR1_CA = %X'7F';
literal KA0302$M_SLOT5_LBECR1_CID = %X'780';
literal KA0302$M_SLOT5_LBECR1_RID = %X'7800';
literal KA0302$M_SLOT5_LBECR1_CNF = %X'8000';
literal KA0302$M_SLOT5_LBECR1_SHARED = %X'10000';
literal KA0302$M_SLOT5_LBECR1_DIRTY = %X'20000';
literal KA0302$M_SLOT5_LBECR1_DCYCLE = %X'C0000';
literal KA0302$M_SLOT6_LDEV_DTYPE = %X'FFFF';
literal KA0302$M_SLOT6_LDEV_DREV = %X'FFFF0000';
literal KA0302$M_SLOT6_LBER_E = %X'1';
literal KA0302$M_SLOT6_LBER_UCE = %X'2';
literal KA0302$M_SLOT6_LBER_UCE2 = %X'4';
literal KA0302$M_SLOT6_LBER_CE = %X'8';
literal KA0302$M_SLOT6_LBER_CE2 = %X'10';
literal KA0302$M_SLOT6_LBER_CPE = %X'20';
literal KA0302$M_SLOT6_LBER_CPE2 = %X'40';
literal KA0302$M_SLOT6_LBER_CDPE = %X'80';
literal KA0302$M_SLOT6_LBER_CDPE2 = %X'100';
literal KA0302$M_SLOT6_LBER_TDE = %X'200';
literal KA0302$M_SLOT6_LBER_STE = %X'400';
literal KA0302$M_SLOT6_LBER_CNFE = %X'800';
literal KA0302$M_SLOT6_LBER_NXAE = %X'1000';
literal KA0302$M_SLOT6_LBER_CAE = %X'2000';
literal KA0302$M_SLOT6_LBER_SHE = %X'4000';
literal KA0302$M_SLOT6_LBER_DIE = %X'8000';
literal KA0302$M_SLOT6_LBER_DTCE = %X'10000';
literal KA0302$M_SLOT6_LBER_CTCE = %X'20000';
literal KA0302$M_SLOT6_LBER_NSES = %X'40000';
literal KA0302$M_SLOT6_LCNR_CEEN = %X'1';
literal KA0302$M_SLOT6_LCNR_RSTSTAT = %X'10000000';
literal KA0302$M_SLOT6_LCNR_NHALT = %X'20000000';
literal KA0302$M_SLOT6_LCNR_NRST = %X'40000000';
literal KA0302$M_SLOT6_LCNR_STF = %X'80000000';
literal KA0302$M_SLOT6_IBR_RCV_SDAT = %X'1';
literal KA0302$M_SLOT6_IBR_XMT_SDAT = %X'2';
literal KA0302$M_SLOT6_IBR_SCLK = %X'4';
literal KA0302$M_SLOT6_LMMR0_EN = %X'1';
literal KA0302$M_SLOT6_LMMR0_INT = %X'6';
literal KA0302$M_SLOT6_LMMR0_IA = %X'18';
literal KA0302$M_SLOT6_LMMR0_AW = %X'1E0';
literal KA0302$M_SLOT6_LMMR0_NBANKS = %X'600';
literal KA0302$M_SLOT6_LMMR0_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT6_LMMR1_EN = %X'1';
literal KA0302$M_SLOT6_LMMR1_INT = %X'6';
literal KA0302$M_SLOT6_LMMR1_IA = %X'18';
literal KA0302$M_SLOT6_LMMR1_AW = %X'1E0';
literal KA0302$M_SLOT6_LMMR1_NBANKS = %X'600';
literal KA0302$M_SLOT6_LMMR1_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT6_LMMR2_EN = %X'1';
literal KA0302$M_SLOT6_LMMR2_INT = %X'6';
literal KA0302$M_SLOT6_LMMR2_IA = %X'18';
literal KA0302$M_SLOT6_LMMR2_AW = %X'1E0';
literal KA0302$M_SLOT6_LMMR2_NBANKS = %X'600';
literal KA0302$M_SLOT6_LMMR2_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT6_LMMR3_EN = %X'1';
literal KA0302$M_SLOT6_LMMR3_INT = %X'6';
literal KA0302$M_SLOT6_LMMR3_IA = %X'18';
literal KA0302$M_SLOT6_LMMR3_AW = %X'1E0';
literal KA0302$M_SLOT6_LMMR3_NBANKS = %X'600';
literal KA0302$M_SLOT6_LMMR3_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT6_LMMR4_EN = %X'1';
literal KA0302$M_SLOT6_LMMR4_INT = %X'6';
literal KA0302$M_SLOT6_LMMR4_IA = %X'18';
literal KA0302$M_SLOT6_LMMR4_AW = %X'1E0';
literal KA0302$M_SLOT6_LMMR4_NBANKS = %X'600';
literal KA0302$M_SLOT6_LMMR4_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT6_LMMR5_EN = %X'1';
literal KA0302$M_SLOT6_LMMR5_INT = %X'6';
literal KA0302$M_SLOT6_LMMR5_IA = %X'18';
literal KA0302$M_SLOT6_LMMR5_AW = %X'1E0';
literal KA0302$M_SLOT6_LMMR5_NBANKS = %X'600';
literal KA0302$M_SLOT6_LMMR5_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT6_LMMR6_EN = %X'1';
literal KA0302$M_SLOT6_LMMR6_INT = %X'6';
literal KA0302$M_SLOT6_LMMR6_IA = %X'18';
literal KA0302$M_SLOT6_LMMR6_AW = %X'1E0';
literal KA0302$M_SLOT6_LMMR6_NBANKS = %X'600';
literal KA0302$M_SLOT6_LMMR6_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT6_LMMR7_EN = %X'1';
literal KA0302$M_SLOT6_LMMR7_INT = %X'6';
literal KA0302$M_SLOT6_LMMR7_IA = %X'18';
literal KA0302$M_SLOT6_LMMR7_AW = %X'1E0';
literal KA0302$M_SLOT6_LMMR7_NBANKS = %X'600';
literal KA0302$M_SLOT6_LMMR7_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT6_LBESR0_SYNDROME = %X'7F';
literal KA0302$M_SLOT6_LBESR1_SYNDROME = %X'7F';
literal KA0302$M_SLOT6_LBESR2_SYNDROME = %X'7F';
literal KA0302$M_SLOT6_LBESR3_SYNDROME = %X'7F';
literal KA0302$M_SLOT6_LBECR1_CA = %X'7F';
literal KA0302$M_SLOT6_LBECR1_CID = %X'780';
literal KA0302$M_SLOT6_LBECR1_RID = %X'7800';
literal KA0302$M_SLOT6_LBECR1_CNF = %X'8000';
literal KA0302$M_SLOT6_LBECR1_SHARED = %X'10000';
literal KA0302$M_SLOT6_LBECR1_DIRTY = %X'20000';
literal KA0302$M_SLOT6_LBECR1_DCYCLE = %X'C0000';
literal KA0302$M_SLOT7_LDEV_DTYPE = %X'FFFF';
literal KA0302$M_SLOT7_LDEV_DREV = %X'FFFF0000';
literal KA0302$M_SLOT7_LBER_E = %X'1';
literal KA0302$M_SLOT7_LBER_UCE = %X'2';
literal KA0302$M_SLOT7_LBER_UCE2 = %X'4';
literal KA0302$M_SLOT7_LBER_CE = %X'8';
literal KA0302$M_SLOT7_LBER_CE2 = %X'10';
literal KA0302$M_SLOT7_LBER_CPE = %X'20';
literal KA0302$M_SLOT7_LBER_CPE2 = %X'40';
literal KA0302$M_SLOT7_LBER_CDPE = %X'80';
literal KA0302$M_SLOT7_LBER_CDPE2 = %X'100';
literal KA0302$M_SLOT7_LBER_TDE = %X'200';
literal KA0302$M_SLOT7_LBER_STE = %X'400';
literal KA0302$M_SLOT7_LBER_CNFE = %X'800';
literal KA0302$M_SLOT7_LBER_NXAE = %X'1000';
literal KA0302$M_SLOT7_LBER_CAE = %X'2000';
literal KA0302$M_SLOT7_LBER_SHE = %X'4000';
literal KA0302$M_SLOT7_LBER_DIE = %X'8000';
literal KA0302$M_SLOT7_LBER_DTCE = %X'10000';
literal KA0302$M_SLOT7_LBER_CTCE = %X'20000';
literal KA0302$M_SLOT7_LBER_NSES = %X'40000';
literal KA0302$M_SLOT7_LCNR_CEEN = %X'1';
literal KA0302$M_SLOT7_LCNR_RSTSTAT = %X'10000000';
literal KA0302$M_SLOT7_LCNR_NHALT = %X'20000000';
literal KA0302$M_SLOT7_LCNR_NRST = %X'40000000';
literal KA0302$M_SLOT7_LCNR_STF = %X'80000000';
literal KA0302$M_SLOT7_IBR_RCV_SDAT = %X'1';
literal KA0302$M_SLOT7_IBR_XMT_SDAT = %X'2';
literal KA0302$M_SLOT7_IBR_SCLK = %X'4';
literal KA0302$M_SLOT7_LMMR0_EN = %X'1';
literal KA0302$M_SLOT7_LMMR0_INT = %X'6';
literal KA0302$M_SLOT7_LMMR0_IA = %X'18';
literal KA0302$M_SLOT7_LMMR0_AW = %X'1E0';
literal KA0302$M_SLOT7_LMMR0_NBANKS = %X'600';
literal KA0302$M_SLOT7_LMMR0_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT7_LMMR1_EN = %X'1';
literal KA0302$M_SLOT7_LMMR1_INT = %X'6';
literal KA0302$M_SLOT7_LMMR1_IA = %X'18';
literal KA0302$M_SLOT7_LMMR1_AW = %X'1E0';
literal KA0302$M_SLOT7_LMMR1_NBANKS = %X'600';
literal KA0302$M_SLOT7_LMMR1_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT7_LMMR2_EN = %X'1';
literal KA0302$M_SLOT7_LMMR2_INT = %X'6';
literal KA0302$M_SLOT7_LMMR2_IA = %X'18';
literal KA0302$M_SLOT7_LMMR2_AW = %X'1E0';
literal KA0302$M_SLOT7_LMMR2_NBANKS = %X'600';
literal KA0302$M_SLOT7_LMMR2_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT7_LMMR3_EN = %X'1';
literal KA0302$M_SLOT7_LMMR3_INT = %X'6';
literal KA0302$M_SLOT7_LMMR3_IA = %X'18';
literal KA0302$M_SLOT7_LMMR3_AW = %X'1E0';
literal KA0302$M_SLOT7_LMMR3_NBANKS = %X'600';
literal KA0302$M_SLOT7_LMMR3_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT7_LMMR4_EN = %X'1';
literal KA0302$M_SLOT7_LMMR4_INT = %X'6';
literal KA0302$M_SLOT7_LMMR4_IA = %X'18';
literal KA0302$M_SLOT7_LMMR4_AW = %X'1E0';
literal KA0302$M_SLOT7_LMMR4_NBANKS = %X'600';
literal KA0302$M_SLOT7_LMMR4_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT7_LMMR5_EN = %X'1';
literal KA0302$M_SLOT7_LMMR5_INT = %X'6';
literal KA0302$M_SLOT7_LMMR5_IA = %X'18';
literal KA0302$M_SLOT7_LMMR5_AW = %X'1E0';
literal KA0302$M_SLOT7_LMMR5_NBANKS = %X'600';
literal KA0302$M_SLOT7_LMMR5_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT7_LMMR6_EN = %X'1';
literal KA0302$M_SLOT7_LMMR6_INT = %X'6';
literal KA0302$M_SLOT7_LMMR6_IA = %X'18';
literal KA0302$M_SLOT7_LMMR6_AW = %X'1E0';
literal KA0302$M_SLOT7_LMMR6_NBANKS = %X'600';
literal KA0302$M_SLOT7_LMMR6_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT7_LMMR7_EN = %X'1';
literal KA0302$M_SLOT7_LMMR7_INT = %X'6';
literal KA0302$M_SLOT7_LMMR7_IA = %X'18';
literal KA0302$M_SLOT7_LMMR7_AW = %X'1E0';
literal KA0302$M_SLOT7_LMMR7_NBANKS = %X'600';
literal KA0302$M_SLOT7_LMMR7_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT7_LBESR0_SYNDROME = %X'7F';
literal KA0302$M_SLOT7_LBESR1_SYNDROME = %X'7F';
literal KA0302$M_SLOT7_LBESR2_SYNDROME = %X'7F';
literal KA0302$M_SLOT7_LBESR3_SYNDROME = %X'7F';
literal KA0302$M_SLOT7_LBECR1_CA = %X'7F';
literal KA0302$M_SLOT7_LBECR1_CID = %X'780';
literal KA0302$M_SLOT7_LBECR1_RID = %X'7800';
literal KA0302$M_SLOT7_LBECR1_CNF = %X'8000';
literal KA0302$M_SLOT7_LBECR1_SHARED = %X'10000';
literal KA0302$M_SLOT7_LBECR1_DIRTY = %X'20000';
literal KA0302$M_SLOT7_LBECR1_DCYCLE = %X'C0000';
literal KA0302$M_SLOT8_LDEV_DTYPE = %X'FFFF';
literal KA0302$M_SLOT8_LDEV_DREV = %X'FFFF0000';
literal KA0302$M_SLOT8_LBER_E = %X'1';
literal KA0302$M_SLOT8_LBER_UCE = %X'2';
literal KA0302$M_SLOT8_LBER_UCE2 = %X'4';
literal KA0302$M_SLOT8_LBER_CE = %X'8';
literal KA0302$M_SLOT8_LBER_CE2 = %X'10';
literal KA0302$M_SLOT8_LBER_CPE = %X'20';
literal KA0302$M_SLOT8_LBER_CPE2 = %X'40';
literal KA0302$M_SLOT8_LBER_CDPE = %X'80';
literal KA0302$M_SLOT8_LBER_CDPE2 = %X'100';
literal KA0302$M_SLOT8_LBER_TDE = %X'200';
literal KA0302$M_SLOT8_LBER_STE = %X'400';
literal KA0302$M_SLOT8_LBER_CNFE = %X'800';
literal KA0302$M_SLOT8_LBER_NXAE = %X'1000';
literal KA0302$M_SLOT8_LBER_CAE = %X'2000';
literal KA0302$M_SLOT8_LBER_SHE = %X'4000';
literal KA0302$M_SLOT8_LBER_DIE = %X'8000';
literal KA0302$M_SLOT8_LBER_DTCE = %X'10000';
literal KA0302$M_SLOT8_LBER_CTCE = %X'20000';
literal KA0302$M_SLOT8_LBER_NSES = %X'40000';
literal KA0302$M_SLOT8_LCNR_CEEN = %X'1';
literal KA0302$M_SLOT8_LCNR_RSTSTAT = %X'10000000';
literal KA0302$M_SLOT8_LCNR_NHALT = %X'20000000';
literal KA0302$M_SLOT8_LCNR_NRST = %X'40000000';
literal KA0302$M_SLOT8_LCNR_STF = %X'80000000';
literal KA0302$M_SLOT8_IBR_RCV_SDAT = %X'1';
literal KA0302$M_SLOT8_IBR_XMT_SDAT = %X'2';
literal KA0302$M_SLOT8_IBR_SCLK = %X'4';
literal KA0302$M_SLOT8_LMMR0_EN = %X'1';
literal KA0302$M_SLOT8_LMMR0_INT = %X'6';
literal KA0302$M_SLOT8_LMMR0_IA = %X'18';
literal KA0302$M_SLOT8_LMMR0_AW = %X'1E0';
literal KA0302$M_SLOT8_LMMR0_NBANKS = %X'600';
literal KA0302$M_SLOT8_LMMR0_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT8_LMMR1_EN = %X'1';
literal KA0302$M_SLOT8_LMMR1_INT = %X'6';
literal KA0302$M_SLOT8_LMMR1_IA = %X'18';
literal KA0302$M_SLOT8_LMMR1_AW = %X'1E0';
literal KA0302$M_SLOT8_LMMR1_NBANKS = %X'600';
literal KA0302$M_SLOT8_LMMR1_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT8_LMMR2_EN = %X'1';
literal KA0302$M_SLOT8_LMMR2_INT = %X'6';
literal KA0302$M_SLOT8_LMMR2_IA = %X'18';
literal KA0302$M_SLOT8_LMMR2_AW = %X'1E0';
literal KA0302$M_SLOT8_LMMR2_NBANKS = %X'600';
literal KA0302$M_SLOT8_LMMR2_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT8_LMMR3_EN = %X'1';
literal KA0302$M_SLOT8_LMMR3_INT = %X'6';
literal KA0302$M_SLOT8_LMMR3_IA = %X'18';
literal KA0302$M_SLOT8_LMMR3_AW = %X'1E0';
literal KA0302$M_SLOT8_LMMR3_NBANKS = %X'600';
literal KA0302$M_SLOT8_LMMR3_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT8_LMMR4_EN = %X'1';
literal KA0302$M_SLOT8_LMMR4_INT = %X'6';
literal KA0302$M_SLOT8_LMMR4_IA = %X'18';
literal KA0302$M_SLOT8_LMMR4_AW = %X'1E0';
literal KA0302$M_SLOT8_LMMR4_NBANKS = %X'600';
literal KA0302$M_SLOT8_LMMR4_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT8_LMMR5_EN = %X'1';
literal KA0302$M_SLOT8_LMMR5_INT = %X'6';
literal KA0302$M_SLOT8_LMMR5_IA = %X'18';
literal KA0302$M_SLOT8_LMMR5_AW = %X'1E0';
literal KA0302$M_SLOT8_LMMR5_NBANKS = %X'600';
literal KA0302$M_SLOT8_LMMR5_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT8_LMMR6_EN = %X'1';
literal KA0302$M_SLOT8_LMMR6_INT = %X'6';
literal KA0302$M_SLOT8_LMMR6_IA = %X'18';
literal KA0302$M_SLOT8_LMMR6_AW = %X'1E0';
literal KA0302$M_SLOT8_LMMR6_NBANKS = %X'600';
literal KA0302$M_SLOT8_LMMR6_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT8_LMMR7_EN = %X'1';
literal KA0302$M_SLOT8_LMMR7_INT = %X'6';
literal KA0302$M_SLOT8_LMMR7_IA = %X'18';
literal KA0302$M_SLOT8_LMMR7_AW = %X'1E0';
literal KA0302$M_SLOT8_LMMR7_NBANKS = %X'600';
literal KA0302$M_SLOT8_LMMR7_ADDR = %X'FFFE0000';
literal KA0302$M_SLOT8_LBESR0_SYNDROME = %X'7F';
literal KA0302$M_SLOT8_LBESR1_SYNDROME = %X'7F';
literal KA0302$M_SLOT8_LBESR2_SYNDROME = %X'7F';
literal KA0302$M_SLOT8_LBESR3_SYNDROME = %X'7F';
literal KA0302$M_SLOT8_LBECR1_CA = %X'7F';
literal KA0302$M_SLOT8_LBECR1_CID = %X'780';
literal KA0302$M_SLOT8_LBECR1_RID = %X'7800';
literal KA0302$M_SLOT8_LBECR1_CNF = %X'8000';
literal KA0302$M_SLOT8_LBECR1_SHARED = %X'10000';
literal KA0302$M_SLOT8_LBECR1_DIRTY = %X'20000';
literal KA0302$M_SLOT8_LBECR1_DCYCLE = %X'C0000';
literal KA0302$M_LILID0_IDENT = %X'FFFF';
literal KA0302$M_LILID1_IDENT = %X'FFFF';
literal KA0302$M_LILID2_IDENT = %X'FFFF';
literal KA0302$M_LILID3_IDENT = %X'FFFF';
literal KA0302$M_LCPUMASK_CPU0 = %X'F';
literal KA0302$M_LCPUMASK_CPU1 = %X'F0';
literal KA0302$M_LCPUMASK_CPU2 = %X'F00';
literal KA0302$M_LCPUMASK_CPU3 = %X'F000';
literal KA0302$M_IPCNSE_MBX_HOSE0_TIP = %X'1';
literal KA0302$M_IPCNSE_MBX_HOSE1_TIP = %X'2';
literal KA0302$M_IPCNSE_MBX_HOSE2_TIP = %X'4';
literal KA0302$M_IPCNSE_MBX_HOSE3_TIP = %X'8';
literal KA0302$M_IPCNSE_UPHOSE0_OFLO = %X'10';
literal KA0302$M_IPCNSE_UPHOSE1_OFLO = %X'20';
literal KA0302$M_IPCNSE_UPHOSE2_OFLO = %X'40';
literal KA0302$M_IPCNSE_UPHOSE3_OFLO = %X'80';
literal KA0302$M_IPCNSE_UPHOSE0_PKT_ERR = %X'100';
literal KA0302$M_IPCNSE_UPHOSE1_PKT_ERR = %X'200';
literal KA0302$M_IPCNSE_UPHOSE2_PKT_ERR = %X'400';
literal KA0302$M_IPCNSE_UPHOSE3_PKT_ERR = %X'800';
literal KA0302$M_IPCNSE_UPHOSE0_PAR_ERR = %X'1000';
literal KA0302$M_IPCNSE_UPHOSE1_PAR_ERR = %X'2000';
literal KA0302$M_IPCNSE_UPHOSE2_PAR_ERR = %X'4000';
literal KA0302$M_IPCNSE_UPHOSE3_PAR_ERR = %X'8000';
literal KA0302$M_IPCNSE_UP_HIC_IE = %X'10000';
literal KA0302$M_IPCNSE_IPC_INT_ERR = %X'20000';
literal KA0302$M_IPCNSE_UP_VRTX_ERR = %X'40000';
literal KA0302$M_IPCNSE_DN_VRTX_ERR = %X'80000';
literal KA0302$M_IPCNSE_MULT_INTR_ERR = %X'100000';
literal KA0302$M_IPCNSE_INTR_NSES = %X'80000000';
literal KA0302$M_IPCVR_VECTOR = %X'FFFF';
literal KA0302$M_IPCMSR_ARB_HIGH = %X'1';
literal KA0302$M_IPCMSR_ARB_CTL = %X'6';
literal KA0302$M_IPCHST_H0_ERROR = %X'1';
literal KA0302$M_IPCHST_H0_PWROK = %X'2';
literal KA0302$M_IPCHST_H0_CBLOK = %X'4';
literal KA0302$M_IPCHST_H0_PWROK_TRANS = %X'8';
literal KA0302$M_IPCHST_H1_ERROR = %X'10';
literal KA0302$M_IPCHST_H1_PWROK = %X'20';
literal KA0302$M_IPCHST_H1_CBLOK = %X'40';
literal KA0302$M_IPCHST_H1_PWROK_TRANS = %X'80';
literal KA0302$M_IPCHST_H2_ERROR = %X'100';
literal KA0302$M_IPCHST_H2_PWROK = %X'200';
literal KA0302$M_IPCHST_H2_CBLOK = %X'400';
literal KA0302$M_IPCHST_H2_PWROK_TRANS = %X'800';
literal KA0302$M_IPCHST_H3_ERROR = %X'1000';
literal KA0302$M_IPCHST_H3_PWROK = %X'2000';
literal KA0302$M_IPCHST_H3_CBLOK = %X'4000';
literal KA0302$M_IPCHST_H3_PWROK_TRANS = %X'8000';
literal KA0302$M_IPCHST_HOSE0_RST = %X'10000000';
literal KA0302$M_IPCHST_HOSE1_RST = %X'20000000';
literal KA0302$M_IPCHST_HOSE2_RST = %X'40000000';
literal KA0302$M_IPCHST_HOSE3_RST = %X'80000000';
literal KA0302$K_IPCHST_BUS_PRESENT = 6;
literal KA0302$M_IPCDR_FRC_DN_ILL_CMD = %X'1';
literal KA0302$M_IPCDR_FRC_DN_SEQ_ERR = %X'2';
literal KA0302$M_IPCDR_FRC_DN_DPE = %X'C';
literal KA0302$M_IPCDR_DIS_LSB_CMD = %X'400';
literal KA0302$M_IPCDR_HIC_LPBCK_EN = %X'800';
literal KA0302$M_IPCDR_FRC_DAT_PE = %X'1000';
literal KA0302$M_IPCDR_FRC_CMD_PE = %X'2000';
literal KA0302$M_IPCDR_FRC_CNFE = %X'400000';
literal KA0302$M_IPCDR_FRC_CAE = %X'800000';
literal KA0302$M_IPCDR_DIAG_ECC = %X'7F000000';
literal KA0302$M_IPCDR_DIAG_ECC_EN = %X'80000000';
literal KA0302$M_LIOINTR_CPU0 = %X'F';
literal KA0302$M_LIOINTR_CPU1 = %X'F0';
literal KA0302$M_LIOINTR_CPU2 = %X'F00';
literal KA0302$M_LIOINTR_CPU3 = %X'F000';
literal KA0302$M_LIPINTR_CPU0 = %X'F';
literal KA0302$M_LIPINTR_CPU1 = %X'F0';
literal KA0302$M_LIPINTR_CPU2 = %X'F00';
literal KA0302$M_LIPINTR_CPU3 = %X'F000';
literal KA0302$M_WATCH_CSRA_RS = %X'F';
literal KA0302$M_WATCH_CSRA_DV = %X'70';
literal KA0302$M_WATCH_CSRA_UIP = %X'80';
literal KA0302$M_WATCH_CSRB_DSE = %X'1';
literal KA0302$M_WATCH_CSRB_24_12 = %X'2';
literal KA0302$M_WATCH_CSRB_DM = %X'4';
literal KA0302$M_WATCH_CSRB_SQWE = %X'8';
literal KA0302$M_WATCH_CSRB_UIE = %X'10';
literal KA0302$M_WATCH_CSRB_AIE = %X'20';
literal KA0302$M_WATCH_CSRB_PIE = %X'40';
literal KA0302$M_WATCH_CSRB_SET = %X'80';
literal KA0302$M_WATCH_CSRC_UF = %X'10';
literal KA0302$M_WATCH_CSRC_AF = %X'20';
literal KA0302$M_WATCH_CSRC_PF = %X'40';
literal KA0302$M_WATCH_CSRC_IRQF = %X'80';
literal KA0302$M_WATCH_CSRD_VRT = %X'80';
literal KA0302$M_GBUS_WHAMI_NID = %X'7';
literal KA0302$M_GBUS_WHAMI_MFG = %X'8';
literal KA0302$M_GBUS_WHAMI_LSB_BAD = %X'10';
literal KA0302$M_GBUS_LEDS_STP = %X'1';
literal KA0302$M_GBUS_LEDS_CONW = %X'2';
literal KA0302$M_GBUS_LEDS_RUN = %X'4';
literal KA0302$M_GBUS_LEDS_LED3 = %X'8';
literal KA0302$M_GBUS_LEDS_LED4 = %X'10';
literal KA0302$M_GBUS_LEDS_LED5 = %X'20';
literal KA0302$M_GBUS_LEDS_LED6 = %X'40';
literal KA0302$M_GBUS_LEDS_LED7 = %X'80';
literal KA0302$M_GBUS_PMASK_HALTEN = %X'1';
literal KA0302$M_GBUS_PMASK_SELTERM = %X'6';
literal KA0302$M_GBUS_INTR_UARTINT0 = %X'1';
literal KA0302$M_GBUS_INTR_UARTINT1 = %X'2';
literal KA0302$M_GBUS_INTR_LSB0 = %X'4';
literal KA0302$M_GBUS_INTR_LSB2 = %X'20';
literal KA0302$M_GBUS_INTR_IP = %X'40';
literal KA0302$M_GBUS_INTR_INTIM = %X'80';
literal KA0302$M_GBUS_HALT_PHALT = %X'40';
literal KA0302$M_GBUS_HALT_NHALT = %X'80';
literal KA0302$M_GBUS_MISC_EXPSEL = %X'3';
literal KA0302$S_KA0302DEF = 262404;    !  Old size name, synonym for KA0302$S_KA0302
literal KA0302$S_KA0302 = 262404;
macro KA0302$L_SLOT0_LDEV = 0,0,32,0 %;
macro KA0302$V_SLOT0_LDEV_DTYPE = 0,0,16,0 %;
literal KA0302$S_SLOT0_LDEV_DTYPE = 16;
macro KA0302$V_SLOT0_LDEV_DREV = 0,16,16,0 %;
literal KA0302$S_SLOT0_LDEV_DREV = 16;
macro KA0302$b_fill10 = 4,0,0,0 %;
literal KA0302$s_fill10 = 60;
macro KA0302$L_SLOT0_LBER = 64,0,32,0 %;
macro KA0302$V_SLOT0_LBER_E = 64,0,1,0 %;
macro KA0302$V_SLOT0_LBER_UCE = 64,1,1,0 %;
macro KA0302$V_SLOT0_LBER_UCE2 = 64,2,1,0 %;
macro KA0302$V_SLOT0_LBER_CE = 64,3,1,0 %;
macro KA0302$V_SLOT0_LBER_CE2 = 64,4,1,0 %;
macro KA0302$V_SLOT0_LBER_CPE = 64,5,1,0 %;
macro KA0302$V_SLOT0_LBER_CPE2 = 64,6,1,0 %;
macro KA0302$V_SLOT0_LBER_CDPE = 64,7,1,0 %;
macro KA0302$V_SLOT0_LBER_CDPE2 = 64,8,1,0 %;
macro KA0302$V_SLOT0_LBER_TDE = 64,9,1,0 %;
macro KA0302$V_SLOT0_LBER_STE = 64,10,1,0 %;
macro KA0302$V_SLOT0_LBER_CNFE = 64,11,1,0 %;
macro KA0302$V_SLOT0_LBER_NXAE = 64,12,1,0 %;
macro KA0302$V_SLOT0_LBER_CAE = 64,13,1,0 %;
macro KA0302$V_SLOT0_LBER_SHE = 64,14,1,0 %;
macro KA0302$V_SLOT0_LBER_DIE = 64,15,1,0 %;
macro KA0302$V_SLOT0_LBER_DTCE = 64,16,1,0 %;
macro KA0302$V_SLOT0_LBER_CTCE = 64,17,1,0 %;
macro KA0302$V_SLOT0_LBER_NSES = 64,18,1,0 %;
macro KA0302$b_fill20 = 68,0,0,0 %;
literal KA0302$s_fill20 = 60;
macro KA0302$L_SLOT0_LCNR = 128,0,32,0 %;
macro KA0302$V_SLOT0_LCNR_CEEN = 128,0,1,0 %;
macro KA0302$V_SLOT0_LCNR_RSTSTAT = 128,28,1,0 %;
macro KA0302$V_SLOT0_LCNR_NHALT = 128,29,1,0 %;
macro KA0302$V_SLOT0_LCNR_NRST = 128,30,1,0 %;
macro KA0302$V_SLOT0_LCNR_STF = 128,31,1,0 %;
macro KA0302$b_fill25 = 132,0,0,0 %;
literal KA0302$s_fill25 = 60;
macro KA0302$L_SLOT0_IBR = 192,0,32,0 %;
macro KA0302$V_SLOT0_IBR_RCV_SDAT = 192,0,1,0 %;
macro KA0302$V_SLOT0_IBR_XMT_SDAT = 192,1,1,0 %;
macro KA0302$V_SLOT0_IBR_SCLK = 192,2,1,0 %;
macro KA0302$b_fill30 = 196,0,0,0 %;
literal KA0302$s_fill30 = 316;
macro KA0302$L_SLOT0_LMMR0 = 512,0,32,0 %;
macro KA0302$V_SLOT0_LMMR0_EN = 512,0,1,0 %;
macro KA0302$V_SLOT0_LMMR0_INT = 512,1,2,0 %;
literal KA0302$S_SLOT0_LMMR0_INT = 2;
macro KA0302$V_SLOT0_LMMR0_IA = 512,3,2,0 %;
literal KA0302$S_SLOT0_LMMR0_IA = 2;
macro KA0302$V_SLOT0_LMMR0_AW = 512,5,4,0 %;
literal KA0302$S_SLOT0_LMMR0_AW = 4;
macro KA0302$V_SLOT0_LMMR0_NBANKS = 512,9,2,0 %;
literal KA0302$S_SLOT0_LMMR0_NBANKS = 2;
macro KA0302$V_SLOT0_LMMR0_ADDR = 512,17,15,0 %;
literal KA0302$S_SLOT0_LMMR0_ADDR = 15;
macro KA0302$b_fill40 = 516,0,0,0 %;
literal KA0302$s_fill40 = 60;
macro KA0302$L_SLOT0_LMMR1 = 576,0,32,0 %;
macro KA0302$V_SLOT0_LMMR1_EN = 576,0,1,0 %;
macro KA0302$V_SLOT0_LMMR1_INT = 576,1,2,0 %;
literal KA0302$S_SLOT0_LMMR1_INT = 2;
macro KA0302$V_SLOT0_LMMR1_IA = 576,3,2,0 %;
literal KA0302$S_SLOT0_LMMR1_IA = 2;
macro KA0302$V_SLOT0_LMMR1_AW = 576,5,4,0 %;
literal KA0302$S_SLOT0_LMMR1_AW = 4;
macro KA0302$V_SLOT0_LMMR1_NBANKS = 576,9,2,0 %;
literal KA0302$S_SLOT0_LMMR1_NBANKS = 2;
macro KA0302$V_SLOT0_LMMR1_ADDR = 576,17,15,0 %;
literal KA0302$S_SLOT0_LMMR1_ADDR = 15;
macro KA0302$b_fill50 = 580,0,0,0 %;
literal KA0302$s_fill50 = 60;
macro KA0302$L_SLOT0_LMMR2 = 640,0,32,0 %;
macro KA0302$V_SLOT0_LMMR2_EN = 640,0,1,0 %;
macro KA0302$V_SLOT0_LMMR2_INT = 640,1,2,0 %;
literal KA0302$S_SLOT0_LMMR2_INT = 2;
macro KA0302$V_SLOT0_LMMR2_IA = 640,3,2,0 %;
literal KA0302$S_SLOT0_LMMR2_IA = 2;
macro KA0302$V_SLOT0_LMMR2_AW = 640,5,4,0 %;
literal KA0302$S_SLOT0_LMMR2_AW = 4;
macro KA0302$V_SLOT0_LMMR2_NBANKS = 640,9,2,0 %;
literal KA0302$S_SLOT0_LMMR2_NBANKS = 2;
macro KA0302$V_SLOT0_LMMR2_ADDR = 640,17,15,0 %;
literal KA0302$S_SLOT0_LMMR2_ADDR = 15;
macro KA0302$b_fill60 = 644,0,0,0 %;
literal KA0302$s_fill60 = 60;
macro KA0302$L_SLOT0_LMMR3 = 704,0,32,0 %;
macro KA0302$V_SLOT0_LMMR3_EN = 704,0,1,0 %;
macro KA0302$V_SLOT0_LMMR3_INT = 704,1,2,0 %;
literal KA0302$S_SLOT0_LMMR3_INT = 2;
macro KA0302$V_SLOT0_LMMR3_IA = 704,3,2,0 %;
literal KA0302$S_SLOT0_LMMR3_IA = 2;
macro KA0302$V_SLOT0_LMMR3_AW = 704,5,4,0 %;
literal KA0302$S_SLOT0_LMMR3_AW = 4;
macro KA0302$V_SLOT0_LMMR3_NBANKS = 704,9,2,0 %;
literal KA0302$S_SLOT0_LMMR3_NBANKS = 2;
macro KA0302$V_SLOT0_LMMR3_ADDR = 704,17,15,0 %;
literal KA0302$S_SLOT0_LMMR3_ADDR = 15;
macro KA0302$b_fill70 = 708,0,0,0 %;
literal KA0302$s_fill70 = 60;
macro KA0302$L_SLOT0_LMMR4 = 768,0,32,0 %;
macro KA0302$V_SLOT0_LMMR4_EN = 768,0,1,0 %;
macro KA0302$V_SLOT0_LMMR4_INT = 768,1,2,0 %;
literal KA0302$S_SLOT0_LMMR4_INT = 2;
macro KA0302$V_SLOT0_LMMR4_IA = 768,3,2,0 %;
literal KA0302$S_SLOT0_LMMR4_IA = 2;
macro KA0302$V_SLOT0_LMMR4_AW = 768,5,4,0 %;
literal KA0302$S_SLOT0_LMMR4_AW = 4;
macro KA0302$V_SLOT0_LMMR4_NBANKS = 768,9,2,0 %;
literal KA0302$S_SLOT0_LMMR4_NBANKS = 2;
macro KA0302$V_SLOT0_LMMR4_ADDR = 768,17,15,0 %;
literal KA0302$S_SLOT0_LMMR4_ADDR = 15;
macro KA0302$b_fill80 = 772,0,0,0 %;
literal KA0302$s_fill80 = 60;
macro KA0302$L_SLOT0_LMMR5 = 832,0,32,0 %;
macro KA0302$V_SLOT0_LMMR5_EN = 832,0,1,0 %;
macro KA0302$V_SLOT0_LMMR5_INT = 832,1,2,0 %;
literal KA0302$S_SLOT0_LMMR5_INT = 2;
macro KA0302$V_SLOT0_LMMR5_IA = 832,3,2,0 %;
literal KA0302$S_SLOT0_LMMR5_IA = 2;
macro KA0302$V_SLOT0_LMMR5_AW = 832,5,4,0 %;
literal KA0302$S_SLOT0_LMMR5_AW = 4;
macro KA0302$V_SLOT0_LMMR5_NBANKS = 832,9,2,0 %;
literal KA0302$S_SLOT0_LMMR5_NBANKS = 2;
macro KA0302$V_SLOT0_LMMR5_ADDR = 832,17,15,0 %;
literal KA0302$S_SLOT0_LMMR5_ADDR = 15;
macro KA0302$b_fill90 = 836,0,0,0 %;
literal KA0302$s_fill90 = 60;
macro KA0302$L_SLOT0_LMMR6 = 896,0,32,0 %;
macro KA0302$V_SLOT0_LMMR6_EN = 896,0,1,0 %;
macro KA0302$V_SLOT0_LMMR6_INT = 896,1,2,0 %;
literal KA0302$S_SLOT0_LMMR6_INT = 2;
macro KA0302$V_SLOT0_LMMR6_IA = 896,3,2,0 %;
literal KA0302$S_SLOT0_LMMR6_IA = 2;
macro KA0302$V_SLOT0_LMMR6_AW = 896,5,4,0 %;
literal KA0302$S_SLOT0_LMMR6_AW = 4;
macro KA0302$V_SLOT0_LMMR6_NBANKS = 896,9,2,0 %;
literal KA0302$S_SLOT0_LMMR6_NBANKS = 2;
macro KA0302$V_SLOT0_LMMR6_ADDR = 896,17,15,0 %;
literal KA0302$S_SLOT0_LMMR6_ADDR = 15;
macro KA0302$b_fill100 = 900,0,0,0 %;
literal KA0302$s_fill100 = 60;
macro KA0302$L_SLOT0_LMMR7 = 960,0,32,0 %;
macro KA0302$V_SLOT0_LMMR7_EN = 960,0,1,0 %;
macro KA0302$V_SLOT0_LMMR7_INT = 960,1,2,0 %;
literal KA0302$S_SLOT0_LMMR7_INT = 2;
macro KA0302$V_SLOT0_LMMR7_IA = 960,3,2,0 %;
literal KA0302$S_SLOT0_LMMR7_IA = 2;
macro KA0302$V_SLOT0_LMMR7_AW = 960,5,4,0 %;
literal KA0302$S_SLOT0_LMMR7_AW = 4;
macro KA0302$V_SLOT0_LMMR7_NBANKS = 960,9,2,0 %;
literal KA0302$S_SLOT0_LMMR7_NBANKS = 2;
macro KA0302$V_SLOT0_LMMR7_ADDR = 960,17,15,0 %;
literal KA0302$S_SLOT0_LMMR7_ADDR = 15;
macro KA0302$b_fill110 = 964,0,0,0 %;
literal KA0302$s_fill110 = 572;
macro KA0302$L_SLOT0_LBESR0 = 1536,0,32,0 %;
macro KA0302$V_SLOT0_LBESR0_SYNDROME = 1536,0,7,0 %;
literal KA0302$S_SLOT0_LBESR0_SYNDROME = 7;
macro KA0302$b_fill120 = 1540,0,0,0 %;
literal KA0302$s_fill120 = 60;
macro KA0302$L_SLOT0_LBESR1 = 1600,0,32,0 %;
macro KA0302$V_SLOT0_LBESR1_SYNDROME = 1600,0,7,0 %;
literal KA0302$S_SLOT0_LBESR1_SYNDROME = 7;
macro KA0302$b_fill130 = 1604,0,0,0 %;
literal KA0302$s_fill130 = 60;
macro KA0302$L_SLOT0_LBESR2 = 1664,0,32,0 %;
macro KA0302$V_SLOT0_LBESR2_SYNDROME = 1664,0,7,0 %;
literal KA0302$S_SLOT0_LBESR2_SYNDROME = 7;
macro KA0302$b_fill140 = 1668,0,0,0 %;
literal KA0302$s_fill140 = 60;
macro KA0302$L_SLOT0_LBESR3 = 1728,0,32,0 %;
macro KA0302$V_SLOT0_LBESR3_SYNDROME = 1728,0,7,0 %;
literal KA0302$S_SLOT0_LBESR3_SYNDROME = 7;
macro KA0302$b_fill150 = 1732,0,0,0 %;
literal KA0302$s_fill150 = 60;
macro KA0302$L_SLOT0_LBECR0 = 1792,0,32,0 %;
macro KA0302$L_SLOT0_LBECR0_CA = 1792,0,32,0 %;
macro KA0302$b_fill160 = 1796,0,0,0 %;
literal KA0302$s_fill160 = 60;
macro KA0302$L_SLOT0_LBECR1 = 1856,0,32,0 %;
macro KA0302$V_SLOT0_LBECR1_CA = 1856,0,7,0 %;
literal KA0302$S_SLOT0_LBECR1_CA = 7;
macro KA0302$V_SLOT0_LBECR1_CID = 1856,7,4,0 %;
literal KA0302$S_SLOT0_LBECR1_CID = 4;
macro KA0302$V_SLOT0_LBECR1_RID = 1856,11,4,0 %;
literal KA0302$S_SLOT0_LBECR1_RID = 4;
macro KA0302$V_SLOT0_LBECR1_CNF = 1856,15,1,0 %;
macro KA0302$V_SLOT0_LBECR1_SHARED = 1856,16,1,0 %;
macro KA0302$V_SLOT0_LBECR1_DIRTY = 1856,17,1,0 %;
macro KA0302$V_SLOT0_LBECR1_DCYCLE = 1856,18,2,0 %;
literal KA0302$S_SLOT0_LBECR1_DCYCLE = 2;
macro KA0302$b_fill170 = 1860,0,0,0 %;
literal KA0302$s_fill170 = 1212;
macro KA0302$L_SLOT0_LMODE = 3072,0,32,0 %;
macro KA0302$b_fill180 = 3076,0,0,0 %;
literal KA0302$s_fill180 = 60;
macro KA0302$L_SLOT0_LMERR = 3136,0,32,0 %;
macro KA0302$b_fill190 = 3140,0,0,0 %;
literal KA0302$s_fill190 = 60;
macro KA0302$L_SLOT0_LLOCK = 3200,0,32,0 %;
macro KA0302$b_fill200 = 3204,0,0,0 %;
literal KA0302$s_fill200 = 60;
macro KA0302$L_SLOT0_LEDTO = 3264,0,32,0 %;
macro KA0302$b_fill210 = 3268,0,0,0 %;
literal KA0302$s_fill210 = 60;
macro KA0302$L_SLOT0_LDIAG = 3328,0,32,0 %;
macro KA0302$b_fill220 = 3332,0,0,0 %;
literal KA0302$s_fill220 = 60;
macro KA0302$L_SLOT0_LTAGA = 3392,0,32,0 %;
macro KA0302$b_fill230 = 3396,0,0,0 %;
literal KA0302$s_fill230 = 60;
macro KA0302$L_SLOT0_LTAGW = 3456,0,32,0 %;
macro KA0302$b_fill240 = 3460,0,0,0 %;
literal KA0302$s_fill240 = 124;
macro KA0302$L_SLOT0_LCON0 = 3584,0,32,0 %;
macro KA0302$b_fill250 = 3588,0,0,0 %;
literal KA0302$s_fill250 = 60;
macro KA0302$L_SLOT0_LCON1 = 3648,0,32,0 %;
macro KA0302$b_fill260 = 3652,0,0,0 %;
literal KA0302$s_fill260 = 188;
macro KA0302$L_SLOT0_LPERF = 3840,0,32,0 %;
macro KA0302$b_fill270 = 3844,0,0,0 %;
literal KA0302$s_fill270 = 60;
macro KA0302$L_SLOT0_LCNTR0 = 3904,0,32,0 %;
macro KA0302$b_fill280 = 3908,0,0,0 %;
literal KA0302$s_fill280 = 60;
macro KA0302$L_SLOT0_LCNTR1 = 3968,0,32,0 %;
macro KA0302$b_fill290 = 3972,0,0,0 %;
literal KA0302$s_fill290 = 60;
macro KA0302$L_SLOT0_LMISSADDR = 4032,0,32,0 %;
macro KA0302$b_fill300 = 4036,0,0,0 %;
literal KA0302$s_fill300 = 4156;
macro KA0302$L_SLOT0_MCR = 8192,0,32,0 %;
macro KA0302$V_SLOT0_MCR_DTYPE = 8192,0,1,0 %;
macro KA0302$V_SLOT0_MCR_STRN = 8192,2,2,0 %;
literal KA0302$S_SLOT0_MCR_STRN = 2;
macro KA0302$b_fill305 = 8196,0,0,0 %;
literal KA0302$s_fill305 = 60;
macro KA0302$L_SLOT0_AMR = 8256,0,32,0 %;
macro KA0302$V_SLOT0_AMR_E = 8256,0,1,0 %;
macro KA0302$V_SLOT0_AMR_INTL = 8256,1,2,0 %;
literal KA0302$S_SLOT0_AMR_INTL = 2;
macro KA0302$V_SLOT0_AMR_IA = 8256,3,2,0 %;
literal KA0302$S_SLOT0_AMR_IA = 2;
macro KA0302$V_SLOT0_AMR_AW = 8256,5,4,0 %;
literal KA0302$S_SLOT0_AMR_AW = 4;
macro KA0302$V_SLOT0_AMR_NBANKS = 8256,9,2,0 %;
literal KA0302$S_SLOT0_AMR_NBANKS = 2;
macro KA0302$V_SLOT0_AMR_MADR = 8256,17,15,0 %;
literal KA0302$S_SLOT0_AMR_MADR = 15;
macro KA0302$b_fill310 = 8260,0,0,0 %;
literal KA0302$s_fill310 = 60;
macro KA0302$L_SLOT0_MSTR0 = 8320,0,32,0 %;
macro KA0302$b_fill320 = 8324,0,0,0 %;
literal KA0302$s_fill320 = 60;
macro KA0302$L_SLOT0_MSTR1 = 8384,0,32,0 %;
macro KA0302$b_fill330 = 8388,0,0,0 %;
literal KA0302$s_fill330 = 60;
macro KA0302$L_SLOT0_FADR = 8448,0,32,0 %;
macro KA0302$b_fill340 = 8452,0,0,0 %;
literal KA0302$s_fill340 = 60;
macro KA0302$L_SLOT0_MERA = 8512,0,32,0 %;
macro KA0302$V_SLOT0_MERA_CER = 8512,0,1,0 %;
macro KA0302$V_SLOT0_MERA_UCER = 8512,1,1,0 %;
macro KA0302$V_SLOT0_MERA_MULE = 8512,2,1,0 %;
macro KA0302$V_SLOT0_MERA_APER = 8512,3,1,0 %;
macro KA0302$V_SLOT0_MERA_CERA = 8512,4,1,0 %;
macro KA0302$V_SLOT0_MERA_CERB = 8512,5,1,0 %;
macro KA0302$V_SLOT0_MERA_FSTR = 8512,6,3,0 %;
literal KA0302$S_SLOT0_MERA_FSTR = 3;
macro KA0302$V_SLOT0_MERA_BNKER = 8512,9,1,0 %;
macro KA0302$V_SLOT0_MERA_UCERA = 8512,10,1,0 %;
macro KA0302$V_SLOT0_MERA_UCERB = 8512,11,1,0 %;
macro KA0302$b_fill350 = 8516,0,0,0 %;
literal KA0302$s_fill350 = 60;
macro KA0302$L_SLOT0_MSYNDA = 8576,0,32,0 %;
macro KA0302$V_SLOT0_MSYNDA_SYND = 8576,0,8,0 %;
literal KA0302$S_SLOT0_MSYNDA_SYND = 8;
macro KA0302$b_fill360 = 8580,0,0,0 %;
literal KA0302$s_fill360 = 60;
macro KA0302$L_SLOT0_MDRA = 8640,0,32,0 %;
macro KA0302$V_SLOT0_MDRA_FCBS = 8640,0,1,0 %;
macro KA0302$V_SLOT0_MDRA_DRDC = 8640,1,1,0 %;
macro KA0302$V_SLOT0_MDRA_DWDC = 8640,2,1,0 %;
macro KA0302$V_SLOT0_MDRA_BPAS = 8640,3,1,0 %;
macro KA0302$V_SLOT0_MDRA_EXST = 8640,4,1,0 %;
macro KA0302$V_SLOT0_MDRA_STPM = 8640,5,1,0 %;
macro KA0302$V_SLOT0_MDRA_MODE = 8640,6,1,0 %;
macro KA0302$V_SLOT0_MDRA_IGSB = 8640,7,1,0 %;
macro KA0302$V_SLOT0_MDRA_FRPE = 8640,8,1,0 %;
macro KA0302$V_SLOT0_MDRA_FCPE = 8640,9,1,0 %;
macro KA0302$V_SLOT0_MDRA_DCRD = 8640,27,1,0 %;
macro KA0302$V_SLOT0_MDRA_RFR = 8640,28,2,0 %;
literal KA0302$S_SLOT0_MDRA_RFR = 2;
macro KA0302$V_SLOT0_MDRA_BRFSH = 8640,30,1,0 %;
macro KA0302$V_SLOT0_MDRA_DRFSH = 8640,31,1,0 %;
macro KA0302$b_fill370 = 8644,0,0,0 %;
literal KA0302$s_fill370 = 60;
macro KA0302$L_SLOT0_MCBSA = 8704,0,32,0 %;
macro KA0302$V_SLOT0_MCBSA_SCB = 8704,0,8,0 %;
literal KA0302$S_SLOT0_MCBSA_SCB = 8;
macro KA0302$b_fill380 = 8708,0,0,0 %;
literal KA0302$s_fill380 = 7996;
macro KA0302$L_SLOT0_MERB = 16704,0,32,0 %;
macro KA0302$V_SLOT0_MERB_CER = 16704,0,1,0 %;
macro KA0302$V_SLOT0_MERB_UCER = 16704,1,1,0 %;
macro KA0302$V_SLOT0_MERB_MULE = 16704,2,1,0 %;
macro KA0302$V_SLOT0_MERB_APER = 16704,3,1,0 %;
macro KA0302$b_fill390 = 16708,0,0,0 %;
literal KA0302$s_fill390 = 60;
macro KA0302$L_SLOT0_MSYNDB = 16768,0,32,0 %;
macro KA0302$V_SLOT0_MSYNDB_SYND = 16768,0,8,0 %;
literal KA0302$S_SLOT0_MSYNDB_SYND = 8;
macro KA0302$b_fill400 = 16772,0,0,0 %;
literal KA0302$s_fill400 = 60;
macro KA0302$L_SLOT0_MDRB = 16832,0,32,0 %;
macro KA0302$V_SLOT0_MDRB_FCBS = 16832,0,1,0 %;
macro KA0302$V_SLOT0_MDRB_DRDC = 16832,1,1,0 %;
macro KA0302$V_SLOT0_MDRB_DWDC = 16832,2,1,0 %;
macro KA0302$V_SLOT0_MDRB_BPAS = 16832,3,1,0 %;
macro KA0302$V_SLOT0_MDRB_EXST = 16832,4,1,0 %;
macro KA0302$V_SLOT0_MDRB_STPM = 16832,5,1,0 %;
macro KA0302$V_SLOT0_MDRB_MODE = 16832,6,1,0 %;
macro KA0302$V_SLOT0_MDRB_IGSB = 16832,7,1,0 %;
macro KA0302$b_fill410 = 16836,0,0,0 %;
literal KA0302$s_fill410 = 60;
macro KA0302$L_SLOT0_MCBSB = 16896,0,32,0 %;
macro KA0302$V_SLOT0_MCBSB_SCB = 16896,0,8,0 %;
literal KA0302$S_SLOT0_MCBSB_SCB = 8;
macro KA0302$b_fill420 = 16900,0,0,0 %;
literal KA0302$s_fill420 = 7676;
macro KA0302$L_SLOT1_LDEV = 24576,0,32,0 %;
macro KA0302$V_SLOT1_LDEV_DTYPE = 24576,0,16,0 %;
literal KA0302$S_SLOT1_LDEV_DTYPE = 16;
macro KA0302$V_SLOT1_LDEV_DREV = 24576,16,16,0 %;
literal KA0302$S_SLOT1_LDEV_DREV = 16;
macro KA0302$b_fill430 = 24580,0,0,0 %;
literal KA0302$s_fill430 = 60;
macro KA0302$L_SLOT1_LBER = 24640,0,32,0 %;
macro KA0302$V_SLOT1_LBER_E = 24640,0,1,0 %;
macro KA0302$V_SLOT1_LBER_UCE = 24640,1,1,0 %;
macro KA0302$V_SLOT1_LBER_UCE2 = 24640,2,1,0 %;
macro KA0302$V_SLOT1_LBER_CE = 24640,3,1,0 %;
macro KA0302$V_SLOT1_LBER_CE2 = 24640,4,1,0 %;
macro KA0302$V_SLOT1_LBER_CPE = 24640,5,1,0 %;
macro KA0302$V_SLOT1_LBER_CPE2 = 24640,6,1,0 %;
macro KA0302$V_SLOT1_LBER_CDPE = 24640,7,1,0 %;
macro KA0302$V_SLOT1_LBER_CDPE2 = 24640,8,1,0 %;
macro KA0302$V_SLOT1_LBER_TDE = 24640,9,1,0 %;
macro KA0302$V_SLOT1_LBER_STE = 24640,10,1,0 %;
macro KA0302$V_SLOT1_LBER_CNFE = 24640,11,1,0 %;
macro KA0302$V_SLOT1_LBER_NXAE = 24640,12,1,0 %;
macro KA0302$V_SLOT1_LBER_CAE = 24640,13,1,0 %;
macro KA0302$V_SLOT1_LBER_SHE = 24640,14,1,0 %;
macro KA0302$V_SLOT1_LBER_DIE = 24640,15,1,0 %;
macro KA0302$V_SLOT1_LBER_DTCE = 24640,16,1,0 %;
macro KA0302$V_SLOT1_LBER_CTCE = 24640,17,1,0 %;
macro KA0302$V_SLOT1_LBER_NSES = 24640,18,1,0 %;
macro KA0302$b_fill440 = 24644,0,0,0 %;
literal KA0302$s_fill440 = 60;
macro KA0302$L_SLOT1_LCNR = 24704,0,32,0 %;
macro KA0302$V_SLOT1_LCNR_CEEN = 24704,0,1,0 %;
macro KA0302$V_SLOT1_LCNR_RSTSTAT = 24704,28,1,0 %;
macro KA0302$V_SLOT1_LCNR_NHALT = 24704,29,1,0 %;
macro KA0302$V_SLOT1_LCNR_NRST = 24704,30,1,0 %;
macro KA0302$V_SLOT1_LCNR_STF = 24704,31,1,0 %;
macro KA0302$b_fill445 = 24708,0,0,0 %;
literal KA0302$s_fill445 = 60;
macro KA0302$L_SLOT1_IBR = 24768,0,32,0 %;
macro KA0302$V_SLOT1_IBR_RCV_SDAT = 24768,0,1,0 %;
macro KA0302$V_SLOT1_IBR_XMT_SDAT = 24768,1,1,0 %;
macro KA0302$V_SLOT1_IBR_SCLK = 24768,2,1,0 %;
macro KA0302$b_fill450 = 24772,0,0,0 %;
literal KA0302$s_fill450 = 316;
macro KA0302$L_SLOT1_LMMR0 = 25088,0,32,0 %;
macro KA0302$V_SLOT1_LMMR0_EN = 25088,0,1,0 %;
macro KA0302$V_SLOT1_LMMR0_INT = 25088,1,2,0 %;
literal KA0302$S_SLOT1_LMMR0_INT = 2;
macro KA0302$V_SLOT1_LMMR0_IA = 25088,3,2,0 %;
literal KA0302$S_SLOT1_LMMR0_IA = 2;
macro KA0302$V_SLOT1_LMMR0_AW = 25088,5,4,0 %;
literal KA0302$S_SLOT1_LMMR0_AW = 4;
macro KA0302$V_SLOT1_LMMR0_NBANKS = 25088,9,2,0 %;
literal KA0302$S_SLOT1_LMMR0_NBANKS = 2;
macro KA0302$V_SLOT1_LMMR0_ADDR = 25088,17,15,0 %;
literal KA0302$S_SLOT1_LMMR0_ADDR = 15;
macro KA0302$b_fill460 = 25092,0,0,0 %;
literal KA0302$s_fill460 = 60;
macro KA0302$L_SLOT1_LMMR1 = 25152,0,32,0 %;
macro KA0302$V_SLOT1_LMMR1_EN = 25152,0,1,0 %;
macro KA0302$V_SLOT1_LMMR1_INT = 25152,1,2,0 %;
literal KA0302$S_SLOT1_LMMR1_INT = 2;
macro KA0302$V_SLOT1_LMMR1_IA = 25152,3,2,0 %;
literal KA0302$S_SLOT1_LMMR1_IA = 2;
macro KA0302$V_SLOT1_LMMR1_AW = 25152,5,4,0 %;
literal KA0302$S_SLOT1_LMMR1_AW = 4;
macro KA0302$V_SLOT1_LMMR1_NBANKS = 25152,9,2,0 %;
literal KA0302$S_SLOT1_LMMR1_NBANKS = 2;
macro KA0302$V_SLOT1_LMMR1_ADDR = 25152,17,15,0 %;
literal KA0302$S_SLOT1_LMMR1_ADDR = 15;
macro KA0302$b_fill470 = 25156,0,0,0 %;
literal KA0302$s_fill470 = 60;
macro KA0302$L_SLOT1_LMMR2 = 25216,0,32,0 %;
macro KA0302$V_SLOT1_LMMR2_EN = 25216,0,1,0 %;
macro KA0302$V_SLOT1_LMMR2_INT = 25216,1,2,0 %;
literal KA0302$S_SLOT1_LMMR2_INT = 2;
macro KA0302$V_SLOT1_LMMR2_IA = 25216,3,2,0 %;
literal KA0302$S_SLOT1_LMMR2_IA = 2;
macro KA0302$V_SLOT1_LMMR2_AW = 25216,5,4,0 %;
literal KA0302$S_SLOT1_LMMR2_AW = 4;
macro KA0302$V_SLOT1_LMMR2_NBANKS = 25216,9,2,0 %;
literal KA0302$S_SLOT1_LMMR2_NBANKS = 2;
macro KA0302$V_SLOT1_LMMR2_ADDR = 25216,17,15,0 %;
literal KA0302$S_SLOT1_LMMR2_ADDR = 15;
macro KA0302$b_fill480 = 25220,0,0,0 %;
literal KA0302$s_fill480 = 60;
macro KA0302$L_SLOT1_LMMR3 = 25280,0,32,0 %;
macro KA0302$V_SLOT1_LMMR3_EN = 25280,0,1,0 %;
macro KA0302$V_SLOT1_LMMR3_INT = 25280,1,2,0 %;
literal KA0302$S_SLOT1_LMMR3_INT = 2;
macro KA0302$V_SLOT1_LMMR3_IA = 25280,3,2,0 %;
literal KA0302$S_SLOT1_LMMR3_IA = 2;
macro KA0302$V_SLOT1_LMMR3_AW = 25280,5,4,0 %;
literal KA0302$S_SLOT1_LMMR3_AW = 4;
macro KA0302$V_SLOT1_LMMR3_NBANKS = 25280,9,2,0 %;
literal KA0302$S_SLOT1_LMMR3_NBANKS = 2;
macro KA0302$V_SLOT1_LMMR3_ADDR = 25280,17,15,0 %;
literal KA0302$S_SLOT1_LMMR3_ADDR = 15;
macro KA0302$b_fill490 = 25284,0,0,0 %;
literal KA0302$s_fill490 = 60;
macro KA0302$L_SLOT1_LMMR4 = 25344,0,32,0 %;
macro KA0302$V_SLOT1_LMMR4_EN = 25344,0,1,0 %;
macro KA0302$V_SLOT1_LMMR4_INT = 25344,1,2,0 %;
literal KA0302$S_SLOT1_LMMR4_INT = 2;
macro KA0302$V_SLOT1_LMMR4_IA = 25344,3,2,0 %;
literal KA0302$S_SLOT1_LMMR4_IA = 2;
macro KA0302$V_SLOT1_LMMR4_AW = 25344,5,4,0 %;
literal KA0302$S_SLOT1_LMMR4_AW = 4;
macro KA0302$V_SLOT1_LMMR4_NBANKS = 25344,9,2,0 %;
literal KA0302$S_SLOT1_LMMR4_NBANKS = 2;
macro KA0302$V_SLOT1_LMMR4_ADDR = 25344,17,15,0 %;
literal KA0302$S_SLOT1_LMMR4_ADDR = 15;
macro KA0302$b_fill500 = 25348,0,0,0 %;
literal KA0302$s_fill500 = 60;
macro KA0302$L_SLOT1_LMMR5 = 25408,0,32,0 %;
macro KA0302$V_SLOT1_LMMR5_EN = 25408,0,1,0 %;
macro KA0302$V_SLOT1_LMMR5_INT = 25408,1,2,0 %;
literal KA0302$S_SLOT1_LMMR5_INT = 2;
macro KA0302$V_SLOT1_LMMR5_IA = 25408,3,2,0 %;
literal KA0302$S_SLOT1_LMMR5_IA = 2;
macro KA0302$V_SLOT1_LMMR5_AW = 25408,5,4,0 %;
literal KA0302$S_SLOT1_LMMR5_AW = 4;
macro KA0302$V_SLOT1_LMMR5_NBANKS = 25408,9,2,0 %;
literal KA0302$S_SLOT1_LMMR5_NBANKS = 2;
macro KA0302$V_SLOT1_LMMR5_ADDR = 25408,17,15,0 %;
literal KA0302$S_SLOT1_LMMR5_ADDR = 15;
macro KA0302$b_fill510 = 25412,0,0,0 %;
literal KA0302$s_fill510 = 60;
macro KA0302$L_SLOT1_LMMR6 = 25472,0,32,0 %;
macro KA0302$V_SLOT1_LMMR6_EN = 25472,0,1,0 %;
macro KA0302$V_SLOT1_LMMR6_INT = 25472,1,2,0 %;
literal KA0302$S_SLOT1_LMMR6_INT = 2;
macro KA0302$V_SLOT1_LMMR6_IA = 25472,3,2,0 %;
literal KA0302$S_SLOT1_LMMR6_IA = 2;
macro KA0302$V_SLOT1_LMMR6_AW = 25472,5,4,0 %;
literal KA0302$S_SLOT1_LMMR6_AW = 4;
macro KA0302$V_SLOT1_LMMR6_NBANKS = 25472,9,2,0 %;
literal KA0302$S_SLOT1_LMMR6_NBANKS = 2;
macro KA0302$V_SLOT1_LMMR6_ADDR = 25472,17,15,0 %;
literal KA0302$S_SLOT1_LMMR6_ADDR = 15;
macro KA0302$b_fill520 = 25476,0,0,0 %;
literal KA0302$s_fill520 = 60;
macro KA0302$L_SLOT1_LMMR7 = 25536,0,32,0 %;
macro KA0302$V_SLOT1_LMMR7_EN = 25536,0,1,0 %;
macro KA0302$V_SLOT1_LMMR7_INT = 25536,1,2,0 %;
literal KA0302$S_SLOT1_LMMR7_INT = 2;
macro KA0302$V_SLOT1_LMMR7_IA = 25536,3,2,0 %;
literal KA0302$S_SLOT1_LMMR7_IA = 2;
macro KA0302$V_SLOT1_LMMR7_AW = 25536,5,4,0 %;
literal KA0302$S_SLOT1_LMMR7_AW = 4;
macro KA0302$V_SLOT1_LMMR7_NBANKS = 25536,9,2,0 %;
literal KA0302$S_SLOT1_LMMR7_NBANKS = 2;
macro KA0302$V_SLOT1_LMMR7_ADDR = 25536,17,15,0 %;
literal KA0302$S_SLOT1_LMMR7_ADDR = 15;
macro KA0302$b_fill530 = 25540,0,0,0 %;
literal KA0302$s_fill530 = 572;
macro KA0302$L_SLOT1_LBESR0 = 26112,0,32,0 %;
macro KA0302$V_SLOT1_LBESR0_SYNDROME = 26112,0,7,0 %;
literal KA0302$S_SLOT1_LBESR0_SYNDROME = 7;
macro KA0302$b_fill540 = 26116,0,0,0 %;
literal KA0302$s_fill540 = 60;
macro KA0302$L_SLOT1_LBESR1 = 26176,0,32,0 %;
macro KA0302$V_SLOT1_LBESR1_SYNDROME = 26176,0,7,0 %;
literal KA0302$S_SLOT1_LBESR1_SYNDROME = 7;
macro KA0302$b_fill550 = 26180,0,0,0 %;
literal KA0302$s_fill550 = 60;
macro KA0302$L_SLOT1_LBESR2 = 26240,0,32,0 %;
macro KA0302$V_SLOT1_LBESR2_SYNDROME = 26240,0,7,0 %;
literal KA0302$S_SLOT1_LBESR2_SYNDROME = 7;
macro KA0302$b_fill560 = 26244,0,0,0 %;
literal KA0302$s_fill560 = 60;
macro KA0302$L_SLOT1_LBESR3 = 26304,0,32,0 %;
macro KA0302$V_SLOT1_LBESR3_SYNDROME = 26304,0,7,0 %;
literal KA0302$S_SLOT1_LBESR3_SYNDROME = 7;
macro KA0302$b_fill570 = 26308,0,0,0 %;
literal KA0302$s_fill570 = 60;
macro KA0302$L_SLOT1_LBECR0 = 26368,0,32,0 %;
macro KA0302$L_SLOT1_LBECR0_CA = 26368,0,32,0 %;
macro KA0302$b_fill580 = 26372,0,0,0 %;
literal KA0302$s_fill580 = 60;
macro KA0302$L_SLOT1_LBECR1 = 26432,0,32,0 %;
macro KA0302$V_SLOT1_LBECR1_CA = 26432,0,7,0 %;
literal KA0302$S_SLOT1_LBECR1_CA = 7;
macro KA0302$V_SLOT1_LBECR1_CID = 26432,7,4,0 %;
literal KA0302$S_SLOT1_LBECR1_CID = 4;
macro KA0302$V_SLOT1_LBECR1_RID = 26432,11,4,0 %;
literal KA0302$S_SLOT1_LBECR1_RID = 4;
macro KA0302$V_SLOT1_LBECR1_CNF = 26432,15,1,0 %;
macro KA0302$V_SLOT1_LBECR1_SHARED = 26432,16,1,0 %;
macro KA0302$V_SLOT1_LBECR1_DIRTY = 26432,17,1,0 %;
macro KA0302$V_SLOT1_LBECR1_DCYCLE = 26432,18,2,0 %;
literal KA0302$S_SLOT1_LBECR1_DCYCLE = 2;
macro KA0302$b_fill590 = 26436,0,0,0 %;
literal KA0302$s_fill590 = 1212;
macro KA0302$L_SLOT1_LMODE = 27648,0,32,0 %;
macro KA0302$b_fill600 = 27652,0,0,0 %;
literal KA0302$s_fill600 = 60;
macro KA0302$L_SLOT1_LMERR = 27712,0,32,0 %;
macro KA0302$b_fill610 = 27716,0,0,0 %;
literal KA0302$s_fill610 = 60;
macro KA0302$L_SLOT1_LLOCK = 27776,0,32,0 %;
macro KA0302$b_fill620 = 27780,0,0,0 %;
literal KA0302$s_fill620 = 60;
macro KA0302$L_SLOT1_LEDTO = 27840,0,32,0 %;
macro KA0302$b_fill630 = 27844,0,0,0 %;
literal KA0302$s_fill630 = 60;
macro KA0302$L_SLOT1_LDIAG = 27904,0,32,0 %;
macro KA0302$b_fill640 = 27908,0,0,0 %;
literal KA0302$s_fill640 = 60;
macro KA0302$L_SLOT1_LTAGA = 27968,0,32,0 %;
macro KA0302$b_fill650 = 27972,0,0,0 %;
literal KA0302$s_fill650 = 60;
macro KA0302$L_SLOT1_LTAGW = 28032,0,32,0 %;
macro KA0302$b_fill660 = 28036,0,0,0 %;
literal KA0302$s_fill660 = 124;
macro KA0302$L_SLOT1_LCON0 = 28160,0,32,0 %;
macro KA0302$b_fill670 = 28164,0,0,0 %;
literal KA0302$s_fill670 = 60;
macro KA0302$L_SLOT1_LCON1 = 28224,0,32,0 %;
macro KA0302$b_fill680 = 28228,0,0,0 %;
literal KA0302$s_fill680 = 188;
macro KA0302$L_SLOT1_LPERF = 28416,0,32,0 %;
macro KA0302$b_fill690 = 28420,0,0,0 %;
literal KA0302$s_fill690 = 60;
macro KA0302$L_SLOT1_LCNTR0 = 28480,0,32,0 %;
macro KA0302$b_fill700 = 28484,0,0,0 %;
literal KA0302$s_fill700 = 60;
macro KA0302$L_SLOT1_LCNTR1 = 28544,0,32,0 %;
macro KA0302$b_fill705 = 28548,0,0,0 %;
literal KA0302$s_fill705 = 60;
macro KA0302$L_SLOT1_LMISSADDR = 28608,0,32,0 %;
macro KA0302$b_fill706 = 28612,0,0,0 %;
literal KA0302$s_fill706 = 4156;
macro KA0302$L_SLOT1_MCR = 32768,0,32,0 %;
macro KA0302$b_fill710 = 32772,0,0,0 %;
literal KA0302$s_fill710 = 60;
macro KA0302$L_SLOT1_AMR = 32832,0,32,0 %;
macro KA0302$b_fill720 = 32836,0,0,0 %;
literal KA0302$s_fill720 = 60;
macro KA0302$L_SLOT1_MSTR0 = 32896,0,32,0 %;
macro KA0302$b_fill730 = 32900,0,0,0 %;
literal KA0302$s_fill730 = 60;
macro KA0302$L_SLOT1_MSTR1 = 32960,0,32,0 %;
macro KA0302$b_fill740 = 32964,0,0,0 %;
literal KA0302$s_fill740 = 60;
macro KA0302$L_SLOT1_FADR = 33024,0,32,0 %;
macro KA0302$b_fill750 = 33028,0,0,0 %;
literal KA0302$s_fill750 = 60;
macro KA0302$L_SLOT1_MERA = 33088,0,32,0 %;
macro KA0302$b_fill760 = 33092,0,0,0 %;
literal KA0302$s_fill760 = 60;
macro KA0302$L_SLOT1_MSYNDA = 33152,0,32,0 %;
macro KA0302$b_fill770 = 33156,0,0,0 %;
literal KA0302$s_fill770 = 60;
macro KA0302$L_SLOT1_MDRA = 33216,0,32,0 %;
macro KA0302$b_fill780 = 33220,0,0,0 %;
literal KA0302$s_fill780 = 60;
macro KA0302$L_SLOT1_MCBSA = 33280,0,32,0 %;
macro KA0302$b_fill790 = 33284,0,0,0 %;
literal KA0302$s_fill790 = 7996;
macro KA0302$L_SLOT1_MERB = 41280,0,32,0 %;
macro KA0302$b_fill800 = 41284,0,0,0 %;
literal KA0302$s_fill800 = 60;
macro KA0302$L_SLOT1_MSYNDB = 41344,0,32,0 %;
macro KA0302$b_fill810 = 41348,0,0,0 %;
literal KA0302$s_fill810 = 60;
macro KA0302$L_SLOT1_MDRB = 41408,0,32,0 %;
macro KA0302$b_fill820 = 41412,0,0,0 %;
literal KA0302$s_fill820 = 60;
macro KA0302$L_SLOT1_MCBSB = 41472,0,32,0 %;
macro KA0302$b_fill830 = 41476,0,0,0 %;
literal KA0302$s_fill830 = 7676;
macro KA0302$L_SLOT2_LDEV = 49152,0,32,0 %;
macro KA0302$V_SLOT2_LDEV_DTYPE = 49152,0,16,0 %;
literal KA0302$S_SLOT2_LDEV_DTYPE = 16;
macro KA0302$V_SLOT2_LDEV_DREV = 49152,16,16,0 %;
literal KA0302$S_SLOT2_LDEV_DREV = 16;
macro KA0302$b_fill840 = 49156,0,0,0 %;
literal KA0302$s_fill840 = 60;
macro KA0302$L_SLOT2_LBER = 49216,0,32,0 %;
macro KA0302$V_SLOT2_LBER_E = 49216,0,1,0 %;
macro KA0302$V_SLOT2_LBER_UCE = 49216,1,1,0 %;
macro KA0302$V_SLOT2_LBER_UCE2 = 49216,2,1,0 %;
macro KA0302$V_SLOT2_LBER_CE = 49216,3,1,0 %;
macro KA0302$V_SLOT2_LBER_CE2 = 49216,4,1,0 %;
macro KA0302$V_SLOT2_LBER_CPE = 49216,5,1,0 %;
macro KA0302$V_SLOT2_LBER_CPE2 = 49216,6,1,0 %;
macro KA0302$V_SLOT2_LBER_CDPE = 49216,7,1,0 %;
macro KA0302$V_SLOT2_LBER_CDPE2 = 49216,8,1,0 %;
macro KA0302$V_SLOT2_LBER_TDE = 49216,9,1,0 %;
macro KA0302$V_SLOT2_LBER_STE = 49216,10,1,0 %;
macro KA0302$V_SLOT2_LBER_CNFE = 49216,11,1,0 %;
macro KA0302$V_SLOT2_LBER_NXAE = 49216,12,1,0 %;
macro KA0302$V_SLOT2_LBER_CAE = 49216,13,1,0 %;
macro KA0302$V_SLOT2_LBER_SHE = 49216,14,1,0 %;
macro KA0302$V_SLOT2_LBER_DIE = 49216,15,1,0 %;
macro KA0302$V_SLOT2_LBER_DTCE = 49216,16,1,0 %;
macro KA0302$V_SLOT2_LBER_CTCE = 49216,17,1,0 %;
macro KA0302$V_SLOT2_LBER_NSES = 49216,18,1,0 %;
macro KA0302$b_fill850 = 49220,0,0,0 %;
literal KA0302$s_fill850 = 60;
macro KA0302$L_SLOT2_LCNR = 49280,0,32,0 %;
macro KA0302$V_SLOT2_LCNR_CEEN = 49280,0,1,0 %;
macro KA0302$V_SLOT2_LCNR_RSTSTAT = 49280,28,1,0 %;
macro KA0302$V_SLOT2_LCNR_NHALT = 49280,29,1,0 %;
macro KA0302$V_SLOT2_LCNR_NRST = 49280,30,1,0 %;
macro KA0302$V_SLOT2_LCNR_STF = 49280,31,1,0 %;
macro KA0302$b_fill855 = 49284,0,0,0 %;
literal KA0302$s_fill855 = 60;
macro KA0302$L_SLOT2_IBR = 49344,0,32,0 %;
macro KA0302$V_SLOT2_IBR_RCV_SDAT = 49344,0,1,0 %;
macro KA0302$V_SLOT2_IBR_XMT_SDAT = 49344,1,1,0 %;
macro KA0302$V_SLOT2_IBR_SCLK = 49344,2,1,0 %;
macro KA0302$b_fill860 = 49348,0,0,0 %;
literal KA0302$s_fill860 = 316;
macro KA0302$L_SLOT2_LMMR0 = 49664,0,32,0 %;
macro KA0302$V_SLOT2_LMMR0_EN = 49664,0,1,0 %;
macro KA0302$V_SLOT2_LMMR0_INT = 49664,1,2,0 %;
literal KA0302$S_SLOT2_LMMR0_INT = 2;
macro KA0302$V_SLOT2_LMMR0_IA = 49664,3,2,0 %;
literal KA0302$S_SLOT2_LMMR0_IA = 2;
macro KA0302$V_SLOT2_LMMR0_AW = 49664,5,4,0 %;
literal KA0302$S_SLOT2_LMMR0_AW = 4;
macro KA0302$V_SLOT2_LMMR0_NBANKS = 49664,9,2,0 %;
literal KA0302$S_SLOT2_LMMR0_NBANKS = 2;
macro KA0302$V_SLOT2_LMMR0_ADDR = 49664,17,15,0 %;
literal KA0302$S_SLOT2_LMMR0_ADDR = 15;
macro KA0302$b_fill870 = 49668,0,0,0 %;
literal KA0302$s_fill870 = 60;
macro KA0302$L_SLOT2_LMMR1 = 49728,0,32,0 %;
macro KA0302$V_SLOT2_LMMR1_EN = 49728,0,1,0 %;
macro KA0302$V_SLOT2_LMMR1_INT = 49728,1,2,0 %;
literal KA0302$S_SLOT2_LMMR1_INT = 2;
macro KA0302$V_SLOT2_LMMR1_IA = 49728,3,2,0 %;
literal KA0302$S_SLOT2_LMMR1_IA = 2;
macro KA0302$V_SLOT2_LMMR1_AW = 49728,5,4,0 %;
literal KA0302$S_SLOT2_LMMR1_AW = 4;
macro KA0302$V_SLOT2_LMMR1_NBANKS = 49728,9,2,0 %;
literal KA0302$S_SLOT2_LMMR1_NBANKS = 2;
macro KA0302$V_SLOT2_LMMR1_ADDR = 49728,17,15,0 %;
literal KA0302$S_SLOT2_LMMR1_ADDR = 15;
macro KA0302$b_fill880 = 49732,0,0,0 %;
literal KA0302$s_fill880 = 60;
macro KA0302$L_SLOT2_LMMR2 = 49792,0,32,0 %;
macro KA0302$V_SLOT2_LMMR2_EN = 49792,0,1,0 %;
macro KA0302$V_SLOT2_LMMR2_INT = 49792,1,2,0 %;
literal KA0302$S_SLOT2_LMMR2_INT = 2;
macro KA0302$V_SLOT2_LMMR2_IA = 49792,3,2,0 %;
literal KA0302$S_SLOT2_LMMR2_IA = 2;
macro KA0302$V_SLOT2_LMMR2_AW = 49792,5,4,0 %;
literal KA0302$S_SLOT2_LMMR2_AW = 4;
macro KA0302$V_SLOT2_LMMR2_NBANKS = 49792,9,2,0 %;
literal KA0302$S_SLOT2_LMMR2_NBANKS = 2;
macro KA0302$V_SLOT2_LMMR2_ADDR = 49792,17,15,0 %;
literal KA0302$S_SLOT2_LMMR2_ADDR = 15;
macro KA0302$b_fill890 = 49796,0,0,0 %;
literal KA0302$s_fill890 = 60;
macro KA0302$L_SLOT2_LMMR3 = 49856,0,32,0 %;
macro KA0302$V_SLOT2_LMMR3_EN = 49856,0,1,0 %;
macro KA0302$V_SLOT2_LMMR3_INT = 49856,1,2,0 %;
literal KA0302$S_SLOT2_LMMR3_INT = 2;
macro KA0302$V_SLOT2_LMMR3_IA = 49856,3,2,0 %;
literal KA0302$S_SLOT2_LMMR3_IA = 2;
macro KA0302$V_SLOT2_LMMR3_AW = 49856,5,4,0 %;
literal KA0302$S_SLOT2_LMMR3_AW = 4;
macro KA0302$V_SLOT2_LMMR3_NBANKS = 49856,9,2,0 %;
literal KA0302$S_SLOT2_LMMR3_NBANKS = 2;
macro KA0302$V_SLOT2_LMMR3_ADDR = 49856,17,15,0 %;
literal KA0302$S_SLOT2_LMMR3_ADDR = 15;
macro KA0302$b_fill900 = 49860,0,0,0 %;
literal KA0302$s_fill900 = 60;
macro KA0302$L_SLOT2_LMMR4 = 49920,0,32,0 %;
macro KA0302$V_SLOT2_LMMR4_EN = 49920,0,1,0 %;
macro KA0302$V_SLOT2_LMMR4_INT = 49920,1,2,0 %;
literal KA0302$S_SLOT2_LMMR4_INT = 2;
macro KA0302$V_SLOT2_LMMR4_IA = 49920,3,2,0 %;
literal KA0302$S_SLOT2_LMMR4_IA = 2;
macro KA0302$V_SLOT2_LMMR4_AW = 49920,5,4,0 %;
literal KA0302$S_SLOT2_LMMR4_AW = 4;
macro KA0302$V_SLOT2_LMMR4_NBANKS = 49920,9,2,0 %;
literal KA0302$S_SLOT2_LMMR4_NBANKS = 2;
macro KA0302$V_SLOT2_LMMR4_ADDR = 49920,17,15,0 %;
literal KA0302$S_SLOT2_LMMR4_ADDR = 15;
macro KA0302$b_fill910 = 49924,0,0,0 %;
literal KA0302$s_fill910 = 60;
macro KA0302$L_SLOT2_LMMR5 = 49984,0,32,0 %;
macro KA0302$V_SLOT2_LMMR5_EN = 49984,0,1,0 %;
macro KA0302$V_SLOT2_LMMR5_INT = 49984,1,2,0 %;
literal KA0302$S_SLOT2_LMMR5_INT = 2;
macro KA0302$V_SLOT2_LMMR5_IA = 49984,3,2,0 %;
literal KA0302$S_SLOT2_LMMR5_IA = 2;
macro KA0302$V_SLOT2_LMMR5_AW = 49984,5,4,0 %;
literal KA0302$S_SLOT2_LMMR5_AW = 4;
macro KA0302$V_SLOT2_LMMR5_NBANKS = 49984,9,2,0 %;
literal KA0302$S_SLOT2_LMMR5_NBANKS = 2;
macro KA0302$V_SLOT2_LMMR5_ADDR = 49984,17,15,0 %;
literal KA0302$S_SLOT2_LMMR5_ADDR = 15;
macro KA0302$b_fill920 = 49988,0,0,0 %;
literal KA0302$s_fill920 = 60;
macro KA0302$L_SLOT2_LMMR6 = 50048,0,32,0 %;
macro KA0302$V_SLOT2_LMMR6_EN = 50048,0,1,0 %;
macro KA0302$V_SLOT2_LMMR6_INT = 50048,1,2,0 %;
literal KA0302$S_SLOT2_LMMR6_INT = 2;
macro KA0302$V_SLOT2_LMMR6_IA = 50048,3,2,0 %;
literal KA0302$S_SLOT2_LMMR6_IA = 2;
macro KA0302$V_SLOT2_LMMR6_AW = 50048,5,4,0 %;
literal KA0302$S_SLOT2_LMMR6_AW = 4;
macro KA0302$V_SLOT2_LMMR6_NBANKS = 50048,9,2,0 %;
literal KA0302$S_SLOT2_LMMR6_NBANKS = 2;
macro KA0302$V_SLOT2_LMMR6_ADDR = 50048,17,15,0 %;
literal KA0302$S_SLOT2_LMMR6_ADDR = 15;
macro KA0302$b_fill930 = 50052,0,0,0 %;
literal KA0302$s_fill930 = 60;
macro KA0302$L_SLOT2_LMMR7 = 50112,0,32,0 %;
macro KA0302$V_SLOT2_LMMR7_EN = 50112,0,1,0 %;
macro KA0302$V_SLOT2_LMMR7_INT = 50112,1,2,0 %;
literal KA0302$S_SLOT2_LMMR7_INT = 2;
macro KA0302$V_SLOT2_LMMR7_IA = 50112,3,2,0 %;
literal KA0302$S_SLOT2_LMMR7_IA = 2;
macro KA0302$V_SLOT2_LMMR7_AW = 50112,5,4,0 %;
literal KA0302$S_SLOT2_LMMR7_AW = 4;
macro KA0302$V_SLOT2_LMMR7_NBANKS = 50112,9,2,0 %;
literal KA0302$S_SLOT2_LMMR7_NBANKS = 2;
macro KA0302$V_SLOT2_LMMR7_ADDR = 50112,17,15,0 %;
literal KA0302$S_SLOT2_LMMR7_ADDR = 15;
macro KA0302$b_fill940 = 50116,0,0,0 %;
literal KA0302$s_fill940 = 572;
macro KA0302$L_SLOT2_LBESR0 = 50688,0,32,0 %;
macro KA0302$V_SLOT2_LBESR0_SYNDROME = 50688,0,7,0 %;
literal KA0302$S_SLOT2_LBESR0_SYNDROME = 7;
macro KA0302$b_fill950 = 50692,0,0,0 %;
literal KA0302$s_fill950 = 60;
macro KA0302$L_SLOT2_LBESR1 = 50752,0,32,0 %;
macro KA0302$V_SLOT2_LBESR1_SYNDROME = 50752,0,7,0 %;
literal KA0302$S_SLOT2_LBESR1_SYNDROME = 7;
macro KA0302$b_fill960 = 50756,0,0,0 %;
literal KA0302$s_fill960 = 60;
macro KA0302$L_SLOT2_LBESR2 = 50816,0,32,0 %;
macro KA0302$V_SLOT2_LBESR2_SYNDROME = 50816,0,7,0 %;
literal KA0302$S_SLOT2_LBESR2_SYNDROME = 7;
macro KA0302$b_fill970 = 50820,0,0,0 %;
literal KA0302$s_fill970 = 60;
macro KA0302$L_SLOT2_LBESR3 = 50880,0,32,0 %;
macro KA0302$V_SLOT2_LBESR3_SYNDROME = 50880,0,7,0 %;
literal KA0302$S_SLOT2_LBESR3_SYNDROME = 7;
macro KA0302$b_fill980 = 50884,0,0,0 %;
literal KA0302$s_fill980 = 60;
macro KA0302$L_SLOT2_LBECR0 = 50944,0,32,0 %;
macro KA0302$L_SLOT2_LBECR0_CA = 50944,0,32,0 %;
macro KA0302$b_fill990 = 50948,0,0,0 %;
literal KA0302$s_fill990 = 60;
macro KA0302$L_SLOT2_LBECR1 = 51008,0,32,0 %;
macro KA0302$V_SLOT2_LBECR1_CA = 51008,0,7,0 %;
literal KA0302$S_SLOT2_LBECR1_CA = 7;
macro KA0302$V_SLOT2_LBECR1_CID = 51008,7,4,0 %;
literal KA0302$S_SLOT2_LBECR1_CID = 4;
macro KA0302$V_SLOT2_LBECR1_RID = 51008,11,4,0 %;
literal KA0302$S_SLOT2_LBECR1_RID = 4;
macro KA0302$V_SLOT2_LBECR1_CNF = 51008,15,1,0 %;
macro KA0302$V_SLOT2_LBECR1_SHARED = 51008,16,1,0 %;
macro KA0302$V_SLOT2_LBECR1_DIRTY = 51008,17,1,0 %;
macro KA0302$V_SLOT2_LBECR1_DCYCLE = 51008,18,2,0 %;
literal KA0302$S_SLOT2_LBECR1_DCYCLE = 2;
macro KA0302$b_fill1000 = 51012,0,0,0 %;
literal KA0302$s_fill1000 = 1212;
macro KA0302$L_SLOT2_LMODE = 52224,0,32,0 %;
macro KA0302$b_fill1010 = 52228,0,0,0 %;
literal KA0302$s_fill1010 = 60;
macro KA0302$L_SLOT2_LMERR = 52288,0,32,0 %;
macro KA0302$b_fill1020 = 52292,0,0,0 %;
literal KA0302$s_fill1020 = 60;
macro KA0302$L_SLOT2_LLOCK = 52352,0,32,0 %;
macro KA0302$b_fill1030 = 52356,0,0,0 %;
literal KA0302$s_fill1030 = 60;
macro KA0302$L_SLOT2_LEDTO = 52416,0,32,0 %;
macro KA0302$b_fill1040 = 52420,0,0,0 %;
literal KA0302$s_fill1040 = 60;
macro KA0302$L_SLOT2_LDIAG = 52480,0,32,0 %;
macro KA0302$b_fill1050 = 52484,0,0,0 %;
literal KA0302$s_fill1050 = 60;
macro KA0302$L_SLOT2_LTAGA = 52544,0,32,0 %;
macro KA0302$b_fill1060 = 52548,0,0,0 %;
literal KA0302$s_fill1060 = 60;
macro KA0302$L_SLOT2_LTAGW = 52608,0,32,0 %;
macro KA0302$b_fill1070 = 52612,0,0,0 %;
literal KA0302$s_fill1070 = 124;
macro KA0302$L_SLOT2_LCON0 = 52736,0,32,0 %;
macro KA0302$b_fill1080 = 52740,0,0,0 %;
literal KA0302$s_fill1080 = 60;
macro KA0302$L_SLOT2_LCON1 = 52800,0,32,0 %;
macro KA0302$b_fill1090 = 52804,0,0,0 %;
literal KA0302$s_fill1090 = 188;
macro KA0302$L_SLOT2_LPERF = 52992,0,32,0 %;
macro KA0302$b_fill1100 = 52996,0,0,0 %;
literal KA0302$s_fill1100 = 60;
macro KA0302$L_SLOT2_LCNTR0 = 53056,0,32,0 %;
macro KA0302$b_fill1110 = 53060,0,0,0 %;
literal KA0302$s_fill1110 = 60;
macro KA0302$L_SLOT2_LCNTR1 = 53120,0,32,0 %;
macro KA0302$b_fill1120 = 53124,0,0,0 %;
literal KA0302$s_fill1120 = 60;
macro KA0302$L_SLOT2_LMISSADDR = 53184,0,32,0 %;
macro KA0302$b_fill1125 = 53188,0,0,0 %;
literal KA0302$s_fill1125 = 4156;
macro KA0302$L_SLOT2_MCR = 57344,0,32,0 %;
macro KA0302$b_fill1130 = 57348,0,0,0 %;
literal KA0302$s_fill1130 = 60;
macro KA0302$L_SLOT2_AMR = 57408,0,32,0 %;
macro KA0302$b_fill1140 = 57412,0,0,0 %;
literal KA0302$s_fill1140 = 60;
macro KA0302$L_SLOT2_MSTR0 = 57472,0,32,0 %;
macro KA0302$b_fill1150 = 57476,0,0,0 %;
literal KA0302$s_fill1150 = 60;
macro KA0302$L_SLOT2_MSTR1 = 57536,0,32,0 %;
macro KA0302$b_fill1160 = 57540,0,0,0 %;
literal KA0302$s_fill1160 = 60;
macro KA0302$L_SLOT2_FADR = 57600,0,32,0 %;
macro KA0302$b_fill1170 = 57604,0,0,0 %;
literal KA0302$s_fill1170 = 60;
macro KA0302$L_SLOT2_MERA = 57664,0,32,0 %;
macro KA0302$b_fill1180 = 57668,0,0,0 %;
literal KA0302$s_fill1180 = 60;
macro KA0302$L_SLOT2_MSYNDA = 57728,0,32,0 %;
macro KA0302$b_fill1190 = 57732,0,0,0 %;
literal KA0302$s_fill1190 = 60;
macro KA0302$L_SLOT2_MDRA = 57792,0,32,0 %;
macro KA0302$b_fill1200 = 57796,0,0,0 %;
literal KA0302$s_fill1200 = 60;
macro KA0302$L_SLOT2_MCBSA = 57856,0,32,0 %;
macro KA0302$b_fill1210 = 57860,0,0,0 %;
literal KA0302$s_fill1210 = 7996;
macro KA0302$L_SLOT2_MERB = 65856,0,32,0 %;
macro KA0302$b_fill1220 = 65860,0,0,0 %;
literal KA0302$s_fill1220 = 60;
macro KA0302$L_SLOT2_MSYNDB = 65920,0,32,0 %;
macro KA0302$b_fill1230 = 65924,0,0,0 %;
literal KA0302$s_fill1230 = 60;
macro KA0302$L_SLOT2_MDRB = 65984,0,32,0 %;
macro KA0302$b_fill1240 = 65988,0,0,0 %;
literal KA0302$s_fill1240 = 60;
macro KA0302$L_SLOT2_MCBSB = 66048,0,32,0 %;
macro KA0302$b_fill1250 = 66052,0,0,0 %;
literal KA0302$s_fill1250 = 7676;
macro KA0302$L_SLOT3_LDEV = 73728,0,32,0 %;
macro KA0302$V_SLOT3_LDEV_DTYPE = 73728,0,16,0 %;
literal KA0302$S_SLOT3_LDEV_DTYPE = 16;
macro KA0302$V_SLOT3_LDEV_DREV = 73728,16,16,0 %;
literal KA0302$S_SLOT3_LDEV_DREV = 16;
macro KA0302$b_fill1260 = 73732,0,0,0 %;
literal KA0302$s_fill1260 = 60;
macro KA0302$L_SLOT3_LBER = 73792,0,32,0 %;
macro KA0302$V_SLOT3_LBER_E = 73792,0,1,0 %;
macro KA0302$V_SLOT3_LBER_UCE = 73792,1,1,0 %;
macro KA0302$V_SLOT3_LBER_UCE2 = 73792,2,1,0 %;
macro KA0302$V_SLOT3_LBER_CE = 73792,3,1,0 %;
macro KA0302$V_SLOT3_LBER_CE2 = 73792,4,1,0 %;
macro KA0302$V_SLOT3_LBER_CPE = 73792,5,1,0 %;
macro KA0302$V_SLOT3_LBER_CPE2 = 73792,6,1,0 %;
macro KA0302$V_SLOT3_LBER_CDPE = 73792,7,1,0 %;
macro KA0302$V_SLOT3_LBER_CDPE2 = 73792,8,1,0 %;
macro KA0302$V_SLOT3_LBER_TDE = 73792,9,1,0 %;
macro KA0302$V_SLOT3_LBER_STE = 73792,10,1,0 %;
macro KA0302$V_SLOT3_LBER_CNFE = 73792,11,1,0 %;
macro KA0302$V_SLOT3_LBER_NXAE = 73792,12,1,0 %;
macro KA0302$V_SLOT3_LBER_CAE = 73792,13,1,0 %;
macro KA0302$V_SLOT3_LBER_SHE = 73792,14,1,0 %;
macro KA0302$V_SLOT3_LBER_DIE = 73792,15,1,0 %;
macro KA0302$V_SLOT3_LBER_DTCE = 73792,16,1,0 %;
macro KA0302$V_SLOT3_LBER_CTCE = 73792,17,1,0 %;
macro KA0302$V_SLOT3_LBER_NSES = 73792,18,1,0 %;
macro KA0302$b_fill1270 = 73796,0,0,0 %;
literal KA0302$s_fill1270 = 60;
macro KA0302$L_SLOT3_LCNR = 73856,0,32,0 %;
macro KA0302$V_SLOT3_LCNR_CEEN = 73856,0,1,0 %;
macro KA0302$V_SLOT3_LCNR_RSTSTAT = 73856,28,1,0 %;
macro KA0302$V_SLOT3_LCNR_NHALT = 73856,29,1,0 %;
macro KA0302$V_SLOT3_LCNR_NRST = 73856,30,1,0 %;
macro KA0302$V_SLOT3_LCNR_STF = 73856,31,1,0 %;
macro KA0302$b_fill275 = 73860,0,0,0 %;
literal KA0302$s_fill275 = 60;
macro KA0302$L_SLOT3_IBR = 73920,0,32,0 %;
macro KA0302$V_SLOT3_IBR_RCV_SDAT = 73920,0,1,0 %;
macro KA0302$V_SLOT3_IBR_XMT_SDAT = 73920,1,1,0 %;
macro KA0302$V_SLOT3_IBR_SCLK = 73920,2,1,0 %;
macro KA0302$b_fill1280 = 73924,0,0,0 %;
literal KA0302$s_fill1280 = 316;
macro KA0302$L_SLOT3_LMMR0 = 74240,0,32,0 %;
macro KA0302$V_SLOT3_LMMR0_EN = 74240,0,1,0 %;
macro KA0302$V_SLOT3_LMMR0_INT = 74240,1,2,0 %;
literal KA0302$S_SLOT3_LMMR0_INT = 2;
macro KA0302$V_SLOT3_LMMR0_IA = 74240,3,2,0 %;
literal KA0302$S_SLOT3_LMMR0_IA = 2;
macro KA0302$V_SLOT3_LMMR0_AW = 74240,5,4,0 %;
literal KA0302$S_SLOT3_LMMR0_AW = 4;
macro KA0302$V_SLOT3_LMMR0_NBANKS = 74240,9,2,0 %;
literal KA0302$S_SLOT3_LMMR0_NBANKS = 2;
macro KA0302$V_SLOT3_LMMR0_ADDR = 74240,17,15,0 %;
literal KA0302$S_SLOT3_LMMR0_ADDR = 15;
macro KA0302$b_fill1290 = 74244,0,0,0 %;
literal KA0302$s_fill1290 = 60;
macro KA0302$L_SLOT3_LMMR1 = 74304,0,32,0 %;
macro KA0302$V_SLOT3_LMMR1_EN = 74304,0,1,0 %;
macro KA0302$V_SLOT3_LMMR1_INT = 74304,1,2,0 %;
literal KA0302$S_SLOT3_LMMR1_INT = 2;
macro KA0302$V_SLOT3_LMMR1_IA = 74304,3,2,0 %;
literal KA0302$S_SLOT3_LMMR1_IA = 2;
macro KA0302$V_SLOT3_LMMR1_AW = 74304,5,4,0 %;
literal KA0302$S_SLOT3_LMMR1_AW = 4;
macro KA0302$V_SLOT3_LMMR1_NBANKS = 74304,9,2,0 %;
literal KA0302$S_SLOT3_LMMR1_NBANKS = 2;
macro KA0302$V_SLOT3_LMMR1_ADDR = 74304,17,15,0 %;
literal KA0302$S_SLOT3_LMMR1_ADDR = 15;
macro KA0302$b_fill1300 = 74308,0,0,0 %;
literal KA0302$s_fill1300 = 60;
macro KA0302$L_SLOT3_LMMR2 = 74368,0,32,0 %;
macro KA0302$V_SLOT3_LMMR2_EN = 74368,0,1,0 %;
macro KA0302$V_SLOT3_LMMR2_INT = 74368,1,2,0 %;
literal KA0302$S_SLOT3_LMMR2_INT = 2;
macro KA0302$V_SLOT3_LMMR2_IA = 74368,3,2,0 %;
literal KA0302$S_SLOT3_LMMR2_IA = 2;
macro KA0302$V_SLOT3_LMMR2_AW = 74368,5,4,0 %;
literal KA0302$S_SLOT3_LMMR2_AW = 4;
macro KA0302$V_SLOT3_LMMR2_NBANKS = 74368,9,2,0 %;
literal KA0302$S_SLOT3_LMMR2_NBANKS = 2;
macro KA0302$V_SLOT3_LMMR2_ADDR = 74368,17,15,0 %;
literal KA0302$S_SLOT3_LMMR2_ADDR = 15;
macro KA0302$b_fill1310 = 74372,0,0,0 %;
literal KA0302$s_fill1310 = 60;
macro KA0302$L_SLOT3_LMMR3 = 74432,0,32,0 %;
macro KA0302$V_SLOT3_LMMR3_EN = 74432,0,1,0 %;
macro KA0302$V_SLOT3_LMMR3_INT = 74432,1,2,0 %;
literal KA0302$S_SLOT3_LMMR3_INT = 2;
macro KA0302$V_SLOT3_LMMR3_IA = 74432,3,2,0 %;
literal KA0302$S_SLOT3_LMMR3_IA = 2;
macro KA0302$V_SLOT3_LMMR3_AW = 74432,5,4,0 %;
literal KA0302$S_SLOT3_LMMR3_AW = 4;
macro KA0302$V_SLOT3_LMMR3_NBANKS = 74432,9,2,0 %;
literal KA0302$S_SLOT3_LMMR3_NBANKS = 2;
macro KA0302$V_SLOT3_LMMR3_ADDR = 74432,17,15,0 %;
literal KA0302$S_SLOT3_LMMR3_ADDR = 15;
macro KA0302$b_fill1320 = 74436,0,0,0 %;
literal KA0302$s_fill1320 = 60;
macro KA0302$L_SLOT3_LMMR4 = 74496,0,32,0 %;
macro KA0302$V_SLOT3_LMMR4_EN = 74496,0,1,0 %;
macro KA0302$V_SLOT3_LMMR4_INT = 74496,1,2,0 %;
literal KA0302$S_SLOT3_LMMR4_INT = 2;
macro KA0302$V_SLOT3_LMMR4_IA = 74496,3,2,0 %;
literal KA0302$S_SLOT3_LMMR4_IA = 2;
macro KA0302$V_SLOT3_LMMR4_AW = 74496,5,4,0 %;
literal KA0302$S_SLOT3_LMMR4_AW = 4;
macro KA0302$V_SLOT3_LMMR4_NBANKS = 74496,9,2,0 %;
literal KA0302$S_SLOT3_LMMR4_NBANKS = 2;
macro KA0302$V_SLOT3_LMMR4_ADDR = 74496,17,15,0 %;
literal KA0302$S_SLOT3_LMMR4_ADDR = 15;
macro KA0302$b_fill1330 = 74500,0,0,0 %;
literal KA0302$s_fill1330 = 60;
macro KA0302$L_SLOT3_LMMR5 = 74560,0,32,0 %;
macro KA0302$V_SLOT3_LMMR5_EN = 74560,0,1,0 %;
macro KA0302$V_SLOT3_LMMR5_INT = 74560,1,2,0 %;
literal KA0302$S_SLOT3_LMMR5_INT = 2;
macro KA0302$V_SLOT3_LMMR5_IA = 74560,3,2,0 %;
literal KA0302$S_SLOT3_LMMR5_IA = 2;
macro KA0302$V_SLOT3_LMMR5_AW = 74560,5,4,0 %;
literal KA0302$S_SLOT3_LMMR5_AW = 4;
macro KA0302$V_SLOT3_LMMR5_NBANKS = 74560,9,2,0 %;
literal KA0302$S_SLOT3_LMMR5_NBANKS = 2;
macro KA0302$V_SLOT3_LMMR5_ADDR = 74560,17,15,0 %;
literal KA0302$S_SLOT3_LMMR5_ADDR = 15;
macro KA0302$b_fill1340 = 74564,0,0,0 %;
literal KA0302$s_fill1340 = 60;
macro KA0302$L_SLOT3_LMMR6 = 74624,0,32,0 %;
macro KA0302$V_SLOT3_LMMR6_EN = 74624,0,1,0 %;
macro KA0302$V_SLOT3_LMMR6_INT = 74624,1,2,0 %;
literal KA0302$S_SLOT3_LMMR6_INT = 2;
macro KA0302$V_SLOT3_LMMR6_IA = 74624,3,2,0 %;
literal KA0302$S_SLOT3_LMMR6_IA = 2;
macro KA0302$V_SLOT3_LMMR6_AW = 74624,5,4,0 %;
literal KA0302$S_SLOT3_LMMR6_AW = 4;
macro KA0302$V_SLOT3_LMMR6_NBANKS = 74624,9,2,0 %;
literal KA0302$S_SLOT3_LMMR6_NBANKS = 2;
macro KA0302$V_SLOT3_LMMR6_ADDR = 74624,17,15,0 %;
literal KA0302$S_SLOT3_LMMR6_ADDR = 15;
macro KA0302$b_fill1350 = 74628,0,0,0 %;
literal KA0302$s_fill1350 = 60;
macro KA0302$L_SLOT3_LMMR7 = 74688,0,32,0 %;
macro KA0302$V_SLOT3_LMMR7_EN = 74688,0,1,0 %;
macro KA0302$V_SLOT3_LMMR7_INT = 74688,1,2,0 %;
literal KA0302$S_SLOT3_LMMR7_INT = 2;
macro KA0302$V_SLOT3_LMMR7_IA = 74688,3,2,0 %;
literal KA0302$S_SLOT3_LMMR7_IA = 2;
macro KA0302$V_SLOT3_LMMR7_AW = 74688,5,4,0 %;
literal KA0302$S_SLOT3_LMMR7_AW = 4;
macro KA0302$V_SLOT3_LMMR7_NBANKS = 74688,9,2,0 %;
literal KA0302$S_SLOT3_LMMR7_NBANKS = 2;
macro KA0302$V_SLOT3_LMMR7_ADDR = 74688,17,15,0 %;
literal KA0302$S_SLOT3_LMMR7_ADDR = 15;
macro KA0302$b_fill1360 = 74692,0,0,0 %;
literal KA0302$s_fill1360 = 572;
macro KA0302$L_SLOT3_LBESR0 = 75264,0,32,0 %;
macro KA0302$V_SLOT3_LBESR0_SYNDROME = 75264,0,7,0 %;
literal KA0302$S_SLOT3_LBESR0_SYNDROME = 7;
macro KA0302$b_fill1370 = 75268,0,0,0 %;
literal KA0302$s_fill1370 = 60;
macro KA0302$L_SLOT3_LBESR1 = 75328,0,32,0 %;
macro KA0302$V_SLOT3_LBESR1_SYNDROME = 75328,0,7,0 %;
literal KA0302$S_SLOT3_LBESR1_SYNDROME = 7;
macro KA0302$b_fill1380 = 75332,0,0,0 %;
literal KA0302$s_fill1380 = 60;
macro KA0302$L_SLOT3_LBESR2 = 75392,0,32,0 %;
macro KA0302$V_SLOT3_LBESR2_SYNDROME = 75392,0,7,0 %;
literal KA0302$S_SLOT3_LBESR2_SYNDROME = 7;
macro KA0302$b_fill1390 = 75396,0,0,0 %;
literal KA0302$s_fill1390 = 60;
macro KA0302$L_SLOT3_LBESR3 = 75456,0,32,0 %;
macro KA0302$V_SLOT3_LBESR3_SYNDROME = 75456,0,7,0 %;
literal KA0302$S_SLOT3_LBESR3_SYNDROME = 7;
macro KA0302$b_fill1400 = 75460,0,0,0 %;
literal KA0302$s_fill1400 = 60;
macro KA0302$L_SLOT3_LBECR0 = 75520,0,32,0 %;
macro KA0302$L_SLOT3_LBECR0_CA = 75520,0,32,0 %;
macro KA0302$b_fill1410 = 75524,0,0,0 %;
literal KA0302$s_fill1410 = 60;
macro KA0302$L_SLOT3_LBECR1 = 75584,0,32,0 %;
macro KA0302$V_SLOT3_LBECR1_CA = 75584,0,7,0 %;
literal KA0302$S_SLOT3_LBECR1_CA = 7;
macro KA0302$V_SLOT3_LBECR1_CID = 75584,7,4,0 %;
literal KA0302$S_SLOT3_LBECR1_CID = 4;
macro KA0302$V_SLOT3_LBECR1_RID = 75584,11,4,0 %;
literal KA0302$S_SLOT3_LBECR1_RID = 4;
macro KA0302$V_SLOT3_LBECR1_CNF = 75584,15,1,0 %;
macro KA0302$V_SLOT3_LBECR1_SHARED = 75584,16,1,0 %;
macro KA0302$V_SLOT3_LBECR1_DIRTY = 75584,17,1,0 %;
macro KA0302$V_SLOT3_LBECR1_DCYCLE = 75584,18,2,0 %;
literal KA0302$S_SLOT3_LBECR1_DCYCLE = 2;
macro KA0302$b_fill1420 = 75588,0,0,0 %;
literal KA0302$s_fill1420 = 1212;
macro KA0302$L_SLOT3_LMODE = 76800,0,32,0 %;
macro KA0302$b_fill1430 = 76804,0,0,0 %;
literal KA0302$s_fill1430 = 60;
macro KA0302$L_SLOT3_LMERR = 76864,0,32,0 %;
macro KA0302$b_fill1440 = 76868,0,0,0 %;
literal KA0302$s_fill1440 = 60;
macro KA0302$L_SLOT3_LLOCK = 76928,0,32,0 %;
macro KA0302$b_fill1450 = 76932,0,0,0 %;
literal KA0302$s_fill1450 = 60;
macro KA0302$L_SLOT3_LEDTO = 76992,0,32,0 %;
macro KA0302$b_fill1460 = 76996,0,0,0 %;
literal KA0302$s_fill1460 = 60;
macro KA0302$L_SLOT3_LDIAG = 77056,0,32,0 %;
macro KA0302$b_fill1470 = 77060,0,0,0 %;
literal KA0302$s_fill1470 = 60;
macro KA0302$L_SLOT3_LTAGA = 77120,0,32,0 %;
macro KA0302$b_fill1480 = 77124,0,0,0 %;
literal KA0302$s_fill1480 = 60;
macro KA0302$L_SLOT3_LTAGW = 77184,0,32,0 %;
macro KA0302$b_fill1490 = 77188,0,0,0 %;
literal KA0302$s_fill1490 = 124;
macro KA0302$L_SLOT3_LCON0 = 77312,0,32,0 %;
macro KA0302$b_fill1500 = 77316,0,0,0 %;
literal KA0302$s_fill1500 = 60;
macro KA0302$L_SLOT3_LCON1 = 77376,0,32,0 %;
macro KA0302$b_fill1510 = 77380,0,0,0 %;
literal KA0302$s_fill1510 = 188;
macro KA0302$L_SLOT3_LPERF = 77568,0,32,0 %;
macro KA0302$b_fill1520 = 77572,0,0,0 %;
literal KA0302$s_fill1520 = 60;
macro KA0302$L_SLOT3_LCNTR0 = 77632,0,32,0 %;
macro KA0302$b_fill1530 = 77636,0,0,0 %;
literal KA0302$s_fill1530 = 60;
macro KA0302$L_SLOT3_LCNTR1 = 77696,0,32,0 %;
macro KA0302$b_fill1540 = 77700,0,0,0 %;
literal KA0302$s_fill1540 = 60;
macro KA0302$L_SLOT3_LMISSADDR = 77760,0,32,0 %;
macro KA0302$b_fill1545 = 77764,0,0,0 %;
literal KA0302$s_fill1545 = 4156;
macro KA0302$L_SLOT3_MCR = 81920,0,32,0 %;
macro KA0302$b_fill1550 = 81924,0,0,0 %;
literal KA0302$s_fill1550 = 60;
macro KA0302$L_SLOT3_AMR = 81984,0,32,0 %;
macro KA0302$b_fill1560 = 81988,0,0,0 %;
literal KA0302$s_fill1560 = 60;
macro KA0302$L_SLOT3_MSTR0 = 82048,0,32,0 %;
macro KA0302$b_fill1570 = 82052,0,0,0 %;
literal KA0302$s_fill1570 = 60;
macro KA0302$L_SLOT3_MSTR1 = 82112,0,32,0 %;
macro KA0302$b_fill1580 = 82116,0,0,0 %;
literal KA0302$s_fill1580 = 60;
macro KA0302$L_SLOT3_FADR = 82176,0,32,0 %;
macro KA0302$b_fill1590 = 82180,0,0,0 %;
literal KA0302$s_fill1590 = 60;
macro KA0302$L_SLOT3_MERA = 82240,0,32,0 %;
macro KA0302$b_fill1600 = 82244,0,0,0 %;
literal KA0302$s_fill1600 = 60;
macro KA0302$L_SLOT3_MSYNDA = 82304,0,32,0 %;
macro KA0302$b_fill1610 = 82308,0,0,0 %;
literal KA0302$s_fill1610 = 60;
macro KA0302$L_SLOT3_MDRA = 82368,0,32,0 %;
macro KA0302$b_fill1620 = 82372,0,0,0 %;
literal KA0302$s_fill1620 = 60;
macro KA0302$L_SLOT3_MCBSA = 82432,0,32,0 %;
macro KA0302$b_fill1630 = 82436,0,0,0 %;
literal KA0302$s_fill1630 = 7996;
macro KA0302$L_SLOT3_MERB = 90432,0,32,0 %;
macro KA0302$b_fill1640 = 90436,0,0,0 %;
literal KA0302$s_fill1640 = 60;
macro KA0302$L_SLOT3_MSYNDB = 90496,0,32,0 %;
macro KA0302$b_fill1650 = 90500,0,0,0 %;
literal KA0302$s_fill1650 = 60;
macro KA0302$L_SLOT3_MDRB = 90560,0,32,0 %;
macro KA0302$b_fill1660 = 90564,0,0,0 %;
literal KA0302$s_fill1660 = 60;
macro KA0302$L_SLOT3_MCBSB = 90624,0,32,0 %;
macro KA0302$b_fill1670 = 90628,0,0,0 %;
literal KA0302$s_fill1670 = 7676;
macro KA0302$L_SLOT4_LDEV = 98304,0,32,0 %;
macro KA0302$V_SLOT4_LDEV_DTYPE = 98304,0,16,0 %;
literal KA0302$S_SLOT4_LDEV_DTYPE = 16;
macro KA0302$V_SLOT4_LDEV_DREV = 98304,16,16,0 %;
literal KA0302$S_SLOT4_LDEV_DREV = 16;
macro KA0302$b_fill1680 = 98308,0,0,0 %;
literal KA0302$s_fill1680 = 60;
macro KA0302$L_SLOT4_LBER = 98368,0,32,0 %;
macro KA0302$V_SLOT4_LBER_E = 98368,0,1,0 %;
macro KA0302$V_SLOT4_LBER_UCE = 98368,1,1,0 %;
macro KA0302$V_SLOT4_LBER_UCE2 = 98368,2,1,0 %;
macro KA0302$V_SLOT4_LBER_CE = 98368,3,1,0 %;
macro KA0302$V_SLOT4_LBER_CE2 = 98368,4,1,0 %;
macro KA0302$V_SLOT4_LBER_CPE = 98368,5,1,0 %;
macro KA0302$V_SLOT4_LBER_CPE2 = 98368,6,1,0 %;
macro KA0302$V_SLOT4_LBER_CDPE = 98368,7,1,0 %;
macro KA0302$V_SLOT4_LBER_CDPE2 = 98368,8,1,0 %;
macro KA0302$V_SLOT4_LBER_TDE = 98368,9,1,0 %;
macro KA0302$V_SLOT4_LBER_STE = 98368,10,1,0 %;
macro KA0302$V_SLOT4_LBER_CNFE = 98368,11,1,0 %;
macro KA0302$V_SLOT4_LBER_NXAE = 98368,12,1,0 %;
macro KA0302$V_SLOT4_LBER_CAE = 98368,13,1,0 %;
macro KA0302$V_SLOT4_LBER_SHE = 98368,14,1,0 %;
macro KA0302$V_SLOT4_LBER_DIE = 98368,15,1,0 %;
macro KA0302$V_SLOT4_LBER_DTCE = 98368,16,1,0 %;
macro KA0302$V_SLOT4_LBER_CTCE = 98368,17,1,0 %;
macro KA0302$V_SLOT4_LBER_NSES = 98368,18,1,0 %;
macro KA0302$b_fill1690 = 98372,0,0,0 %;
literal KA0302$s_fill1690 = 60;
macro KA0302$L_SLOT4_LCNR = 98432,0,32,0 %;
macro KA0302$V_SLOT4_LCNR_CEEN = 98432,0,1,0 %;
macro KA0302$V_SLOT4_LCNR_RSTSTAT = 98432,28,1,0 %;
macro KA0302$V_SLOT4_LCNR_NHALT = 98432,29,1,0 %;
macro KA0302$V_SLOT4_LCNR_NRST = 98432,30,1,0 %;
macro KA0302$V_SLOT4_LCNR_STF = 98432,31,1,0 %;
macro KA0302$b_fill1695 = 98436,0,0,0 %;
literal KA0302$s_fill1695 = 60;
macro KA0302$L_SLOT4_IBR = 98496,0,32,0 %;
macro KA0302$V_SLOT4_IBR_RCV_SDAT = 98496,0,1,0 %;
macro KA0302$V_SLOT4_IBR_XMT_SDAT = 98496,1,1,0 %;
macro KA0302$V_SLOT4_IBR_SCLK = 98496,2,1,0 %;
macro KA0302$b_fill1700 = 98500,0,0,0 %;
literal KA0302$s_fill1700 = 316;
macro KA0302$L_SLOT4_LMMR0 = 98816,0,32,0 %;
macro KA0302$V_SLOT4_LMMR0_EN = 98816,0,1,0 %;
macro KA0302$V_SLOT4_LMMR0_INT = 98816,1,2,0 %;
literal KA0302$S_SLOT4_LMMR0_INT = 2;
macro KA0302$V_SLOT4_LMMR0_IA = 98816,3,2,0 %;
literal KA0302$S_SLOT4_LMMR0_IA = 2;
macro KA0302$V_SLOT4_LMMR0_AW = 98816,5,4,0 %;
literal KA0302$S_SLOT4_LMMR0_AW = 4;
macro KA0302$V_SLOT4_LMMR0_NBANKS = 98816,9,2,0 %;
literal KA0302$S_SLOT4_LMMR0_NBANKS = 2;
macro KA0302$V_SLOT4_LMMR0_ADDR = 98816,17,15,0 %;
literal KA0302$S_SLOT4_LMMR0_ADDR = 15;
macro KA0302$b_fill1710 = 98820,0,0,0 %;
literal KA0302$s_fill1710 = 60;
macro KA0302$L_SLOT4_LMMR1 = 98880,0,32,0 %;
macro KA0302$V_SLOT4_LMMR1_EN = 98880,0,1,0 %;
macro KA0302$V_SLOT4_LMMR1_INT = 98880,1,2,0 %;
literal KA0302$S_SLOT4_LMMR1_INT = 2;
macro KA0302$V_SLOT4_LMMR1_IA = 98880,3,2,0 %;
literal KA0302$S_SLOT4_LMMR1_IA = 2;
macro KA0302$V_SLOT4_LMMR1_AW = 98880,5,4,0 %;
literal KA0302$S_SLOT4_LMMR1_AW = 4;
macro KA0302$V_SLOT4_LMMR1_NBANKS = 98880,9,2,0 %;
literal KA0302$S_SLOT4_LMMR1_NBANKS = 2;
macro KA0302$V_SLOT4_LMMR1_ADDR = 98880,17,15,0 %;
literal KA0302$S_SLOT4_LMMR1_ADDR = 15;
macro KA0302$b_fill1720 = 98884,0,0,0 %;
literal KA0302$s_fill1720 = 60;
macro KA0302$L_SLOT4_LMMR2 = 98944,0,32,0 %;
macro KA0302$V_SLOT4_LMMR2_EN = 98944,0,1,0 %;
macro KA0302$V_SLOT4_LMMR2_INT = 98944,1,2,0 %;
literal KA0302$S_SLOT4_LMMR2_INT = 2;
macro KA0302$V_SLOT4_LMMR2_IA = 98944,3,2,0 %;
literal KA0302$S_SLOT4_LMMR2_IA = 2;
macro KA0302$V_SLOT4_LMMR2_AW = 98944,5,4,0 %;
literal KA0302$S_SLOT4_LMMR2_AW = 4;
macro KA0302$V_SLOT4_LMMR2_NBANKS = 98944,9,2,0 %;
literal KA0302$S_SLOT4_LMMR2_NBANKS = 2;
macro KA0302$V_SLOT4_LMMR2_ADDR = 98944,17,15,0 %;
literal KA0302$S_SLOT4_LMMR2_ADDR = 15;
macro KA0302$b_fill1730 = 98948,0,0,0 %;
literal KA0302$s_fill1730 = 60;
macro KA0302$L_SLOT4_LMMR3 = 99008,0,32,0 %;
macro KA0302$V_SLOT4_LMMR3_EN = 99008,0,1,0 %;
macro KA0302$V_SLOT4_LMMR3_INT = 99008,1,2,0 %;
literal KA0302$S_SLOT4_LMMR3_INT = 2;
macro KA0302$V_SLOT4_LMMR3_IA = 99008,3,2,0 %;
literal KA0302$S_SLOT4_LMMR3_IA = 2;
macro KA0302$V_SLOT4_LMMR3_AW = 99008,5,4,0 %;
literal KA0302$S_SLOT4_LMMR3_AW = 4;
macro KA0302$V_SLOT4_LMMR3_NBANKS = 99008,9,2,0 %;
literal KA0302$S_SLOT4_LMMR3_NBANKS = 2;
macro KA0302$V_SLOT4_LMMR3_ADDR = 99008,17,15,0 %;
literal KA0302$S_SLOT4_LMMR3_ADDR = 15;
macro KA0302$b_fill1740 = 99012,0,0,0 %;
literal KA0302$s_fill1740 = 60;
macro KA0302$L_SLOT4_LMMR4 = 99072,0,32,0 %;
macro KA0302$V_SLOT4_LMMR4_EN = 99072,0,1,0 %;
macro KA0302$V_SLOT4_LMMR4_INT = 99072,1,2,0 %;
literal KA0302$S_SLOT4_LMMR4_INT = 2;
macro KA0302$V_SLOT4_LMMR4_IA = 99072,3,2,0 %;
literal KA0302$S_SLOT4_LMMR4_IA = 2;
macro KA0302$V_SLOT4_LMMR4_AW = 99072,5,4,0 %;
literal KA0302$S_SLOT4_LMMR4_AW = 4;
macro KA0302$V_SLOT4_LMMR4_NBANKS = 99072,9,2,0 %;
literal KA0302$S_SLOT4_LMMR4_NBANKS = 2;
macro KA0302$V_SLOT4_LMMR4_ADDR = 99072,17,15,0 %;
literal KA0302$S_SLOT4_LMMR4_ADDR = 15;
macro KA0302$b_fill1750 = 99076,0,0,0 %;
literal KA0302$s_fill1750 = 60;
macro KA0302$L_SLOT4_LMMR5 = 99136,0,32,0 %;
macro KA0302$V_SLOT4_LMMR5_EN = 99136,0,1,0 %;
macro KA0302$V_SLOT4_LMMR5_INT = 99136,1,2,0 %;
literal KA0302$S_SLOT4_LMMR5_INT = 2;
macro KA0302$V_SLOT4_LMMR5_IA = 99136,3,2,0 %;
literal KA0302$S_SLOT4_LMMR5_IA = 2;
macro KA0302$V_SLOT4_LMMR5_AW = 99136,5,4,0 %;
literal KA0302$S_SLOT4_LMMR5_AW = 4;
macro KA0302$V_SLOT4_LMMR5_NBANKS = 99136,9,2,0 %;
literal KA0302$S_SLOT4_LMMR5_NBANKS = 2;
macro KA0302$V_SLOT4_LMMR5_ADDR = 99136,17,15,0 %;
literal KA0302$S_SLOT4_LMMR5_ADDR = 15;
macro KA0302$b_fill1760 = 99140,0,0,0 %;
literal KA0302$s_fill1760 = 60;
macro KA0302$L_SLOT4_LMMR6 = 99200,0,32,0 %;
macro KA0302$V_SLOT4_LMMR6_EN = 99200,0,1,0 %;
macro KA0302$V_SLOT4_LMMR6_INT = 99200,1,2,0 %;
literal KA0302$S_SLOT4_LMMR6_INT = 2;
macro KA0302$V_SLOT4_LMMR6_IA = 99200,3,2,0 %;
literal KA0302$S_SLOT4_LMMR6_IA = 2;
macro KA0302$V_SLOT4_LMMR6_AW = 99200,5,4,0 %;
literal KA0302$S_SLOT4_LMMR6_AW = 4;
macro KA0302$V_SLOT4_LMMR6_NBANKS = 99200,9,2,0 %;
literal KA0302$S_SLOT4_LMMR6_NBANKS = 2;
macro KA0302$V_SLOT4_LMMR6_ADDR = 99200,17,15,0 %;
literal KA0302$S_SLOT4_LMMR6_ADDR = 15;
macro KA0302$b_fill1770 = 99204,0,0,0 %;
literal KA0302$s_fill1770 = 60;
macro KA0302$L_SLOT4_LMMR7 = 99264,0,32,0 %;
macro KA0302$V_SLOT4_LMMR7_EN = 99264,0,1,0 %;
macro KA0302$V_SLOT4_LMMR7_INT = 99264,1,2,0 %;
literal KA0302$S_SLOT4_LMMR7_INT = 2;
macro KA0302$V_SLOT4_LMMR7_IA = 99264,3,2,0 %;
literal KA0302$S_SLOT4_LMMR7_IA = 2;
macro KA0302$V_SLOT4_LMMR7_AW = 99264,5,4,0 %;
literal KA0302$S_SLOT4_LMMR7_AW = 4;
macro KA0302$V_SLOT4_LMMR7_NBANKS = 99264,9,2,0 %;
literal KA0302$S_SLOT4_LMMR7_NBANKS = 2;
macro KA0302$V_SLOT4_LMMR7_ADDR = 99264,17,15,0 %;
literal KA0302$S_SLOT4_LMMR7_ADDR = 15;
macro KA0302$b_fill1780 = 99268,0,0,0 %;
literal KA0302$s_fill1780 = 572;
macro KA0302$L_SLOT4_LBESR0 = 99840,0,32,0 %;
macro KA0302$V_SLOT4_LBESR0_SYNDROME = 99840,0,7,0 %;
literal KA0302$S_SLOT4_LBESR0_SYNDROME = 7;
macro KA0302$b_fill1790 = 99844,0,0,0 %;
literal KA0302$s_fill1790 = 60;
macro KA0302$L_SLOT4_LBESR1 = 99904,0,32,0 %;
macro KA0302$V_SLOT4_LBESR1_SYNDROME = 99904,0,7,0 %;
literal KA0302$S_SLOT4_LBESR1_SYNDROME = 7;
macro KA0302$b_fill1800 = 99908,0,0,0 %;
literal KA0302$s_fill1800 = 60;
macro KA0302$L_SLOT4_LBESR2 = 99968,0,32,0 %;
macro KA0302$V_SLOT4_LBESR2_SYNDROME = 99968,0,7,0 %;
literal KA0302$S_SLOT4_LBESR2_SYNDROME = 7;
macro KA0302$b_fill1810 = 99972,0,0,0 %;
literal KA0302$s_fill1810 = 60;
macro KA0302$L_SLOT4_LBESR3 = 100032,0,32,0 %;
macro KA0302$V_SLOT4_LBESR3_SYNDROME = 100032,0,7,0 %;
literal KA0302$S_SLOT4_LBESR3_SYNDROME = 7;
macro KA0302$b_fill1820 = 100036,0,0,0 %;
literal KA0302$s_fill1820 = 60;
macro KA0302$L_SLOT4_LBECR0 = 100096,0,32,0 %;
macro KA0302$L_SLOT4_LBECR0_CA = 100096,0,32,0 %;
macro KA0302$b_fill1830 = 100100,0,0,0 %;
literal KA0302$s_fill1830 = 60;
macro KA0302$L_SLOT4_LBECR1 = 100160,0,32,0 %;
macro KA0302$V_SLOT4_LBECR1_CA = 100160,0,7,0 %;
literal KA0302$S_SLOT4_LBECR1_CA = 7;
macro KA0302$V_SLOT4_LBECR1_CID = 100160,7,4,0 %;
literal KA0302$S_SLOT4_LBECR1_CID = 4;
macro KA0302$V_SLOT4_LBECR1_RID = 100160,11,4,0 %;
literal KA0302$S_SLOT4_LBECR1_RID = 4;
macro KA0302$V_SLOT4_LBECR1_CNF = 100160,15,1,0 %;
macro KA0302$V_SLOT4_LBECR1_SHARED = 100160,16,1,0 %;
macro KA0302$V_SLOT4_LBECR1_DIRTY = 100160,17,1,0 %;
macro KA0302$V_SLOT4_LBECR1_DCYCLE = 100160,18,2,0 %;
literal KA0302$S_SLOT4_LBECR1_DCYCLE = 2;
macro KA0302$b_fill1840 = 100164,0,0,0 %;
literal KA0302$s_fill1840 = 1212;
macro KA0302$L_SLOT4_LMODE = 101376,0,32,0 %;
macro KA0302$b_fill1850 = 101380,0,0,0 %;
literal KA0302$s_fill1850 = 60;
macro KA0302$L_SLOT4_LMERR = 101440,0,32,0 %;
macro KA0302$b_fill1860 = 101444,0,0,0 %;
literal KA0302$s_fill1860 = 60;
macro KA0302$L_SLOT4_LLOCK = 101504,0,32,0 %;
macro KA0302$b_fill1870 = 101508,0,0,0 %;
literal KA0302$s_fill1870 = 60;
macro KA0302$L_SLOT4_LEDTO = 101568,0,32,0 %;
macro KA0302$b_fill1880 = 101572,0,0,0 %;
literal KA0302$s_fill1880 = 60;
macro KA0302$L_SLOT4_LDIAG = 101632,0,32,0 %;
macro KA0302$b_fill1890 = 101636,0,0,0 %;
literal KA0302$s_fill1890 = 60;
macro KA0302$L_SLOT4_LTAGA = 101696,0,32,0 %;
macro KA0302$b_fill1900 = 101700,0,0,0 %;
literal KA0302$s_fill1900 = 60;
macro KA0302$L_SLOT4_LTAGW = 101760,0,32,0 %;
macro KA0302$b_fill1910 = 101764,0,0,0 %;
literal KA0302$s_fill1910 = 124;
macro KA0302$L_SLOT4_LCON0 = 101888,0,32,0 %;
macro KA0302$b_fill1920 = 101892,0,0,0 %;
literal KA0302$s_fill1920 = 60;
macro KA0302$L_SLOT4_LCON1 = 101952,0,32,0 %;
macro KA0302$b_fill1930 = 101956,0,0,0 %;
literal KA0302$s_fill1930 = 188;
macro KA0302$L_SLOT4_LPERF = 102144,0,32,0 %;
macro KA0302$b_fill1940 = 102148,0,0,0 %;
literal KA0302$s_fill1940 = 60;
macro KA0302$L_SLOT4_LCNTR0 = 102208,0,32,0 %;
macro KA0302$b_fill1950 = 102212,0,0,0 %;
literal KA0302$s_fill1950 = 60;
macro KA0302$L_SLOT4_LCNTR1 = 102272,0,32,0 %;
macro KA0302$b_fill1960 = 102276,0,0,0 %;
literal KA0302$s_fill1960 = 60;
macro KA0302$L_SLOT4_LMISSADDR = 102336,0,32,0 %;
macro KA0302$b_fill1965 = 102340,0,0,0 %;
literal KA0302$s_fill1965 = 4156;
macro KA0302$L_SLOT4_MCR = 106496,0,32,0 %;
macro KA0302$b_fill1970 = 106500,0,0,0 %;
literal KA0302$s_fill1970 = 60;
macro KA0302$L_SLOT4_AMR = 106560,0,32,0 %;
macro KA0302$b_fill1980 = 106564,0,0,0 %;
literal KA0302$s_fill1980 = 60;
macro KA0302$L_SLOT4_MSTR0 = 106624,0,32,0 %;
macro KA0302$b_fill1990 = 106628,0,0,0 %;
literal KA0302$s_fill1990 = 60;
macro KA0302$L_SLOT4_MSTR1 = 106688,0,32,0 %;
macro KA0302$b_fill2000 = 106692,0,0,0 %;
literal KA0302$s_fill2000 = 60;
macro KA0302$L_SLOT4_FADR = 106752,0,32,0 %;
macro KA0302$b_fill2010 = 106756,0,0,0 %;
literal KA0302$s_fill2010 = 60;
macro KA0302$L_SLOT4_MERA = 106816,0,32,0 %;
macro KA0302$b_fill2020 = 106820,0,0,0 %;
literal KA0302$s_fill2020 = 60;
macro KA0302$L_SLOT4_MSYNDA = 106880,0,32,0 %;
macro KA0302$b_fill2030 = 106884,0,0,0 %;
literal KA0302$s_fill2030 = 60;
macro KA0302$L_SLOT4_MDRA = 106944,0,32,0 %;
macro KA0302$b_fill2040 = 106948,0,0,0 %;
literal KA0302$s_fill2040 = 60;
macro KA0302$L_SLOT4_MCBSA = 107008,0,32,0 %;
macro KA0302$b_fill2050 = 107012,0,0,0 %;
literal KA0302$s_fill2050 = 7996;
macro KA0302$L_SLOT4_MERB = 115008,0,32,0 %;
macro KA0302$b_fill2060 = 115012,0,0,0 %;
literal KA0302$s_fill2060 = 60;
macro KA0302$L_SLOT4_MSYNDB = 115072,0,32,0 %;
macro KA0302$b_fill2070 = 115076,0,0,0 %;
literal KA0302$s_fill2070 = 60;
macro KA0302$L_SLOT4_MDRB = 115136,0,32,0 %;
macro KA0302$b_fill2080 = 115140,0,0,0 %;
literal KA0302$s_fill2080 = 60;
macro KA0302$L_SLOT4_MCBSB = 115200,0,32,0 %;
macro KA0302$b_fill2090 = 115204,0,0,0 %;
literal KA0302$s_fill2090 = 7676;
macro KA0302$L_SLOT5_LDEV = 122880,0,32,0 %;
macro KA0302$V_SLOT5_LDEV_DTYPE = 122880,0,16,0 %;
literal KA0302$S_SLOT5_LDEV_DTYPE = 16;
macro KA0302$V_SLOT5_LDEV_DREV = 122880,16,16,0 %;
literal KA0302$S_SLOT5_LDEV_DREV = 16;
macro KA0302$b_fill2100 = 122884,0,0,0 %;
literal KA0302$s_fill2100 = 60;
macro KA0302$L_SLOT5_LBER = 122944,0,32,0 %;
macro KA0302$V_SLOT5_LBER_E = 122944,0,1,0 %;
macro KA0302$V_SLOT5_LBER_UCE = 122944,1,1,0 %;
macro KA0302$V_SLOT5_LBER_UCE2 = 122944,2,1,0 %;
macro KA0302$V_SLOT5_LBER_CE = 122944,3,1,0 %;
macro KA0302$V_SLOT5_LBER_CE2 = 122944,4,1,0 %;
macro KA0302$V_SLOT5_LBER_CPE = 122944,5,1,0 %;
macro KA0302$V_SLOT5_LBER_CPE2 = 122944,6,1,0 %;
macro KA0302$V_SLOT5_LBER_CDPE = 122944,7,1,0 %;
macro KA0302$V_SLOT5_LBER_CDPE2 = 122944,8,1,0 %;
macro KA0302$V_SLOT5_LBER_TDE = 122944,9,1,0 %;
macro KA0302$V_SLOT5_LBER_STE = 122944,10,1,0 %;
macro KA0302$V_SLOT5_LBER_CNFE = 122944,11,1,0 %;
macro KA0302$V_SLOT5_LBER_NXAE = 122944,12,1,0 %;
macro KA0302$V_SLOT5_LBER_CAE = 122944,13,1,0 %;
macro KA0302$V_SLOT5_LBER_SHE = 122944,14,1,0 %;
macro KA0302$V_SLOT5_LBER_DIE = 122944,15,1,0 %;
macro KA0302$V_SLOT5_LBER_DTCE = 122944,16,1,0 %;
macro KA0302$V_SLOT5_LBER_CTCE = 122944,17,1,0 %;
macro KA0302$V_SLOT5_LBER_NSES = 122944,18,1,0 %;
macro KA0302$b_fill2110 = 122948,0,0,0 %;
literal KA0302$s_fill2110 = 60;
macro KA0302$L_SLOT5_LCNR = 123008,0,32,0 %;
macro KA0302$V_SLOT5_LCNR_CEEN = 123008,0,1,0 %;
macro KA0302$V_SLOT5_LCNR_RSTSTAT = 123008,28,1,0 %;
macro KA0302$V_SLOT5_LCNR_NHALT = 123008,29,1,0 %;
macro KA0302$V_SLOT5_LCNR_NRST = 123008,30,1,0 %;
macro KA0302$V_SLOT5_LCNR_STF = 123008,31,1,0 %;
macro KA0302$b_fill2115 = 123012,0,0,0 %;
literal KA0302$s_fill2115 = 60;
macro KA0302$L_SLOT5_IBR = 123072,0,32,0 %;
macro KA0302$V_SLOT5_IBR_RCV_SDAT = 123072,0,1,0 %;
macro KA0302$V_SLOT5_IBR_XMT_SDAT = 123072,1,1,0 %;
macro KA0302$V_SLOT5_IBR_SCLK = 123072,2,1,0 %;
macro KA0302$b_fill2120 = 123076,0,0,0 %;
literal KA0302$s_fill2120 = 316;
macro KA0302$L_SLOT5_LMMR0 = 123392,0,32,0 %;
macro KA0302$V_SLOT5_LMMR0_EN = 123392,0,1,0 %;
macro KA0302$V_SLOT5_LMMR0_INT = 123392,1,2,0 %;
literal KA0302$S_SLOT5_LMMR0_INT = 2;
macro KA0302$V_SLOT5_LMMR0_IA = 123392,3,2,0 %;
literal KA0302$S_SLOT5_LMMR0_IA = 2;
macro KA0302$V_SLOT5_LMMR0_AW = 123392,5,4,0 %;
literal KA0302$S_SLOT5_LMMR0_AW = 4;
macro KA0302$V_SLOT5_LMMR0_NBANKS = 123392,9,2,0 %;
literal KA0302$S_SLOT5_LMMR0_NBANKS = 2;
macro KA0302$V_SLOT5_LMMR0_ADDR = 123392,17,15,0 %;
literal KA0302$S_SLOT5_LMMR0_ADDR = 15;
macro KA0302$b_fill2130 = 123396,0,0,0 %;
literal KA0302$s_fill2130 = 60;
macro KA0302$L_SLOT5_LMMR1 = 123456,0,32,0 %;
macro KA0302$V_SLOT5_LMMR1_EN = 123456,0,1,0 %;
macro KA0302$V_SLOT5_LMMR1_INT = 123456,1,2,0 %;
literal KA0302$S_SLOT5_LMMR1_INT = 2;
macro KA0302$V_SLOT5_LMMR1_IA = 123456,3,2,0 %;
literal KA0302$S_SLOT5_LMMR1_IA = 2;
macro KA0302$V_SLOT5_LMMR1_AW = 123456,5,4,0 %;
literal KA0302$S_SLOT5_LMMR1_AW = 4;
macro KA0302$V_SLOT5_LMMR1_NBANKS = 123456,9,2,0 %;
literal KA0302$S_SLOT5_LMMR1_NBANKS = 2;
macro KA0302$V_SLOT5_LMMR1_ADDR = 123456,17,15,0 %;
literal KA0302$S_SLOT5_LMMR1_ADDR = 15;
macro KA0302$b_fill2140 = 123460,0,0,0 %;
literal KA0302$s_fill2140 = 60;
macro KA0302$L_SLOT5_LMMR2 = 123520,0,32,0 %;
macro KA0302$V_SLOT5_LMMR2_EN = 123520,0,1,0 %;
macro KA0302$V_SLOT5_LMMR2_INT = 123520,1,2,0 %;
literal KA0302$S_SLOT5_LMMR2_INT = 2;
macro KA0302$V_SLOT5_LMMR2_IA = 123520,3,2,0 %;
literal KA0302$S_SLOT5_LMMR2_IA = 2;
macro KA0302$V_SLOT5_LMMR2_AW = 123520,5,4,0 %;
literal KA0302$S_SLOT5_LMMR2_AW = 4;
macro KA0302$V_SLOT5_LMMR2_NBANKS = 123520,9,2,0 %;
literal KA0302$S_SLOT5_LMMR2_NBANKS = 2;
macro KA0302$V_SLOT5_LMMR2_ADDR = 123520,17,15,0 %;
literal KA0302$S_SLOT5_LMMR2_ADDR = 15;
macro KA0302$b_fill2150 = 123524,0,0,0 %;
literal KA0302$s_fill2150 = 60;
macro KA0302$L_SLOT5_LMMR3 = 123584,0,32,0 %;
macro KA0302$V_SLOT5_LMMR3_EN = 123584,0,1,0 %;
macro KA0302$V_SLOT5_LMMR3_INT = 123584,1,2,0 %;
literal KA0302$S_SLOT5_LMMR3_INT = 2;
macro KA0302$V_SLOT5_LMMR3_IA = 123584,3,2,0 %;
literal KA0302$S_SLOT5_LMMR3_IA = 2;
macro KA0302$V_SLOT5_LMMR3_AW = 123584,5,4,0 %;
literal KA0302$S_SLOT5_LMMR3_AW = 4;
macro KA0302$V_SLOT5_LMMR3_NBANKS = 123584,9,2,0 %;
literal KA0302$S_SLOT5_LMMR3_NBANKS = 2;
macro KA0302$V_SLOT5_LMMR3_ADDR = 123584,17,15,0 %;
literal KA0302$S_SLOT5_LMMR3_ADDR = 15;
macro KA0302$b_fill2160 = 123588,0,0,0 %;
literal KA0302$s_fill2160 = 60;
macro KA0302$L_SLOT5_LMMR4 = 123648,0,32,0 %;
macro KA0302$V_SLOT5_LMMR4_EN = 123648,0,1,0 %;
macro KA0302$V_SLOT5_LMMR4_INT = 123648,1,2,0 %;
literal KA0302$S_SLOT5_LMMR4_INT = 2;
macro KA0302$V_SLOT5_LMMR4_IA = 123648,3,2,0 %;
literal KA0302$S_SLOT5_LMMR4_IA = 2;
macro KA0302$V_SLOT5_LMMR4_AW = 123648,5,4,0 %;
literal KA0302$S_SLOT5_LMMR4_AW = 4;
macro KA0302$V_SLOT5_LMMR4_NBANKS = 123648,9,2,0 %;
literal KA0302$S_SLOT5_LMMR4_NBANKS = 2;
macro KA0302$V_SLOT5_LMMR4_ADDR = 123648,17,15,0 %;
literal KA0302$S_SLOT5_LMMR4_ADDR = 15;
macro KA0302$b_fill2170 = 123652,0,0,0 %;
literal KA0302$s_fill2170 = 60;
macro KA0302$L_SLOT5_LMMR5 = 123712,0,32,0 %;
macro KA0302$V_SLOT5_LMMR5_EN = 123712,0,1,0 %;
macro KA0302$V_SLOT5_LMMR5_INT = 123712,1,2,0 %;
literal KA0302$S_SLOT5_LMMR5_INT = 2;
macro KA0302$V_SLOT5_LMMR5_IA = 123712,3,2,0 %;
literal KA0302$S_SLOT5_LMMR5_IA = 2;
macro KA0302$V_SLOT5_LMMR5_AW = 123712,5,4,0 %;
literal KA0302$S_SLOT5_LMMR5_AW = 4;
macro KA0302$V_SLOT5_LMMR5_NBANKS = 123712,9,2,0 %;
literal KA0302$S_SLOT5_LMMR5_NBANKS = 2;
macro KA0302$V_SLOT5_LMMR5_ADDR = 123712,17,15,0 %;
literal KA0302$S_SLOT5_LMMR5_ADDR = 15;
macro KA0302$b_fill2180 = 123716,0,0,0 %;
literal KA0302$s_fill2180 = 60;
macro KA0302$L_SLOT5_LMMR6 = 123776,0,32,0 %;
macro KA0302$V_SLOT5_LMMR6_EN = 123776,0,1,0 %;
macro KA0302$V_SLOT5_LMMR6_INT = 123776,1,2,0 %;
literal KA0302$S_SLOT5_LMMR6_INT = 2;
macro KA0302$V_SLOT5_LMMR6_IA = 123776,3,2,0 %;
literal KA0302$S_SLOT5_LMMR6_IA = 2;
macro KA0302$V_SLOT5_LMMR6_AW = 123776,5,4,0 %;
literal KA0302$S_SLOT5_LMMR6_AW = 4;
macro KA0302$V_SLOT5_LMMR6_NBANKS = 123776,9,2,0 %;
literal KA0302$S_SLOT5_LMMR6_NBANKS = 2;
macro KA0302$V_SLOT5_LMMR6_ADDR = 123776,17,15,0 %;
literal KA0302$S_SLOT5_LMMR6_ADDR = 15;
macro KA0302$b_fill2190 = 123780,0,0,0 %;
literal KA0302$s_fill2190 = 60;
macro KA0302$L_SLOT5_LMMR7 = 123840,0,32,0 %;
macro KA0302$V_SLOT5_LMMR7_EN = 123840,0,1,0 %;
macro KA0302$V_SLOT5_LMMR7_INT = 123840,1,2,0 %;
literal KA0302$S_SLOT5_LMMR7_INT = 2;
macro KA0302$V_SLOT5_LMMR7_IA = 123840,3,2,0 %;
literal KA0302$S_SLOT5_LMMR7_IA = 2;
macro KA0302$V_SLOT5_LMMR7_AW = 123840,5,4,0 %;
literal KA0302$S_SLOT5_LMMR7_AW = 4;
macro KA0302$V_SLOT5_LMMR7_NBANKS = 123840,9,2,0 %;
literal KA0302$S_SLOT5_LMMR7_NBANKS = 2;
macro KA0302$V_SLOT5_LMMR7_ADDR = 123840,17,15,0 %;
literal KA0302$S_SLOT5_LMMR7_ADDR = 15;
macro KA0302$b_fill2200 = 123844,0,0,0 %;
literal KA0302$s_fill2200 = 572;
macro KA0302$L_SLOT5_LBESR0 = 124416,0,32,0 %;
macro KA0302$V_SLOT5_LBESR0_SYNDROME = 124416,0,7,0 %;
literal KA0302$S_SLOT5_LBESR0_SYNDROME = 7;
macro KA0302$b_fill2210 = 124420,0,0,0 %;
literal KA0302$s_fill2210 = 60;
macro KA0302$L_SLOT5_LBESR1 = 124480,0,32,0 %;
macro KA0302$V_SLOT5_LBESR1_SYNDROME = 124480,0,7,0 %;
literal KA0302$S_SLOT5_LBESR1_SYNDROME = 7;
macro KA0302$b_fill2220 = 124484,0,0,0 %;
literal KA0302$s_fill2220 = 60;
macro KA0302$L_SLOT5_LBESR2 = 124544,0,32,0 %;
macro KA0302$V_SLOT5_LBESR2_SYNDROME = 124544,0,7,0 %;
literal KA0302$S_SLOT5_LBESR2_SYNDROME = 7;
macro KA0302$b_fill2230 = 124548,0,0,0 %;
literal KA0302$s_fill2230 = 60;
macro KA0302$L_SLOT5_LBESR3 = 124608,0,32,0 %;
macro KA0302$V_SLOT5_LBESR3_SYNDROME = 124608,0,7,0 %;
literal KA0302$S_SLOT5_LBESR3_SYNDROME = 7;
macro KA0302$b_fill2240 = 124612,0,0,0 %;
literal KA0302$s_fill2240 = 60;
macro KA0302$L_SLOT5_LBECR0 = 124672,0,32,0 %;
macro KA0302$L_SLOT5_LBECR0_CA = 124672,0,32,0 %;
macro KA0302$b_fill2250 = 124676,0,0,0 %;
literal KA0302$s_fill2250 = 60;
macro KA0302$L_SLOT5_LBECR1 = 124736,0,32,0 %;
macro KA0302$V_SLOT5_LBECR1_CA = 124736,0,7,0 %;
literal KA0302$S_SLOT5_LBECR1_CA = 7;
macro KA0302$V_SLOT5_LBECR1_CID = 124736,7,4,0 %;
literal KA0302$S_SLOT5_LBECR1_CID = 4;
macro KA0302$V_SLOT5_LBECR1_RID = 124736,11,4,0 %;
literal KA0302$S_SLOT5_LBECR1_RID = 4;
macro KA0302$V_SLOT5_LBECR1_CNF = 124736,15,1,0 %;
macro KA0302$V_SLOT5_LBECR1_SHARED = 124736,16,1,0 %;
macro KA0302$V_SLOT5_LBECR1_DIRTY = 124736,17,1,0 %;
macro KA0302$V_SLOT5_LBECR1_DCYCLE = 124736,18,2,0 %;
literal KA0302$S_SLOT5_LBECR1_DCYCLE = 2;
macro KA0302$b_fill2260 = 124740,0,0,0 %;
literal KA0302$s_fill2260 = 1212;
macro KA0302$L_SLOT5_LMODE = 125952,0,32,0 %;
macro KA0302$b_fill2270 = 125956,0,0,0 %;
literal KA0302$s_fill2270 = 60;
macro KA0302$L_SLOT5_LMERR = 126016,0,32,0 %;
macro KA0302$b_fill2280 = 126020,0,0,0 %;
literal KA0302$s_fill2280 = 60;
macro KA0302$L_SLOT5_LLOCK = 126080,0,32,0 %;
macro KA0302$b_fill2290 = 126084,0,0,0 %;
literal KA0302$s_fill2290 = 60;
macro KA0302$L_SLOT5_LEDTO = 126144,0,32,0 %;
macro KA0302$b_fill2300 = 126148,0,0,0 %;
literal KA0302$s_fill2300 = 60;
macro KA0302$L_SLOT5_LDIAG = 126208,0,32,0 %;
macro KA0302$b_fill2310 = 126212,0,0,0 %;
literal KA0302$s_fill2310 = 60;
macro KA0302$L_SLOT5_LTAGA = 126272,0,32,0 %;
macro KA0302$b_fill2320 = 126276,0,0,0 %;
literal KA0302$s_fill2320 = 60;
macro KA0302$L_SLOT5_LTAGW = 126336,0,32,0 %;
macro KA0302$b_fill2330 = 126340,0,0,0 %;
literal KA0302$s_fill2330 = 124;
macro KA0302$L_SLOT5_LCON0 = 126464,0,32,0 %;
macro KA0302$b_fill2340 = 126468,0,0,0 %;
literal KA0302$s_fill2340 = 60;
macro KA0302$L_SLOT5_LCON1 = 126528,0,32,0 %;
macro KA0302$b_fill2350 = 126532,0,0,0 %;
literal KA0302$s_fill2350 = 188;
macro KA0302$L_SLOT5_LPERF = 126720,0,32,0 %;
macro KA0302$b_fill2360 = 126724,0,0,0 %;
literal KA0302$s_fill2360 = 60;
macro KA0302$L_SLOT5_LCNTR0 = 126784,0,32,0 %;
macro KA0302$b_fill2370 = 126788,0,0,0 %;
literal KA0302$s_fill2370 = 60;
macro KA0302$L_SLOT5_LCNTR1 = 126848,0,32,0 %;
macro KA0302$b_fill2380 = 126852,0,0,0 %;
literal KA0302$s_fill2380 = 60;
macro KA0302$L_SLOT5_LMISSADDR = 126912,0,32,0 %;
macro KA0302$b_fill2385 = 126916,0,0,0 %;
literal KA0302$s_fill2385 = 4156;
macro KA0302$L_SLOT5_MCR = 131072,0,32,0 %;
macro KA0302$b_fill2390 = 131076,0,0,0 %;
literal KA0302$s_fill2390 = 60;
macro KA0302$L_SLOT5_AMR = 131136,0,32,0 %;
macro KA0302$b_fill2400 = 131140,0,0,0 %;
literal KA0302$s_fill2400 = 60;
macro KA0302$L_SLOT5_MSTR0 = 131200,0,32,0 %;
macro KA0302$b_fill2410 = 131204,0,0,0 %;
literal KA0302$s_fill2410 = 60;
macro KA0302$L_SLOT5_MSTR1 = 131264,0,32,0 %;
macro KA0302$b_fill2420 = 131268,0,0,0 %;
literal KA0302$s_fill2420 = 60;
macro KA0302$L_SLOT5_FADR = 131328,0,32,0 %;
macro KA0302$b_fill2430 = 131332,0,0,0 %;
literal KA0302$s_fill2430 = 60;
macro KA0302$L_SLOT5_MERA = 131392,0,32,0 %;
macro KA0302$b_fill2440 = 131396,0,0,0 %;
literal KA0302$s_fill2440 = 60;
macro KA0302$L_SLOT5_MSYNDA = 131456,0,32,0 %;
macro KA0302$b_fill2450 = 131460,0,0,0 %;
literal KA0302$s_fill2450 = 60;
macro KA0302$L_SLOT5_MDRA = 131520,0,32,0 %;
macro KA0302$b_fill2460 = 131524,0,0,0 %;
literal KA0302$s_fill2460 = 60;
macro KA0302$L_SLOT5_MCBSA = 131584,0,32,0 %;
macro KA0302$b_fill2470 = 131588,0,0,0 %;
literal KA0302$s_fill2470 = 7996;
macro KA0302$L_SLOT5_MERB = 139584,0,32,0 %;
macro KA0302$b_fill2480 = 139588,0,0,0 %;
literal KA0302$s_fill2480 = 60;
macro KA0302$L_SLOT5_MSYNDB = 139648,0,32,0 %;
macro KA0302$b_fill2490 = 139652,0,0,0 %;
literal KA0302$s_fill2490 = 60;
macro KA0302$L_SLOT5_MDRB = 139712,0,32,0 %;
macro KA0302$b_fill2500 = 139716,0,0,0 %;
literal KA0302$s_fill2500 = 60;
macro KA0302$L_SLOT5_MCBSB = 139776,0,32,0 %;
macro KA0302$b_fill2510 = 139780,0,0,0 %;
literal KA0302$s_fill2510 = 7676;
macro KA0302$L_SLOT6_LDEV = 147456,0,32,0 %;
macro KA0302$V_SLOT6_LDEV_DTYPE = 147456,0,16,0 %;
literal KA0302$S_SLOT6_LDEV_DTYPE = 16;
macro KA0302$V_SLOT6_LDEV_DREV = 147456,16,16,0 %;
literal KA0302$S_SLOT6_LDEV_DREV = 16;
macro KA0302$b_fill2520 = 147460,0,0,0 %;
literal KA0302$s_fill2520 = 60;
macro KA0302$L_SLOT6_LBER = 147520,0,32,0 %;
macro KA0302$V_SLOT6_LBER_E = 147520,0,1,0 %;
macro KA0302$V_SLOT6_LBER_UCE = 147520,1,1,0 %;
macro KA0302$V_SLOT6_LBER_UCE2 = 147520,2,1,0 %;
macro KA0302$V_SLOT6_LBER_CE = 147520,3,1,0 %;
macro KA0302$V_SLOT6_LBER_CE2 = 147520,4,1,0 %;
macro KA0302$V_SLOT6_LBER_CPE = 147520,5,1,0 %;
macro KA0302$V_SLOT6_LBER_CPE2 = 147520,6,1,0 %;
macro KA0302$V_SLOT6_LBER_CDPE = 147520,7,1,0 %;
macro KA0302$V_SLOT6_LBER_CDPE2 = 147520,8,1,0 %;
macro KA0302$V_SLOT6_LBER_TDE = 147520,9,1,0 %;
macro KA0302$V_SLOT6_LBER_STE = 147520,10,1,0 %;
macro KA0302$V_SLOT6_LBER_CNFE = 147520,11,1,0 %;
macro KA0302$V_SLOT6_LBER_NXAE = 147520,12,1,0 %;
macro KA0302$V_SLOT6_LBER_CAE = 147520,13,1,0 %;
macro KA0302$V_SLOT6_LBER_SHE = 147520,14,1,0 %;
macro KA0302$V_SLOT6_LBER_DIE = 147520,15,1,0 %;
macro KA0302$V_SLOT6_LBER_DTCE = 147520,16,1,0 %;
macro KA0302$V_SLOT6_LBER_CTCE = 147520,17,1,0 %;
macro KA0302$V_SLOT6_LBER_NSES = 147520,18,1,0 %;
macro KA0302$b_fill2530 = 147524,0,0,0 %;
literal KA0302$s_fill2530 = 60;
macro KA0302$L_SLOT6_LCNR = 147584,0,32,0 %;
macro KA0302$V_SLOT6_LCNR_CEEN = 147584,0,1,0 %;
macro KA0302$V_SLOT6_LCNR_RSTSTAT = 147584,28,1,0 %;
macro KA0302$V_SLOT6_LCNR_NHALT = 147584,29,1,0 %;
macro KA0302$V_SLOT6_LCNR_NRST = 147584,30,1,0 %;
macro KA0302$V_SLOT6_LCNR_STF = 147584,31,1,0 %;
macro KA0302$b_fill2535 = 147588,0,0,0 %;
literal KA0302$s_fill2535 = 60;
macro KA0302$L_SLOT6_IBR = 147648,0,32,0 %;
macro KA0302$V_SLOT6_IBR_RCV_SDAT = 147648,0,1,0 %;
macro KA0302$V_SLOT6_IBR_XMT_SDAT = 147648,1,1,0 %;
macro KA0302$V_SLOT6_IBR_SCLK = 147648,2,1,0 %;
macro KA0302$b_fill2540 = 147652,0,0,0 %;
literal KA0302$s_fill2540 = 316;
macro KA0302$L_SLOT6_LMMR0 = 147968,0,32,0 %;
macro KA0302$V_SLOT6_LMMR0_EN = 147968,0,1,0 %;
macro KA0302$V_SLOT6_LMMR0_INT = 147968,1,2,0 %;
literal KA0302$S_SLOT6_LMMR0_INT = 2;
macro KA0302$V_SLOT6_LMMR0_IA = 147968,3,2,0 %;
literal KA0302$S_SLOT6_LMMR0_IA = 2;
macro KA0302$V_SLOT6_LMMR0_AW = 147968,5,4,0 %;
literal KA0302$S_SLOT6_LMMR0_AW = 4;
macro KA0302$V_SLOT6_LMMR0_NBANKS = 147968,9,2,0 %;
literal KA0302$S_SLOT6_LMMR0_NBANKS = 2;
macro KA0302$V_SLOT6_LMMR0_ADDR = 147968,17,15,0 %;
literal KA0302$S_SLOT6_LMMR0_ADDR = 15;
macro KA0302$b_fill2550 = 147972,0,0,0 %;
literal KA0302$s_fill2550 = 60;
macro KA0302$L_SLOT6_LMMR1 = 148032,0,32,0 %;
macro KA0302$V_SLOT6_LMMR1_EN = 148032,0,1,0 %;
macro KA0302$V_SLOT6_LMMR1_INT = 148032,1,2,0 %;
literal KA0302$S_SLOT6_LMMR1_INT = 2;
macro KA0302$V_SLOT6_LMMR1_IA = 148032,3,2,0 %;
literal KA0302$S_SLOT6_LMMR1_IA = 2;
macro KA0302$V_SLOT6_LMMR1_AW = 148032,5,4,0 %;
literal KA0302$S_SLOT6_LMMR1_AW = 4;
macro KA0302$V_SLOT6_LMMR1_NBANKS = 148032,9,2,0 %;
literal KA0302$S_SLOT6_LMMR1_NBANKS = 2;
macro KA0302$V_SLOT6_LMMR1_ADDR = 148032,17,15,0 %;
literal KA0302$S_SLOT6_LMMR1_ADDR = 15;
macro KA0302$b_fill2560 = 148036,0,0,0 %;
literal KA0302$s_fill2560 = 60;
macro KA0302$L_SLOT6_LMMR2 = 148096,0,32,0 %;
macro KA0302$V_SLOT6_LMMR2_EN = 148096,0,1,0 %;
macro KA0302$V_SLOT6_LMMR2_INT = 148096,1,2,0 %;
literal KA0302$S_SLOT6_LMMR2_INT = 2;
macro KA0302$V_SLOT6_LMMR2_IA = 148096,3,2,0 %;
literal KA0302$S_SLOT6_LMMR2_IA = 2;
macro KA0302$V_SLOT6_LMMR2_AW = 148096,5,4,0 %;
literal KA0302$S_SLOT6_LMMR2_AW = 4;
macro KA0302$V_SLOT6_LMMR2_NBANKS = 148096,9,2,0 %;
literal KA0302$S_SLOT6_LMMR2_NBANKS = 2;
macro KA0302$V_SLOT6_LMMR2_ADDR = 148096,17,15,0 %;
literal KA0302$S_SLOT6_LMMR2_ADDR = 15;
macro KA0302$b_fill2570 = 148100,0,0,0 %;
literal KA0302$s_fill2570 = 60;
macro KA0302$L_SLOT6_LMMR3 = 148160,0,32,0 %;
macro KA0302$V_SLOT6_LMMR3_EN = 148160,0,1,0 %;
macro KA0302$V_SLOT6_LMMR3_INT = 148160,1,2,0 %;
literal KA0302$S_SLOT6_LMMR3_INT = 2;
macro KA0302$V_SLOT6_LMMR3_IA = 148160,3,2,0 %;
literal KA0302$S_SLOT6_LMMR3_IA = 2;
macro KA0302$V_SLOT6_LMMR3_AW = 148160,5,4,0 %;
literal KA0302$S_SLOT6_LMMR3_AW = 4;
macro KA0302$V_SLOT6_LMMR3_NBANKS = 148160,9,2,0 %;
literal KA0302$S_SLOT6_LMMR3_NBANKS = 2;
macro KA0302$V_SLOT6_LMMR3_ADDR = 148160,17,15,0 %;
literal KA0302$S_SLOT6_LMMR3_ADDR = 15;
macro KA0302$b_fill2580 = 148164,0,0,0 %;
literal KA0302$s_fill2580 = 60;
macro KA0302$L_SLOT6_LMMR4 = 148224,0,32,0 %;
macro KA0302$V_SLOT6_LMMR4_EN = 148224,0,1,0 %;
macro KA0302$V_SLOT6_LMMR4_INT = 148224,1,2,0 %;
literal KA0302$S_SLOT6_LMMR4_INT = 2;
macro KA0302$V_SLOT6_LMMR4_IA = 148224,3,2,0 %;
literal KA0302$S_SLOT6_LMMR4_IA = 2;
macro KA0302$V_SLOT6_LMMR4_AW = 148224,5,4,0 %;
literal KA0302$S_SLOT6_LMMR4_AW = 4;
macro KA0302$V_SLOT6_LMMR4_NBANKS = 148224,9,2,0 %;
literal KA0302$S_SLOT6_LMMR4_NBANKS = 2;
macro KA0302$V_SLOT6_LMMR4_ADDR = 148224,17,15,0 %;
literal KA0302$S_SLOT6_LMMR4_ADDR = 15;
macro KA0302$b_fill2590 = 148228,0,0,0 %;
literal KA0302$s_fill2590 = 60;
macro KA0302$L_SLOT6_LMMR5 = 148288,0,32,0 %;
macro KA0302$V_SLOT6_LMMR5_EN = 148288,0,1,0 %;
macro KA0302$V_SLOT6_LMMR5_INT = 148288,1,2,0 %;
literal KA0302$S_SLOT6_LMMR5_INT = 2;
macro KA0302$V_SLOT6_LMMR5_IA = 148288,3,2,0 %;
literal KA0302$S_SLOT6_LMMR5_IA = 2;
macro KA0302$V_SLOT6_LMMR5_AW = 148288,5,4,0 %;
literal KA0302$S_SLOT6_LMMR5_AW = 4;
macro KA0302$V_SLOT6_LMMR5_NBANKS = 148288,9,2,0 %;
literal KA0302$S_SLOT6_LMMR5_NBANKS = 2;
macro KA0302$V_SLOT6_LMMR5_ADDR = 148288,17,15,0 %;
literal KA0302$S_SLOT6_LMMR5_ADDR = 15;
macro KA0302$b_fill2600 = 148292,0,0,0 %;
literal KA0302$s_fill2600 = 60;
macro KA0302$L_SLOT6_LMMR6 = 148352,0,32,0 %;
macro KA0302$V_SLOT6_LMMR6_EN = 148352,0,1,0 %;
macro KA0302$V_SLOT6_LMMR6_INT = 148352,1,2,0 %;
literal KA0302$S_SLOT6_LMMR6_INT = 2;
macro KA0302$V_SLOT6_LMMR6_IA = 148352,3,2,0 %;
literal KA0302$S_SLOT6_LMMR6_IA = 2;
macro KA0302$V_SLOT6_LMMR6_AW = 148352,5,4,0 %;
literal KA0302$S_SLOT6_LMMR6_AW = 4;
macro KA0302$V_SLOT6_LMMR6_NBANKS = 148352,9,2,0 %;
literal KA0302$S_SLOT6_LMMR6_NBANKS = 2;
macro KA0302$V_SLOT6_LMMR6_ADDR = 148352,17,15,0 %;
literal KA0302$S_SLOT6_LMMR6_ADDR = 15;
macro KA0302$b_fill2610 = 148356,0,0,0 %;
literal KA0302$s_fill2610 = 60;
macro KA0302$L_SLOT6_LMMR7 = 148416,0,32,0 %;
macro KA0302$V_SLOT6_LMMR7_EN = 148416,0,1,0 %;
macro KA0302$V_SLOT6_LMMR7_INT = 148416,1,2,0 %;
literal KA0302$S_SLOT6_LMMR7_INT = 2;
macro KA0302$V_SLOT6_LMMR7_IA = 148416,3,2,0 %;
literal KA0302$S_SLOT6_LMMR7_IA = 2;
macro KA0302$V_SLOT6_LMMR7_AW = 148416,5,4,0 %;
literal KA0302$S_SLOT6_LMMR7_AW = 4;
macro KA0302$V_SLOT6_LMMR7_NBANKS = 148416,9,2,0 %;
literal KA0302$S_SLOT6_LMMR7_NBANKS = 2;
macro KA0302$V_SLOT6_LMMR7_ADDR = 148416,17,15,0 %;
literal KA0302$S_SLOT6_LMMR7_ADDR = 15;
macro KA0302$b_fill2620 = 148420,0,0,0 %;
literal KA0302$s_fill2620 = 572;
macro KA0302$L_SLOT6_LBESR0 = 148992,0,32,0 %;
macro KA0302$V_SLOT6_LBESR0_SYNDROME = 148992,0,7,0 %;
literal KA0302$S_SLOT6_LBESR0_SYNDROME = 7;
macro KA0302$b_fill2630 = 148996,0,0,0 %;
literal KA0302$s_fill2630 = 60;
macro KA0302$L_SLOT6_LBESR1 = 149056,0,32,0 %;
macro KA0302$V_SLOT6_LBESR1_SYNDROME = 149056,0,7,0 %;
literal KA0302$S_SLOT6_LBESR1_SYNDROME = 7;
macro KA0302$b_fill2640 = 149060,0,0,0 %;
literal KA0302$s_fill2640 = 60;
macro KA0302$L_SLOT6_LBESR2 = 149120,0,32,0 %;
macro KA0302$V_SLOT6_LBESR2_SYNDROME = 149120,0,7,0 %;
literal KA0302$S_SLOT6_LBESR2_SYNDROME = 7;
macro KA0302$b_fill2650 = 149124,0,0,0 %;
literal KA0302$s_fill2650 = 60;
macro KA0302$L_SLOT6_LBESR3 = 149184,0,32,0 %;
macro KA0302$V_SLOT6_LBESR3_SYNDROME = 149184,0,7,0 %;
literal KA0302$S_SLOT6_LBESR3_SYNDROME = 7;
macro KA0302$b_fill2660 = 149188,0,0,0 %;
literal KA0302$s_fill2660 = 60;
macro KA0302$L_SLOT6_LBECR0 = 149248,0,32,0 %;
macro KA0302$L_SLOT6_LBECR0_CA = 149248,0,32,0 %;
macro KA0302$b_fill2670 = 149252,0,0,0 %;
literal KA0302$s_fill2670 = 60;
macro KA0302$L_SLOT6_LBECR1 = 149312,0,32,0 %;
macro KA0302$V_SLOT6_LBECR1_CA = 149312,0,7,0 %;
literal KA0302$S_SLOT6_LBECR1_CA = 7;
macro KA0302$V_SLOT6_LBECR1_CID = 149312,7,4,0 %;
literal KA0302$S_SLOT6_LBECR1_CID = 4;
macro KA0302$V_SLOT6_LBECR1_RID = 149312,11,4,0 %;
literal KA0302$S_SLOT6_LBECR1_RID = 4;
macro KA0302$V_SLOT6_LBECR1_CNF = 149312,15,1,0 %;
macro KA0302$V_SLOT6_LBECR1_SHARED = 149312,16,1,0 %;
macro KA0302$V_SLOT6_LBECR1_DIRTY = 149312,17,1,0 %;
macro KA0302$V_SLOT6_LBECR1_DCYCLE = 149312,18,2,0 %;
literal KA0302$S_SLOT6_LBECR1_DCYCLE = 2;
macro KA0302$b_fill2680 = 149316,0,0,0 %;
literal KA0302$s_fill2680 = 1212;
macro KA0302$L_SLOT6_LMODE = 150528,0,32,0 %;
macro KA0302$b_fill2690 = 150532,0,0,0 %;
literal KA0302$s_fill2690 = 60;
macro KA0302$L_SLOT6_LMERR = 150592,0,32,0 %;
macro KA0302$b_fill2700 = 150596,0,0,0 %;
literal KA0302$s_fill2700 = 60;
macro KA0302$L_SLOT6_LLOCK = 150656,0,32,0 %;
macro KA0302$b_fill2710 = 150660,0,0,0 %;
literal KA0302$s_fill2710 = 60;
macro KA0302$L_SLOT6_LEDTO = 150720,0,32,0 %;
macro KA0302$b_fill2720 = 150724,0,0,0 %;
literal KA0302$s_fill2720 = 60;
macro KA0302$L_SLOT6_LDIAG = 150784,0,32,0 %;
macro KA0302$b_fill2730 = 150788,0,0,0 %;
literal KA0302$s_fill2730 = 60;
macro KA0302$L_SLOT6_LTAGA = 150848,0,32,0 %;
macro KA0302$b_fill2740 = 150852,0,0,0 %;
literal KA0302$s_fill2740 = 60;
macro KA0302$L_SLOT6_LTAGW = 150912,0,32,0 %;
macro KA0302$b_fill2750 = 150916,0,0,0 %;
literal KA0302$s_fill2750 = 124;
macro KA0302$L_SLOT6_LCON0 = 151040,0,32,0 %;
macro KA0302$b_fill2760 = 151044,0,0,0 %;
literal KA0302$s_fill2760 = 60;
macro KA0302$L_SLOT6_LCON1 = 151104,0,32,0 %;
macro KA0302$b_fill2770 = 151108,0,0,0 %;
literal KA0302$s_fill2770 = 188;
macro KA0302$L_SLOT6_LPERF = 151296,0,32,0 %;
macro KA0302$b_fill2780 = 151300,0,0,0 %;
literal KA0302$s_fill2780 = 60;
macro KA0302$L_SLOT6_LCNTR0 = 151360,0,32,0 %;
macro KA0302$b_fill2790 = 151364,0,0,0 %;
literal KA0302$s_fill2790 = 60;
macro KA0302$L_SLOT6_LCNTR1 = 151424,0,32,0 %;
macro KA0302$b_fill2800 = 151428,0,0,0 %;
literal KA0302$s_fill2800 = 60;
macro KA0302$L_SLOT6_LMISSADDR = 151488,0,32,0 %;
macro KA0302$b_fill2805 = 151492,0,0,0 %;
literal KA0302$s_fill2805 = 4156;
macro KA0302$L_SLOT6_MCR = 155648,0,32,0 %;
macro KA0302$b_fill2810 = 155652,0,0,0 %;
literal KA0302$s_fill2810 = 60;
macro KA0302$L_SLOT6_AMR = 155712,0,32,0 %;
macro KA0302$b_fill2820 = 155716,0,0,0 %;
literal KA0302$s_fill2820 = 60;
macro KA0302$L_SLOT6_MSTR0 = 155776,0,32,0 %;
macro KA0302$b_fill2830 = 155780,0,0,0 %;
literal KA0302$s_fill2830 = 60;
macro KA0302$L_SLOT6_MSTR1 = 155840,0,32,0 %;
macro KA0302$b_fill2840 = 155844,0,0,0 %;
literal KA0302$s_fill2840 = 60;
macro KA0302$L_SLOT6_FADR = 155904,0,32,0 %;
macro KA0302$b_fill2850 = 155908,0,0,0 %;
literal KA0302$s_fill2850 = 60;
macro KA0302$L_SLOT6_MERA = 155968,0,32,0 %;
macro KA0302$b_fill2860 = 155972,0,0,0 %;
literal KA0302$s_fill2860 = 60;
macro KA0302$L_SLOT6_MSYNDA = 156032,0,32,0 %;
macro KA0302$b_fill2870 = 156036,0,0,0 %;
literal KA0302$s_fill2870 = 60;
macro KA0302$L_SLOT6_MDRA = 156096,0,32,0 %;
macro KA0302$b_fill2880 = 156100,0,0,0 %;
literal KA0302$s_fill2880 = 60;
macro KA0302$L_SLOT6_MCBSA = 156160,0,32,0 %;
macro KA0302$b_fill2890 = 156164,0,0,0 %;
literal KA0302$s_fill2890 = 7996;
macro KA0302$L_SLOT6_MERB = 164160,0,32,0 %;
macro KA0302$b_fill2900 = 164164,0,0,0 %;
literal KA0302$s_fill2900 = 60;
macro KA0302$L_SLOT6_MSYNDB = 164224,0,32,0 %;
macro KA0302$b_fill2910 = 164228,0,0,0 %;
literal KA0302$s_fill2910 = 60;
macro KA0302$L_SLOT6_MDRB = 164288,0,32,0 %;
macro KA0302$b_fill2920 = 164292,0,0,0 %;
literal KA0302$s_fill2920 = 60;
macro KA0302$L_SLOT6_MCBSB = 164352,0,32,0 %;
macro KA0302$b_fill2930 = 164356,0,0,0 %;
literal KA0302$s_fill2930 = 7676;
macro KA0302$L_SLOT7_LDEV = 172032,0,32,0 %;
macro KA0302$V_SLOT7_LDEV_DTYPE = 172032,0,16,0 %;
literal KA0302$S_SLOT7_LDEV_DTYPE = 16;
macro KA0302$V_SLOT7_LDEV_DREV = 172032,16,16,0 %;
literal KA0302$S_SLOT7_LDEV_DREV = 16;
macro KA0302$b_fill2940 = 172036,0,0,0 %;
literal KA0302$s_fill2940 = 60;
macro KA0302$L_SLOT7_LBER = 172096,0,32,0 %;
macro KA0302$V_SLOT7_LBER_E = 172096,0,1,0 %;
macro KA0302$V_SLOT7_LBER_UCE = 172096,1,1,0 %;
macro KA0302$V_SLOT7_LBER_UCE2 = 172096,2,1,0 %;
macro KA0302$V_SLOT7_LBER_CE = 172096,3,1,0 %;
macro KA0302$V_SLOT7_LBER_CE2 = 172096,4,1,0 %;
macro KA0302$V_SLOT7_LBER_CPE = 172096,5,1,0 %;
macro KA0302$V_SLOT7_LBER_CPE2 = 172096,6,1,0 %;
macro KA0302$V_SLOT7_LBER_CDPE = 172096,7,1,0 %;
macro KA0302$V_SLOT7_LBER_CDPE2 = 172096,8,1,0 %;
macro KA0302$V_SLOT7_LBER_TDE = 172096,9,1,0 %;
macro KA0302$V_SLOT7_LBER_STE = 172096,10,1,0 %;
macro KA0302$V_SLOT7_LBER_CNFE = 172096,11,1,0 %;
macro KA0302$V_SLOT7_LBER_NXAE = 172096,12,1,0 %;
macro KA0302$V_SLOT7_LBER_CAE = 172096,13,1,0 %;
macro KA0302$V_SLOT7_LBER_SHE = 172096,14,1,0 %;
macro KA0302$V_SLOT7_LBER_DIE = 172096,15,1,0 %;
macro KA0302$V_SLOT7_LBER_DTCE = 172096,16,1,0 %;
macro KA0302$V_SLOT7_LBER_CTCE = 172096,17,1,0 %;
macro KA0302$V_SLOT7_LBER_NSES = 172096,18,1,0 %;
macro KA0302$b_fill2950 = 172100,0,0,0 %;
literal KA0302$s_fill2950 = 60;
macro KA0302$L_SLOT7_LCNR = 172160,0,32,0 %;
macro KA0302$V_SLOT7_LCNR_CEEN = 172160,0,1,0 %;
macro KA0302$V_SLOT7_LCNR_RSTSTAT = 172160,28,1,0 %;
macro KA0302$V_SLOT7_LCNR_NHALT = 172160,29,1,0 %;
macro KA0302$V_SLOT7_LCNR_NRST = 172160,30,1,0 %;
macro KA0302$V_SLOT7_LCNR_STF = 172160,31,1,0 %;
macro KA0302$b_fill2955 = 172164,0,0,0 %;
literal KA0302$s_fill2955 = 60;
macro KA0302$L_SLOT7_IBR = 172224,0,32,0 %;
macro KA0302$V_SLOT7_IBR_RCV_SDAT = 172224,0,1,0 %;
macro KA0302$V_SLOT7_IBR_XMT_SDAT = 172224,1,1,0 %;
macro KA0302$V_SLOT7_IBR_SCLK = 172224,2,1,0 %;
macro KA0302$b_fill2960 = 172228,0,0,0 %;
literal KA0302$s_fill2960 = 316;
macro KA0302$L_SLOT7_LMMR0 = 172544,0,32,0 %;
macro KA0302$V_SLOT7_LMMR0_EN = 172544,0,1,0 %;
macro KA0302$V_SLOT7_LMMR0_INT = 172544,1,2,0 %;
literal KA0302$S_SLOT7_LMMR0_INT = 2;
macro KA0302$V_SLOT7_LMMR0_IA = 172544,3,2,0 %;
literal KA0302$S_SLOT7_LMMR0_IA = 2;
macro KA0302$V_SLOT7_LMMR0_AW = 172544,5,4,0 %;
literal KA0302$S_SLOT7_LMMR0_AW = 4;
macro KA0302$V_SLOT7_LMMR0_NBANKS = 172544,9,2,0 %;
literal KA0302$S_SLOT7_LMMR0_NBANKS = 2;
macro KA0302$V_SLOT7_LMMR0_ADDR = 172544,17,15,0 %;
literal KA0302$S_SLOT7_LMMR0_ADDR = 15;
macro KA0302$b_fill2970 = 172548,0,0,0 %;
literal KA0302$s_fill2970 = 60;
macro KA0302$L_SLOT7_LMMR1 = 172608,0,32,0 %;
macro KA0302$V_SLOT7_LMMR1_EN = 172608,0,1,0 %;
macro KA0302$V_SLOT7_LMMR1_INT = 172608,1,2,0 %;
literal KA0302$S_SLOT7_LMMR1_INT = 2;
macro KA0302$V_SLOT7_LMMR1_IA = 172608,3,2,0 %;
literal KA0302$S_SLOT7_LMMR1_IA = 2;
macro KA0302$V_SLOT7_LMMR1_AW = 172608,5,4,0 %;
literal KA0302$S_SLOT7_LMMR1_AW = 4;
macro KA0302$V_SLOT7_LMMR1_NBANKS = 172608,9,2,0 %;
literal KA0302$S_SLOT7_LMMR1_NBANKS = 2;
macro KA0302$V_SLOT7_LMMR1_ADDR = 172608,17,15,0 %;
literal KA0302$S_SLOT7_LMMR1_ADDR = 15;
macro KA0302$b_fill2980 = 172612,0,0,0 %;
literal KA0302$s_fill2980 = 60;
macro KA0302$L_SLOT7_LMMR2 = 172672,0,32,0 %;
macro KA0302$V_SLOT7_LMMR2_EN = 172672,0,1,0 %;
macro KA0302$V_SLOT7_LMMR2_INT = 172672,1,2,0 %;
literal KA0302$S_SLOT7_LMMR2_INT = 2;
macro KA0302$V_SLOT7_LMMR2_IA = 172672,3,2,0 %;
literal KA0302$S_SLOT7_LMMR2_IA = 2;
macro KA0302$V_SLOT7_LMMR2_AW = 172672,5,4,0 %;
literal KA0302$S_SLOT7_LMMR2_AW = 4;
macro KA0302$V_SLOT7_LMMR2_NBANKS = 172672,9,2,0 %;
literal KA0302$S_SLOT7_LMMR2_NBANKS = 2;
macro KA0302$V_SLOT7_LMMR2_ADDR = 172672,17,15,0 %;
literal KA0302$S_SLOT7_LMMR2_ADDR = 15;
macro KA0302$b_fill2990 = 172676,0,0,0 %;
literal KA0302$s_fill2990 = 60;
macro KA0302$L_SLOT7_LMMR3 = 172736,0,32,0 %;
macro KA0302$V_SLOT7_LMMR3_EN = 172736,0,1,0 %;
macro KA0302$V_SLOT7_LMMR3_INT = 172736,1,2,0 %;
literal KA0302$S_SLOT7_LMMR3_INT = 2;
macro KA0302$V_SLOT7_LMMR3_IA = 172736,3,2,0 %;
literal KA0302$S_SLOT7_LMMR3_IA = 2;
macro KA0302$V_SLOT7_LMMR3_AW = 172736,5,4,0 %;
literal KA0302$S_SLOT7_LMMR3_AW = 4;
macro KA0302$V_SLOT7_LMMR3_NBANKS = 172736,9,2,0 %;
literal KA0302$S_SLOT7_LMMR3_NBANKS = 2;
macro KA0302$V_SLOT7_LMMR3_ADDR = 172736,17,15,0 %;
literal KA0302$S_SLOT7_LMMR3_ADDR = 15;
macro KA0302$b_fill3000 = 172740,0,0,0 %;
literal KA0302$s_fill3000 = 60;
macro KA0302$L_SLOT7_LMMR4 = 172800,0,32,0 %;
macro KA0302$V_SLOT7_LMMR4_EN = 172800,0,1,0 %;
macro KA0302$V_SLOT7_LMMR4_INT = 172800,1,2,0 %;
literal KA0302$S_SLOT7_LMMR4_INT = 2;
macro KA0302$V_SLOT7_LMMR4_IA = 172800,3,2,0 %;
literal KA0302$S_SLOT7_LMMR4_IA = 2;
macro KA0302$V_SLOT7_LMMR4_AW = 172800,5,4,0 %;
literal KA0302$S_SLOT7_LMMR4_AW = 4;
macro KA0302$V_SLOT7_LMMR4_NBANKS = 172800,9,2,0 %;
literal KA0302$S_SLOT7_LMMR4_NBANKS = 2;
macro KA0302$V_SLOT7_LMMR4_ADDR = 172800,17,15,0 %;
literal KA0302$S_SLOT7_LMMR4_ADDR = 15;
macro KA0302$b_fill3010 = 172804,0,0,0 %;
literal KA0302$s_fill3010 = 60;
macro KA0302$L_SLOT7_LMMR5 = 172864,0,32,0 %;
macro KA0302$V_SLOT7_LMMR5_EN = 172864,0,1,0 %;
macro KA0302$V_SLOT7_LMMR5_INT = 172864,1,2,0 %;
literal KA0302$S_SLOT7_LMMR5_INT = 2;
macro KA0302$V_SLOT7_LMMR5_IA = 172864,3,2,0 %;
literal KA0302$S_SLOT7_LMMR5_IA = 2;
macro KA0302$V_SLOT7_LMMR5_AW = 172864,5,4,0 %;
literal KA0302$S_SLOT7_LMMR5_AW = 4;
macro KA0302$V_SLOT7_LMMR5_NBANKS = 172864,9,2,0 %;
literal KA0302$S_SLOT7_LMMR5_NBANKS = 2;
macro KA0302$V_SLOT7_LMMR5_ADDR = 172864,17,15,0 %;
literal KA0302$S_SLOT7_LMMR5_ADDR = 15;
macro KA0302$b_fill3020 = 172868,0,0,0 %;
literal KA0302$s_fill3020 = 60;
macro KA0302$L_SLOT7_LMMR6 = 172928,0,32,0 %;
macro KA0302$V_SLOT7_LMMR6_EN = 172928,0,1,0 %;
macro KA0302$V_SLOT7_LMMR6_INT = 172928,1,2,0 %;
literal KA0302$S_SLOT7_LMMR6_INT = 2;
macro KA0302$V_SLOT7_LMMR6_IA = 172928,3,2,0 %;
literal KA0302$S_SLOT7_LMMR6_IA = 2;
macro KA0302$V_SLOT7_LMMR6_AW = 172928,5,4,0 %;
literal KA0302$S_SLOT7_LMMR6_AW = 4;
macro KA0302$V_SLOT7_LMMR6_NBANKS = 172928,9,2,0 %;
literal KA0302$S_SLOT7_LMMR6_NBANKS = 2;
macro KA0302$V_SLOT7_LMMR6_ADDR = 172928,17,15,0 %;
literal KA0302$S_SLOT7_LMMR6_ADDR = 15;
macro KA0302$b_fill3030 = 172932,0,0,0 %;
literal KA0302$s_fill3030 = 60;
macro KA0302$L_SLOT7_LMMR7 = 172992,0,32,0 %;
macro KA0302$V_SLOT7_LMMR7_EN = 172992,0,1,0 %;
macro KA0302$V_SLOT7_LMMR7_INT = 172992,1,2,0 %;
literal KA0302$S_SLOT7_LMMR7_INT = 2;
macro KA0302$V_SLOT7_LMMR7_IA = 172992,3,2,0 %;
literal KA0302$S_SLOT7_LMMR7_IA = 2;
macro KA0302$V_SLOT7_LMMR7_AW = 172992,5,4,0 %;
literal KA0302$S_SLOT7_LMMR7_AW = 4;
macro KA0302$V_SLOT7_LMMR7_NBANKS = 172992,9,2,0 %;
literal KA0302$S_SLOT7_LMMR7_NBANKS = 2;
macro KA0302$V_SLOT7_LMMR7_ADDR = 172992,17,15,0 %;
literal KA0302$S_SLOT7_LMMR7_ADDR = 15;
macro KA0302$b_fill3040 = 172996,0,0,0 %;
literal KA0302$s_fill3040 = 572;
macro KA0302$L_SLOT7_LBESR0 = 173568,0,32,0 %;
macro KA0302$V_SLOT7_LBESR0_SYNDROME = 173568,0,7,0 %;
literal KA0302$S_SLOT7_LBESR0_SYNDROME = 7;
macro KA0302$b_fill3050 = 173572,0,0,0 %;
literal KA0302$s_fill3050 = 60;
macro KA0302$L_SLOT7_LBESR1 = 173632,0,32,0 %;
macro KA0302$V_SLOT7_LBESR1_SYNDROME = 173632,0,7,0 %;
literal KA0302$S_SLOT7_LBESR1_SYNDROME = 7;
macro KA0302$b_fill3060 = 173636,0,0,0 %;
literal KA0302$s_fill3060 = 60;
macro KA0302$L_SLOT7_LBESR2 = 173696,0,32,0 %;
macro KA0302$V_SLOT7_LBESR2_SYNDROME = 173696,0,7,0 %;
literal KA0302$S_SLOT7_LBESR2_SYNDROME = 7;
macro KA0302$b_fill3070 = 173700,0,0,0 %;
literal KA0302$s_fill3070 = 60;
macro KA0302$L_SLOT7_LBESR3 = 173760,0,32,0 %;
macro KA0302$V_SLOT7_LBESR3_SYNDROME = 173760,0,7,0 %;
literal KA0302$S_SLOT7_LBESR3_SYNDROME = 7;
macro KA0302$b_fill3080 = 173764,0,0,0 %;
literal KA0302$s_fill3080 = 60;
macro KA0302$L_SLOT7_LBECR0 = 173824,0,32,0 %;
macro KA0302$L_SLOT7_LBECR0_CA = 173824,0,32,0 %;
macro KA0302$b_fill3090 = 173828,0,0,0 %;
literal KA0302$s_fill3090 = 60;
macro KA0302$L_SLOT7_LBECR1 = 173888,0,32,0 %;
macro KA0302$V_SLOT7_LBECR1_CA = 173888,0,7,0 %;
literal KA0302$S_SLOT7_LBECR1_CA = 7;
macro KA0302$V_SLOT7_LBECR1_CID = 173888,7,4,0 %;
literal KA0302$S_SLOT7_LBECR1_CID = 4;
macro KA0302$V_SLOT7_LBECR1_RID = 173888,11,4,0 %;
literal KA0302$S_SLOT7_LBECR1_RID = 4;
macro KA0302$V_SLOT7_LBECR1_CNF = 173888,15,1,0 %;
macro KA0302$V_SLOT7_LBECR1_SHARED = 173888,16,1,0 %;
macro KA0302$V_SLOT7_LBECR1_DIRTY = 173888,17,1,0 %;
macro KA0302$V_SLOT7_LBECR1_DCYCLE = 173888,18,2,0 %;
literal KA0302$S_SLOT7_LBECR1_DCYCLE = 2;
macro KA0302$b_fill3100 = 173892,0,0,0 %;
literal KA0302$s_fill3100 = 1212;
macro KA0302$L_SLOT7_LMODE = 175104,0,32,0 %;
macro KA0302$b_fill3110 = 175108,0,0,0 %;
literal KA0302$s_fill3110 = 60;
macro KA0302$L_SLOT7_LMERR = 175168,0,32,0 %;
macro KA0302$b_fill3120 = 175172,0,0,0 %;
literal KA0302$s_fill3120 = 60;
macro KA0302$L_SLOT7_LLOCK = 175232,0,32,0 %;
macro KA0302$b_fill3130 = 175236,0,0,0 %;
literal KA0302$s_fill3130 = 60;
macro KA0302$L_SLOT7_LEDTO = 175296,0,32,0 %;
macro KA0302$b_fill3140 = 175300,0,0,0 %;
literal KA0302$s_fill3140 = 60;
macro KA0302$L_SLOT7_LDIAG = 175360,0,32,0 %;
macro KA0302$b_fill3150 = 175364,0,0,0 %;
literal KA0302$s_fill3150 = 60;
macro KA0302$L_SLOT7_LTAGA = 175424,0,32,0 %;
macro KA0302$b_fill3160 = 175428,0,0,0 %;
literal KA0302$s_fill3160 = 60;
macro KA0302$L_SLOT7_LTAGW = 175488,0,32,0 %;
macro KA0302$b_fill3170 = 175492,0,0,0 %;
literal KA0302$s_fill3170 = 124;
macro KA0302$L_SLOT7_LCON0 = 175616,0,32,0 %;
macro KA0302$b_fill3180 = 175620,0,0,0 %;
literal KA0302$s_fill3180 = 60;
macro KA0302$L_SLOT7_LCON1 = 175680,0,32,0 %;
macro KA0302$b_fill3190 = 175684,0,0,0 %;
literal KA0302$s_fill3190 = 188;
macro KA0302$L_SLOT7_LPERF = 175872,0,32,0 %;
macro KA0302$b_fill3200 = 175876,0,0,0 %;
literal KA0302$s_fill3200 = 60;
macro KA0302$L_SLOT7_LCNTR0 = 175936,0,32,0 %;
macro KA0302$b_fill3210 = 175940,0,0,0 %;
literal KA0302$s_fill3210 = 60;
macro KA0302$L_SLOT7_LCNTR1 = 176000,0,32,0 %;
macro KA0302$b_fill3220 = 176004,0,0,0 %;
literal KA0302$s_fill3220 = 60;
macro KA0302$L_SLOT7_LMISSADDR = 176064,0,32,0 %;
macro KA0302$b_fill3225 = 176068,0,0,0 %;
literal KA0302$s_fill3225 = 4156;
macro KA0302$L_SLOT7_MCR = 180224,0,32,0 %;
macro KA0302$b_fill3230 = 180228,0,0,0 %;
literal KA0302$s_fill3230 = 60;
macro KA0302$L_SLOT7_AMR = 180288,0,32,0 %;
macro KA0302$b_fill3240 = 180292,0,0,0 %;
literal KA0302$s_fill3240 = 60;
macro KA0302$L_SLOT7_MSTR0 = 180352,0,32,0 %;
macro KA0302$b_fill3250 = 180356,0,0,0 %;
literal KA0302$s_fill3250 = 60;
macro KA0302$L_SLOT7_MSTR1 = 180416,0,32,0 %;
macro KA0302$b_fill3260 = 180420,0,0,0 %;
literal KA0302$s_fill3260 = 60;
macro KA0302$L_SLOT7_FADR = 180480,0,32,0 %;
macro KA0302$b_fill3270 = 180484,0,0,0 %;
literal KA0302$s_fill3270 = 60;
macro KA0302$L_SLOT7_MERA = 180544,0,32,0 %;
macro KA0302$b_fill3280 = 180548,0,0,0 %;
literal KA0302$s_fill3280 = 60;
macro KA0302$L_SLOT7_MSYNDA = 180608,0,32,0 %;
macro KA0302$b_fill3290 = 180612,0,0,0 %;
literal KA0302$s_fill3290 = 60;
macro KA0302$L_SLOT7_MDRA = 180672,0,32,0 %;
macro KA0302$b_fill3300 = 180676,0,0,0 %;
literal KA0302$s_fill3300 = 60;
macro KA0302$L_SLOT7_MCBSA = 180736,0,32,0 %;
macro KA0302$b_fill3310 = 180740,0,0,0 %;
literal KA0302$s_fill3310 = 7996;
macro KA0302$L_SLOT7_MERB = 188736,0,32,0 %;
macro KA0302$b_fill3320 = 188740,0,0,0 %;
literal KA0302$s_fill3320 = 60;
macro KA0302$L_SLOT7_MSYNDB = 188800,0,32,0 %;
macro KA0302$b_fill3330 = 188804,0,0,0 %;
literal KA0302$s_fill3330 = 60;
macro KA0302$L_SLOT7_MDRB = 188864,0,32,0 %;
macro KA0302$b_fill3340 = 188868,0,0,0 %;
literal KA0302$s_fill3340 = 60;
macro KA0302$L_SLOT7_MCBSB = 188928,0,32,0 %;
macro KA0302$b_fill3350 = 188932,0,0,0 %;
literal KA0302$s_fill3350 = 7676;
macro KA0302$L_SLOT8_LDEV = 196608,0,32,0 %;
macro KA0302$V_SLOT8_LDEV_DTYPE = 196608,0,16,0 %;
literal KA0302$S_SLOT8_LDEV_DTYPE = 16;
macro KA0302$V_SLOT8_LDEV_DREV = 196608,16,16,0 %;
literal KA0302$S_SLOT8_LDEV_DREV = 16;
macro KA0302$b_fill3360 = 196612,0,0,0 %;
literal KA0302$s_fill3360 = 60;
macro KA0302$L_SLOT8_LBER = 196672,0,32,0 %;
macro KA0302$V_SLOT8_LBER_E = 196672,0,1,0 %;
macro KA0302$V_SLOT8_LBER_UCE = 196672,1,1,0 %;
macro KA0302$V_SLOT8_LBER_UCE2 = 196672,2,1,0 %;
macro KA0302$V_SLOT8_LBER_CE = 196672,3,1,0 %;
macro KA0302$V_SLOT8_LBER_CE2 = 196672,4,1,0 %;
macro KA0302$V_SLOT8_LBER_CPE = 196672,5,1,0 %;
macro KA0302$V_SLOT8_LBER_CPE2 = 196672,6,1,0 %;
macro KA0302$V_SLOT8_LBER_CDPE = 196672,7,1,0 %;
macro KA0302$V_SLOT8_LBER_CDPE2 = 196672,8,1,0 %;
macro KA0302$V_SLOT8_LBER_TDE = 196672,9,1,0 %;
macro KA0302$V_SLOT8_LBER_STE = 196672,10,1,0 %;
macro KA0302$V_SLOT8_LBER_CNFE = 196672,11,1,0 %;
macro KA0302$V_SLOT8_LBER_NXAE = 196672,12,1,0 %;
macro KA0302$V_SLOT8_LBER_CAE = 196672,13,1,0 %;
macro KA0302$V_SLOT8_LBER_SHE = 196672,14,1,0 %;
macro KA0302$V_SLOT8_LBER_DIE = 196672,15,1,0 %;
macro KA0302$V_SLOT8_LBER_DTCE = 196672,16,1,0 %;
macro KA0302$V_SLOT8_LBER_CTCE = 196672,17,1,0 %;
macro KA0302$V_SLOT8_LBER_NSES = 196672,18,1,0 %;
macro KA0302$b_fill3370 = 196676,0,0,0 %;
literal KA0302$s_fill3370 = 60;
macro KA0302$L_SLOT8_LCNR = 196736,0,32,0 %;
macro KA0302$V_SLOT8_LCNR_CEEN = 196736,0,1,0 %;
macro KA0302$V_SLOT8_LCNR_RSTSTAT = 196736,28,1,0 %;
macro KA0302$V_SLOT8_LCNR_NHALT = 196736,29,1,0 %;
macro KA0302$V_SLOT8_LCNR_NRST = 196736,30,1,0 %;
macro KA0302$V_SLOT8_LCNR_STF = 196736,31,1,0 %;
macro KA0302$b_fill3375 = 196740,0,0,0 %;
literal KA0302$s_fill3375 = 60;
macro KA0302$L_SLOT8_IBR = 196800,0,32,0 %;
macro KA0302$V_SLOT8_IBR_RCV_SDAT = 196800,0,1,0 %;
macro KA0302$V_SLOT8_IBR_XMT_SDAT = 196800,1,1,0 %;
macro KA0302$V_SLOT8_IBR_SCLK = 196800,2,1,0 %;
macro KA0302$b_fill3380 = 196804,0,0,0 %;
literal KA0302$s_fill3380 = 316;
macro KA0302$L_SLOT8_LMMR0 = 197120,0,32,0 %;
macro KA0302$V_SLOT8_LMMR0_EN = 197120,0,1,0 %;
macro KA0302$V_SLOT8_LMMR0_INT = 197120,1,2,0 %;
literal KA0302$S_SLOT8_LMMR0_INT = 2;
macro KA0302$V_SLOT8_LMMR0_IA = 197120,3,2,0 %;
literal KA0302$S_SLOT8_LMMR0_IA = 2;
macro KA0302$V_SLOT8_LMMR0_AW = 197120,5,4,0 %;
literal KA0302$S_SLOT8_LMMR0_AW = 4;
macro KA0302$V_SLOT8_LMMR0_NBANKS = 197120,9,2,0 %;
literal KA0302$S_SLOT8_LMMR0_NBANKS = 2;
macro KA0302$V_SLOT8_LMMR0_ADDR = 197120,17,15,0 %;
literal KA0302$S_SLOT8_LMMR0_ADDR = 15;
macro KA0302$b_fill3390 = 197124,0,0,0 %;
literal KA0302$s_fill3390 = 60;
macro KA0302$L_SLOT8_LMMR1 = 197184,0,32,0 %;
macro KA0302$V_SLOT8_LMMR1_EN = 197184,0,1,0 %;
macro KA0302$V_SLOT8_LMMR1_INT = 197184,1,2,0 %;
literal KA0302$S_SLOT8_LMMR1_INT = 2;
macro KA0302$V_SLOT8_LMMR1_IA = 197184,3,2,0 %;
literal KA0302$S_SLOT8_LMMR1_IA = 2;
macro KA0302$V_SLOT8_LMMR1_AW = 197184,5,4,0 %;
literal KA0302$S_SLOT8_LMMR1_AW = 4;
macro KA0302$V_SLOT8_LMMR1_NBANKS = 197184,9,2,0 %;
literal KA0302$S_SLOT8_LMMR1_NBANKS = 2;
macro KA0302$V_SLOT8_LMMR1_ADDR = 197184,17,15,0 %;
literal KA0302$S_SLOT8_LMMR1_ADDR = 15;
macro KA0302$b_fill3400 = 197188,0,0,0 %;
literal KA0302$s_fill3400 = 60;
macro KA0302$L_SLOT8_LMMR2 = 197248,0,32,0 %;
macro KA0302$V_SLOT8_LMMR2_EN = 197248,0,1,0 %;
macro KA0302$V_SLOT8_LMMR2_INT = 197248,1,2,0 %;
literal KA0302$S_SLOT8_LMMR2_INT = 2;
macro KA0302$V_SLOT8_LMMR2_IA = 197248,3,2,0 %;
literal KA0302$S_SLOT8_LMMR2_IA = 2;
macro KA0302$V_SLOT8_LMMR2_AW = 197248,5,4,0 %;
literal KA0302$S_SLOT8_LMMR2_AW = 4;
macro KA0302$V_SLOT8_LMMR2_NBANKS = 197248,9,2,0 %;
literal KA0302$S_SLOT8_LMMR2_NBANKS = 2;
macro KA0302$V_SLOT8_LMMR2_ADDR = 197248,17,15,0 %;
literal KA0302$S_SLOT8_LMMR2_ADDR = 15;
macro KA0302$b_fill3410 = 197252,0,0,0 %;
literal KA0302$s_fill3410 = 60;
macro KA0302$L_SLOT8_LMMR3 = 197312,0,32,0 %;
macro KA0302$V_SLOT8_LMMR3_EN = 197312,0,1,0 %;
macro KA0302$V_SLOT8_LMMR3_INT = 197312,1,2,0 %;
literal KA0302$S_SLOT8_LMMR3_INT = 2;
macro KA0302$V_SLOT8_LMMR3_IA = 197312,3,2,0 %;
literal KA0302$S_SLOT8_LMMR3_IA = 2;
macro KA0302$V_SLOT8_LMMR3_AW = 197312,5,4,0 %;
literal KA0302$S_SLOT8_LMMR3_AW = 4;
macro KA0302$V_SLOT8_LMMR3_NBANKS = 197312,9,2,0 %;
literal KA0302$S_SLOT8_LMMR3_NBANKS = 2;
macro KA0302$V_SLOT8_LMMR3_ADDR = 197312,17,15,0 %;
literal KA0302$S_SLOT8_LMMR3_ADDR = 15;
macro KA0302$b_fill3420 = 197316,0,0,0 %;
literal KA0302$s_fill3420 = 60;
macro KA0302$L_SLOT8_LMMR4 = 197376,0,32,0 %;
macro KA0302$V_SLOT8_LMMR4_EN = 197376,0,1,0 %;
macro KA0302$V_SLOT8_LMMR4_INT = 197376,1,2,0 %;
literal KA0302$S_SLOT8_LMMR4_INT = 2;
macro KA0302$V_SLOT8_LMMR4_IA = 197376,3,2,0 %;
literal KA0302$S_SLOT8_LMMR4_IA = 2;
macro KA0302$V_SLOT8_LMMR4_AW = 197376,5,4,0 %;
literal KA0302$S_SLOT8_LMMR4_AW = 4;
macro KA0302$V_SLOT8_LMMR4_NBANKS = 197376,9,2,0 %;
literal KA0302$S_SLOT8_LMMR4_NBANKS = 2;
macro KA0302$V_SLOT8_LMMR4_ADDR = 197376,17,15,0 %;
literal KA0302$S_SLOT8_LMMR4_ADDR = 15;
macro KA0302$b_fill3430 = 197380,0,0,0 %;
literal KA0302$s_fill3430 = 60;
macro KA0302$L_SLOT8_LMMR5 = 197440,0,32,0 %;
macro KA0302$V_SLOT8_LMMR5_EN = 197440,0,1,0 %;
macro KA0302$V_SLOT8_LMMR5_INT = 197440,1,2,0 %;
literal KA0302$S_SLOT8_LMMR5_INT = 2;
macro KA0302$V_SLOT8_LMMR5_IA = 197440,3,2,0 %;
literal KA0302$S_SLOT8_LMMR5_IA = 2;
macro KA0302$V_SLOT8_LMMR5_AW = 197440,5,4,0 %;
literal KA0302$S_SLOT8_LMMR5_AW = 4;
macro KA0302$V_SLOT8_LMMR5_NBANKS = 197440,9,2,0 %;
literal KA0302$S_SLOT8_LMMR5_NBANKS = 2;
macro KA0302$V_SLOT8_LMMR5_ADDR = 197440,17,15,0 %;
literal KA0302$S_SLOT8_LMMR5_ADDR = 15;
macro KA0302$b_fill3440 = 197444,0,0,0 %;
literal KA0302$s_fill3440 = 60;
macro KA0302$L_SLOT8_LMMR6 = 197504,0,32,0 %;
macro KA0302$V_SLOT8_LMMR6_EN = 197504,0,1,0 %;
macro KA0302$V_SLOT8_LMMR6_INT = 197504,1,2,0 %;
literal KA0302$S_SLOT8_LMMR6_INT = 2;
macro KA0302$V_SLOT8_LMMR6_IA = 197504,3,2,0 %;
literal KA0302$S_SLOT8_LMMR6_IA = 2;
macro KA0302$V_SLOT8_LMMR6_AW = 197504,5,4,0 %;
literal KA0302$S_SLOT8_LMMR6_AW = 4;
macro KA0302$V_SLOT8_LMMR6_NBANKS = 197504,9,2,0 %;
literal KA0302$S_SLOT8_LMMR6_NBANKS = 2;
macro KA0302$V_SLOT8_LMMR6_ADDR = 197504,17,15,0 %;
literal KA0302$S_SLOT8_LMMR6_ADDR = 15;
macro KA0302$b_fill3450 = 197508,0,0,0 %;
literal KA0302$s_fill3450 = 60;
macro KA0302$L_SLOT8_LMMR7 = 197568,0,32,0 %;
macro KA0302$V_SLOT8_LMMR7_EN = 197568,0,1,0 %;
macro KA0302$V_SLOT8_LMMR7_INT = 197568,1,2,0 %;
literal KA0302$S_SLOT8_LMMR7_INT = 2;
macro KA0302$V_SLOT8_LMMR7_IA = 197568,3,2,0 %;
literal KA0302$S_SLOT8_LMMR7_IA = 2;
macro KA0302$V_SLOT8_LMMR7_AW = 197568,5,4,0 %;
literal KA0302$S_SLOT8_LMMR7_AW = 4;
macro KA0302$V_SLOT8_LMMR7_NBANKS = 197568,9,2,0 %;
literal KA0302$S_SLOT8_LMMR7_NBANKS = 2;
macro KA0302$V_SLOT8_LMMR7_ADDR = 197568,17,15,0 %;
literal KA0302$S_SLOT8_LMMR7_ADDR = 15;
macro KA0302$b_fill3460 = 197572,0,0,0 %;
literal KA0302$s_fill3460 = 572;
macro KA0302$L_SLOT8_LBESR0 = 198144,0,32,0 %;
macro KA0302$V_SLOT8_LBESR0_SYNDROME = 198144,0,7,0 %;
literal KA0302$S_SLOT8_LBESR0_SYNDROME = 7;
macro KA0302$b_fill3470 = 198148,0,0,0 %;
literal KA0302$s_fill3470 = 60;
macro KA0302$L_SLOT8_LBESR1 = 198208,0,32,0 %;
macro KA0302$V_SLOT8_LBESR1_SYNDROME = 198208,0,7,0 %;
literal KA0302$S_SLOT8_LBESR1_SYNDROME = 7;
macro KA0302$b_fill3480 = 198212,0,0,0 %;
literal KA0302$s_fill3480 = 60;
macro KA0302$L_SLOT8_LBESR2 = 198272,0,32,0 %;
macro KA0302$V_SLOT8_LBESR2_SYNDROME = 198272,0,7,0 %;
literal KA0302$S_SLOT8_LBESR2_SYNDROME = 7;
macro KA0302$b_fill3490 = 198276,0,0,0 %;
literal KA0302$s_fill3490 = 60;
macro KA0302$L_SLOT8_LBESR3 = 198336,0,32,0 %;
macro KA0302$V_SLOT8_LBESR3_SYNDROME = 198336,0,7,0 %;
literal KA0302$S_SLOT8_LBESR3_SYNDROME = 7;
macro KA0302$b_fill3500 = 198340,0,0,0 %;
literal KA0302$s_fill3500 = 60;
macro KA0302$L_SLOT8_LBECR0 = 198400,0,32,0 %;
macro KA0302$L_SLOT8_LBECR0_CA = 198400,0,32,0 %;
macro KA0302$b_fill3510 = 198404,0,0,0 %;
literal KA0302$s_fill3510 = 60;
macro KA0302$L_SLOT8_LBECR1 = 198464,0,32,0 %;
macro KA0302$V_SLOT8_LBECR1_CA = 198464,0,7,0 %;
literal KA0302$S_SLOT8_LBECR1_CA = 7;
macro KA0302$V_SLOT8_LBECR1_CID = 198464,7,4,0 %;
literal KA0302$S_SLOT8_LBECR1_CID = 4;
macro KA0302$V_SLOT8_LBECR1_RID = 198464,11,4,0 %;
literal KA0302$S_SLOT8_LBECR1_RID = 4;
macro KA0302$V_SLOT8_LBECR1_CNF = 198464,15,1,0 %;
macro KA0302$V_SLOT8_LBECR1_SHARED = 198464,16,1,0 %;
macro KA0302$V_SLOT8_LBECR1_DIRTY = 198464,17,1,0 %;
macro KA0302$V_SLOT8_LBECR1_DCYCLE = 198464,18,2,0 %;
literal KA0302$S_SLOT8_LBECR1_DCYCLE = 2;
macro KA0302$b_fill3520 = 198468,0,0,0 %;
literal KA0302$s_fill3520 = 700;
macro KA0302$L_LILID0 = 199168,0,32,0 %;
macro KA0302$V_LILID0_IDENT = 199168,0,16,0 %;
literal KA0302$S_LILID0_IDENT = 16;
macro KA0302$b_fill3530 = 199172,0,0,0 %;
literal KA0302$s_fill3530 = 60;
macro KA0302$L_LILID1 = 199232,0,32,0 %;
macro KA0302$V_LILID1_IDENT = 199232,0,16,0 %;
literal KA0302$S_LILID1_IDENT = 16;
macro KA0302$b_fill3540 = 199236,0,0,0 %;
literal KA0302$s_fill3540 = 60;
macro KA0302$L_LILID2 = 199296,0,32,0 %;
macro KA0302$V_LILID2_IDENT = 199296,0,16,0 %;
literal KA0302$S_LILID2_IDENT = 16;
macro KA0302$b_fill3550 = 199300,0,0,0 %;
literal KA0302$s_fill3550 = 60;
macro KA0302$L_LILID3 = 199360,0,32,0 %;
macro KA0302$V_LILID3_IDENT = 199360,0,16,0 %;
literal KA0302$S_LILID3_IDENT = 16;
macro KA0302$b_fill3560 = 199364,0,0,0 %;
literal KA0302$s_fill3560 = 60;
macro KA0302$L_LCPUMASK = 199424,0,32,0 %;
macro KA0302$V_LCPUMASK_CPU0 = 199424,0,4,0 %;
literal KA0302$S_LCPUMASK_CPU0 = 4;
macro KA0302$V_LCPUMASK_CPU1 = 199424,4,4,0 %;
literal KA0302$S_LCPUMASK_CPU1 = 4;
macro KA0302$V_LCPUMASK_CPU2 = 199424,8,4,0 %;
literal KA0302$S_LCPUMASK_CPU2 = 4;
macro KA0302$V_LCPUMASK_CPU3 = 199424,12,4,0 %;
literal KA0302$S_LCPUMASK_CPU3 = 4;
macro KA0302$b_fill3570 = 199428,0,0,0 %;
literal KA0302$s_fill3570 = 252;
macro KA0302$Q_LMBPR = 199680,0,0,1 %;
literal KA0302$S_LMBPR = 8;
macro KA0302$b_fill3580 = 199688,0,0,0 %;
literal KA0302$s_fill3580 = 5112;
macro KA0302$L_IPCNSE = 204800,0,32,0 %;
macro KA0302$V_IPCNSE_MBX_HOSE0_TIP = 204800,0,1,0 %;
macro KA0302$V_IPCNSE_MBX_HOSE1_TIP = 204800,1,1,0 %;
macro KA0302$V_IPCNSE_MBX_HOSE2_TIP = 204800,2,1,0 %;
macro KA0302$V_IPCNSE_MBX_HOSE3_TIP = 204800,3,1,0 %;
macro KA0302$V_IPCNSE_UPHOSE0_OFLO = 204800,4,1,0 %;
macro KA0302$V_IPCNSE_UPHOSE1_OFLO = 204800,5,1,0 %;
macro KA0302$V_IPCNSE_UPHOSE2_OFLO = 204800,6,1,0 %;
macro KA0302$V_IPCNSE_UPHOSE3_OFLO = 204800,7,1,0 %;
macro KA0302$V_IPCNSE_UPHOSE0_PKT_ERR = 204800,8,1,0 %;
macro KA0302$V_IPCNSE_UPHOSE1_PKT_ERR = 204800,9,1,0 %;
macro KA0302$V_IPCNSE_UPHOSE2_PKT_ERR = 204800,10,1,0 %;
macro KA0302$V_IPCNSE_UPHOSE3_PKT_ERR = 204800,11,1,0 %;
macro KA0302$V_IPCNSE_UPHOSE0_PAR_ERR = 204800,12,1,0 %;
macro KA0302$V_IPCNSE_UPHOSE1_PAR_ERR = 204800,13,1,0 %;
macro KA0302$V_IPCNSE_UPHOSE2_PAR_ERR = 204800,14,1,0 %;
macro KA0302$V_IPCNSE_UPHOSE3_PAR_ERR = 204800,15,1,0 %;
macro KA0302$V_IPCNSE_UP_HIC_IE = 204800,16,1,0 %;
macro KA0302$V_IPCNSE_IPC_INT_ERR = 204800,17,1,0 %;
macro KA0302$V_IPCNSE_UP_VRTX_ERR = 204800,18,1,0 %;
macro KA0302$V_IPCNSE_DN_VRTX_ERR = 204800,19,1,0 %;
macro KA0302$V_IPCNSE_MULT_INTR_ERR = 204800,20,1,0 %;
macro KA0302$V_IPCNSE_INTR_NSES = 204800,31,1,0 %;
macro KA0302$b_fill3590 = 204804,0,0,0 %;
literal KA0302$s_fill3590 = 60;
macro KA0302$L_IPCVR = 204864,0,32,0 %;
macro KA0302$V_IPCVR_VECTOR = 204864,0,16,0 %;
literal KA0302$S_IPCVR_VECTOR = 16;
macro KA0302$b_fill3610 = 204868,0,0,0 %;
literal KA0302$s_fill3610 = 60;
macro KA0302$L_IPCMSR = 204928,0,32,0 %;
macro KA0302$V_IPCMSR_ARB_HIGH = 204928,0,1,0 %;
macro KA0302$V_IPCMSR_ARB_CTL = 204928,1,2,0 %;
literal KA0302$S_IPCMSR_ARB_CTL = 2;
macro KA0302$b_fill3620 = 204932,0,0,0 %;
literal KA0302$s_fill3620 = 60;
macro KA0302$L_IPCHST = 204992,0,32,0 %;
macro KA0302$V_IPCHST_H0_ERROR = 204992,0,1,0 %;
macro KA0302$V_IPCHST_H0_PWROK = 204992,1,1,0 %;
macro KA0302$V_IPCHST_H0_CBLOK = 204992,2,1,0 %;
macro KA0302$V_IPCHST_H0_PWROK_TRANS = 204992,3,1,0 %;
macro KA0302$V_IPCHST_H1_ERROR = 204992,4,1,0 %;
macro KA0302$V_IPCHST_H1_PWROK = 204992,5,1,0 %;
macro KA0302$V_IPCHST_H1_CBLOK = 204992,6,1,0 %;
macro KA0302$V_IPCHST_H1_PWROK_TRANS = 204992,7,1,0 %;
macro KA0302$V_IPCHST_H2_ERROR = 204992,8,1,0 %;
macro KA0302$V_IPCHST_H2_PWROK = 204992,9,1,0 %;
macro KA0302$V_IPCHST_H2_CBLOK = 204992,10,1,0 %;
macro KA0302$V_IPCHST_H2_PWROK_TRANS = 204992,11,1,0 %;
macro KA0302$V_IPCHST_H3_ERROR = 204992,12,1,0 %;
macro KA0302$V_IPCHST_H3_PWROK = 204992,13,1,0 %;
macro KA0302$V_IPCHST_H3_CBLOK = 204992,14,1,0 %;
macro KA0302$V_IPCHST_H3_PWROK_TRANS = 204992,15,1,0 %;
macro KA0302$V_IPCHST_HOSE0_RST = 204992,28,1,0 %;
macro KA0302$V_IPCHST_HOSE1_RST = 204992,29,1,0 %;
macro KA0302$V_IPCHST_HOSE2_RST = 204992,30,1,0 %;
macro KA0302$V_IPCHST_HOSE3_RST = 204992,31,1,0 %;
macro KA0302$b_fill3630 = 204996,0,0,0 %;
literal KA0302$s_fill3630 = 60;
macro KA0302$L_IPCDR = 205056,0,32,0 %;
macro KA0302$V_IPCDR_FRC_DN_ILL_CMD = 205056,0,1,0 %;
macro KA0302$V_IPCDR_FRC_DN_SEQ_ERR = 205056,1,1,0 %;
macro KA0302$V_IPCDR_FRC_DN_DPE = 205056,2,2,0 %;
literal KA0302$S_IPCDR_FRC_DN_DPE = 2;
macro KA0302$V_IPCDR_DIS_LSB_CMD = 205056,10,1,0 %;
macro KA0302$V_IPCDR_HIC_LPBCK_EN = 205056,11,1,0 %;
macro KA0302$V_IPCDR_FRC_DAT_PE = 205056,12,1,0 %;
macro KA0302$V_IPCDR_FRC_CMD_PE = 205056,13,1,0 %;
macro KA0302$V_IPCDR_FRC_CNFE = 205056,22,1,0 %;
macro KA0302$V_IPCDR_FRC_CAE = 205056,23,1,0 %;
macro KA0302$V_IPCDR_DIAG_ECC = 205056,24,7,0 %;
literal KA0302$S_IPCDR_DIAG_ECC = 7;
macro KA0302$V_IPCDR_DIAG_ECC_EN = 205056,31,1,0 %;
macro KA0302$b_fill3650 = 205060,0,0,0 %;
literal KA0302$s_fill3650 = 7932;
macro KA0302$L_LIOINTR = 212992,0,32,0 %;
macro KA0302$V_LIOINTR_CPU0 = 212992,0,4,0 %;
literal KA0302$S_LIOINTR_CPU0 = 4;
macro KA0302$V_LIOINTR_CPU1 = 212992,4,4,0 %;
literal KA0302$S_LIOINTR_CPU1 = 4;
macro KA0302$V_LIOINTR_CPU2 = 212992,8,4,0 %;
literal KA0302$S_LIOINTR_CPU2 = 4;
macro KA0302$V_LIOINTR_CPU3 = 212992,12,4,0 %;
literal KA0302$S_LIOINTR_CPU3 = 4;
macro KA0302$b_fill3660 = 212996,0,0,0 %;
literal KA0302$s_fill3660 = 60;
macro KA0302$L_LIPINTR = 213056,0,32,0 %;
macro KA0302$V_LIPINTR_CPU0 = 213056,0,4,0 %;
literal KA0302$S_LIPINTR_CPU0 = 4;
macro KA0302$V_LIPINTR_CPU1 = 213056,4,4,0 %;
literal KA0302$S_LIPINTR_CPU1 = 4;
macro KA0302$V_LIPINTR_CPU2 = 213056,8,4,0 %;
literal KA0302$S_LIPINTR_CPU2 = 4;
macro KA0302$V_LIPINTR_CPU3 = 213056,12,4,0 %;
literal KA0302$S_LIPINTR_CPU3 = 4;
macro KA0302$b_fill3670 = 213060,0,0,0 %;
literal KA0302$s_fill3670 = 8124;
macro KA0302$L_UART0A_RR0 = 221184,0,32,0 %;
macro KA0302$b_fill3680 = 221188,0,0,0 %;
literal KA0302$s_fill3680 = 60;
macro KA0302$L_UART0A_RR8 = 221248,0,32,0 %;
macro KA0302$b_fill3690 = 221252,0,0,0 %;
literal KA0302$s_fill3690 = 60;
macro KA0302$L_UART0B_RR0 = 221312,0,32,0 %;
macro KA0302$b_fill3700 = 221316,0,0,0 %;
literal KA0302$s_fill3700 = 60;
macro KA0302$L_UART0B_RR8 = 221376,0,32,0 %;
macro KA0302$b_fill3710 = 221380,0,0,0 %;
literal KA0302$s_fill3710 = 7996;
macro KA0302$L_UART1B_RR0 = 229376,0,32,0 %;
macro KA0302$L_UART1B_WR0 = 229376,0,32,0 %;
macro KA0302$b_fill3740 = 229380,0,0,0 %;
literal KA0302$s_fill3740 = 60;
macro KA0302$L_UART1B_RR8 = 229440,0,32,0 %;
macro KA0302$b_fill3750 = 229444,0,0,0 %;
literal KA0302$s_fill3750 = 60;
macro KA0302$L_UART1A_RR0 = 229504,0,32,0 %;
macro KA0302$b_fill3720 = 229508,0,0,0 %;
literal KA0302$s_fill3720 = 60;
macro KA0302$L_UART1A_RR8 = 229568,0,32,0 %;
macro KA0302$b_fill3730 = 229572,0,0,0 %;
literal KA0302$s_fill3730 = 7996;
macro KA0302$L_UART2B_RR0 = 237568,0,32,0 %;
macro KA0302$b_fill3780 = 237572,0,0,0 %;
literal KA0302$s_fill3780 = 60;
macro KA0302$L_UART2B_RR8 = 237632,0,32,0 %;
macro KA0302$b_fill3790 = 237636,0,0,0 %;
literal KA0302$s_fill3790 = 60;
macro KA0302$L_UART2A_RR0 = 237696,0,32,0 %;
macro KA0302$b_fill3760 = 237700,0,0,0 %;
literal KA0302$s_fill3760 = 60;
macro KA0302$L_UART2A_RR8 = 237760,0,32,0 %;
macro KA0302$b_fill3770 = 237764,0,0,0 %;
literal KA0302$s_fill3770 = 7996;
macro KA0302$L_WATCH_SECONDS = 245760,0,32,0 %;
macro KA0302$b_fill3800 = 245764,0,0,0 %;
literal KA0302$s_fill3800 = 124;
macro KA0302$L_WATCH_MINUTES = 245888,0,32,0 %;
macro KA0302$b_fill3810 = 245892,0,0,0 %;
literal KA0302$s_fill3810 = 124;
macro KA0302$L_WATCH_HOURS = 246016,0,32,0 %;
macro KA0302$b_fill3820 = 246020,0,0,0 %;
literal KA0302$s_fill3820 = 188;
macro KA0302$L_WATCH_DOM = 246208,0,32,0 %;
macro KA0302$b_fill3830 = 246212,0,0,0 %;
literal KA0302$s_fill3830 = 60;
macro KA0302$L_WATCH_MONTH = 246272,0,32,0 %;
macro KA0302$b_fill3840 = 246276,0,0,0 %;
literal KA0302$s_fill3840 = 60;
macro KA0302$L_WATCH_YEAR = 246336,0,32,0 %;
macro KA0302$b_fill3850 = 246340,0,0,0 %;
literal KA0302$s_fill3850 = 60;
macro KA0302$L_WATCH_CSRA = 246400,0,32,0 %;
macro KA0302$V_WATCH_CSRA_RS = 246400,0,4,0 %;
literal KA0302$S_WATCH_CSRA_RS = 4;
macro KA0302$V_WATCH_CSRA_DV = 246400,4,3,0 %;
literal KA0302$S_WATCH_CSRA_DV = 3;
macro KA0302$V_WATCH_CSRA_UIP = 246400,7,1,0 %;
macro KA0302$b_fill3860 = 246404,0,0,0 %;
literal KA0302$s_fill3860 = 60;
macro KA0302$L_WATCH_CSRB = 246464,0,32,0 %;
macro KA0302$V_WATCH_CSRB_DSE = 246464,0,1,0 %;
macro KA0302$V_WATCH_CSRB_24_12 = 246464,1,1,0 %;
macro KA0302$V_WATCH_CSRB_DM = 246464,2,1,0 %;
macro KA0302$V_WATCH_CSRB_SQWE = 246464,3,1,0 %;
macro KA0302$V_WATCH_CSRB_UIE = 246464,4,1,0 %;
macro KA0302$V_WATCH_CSRB_AIE = 246464,5,1,0 %;
macro KA0302$V_WATCH_CSRB_PIE = 246464,6,1,0 %;
macro KA0302$V_WATCH_CSRB_SET = 246464,7,1,0 %;
macro KA0302$b_fill3870 = 246468,0,0,0 %;
literal KA0302$s_fill3870 = 60;
macro KA0302$L_WATCH_CSRC = 246528,0,32,0 %;
macro KA0302$V_WATCH_CSRC_UF = 246528,4,1,0 %;
macro KA0302$V_WATCH_CSRC_AF = 246528,5,1,0 %;
macro KA0302$V_WATCH_CSRC_PF = 246528,6,1,0 %;
macro KA0302$V_WATCH_CSRC_IRQF = 246528,7,1,0 %;
macro KA0302$b_fill3880 = 246532,0,0,0 %;
literal KA0302$s_fill3880 = 60;
macro KA0302$L_WATCH_CSRD = 246592,0,32,0 %;
macro KA0302$V_WATCH_CSRD_VRT = 246592,7,1,0 %;
macro KA0302$b_fill3890 = 246596,0,0,0 %;
literal KA0302$s_fill3890 = 60;
macro KA0302$L_WATCH_RAM = 246656,0,32,0 %;
macro KA0302$b_fill3900 = 246660,0,0,0 %;
literal KA0302$s_fill3900 = 7292;
macro KA0302$L_GBUS_WHAMI = 253952,0,32,0 %;
macro KA0302$V_GBUS_WHAMI_NID = 253952,0,3,0 %;
literal KA0302$S_GBUS_WHAMI_NID = 3;
macro KA0302$V_GBUS_WHAMI_MFG = 253952,3,1,0 %;
macro KA0302$V_GBUS_WHAMI_LSB_BAD = 253952,4,1,0 %;
macro KA0302$b_fill3910 = 253956,0,0,0 %;
literal KA0302$s_fill3910 = 60;
macro KA0302$L_GBUS_LEDS = 254016,0,32,0 %;
macro KA0302$V_GBUS_LEDS_STP = 254016,0,1,0 %;
macro KA0302$V_GBUS_LEDS_CONW = 254016,1,1,0 %;
macro KA0302$V_GBUS_LEDS_RUN = 254016,2,1,0 %;
macro KA0302$V_GBUS_LEDS_LED3 = 254016,3,1,0 %;
macro KA0302$V_GBUS_LEDS_LED4 = 254016,4,1,0 %;
macro KA0302$V_GBUS_LEDS_LED5 = 254016,5,1,0 %;
macro KA0302$V_GBUS_LEDS_LED6 = 254016,6,1,0 %;
macro KA0302$V_GBUS_LEDS_LED7 = 254016,7,1,0 %;
macro KA0302$b_fill3920 = 254020,0,0,0 %;
literal KA0302$s_fill3920 = 60;
macro KA0302$L_GBUS_PMASK = 254080,0,32,0 %;
macro KA0302$V_GBUS_PMASK_HALTEN = 254080,0,1,0 %;
macro KA0302$V_GBUS_PMASK_SELTERM = 254080,1,2,0 %;
literal KA0302$S_GBUS_PMASK_SELTERM = 2;
macro KA0302$b_fill3930 = 254084,0,0,0 %;
literal KA0302$s_fill3930 = 60;
macro KA0302$L_GBUS_INTR = 254144,0,32,0 %;
macro KA0302$V_GBUS_INTR_UARTINT0 = 254144,0,1,0 %;
macro KA0302$V_GBUS_INTR_UARTINT1 = 254144,1,1,0 %;
macro KA0302$V_GBUS_INTR_LSB0 = 254144,2,1,0 %;
macro KA0302$V_GBUS_INTR_LSB2 = 254144,5,1,0 %;
macro KA0302$V_GBUS_INTR_IP = 254144,6,1,0 %;
macro KA0302$V_GBUS_INTR_INTIM = 254144,7,1,0 %;
macro KA0302$b_fill3940 = 254148,0,0,0 %;
literal KA0302$s_fill3940 = 60;
macro KA0302$L_GBUS_HALT = 254208,0,32,0 %;
macro KA0302$V_GBUS_HALT_PHALT = 254208,6,1,0 %;
macro KA0302$V_GBUS_HALT_NHALT = 254208,7,1,0 %;
macro KA0302$b_fill3950 = 254212,0,0,0 %;
literal KA0302$s_fill3950 = 60;
macro KA0302$L_GBUS_LSBRST = 254272,0,32,0 %;
macro KA0302$b_fill3960 = 254276,0,0,0 %;
literal KA0302$s_fill3960 = 60;
macro KA0302$L_GBUS_MISC = 254336,0,32,0 %;
macro KA0302$V_GBUS_MISC_EXPSEL = 254336,0,2,0 %;
literal KA0302$S_GBUS_MISC_EXPSEL = 2;
macro KA0302$b_fill3970 = 254340,0,0,0 %;
literal KA0302$s_fill3970 = 7804;
macro KA0302$L_GBUS_RMODE_ENA = 262144,0,32,0 %;
macro KA0302$b_fill3971 = 262148,0,0,0 %;
literal KA0302$s_fill3971 = 252;
macro KA0302$L_GBUS_LTAGRW = 262400,0,32,0 %;
literal FLAG$M_FINT_VECTOR = %X'FFFF';
literal FLAG$M_NID_NODESIDE = %X'1';
literal FLAG$M_NID_GA = %X'3E';
literal FLAG$M_NID_BUS_ADDRESS = %X'FFC0';
literal FLAG$M_STO_VALUE = %X'7F000000';
literal FLAG$M_STO_fill1 = %X'80000000';
literal FLAG$M_ERRORHI_CMD_FIELD = %X'FF';
literal FLAG$M_ERRORHI_STATUS_FIELD = %X'FF00';
literal FLAG$M_ERRORHI_CAP_LINES = %X'70000';
literal FLAG$M_ERRORHI_USE = %X'80000';
literal FLAG$M_ERRORHI_PROTO_ERR = %X'400000';
literal FLAG$M_ERRORHI_DA_PE = %X'800000';
literal FLAG$M_ERRORHI_CMD_PE = %X'1000000';
literal FLAG$M_ERRORHI_NXA = %X'4000000';
literal FLAG$M_ERRORHI_DISC_PHASE = %X'8000000';
literal FLAG$M_ERRORHI_DATA_PHASE = %X'10000000';
literal FLAG$M_ERRORHI_CON_PHASE = %X'20000000';
literal FLAG$M_ERRORHI_MASTER = %X'40000000';
literal FLAG$M_ERRORHI_ERR_SUM = %X'80000000';
literal FLAG$M_ERRORLO_NXTID = %X'1';
literal FLAG$M_TTO_VAL = %X'1E0000';
literal FLAG$M_BZRTRY_BRT = %X'3FF';
literal FLAG$M_BZRTRY_RETDLY = %X'FFF8000';
literal FLAG$M_FCTL_SM = %X'1';
literal FLAG$M_FCTL_SI = %X'2';
literal FLAG$M_FCTL_PRE = %X'4';
literal FLAG$M_FCTL_STF = %X'8';
literal FLAG$M_FCTL_MERR_EN = %X'10';
literal FLAG$M_FCTL_SEL_SLV_ERR_EN = %X'20';
literal FLAG$M_FCTL_SLV_ERR_EN = %X'40';
literal FLAG$M_FCTL_HOSE_ERR_EN = %X'80';
literal FLAG$M_FCTL_FATAL_ERR_ST_EN = %X'100';
literal FLAG$M_FCTL_FBUS_RESET = %X'200';
literal FLAG$M_FCTL_FINTEN_14 = %X'400';
literal FLAG$M_FCTL_FINTEN_15 = %X'800';
literal FLAG$M_FCTL_FINTEN_16 = %X'1000';
literal FLAG$M_FCTL_FINTEN_17 = %X'2000';
literal FLAG$M_FCTL_FINTEN = %X'4000';
literal FLAG$M_FCTL_GF0 = %X'8000';
literal FLAG$M_FCTL_GF1 = %X'10000';
literal FLAG$M_FCTL_MEMDECEN = %X'20000';
literal FLAG$M_FCTL_CSRRBEN = %X'40000';
literal FLAG$M_FCTL_ENUPRST = %X'80000';
literal FLAG$M_DIAG_DNP_HDRERR = %X'1';
literal FLAG$M_DIAG_DNP_DERR = %X'2';
literal FLAG$M_DIAG_DRE = %X'4';
literal FLAG$M_DIAG_FTTO = %X'8';
literal FLAG$M_DIAG_FBI = %X'10';
literal FLAG$M_DIAG_SDL = %X'20';
literal FLAG$M_DIAG_LBD = %X'40';
literal FLAG$M_DIAG_LBEN = %X'80';
literal FLAG$M_DIAG_LBRDY = %X'100';
literal FLAG$M_DIAG_CP = %X'8000';
literal FLAG$M_DIAG_CM = %X'FF0000';
literal FLAG$M_DIAG_BP = %X'FF000000';
literal FLAG$M_FERR_FINTERR = %X'1';
literal FLAG$M_FERR_DHURR = %X'2';
literal FLAG$M_FERR_DHDPE = %X'4';
literal FLAG$M_FERR_TTO = %X'8';
literal FLAG$M_FERR_STO = %X'10';
literal FLAG$M_FERR_BRTO = %X'20';
literal FLAG$M_FERR_DPCU = %X'8000';
literal FLAG$M_FERR_FIFOFULL = %X'10000';
literal FLAG$M_FERR_DNHSE_ICCE = %X'20000';
literal FLAG$M_FERR_DNHSE_PLE = %X'40000';
literal FLAG$M_FERR_DNHSE_IDMALE = %X'80000';
literal FLAG$M_FERR_DNHSE_CMDLE = %X'100000';
literal FLAG$M_FERR_DNHSE_HCPE = %X'200000';
literal FLAG$M_FERR_DNHSE_SEQERR = %X'400000';
literal FLAG$M_FERR_UMBCMD = %X'800000';
literal FLAG$M_FERR_BINT = %X'1000000';
literal FLAG$M_IBR_RCV_SDAT = %X'1';
literal FLAG$M_IBR_XMT_SDAT = %X'2';
literal FLAG$M_IBR_SCLK = %X'4';
literal FLAG$M_DEVICE_ID_FLAG_ID = %X'FFFF';
literal FLAG$M_DEVICE_ID_REV = %X'F0000';
literal FLAG$M_DEVICE_ID_NODESIDE = %X'100000';
literal FLAG$M_DEVICE_ID_GA = %X'3E00000';
literal FLAG$S_FLAGDEF = 60;            !  Old size name, synonym for  FLAG$S_KA0302FLAG
literal FLAG$S_KA0302FLAG = 60;
macro FLAG$L_FINT = 0,0,32,0 %;
macro FLAG$V_FINT_VECTOR = 0,0,16,0 %;
literal FLAG$S_FINT_VECTOR = 16;
macro FLAG$L_NID = 4,0,32,0 %;
macro FLAG$V_NID_NODESIDE = 4,0,1,0 %;
macro FLAG$V_NID_GA = 4,1,5,0 %;
literal FLAG$S_NID_GA = 5;
macro FLAG$V_NID_BUS_ADDRESS = 4,6,10,0 %;
literal FLAG$S_NID_BUS_ADDRESS = 10;
macro FLAG$L_STO = 8,0,32,0 %;
macro FLAG$V_STO_VALUE = 8,24,7,0 %;
literal FLAG$S_STO_VALUE = 7;
macro FLAG$V_STO_fill1 = 8,31,1,0 %;
macro FLAG$L_ERRORHI = 12,0,32,0 %;
macro FLAG$V_ERRORHI_CMD_FIELD = 12,0,8,0 %;
literal FLAG$S_ERRORHI_CMD_FIELD = 8;
macro FLAG$V_ERRORHI_STATUS_FIELD = 12,8,8,0 %;
literal FLAG$S_ERRORHI_STATUS_FIELD = 8;
macro FLAG$V_ERRORHI_CAP_LINES = 12,16,3,0 %;
literal FLAG$S_ERRORHI_CAP_LINES = 3;
macro FLAG$V_ERRORHI_USE = 12,19,1,0 %;
macro FLAG$V_ERRORHI_PROTO_ERR = 12,22,1,0 %;
macro FLAG$V_ERRORHI_DA_PE = 12,23,1,0 %;
macro FLAG$V_ERRORHI_CMD_PE = 12,24,1,0 %;
macro FLAG$V_ERRORHI_NXA = 12,26,1,0 %;
macro FLAG$V_ERRORHI_DISC_PHASE = 12,27,1,0 %;
macro FLAG$V_ERRORHI_DATA_PHASE = 12,28,1,0 %;
macro FLAG$V_ERRORHI_CON_PHASE = 12,29,1,0 %;
macro FLAG$V_ERRORHI_MASTER = 12,30,1,0 %;
macro FLAG$V_ERRORHI_ERR_SUM = 12,31,1,0 %;
macro FLAG$L_ERRORLO = 16,0,32,0 %;
macro FLAG$V_ERRORLO_NXTID = 16,0,1,0 %;
macro FLAG$L_FADRHI = 20,0,32,0 %;
macro FLAG$L_FADRLO = 24,0,32,0 %;
macro FLAG$L_TTO = 28,0,32,0 %;
macro FLAG$V_TTO_VAL = 28,17,4,0 %;
literal FLAG$S_TTO_VAL = 4;
macro FLAG$L_BZRTRY = 32,0,32,0 %;
macro FLAG$V_BZRTRY_BRT = 32,0,10,0 %;
literal FLAG$S_BZRTRY_BRT = 10;
macro FLAG$V_BZRTRY_RETDLY = 32,15,13,0 %;
literal FLAG$S_BZRTRY_RETDLY = 13;
macro FLAG$L_FCTL = 36,0,32,0 %;
macro FLAG$V_FCTL_SM = 36,0,1,0 %;
macro FLAG$V_FCTL_SI = 36,1,1,0 %;
macro FLAG$V_FCTL_PRE = 36,2,1,0 %;
macro FLAG$V_FCTL_STF = 36,3,1,0 %;
macro FLAG$V_FCTL_MERR_EN = 36,4,1,0 %;
macro FLAG$V_FCTL_SEL_SLV_ERR_EN = 36,5,1,0 %;
macro FLAG$V_FCTL_SLV_ERR_EN = 36,6,1,0 %;
macro FLAG$V_FCTL_HOSE_ERR_EN = 36,7,1,0 %;
macro FLAG$V_FCTL_FATAL_ERR_ST_EN = 36,8,1,0 %;
macro FLAG$V_FCTL_FBUS_RESET = 36,9,1,0 %;
macro FLAG$V_FCTL_FINTEN_14 = 36,10,1,0 %;
macro FLAG$V_FCTL_FINTEN_15 = 36,11,1,0 %;
macro FLAG$V_FCTL_FINTEN_16 = 36,12,1,0 %;
macro FLAG$V_FCTL_FINTEN_17 = 36,13,1,0 %;
macro FLAG$V_FCTL_FINTEN = 36,14,1,0 %;
macro FLAG$V_FCTL_GF0 = 36,15,1,0 %;
macro FLAG$V_FCTL_GF1 = 36,16,1,0 %;
macro FLAG$V_FCTL_MEMDECEN = 36,17,1,0 %;
macro FLAG$V_FCTL_CSRRBEN = 36,18,1,0 %;
macro FLAG$V_FCTL_ENUPRST = 36,19,1,0 %;
macro FLAG$L_DIAG = 40,0,32,0 %;
macro FLAG$V_DIAG_DNP_HDRERR = 40,0,1,0 %;
macro FLAG$V_DIAG_DNP_DERR = 40,1,1,0 %;
macro FLAG$V_DIAG_DRE = 40,2,1,0 %;
macro FLAG$V_DIAG_FTTO = 40,3,1,0 %;
macro FLAG$V_DIAG_FBI = 40,4,1,0 %;
macro FLAG$V_DIAG_SDL = 40,5,1,0 %;
macro FLAG$V_DIAG_LBD = 40,6,1,0 %;
macro FLAG$V_DIAG_LBEN = 40,7,1,0 %;
macro FLAG$V_DIAG_LBRDY = 40,8,1,0 %;
macro FLAG$V_DIAG_CP = 40,15,1,0 %;
macro FLAG$V_DIAG_CM = 40,16,8,0 %;
literal FLAG$S_DIAG_CM = 8;
macro FLAG$V_DIAG_BP = 40,24,8,0 %;
literal FLAG$S_DIAG_BP = 8;
macro FLAG$L_FGPR = 44,0,32,0 %;
macro FLAG$L_FERR = 48,0,32,0 %;
macro FLAG$V_FERR_FINTERR = 48,0,1,0 %;
macro FLAG$V_FERR_DHURR = 48,1,1,0 %;
macro FLAG$V_FERR_DHDPE = 48,2,1,0 %;
macro FLAG$V_FERR_TTO = 48,3,1,0 %;
macro FLAG$V_FERR_STO = 48,4,1,0 %;
macro FLAG$V_FERR_BRTO = 48,5,1,0 %;
macro FLAG$V_FERR_DPCU = 48,15,1,0 %;
macro FLAG$V_FERR_FIFOFULL = 48,16,1,0 %;
macro FLAG$V_FERR_DNHSE_ICCE = 48,17,1,0 %;
macro FLAG$V_FERR_DNHSE_PLE = 48,18,1,0 %;
macro FLAG$V_FERR_DNHSE_IDMALE = 48,19,1,0 %;
macro FLAG$V_FERR_DNHSE_CMDLE = 48,20,1,0 %;
macro FLAG$V_FERR_DNHSE_HCPE = 48,21,1,0 %;
macro FLAG$V_FERR_DNHSE_SEQERR = 48,22,1,0 %;
macro FLAG$V_FERR_UMBCMD = 48,23,1,0 %;
macro FLAG$V_FERR_BINT = 48,24,1,0 %;
macro FLAG$L_IBR = 52,0,32,0 %;
macro FLAG$V_IBR_RCV_SDAT = 52,0,1,0 %;
macro FLAG$V_IBR_XMT_SDAT = 52,1,1,0 %;
macro FLAG$V_IBR_SCLK = 52,2,1,0 %;
macro FLAG$L_DEVICE_ID = 56,0,32,0 %;
macro FLAG$V_DEVICE_ID_FLAG_ID = 56,0,16,0 %;
literal FLAG$S_DEVICE_ID_FLAG_ID = 16;
macro FLAG$V_DEVICE_ID_REV = 56,16,4,0 %;
literal FLAG$S_DEVICE_ID_REV = 4;
macro FLAG$V_DEVICE_ID_NODESIDE = 56,20,1,0 %;
macro FLAG$V_DEVICE_ID_GA = 56,21,5,0 %;
literal FLAG$S_DEVICE_ID_GA = 5;
literal LAMB$M_LDIAG_F39 = %X'100';
literal LAMB$M_LDIAG_STE = %X'200';
literal LAMB$M_LDIAG_FXA = %X'400';
literal LAMB$M_LDIAG_ASM = %X'1800';
literal LAMB$M_LDIAG_DRNK = %X'4000';
literal LAMB$M_LDIAG_FPE = %X'F0000';
literal LAMB$M_LDIAG_CRE = %X'100000';
literal LAMB$M_LDIAG_FRRM = %X'600000';
literal LAMB$M_LDIAG_LOOP = %X'800000';
literal LAMB$M_LDIAG_LOCK = %X'1000000';
literal LAMB$M_LDIAG_AS = %X'2000000';
literal LAMB$M_LDIAG_DLLF = %X'C000000';
literal LAMB$M_LDIAG_NODE = %X'F0000000';
literal LAMB$M_IMSK_IMBER = %X'10';
literal LAMB$M_IMSK_IRBDPE = %X'20';
literal LAMB$M_IMSK_IDFDPE = %X'40';
literal LAMB$M_IMSK_ITTO = %X'2000';
literal LAMB$M_IMSK_ICNAK = %X'8000';
literal LAMB$M_IMSK_IRER = %X'10000';
literal LAMB$M_IMSK_IRSE = %X'20000';
literal LAMB$M_IMSK_INRR = %X'40000';
literal LAMB$M_IMSK_ICRD = %X'80000';
literal LAMB$M_IMSK_IWDNAK = %X'100000';
literal LAMB$M_IMSK_IRIDNAK = %X'200000';
literal LAMB$M_IMSK_IWSE = %X'400000';
literal LAMB$M_IMSK_IXPE = %X'800000';
literal LAMB$M_IMSK_IIPE = %X'1000000';
literal LAMB$M_IMSK_IWEI = %X'2000000';
literal LAMB$M_IMSK_ICC = %X'8000000';
literal LAMB$M_LEVR_VEC = %X'FFFF';
literal LAMB$M_LERR_FE = %X'8';
literal LAMB$M_LERR_MBOF = %X'10';
literal LAMB$M_LERR_RBDPE = %X'20';
literal LAMB$M_LERR_DFDPE = %X'40';
literal LAMB$M_LERR_MBIA = %X'1000';
literal LAMB$M_LERR_MBIC = %X'2000';
literal LAMB$M_LERR_MBPE = %X'4000';
literal LAMB$M_LERR_IVID = %X'78000';
literal LAMB$M_LERR_DHDPE = %X'10000000';
literal LAMB$M_LERR_XMIPE0 = %X'20000000';
literal LAMB$M_LERR_XMIPE1 = %X'40000000';
literal LAMB$M_LERR_XMIPE2 = %X'80000000';
literal LAMB$M_IPR1_IP1 = %X'F';
literal LAMB$M_IPR1_IP2 = %X'F0';
literal LAMB$M_IPR1_IP3 = %X'F00';
literal LAMB$M_IPR1_IP4 = %X'F000';
literal LAMB$M_IPR1_IP5 = %X'F0000';
literal LAMB$M_IPR1_IP6 = %X'F00000';
literal LAMB$M_IPR1_IP7 = %X'F000000';
literal LAMB$M_IPR1_IP8 = %X'F0000000';
literal LAMB$M_IPR2_IP9 = %X'F';
literal LAMB$M_IPR2_IP10 = %X'F0';
literal LAMB$M_IPR2_IP11 = %X'F00';
literal LAMB$M_IPR2_IP12 = %X'F000';
literal LAMB$M_IPR2_IP13 = %X'F0000';
literal LAMB$M_IPR2_IP14 = %X'F00000';
literal LAMB$M_IPR2_LEIP = %X'80000000';
literal LAMB$M_IIPR_IPL14ID = %X'F';
literal LAMB$M_IIPR_IPL15ID = %X'F0';
literal LAMB$M_IIPR_IPL16ID = %X'F00';
literal LAMB$M_IIPR_IPL17ID = %X'F000';
literal LAMB$M_IIPR_IDENTID = %X'F0000';
literal LAMB$S_LAMBDEF = 96;            !  Old size name, synonym for LAMB$S_LAMB
literal LAMB$S_LAMB = 96;
macro LAMB$L_LDIAG = 64,0,32,0 %;
macro LAMB$V_LDIAG_F39 = 64,8,1,0 %;
macro LAMB$V_LDIAG_STE = 64,9,1,0 %;
macro LAMB$V_LDIAG_FXA = 64,10,1,0 %;
macro LAMB$V_LDIAG_ASM = 64,11,2,0 %;
literal LAMB$S_LDIAG_ASM = 2;
macro LAMB$V_LDIAG_DRNK = 64,14,1,0 %;
macro LAMB$V_LDIAG_FPE = 64,16,4,0 %;
literal LAMB$S_LDIAG_FPE = 4;
macro LAMB$V_LDIAG_CRE = 64,20,1,0 %;
macro LAMB$V_LDIAG_FRRM = 64,21,2,0 %;
literal LAMB$S_LDIAG_FRRM = 2;
macro LAMB$V_LDIAG_LOOP = 64,23,1,0 %;
macro LAMB$V_LDIAG_LOCK = 64,24,1,0 %;
macro LAMB$V_LDIAG_AS = 64,25,1,0 %;
macro LAMB$V_LDIAG_DLLF = 64,26,2,0 %;
literal LAMB$S_LDIAG_DLLF = 2;
macro LAMB$V_LDIAG_NODE = 64,28,4,0 %;
literal LAMB$S_LDIAG_NODE = 4;
macro LAMB$L_IMSK = 68,0,32,0 %;
macro LAMB$V_IMSK_IMBER = 68,4,1,0 %;
macro LAMB$V_IMSK_IRBDPE = 68,5,1,0 %;
macro LAMB$V_IMSK_IDFDPE = 68,6,1,0 %;
macro LAMB$V_IMSK_ITTO = 68,13,1,0 %;
macro LAMB$V_IMSK_ICNAK = 68,15,1,0 %;
macro LAMB$V_IMSK_IRER = 68,16,1,0 %;
macro LAMB$V_IMSK_IRSE = 68,17,1,0 %;
macro LAMB$V_IMSK_INRR = 68,18,1,0 %;
macro LAMB$V_IMSK_ICRD = 68,19,1,0 %;
macro LAMB$V_IMSK_IWDNAK = 68,20,1,0 %;
macro LAMB$V_IMSK_IRIDNAK = 68,21,1,0 %;
macro LAMB$V_IMSK_IWSE = 68,22,1,0 %;
macro LAMB$V_IMSK_IXPE = 68,23,1,0 %;
macro LAMB$V_IMSK_IIPE = 68,24,1,0 %;
macro LAMB$V_IMSK_IWEI = 68,25,1,0 %;
macro LAMB$V_IMSK_ICC = 68,27,1,0 %;
macro LAMB$L_LEVR = 72,0,32,0 %;
macro LAMB$V_LEVR_VEC = 72,0,16,0 %;
literal LAMB$S_LEVR_VEC = 16;
macro LAMB$L_LERR = 76,0,32,0 %;
macro LAMB$V_LERR_FE = 76,3,1,0 %;
macro LAMB$V_LERR_MBOF = 76,4,1,0 %;
macro LAMB$V_LERR_RBDPE = 76,5,1,0 %;
macro LAMB$V_LERR_DFDPE = 76,6,1,0 %;
macro LAMB$V_LERR_MBIA = 76,12,1,0 %;
macro LAMB$V_LERR_MBIC = 76,13,1,0 %;
macro LAMB$V_LERR_MBPE = 76,14,1,0 %;
macro LAMB$V_LERR_IVID = 76,15,4,0 %;
literal LAMB$S_LERR_IVID = 4;
macro LAMB$V_LERR_DHDPE = 76,28,1,0 %;
macro LAMB$V_LERR_XMIPE0 = 76,29,1,0 %;
macro LAMB$V_LERR_XMIPE1 = 76,30,1,0 %;
macro LAMB$V_LERR_XMIPE2 = 76,31,1,0 %;
macro LAMB$L_LGPR = 80,0,32,0 %;
macro LAMB$L_IPR1 = 84,0,32,0 %;
macro LAMB$V_IPR1_IP1 = 84,0,4,0 %;
literal LAMB$S_IPR1_IP1 = 4;
macro LAMB$V_IPR1_IP2 = 84,4,4,0 %;
literal LAMB$S_IPR1_IP2 = 4;
macro LAMB$V_IPR1_IP3 = 84,8,4,0 %;
literal LAMB$S_IPR1_IP3 = 4;
macro LAMB$V_IPR1_IP4 = 84,12,4,0 %;
literal LAMB$S_IPR1_IP4 = 4;
macro LAMB$V_IPR1_IP5 = 84,16,4,0 %;
literal LAMB$S_IPR1_IP5 = 4;
macro LAMB$V_IPR1_IP6 = 84,20,4,0 %;
literal LAMB$S_IPR1_IP6 = 4;
macro LAMB$V_IPR1_IP7 = 84,24,4,0 %;
literal LAMB$S_IPR1_IP7 = 4;
macro LAMB$V_IPR1_IP8 = 84,28,4,0 %;
literal LAMB$S_IPR1_IP8 = 4;
macro LAMB$L_IPR2 = 88,0,32,0 %;
macro LAMB$V_IPR2_IP9 = 88,0,4,0 %;
literal LAMB$S_IPR2_IP9 = 4;
macro LAMB$V_IPR2_IP10 = 88,4,4,0 %;
literal LAMB$S_IPR2_IP10 = 4;
macro LAMB$V_IPR2_IP11 = 88,8,4,0 %;
literal LAMB$S_IPR2_IP11 = 4;
macro LAMB$V_IPR2_IP12 = 88,12,4,0 %;
literal LAMB$S_IPR2_IP12 = 4;
macro LAMB$V_IPR2_IP13 = 88,16,4,0 %;
literal LAMB$S_IPR2_IP13 = 4;
macro LAMB$V_IPR2_IP14 = 88,20,4,0 %;
literal LAMB$S_IPR2_IP14 = 4;
macro LAMB$V_IPR2_LEIP = 88,31,1,0 %;
macro LAMB$L_IIPR = 92,0,32,0 %;
macro LAMB$V_IIPR_IPL14ID = 92,0,4,0 %;
literal LAMB$S_IIPR_IPL14ID = 4;
macro LAMB$V_IIPR_IPL15ID = 92,4,4,0 %;
literal LAMB$S_IIPR_IPL15ID = 4;
macro LAMB$V_IIPR_IPL16ID = 92,8,4,0 %;
literal LAMB$S_IIPR_IPL16ID = 4;
macro LAMB$V_IIPR_IPL17ID = 92,12,4,0 %;
literal LAMB$S_IIPR_IPL17ID = 4;
macro LAMB$V_IIPR_IDENTID = 92,16,4,0 %;
literal LAMB$S_IIPR_IDENTID = 4;
 
!*** MODULE $MCHECK0302DEF ***
literal MCHECK0302$M_GBUS_HALT_PHALT = %X'40';
literal MCHECK0302$M_GBUS_HALT_NHALT = %X'80';
literal MCHECK0302$M_GBUS_INTR_UARTINT0 = %X'10000';
literal MCHECK0302$M_GBUS_INTR_UARTINT1 = %X'20000';
literal MCHECK0302$M_GBUS_INTR_LSB0 = %X'40000';
literal MCHECK0302$M_GBUS_INTR_LSB2 = %X'200000';
literal MCHECK0302$M_GBUS_INTR_IP = %X'400000';
literal MCHECK0302$M_GBUS_INTR_INTIM = %X'800000';
literal MCHECK0302$M_GBUS_PMASK_HALTEN = %X'100000000';
literal MCHECK0302$M_GBUS_PMASK_SELTERM = %X'600000000';
literal MCHECK0302$M_GBUS_WHAMI_NID = %X'7000000000000';
literal MCHECK0302$M_GBUS_WHAMI_MFG = %X'8000000000000';
literal MCHECK0302$M_GBUS_WHAMI_LSB_BAD = %X'10000000000000';
literal MCHECK0302$S_GBUS = 7;
macro MCHECK0302$V_GBUS_HALT_PHALT = 0,6,1,0 %;
macro MCHECK0302$V_GBUS_HALT_NHALT = 0,7,1,0 %;
macro MCHECK0302$V_GBUS_INTR_UARTINT0 = 0,16,1,0 %;
macro MCHECK0302$V_GBUS_INTR_UARTINT1 = 0,17,1,0 %;
macro MCHECK0302$V_GBUS_INTR_LSB0 = 0,18,1,0 %;
macro MCHECK0302$V_GBUS_INTR_LSB2 = 0,21,1,0 %;
macro MCHECK0302$V_GBUS_INTR_IP = 0,22,1,0 %;
macro MCHECK0302$V_GBUS_INTR_INTIM = 0,23,1,0 %;
macro MCHECK0302$V_GBUS_PMASK_HALTEN = 4,0,1,0 %;
macro MCHECK0302$V_GBUS_PMASK_SELTERM = 4,1,2,0 %;
literal MCHECK0302$S_GBUS_PMASK_SELTERM = 2;
macro MCHECK0302$V_GBUS_WHAMI_NID = 4,16,3,0 %;
literal MCHECK0302$S_GBUS_WHAMI_NID = 3;
macro MCHECK0302$V_GBUS_WHAMI_MFG = 4,19,1,0 %;
macro MCHECK0302$V_GBUS_WHAMI_LSB_BAD = 4,20,1,0 %;
literal MCHECK0302$S_LMODE = 4;
macro MCHECK0302$L_LMODE = 0,0,32,0 %;
literal MCHECK0302$S_LMERR = 8;
macro MCHECK0302$L_LMERR = 0,0,32,0 %;
macro MCHECK0302$v_lmerr_pmap_dlowpe = 0,0,1,0 %;
macro MCHECK0302$v_lmerr_pmap_dhipe = 0,1,1,0 %;
macro MCHECK0302$v_lmerr_pmap_i0pe = 0,2,1,0 %;
macro MCHECK0302$v_lmerr_pmap_i1pe = 0,3,1,0 %;
macro MCHECK0302$v_lmerr_btagpe = 0,4,1,0 %; !  BTAG Parity Error
macro MCHECK0302$v_lmerr_bstatpe = 0,5,1,0 %; !  BSTATUS Parity Error
macro MCHECK0302$v_lmerr_bmappe = 0,6,1,0 %; !  BMAP Parity Error
macro MCHECK0302$v_lmerr_bdatasbe = 0,7,1,0 %; !  Bcache Data Single Bit error 
macro MCHECK0302$v_lmerr_bdatadbe = 0,8,1,0 %; !  Bcache Data Double Bit error 
macro MCHECK0302$v_lmerr_arbcol = 0,9,1,0 %; !  Arbitration COllision 
macro MCHECK0302$v_lmerr_arbdrop = 0,10,1,0 %; !  Arbitration Drop
macro MCHECK0302$v_lmerr_edalto = 0,11,1,0 %; !  EDAL Timeout.
literal MCHECK0302$S_LLOCK = 4;
macro MCHECK0302$L_LLOCK = 0,0,32,0 %;
literal MCHECK0302$M_LBER_E = %X'1';
literal MCHECK0302$M_LBER_UCE = %X'2';
literal MCHECK0302$M_LBER_UCE2 = %X'4';
literal MCHECK0302$M_LBER_CE = %X'8';
literal MCHECK0302$M_LBER_CE2 = %X'10';
literal MCHECK0302$M_LBER_CPE = %X'20';
literal MCHECK0302$M_LBER_CPE2 = %X'40';
literal MCHECK0302$M_LBER_CDPE = %X'80';
literal MCHECK0302$M_LBER_CDPE2 = %X'100';
literal MCHECK0302$M_LBER_TDE = %X'200';
literal MCHECK0302$M_LBER_STE = %X'400';
literal MCHECK0302$M_LBER_CNFE = %X'800';
literal MCHECK0302$M_LBER_NXAE = %X'1000';
literal MCHECK0302$M_LBER_CAE = %X'2000';
literal MCHECK0302$M_LBER_SHE = %X'4000';
literal MCHECK0302$M_LBER_DIE = %X'8000';
literal MCHECK0302$M_LBER_DTCE = %X'10000';
literal MCHECK0302$M_LBER_CTCE = %X'20000';
literal MCHECK0302$M_LBER_NSES = %X'40000';
literal MCHECK0302$S_LBER = 4;
macro MCHECK0302$L_LBER = 0,0,32,0 %;
macro MCHECK0302$V_LBER_E = 0,0,1,0 %;
macro MCHECK0302$V_LBER_UCE = 0,1,1,0 %;
macro MCHECK0302$V_LBER_UCE2 = 0,2,1,0 %;
macro MCHECK0302$V_LBER_CE = 0,3,1,0 %;
macro MCHECK0302$V_LBER_CE2 = 0,4,1,0 %;
macro MCHECK0302$V_LBER_CPE = 0,5,1,0 %;
macro MCHECK0302$V_LBER_CPE2 = 0,6,1,0 %;
macro MCHECK0302$V_LBER_CDPE = 0,7,1,0 %;
macro MCHECK0302$V_LBER_CDPE2 = 0,8,1,0 %;
macro MCHECK0302$V_LBER_TDE = 0,9,1,0 %;
macro MCHECK0302$V_LBER_STE = 0,10,1,0 %;
macro MCHECK0302$V_LBER_CNFE = 0,11,1,0 %;
macro MCHECK0302$V_LBER_NXAE = 0,12,1,0 %;
macro MCHECK0302$V_LBER_CAE = 0,13,1,0 %;
macro MCHECK0302$V_LBER_SHE = 0,14,1,0 %;
macro MCHECK0302$V_LBER_DIE = 0,15,1,0 %;
macro MCHECK0302$V_LBER_DTCE = 0,16,1,0 %;
macro MCHECK0302$V_LBER_CTCE = 0,17,1,0 %;
macro MCHECK0302$V_LBER_NSES = 0,18,1,0 %;
literal MCHECK0302$M_LCNR_CEEN = %X'1';
literal MCHECK0302$M_LCNR_RSTSTAT = %X'10000000';
literal MCHECK0302$M_LCNR_NHALT = %X'20000000';
literal MCHECK0302$M_LCNR_NRST = %X'40000000';
literal MCHECK0302$M_LCNR_STF = %X'80000000';
literal MCHECK0302$S_LCNR = 4;
macro MCHECK0302$L_LCNR = 0,0,32,0 %;
macro MCHECK0302$V_LCNR_CEEN = 0,0,1,0 %;
macro MCHECK0302$V_LCNR_RSTSTAT = 0,28,1,0 %;
macro MCHECK0302$V_LCNR_NHALT = 0,29,1,0 %;
macro MCHECK0302$V_LCNR_NRST = 0,30,1,0 %;
macro MCHECK0302$V_LCNR_STF = 0,31,1,0 %;
literal MCHECK0302$M_LDEV_DTYPE = %X'FFFF';
literal MCHECK0302$M_LDEV_DREV = %X'FFFF0000';
literal MCHECK0302$S_LDEV = 4;
macro MCHECK0302$L_LDEV = 0,0,32,0 %;
macro MCHECK0302$V_LDEV_DTYPE = 0,0,16,0 %;
literal MCHECK0302$S_LDEV_DTYPE = 16;
macro MCHECK0302$V_LDEV_DREV = 0,16,16,0 %;
literal MCHECK0302$S_LDEV_DREV = 16;
literal MCHECK0302$M_LBESR0_SYNDROME = %X'7F';
literal MCHECK0302$S_LBESR0 = 4;
macro MCHECK0302$L_LBESR0 = 0,0,32,0 %;
macro MCHECK0302$V_LBESR0_SYNDROME = 0,0,7,0 %;
literal MCHECK0302$S_LBESR0_SYNDROME = 7;
literal MCHECK0302$M_LBESR1_SYNDROME = %X'7F';
literal MCHECK0302$S_LBESR1 = 4;
macro MCHECK0302$L_LBESR1 = 0,0,32,0 %;
macro MCHECK0302$V_LBESR1_SYNDROME = 0,0,7,0 %;
literal MCHECK0302$S_LBESR1_SYNDROME = 7;
literal MCHECK0302$M_LBESR2_SYNDROME = %X'7F';
literal MCHECK0302$S_LBESR2 = 4;
macro MCHECK0302$L_LBESR2 = 0,0,32,0 %;
macro MCHECK0302$V_LBESR2_SYNDROME = 0,0,7,0 %;
literal MCHECK0302$S_LBESR2_SYNDROME = 7;
literal MCHECK0302$M_LBESR3_SYNDROME = %X'7F';
literal MCHECK0302$S_LBESR3 = 4;
macro MCHECK0302$L_LBESR3 = 0,0,32,0 %;
macro MCHECK0302$V_LBESR3_SYNDROME = 0,0,7,0 %;
literal MCHECK0302$S_LBESR3_SYNDROME = 7;
literal MCHECK0302$S_LBECR0 = 4;
macro MCHECK0302$L_LBECR0 = 0,0,32,0 %;
macro MCHECK0302$L_LBECR0_CA = 0,0,32,0 %;
literal MCHECK0302$M_LBECR1_CA = %X'7';
literal MCHECK0302$M_LBECR1_CMD = %X'38';
literal MCHECK0302$M_LBECR1_RSVD = %X'780';
literal MCHECK0302$M_LBECR1_CID = %X'7800';
literal MCHECK0302$M_LBECR1_CNF = %X'8000';
literal MCHECK0302$M_LBECR1_SHARED = %X'10000';
literal MCHECK0302$M_LBECR1_DIRTY = %X'20000';
literal MCHECK0302$M_LBECR1_DCYCLE = %X'C0000';
literal MCHECK0302$S_LBECR1 = 4;
macro MCHECK0302$L_LBECR1 = 0,0,32,0 %;
macro MCHECK0302$V_LBECR1_CA = 0,0,3,0 %;
literal MCHECK0302$S_LBECR1_CA = 3;
macro MCHECK0302$V_LBECR1_CMD = 0,3,3,0 %;
literal MCHECK0302$S_LBECR1_CMD = 3;
macro MCHECK0302$V_LBECR1_PAR = 0,6,1,0 %;
macro MCHECK0302$V_LBECR1_RSVD = 0,7,4,0 %;
literal MCHECK0302$S_LBECR1_RSVD = 4;
macro MCHECK0302$V_LBECR1_CID = 0,11,4,0 %;
literal MCHECK0302$S_LBECR1_CID = 4;
macro MCHECK0302$V_LBECR1_CNF = 0,15,1,0 %;
macro MCHECK0302$V_LBECR1_SHARED = 0,16,1,0 %;
macro MCHECK0302$V_LBECR1_DIRTY = 0,17,1,0 %;
macro MCHECK0302$V_LBECR1_DCYCLE = 0,18,2,0 %;
literal MCHECK0302$S_LBECR1_DCYCLE = 2;
literal MCHECK0302$M_MCR_DTYPE = %X'1';
literal MCHECK0302$M_MCR_STRN = %X'C';
literal MCHECK0302$S_MCR = 4;           !  Old size name, synonym for  MCHECK0302$S_KA0302MCR
literal MCHECK0302$S_KA0302MCR = 4;
macro MCHECK0302$L_MCR = 0,0,32,0 %;
macro MCHECK0302$V_MCR_DTYPE = 0,0,1,0 %;
macro MCHECK0302$V_MCR_STRN = 0,2,2,0 %;
literal MCHECK0302$S_MCR_STRN = 2;
literal MCHECK0302$M_AMR_E = %X'1';
literal MCHECK0302$M_AMR_INTL = %X'6';
literal MCHECK0302$M_AMR_IA = %X'18';
literal MCHECK0302$M_AMR_AW = %X'1E0';
literal MCHECK0302$M_AMR_NBANKS = %X'600';
literal MCHECK0302$M_AMR_MADR = %X'FFFE0000';
literal MCHECK0302$S_AMR = 4;           !  Old size name, synonym for  MCHECK0302$S_KA0302AMR
literal MCHECK0302$S_KA0302AMR = 4;
macro MCHECK0302$L_AMR = 0,0,32,0 %;
macro MCHECK0302$V_AMR_E = 0,0,1,0 %;
macro MCHECK0302$V_AMR_INTL = 0,1,2,0 %;
literal MCHECK0302$S_AMR_INTL = 2;
macro MCHECK0302$V_AMR_IA = 0,3,2,0 %;
literal MCHECK0302$S_AMR_IA = 2;
macro MCHECK0302$V_AMR_AW = 0,5,4,0 %;
literal MCHECK0302$S_AMR_AW = 4;
macro MCHECK0302$V_AMR_NBANKS = 0,9,2,0 %;
literal MCHECK0302$S_AMR_NBANKS = 2;
macro MCHECK0302$V_AMR_MADR = 0,17,15,0 %;
literal MCHECK0302$S_AMR_MADR = 15;
literal MCHECK0302$S_MSTR0 = 4;
macro MCHECK0302$L_MSTR0 = 0,0,32,0 %;
literal MCHECK0302$S_MSTR1 = 4;
macro MCHECK0302$L_MSTR1 = 0,0,32,0 %;
literal MCHECK0302$S_FADR = 4;
macro MCHECK0302$L_FADR = 0,0,32,0 %;
literal MCHECK0302$M_MERA_CER = %X'1';
literal MCHECK0302$M_MERA_UCER = %X'2';
literal MCHECK0302$M_MERA_MULE = %X'4';
literal MCHECK0302$M_MERA_APER = %X'8';
literal MCHECK0302$M_MERA_CERA = %X'10';
literal MCHECK0302$M_MERA_CERB = %X'20';
literal MCHECK0302$M_MERA_FSTR = %X'1C0';
literal MCHECK0302$M_MERA_BNKER = %X'200';
literal MCHECK0302$M_MERA_UCERA = %X'400';
literal MCHECK0302$M_MERA_UCERB = %X'800';
literal MCHECK0302$S_MERA = 4;
macro MCHECK0302$L_MERA = 0,0,32,0 %;
macro MCHECK0302$V_MERA_CER = 0,0,1,0 %;
macro MCHECK0302$V_MERA_UCER = 0,1,1,0 %;
macro MCHECK0302$V_MERA_MULE = 0,2,1,0 %;
macro MCHECK0302$V_MERA_APER = 0,3,1,0 %;
macro MCHECK0302$V_MERA_CERA = 0,4,1,0 %;
macro MCHECK0302$V_MERA_CERB = 0,5,1,0 %;
macro MCHECK0302$V_MERA_FSTR = 0,6,3,0 %;
literal MCHECK0302$S_MERA_FSTR = 3;
macro MCHECK0302$V_MERA_BNKER = 0,9,1,0 %;
macro MCHECK0302$V_MERA_UCERA = 0,10,1,0 %;
macro MCHECK0302$V_MERA_UCERB = 0,11,1,0 %;
literal MCHECK0302$M_MSYNDA_SYND = %X'FF';
literal MCHECK0302$S_MSYNDA = 4;
macro MCHECK0302$L_MSYNDA = 0,0,32,0 %;
macro MCHECK0302$V_MSYNDA_SYND = 0,0,8,0 %;
literal MCHECK0302$S_MSYNDA_SYND = 8;
literal MCHECK0302$M_MDRA_FCBS = %X'1';
literal MCHECK0302$M_MDRA_DRDC = %X'2';
literal MCHECK0302$M_MDRA_DWDC = %X'4';
literal MCHECK0302$M_MDRA_BPAS = %X'8';
literal MCHECK0302$M_MDRA_EXST = %X'10';
literal MCHECK0302$M_MDRA_STPM = %X'20';
literal MCHECK0302$M_MDRA_MODE = %X'40';
literal MCHECK0302$M_MDRA_IGSB = %X'80';
literal MCHECK0302$M_MDRA_FRPE = %X'100';
literal MCHECK0302$M_MDRA_FCPE = %X'200';
literal MCHECK0302$M_MDRA_DCRD = %X'8000000';
literal MCHECK0302$M_MDRA_RFR = %X'30000000';
literal MCHECK0302$M_MDRA_BRFSH = %X'40000000';
literal MCHECK0302$M_MDRA_DRFSH = %X'80000000';
literal MCHECK0302$S_MDRA = 4;
macro MCHECK0302$L_MDRA = 0,0,32,0 %;
macro MCHECK0302$V_MDRA_FCBS = 0,0,1,0 %;
macro MCHECK0302$V_MDRA_DRDC = 0,1,1,0 %;
macro MCHECK0302$V_MDRA_DWDC = 0,2,1,0 %;
macro MCHECK0302$V_MDRA_BPAS = 0,3,1,0 %;
macro MCHECK0302$V_MDRA_EXST = 0,4,1,0 %;
macro MCHECK0302$V_MDRA_STPM = 0,5,1,0 %;
macro MCHECK0302$V_MDRA_MODE = 0,6,1,0 %;
macro MCHECK0302$V_MDRA_IGSB = 0,7,1,0 %;
macro MCHECK0302$V_MDRA_FRPE = 0,8,1,0 %;
macro MCHECK0302$V_MDRA_FCPE = 0,9,1,0 %;
macro MCHECK0302$V_MDRA_DCRD = 0,27,1,0 %;
macro MCHECK0302$V_MDRA_RFR = 0,28,2,0 %;
literal MCHECK0302$S_MDRA_RFR = 2;
macro MCHECK0302$V_MDRA_BRFSH = 0,30,1,0 %;
macro MCHECK0302$V_MDRA_DRFSH = 0,31,1,0 %;
literal MCHECK0302$M_MCBSA_SCB = %X'FF';
literal MCHECK0302$S_MCBSA = 4;
macro MCHECK0302$L_MCBSA = 0,0,32,0 %;
macro MCHECK0302$V_MCBSA_SCB = 0,0,8,0 %;
literal MCHECK0302$S_MCBSA_SCB = 8;
literal MCHECK0302$M_MERB_CER = %X'1';
literal MCHECK0302$M_MERB_UCER = %X'2';
literal MCHECK0302$M_MERB_MULE = %X'4';
literal MCHECK0302$M_MERB_APER = %X'8';
literal MCHECK0302$S_MERB = 4;
macro MCHECK0302$L_MERB = 0,0,32,0 %;
macro MCHECK0302$V_MERB_CER = 0,0,1,0 %;
macro MCHECK0302$V_MERB_UCER = 0,1,1,0 %;
macro MCHECK0302$V_MERB_MULE = 0,2,1,0 %;
macro MCHECK0302$V_MERB_APER = 0,3,1,0 %;
literal MCHECK0302$M_MSYNDB_SYND = %X'FF';
literal MCHECK0302$S_MSYNDB = 4;
macro MCHECK0302$L_MSYNDB = 0,0,32,0 %;
macro MCHECK0302$V_MSYNDB_SYND = 0,0,8,0 %;
literal MCHECK0302$S_MSYNDB_SYND = 8;
literal MCHECK0302$M_MDRB_FCBS = %X'1';
literal MCHECK0302$M_MDRB_DRDC = %X'2';
literal MCHECK0302$M_MDRB_DWDC = %X'4';
literal MCHECK0302$M_MDRB_BPAS = %X'8';
literal MCHECK0302$M_MDRB_EXST = %X'10';
literal MCHECK0302$M_MDRB_STPM = %X'20';
literal MCHECK0302$M_MDRB_MODE = %X'40';
literal MCHECK0302$M_MDRB_IGSB = %X'80';
literal MCHECK0302$S_MDRB = 4;
macro MCHECK0302$L_MDRB = 0,0,32,0 %;
macro MCHECK0302$V_MDRB_FCBS = 0,0,1,0 %;
macro MCHECK0302$V_MDRB_DRDC = 0,1,1,0 %;
macro MCHECK0302$V_MDRB_DWDC = 0,2,1,0 %;
macro MCHECK0302$V_MDRB_BPAS = 0,3,1,0 %;
macro MCHECK0302$V_MDRB_EXST = 0,4,1,0 %;
macro MCHECK0302$V_MDRB_STPM = 0,5,1,0 %;
macro MCHECK0302$V_MDRB_MODE = 0,6,1,0 %;
macro MCHECK0302$V_MDRB_IGSB = 0,7,1,0 %;
literal MCHECK0302$M_MCBSB_SCB = %X'FF';
literal MCHECK0302$S_MCBSB = 4;
macro MCHECK0302$L_MCBSB = 0,0,32,0 %;
macro MCHECK0302$V_MCBSB_SCB = 0,0,8,0 %;
literal MCHECK0302$S_MCBSB_SCB = 8;
literal CPU0302$K_ecc_max_count = 32;
!  Note that %xB2D05E00 equals 5 minutes in 100 nanosecond units
literal CPU0302$K_ecc_threshold = -1294967296;
 
!*** MODULE $KA0402DEF ***
literal KA0402$M_IOSLOT_SLOT0_SG = %X'1';
literal KA0402$M_IOSLOT_SLOT0_BM = %X'2';
literal KA0402$M_IOSLOT_SLOT0_PE = %X'4';
literal KA0402$M_IOSLOT_SLOT1_SG = %X'8';
literal KA0402$M_IOSLOT_SLOT1_BM = %X'10';
literal KA0402$M_IOSLOT_SLOT1_PE = %X'20';
literal KA0402$M_IOSLOT_SLOT2_SG = %X'40';
literal KA0402$M_IOSLOT_SLOT2_BM = %X'80';
literal KA0402$M_IOSLOT_SLOT2_PE = %X'100';
literal KA0402$M_IOSLOT_SLOT3_SG = %X'200';
literal KA0402$M_IOSLOT_SLOT3_BM = %X'400';
literal KA0402$M_IOSLOT_SLOT3_PE = %X'800';
literal KA0402$M_IOSLOT_SLOT4_SG = %X'1000';
literal KA0402$M_IOSLOT_SLOT4_BM = %X'2000';
literal KA0402$M_IOSLOT_SLOT4_PE = %X'4000';
literal KA0402$M_IOSLOT_SLOT5_SG = %X'8000';
literal KA0402$M_IOSLOT_SLOT5_BM = %X'10000';
literal KA0402$M_IOSLOT_SLOT5_PE = %X'20000';
literal KA0402$M_IOSLOT_SLOT6_SG = %X'40000';
literal KA0402$M_IOSLOT_SLOT6_BM = %X'80000';
literal KA0402$M_IOSLOT_SLOT6_PE = %X'100000';
literal KA0402$M_IOSLOT_CORE_SG = %X'200000';
literal KA0402$M_IOSLOT_CORE_BM = %X'400000';
literal KA0402$M_IOSLOT_CORE_PE = %X'800000';
literal KA0402$M_IOSLOT_CXTURBO_SG = %X'1000000';
literal KA0402$M_IOSLOT_CXTURBO_BM = %X'2000000';
literal KA0402$M_IOSLOT_CXTURBO_PE = %X'4000000';
literal KA0402$M_IOSLOT_RM_BYTE0 = %X'8000000';
literal KA0402$M_IOSLOT_RM_BYTE1 = %X'10000000';
literal KA0402$M_IOSLOT_RM_BYTE2 = %X'20000000';
literal KA0402$M_IOSLOT_RM_BYTE3 = %X'40000000';
literal KA0402$M_IOSLOT_RM_VALID = %X'80000000';
literal KA0402$M_TCCONFIG_MAGIC = %X'1F';
literal KA0402$M_TCCONFIG_PAGE_SIZE = %X'100';
literal KA0402$M_TCEREG_SLOT_ID = %X'F';
literal KA0402$M_TCEREG_SG = %X'10';
literal KA0402$M_TCEREG_BM = %X'20';
literal KA0402$M_TCEREG_PE = %X'40';
literal KA0402$M_TCEREG_LOCK = %X'80';
literal KA0402$M_TCEREG_OFFSET = %X'1F00';
literal KA0402$M_TCEREG_SYNDROME = %X'7F0000';
literal KA0402$M_TCEREG_WM_BYTE0 = %X'1000000';
literal KA0402$M_TCEREG_WM_BYTE1 = %X'2000000';
literal KA0402$M_TCEREG_WM_BYTE2 = %X'4000000';
literal KA0402$M_TCEREG_WM_BYTE3 = %X'8000000';
literal KA0402$M_TCEREG_W = %X'40000000';
literal KA0402$M_TCEREG_D = %X'80000000';
literal KA0402$M_IR_TC_INT = %X'1FF';
literal KA0402$M_IR_SEO = %X'80000';
literal KA0402$M_IR_DBF = %X'100000';
literal KA0402$M_IR_X2K = %X'200000';
literal KA0402$M_IR_TCR = %X'400000';
literal KA0402$M_IR_TPE = %X'800000';
literal KA0402$M_IR_TER = %X'1000000';
literal KA0402$M_IR_SBE = %X'2000000';
literal KA0402$M_IR_DBE = %X'4000000';
literal KA0402$M_IR_TO = %X'8000000';
literal KA0402$M_IR_TL = %X'10000000';
literal KA0402$M_IR_IA = %X'20000000';
literal KA0402$M_IR_NV = %X'40000000';
literal KA0402$M_IR_PE = %X'80000000';
literal KA0402$M_IC_TC_INT = %X'1FF';
literal KA0402$M_IC_SEO = %X'80000';
literal KA0402$M_IC_DBF = %X'100000';
literal KA0402$M_IC_X2K = %X'200000';
literal KA0402$M_IC_TCR = %X'400000';
literal KA0402$M_IC_TPE = %X'800000';
literal KA0402$M_IC_TER = %X'1000000';
literal KA0402$M_IC_SBE = %X'2000000';
literal KA0402$M_IC_DBE = %X'4000000';
literal KA0402$M_IC_TO = %X'8000000';
literal KA0402$M_IC_TL = %X'10000000';
literal KA0402$M_IC_IA = %X'20000000';
literal KA0402$M_IC_NV = %X'40000000';
literal KA0402$M_IC_PE = %X'80000000';
literal KA0402$M_LDP_DMA_PA_LO = %X'FFFE0';
literal KA0402$M_LDP_DMA_PA_HI = %X'FFF00000';
literal KA0402$M_SCOMM_TR_DMA_PA = %X'FFFFFFE0';
literal KA0402$M_SCOMM_RC_DMA_PA = %X'FFFFFFE0';
literal KA0402$M_PRINTER_TR_DMA_PA = %X'FFFFFFE0';
literal KA0402$M_PRINTER_RC_DMA_PA = %X'FFFFFFE0';
literal KA0402$M_ISDN_TR_DMA_PA = %X'FFFFFFE0';
literal KA0402$M_ISDN_TR_BUF_DMA_PA = %X'FFFFFFE0';
literal KA0402$M_ISDN_RC_DMA_PA = %X'FFFFFFE0';
literal KA0402$M_ISDN_RC_BUF_DMA_PA = %X'FFFFFFE0';
literal KA0402$M_SSR_LEDS = %X'FF';
literal KA0402$M_SSR_LANCE_RESET = %X'100';
literal KA0402$M_SSR_RTC_RESET = %X'400';
literal KA0402$M_SSR_SSC_RESET = %X'800';
literal KA0402$M_SSR_ISDN_RESET = %X'1000';
literal KA0402$M_SSR_10BASET_SEL = %X'2000';
literal KA0402$M_SSR_NI_LOOPBACK = %X'4000';
literal KA0402$M_SSR_TXDIS = %X'8000';
literal KA0402$M_SSR_LANCE_DMA_EN = %X'10000';
literal KA0402$M_SSR_ISDN_RC_DMA_EN = %X'80000';
literal KA0402$M_SSR_ISDN_TR_DMA_EN = %X'100000';
literal KA0402$M_SSR_PRINTER_RC_DMA_EN = %X'10000000';
literal KA0402$M_SSR_PRINTER_TR_DMA_EN = %X'20000000';
literal KA0402$M_SSR_COMM_RC_DMA_EN = %X'40000000';
literal KA0402$M_SSR_COMM_TR_DMA_EN = %X'80000000';
literal KA0402$M_SIR_HALT0 = %X'1';
literal KA0402$M_SIR_HALT1 = %X'2';
literal KA0402$M_SIR_ALT_CONSOLE = %X'8';
literal KA0402$M_SIR_SCC0_SI = %X'40';
literal KA0402$M_SIR_SCC1_SI = %X'80';
literal KA0402$M_SIR_NI_INTR = %X'100';
literal KA0402$M_SIR_ISDN_INTR = %X'2000';
literal KA0402$M_SIR_LANCE_DMA_RE = %X'10000';
literal KA0402$M_SIR_ISDN_DMA_MRE = %X'100000';
literal KA0402$M_SIR_ISDN_DMA_RC_INTR = %X'200000';
literal KA0402$M_SIR_ISDN_DMA_TR_INTR = %X'400000';
literal KA0402$M_SIR_PP_RC_DMA_OVR = %X'1000000';
literal KA0402$M_SIR_PP_RC_HP_INTR = %X'2000000';
literal KA0402$M_SIR_PP_TR_DMA_MRE = %X'4000000';
literal KA0402$M_SIR_PP_TR_PE_INTR = %X'8000000';
literal KA0402$M_SIR_COMM_RC_DMA_OVR = %X'10000000';
literal KA0402$M_SIR_COMM_RC_HP_INTR = %X'20000000';
literal KA0402$M_SIR_COMM_TR_DMA_MRE = %X'40000000';
literal KA0402$M_SIR_COMM_TR_PE_INTR = %X'80000000';
literal KA0402$M_SIMR_HALT0 = %X'1';
literal KA0402$M_SIMR_HALT1 = %X'2';
literal KA0402$M_SIMR_ALT_CONSOLE = %X'8';
literal KA0402$M_SIMR_SCC0_SI = %X'40';
literal KA0402$M_SIMR_SCC1_SI = %X'80';
literal KA0402$M_SIMR_NI_INTR = %X'100';
literal KA0402$M_SIMR_ISDN_INTR = %X'2000';
literal KA0402$M_SIMR_LANCE_DMA_RE = %X'10000';
literal KA0402$M_SIMR_ISDN_DMA_MRE = %X'100000';
literal KA0402$M_SIMR_ISDN_DMA_RC_INTR = %X'200000';
literal KA0402$M_SIMR_ISDN_DMA_TR_INTR = %X'400000';
literal KA0402$M_SIMR_PP_RC_DMA_OVR = %X'1000000';
literal KA0402$M_SIMR_PP_RC_HP_INTR = %X'2000000';
literal KA0402$M_SIMR_PP_TR_DMA_MRE = %X'4000000';
literal KA0402$M_SIMR_PP_TR_PE_INTR = %X'8000000';
literal KA0402$M_SIMR_COMM_RC_DMA_OVR = %X'10000000';
literal KA0402$M_SIMR_COMM_RC_HP_INTR = %X'20000000';
literal KA0402$M_SIMR_COMM_TR_DMA_MRE = %X'40000000';
literal KA0402$M_SIMR_COMM_TR_PE_INTR = %X'80000000';
literal KA0402$M_SADR_TC_ADDR = %X'1FFFFE0';
literal KA0402$M_ISDN_DATA_TR_DATA = %X'FFFFFF';
literal KA0402$M_ISDN_DATA_RC_DATA = %X'FFFFFF';
literal KA0402$M_LANCE_SLOT_CS = %X'F';
literal KA0402$M_LANCE_SLOT_HW_ADDR = %X'3F0';
literal KA0402$M_SCC0_SLOT_CS = %X'F';
literal KA0402$M_SCC0_SLOT_HW_ADDR = %X'3F0';
literal KA0402$M_SCC1_SLOT_CS = %X'F';
literal KA0402$M_SCC1_SLOT_HW_ADDR = %X'3F0';
literal KA0402$S_KA0402DEF = 434176;    !  Old KA0402 size for compatibility
literal KA0402$S_KA0402 = 434176;
macro KA0402$L_IOSLOT = 0,0,32,1 %;     !  Slot mode register
macro KA0402$V_IOSLOT_SLOT0_SG = 0,0,1,0 %;
macro KA0402$V_IOSLOT_SLOT0_BM = 0,1,1,0 %;
macro KA0402$V_IOSLOT_SLOT0_PE = 0,2,1,0 %;
macro KA0402$V_IOSLOT_SLOT1_SG = 0,3,1,0 %;
macro KA0402$V_IOSLOT_SLOT1_BM = 0,4,1,0 %;
macro KA0402$V_IOSLOT_SLOT1_PE = 0,5,1,0 %;
macro KA0402$V_IOSLOT_SLOT2_SG = 0,6,1,0 %;
macro KA0402$V_IOSLOT_SLOT2_BM = 0,7,1,0 %;
macro KA0402$V_IOSLOT_SLOT2_PE = 0,8,1,0 %;
macro KA0402$V_IOSLOT_SLOT3_SG = 0,9,1,0 %;
macro KA0402$V_IOSLOT_SLOT3_BM = 0,10,1,0 %;
macro KA0402$V_IOSLOT_SLOT3_PE = 0,11,1,0 %;
macro KA0402$V_IOSLOT_SLOT4_SG = 0,12,1,0 %;
macro KA0402$V_IOSLOT_SLOT4_BM = 0,13,1,0 %;
macro KA0402$V_IOSLOT_SLOT4_PE = 0,14,1,0 %;
macro KA0402$V_IOSLOT_SLOT5_SG = 0,15,1,0 %;
macro KA0402$V_IOSLOT_SLOT5_BM = 0,16,1,0 %;
macro KA0402$V_IOSLOT_SLOT5_PE = 0,17,1,0 %;
macro KA0402$V_IOSLOT_SLOT6_SG = 0,18,1,0 %;
macro KA0402$V_IOSLOT_SLOT6_BM = 0,19,1,0 %;
macro KA0402$V_IOSLOT_SLOT6_PE = 0,20,1,0 %;
macro KA0402$V_IOSLOT_CORE_SG = 0,21,1,0 %;
macro KA0402$V_IOSLOT_CORE_BM = 0,22,1,0 %;
macro KA0402$V_IOSLOT_CORE_PE = 0,23,1,0 %;
macro KA0402$V_IOSLOT_CXTURBO_SG = 0,24,1,0 %;
macro KA0402$V_IOSLOT_CXTURBO_BM = 0,25,1,0 %;
macro KA0402$V_IOSLOT_CXTURBO_PE = 0,26,1,0 %;
macro KA0402$V_IOSLOT_RM_BYTE0 = 0,27,1,0 %;
macro KA0402$V_IOSLOT_RM_BYTE1 = 0,28,1,0 %;
macro KA0402$V_IOSLOT_RM_BYTE2 = 0,29,1,0 %;
macro KA0402$V_IOSLOT_RM_BYTE3 = 0,30,1,0 %;
macro KA0402$V_IOSLOT_RM_VALID = 0,31,1,0 %;
macro KA0402$L_TCCONFIG = 16,0,32,1 %;  !  TC Configuration register
macro KA0402$V_TCCONFIG_MAGIC = 16,0,5,0 %;
literal KA0402$S_TCCONFIG_MAGIC = 5;
macro KA0402$V_TCCONFIG_PAGE_SIZE = 16,8,1,0 %;
macro KA0402$L_FADR = 32,0,32,1 %;      !  Failing Address register
macro KA0402$L_TCEREG = 48,0,32,1 %;    !  Error register
macro KA0402$V_TCEREG_SLOT_ID = 48,0,4,0 %;
literal KA0402$S_TCEREG_SLOT_ID = 4;
macro KA0402$V_TCEREG_SG = 48,4,1,0 %;
macro KA0402$V_TCEREG_BM = 48,5,1,0 %;
macro KA0402$V_TCEREG_PE = 48,6,1,0 %;
macro KA0402$V_TCEREG_LOCK = 48,7,1,0 %;
macro KA0402$V_TCEREG_OFFSET = 48,8,5,0 %;
literal KA0402$S_TCEREG_OFFSET = 5;
macro KA0402$V_TCEREG_SYNDROME = 48,16,7,0 %;
literal KA0402$S_TCEREG_SYNDROME = 7;
macro KA0402$V_TCEREG_WM_BYTE0 = 48,24,1,0 %;
macro KA0402$V_TCEREG_WM_BYTE1 = 48,25,1,0 %;
macro KA0402$V_TCEREG_WM_BYTE2 = 48,26,1,0 %;
macro KA0402$V_TCEREG_WM_BYTE3 = 48,27,1,0 %;
macro KA0402$V_TCEREG_W = 48,30,1,0 %;
macro KA0402$V_TCEREG_D = 48,31,1,0 %;
macro KA0402$L_MCR0 = 8192,0,32,1 %;    !  Memory configuration 0
macro KA0402$L_MCR1 = 16384,0,32,1 %;   !  Memory configuration 1
macro KA0402$L_MCR2 = 24576,0,32,1 %;   !  Memory configuration 2
macro KA0402$L_MCR3 = 32768,0,32,1 %;   !  Memory configuration 3
macro KA0402$L_MCR4 = 40960,0,32,1 %;   !  Memory configuration 4
macro KA0402$L_MCR5 = 49152,0,32,1 %;   !  Memory configuration 5
macro KA0402$L_MCR6 = 57344,0,32,1 %;   !  Memory configuration 6
macro KA0402$L_MCR7 = 65536,0,32,1 %;   !  Memory configuration 7
macro KA0402$L_IR = 73728,0,32,1 %;     !  Interrupt register
macro KA0402$V_IR_TC_INT = 73728,0,9,0 %;
literal KA0402$S_IR_TC_INT = 9;
macro KA0402$V_IR_SEO = 73728,19,1,0 %;
macro KA0402$V_IR_DBF = 73728,20,1,0 %;
macro KA0402$V_IR_X2K = 73728,21,1,0 %;
macro KA0402$V_IR_TCR = 73728,22,1,0 %;
macro KA0402$V_IR_TPE = 73728,23,1,0 %;
macro KA0402$V_IR_TER = 73728,24,1,0 %;
macro KA0402$V_IR_SBE = 73728,25,1,0 %;
macro KA0402$V_IR_DBE = 73728,26,1,0 %;
macro KA0402$V_IR_TO = 73728,27,1,0 %;
macro KA0402$V_IR_TL = 73728,28,1,0 %;
macro KA0402$V_IR_IA = 73728,29,1,0 %;
macro KA0402$V_IR_NV = 73728,30,1,0 %;
macro KA0402$V_IR_PE = 73728,31,1,0 %;
macro KA0402$L_IC = 81920,0,32,1 %;     !  Interrupt Cause register
macro KA0402$V_IC_TC_INT = 81920,0,9,0 %;
literal KA0402$S_IC_TC_INT = 9;
macro KA0402$V_IC_SEO = 81920,19,1,0 %;
macro KA0402$V_IC_DBF = 81920,20,1,0 %;
macro KA0402$V_IC_X2K = 81920,21,1,0 %;
macro KA0402$V_IC_TCR = 81920,22,1,0 %;
macro KA0402$V_IC_TPE = 81920,23,1,0 %;
macro KA0402$V_IC_TER = 81920,24,1,0 %;
macro KA0402$V_IC_SBE = 81920,25,1,0 %;
macro KA0402$V_IC_DBE = 81920,26,1,0 %;
macro KA0402$V_IC_TO = 81920,27,1,0 %;
macro KA0402$V_IC_TL = 81920,28,1,0 %;
macro KA0402$V_IC_IA = 81920,29,1,0 %;
macro KA0402$V_IC_NV = 81920,30,1,0 %;
macro KA0402$V_IC_PE = 81920,31,1,0 %;
macro KA0402$L_SG_MAP = 90112,0,32,1 %; !  Scatter/gather map (32 pages)
macro KA0402$L_TCRESET = 352256,0,32,1 %; !  TC reset register
macro KA0402$L_IOCTL_CSR = 360448,0,32,1 %; !  Core I/O base CSR address
macro KA0402$L_LDP = 360512,0,32,1 %;   !  Ethernet Lance DMA pointer
macro KA0402$V_LDP_DMA_PA_LO = 360512,5,15,0 %;
literal KA0402$S_LDP_DMA_PA_LO = 15;
macro KA0402$V_LDP_DMA_PA_HI = 360512,20,12,0 %;
literal KA0402$S_LDP_DMA_PA_HI = 12;
macro KA0402$L_SCOMM_TR = 360544,0,32,1 %; !  Serial comm transmit port 1 DMA pointer
macro KA0402$V_SCOMM_TR_DMA_PA = 360544,5,27,0 %;
literal KA0402$S_SCOMM_TR_DMA_PA = 27;
macro KA0402$L_SCOMM_RC = 360576,0,32,1 %; !  Serial comm receive port 1 DMA pointer
macro KA0402$V_SCOMM_RC_DMA_PA = 360576,5,27,0 %;
literal KA0402$S_SCOMM_RC_DMA_PA = 27;
macro KA0402$L_PRINTER_TR = 360608,0,32,1 %; !  Printer transmit port DMA pointer
macro KA0402$V_PRINTER_TR_DMA_PA = 360608,5,27,0 %;
literal KA0402$S_PRINTER_TR_DMA_PA = 27;
macro KA0402$L_PRINTER_RC = 360640,0,32,1 %; !  Printer receive port DMA pointer
macro KA0402$V_PRINTER_RC_DMA_PA = 360640,5,27,0 %;
literal KA0402$S_PRINTER_RC_DMA_PA = 27;
macro KA0402$L_ISDN_TR = 360704,0,32,1 %; !  ISDN transmit DMA pointer
macro KA0402$V_ISDN_TR_DMA_PA = 360704,5,27,0 %;
literal KA0402$S_ISDN_TR_DMA_PA = 27;
macro KA0402$L_ISDN_TR_BUF = 360736,0,32,1 %; !  ISDN transmit DMA buffer pointer
macro KA0402$V_ISDN_TR_BUF_DMA_PA = 360736,5,27,0 %;
literal KA0402$S_ISDN_TR_BUF_DMA_PA = 27;
macro KA0402$L_ISDN_RC = 360768,0,32,1 %; !  ISDN receive DMA pointer 
macro KA0402$V_ISDN_RC_DMA_PA = 360768,5,27,0 %;
literal KA0402$S_ISDN_RC_DMA_PA = 27;
macro KA0402$L_ISDN_RC_BUF = 360800,0,32,1 %; !  ISDN receive DMA buffer pointer 
macro KA0402$V_ISDN_RC_BUF_DMA_PA = 360800,5,27,0 %;
literal KA0402$S_ISDN_RC_BUF_DMA_PA = 27;
macro KA0402$L_DATA0 = 360832,0,32,1 %; !  System Data Buffer 0
macro KA0402$L_DATA1 = 360864,0,32,1 %; !  System Data Buffer 1
macro KA0402$L_DATA2 = 360896,0,32,1 %; !  System Data Buffer 2
macro KA0402$L_DATA3 = 360928,0,32,1 %; !  System Data Buffer 3
macro KA0402$L_SSR = 360960,0,32,1 %;   !  System support register
macro KA0402$V_SSR_LEDS = 360960,0,8,0 %;
literal KA0402$S_SSR_LEDS = 8;
macro KA0402$V_SSR_LANCE_RESET = 360960,8,1,0 %;
macro KA0402$V_SSR_RTC_RESET = 360960,10,1,0 %;
macro KA0402$V_SSR_SSC_RESET = 360960,11,1,0 %;
macro KA0402$V_SSR_ISDN_RESET = 360960,12,1,0 %;
macro KA0402$V_SSR_10BASET_SEL = 360960,13,1,0 %;
macro KA0402$V_SSR_NI_LOOPBACK = 360960,14,1,0 %;
macro KA0402$V_SSR_TXDIS = 360960,15,1,0 %;
macro KA0402$V_SSR_LANCE_DMA_EN = 360960,16,1,0 %;
macro KA0402$V_SSR_ISDN_RC_DMA_EN = 360960,19,1,0 %;
macro KA0402$V_SSR_ISDN_TR_DMA_EN = 360960,20,1,0 %;
macro KA0402$V_SSR_PRINTER_RC_DMA_EN = 360960,28,1,0 %;
macro KA0402$V_SSR_PRINTER_TR_DMA_EN = 360960,29,1,0 %;
macro KA0402$V_SSR_COMM_RC_DMA_EN = 360960,30,1,0 %;
macro KA0402$V_SSR_COMM_TR_DMA_EN = 360960,31,1,0 %;
macro KA0402$L_SIR = 360992,0,32,1 %;   !  System interrupt register
macro KA0402$V_SIR_HALT0 = 360992,0,1,0 %;
macro KA0402$V_SIR_HALT1 = 360992,1,1,0 %;
macro KA0402$V_SIR_ALT_CONSOLE = 360992,3,1,0 %;
macro KA0402$V_SIR_SCC0_SI = 360992,6,1,0 %;
macro KA0402$V_SIR_SCC1_SI = 360992,7,1,0 %;
macro KA0402$V_SIR_NI_INTR = 360992,8,1,0 %;
macro KA0402$V_SIR_ISDN_INTR = 360992,13,1,0 %;
macro KA0402$V_SIR_LANCE_DMA_RE = 360992,16,1,0 %;
macro KA0402$V_SIR_ISDN_DMA_MRE = 360992,20,1,0 %;
macro KA0402$V_SIR_ISDN_DMA_RC_INTR = 360992,21,1,0 %;
macro KA0402$V_SIR_ISDN_DMA_TR_INTR = 360992,22,1,0 %;
macro KA0402$V_SIR_PP_RC_DMA_OVR = 360992,24,1,0 %;
macro KA0402$V_SIR_PP_RC_HP_INTR = 360992,25,1,0 %;
macro KA0402$V_SIR_PP_TR_DMA_MRE = 360992,26,1,0 %;
macro KA0402$V_SIR_PP_TR_PE_INTR = 360992,27,1,0 %;
macro KA0402$V_SIR_COMM_RC_DMA_OVR = 360992,28,1,0 %;
macro KA0402$V_SIR_COMM_RC_HP_INTR = 360992,29,1,0 %;
macro KA0402$V_SIR_COMM_TR_DMA_MRE = 360992,30,1,0 %;
macro KA0402$V_SIR_COMM_TR_PE_INTR = 360992,31,1,0 %;
macro KA0402$L_SIMR = 361024,0,32,1 %;  !  System interrupt mask register
macro KA0402$V_SIMR_HALT0 = 361024,0,1,0 %;
macro KA0402$V_SIMR_HALT1 = 361024,1,1,0 %;
macro KA0402$V_SIMR_ALT_CONSOLE = 361024,3,1,0 %;
macro KA0402$V_SIMR_SCC0_SI = 361024,6,1,0 %;
macro KA0402$V_SIMR_SCC1_SI = 361024,7,1,0 %;
macro KA0402$V_SIMR_NI_INTR = 361024,8,1,0 %;
macro KA0402$V_SIMR_ISDN_INTR = 361024,13,1,0 %;
macro KA0402$V_SIMR_LANCE_DMA_RE = 361024,16,1,0 %;
macro KA0402$V_SIMR_ISDN_DMA_MRE = 361024,20,1,0 %;
macro KA0402$V_SIMR_ISDN_DMA_RC_INTR = 361024,21,1,0 %;
macro KA0402$V_SIMR_ISDN_DMA_TR_INTR = 361024,22,1,0 %;
macro KA0402$V_SIMR_PP_RC_DMA_OVR = 361024,24,1,0 %;
macro KA0402$V_SIMR_PP_RC_HP_INTR = 361024,25,1,0 %;
macro KA0402$V_SIMR_PP_TR_DMA_MRE = 361024,26,1,0 %;
macro KA0402$V_SIMR_PP_TR_PE_INTR = 361024,27,1,0 %;
macro KA0402$V_SIMR_COMM_RC_DMA_OVR = 361024,28,1,0 %;
macro KA0402$V_SIMR_COMM_RC_HP_INTR = 361024,29,1,0 %;
macro KA0402$V_SIMR_COMM_TR_DMA_MRE = 361024,30,1,0 %;
macro KA0402$V_SIMR_COMM_TR_PE_INTR = 361024,31,1,0 %;
macro KA0402$L_SADR = 361056,0,32,1 %;  !  System address register
macro KA0402$V_SADR_TC_ADDR = 361056,5,20,0 %;
literal KA0402$S_SADR_TC_ADDR = 20;
macro KA0402$L_ISDN_DATA_TR = 361088,0,32,1 %; !  ISDN Data Transmit
macro KA0402$V_ISDN_DATA_TR_DATA = 361088,0,24,0 %;
literal KA0402$S_ISDN_DATA_TR_DATA = 24;
macro KA0402$L_ISDN_DATA_RC = 361120,0,32,1 %; !  ISDN Data Receive
macro KA0402$V_ISDN_DATA_RC_DATA = 361120,0,24,0 %;
literal KA0402$S_ISDN_DATA_RC_DATA = 24;
macro KA0402$L_LANCE_SLOT = 361152,0,32,1 %; !  Lance slot register
macro KA0402$V_LANCE_SLOT_CS = 361152,0,4,0 %;
literal KA0402$S_LANCE_SLOT_CS = 4;
macro KA0402$V_LANCE_SLOT_HW_ADDR = 361152,4,6,0 %;
literal KA0402$S_LANCE_SLOT_HW_ADDR = 6;
macro KA0402$L_SCC0_SLOT = 361216,0,32,1 %; !  SCC0 slot register
macro KA0402$V_SCC0_SLOT_CS = 361216,0,4,0 %;
literal KA0402$S_SCC0_SLOT_CS = 4;
macro KA0402$V_SCC0_SLOT_HW_ADDR = 361216,4,6,0 %;
literal KA0402$S_SCC0_SLOT_HW_ADDR = 6;
macro KA0402$L_SCC1_SLOT = 361248,0,32,1 %; !  SCC1 slot register
macro KA0402$V_SCC1_SLOT_CS = 361248,0,4,0 %;
literal KA0402$S_SCC1_SLOT_CS = 4;
macro KA0402$V_SCC1_SLOT_HW_ADDR = 361248,4,6,0 %;
literal KA0402$S_SCC1_SLOT_HW_ADDR = 6;
macro KA0402$L_NI_ADR_ROM = 368640,0,32,1 %; !  Ethernet address ROM
macro KA0402$L_LANCE_RDP = 376832,0,32,1 %; !  Lance ethernet CSR
macro KA0402$L_LANCE_RAP = 376840,0,32,1 %; !  Lance ethernet CSR
macro KA0402$L_SCC0B_COMM_RAP = 385024,0,32,1 %; !  Comm Port 1 RAP
macro KA0402$L_SCC0B_COMM_DATA = 385032,0,32,1 %; !  Comm Port 1 data
macro KA0402$L_SCC0A_MOUSE_RAP = 385040,0,32,1 %; !  Mouse RAP
macro KA0402$L_SCC0A_MOUSE_DATA = 385048,0,32,1 %; !  Mouse port data register
macro KA0402$L_SCC1B_PRINT_RAP = 393216,0,32,1 %; !  Printer Port 2 RAP
macro KA0402$L_SCC1B_PRINT_DATA = 393224,0,32,1 %; !  Printer Port 2 data
macro KA0402$L_SCC1A_KEY_RAP = 393232,0,32,1 %; !  Keyboard RAP
macro KA0402$L_SCC1A_KEY_DATA = 393240,0,32,1 %; !  Keyboard port data register
macro KA0402$L_RTC_SEC = 401408,0,32,1 %; !  TOY clock CSR--seconds
macro KA0402$L_RTC_ALMS = 401416,0,32,1 %; !  TOY clock CSR--seconds alarm
macro KA0402$L_RTC_MIN = 401424,0,32,1 %; !  TOY clock CSR--minutes
macro KA0402$L_RTC_ALMN = 401432,0,32,1 %; !  TOY clock CSR--minutes alarm
macro KA0402$L_RTC_HOUR = 401440,0,32,1 %; !  TOY clock CSR--hours
macro KA0402$L_RTC_ALMH = 401448,0,32,1 %; !  TOY clock CSR--hours alarm
macro KA0402$L_RTC_DOW = 401456,0,32,1 %; !  TOY clock CSR--day of week
macro KA0402$L_RTC_DAY = 401464,0,32,1 %; !  TOY clock CSR--date of month
macro KA0402$L_RTC_MON = 401472,0,32,1 %; !  TOY clock CSR--month
macro KA0402$L_RTC_YEAR = 401480,0,32,1 %; !  TOY clock CSR--year
macro KA0402$L_RTC_REGA = 401488,0,32,1 %; !  TOY clock CSR--register A 
macro KA0402$L_RTC_REGB = 401496,0,32,1 %; !  TOY clock CSR--register B 
macro KA0402$L_RTC_REGC = 401504,0,32,1 %; !  TOY clock CSR--register C 
macro KA0402$L_RTC_REGD = 401512,0,32,1 %; !  TOY clock CSR--register D 
macro KA0402$L_RTC_RAM = 401520,0,32,1 %; !  TOY clock CSR--base of BBU RAM
macro KA0402$L_SCSI_HOST_ID = 401784,0,32,0 %; !  SCSI Host id for use by PKCDRIVER.
macro KA0402$L_ISDN_AUDIO = 409600,0,32,1 %; !  ISDN audio chip CSR
macro KA0402$L_IMASK_READ = 417792,0,32,0 %; !  Interrupt mask, read
macro KA0402$L_IMASK_WRITE = 434172,0,32,0 %; !  Interrupt mask, write
literal KA0402$M_SG_MAP_PPN = %X'1FFFFF';
literal KA0402$M_SG_MAP_P = %X'200000';
literal KA0402$M_SG_MAP_F = %X'400000';
literal KA0402$M_SG_MAP_V = %X'800000';
literal KA0402$S_SG_MAP_ENTRY_BITS = 3;
macro KA0402$V_SG_MAP_PPN = 0,0,21,0 %;
literal KA0402$S_SG_MAP_PPN = 21;
macro KA0402$V_SG_MAP_P = 0,21,1,0 %;
macro KA0402$V_SG_MAP_F = 0,22,1,0 %;
macro KA0402$V_SG_MAP_V = 0,23,1,0 %;
literal KA0402$M_SG_MAP_VA_LW_IN_PAGE = %X'1FFF';
literal KA0402$M_SG_MAP_VA_PAGE = %X'FFFE000';
literal KA0402$S_SG_MAP_VA_BITS = 4;
macro KA0402$V_SG_MAP_VA_LW_IN_PAGE = 0,0,13,0 %;
literal KA0402$S_SG_MAP_VA_LW_IN_PAGE = 13;
macro KA0402$V_SG_MAP_VA_PAGE = 0,13,15,0 %;
literal KA0402$S_SG_MAP_VA_PAGE = 15;
literal KA0402$K_IO_SCB_VEC = 2048;
literal KA0402$K_CORE_IO_TC_SLOT = 7;
literal KA0402$K_CXTURBO_TC_SLOT = 8;
literal KA0402$K_TC_SLOT0_VEC = 0;
literal KA0402$K_TC_SLOT1_VEC = 1;
literal KA0402$K_TC_SLOT2_VEC = 2;
literal KA0402$K_TC_SLOT3_VEC = 3;
literal KA0402$K_TC_SLOT4_VEC = 4;
literal KA0402$K_TC_SLOT5_VEC = 5;
literal KA0402$K_TC_SLOT6_VEC = 6;
literal KA0402$K_ETHERNET_VEC = 7;
literal KA0402$K_ISDN_VEC = 8;
literal KA0402$K_CXTURBO_VEC = 9;
literal KA0402$K_SCC_VEC = 10;
literal KA0402$K_OPDRVR_XMIT = 11;
literal KA0402$K_OPDRVR_RCV = 12;
literal KA0402$K_TOTAL_VECTORS = 13;
literal KA0402$M_MASK0 = %X'1';
literal KA0402$M_MASK1 = %X'2';
literal KA0402$M_MASK2 = %X'4';
literal KA0402$M_MASK3 = %X'8';
literal KA0402$S_BYTE_MASK_BITS = 1;
macro KA0402$V_MASK0 = 0,0,1,0 %;
macro KA0402$V_MASK1 = 0,1,1,0 %;
macro KA0402$V_MASK2 = 0,2,1,0 %;
macro KA0402$V_MASK3 = 0,3,1,0 %;
!  The following definition defines an entry of a Saved Error Register Table.
!  This table is pointed to by a cell in the Turbo ADP.  The table is divided up 
!  into an entry for each slot.  Each entry contains saved copies of IR, TCEREG, 
!  and FADR.  The entries are written by the machine check handler on an error, and
!  read by a driver (at some appropriate time) to determine if a TC error
!  occurred.
!  Define Saved Register Table Entry
literal KA0402$M_SAVED_IR_TC_INT = %X'1FF';
literal KA0402$M_SAVED_IR_SEO = %X'80000';
literal KA0402$M_SAVED_IR_DBF = %X'100000';
literal KA0402$M_SAVED_IR_X2K = %X'200000';
literal KA0402$M_SAVED_IR_TCR = %X'400000';
literal KA0402$M_SAVED_IR_TPE = %X'800000';
literal KA0402$M_SAVED_IR_TER = %X'1000000';
literal KA0402$M_SAVED_IR_SBE = %X'2000000';
literal KA0402$M_SAVED_IR_DBE = %X'4000000';
literal KA0402$M_SAVED_IR_TO = %X'8000000';
literal KA0402$M_SAVED_IR_TL = %X'10000000';
literal KA0402$M_SAVED_IR_IA = %X'20000000';
literal KA0402$M_SAVED_IR_NV = %X'40000000';
literal KA0402$M_SAVED_IR_PE = %X'80000000';
literal KA0402$M_SAVED_TCEREG_SLOT_ID = %X'F';
literal KA0402$M_SAVED_TCEREG_SG = %X'10';
literal KA0402$M_SAVED_TCEREG_BM = %X'20';
literal KA0402$M_SAVED_TCEREG_PE = %X'40';
literal KA0402$M_SAVED_TCEREG_LOCK = %X'80';
literal KA0402$M_SAVED_TCEREG_OFFSET = %X'1F00';
literal KA0402$M_SAVED_TCEREG_SYNDROME = %X'7F0000';
literal KA0402$M_SAVED_TCEREG_WM_BYTE0 = %X'1000000';
literal KA0402$M_SAVED_TCEREG_WM_BYTE1 = %X'2000000';
literal KA0402$M_SAVED_TCEREG_WM_BYTE2 = %X'4000000';
literal KA0402$M_SAVED_TCEREG_WM_BYTE3 = %X'8000000';
literal KA0402$M_SAVED_TCEREG_W = %X'40000000';
literal KA0402$M_SAVED_TCEREG_D = %X'80000000';
literal KA0402$K_SAVED_REG_ENTRY_SIZE = 16;
literal KA0402$S_SAVED_REG_ENTRY = 16;
macro KA0402$L_SAVED_IR = 0,0,32,0 %;   !  Interrupt reason
macro KA0402$V_SAVED_IR_TC_INT = 0,0,9,0 %;
literal KA0402$S_SAVED_IR_TC_INT = 9;
macro KA0402$V_SAVED_IR_SEO = 0,19,1,0 %;
macro KA0402$V_SAVED_IR_DBF = 0,20,1,0 %;
macro KA0402$V_SAVED_IR_X2K = 0,21,1,0 %;
macro KA0402$V_SAVED_IR_TCR = 0,22,1,0 %;
macro KA0402$V_SAVED_IR_TPE = 0,23,1,0 %;
macro KA0402$V_SAVED_IR_TER = 0,24,1,0 %;
macro KA0402$V_SAVED_IR_SBE = 0,25,1,0 %;
macro KA0402$V_SAVED_IR_DBE = 0,26,1,0 %;
macro KA0402$V_SAVED_IR_TO = 0,27,1,0 %;
macro KA0402$V_SAVED_IR_TL = 0,28,1,0 %;
macro KA0402$V_SAVED_IR_IA = 0,29,1,0 %;
macro KA0402$V_SAVED_IR_NV = 0,30,1,0 %;
macro KA0402$V_SAVED_IR_PE = 0,31,1,0 %;
macro KA0402$L_SAVED_TCEREG = 4,0,32,0 %; !  Error register
macro KA0402$V_SAVED_TCEREG_SLOT_ID = 4,0,4,0 %;
literal KA0402$S_SAVED_TCEREG_SLOT_ID = 4;
macro KA0402$V_SAVED_TCEREG_SG = 4,4,1,0 %;
macro KA0402$V_SAVED_TCEREG_BM = 4,5,1,0 %;
macro KA0402$V_SAVED_TCEREG_PE = 4,6,1,0 %;
macro KA0402$V_SAVED_TCEREG_LOCK = 4,7,1,0 %;
macro KA0402$V_SAVED_TCEREG_OFFSET = 4,8,5,0 %;
literal KA0402$S_SAVED_TCEREG_OFFSET = 5;
macro KA0402$V_SAVED_TCEREG_SYNDROME = 4,16,7,0 %;
literal KA0402$S_SAVED_TCEREG_SYNDROME = 7;
macro KA0402$V_SAVED_TCEREG_WM_BYTE0 = 4,24,1,0 %;
macro KA0402$V_SAVED_TCEREG_WM_BYTE1 = 4,25,1,0 %;
macro KA0402$V_SAVED_TCEREG_WM_BYTE2 = 4,26,1,0 %;
macro KA0402$V_SAVED_TCEREG_WM_BYTE3 = 4,27,1,0 %;
macro KA0402$V_SAVED_TCEREG_W = 4,30,1,0 %;
macro KA0402$V_SAVED_TCEREG_D = 4,31,1,0 %;
macro KA0402$L_SAVED_FADR = 8,0,32,1 %; !  Failing Address
!  Define indexes into error table.  Indexes are 0 thru 10.
!  The count of the number of entries is 11.
literal KA0402$K_SLOT0_INDEX = 0;
literal KA0402$K_SLOT1_INDEX = 1;
literal KA0402$K_SLOT2_INDEX = 2;
literal KA0402$K_SLOT3_INDEX = 3;
literal KA0402$K_SLOT4_INDEX = 4;
literal KA0402$K_SLOT5_INDEX = 5;
literal KA0402$K_SCSI_INDEX = 6;
literal KA0402$K_CORE_NI_INDEX = 7;
literal KA0402$K_CORE_SLU_INDEX = 8;
literal KA0402$K_CORE_ISDN_INDEX = 9;
literal KA0402$K_CXTURBO_INDEX = 10;
literal KA0402$K_SAVED_REG_ENTRY_COUNT = 11;
 
!*** MODULE $KA0602DEF ***
literal KA0602$M_COMBO_TOY_RTCA_RS0 = %X'1';
literal KA0602$M_COMBO_TOY_RTCA_RS1 = %X'2';
literal KA0602$M_COMBO_TOY_RTCA_RS2 = %X'4';
literal KA0602$M_COMBO_TOY_RTCA_RS3 = %X'8';
literal KA0602$M_COMBO_TOY_RTCA_DV0 = %X'10';
literal KA0602$M_COMBO_TOY_RTCA_DV1 = %X'20';
literal KA0602$M_COMBO_TOY_RTCA_DV2 = %X'40';
literal KA0602$M_COMBO_TOY_RTCA_UIP = %X'80';
literal KA0602$M_COMBO_TOY_RTCB_DSE = %X'1';
literal KA0602$M_COMBO_TOY_RTCB_2412 = %X'2';
literal KA0602$M_COMBO_TOY_RTCB_DM = %X'4';
literal KA0602$M_COMBO_TOY_RTCB_UIE = %X'10';
literal KA0602$M_COMBO_TOY_RTCB_AIE = %X'20';
literal KA0602$M_COMBO_TOY_RTCB_PIE = %X'40';
literal KA0602$M_COMBO_TOY_RTCB_SET = %X'80';
literal KA0602$M_COMBO_TOY_RTCC_UF = %X'10';
literal KA0602$M_COMBO_TOY_RTCC_AF = %X'20';
literal KA0602$M_COMBO_TOY_RTCC_PF = %X'40';
literal KA0602$M_COMBO_TOY_RTCC_IRQF = %X'80';
literal KA0602$M_COMBO_TOY_RTCD_VRT = %X'80';
literal KA0602$M_HAE_EISA_ADDR = %X'7F';
literal KA0602$M_SYSCTL_LEDS = %X'F';
literal KA0602$M_SYSCTL_IOR = %X'10';
literal KA0602$M_SYSCTL_ERRENB = %X'20';
literal KA0602$M_SYSCTL_MCNFG = %X'C0';
literal KA0602$M_INT1_OCW2_IRQ = %X'7';
literal KA0602$M_INT1_OCW2_SEL = %X'18';
literal KA0602$M_INT1_OCW2_EOI = %X'20';
literal KA0602$M_INT1_OCW2_SL = %X'40';
literal KA0602$M_INT1_OCW2_ROT = %X'80';
literal KA0602$M_INT1_OCW3_RIS = %X'1';
literal KA0602$M_INT1_OCW3_RR = %X'2';
literal KA0602$M_INT1_OCW3_P = %X'4';
literal KA0602$M_INT1_OCW3_SEL = %X'18';
literal KA0602$M_INT1_OCW3_SMM = %X'20';
literal KA0602$M_INT1_OCW3_ESMM = %X'40';
literal KA0602$M_INT1_OCW1_M0 = %X'1';
literal KA0602$M_INT1_OCW1_M1 = %X'2';
literal KA0602$M_INT1_OCW1_M2 = %X'4';
literal KA0602$M_INT1_OCW1_M3 = %X'8';
literal KA0602$M_INT1_OCW1_M4 = %X'10';
literal KA0602$M_INT1_OCW1_M5 = %X'20';
literal KA0602$M_INT1_OCW1_M6 = %X'40';
literal KA0602$M_INT1_OCW1_M7 = %X'80';
literal KA0602$M_INT2_OCW2_IRQ = %X'7';
literal KA0602$M_INT2_OCW2_SEL = %X'18';
literal KA0602$M_INT2_OCW2_EOI = %X'20';
literal KA0602$M_INT2_OCW2_SL = %X'40';
literal KA0602$M_INT2_OCW2_ROT = %X'80';
literal KA0602$M_INT2_OCW3_RIS = %X'1';
literal KA0602$M_INT2_OCW3_RR = %X'2';
literal KA0602$M_INT2_OCW3_P = %X'4';
literal KA0602$M_INT2_OCW3_SEL = %X'18';
literal KA0602$M_INT2_OCW3_SMM = %X'20';
literal KA0602$M_INT2_OCW3_ESMM = %X'40';
literal KA0602$M_INT2_OCW1_M0 = %X'1';
literal KA0602$M_INT2_OCW1_M1 = %X'2';
literal KA0602$M_INT2_OCW1_M2 = %X'4';
literal KA0602$M_INT2_OCW1_M3 = %X'8';
literal KA0602$M_INT2_OCW1_M4 = %X'10';
literal KA0602$M_INT2_OCW1_M5 = %X'20';
literal KA0602$M_INT2_OCW1_M6 = %X'40';
literal KA0602$M_INT2_OCW1_M7 = %X'80';
literal KA0602$S_KA0602DEF = 548865;    !  Old size name, synonym for KA0602$S_KA0602
literal KA0602$S_KA0602 = 548865;
macro KA0602$L_PORT_INDEX = 0,0,32,0 %;
macro KA0602$b_fill0001 = 4,0,0,1 %;
literal KA0602$s_fill0001 = 508;
macro KA0602$L_PORT_DATA = 512,0,32,0 %;
macro KA0602$b_fill0002 = 516,0,0,1 %;
literal KA0602$s_fill0002 = 508;
macro KA0602$L_COMBO_TOY_MINS = 1024,0,32,0 %;
macro KA0602$b_fill0003 = 1028,0,0,1 %;
literal KA0602$s_fill0003 = 508;
macro KA0602$L_COMBO_TOY_AMINS = 1536,0,32,0 %;
macro KA0602$b_fill0004 = 1540,0,0,1 %;
literal KA0602$s_fill0004 = 508;
macro KA0602$L_COMBO_TOY_HRS = 2048,0,32,0 %;
macro KA0602$b_fill0005 = 2052,0,0,1 %;
literal KA0602$s_fill0005 = 508;
macro KA0602$L_COMBO_TOY_AHRS = 2560,0,32,0 %;
macro KA0602$b_fill0006 = 2564,0,0,1 %;
literal KA0602$s_fill0006 = 508;
macro KA0602$L_COMBO_TOY_DAY = 3072,0,32,0 %;
macro KA0602$b_fill0007 = 3076,0,0,1 %;
literal KA0602$s_fill0007 = 508;
macro KA0602$L_COMBO_TOY_MNTH = 3584,0,32,0 %;
macro KA0602$b_fill0008 = 3588,0,0,1 %;
literal KA0602$s_fill0008 = 508;
macro KA0602$L_COMBO_TOY_YEAR = 4096,0,32,0 %;
macro KA0602$b_fill0009 = 4100,0,0,1 %;
literal KA0602$s_fill0009 = 508;
macro KA0602$L_COMBO_TOY_RTCA = 4608,0,32,0 %;
macro KA0602$V_COMBO_TOY_RTCA_RS0 = 4608,0,1,0 %;
macro KA0602$V_COMBO_TOY_RTCA_RS1 = 4608,1,1,0 %;
macro KA0602$V_COMBO_TOY_RTCA_RS2 = 4608,2,1,0 %;
macro KA0602$V_COMBO_TOY_RTCA_RS3 = 4608,3,1,0 %;
macro KA0602$V_COMBO_TOY_RTCA_DV0 = 4608,4,1,0 %;
macro KA0602$V_COMBO_TOY_RTCA_DV1 = 4608,5,1,0 %;
macro KA0602$V_COMBO_TOY_RTCA_DV2 = 4608,6,1,0 %;
macro KA0602$V_COMBO_TOY_RTCA_UIP = 4608,7,1,0 %;
macro KA0602$b_fill0010 = 4612,0,0,1 %;
literal KA0602$s_fill0010 = 508;
macro KA0602$L_COMBO_TOY_RTCB = 5120,0,32,0 %;
macro KA0602$V_COMBO_TOY_RTCB_DSE = 5120,0,1,0 %;
macro KA0602$V_COMBO_TOY_RTCB_2412 = 5120,1,1,0 %;
macro KA0602$V_COMBO_TOY_RTCB_DM = 5120,2,1,0 %;
macro KA0602$V_COMBO_TOY_RTCB_UIE = 5120,4,1,0 %;
macro KA0602$V_COMBO_TOY_RTCB_AIE = 5120,5,1,0 %;
macro KA0602$V_COMBO_TOY_RTCB_PIE = 5120,6,1,0 %;
macro KA0602$V_COMBO_TOY_RTCB_SET = 5120,7,1,0 %;
macro KA0602$b_fill0011 = 5124,0,0,1 %;
literal KA0602$s_fill0011 = 508;
macro KA0602$L_COMBO_TOY_RTCC = 5632,0,32,0 %;
macro KA0602$V_COMBO_TOY_RTCC_UF = 5632,4,1,0 %;
macro KA0602$V_COMBO_TOY_RTCC_AF = 5632,5,1,0 %;
macro KA0602$V_COMBO_TOY_RTCC_PF = 5632,6,1,0 %;
macro KA0602$V_COMBO_TOY_RTCC_IRQF = 5632,7,1,0 %;
macro KA0602$b_fill0012 = 5636,0,0,1 %;
literal KA0602$s_fill0012 = 508;
macro KA0602$L_COMBO_TOY_RTCD = 6144,0,32,0 %;
macro KA0602$V_COMBO_TOY_RTCD_VRT = 6144,7,1,0 %;
macro KA0602$b_fill0013 = 6148,0,0,1 %;
literal KA0602$s_fill0013 = 2044;
macro KA0602$L_HAE = 8192,0,32,0 %;
macro KA0602$V_HAE_EISA_ADDR = 8192,0,7,0 %;
literal KA0602$S_HAE_EISA_ADDR = 7;
macro KA0602$b_fill2aa = 8196,0,0,1 %;
literal KA0602$s_fill2aa = 8188;
macro KA0602$L_SYSCTL = 16384,0,32,0 %;
macro KA0602$V_SYSCTL_LEDS = 16384,0,4,0 %;
literal KA0602$S_SYSCTL_LEDS = 4;
macro KA0602$V_SYSCTL_IOR = 16384,4,1,0 %;
macro KA0602$V_SYSCTL_ERRENB = 16384,5,1,0 %;
macro KA0602$V_SYSCTL_MCNFG = 16384,6,2,0 %;
literal KA0602$S_SYSCTL_MCNFG = 2;
macro KA0602$b_fill3 = 16388,0,0,1 %;
literal KA0602$s_fill3 = 8188;
macro KA0602$B_DMA1_CH0_CA = 24576,0,8,0 %;
macro KA0602$b_fill4 = 24577,0,0,1 %;
literal KA0602$s_fill4 = 4095;
macro KA0602$B_INT1_OCW2 = 28672,0,8,0 %;
macro KA0602$V_INT1_OCW2_IRQ = 28672,0,3,0 %;
literal KA0602$S_INT1_OCW2_IRQ = 3;
macro KA0602$V_INT1_OCW2_SEL = 28672,3,2,0 %;
literal KA0602$S_INT1_OCW2_SEL = 2;
macro KA0602$V_INT1_OCW2_EOI = 28672,5,1,0 %;
macro KA0602$V_INT1_OCW2_SL = 28672,6,1,0 %;
macro KA0602$V_INT1_OCW2_ROT = 28672,7,1,0 %;
macro KA0602$V_INT1_OCW3_RIS = 28672,0,1,0 %;
macro KA0602$V_INT1_OCW3_RR = 28672,1,1,0 %;
macro KA0602$V_INT1_OCW3_P = 28672,2,1,0 %;
macro KA0602$V_INT1_OCW3_SEL = 28672,3,2,0 %;
literal KA0602$S_INT1_OCW3_SEL = 2;
macro KA0602$V_INT1_OCW3_SMM = 28672,5,1,0 %;
macro KA0602$V_INT1_OCW3_ESMM = 28672,6,1,0 %;
macro KA0602$b_fill5 = 28673,0,0,1 %;
literal KA0602$s_fill5 = 127;
macro KA0602$B_INT1_OCW1 = 28800,0,8,0 %;
macro KA0602$V_INT1_OCW1_M0 = 28800,0,1,0 %;
macro KA0602$V_INT1_OCW1_M1 = 28800,1,1,0 %;
macro KA0602$V_INT1_OCW1_M2 = 28800,2,1,0 %;
macro KA0602$V_INT1_OCW1_M3 = 28800,3,1,0 %;
macro KA0602$V_INT1_OCW1_M4 = 28800,4,1,0 %;
macro KA0602$V_INT1_OCW1_M5 = 28800,5,1,0 %;
macro KA0602$V_INT1_OCW1_M6 = 28800,6,1,0 %;
macro KA0602$V_INT1_OCW1_M7 = 28800,7,1,0 %;
macro KA0602$b_fill6 = 28801,0,0,1 %;
literal KA0602$s_fill6 = 16255;
macro KA0602$B_INT2_OCW2 = 45056,0,8,0 %;
macro KA0602$V_INT2_OCW2_IRQ = 45056,0,3,0 %;
literal KA0602$S_INT2_OCW2_IRQ = 3;
macro KA0602$V_INT2_OCW2_SEL = 45056,3,2,0 %;
literal KA0602$S_INT2_OCW2_SEL = 2;
macro KA0602$V_INT2_OCW2_EOI = 45056,5,1,0 %;
macro KA0602$V_INT2_OCW2_SL = 45056,6,1,0 %;
macro KA0602$V_INT2_OCW2_ROT = 45056,7,1,0 %;
macro KA0602$V_INT2_OCW3_RIS = 45056,0,1,0 %;
macro KA0602$V_INT2_OCW3_RR = 45056,1,1,0 %;
macro KA0602$V_INT2_OCW3_P = 45056,2,1,0 %;
macro KA0602$V_INT2_OCW3_SEL = 45056,3,2,0 %;
literal KA0602$S_INT2_OCW3_SEL = 2;
macro KA0602$V_INT2_OCW3_SMM = 45056,5,1,0 %;
macro KA0602$V_INT2_OCW3_ESMM = 45056,6,1,0 %;
macro KA0602$b_fill7 = 45057,0,0,1 %;
literal KA0602$s_fill7 = 127;
macro KA0602$B_INT2_OCW1 = 45184,0,8,0 %;
macro KA0602$V_INT2_OCW1_M0 = 45184,0,1,0 %;
macro KA0602$V_INT2_OCW1_M1 = 45184,1,1,0 %;
macro KA0602$V_INT2_OCW1_M2 = 45184,2,1,0 %;
macro KA0602$V_INT2_OCW1_M3 = 45184,3,1,0 %;
macro KA0602$V_INT2_OCW1_M4 = 45184,4,1,0 %;
macro KA0602$V_INT2_OCW1_M5 = 45184,5,1,0 %;
macro KA0602$V_INT2_OCW1_M6 = 45184,6,1,0 %;
macro KA0602$V_INT2_OCW1_M7 = 45184,7,1,0 %;
macro KA0602$b_fill8 = 45185,0,0,1 %;
literal KA0602$s_fill8 = 503680;
 
!*** MODULE $KA0702DEF ***
literal KA0702$M_IR_SFB_INT = %X'4';
literal KA0702$M_IR_SCSI_INT = %X'8';
literal KA0702$M_IR_COREIO_INT = %X'10';
literal KA0702$M_IR_BC_TPE = %X'8000000';
literal KA0702$M_IR_TC_ORE = %X'10000000';
literal KA0702$M_IR_TC_TOE = %X'20000000';
literal KA0702$M_IR_BPE = %X'40000000';
literal KA0702$M_IR_MPE = %X'80000000';
literal KA0702$M_TCSR_AP0 = %X'1';
literal KA0702$M_TCSR_AP1 = %X'2';
literal KA0702$M_TCSR_AP2 = %X'4';
literal KA0702$M_TCSR_AP3 = %X'8';
literal KA0702$M_TCSR_AP4 = %X'10';
literal KA0702$M_MCR_SP0_SIZE = %X'1';
literal KA0702$M_MCR_SP1_SIZE = %X'2';
literal KA0702$M_MCR_SP2_SIZE = %X'4';
literal KA0702$M_MCR_SP3_SIZE = %X'8';
literal KA0702$M_LDP_DMA_PA_LO = %X'FFFE0';
literal KA0702$M_LDP_DMA_PA_HI = %X'FFF00000';
literal KA0702$M_SCOMM_TR_DMA_PA = %X'FFFFFFE0';
literal KA0702$M_SCOMM_RC_DMA_PA = %X'FFFFFFE0';
literal KA0702$M_PRINTER_TR_DMA_PA = %X'FFFFFFE0';
literal KA0702$M_PRINTER_RC_DMA_PA = %X'FFFFFFE0';
literal KA0702$M_ISDN_TR_DMA_PA = %X'FFFFFFE0';
literal KA0702$M_ISDN_TR_BUF_DMA_PA = %X'FFFFFFE0';
literal KA0702$M_ISDN_RC_DMA_PA = %X'FFFFFFE0';
literal KA0702$M_ISDN_RC_BUF_DMA_PA = %X'FFFFFFE0';
literal KA0702$M_SSR_IO_MASK = %X'F';
literal KA0702$M_SSR_IO_MASK_EN = %X'10';
literal KA0702$M_SSR_FPE = %X'80';
literal KA0702$M_SSR_LANCE_RESET = %X'100';
literal KA0702$M_SSR_RTC_RESET = %X'400';
literal KA0702$M_SSR_SCC_RESET = %X'800';
literal KA0702$M_SSR_ISDN_RESET = %X'1000';
literal KA0702$M_SSR_TXDIS = %X'8000';
literal KA0702$M_SSR_LANCE_DMA_EN = %X'10000';
literal KA0702$M_SSR_ISDN_RCV_EN = %X'80000';
literal KA0702$M_SSR_ISDN_TR_EN = %X'100000';
literal KA0702$M_SSR_SMR0 = %X'1000000';
literal KA0702$M_SSR_SMR1 = %X'2000000';
literal KA0702$M_SSR_SMRA = %X'4000000';
literal KA0702$M_SSR_FAST_MODE = %X'8000000';
literal KA0702$M_SSR_KBD_RC_DMA_EN = %X'10000000';
literal KA0702$M_SSR_KBD_TR_DMA_EN = %X'20000000';
literal KA0702$M_SSR_COMM_RC_DMA_EN = %X'40000000';
literal KA0702$M_SSR_COMM_TR_DMA_EN = %X'80000000';
literal KA0702$M_SIR_HALT0 = %X'1';
literal KA0702$M_SIR_HALT1 = %X'2';
literal KA0702$M_SIR_TC_SLOT0 = %X'4';
literal KA0702$M_SIR_TC_SLOT1 = %X'8';
literal KA0702$M_SIR_SCC0_INT = %X'40';
literal KA0702$M_SIR_SCC1_INT = %X'80';
literal KA0702$M_SIR_LANCE_INT = %X'100';
literal KA0702$M_SIR_ISDN_INT = %X'2000';
literal KA0702$M_SIR_CONS_SEL = %X'8000';
literal KA0702$M_SIR_LANCE_DMA_ER = %X'10000';
literal KA0702$M_SIR_ISDN_DMA_MRE = %X'100000';
literal KA0702$M_SIR_ISDN_DMA_RC_INTR = %X'200000';
literal KA0702$M_SIR_ISDN_DMA_TR_INTR = %X'400000';
literal KA0702$M_SIR_SCC1_DMA_OV = %X'1000000';
literal KA0702$M_SIR_SCC1_RCV_INT = %X'2000000';
literal KA0702$M_SIR_SCC1_TR_DMA_ME = %X'4000000';
literal KA0702$M_SIR_SCC1_TR_INT = %X'8000000';
literal KA0702$M_SIR_SCC0_DMA_OV = %X'10000000';
literal KA0702$M_SIR_SCC0_RCV_INT = %X'20000000';
literal KA0702$M_SIR_SCC0_TR_DMA_ME = %X'40000000';
literal KA0702$M_SIR_SCC0_TR_INT = %X'80000000';
literal KA0702$M_SIMR_HALT0 = %X'1';
literal KA0702$M_SIMR_HALT1 = %X'2';
literal KA0702$M_SIMR_TC_SLOT0 = %X'4';
literal KA0702$M_SIMR_TC_SLOT1 = %X'8';
literal KA0702$M_SIMR_SCC0_INT = %X'40';
literal KA0702$M_SIMR_SCC1_INT = %X'80';
literal KA0702$M_SIMR_LANCE_INT = %X'100';
literal KA0702$M_SIMR_ISDN_INT = %X'2000';
literal KA0702$M_SIMR_CONS_SEL = %X'8000';
literal KA0702$M_SIMR_LANCE_DMA_ER = %X'10000';
literal KA0702$M_SIMR_ISDN_DMA_MRE = %X'100000';
literal KA0702$M_SIMR_ISDN_DMA_RC_INTR = %X'200000';
literal KA0702$M_SIMR_ISDN_DMA_TR_INTR = %X'400000';
literal KA0702$M_SIMR_SCC1_DMA_OV = %X'1000000';
literal KA0702$M_SIMR_SCC1_RCV_INT = %X'2000000';
literal KA0702$M_SIMR_SCC1_TR_DMA_ME = %X'4000000';
literal KA0702$M_SIMR_SCC1_TR_INT = %X'8000000';
literal KA0702$M_SIMR_SCC0_DMA_OV = %X'10000000';
literal KA0702$M_SIMR_SCC0_RCV_INT = %X'20000000';
literal KA0702$M_SIMR_SCC0_TR_DMA_ME = %X'40000000';
literal KA0702$M_SIMR_SCC0_TR_INT = %X'80000000';
literal KA0702$M_SADR_TC_ADDR = %X'1FFFFE0';
literal KA0702$M_ISDN_DATA_TR_DATA = %X'FFFFFF';
literal KA0702$M_ISDN_DATA_RC_DATA = %X'FFFFFF';
literal KA0702$M_LANCE_SLOT_CS = %X'F';
literal KA0702$M_LANCE_SLOT_HW_ADDR = %X'3F0';
literal KA0702$M_SCC0_SLOT_CS = %X'F';
literal KA0702$M_SCC0_SLOT_HW_ADDR = %X'3F0';
literal KA0702$M_SCC1_SLOT_CS = %X'F';
literal KA0702$M_SCC1_SLOT_HW_ADDR = %X'3F0';
literal KA0702$M_MODE_FIELD = %X'7';
literal KA0702$M_BOOLOP_OP = %X'F';
literal KA0702$M_PIXELSHIFT_COUNT = %X'F';
literal KA0702$M_ADDR_REG_VALUE = %X'FFFFFF';
literal KA0702$M_BRES1_EI1 = %X'FFFF';
literal KA0702$M_BRES1_AI1 = %X'FFFF0000';
literal KA0702$M_BRES2_EI2 = %X'FFFF';
literal KA0702$M_BRES2_AI2 = %X'FFFF0000';
literal KA0702$M_BRES3_LL = %X'F';
literal KA0702$M_BRES3_IEV = %X'FFFF8000';
literal KA0702$M_DEEP_PLANE = %X'3';
literal KA0702$M_V_REF_COUNT_VC = %X'3FF';
literal KA0702$M_V_HOR_PIXELS = %X'1FF';
literal KA0702$M_V_HOR_FP = %X'3E00';
literal KA0702$M_V_HOR_SYNCH = %X'1FC000';
literal KA0702$M_V_HOR_BP = %X'FE00000';
literal KA0702$M_V_VER_SL = %X'7FF';
literal KA0702$M_V_VER_FP = %X'F800';
literal KA0702$M_V_VER_SYNCH = %X'3F0000';
literal KA0702$M_V_VER_BP = %X'FC00000';
literal KA0702$M_V_BASE_ADDR_ROW = %X'1FF';
literal KA0702$M_RAMDAC_ADDR_LO_BYTE0 = %X'FF';
literal KA0702$M_RAMDAC_ADDR_HI_BYTE0 = %X'FF';
literal KA0702$M_RAMDAC_REG_ADDR_BYTE0 = %X'FF';
literal KA0702$M_RAMDAC_MAP_LOC_BYTE0 = %X'FF';
literal KA0702$S_KA0702DEF = 2179072;   !  Old size name, synonym for KA0702$S_KA0702
literal KA0702$S_KA0702 = 2179072;
macro KA0702$L_IR = 0,0,32,0 %;         !  Interrupt register
macro KA0702$V_IR_SFB_INT = 0,2,1,0 %;
macro KA0702$V_IR_SCSI_INT = 0,3,1,0 %;
macro KA0702$V_IR_COREIO_INT = 0,4,1,0 %;
macro KA0702$V_IR_BC_TPE = 0,27,1,0 %;
macro KA0702$V_IR_TC_ORE = 0,28,1,0 %;
macro KA0702$V_IR_TC_TOE = 0,29,1,0 %;
macro KA0702$V_IR_BPE = 0,30,1,0 %;
macro KA0702$V_IR_MPE = 0,31,1,0 %;
macro KA0702$L_TCSR = 16,0,32,0 %;      !  TC status and control register
macro KA0702$V_TCSR_AP0 = 16,0,1,0 %;
macro KA0702$V_TCSR_AP1 = 16,1,1,0 %;
macro KA0702$V_TCSR_AP2 = 16,2,1,0 %;
macro KA0702$V_TCSR_AP3 = 16,3,1,0 %;
macro KA0702$V_TCSR_AP4 = 16,4,1,0 %;
macro KA0702$L_MCR = 32,0,32,0 %;       !  Memory Configuration Register
macro KA0702$V_MCR_SP0_SIZE = 32,0,1,0 %; !  SIMM PAIR0 Size
macro KA0702$V_MCR_SP1_SIZE = 32,1,1,0 %; !  SIMM PAIR1 Size
macro KA0702$V_MCR_SP2_SIZE = 32,2,1,0 %; !  SIMM PAIR2 Size
macro KA0702$V_MCR_SP3_SIZE = 32,3,1,0 %; !  SIMM PAIR3 Size
macro KA0702$L_IOCTL_CSR = 8192,0,32,0 %; !  Core I/O base CSR address
macro KA0702$L_LDP = 8256,0,32,0 %;     !  Ethernet Lance DMA pointer
macro KA0702$V_LDP_DMA_PA_LO = 8256,5,15,0 %;
literal KA0702$S_LDP_DMA_PA_LO = 15;
macro KA0702$V_LDP_DMA_PA_HI = 8256,20,12,0 %;
literal KA0702$S_LDP_DMA_PA_HI = 12;
macro KA0702$L_SCOMM_TR = 8288,0,32,0 %; !  Serial comm transmit port 1 DMA pointer
macro KA0702$V_SCOMM_TR_DMA_PA = 8288,5,27,0 %;
literal KA0702$S_SCOMM_TR_DMA_PA = 27;
macro KA0702$L_SCOMM_RC = 8320,0,32,0 %; !  Serial comm receive port 1 DMA pointer
macro KA0702$V_SCOMM_RC_DMA_PA = 8320,5,27,0 %;
literal KA0702$S_SCOMM_RC_DMA_PA = 27;
macro KA0702$L_PRINTER_TR = 8352,0,32,0 %; !  Printer transmit port DMA pointer
macro KA0702$V_PRINTER_TR_DMA_PA = 8352,5,27,0 %;
literal KA0702$S_PRINTER_TR_DMA_PA = 27;
macro KA0702$L_PRINTER_RC = 8384,0,32,0 %; !  Printer receive port DMA pointer
macro KA0702$V_PRINTER_RC_DMA_PA = 8384,5,27,0 %;
literal KA0702$S_PRINTER_RC_DMA_PA = 27;
macro KA0702$L_ISDN_TR = 8448,0,32,0 %; !  ISDN transmit DMA pointer
macro KA0702$V_ISDN_TR_DMA_PA = 8448,5,27,0 %;
literal KA0702$S_ISDN_TR_DMA_PA = 27;
macro KA0702$L_ISDN_TR_BUF = 8480,0,32,0 %; !  ISDN transmit DMA buffer pointer
macro KA0702$V_ISDN_TR_BUF_DMA_PA = 8480,5,27,0 %;
literal KA0702$S_ISDN_TR_BUF_DMA_PA = 27;
macro KA0702$L_ISDN_RC = 8512,0,32,0 %; !  ISDN receive DMA pointer 
macro KA0702$V_ISDN_RC_DMA_PA = 8512,5,27,0 %;
literal KA0702$S_ISDN_RC_DMA_PA = 27;
macro KA0702$L_ISDN_RC_BUF = 8544,0,32,0 %; !  ISDN receive DMA buffer pointer 
macro KA0702$V_ISDN_RC_BUF_DMA_PA = 8544,5,27,0 %;
literal KA0702$S_ISDN_RC_BUF_DMA_PA = 27;
macro KA0702$L_DATA0 = 8576,0,32,0 %;   !  System Data Buffer 0
macro KA0702$L_DATA1 = 8608,0,32,0 %;   !  System Data Buffer 1
macro KA0702$L_DATA2 = 8640,0,32,0 %;   !  System Data Buffer 2
macro KA0702$L_DATA3 = 8672,0,32,0 %;   !  System Data Buffer 3
macro KA0702$L_SSR = 8704,0,32,0 %;     !  System support register
macro KA0702$V_SSR_IO_MASK = 8704,0,4,0 %;
literal KA0702$S_SSR_IO_MASK = 4;
macro KA0702$V_SSR_IO_MASK_EN = 8704,4,1,0 %;
macro KA0702$V_SSR_FPE = 8704,7,1,0 %;
macro KA0702$V_SSR_LANCE_RESET = 8704,8,1,0 %;
macro KA0702$V_SSR_RTC_RESET = 8704,10,1,0 %;
macro KA0702$V_SSR_SCC_RESET = 8704,11,1,0 %;
macro KA0702$V_SSR_ISDN_RESET = 8704,12,1,0 %;
macro KA0702$V_SSR_TXDIS = 8704,15,1,0 %;
macro KA0702$V_SSR_LANCE_DMA_EN = 8704,16,1,0 %;
macro KA0702$V_SSR_ISDN_RCV_EN = 8704,19,1,0 %;
macro KA0702$V_SSR_ISDN_TR_EN = 8704,20,1,0 %;
macro KA0702$V_SSR_SMR0 = 8704,24,1,0 %;
macro KA0702$V_SSR_SMR1 = 8704,25,1,0 %;
macro KA0702$V_SSR_SMRA = 8704,26,1,0 %;
macro KA0702$V_SSR_FAST_MODE = 8704,27,1,0 %;
macro KA0702$V_SSR_KBD_RC_DMA_EN = 8704,28,1,0 %;
macro KA0702$V_SSR_KBD_TR_DMA_EN = 8704,29,1,0 %;
macro KA0702$V_SSR_COMM_RC_DMA_EN = 8704,30,1,0 %;
macro KA0702$V_SSR_COMM_TR_DMA_EN = 8704,31,1,0 %;
macro KA0702$L_SIR = 8736,0,32,0 %;     !  System interrupt register
macro KA0702$V_SIR_HALT0 = 8736,0,1,0 %;
macro KA0702$V_SIR_HALT1 = 8736,1,1,0 %;
macro KA0702$V_SIR_TC_SLOT0 = 8736,2,1,0 %;
macro KA0702$V_SIR_TC_SLOT1 = 8736,3,1,0 %;
macro KA0702$V_SIR_SCC0_INT = 8736,6,1,0 %;
macro KA0702$V_SIR_SCC1_INT = 8736,7,1,0 %;
macro KA0702$V_SIR_LANCE_INT = 8736,8,1,0 %;
macro KA0702$V_SIR_ISDN_INT = 8736,13,1,0 %;
macro KA0702$V_SIR_CONS_SEL = 8736,15,1,0 %;
macro KA0702$V_SIR_LANCE_DMA_ER = 8736,16,1,0 %;
macro KA0702$V_SIR_ISDN_DMA_MRE = 8736,20,1,0 %;
macro KA0702$V_SIR_ISDN_DMA_RC_INTR = 8736,21,1,0 %;
macro KA0702$V_SIR_ISDN_DMA_TR_INTR = 8736,22,1,0 %;
macro KA0702$V_SIR_SCC1_DMA_OV = 8736,24,1,0 %;
macro KA0702$V_SIR_SCC1_RCV_INT = 8736,25,1,0 %;
macro KA0702$V_SIR_SCC1_TR_DMA_ME = 8736,26,1,0 %;
macro KA0702$V_SIR_SCC1_TR_INT = 8736,27,1,0 %;
macro KA0702$V_SIR_SCC0_DMA_OV = 8736,28,1,0 %;
macro KA0702$V_SIR_SCC0_RCV_INT = 8736,29,1,0 %;
macro KA0702$V_SIR_SCC0_TR_DMA_ME = 8736,30,1,0 %;
macro KA0702$V_SIR_SCC0_TR_INT = 8736,31,1,0 %;
macro KA0702$L_SIMR = 8768,0,32,0 %;    !  System interrupt mask register
macro KA0702$V_SIMR_HALT0 = 8768,0,1,0 %;
macro KA0702$V_SIMR_HALT1 = 8768,1,1,0 %;
macro KA0702$V_SIMR_TC_SLOT0 = 8768,2,1,0 %;
macro KA0702$V_SIMR_TC_SLOT1 = 8768,3,1,0 %;
macro KA0702$V_SIMR_SCC0_INT = 8768,6,1,0 %;
macro KA0702$V_SIMR_SCC1_INT = 8768,7,1,0 %;
macro KA0702$V_SIMR_LANCE_INT = 8768,8,1,0 %;
macro KA0702$V_SIMR_ISDN_INT = 8768,13,1,0 %;
macro KA0702$V_SIMR_CONS_SEL = 8768,15,1,0 %;
macro KA0702$V_SIMR_LANCE_DMA_ER = 8768,16,1,0 %;
macro KA0702$V_SIMR_ISDN_DMA_MRE = 8768,20,1,0 %;
macro KA0702$V_SIMR_ISDN_DMA_RC_INTR = 8768,21,1,0 %;
macro KA0702$V_SIMR_ISDN_DMA_TR_INTR = 8768,22,1,0 %;
macro KA0702$V_SIMR_SCC1_DMA_OV = 8768,24,1,0 %;
macro KA0702$V_SIMR_SCC1_RCV_INT = 8768,25,1,0 %;
macro KA0702$V_SIMR_SCC1_TR_DMA_ME = 8768,26,1,0 %;
macro KA0702$V_SIMR_SCC1_TR_INT = 8768,27,1,0 %;
macro KA0702$V_SIMR_SCC0_DMA_OV = 8768,28,1,0 %;
macro KA0702$V_SIMR_SCC0_RCV_INT = 8768,29,1,0 %;
macro KA0702$V_SIMR_SCC0_TR_DMA_ME = 8768,30,1,0 %;
macro KA0702$V_SIMR_SCC0_TR_INT = 8768,31,1,0 %;
macro KA0702$L_SADR = 8800,0,32,0 %;    !  System address register
macro KA0702$V_SADR_TC_ADDR = 8800,5,20,0 %;
literal KA0702$S_SADR_TC_ADDR = 20;
macro KA0702$L_ISDN_DATA_TR = 8832,0,32,0 %; !  ISDN Data Transmit
macro KA0702$V_ISDN_DATA_TR_DATA = 8832,0,24,0 %;
literal KA0702$S_ISDN_DATA_TR_DATA = 24;
macro KA0702$L_ISDN_DATA_RC = 8864,0,32,0 %; !  ISDN Data Receive
macro KA0702$V_ISDN_DATA_RC_DATA = 8864,0,24,0 %;
literal KA0702$S_ISDN_DATA_RC_DATA = 24;
macro KA0702$L_LANCE_SLOT = 8896,0,32,0 %; !  Lance slot register
macro KA0702$V_LANCE_SLOT_CS = 8896,0,4,0 %;
literal KA0702$S_LANCE_SLOT_CS = 4;
macro KA0702$V_LANCE_SLOT_HW_ADDR = 8896,4,6,0 %;
literal KA0702$S_LANCE_SLOT_HW_ADDR = 6;
macro KA0702$L_SCC0_SLOT = 8960,0,32,0 %; !  SCC0 slot register
macro KA0702$V_SCC0_SLOT_CS = 8960,0,4,0 %;
literal KA0702$S_SCC0_SLOT_CS = 4;
macro KA0702$V_SCC0_SLOT_HW_ADDR = 8960,4,6,0 %;
literal KA0702$S_SCC0_SLOT_HW_ADDR = 6;
macro KA0702$L_SCC1_SLOT = 8992,0,32,0 %; !  SCC1 slot register
macro KA0702$V_SCC1_SLOT_CS = 8992,0,4,0 %;
literal KA0702$S_SCC1_SLOT_CS = 4;
macro KA0702$V_SCC1_SLOT_HW_ADDR = 8992,4,6,0 %;
literal KA0702$S_SCC1_SLOT_HW_ADDR = 6;
macro KA0702$L_NI_ADR_ROM = 16384,0,32,0 %; !  Ethernet address ROM
macro KA0702$L_LANCE_RDP = 24576,0,32,0 %; !  Lance ethernet CSR
macro KA0702$L_LANCE_RAP = 24584,0,32,0 %; !  Lance ethernet CSR
macro KA0702$L_SCC0B_COMM_RAP = 32768,0,32,0 %; !  Comm Port 1 RAP
macro KA0702$L_SCC0B_COMM_DATA = 32776,0,32,0 %; !  Comm Port 1 data
macro KA0702$L_SCC0A_MOUSE_RAP = 32784,0,32,0 %; !  Mouse RAP
macro KA0702$L_SCC0A_MOUSE_DATA = 32792,0,32,0 %; !  Mouse port data register
macro KA0702$L_SCC1B_PRINT_RAP = 40960,0,32,0 %; !  Printer Port 2 RAP
macro KA0702$L_SCC1B_PRINT_DATA = 40968,0,32,0 %; !  Printer Port 2 data
macro KA0702$L_SCC1A_KEY_RAP = 40976,0,32,0 %; !  Keyboard RAP
macro KA0702$L_SCC1A_KEY_DATA = 40984,0,32,0 %; !  Keyboard port data register
macro KA0702$L_RTC_SEC = 49152,0,32,0 %; !  TOY clock CSR--seconds
macro KA0702$L_RTC_ALMS = 49160,0,32,0 %; !  TOY clock CSR--seconds alarm
macro KA0702$L_RTC_MIN = 49168,0,32,0 %; !  TOY clock CSR--minutes
macro KA0702$L_RTC_ALMN = 49176,0,32,0 %; !  TOY clock CSR--minutes alarm
macro KA0702$L_RTC_HOUR = 49184,0,32,0 %; !  TOY clock CSR--hours
macro KA0702$L_RTC_ALMH = 49192,0,32,0 %; !  TOY clock CSR--hours alarm
macro KA0702$L_RTC_DOW = 49200,0,32,0 %; !  TOY clock CSR--day of week
macro KA0702$L_RTC_DAY = 49208,0,32,0 %; !  TOY clock CSR--date of month
macro KA0702$L_RTC_MON = 49216,0,32,0 %; !  TOY clock CSR--month
macro KA0702$L_RTC_YEAR = 49224,0,32,0 %; !  TOY clock CSR--year
macro KA0702$L_RTC_REGA = 49232,0,32,0 %; !  TOY clock CSR--register A 
macro KA0702$L_RTC_REGB = 49240,0,32,0 %; !  TOY clock CSR--register B 
macro KA0702$L_RTC_REGC = 49248,0,32,0 %; !  TOY clock CSR--register C 
macro KA0702$L_RTC_REGD = 49256,0,32,0 %; !  TOY clock CSR--register D 
macro KA0702$L_RTC_RAM = 49264,0,32,0 %; !  TOY clock CSR--base of BBU RAM
macro KA0702$L_SCSI_HOST_ID = 49528,0,32,0 %; !  SCSI Host ID
macro KA0702$L_ISDN_AUDIO = 57344,0,32,0 %; !  ISDN audio chip CSR
macro KA0702$L_CPYBUF0 = 65536,0,32,0 %; !  Copy Buffer register
macro KA0702$L_CPYBUF1 = 65544,0,32,0 %; !  Copy Buffer register
macro KA0702$L_CPYBUF2 = 65552,0,32,0 %; !  Copy Buffer register
macro KA0702$L_CPYBUF3 = 65560,0,32,0 %; !  Copy Buffer register
macro KA0702$L_CPYBUF4 = 65568,0,32,0 %; !  Copy Buffer register
macro KA0702$L_CPYBUF5 = 65576,0,32,0 %; !  Copy Buffer register
macro KA0702$L_CPYBUF6 = 65584,0,32,0 %; !  Copy Buffer register
macro KA0702$L_CPYBUF7 = 65592,0,32,0 %; !  Copy Buffer register
macro KA0702$L_FG = 65600,0,32,0 %;     !  Foreground
macro KA0702$L_BG = 65608,0,32,0 %;     !  Background
macro KA0702$L_PLANEMASK = 65616,0,32,0 %; !  Planemask
macro KA0702$L_PIXELMASK = 65624,0,32,0 %; !  Pixel Mask register
macro KA0702$L_MODE = 65632,0,32,0 %;   !  Mode register
macro KA0702$V_MODE_FIELD = 65632,0,3,0 %;
literal KA0702$S_MODE_FIELD = 3;
macro KA0702$L_BOOLOP = 65640,0,32,0 %; !  Boolean Op register
macro KA0702$V_BOOLOP_OP = 65640,0,4,0 %;
literal KA0702$S_BOOLOP_OP = 4;
macro KA0702$L_PIXELSHIFT = 65648,0,32,0 %; !  Pixel Shift register
macro KA0702$V_PIXELSHIFT_COUNT = 65648,0,4,0 %;
literal KA0702$S_PIXELSHIFT_COUNT = 4;
macro KA0702$L_ADDR_REG = 65656,0,32,0 %; !  Address register
macro KA0702$V_ADDR_REG_VALUE = 65656,0,24,0 %;
literal KA0702$S_ADDR_REG_VALUE = 24;
macro KA0702$L_BRES1 = 65664,0,32,0 %;  !  Bresenham register 1
macro KA0702$V_BRES1_EI1 = 65664,0,16,0 %;
literal KA0702$S_BRES1_EI1 = 16;
macro KA0702$V_BRES1_AI1 = 65664,16,16,0 %;
literal KA0702$S_BRES1_AI1 = 16;
macro KA0702$L_BRES2 = 65672,0,32,0 %;  !  Bresenham register 2
macro KA0702$V_BRES2_EI2 = 65672,0,16,0 %;
literal KA0702$S_BRES2_EI2 = 16;
macro KA0702$V_BRES2_AI2 = 65672,16,16,0 %;
literal KA0702$S_BRES2_AI2 = 16;
macro KA0702$L_BRES3 = 65680,0,32,0 %;  !  Bresenham register 3
macro KA0702$V_BRES3_LL = 65680,0,4,0 %;
literal KA0702$S_BRES3_LL = 4;
macro KA0702$V_BRES3_IEV = 65680,15,17,0 %;
literal KA0702$S_BRES3_IEV = 17;
macro KA0702$L_BCONT = 65688,0,32,0 %;  !  Bresenham continue
macro KA0702$L_DEEP = 65696,0,32,0 %;   !  Deep register
macro KA0702$V_DEEP_PLANE = 65696,0,2,0 %;
literal KA0702$S_DEEP_PLANE = 2;
macro KA0702$L_START = 65704,0,32,0 %;  !  Start register
macro KA0702$L_CI = 65712,0,32,0 %;     !  Clear interrupt
macro KA0702$L_V_REF_COUNT = 65728,0,32,0 %; !  Video refresh count
macro KA0702$V_V_REF_COUNT_VC = 65728,0,10,0 %;
literal KA0702$S_V_REF_COUNT_VC = 10;
macro KA0702$L_V_HOR = 65736,0,32,0 %;  !  Video horizontal setup
macro KA0702$V_V_HOR_PIXELS = 65736,0,9,0 %;
literal KA0702$S_V_HOR_PIXELS = 9;
macro KA0702$V_V_HOR_FP = 65736,9,5,0 %;
literal KA0702$S_V_HOR_FP = 5;
macro KA0702$V_V_HOR_SYNCH = 65736,14,7,0 %;
literal KA0702$S_V_HOR_SYNCH = 7;
macro KA0702$V_V_HOR_BP = 65736,21,7,0 %;
literal KA0702$S_V_HOR_BP = 7;
macro KA0702$L_V_VER = 65744,0,32,0 %;  !  Video vertical setup
macro KA0702$V_V_VER_SL = 65744,0,11,0 %;
literal KA0702$S_V_VER_SL = 11;
macro KA0702$V_V_VER_FP = 65744,11,5,0 %;
literal KA0702$S_V_VER_FP = 5;
macro KA0702$V_V_VER_SYNCH = 65744,16,6,0 %;
literal KA0702$S_V_VER_SYNCH = 6;
macro KA0702$V_V_VER_BP = 65744,22,6,0 %;
literal KA0702$S_V_VER_BP = 6;
macro KA0702$L_V_BASE_ADDR = 65752,0,32,0 %; !  Video Base Address
macro KA0702$V_V_BASE_ADDR_ROW = 65752,0,9,0 %;
literal KA0702$S_V_BASE_ADDR_ROW = 9;
macro KA0702$L_VV = 65760,0,32,0 %;     !  Video valid
macro KA0702$L_EI = 65768,0,32,0 %;     !  Enable interrupts
macro KA0702$L_TCCLK_COUNT = 65776,0,32,0 %; !  TC clk count
macro KA0702$L_VIDCLK_COUNT = 65784,0,32,0 %; !  TC clk count
macro KA0702$L_RAMDAC_ADDR_LO = 73728,0,32,0 %; !  RAMDAC color map and registers
macro KA0702$V_RAMDAC_ADDR_LO_BYTE0 = 73728,0,8,0 %;
literal KA0702$S_RAMDAC_ADDR_LO_BYTE0 = 8;
macro KA0702$L_RAMDAC_ADDR_HI = 73736,0,32,0 %; !  RAMDAC color map and registers
macro KA0702$V_RAMDAC_ADDR_HI_BYTE0 = 73736,0,8,0 %;
literal KA0702$S_RAMDAC_ADDR_HI_BYTE0 = 8;
macro KA0702$L_RAMDAC_REG_ADDR = 73744,0,32,0 %; !  RAMDAC color map and registers
macro KA0702$V_RAMDAC_REG_ADDR_BYTE0 = 73744,0,8,0 %;
literal KA0702$S_RAMDAC_REG_ADDR_BYTE0 = 8;
macro KA0702$L_RAMDAC_MAP_LOC = 73752,0,32,0 %; !  RAMDAC color map and registers
macro KA0702$V_RAMDAC_MAP_LOC_BYTE0 = 73752,0,8,0 %;
literal KA0702$S_RAMDAC_MAP_LOC_BYTE0 = 8;
macro KA0702$L_FB = 81920,0,32,0 %;     !  Video RAM (2 MB dense)
literal KA0702$K_IO_SCB_VEC = 2048;
literal KA0702$K_SCSI_TC_SLOT = 3;
literal KA0702$K_CORE_IO_TC_SLOT = 4;
literal KA0702$K_CXTURBO_TC_SLOT = 2;
literal KA0702$K_TC_SLOT0_VEC = 0;
literal KA0702$K_TC_SLOT1_VEC = 1;
literal KA0702$K_TC_EMPTY2_VEC = 2;
literal KA0702$K_TC_EMPTY3_VEC = 3;
literal KA0702$K_TC_SLOT4_VEC = 4;
literal KA0702$K_COREIO_VEC = 5;
literal KA0702$K_SFB_VEC = 6;
literal KA0702$K_ETHERNET_VEC = 7;
literal KA0702$K_SCC_VEC = 8;
literal KA0702$K_OPDRVR_XMIT = 9;
literal KA0702$K_OPDRVR_RCV = 10;
literal KA0702$K_ISDN_VEC = 11;
literal KA0702$K_TOTAL_VECTORS = 12;
literal KA0702$M_MASK0 = %X'1';
literal KA0702$M_MASK1 = %X'2';
literal KA0702$M_MASK2 = %X'4';
literal KA0702$M_MASK3 = %X'8';
literal KA0702$S_KA0702_MASK_BITS = 1;
macro KA0702$V_MASK0 = 0,0,1,0 %;
macro KA0702$V_MASK1 = 0,1,1,0 %;
macro KA0702$V_MASK2 = 0,2,1,0 %;
macro KA0702$V_MASK3 = 0,3,1,0 %;
!  The following definition defines an entry of a Saved Error Register Table.
!  This table is pointed to by a cell in the Turbo ADP.  The table is divided up 
!  into an entry for each slot.  Each entry contains saved copies of IR, TCEREG, 
!  and FADR.  The entries are written by the machine check handler on an error, and
!  read by a driver (at some appropriate time) to determine if a TC error
!  occurred.
!  Define Saved Register Table Entry
literal KA0702$M_SAVED_IR_SFB_INT = %X'4';
literal KA0702$M_SAVED_IR_SCSI_INT = %X'8';
literal KA0702$M_SAVED_IR_COREIO_INT = %X'10';
literal KA0702$M_SAVED_IR_BC_TPE = %X'8000000';
literal KA0702$M_SAVED_IR_TC_ORE = %X'10000000';
literal KA0702$M_SAVED_IR_TC_TOE = %X'20000000';
literal KA0702$M_SAVED_IR_BPE = %X'40000000';
literal KA0702$M_SAVED_IR_MPE = %X'80000000';
literal KA0702$K_SAVED_REG_ENTRY_SIZE = 8;
literal KA0702$S_KA0702_SAVED_REG = 8;
macro KA0702$L_SAVED_IR = 0,0,32,0 %;   !  Interrupt reason
macro KA0702$V_SAVED_IR_SFB_INT = 0,2,1,0 %;
macro KA0702$V_SAVED_IR_SCSI_INT = 0,3,1,0 %;
macro KA0702$V_SAVED_IR_COREIO_INT = 0,4,1,0 %;
macro KA0702$V_SAVED_IR_BC_TPE = 0,27,1,0 %;
macro KA0702$V_SAVED_IR_TC_ORE = 0,28,1,0 %;
macro KA0702$V_SAVED_IR_TC_TOE = 0,29,1,0 %;
macro KA0702$V_SAVED_IR_BPE = 0,30,1,0 %;
macro KA0702$V_SAVED_IR_MPE = 0,31,1,0 %;
!  Define indexes into error table.  Indexes are 0 thru 10.
!  The count of the number of entries is 11.
literal KA0702$K_SLOT0_INDEX = 0;
literal KA0702$K_SLOT1_INDEX = 1;
literal KA0702$K_SLOT2_INDEX = 2;
literal KA0702$K_SLOT3_INDEX = 3;
literal KA0702$K_SCSI_INDEX = 4;
literal KA0702$K_COREIO_INDEX = 5;
literal KA0702$K_CXTURBO_INDEX = 6;
literal KA0702$K_SAVED_REG_ENTRY_COUNT = 7;
 
!*** MODULE $KA0802DEF ***
literal KA0802$M_APC_HAE = %X'1F';
literal KA0802$M_APC_INTERVAL_TIMER = %X'FFFF';
literal KA0802$M_APC_BUFFER_STATUS_E = %X'1';
literal KA0802$M_APC_BUFFER_STATUS_O = %X'2';
literal KA0802$M_APC_BUFFER_STATUS_M = %X'4';
literal KA0802$M_APC_BUFFER_STATUS_H = %X'8';
literal KA0802$M_APC_ERROR_STATUS = %X'FFFF';
literal KA0802$M_APC_ERROR_MASK = %X'FFFF';
literal KA0802$M_APC_LAST_PREFIX_LEN = %X'60';
literal KA0802$M_APC_LAST_PREFIX_OFF = %X'180';
literal KA0802$M_APC_LAST_PREFIX_CYCLE = %X'E00';
literal KA0802$M_APC_LAST_PREFIX_fill1 = %X'1000';
literal KA0802$M_APC_LAST_PREFIX_A = %X'2000';
literal KA0802$M_APC_LAST_PREFIX_E = %X'4000';
literal KA0802$M_APC_LAST_PREFIX_RW = %X'8000';
literal KA0802$M_APC_LAST_PREFIX_V = %X'10000';
literal KA0802$M_APC_LAST_PREFIX_fill2 = %X'FFFE0000';
literal KA0802$M_APC_LOCK_ADDRESS_L = %X'1';
literal KA0802$M_APC_LOCK_ADDRESS = %X'FFFFFFE0';
literal KA0802$M_APC_PREFIX_LEN = %X'18';
literal KA0802$M_APC_PREFIX_OFF = %X'60';
literal KA0802$M_APC_PREFIX_SUB_FOR_10 = %X'180';
literal KA0802$M_APC_PREFIX_CYCLE = %X'E00';
literal KA0802$M_APC_PREFIX_SUB_87_EN = %X'1000';
literal KA0802$M_APC_PREFIX_SUB_11_9_EN = %X'2000';
literal KA0802$S_KA0802DEF = 32768;     !  Old KA0802 size for compatibility
literal KA0802$S_KA0802 = 32768;
macro KA0802$L_APC_HAE = 0,0,32,1 %;
macro KA0802$V_APC_HAE = 0,0,5,0 %;
literal KA0802$S_APC_HAE = 5;
macro KA0802$L_APC_INTERVAL_TIMER = 128,0,32,1 %;
macro KA0802$V_APC_INTERVAL_TIMER = 128,0,16,0 %;
literal KA0802$S_APC_INTERVAL_TIMER = 16;
macro KA0802$L_APC_BUFFER_STATUS = 192,0,32,1 %;
macro KA0802$V_APC_BUFFER_STATUS_E = 192,0,1,0 %;
macro KA0802$V_APC_BUFFER_STATUS_O = 192,1,1,0 %;
macro KA0802$V_APC_BUFFER_STATUS_M = 192,2,1,0 %;
macro KA0802$V_APC_BUFFER_STATUS_H = 192,3,1,0 %;
macro KA0802$L_APC_ERROR_STATUS = 256,0,32,1 %;
macro KA0802$V_APC_ERROR_STATUS = 256,0,16,0 %;
literal KA0802$S_APC_ERROR_STATUS = 16;
macro KA0802$L_APC_ERROR_MASK = 320,0,32,1 %;
macro KA0802$V_APC_ERROR_MASK = 320,0,16,0 %;
literal KA0802$S_APC_ERROR_MASK = 16;
macro KA0802$L_APC_LAST_PREFIX = 384,0,32,1 %;
macro KA0802$V_APC_LAST_PREFIX_LEN = 384,5,2,0 %;
literal KA0802$S_APC_LAST_PREFIX_LEN = 2;
macro KA0802$V_APC_LAST_PREFIX_OFF = 384,7,2,0 %;
literal KA0802$S_APC_LAST_PREFIX_OFF = 2;
macro KA0802$V_APC_LAST_PREFIX_CYCLE = 384,9,3,0 %;
literal KA0802$S_APC_LAST_PREFIX_CYCLE = 3;
macro KA0802$V_APC_LAST_PREFIX_fill1 = 384,12,1,0 %;
macro KA0802$V_APC_LAST_PREFIX_A = 384,13,1,0 %;
macro KA0802$V_APC_LAST_PREFIX_E = 384,14,1,0 %;
macro KA0802$V_APC_LAST_PREFIX_RW = 384,15,1,0 %;
macro KA0802$V_APC_LAST_PREFIX_V = 384,16,1,0 %;
macro KA0802$V_APC_LAST_PREFIX_fill2 = 384,17,15,0 %;
literal KA0802$S_APC_LAST_PREFIX_fill2 = 15;
macro KA0802$L_APC_LOCK_ADDRESS = 448,0,32,1 %;
macro KA0802$V_APC_LOCK_ADDRESS_L = 448,0,1,0 %;
macro KA0802$V_APC_LOCK_ADDRESS = 448,5,27,0 %;
literal KA0802$S_APC_LOCK_ADDRESS = 27;
macro KA0802$L_APC_LOCAL_DEVICE_PORT = 512,0,32,1 %;
macro KA0802$L_APC_MISC_DATA0 = 640,0,32,1 %;
macro KA0802$L_APC_MISC_DATA1 = 704,0,32,1 %;
macro KA0802$L_APC_PREFIX = 8192,0,32,1 %;
macro KA0802$V_APC_PREFIX_LEN = 8192,3,2,0 %;
literal KA0802$S_APC_PREFIX_LEN = 2;
macro KA0802$V_APC_PREFIX_OFF = 8192,5,2,0 %;
literal KA0802$S_APC_PREFIX_OFF = 2;
macro KA0802$V_APC_PREFIX_SUB_FOR_10 = 8192,7,2,0 %;
literal KA0802$S_APC_PREFIX_SUB_FOR_10 = 2;
macro KA0802$V_APC_PREFIX_CYCLE = 8192,9,3,0 %;
literal KA0802$S_APC_PREFIX_CYCLE = 3;
macro KA0802$V_APC_PREFIX_SUB_87_EN = 8192,12,1,0 %;
macro KA0802$V_APC_PREFIX_SUB_11_9_EN = 8192,13,1,0 %;
macro KA0802$L_APC_CACHE_CONTROL = 24576,0,32,1 %;
macro KA0802$L_APC_PCI_CONFIG = 24704,0,32,1 %;
macro KA0802$L_APC_PCI_STATUS = 24768,0,32,1 %;
macro KA0802$L_APC_MEM_BANK_01 = 24832,0,32,1 %;
macro KA0802$L_APC_MEM_BANK_23 = 24864,0,32,1 %;
macro KA0802$L_APC_MEM_BANK_45 = 24896,0,32,1 %;
macro KA0802$L_APC_MEM_BANK_67 = 24928,0,32,1 %;
macro KA0802$L_APC_MEM_CONTROL = 24960,0,32,1 %;
macro KA0802$L_APC_EXT_PC_HOLE = 25024,0,32,1 %;
macro KA0802$L_APC_EXT_PROG_HOLE = 25056,0,32,1 %;
macro KA0802$L_APC_DIAG_CONTROL = 25088,0,32,1 %;
macro KA0802$L_APC_DIAG_DATA0 = 25216,0,32,1 %;
macro KA0802$L_APC_DIAG_DATA1 = 25280,0,32,1 %;
macro KA0802$L_APC_REV_LEVEL = 25344,0,32,1 %;
macro KA0802$L_APC_PARITY_CONTROL = 25408,0,32,1 %;
macro KA0802$L_APC_SM_ADDRESS = 25600,0,32,1 %;
macro KA0802$L_APC_SM_DATA = 25664,0,32,1 %;
 
!*** MODULE $KA0902DEF ***
literal KA0902$K_MAX_CPU_MODULES = 4;
literal KA0902$K_MAX_MEMORY_MODULES = 4;
literal KA0902$K_OPDRIVER_RCV_ISR = 6;
literal KA0902$K_OPDRIVER_XMT_ISR = 15;
literal KA0902_IIO$M_IOCSR_EN_LDEN = %X'1';
literal KA0902_IIO$M_IOCSR_EL = %X'2';
literal KA0902_IIO$M_IOCSR_ESMV = %X'4';
literal KA0902_IIO$M_IOCSR_PDBP = %X'8';
literal KA0902_IIO$M_IOCSR_PCIPRST0 = %X'10';
literal KA0902_IIO$M_IOCSR_PCIPRST1 = %X'20';
literal KA0902_IIO$M_IOCSR_CAWWP0 = %X'1000';
literal KA0902_IIO$M_IOCSR_CAWWP2 = %X'2000';
literal KA0902_IIO$M_IOCSR_DWWPE = %X'4000';
literal KA0902_IIO$M_IOCSR_PDWWP1 = %X'100000';
literal KA0902_IIO$M_IOCSR_PDWWP0 = %X'200000';
literal KA0902_IIO$M_IOCSR_PBR = %X'400000';
literal KA0902_IIO$M_IOCSR_PIR = %X'800000';
literal KA0902_IIO$M_IOCSR_ENCOI = %X'1000000';
literal KA0902_IIO$M_IOCSR_EPMS = %X'2000000';
literal KA0902_IIO$M_IOCSR_ETLB = %X'4000000';
literal KA0902_IIO$M_IOCSR_EACC = %X'8000000';
literal KA0902_IIO$M_IOCSR_FTLB = %X'10000000';
literal KA0902_IIO$M_IOCSR_ECPC = %X'20000000';
literal KA0902_IIO$M_IOCSR_CIR = %X'40000000';
literal KA0902_IIO$M_IOCSR_EPL = %X'80000000';
literal KA0902_IIO$M_IOCSR_CBBCE = %X'1';
literal KA0902_IIO$M_IOCSR_TRN = %X'E';
literal KA0902_IIO$M_IOCSR_SMVL = %X'70';
literal KA0902_IIO$M_IOCSR_EPR = %X'100';
literal KA0902_IIO$M_IOCSR_CAWWP1 = %X'1000';
literal KA0902_IIO$M_IOCSR_CAWWP3 = %X'2000';
literal KA0902_IIO$M_IOCSR_DWWPO = %X'4000';
literal KA0902_IIO$M_IOCSR_PRM = %X'100000';
literal KA0902_IIO$M_IOCSR_PWM = %X'200000';
literal KA0902_IIO$M_IOCSR_FPRDPED = %X'400000';
literal KA0902_IIO$M_IOCSR_FPADPED = %X'800000';
literal KA0902_IIO$M_IOCSR_FPWDPED = %X'1000000';
literal KA0902_IIO$M_IOCSR_EPNMI = %X'2000000';
literal KA0902_IIO$M_IOCSR_EPDTI = %X'4000000';
literal KA0902_IIO$M_IOCSR_EPSEI = %X'8000000';
literal KA0902_IIO$M_IOCSR_EPPEI = %X'10000000';
literal KA0902_IIO$M_IOCSR_ERDPC = %X'20000000';
literal KA0902_IIO$M_IOCSR_EPADPC = %X'40000000';
literal KA0902_IIO$M_IOCSR_EWDPC = %X'80000000';
literal KA0902_IIO$M_CERR1_URE = %X'1';
literal KA0902_IIO$M_CERR1_NAE = %X'2';
literal KA0902_IIO$M_CERR1_CAPE = %X'4';
literal KA0902_IIO$M_CERR1_MCAPE = %X'8';
literal KA0902_IIO$M_CERR1_RWDPE = %X'10';
literal KA0902_IIO$M_CERR1_MWRPE = %X'20';
literal KA0902_IIO$M_CERR1_RDPE = %X'40';
literal KA0902_IIO$M_CERR1_MRDPE = %X'80';
literal KA0902_IIO$M_CERR1_CAPE0 = %X'100';
literal KA0902_IIO$M_CERR1_CAPE2 = %X'200';
literal KA0902_IIO$M_CERR1_DPE0 = %X'400';
literal KA0902_IIO$M_CERR1_DPE2 = %X'800';
literal KA0902_IIO$M_CERR1_DPE4 = %X'1000';
literal KA0902_IIO$M_CERR1_DPE6 = %X'2000';
literal KA0902_IIO$M_CERR1_CWDP = %X'10000';
literal KA0902_IIO$M_CERR1_BSE = %X'20000';
literal KA0902_IIO$M_CERR1_IPFNE = %X'40000';
literal KA0902_IIO$M_CERR1_CAPE1 = %X'100';
literal KA0902_IIO$M_CERR1_CAPE3 = %X'200';
literal KA0902_IIO$M_CERR1_DPE1 = %X'400';
literal KA0902_IIO$M_CERR1_DPE3 = %X'800';
literal KA0902_IIO$M_CERR1_DPE5 = %X'1000';
literal KA0902_IIO$M_CERR1_DPE7 = %X'2000';
literal KA0902_IIO$M_CERR3_L = %X'FFFFFFFF';
literal KA0902_IIO$M_CERR3_H = %X'FFFFFFFF00000000';
literal KA0902_IIO$M_CERR1_PWDPE = %X'1';
literal KA0902_IIO$M_CERR1_PAPE = %X'2';
literal KA0902_IIO$M_CERR1_PRDPE = %X'4';
literal KA0902_IIO$M_CERR1_PPE = %X'8';
literal KA0902_IIO$M_CERR1_PSE = %X'10';
literal KA0902_IIO$M_CERR1_PDTE = %X'20';
literal KA0902_IIO$M_CERR1_NMI = %X'40';
literal KA0902_IIO$M_PSCM_L = %X'FFFFFFFF';
literal KA0902_IIO$M_PSCM_H = %X'FFFFFFFF00000000';
literal KA0902_IIO$M_HBASE_PHE1 = %X'2000';
literal KA0902_IIO$M_HBASE_PHE2 = %X'4000';
literal KA0902_IIO$M_WBASE1_SGE = %X'40000';
literal KA0902_IIO$M_WBASE1_PWE = %X'80000';
literal KA0902_IIO$M_WBASE2_SGE = %X'40000';
literal KA0902_IIO$M_WBASE2_PWE = %X'80000';
literal KA0902_IIO$M_TLBBR_TLBBV = %X'1';
literal KA0902_IIO$M_TLBBR_TLBBD = %X'7FFFE';
literal KA0902_IIO$M_IVRPR_PRVECT = %X'FF';
literal KA0902_IIO$M_IVRPR_IA = %X'3FFFF';
literal KA0902_IIO$M_HAE3_CFG_TYPE = %X'C0000000';
literal KA0902_IIO$M_TDR0_TLBTD0 = %X'3FFFF';
literal KA0902_IIO$M_TDR0_TLBV0 = %X'1';
literal KA0902_IIO$M_TDR0_TLBPFN = %X'7FFFE';
literal KA0902_IIO$M_TDR1_TLBTD1 = %X'3FFFF';
literal KA0902_IIO$M_TDR1_TLBV1 = %X'1';
literal KA0902_IIO$M_TDR1_TLBPFN = %X'7FFFE';
literal KA0902_IIO$M_TDR2_TLBTD2 = %X'3FFFF';
literal KA0902_IIO$M_TDR2_TLBV2 = %X'1';
literal KA0902_IIO$M_TDR2_TLBPFN = %X'7FFFE';
literal KA0902_IIO$M_TDR3_TLBTD3 = %X'3FFFF';
literal KA0902_IIO$M_TDR3_TLBV3 = %X'1';
literal KA0902_IIO$M_TDR3_TLBPFN = %X'7FFFE';
literal KA0902_IIO$M_TDR4_TLBTD4 = %X'3FFFF';
literal KA0902_IIO$M_TDR4_TLBV4 = %X'1';
literal KA0902_IIO$M_TDR4_TLBPFN = %X'7FFFE';
literal KA0902_IIO$M_TDR5_TLBTD5 = %X'3FFFF';
literal KA0902_IIO$M_TDR5_TLBV5 = %X'1';
literal KA0902_IIO$M_TDR5_TLBPFN = %X'7FFFE';
literal KA0902_IIO$M_TDR6_TLBTD6 = %X'3FFFF';
literal KA0902_IIO$M_TDR6_TLBV6 = %X'1';
literal KA0902_IIO$M_TDR6_TLBPFN = %X'7FFFE';
literal KA0902_IIO$M_TDR7_TLBTD7 = %X'3FFFF';
literal KA0902_IIO$M_TDR7_TLBV7 = %X'1';
literal KA0902_IIO$M_TDR7_TLBPFN = %X'7FFFE';
literal KA0902_IIO$M_IVR_IV = %X'FF';
literal KA0902_IIO$S_KA0902_IIO = 1160;
!  I/O control/status register
macro KA0902_IIO$Q_IOCSR = 0,0,0,1 %;
literal KA0902_IIO$S_IOCSR = 8;
macro KA0902_IIO$L_IOCSR_L = 0,0,32,0 %;
macro KA0902_IIO$V_IOCSR_EN_LDEN = 0,0,1,0 %;
macro KA0902_IIO$V_IOCSR_EL = 0,1,1,0 %; !  Enable loopback
macro KA0902_IIO$V_IOCSR_ESMV = 0,2,1,0 %; !  State Machine Visibility 
macro KA0902_IIO$V_IOCSR_PDBP = 0,3,1,0 %; !  Drive PCI bad parity
macro KA0902_IIO$V_IOCSR_PCIPRST0 = 0,4,1,0 %; !  PCI slot 0 present
macro KA0902_IIO$V_IOCSR_PCIPRST1 = 0,5,1,0 %; !  PCI slot 0 present
macro KA0902_IIO$V_IOCSR_CAWWP0 = 0,12,1,0 %; !  Write CBUS C/A bad parity
macro KA0902_IIO$V_IOCSR_CAWWP2 = 0,13,1,0 %; !  Write CBUS C/A bad parity
macro KA0902_IIO$V_IOCSR_DWWPE = 0,14,1,0 %; !  Write CBUS even bad parity
macro KA0902_IIO$V_IOCSR_PDWWP1 = 0,20,1,0 %; !  Write CBUS DMA bad parity
macro KA0902_IIO$V_IOCSR_PDWWP0 = 0,21,1,0 %; !  Write CBUS DMA bad parity
macro KA0902_IIO$V_IOCSR_PBR = 0,22,1,0 %; !  PCI bus reset
macro KA0902_IIO$V_IOCSR_PIR = 0,23,1,0 %; !  PCI interface reset
macro KA0902_IIO$V_IOCSR_ENCOI = 0,24,1,0 %; !  Enable NOACK,CUCERR,SYNC
macro KA0902_IIO$V_IOCSR_EPMS = 0,25,1,0 %; !  Enable PCI memory space
macro KA0902_IIO$V_IOCSR_ETLB = 0,26,1,0 %; !  Enable Translation buffer
macro KA0902_IIO$V_IOCSR_EACC = 0,27,1,0 %; !  Enable atomic CBUS cycles
macro KA0902_IIO$V_IOCSR_FTLB = 0,28,1,0 %; !  Flush Translation buffer
macro KA0902_IIO$V_IOCSR_ECPC = 0,29,1,0 %; !  Enable CBUS parity check
macro KA0902_IIO$V_IOCSR_CIR = 0,30,1,0 %; !  CBUS interface reset
macro KA0902_IIO$V_IOCSR_EPL = 0,31,1,0 %; !  Enable PCI lock
macro KA0902_IIO$L_IOCSR_H = 4,0,32,0 %;
macro KA0902_IIO$V_IOCSR_CBBCE = 4,0,1,0 %; !  Enable CBUS back-to-back
macro KA0902_IIO$V_IOCSR_TRN = 4,1,3,0 %;
literal KA0902_IIO$S_IOCSR_TRN = 3;     !  T2 revision number
macro KA0902_IIO$V_IOCSR_SMVL = 4,4,3,0 %;
literal KA0902_IIO$S_IOCSR_SMVL = 3;    !  State machine select
macro KA0902_IIO$V_IOCSR_EPR = 4,8,1,0 %; !  Enable passive release
macro KA0902_IIO$V_IOCSR_CAWWP1 = 4,12,1,0 %; !  CBUS C/A bad parity 1
macro KA0902_IIO$V_IOCSR_CAWWP3 = 4,13,1,0 %; !  CBUS C/A bad parity 3
macro KA0902_IIO$V_IOCSR_DWWPO = 4,14,1,0 %; !  CBUS data parity odd
macro KA0902_IIO$V_IOCSR_PRM = 4,20,1,0 %; !  PCI read multiple
macro KA0902_IIO$V_IOCSR_PWM = 4,21,1,0 %; !  PCI write multiple
macro KA0902_IIO$V_IOCSR_FPRDPED = 4,22,1,0 %; !  PCI Force RDPE detect
macro KA0902_IIO$V_IOCSR_FPADPED = 4,23,1,0 %; !  PCI Force APE detect
macro KA0902_IIO$V_IOCSR_FPWDPED = 4,24,1,0 %; !  PCI Force RWPE detect
macro KA0902_IIO$V_IOCSR_EPNMI = 4,25,1,0 %; !  PCI enable NMI
macro KA0902_IIO$V_IOCSR_EPDTI = 4,26,1,0 %; !  PCI enable DTI
macro KA0902_IIO$V_IOCSR_EPSEI = 4,27,1,0 %; !  PCI enable SERR interrupt
macro KA0902_IIO$V_IOCSR_EPPEI = 4,28,1,0 %; !  PCI enable PERR interrupt
macro KA0902_IIO$V_IOCSR_ERDPC = 4,29,1,0 %; !  PCI enable RDPE interrupt
macro KA0902_IIO$V_IOCSR_EPADPC = 4,30,1,0 %; !  PCI enable addr parity int.
macro KA0902_IIO$V_IOCSR_EWDPC = 4,31,1,0 %; !  PCI enable WD parity int.
!  Cbus error register 1
macro KA0902_IIO$Q_CERR1 = 32,0,0,1 %;
literal KA0902_IIO$S_CERR1 = 8;
macro KA0902_IIO$L_CERR1_L = 32,0,32,0 %;
macro KA0902_IIO$V_CERR1_URE = 32,0,1,0 %; !  Uncorrectable read error
macro KA0902_IIO$V_CERR1_NAE = 32,1,1,0 %; !  No acknowledge error
macro KA0902_IIO$V_CERR1_CAPE = 32,2,1,0 %; !  Command address parity error even
macro KA0902_IIO$V_CERR1_MCAPE = 32,3,1,0 %; !  Missed command address parity error even
macro KA0902_IIO$V_CERR1_RWDPE = 32,4,1,0 %; !  Write data parity error even
macro KA0902_IIO$V_CERR1_MWRPE = 32,5,1,0 %; !  Missed write data parity error even
macro KA0902_IIO$V_CERR1_RDPE = 32,6,1,0 %; !  Read data parity error even
macro KA0902_IIO$V_CERR1_MRDPE = 32,7,1,0 %; !  Missed read data parity error even
macro KA0902_IIO$V_CERR1_CAPE0 = 32,8,1,0 %; !  C/A parity error longword 0
macro KA0902_IIO$V_CERR1_CAPE2 = 32,9,1,0 %; !  C/A parity error longword 2
macro KA0902_IIO$V_CERR1_DPE0 = 32,10,1,0 %; !  Data parity error longword 0
macro KA0902_IIO$V_CERR1_DPE2 = 32,11,1,0 %; !  Data parity error longword 2
macro KA0902_IIO$V_CERR1_DPE4 = 32,12,1,0 %; !  Data parity error longword 4
macro KA0902_IIO$V_CERR1_DPE6 = 32,13,1,0 %; !  Data parity error longword 6
macro KA0902_IIO$V_CERR1_CWDP = 32,16,1,0 %; !  Command WDPE
macro KA0902_IIO$V_CERR1_BSE = 32,17,1,0 %; !  Bus sync error
macro KA0902_IIO$V_CERR1_IPFNE = 32,18,1,0 %; !  Invalid PFN
macro KA0902_IIO$L_CERR1_H = 36,0,32,0 %;
macro KA0902_IIO$V_CERR1_CAPE1 = 36,8,1,0 %; !  C/A parity error LW1
macro KA0902_IIO$V_CERR1_CAPE3 = 36,9,1,0 %; !  C/A parity error LW3
macro KA0902_IIO$V_CERR1_DPE1 = 36,10,1,0 %; !  Data parity error LW1
macro KA0902_IIO$V_CERR1_DPE3 = 36,11,1,0 %; !  Data parity error LW3
macro KA0902_IIO$V_CERR1_DPE5 = 36,12,1,0 %; !  Data parity error LW5
macro KA0902_IIO$V_CERR1_DPE7 = 36,13,1,0 %; !  Data parity error LW7
!  Cbus error register 2
macro KA0902_IIO$Q_CERR2 = 64,0,0,0 %;
literal KA0902_IIO$S_CERR2 = 8;
macro KA0902_IIO$L_CERR2_L = 64,0,32,0 %;
macro KA0902_IIO$L_CERR2_H = 68,0,32,0 %;
!  Cbus error register 3
macro KA0902_IIO$Q_CERR3 = 96,0,0,0 %;
literal KA0902_IIO$S_CERR3 = 8;
macro KA0902_IIO$V_CERR3_L = 96,0,32,0 %;
literal KA0902_IIO$S_CERR3_L = 32;
macro KA0902_IIO$V_CERR3_H = 100,0,32,0 %;
literal KA0902_IIO$S_CERR3_H = 32;
!  PCI error register 1
macro KA0902_IIO$Q_PERR1 = 128,0,0,1 %;
literal KA0902_IIO$S_PERR1 = 8;
macro KA0902_IIO$L_PERR1_L = 128,0,32,0 %;
macro KA0902_IIO$V_CERR1_PWDPE = 128,0,1,0 %; !  PCI write data parity error
macro KA0902_IIO$V_CERR1_PAPE = 128,1,1,0 %; !  PCI address parity error
macro KA0902_IIO$V_CERR1_PRDPE = 128,2,1,0 %; !  PCI read data parity error
macro KA0902_IIO$V_CERR1_PPE = 128,3,1,0 %; !  PCI parity error
macro KA0902_IIO$V_CERR1_PSE = 128,4,1,0 %; !  PCI system error
macro KA0902_IIO$V_CERR1_PDTE = 128,5,1,0 %; !  PCI device timeout error
macro KA0902_IIO$V_CERR1_NMI = 128,6,1,0 %; !  Non-maskable interrupt
macro KA0902_IIO$L_PERR1_H = 132,0,32,0 %;
!  PCI error register 2
macro KA0902_IIO$Q_PERR2 = 160,0,0,1 %;
literal KA0902_IIO$S_PERR2 = 8;
macro KA0902_IIO$L_PERR2_L = 160,0,32,0 %;
macro KA0902_IIO$V_PERR2_PEA = 160,0,32,0 %;
literal KA0902_IIO$S_PERR2_PEA = 32;    !  PCI error address
macro KA0902_IIO$L_PERR2_H = 164,0,32,0 %;
macro KA0902_IIO$V_PERR2_PEC = 164,0,5,0 %;
literal KA0902_IIO$S_PERR2_PEC = 5;     !  PCI error command
!  PCI special cycle register
macro KA0902_IIO$Q_PSCM = 192,0,0,0 %;
literal KA0902_IIO$S_PSCM = 8;
macro KA0902_IIO$V_PSCM_L = 192,0,32,0 %;
literal KA0902_IIO$S_PSCM_L = 32;
macro KA0902_IIO$V_PSCM_H = 196,0,32,0 %;
literal KA0902_IIO$S_PSCM_H = 32;
!  High Address Extension register 1
macro KA0902_IIO$Q_HAE1 = 224,0,0,1 %;
literal KA0902_IIO$S_HAE1 = 8;
macro KA0902_IIO$L_HAE1_L = 224,0,32,0 %;
macro KA0902_IIO$V_HAE1_PUA1 = 224,0,5,0 %;
literal KA0902_IIO$S_HAE1_PUA1 = 5;     !  PCI upper address
macro KA0902_IIO$L_HAE1_H = 228,0,32,0 %;
!  High Address Extension register 2
macro KA0902_IIO$Q_HAE2 = 256,0,0,1 %;
literal KA0902_IIO$S_HAE2 = 8;
macro KA0902_IIO$L_HAE2_L = 256,0,32,0 %;
macro KA0902_IIO$V_HAE2_PUA2 = 256,0,9,0 %;
literal KA0902_IIO$S_HAE2_PUA2 = 9;     !  PCI upper address
macro KA0902_IIO$L_HAE2_H = 260,0,32,0 %;
!  PCI Hole base register
macro KA0902_IIO$Q_HBASE = 288,0,0,1 %;
literal KA0902_IIO$S_HBASE = 8;
macro KA0902_IIO$L_HBASE_L = 288,0,32,0 %;
macro KA0902_IIO$V_HBASE_PHEA = 288,0,9,0 %;
literal KA0902_IIO$S_HBASE_PHEA = 9;    !  PCI hole end address
macro KA0902_IIO$V_HBASE_PHE1 = 288,13,1,0 %; !  PCI hole enable 1
macro KA0902_IIO$V_HBASE_PHE2 = 288,14,1,0 %; !  PCI hole enable 2
macro KA0902_IIO$V_HBASE_PHSA = 288,15,9,0 %;
literal KA0902_IIO$S_HBASE_PHSA = 9;    !  PCI hole start address
macro KA0902_IIO$L_HBASE_H = 292,0,32,0 %;
!  PCI Window base register 1
macro KA0902_IIO$Q_WBASE1 = 320,0,0,1 %;
literal KA0902_IIO$S_WBASE1 = 8;
macro KA0902_IIO$L_WBASE1_L = 320,0,32,0 %;
macro KA0902_IIO$V_WBASE1_PWEA = 320,0,12,0 %;
literal KA0902_IIO$S_WBASE1_PWEA = 12;  !  PCI window end address
macro KA0902_IIO$V_WBASE1_SGE = 320,18,1,0 %; !  PCI Scatter-Gather enabled
macro KA0902_IIO$V_WBASE1_PWE = 320,19,1,0 %; !  PCI window enable
macro KA0902_IIO$V_WBASE1_PWSA = 320,20,12,0 %;
literal KA0902_IIO$S_WBASE1_PWSA = 12;  !  PCI window start address
macro KA0902_IIO$L_WBASE1_H = 324,0,32,0 %;
!  PCI Window mask register 1
macro KA0902_IIO$Q_WMASK1 = 352,0,0,1 %;
literal KA0902_IIO$S_WMASK1 = 8;
macro KA0902_IIO$L_WMASK1_L = 352,0,32,0 %;
macro KA0902_IIO$V_WMASK1_PWM = 352,20,11,0 %;
literal KA0902_IIO$S_WMASK1_PWM = 11;   !  PCI window mask
macro KA0902_IIO$L_WMASK1_H = 356,0,32,0 %;
!  PCI Translated Base register 1
macro KA0902_IIO$Q_TBASE1 = 384,0,0,1 %;
literal KA0902_IIO$S_TBASE1 = 8;
macro KA0902_IIO$L_TBASE1_L = 384,0,32,0 %;
macro KA0902_IIO$V_TBASE1_TBA = 384,9,22,0 %;
literal KA0902_IIO$S_TBASE1_TBA = 22;   !  PCI Translated Base
macro KA0902_IIO$L_TBASE1_H = 388,0,32,0 %;
!  PCI Window base register 2
macro KA0902_IIO$Q_WBASE2 = 416,0,0,1 %;
literal KA0902_IIO$S_WBASE2 = 8;
macro KA0902_IIO$L_WBASE2_L = 416,0,32,0 %;
macro KA0902_IIO$V_WBASE2_PWEA = 416,0,12,0 %;
literal KA0902_IIO$S_WBASE2_PWEA = 12;  !  PCI window end address
macro KA0902_IIO$V_WBASE2_SGE = 416,18,1,0 %; !  PCI Scatter-Gather enabled
macro KA0902_IIO$V_WBASE2_PWE = 416,19,1,0 %; !  PCI window enable
macro KA0902_IIO$V_WBASE2_PWSA = 416,20,12,0 %;
literal KA0902_IIO$S_WBASE2_PWSA = 12;  !  PCI window start address
macro KA0902_IIO$L_WBASE2_H = 420,0,32,0 %;
!  PCI Window mask register 2
macro KA0902_IIO$Q_WMASK2 = 448,0,0,1 %;
literal KA0902_IIO$S_WMASK2 = 8;
macro KA0902_IIO$L_WMASK2_L = 448,0,32,0 %;
macro KA0902_IIO$V_WMASK2_PWM = 448,20,11,0 %;
literal KA0902_IIO$S_WMASK2_PWM = 11;   !  PCI window mask
macro KA0902_IIO$L_WMASK2_H = 452,0,32,0 %;
!  PCI Translated Base register 2
macro KA0902_IIO$Q_TBASE2 = 480,0,0,1 %;
literal KA0902_IIO$S_TBASE2 = 8;
macro KA0902_IIO$L_TBASE2_L = 480,0,32,0 %;
macro KA0902_IIO$V_TBASE2_TBA = 480,9,22,0 %;
literal KA0902_IIO$S_TBASE2_TBA = 22;   !  PCI Translated Base
macro KA0902_IIO$L_TBASE2_H = 484,0,32,0 %;
!  PCI TLB by-pass register
macro KA0902_IIO$Q_TLBBR = 512,0,0,1 %;
literal KA0902_IIO$S_TLBBR = 8;
macro KA0902_IIO$L_TLBBR_L = 512,0,32,0 %;
macro KA0902_IIO$V_TLBBR_TLBBV = 512,0,1,0 %; !  TLB by-pass valid
macro KA0902_IIO$V_TLBBR_TLBBD = 512,1,18,0 %;
literal KA0902_IIO$S_TLBBR_TLBBD = 18;  !  TLB by-pass data
macro KA0902_IIO$L_TLBBR_H = 516,0,32,0 %;
!  PCI Invalid Passive Release register
macro KA0902_IIO$Q_IVRPR = 544,0,0,1 %;
literal KA0902_IIO$S_IVRPR = 8;
macro KA0902_IIO$L_IVRPR_L = 544,0,32,0 %;
macro KA0902_IIO$V_IVRPR_PRVECT = 544,0,8,0 %;
literal KA0902_IIO$S_IVRPR_PRVECT = 8;  !  Passive release vec
macro KA0902_IIO$L_IVRPR_H = 548,0,32,0 %;
macro KA0902_IIO$V_IVRPR_IA = 548,0,18,0 %;
literal KA0902_IIO$S_IVRPR_IA = 18;     !  Interrupt address
!  High Address Extension register 3
macro KA0902_IIO$Q_HAE3 = 576,0,0,1 %;
literal KA0902_IIO$S_HAE3 = 8;
macro KA0902_IIO$L_HAE3_L = 576,0,32,0 %;
macro KA0902_IIO$V_HAE3_CFG_TYPE = 576,30,2,0 %;
literal KA0902_IIO$S_HAE3_CFG_TYPE = 2;
macro KA0902_IIO$L_HAE3_H = 580,0,32,0 %;
!  High Address Extension register 4
macro KA0902_IIO$Q_HAE4 = 608,0,0,1 %;
literal KA0902_IIO$S_HAE4 = 8;
macro KA0902_IIO$L_HAE4_L = 608,0,32,0 %;
macro KA0902_IIO$V_HAE4_PUA = 608,0,2,0 %;
literal KA0902_IIO$S_HAE4_PUA = 2;      !  PCI upper address
macro KA0902_IIO$L_HAE4_H = 612,0,32,0 %;
!  TLB data register 0
macro KA0902_IIO$Q_TDR0 = 768,0,0,1 %;
literal KA0902_IIO$S_TDR0 = 8;
macro KA0902_IIO$L_TDR0_L = 768,0,32,0 %;
macro KA0902_IIO$V_TDR0_TLBTD0 = 768,0,18,0 %;
literal KA0902_IIO$S_TDR0_TLBTD0 = 18;  !  Tag for TLB entry 0
macro KA0902_IIO$L_TDR0_H = 772,0,32,0 %;
macro KA0902_IIO$V_TDR0_TLBV0 = 772,0,1,0 %; !  Valid tag for TLB 0
macro KA0902_IIO$V_TDR0_TLBPFN = 772,1,18,0 %;
literal KA0902_IIO$S_TDR0_TLBPFN = 18;  !  PFN for TLB 0
!  TLB data register 1
macro KA0902_IIO$Q_TDR1 = 800,0,0,1 %;
literal KA0902_IIO$S_TDR1 = 8;
macro KA0902_IIO$L_TDR1_L = 800,0,32,0 %;
macro KA0902_IIO$V_TDR1_TLBTD1 = 800,0,18,0 %;
literal KA0902_IIO$S_TDR1_TLBTD1 = 18;  !  Tag for TLB entry 1
macro KA0902_IIO$L_TDR1_H = 804,0,32,0 %;
macro KA0902_IIO$V_TDR1_TLBV1 = 804,0,1,0 %; !  Valid tag for TLB 1
macro KA0902_IIO$V_TDR1_TLBPFN = 804,1,18,0 %;
literal KA0902_IIO$S_TDR1_TLBPFN = 18;  !  PFN for TLB 1
!  TLB data register 2
macro KA0902_IIO$Q_TDR2 = 832,0,0,1 %;
literal KA0902_IIO$S_TDR2 = 8;
macro KA0902_IIO$L_TDR2_L = 832,0,32,0 %;
macro KA0902_IIO$V_TDR2_TLBTD2 = 832,0,18,0 %;
literal KA0902_IIO$S_TDR2_TLBTD2 = 18;  !  Tag for TLB entry 2
macro KA0902_IIO$L_TDR2_H = 836,0,32,0 %;
macro KA0902_IIO$V_TDR2_TLBV2 = 836,0,1,0 %; !  Valid tag for TLB 2
macro KA0902_IIO$V_TDR2_TLBPFN = 836,1,18,0 %;
literal KA0902_IIO$S_TDR2_TLBPFN = 18;  !  PFN for TLB 2
!  TLB data register 3
macro KA0902_IIO$Q_TDR3 = 864,0,0,1 %;
literal KA0902_IIO$S_TDR3 = 8;
macro KA0902_IIO$L_TDR3_L = 864,0,32,0 %;
macro KA0902_IIO$V_TDR3_TLBTD3 = 864,0,18,0 %;
literal KA0902_IIO$S_TDR3_TLBTD3 = 18;  !  Tag for TLB entry 3
macro KA0902_IIO$L_TDR3_H = 868,0,32,0 %;
macro KA0902_IIO$V_TDR3_TLBV3 = 868,0,1,0 %; !  Valid tag for TLB 3
macro KA0902_IIO$V_TDR3_TLBPFN = 868,1,18,0 %;
literal KA0902_IIO$S_TDR3_TLBPFN = 18;  !  PFN for TLB 3
!  TLB data register 4
macro KA0902_IIO$Q_TDR4 = 896,0,0,1 %;
literal KA0902_IIO$S_TDR4 = 8;
macro KA0902_IIO$L_TDR4_L = 896,0,32,0 %;
macro KA0902_IIO$V_TDR4_TLBTD4 = 896,0,18,0 %;
literal KA0902_IIO$S_TDR4_TLBTD4 = 18;  !  Tag for TLB entry 4
macro KA0902_IIO$L_TDR4_H = 900,0,32,0 %;
macro KA0902_IIO$V_TDR4_TLBV4 = 900,0,1,0 %; !  Valid tag for TLB 4
macro KA0902_IIO$V_TDR4_TLBPFN = 900,1,18,0 %;
literal KA0902_IIO$S_TDR4_TLBPFN = 18;  !  PFN for TLB 4
!  TLB data register 5
macro KA0902_IIO$Q_TDR5 = 928,0,0,1 %;
literal KA0902_IIO$S_TDR5 = 8;
macro KA0902_IIO$L_TDR5_L = 928,0,32,0 %;
macro KA0902_IIO$V_TDR5_TLBTD5 = 928,0,18,0 %;
literal KA0902_IIO$S_TDR5_TLBTD5 = 18;  !  Tag for TLB entry 5
macro KA0902_IIO$L_TDR5_H = 932,0,32,0 %;
macro KA0902_IIO$V_TDR5_TLBV5 = 932,0,1,0 %; !  Valid tag for TLB 5
macro KA0902_IIO$V_TDR5_TLBPFN = 932,1,18,0 %;
literal KA0902_IIO$S_TDR5_TLBPFN = 18;  !  PFN for TLB 5
!  TLB data register 6
macro KA0902_IIO$Q_TDR6 = 960,0,0,1 %;
literal KA0902_IIO$S_TDR6 = 8;
macro KA0902_IIO$L_TDR6_L = 960,0,32,0 %;
macro KA0902_IIO$V_TDR6_TLBTD6 = 960,0,18,0 %;
literal KA0902_IIO$S_TDR6_TLBTD6 = 18;  !  Tag for TLB entry 6
macro KA0902_IIO$L_TDR6_H = 964,0,32,0 %;
macro KA0902_IIO$V_TDR6_TLBV6 = 964,0,1,0 %; !  Valid tag for TLB 6
macro KA0902_IIO$V_TDR6_TLBPFN = 964,1,18,0 %;
literal KA0902_IIO$S_TDR6_TLBPFN = 18;  !  PFN for TLB 6
!  TLB data register 7
macro KA0902_IIO$Q_TDR7 = 992,0,0,1 %;
literal KA0902_IIO$S_TDR7 = 8;
macro KA0902_IIO$L_TDR7_L = 992,0,32,0 %;
macro KA0902_IIO$V_TDR7_TLBTD7 = 992,0,18,0 %;
literal KA0902_IIO$S_TDR7_TLBTD7 = 18;  !  Tag for TLB entry 7
macro KA0902_IIO$L_TDR7_H = 996,0,32,0 %;
macro KA0902_IIO$V_TDR7_TLBV7 = 996,0,1,0 %; !  Valid tag for TLB 7
macro KA0902_IIO$V_TDR7_TLBPFN = 996,1,18,0 %;
literal KA0902_IIO$S_TDR7_TLBPFN = 18;  !  PFN for TLB 7
!  Interrupt vector register
macro KA0902_IIO$Q_IVR = 1152,0,0,1 %;
literal KA0902_IIO$S_IVR = 8;
macro KA0902_IIO$L_IVR_L = 1152,0,32,0 %;
macro KA0902_IIO$V_IVR_IV = 1152,0,8,0 %;
literal KA0902_IIO$S_IVR_IV = 8;        !  PCI or EISA vector
macro KA0902_IIO$L_IVR_H = 1156,0,32,0 %;
literal KA0902_IIO$K_LENGTH = 1160;
!                   
!  Sable CPU register definitions
! 
literal KA0902_CPU$M_BCC_ENB_ALLOC_L = %X'1';
literal KA0902_CPU$M_BCC_FRC_FILL_SH_L = %X'2';
literal KA0902_CPU$M_BCC_ENB_TPC_L = %X'4';
literal KA0902_CPU$M_BCC_FILL_WTP_L = %X'8';
literal KA0902_CPU$M_BCC_FILL_WCP_L = %X'10';
literal KA0902_CPU$M_BCC_FILL_WDTP_L = %X'20';
literal KA0902_CPU$M_BCC_ENB_CEI_L = %X'40';
literal KA0902_CPU$M_BCC_ENB_EDCC_L = %X'80';
literal KA0902_CPU$M_BCC_ENB_EDC_CHK_L = %X'100';
literal KA0902_CPU$M_BCC_ENB_BC_CIO_L = %X'200';
literal KA0902_CPU$M_BCC_DIS_BLK_W_L = %X'400';
literal KA0902_CPU$M_BCC_ENB_BC_INIT_L = %X'800';
literal KA0902_CPU$M_BCC_FOR_EDCC_L = %X'1000';
literal KA0902_CPU$M_BCC_SH_D_V_L = %X'E000';
literal KA0902_CPU$M_BCC_EDC_L = %X'3FFF0000';
literal KA0902_CPU$M_BCC_CACHE_SIZE_L = %X'C0000000';
literal KA0902_CPU$M_BCC_ENB_ALLOC_H = %X'1';
literal KA0902_CPU$M_BCC_FRC_FILL_SH_H = %X'2';
literal KA0902_CPU$M_BCC_ENB_TPC_H = %X'4';
literal KA0902_CPU$M_BCC_FILL_WTP_H = %X'8';
literal KA0902_CPU$M_BCC_FILL_WCP_H = %X'10';
literal KA0902_CPU$M_BCC_FILL_WDTP_H = %X'20';
literal KA0902_CPU$M_BCC_ENB_CEI_H = %X'40';
literal KA0902_CPU$M_BCC_ENB_EDCC_H = %X'80';
literal KA0902_CPU$M_BCC_ENB_EDC_CHK_H = %X'100';
literal KA0902_CPU$M_BCC_ENB_BC_CIO_H = %X'200';
literal KA0902_CPU$M_BCC_DIS_BLK_W_H = %X'400';
literal KA0902_CPU$M_BCC_ENB_BC_INIT_H = %X'800';
literal KA0902_CPU$M_BCC_FOR_EDCC_H = %X'1000';
literal KA0902_CPU$M_BCC_SH_D_V_H = %X'E000';
literal KA0902_CPU$M_BCC_EDC_L_H = %X'3FFF0000';
literal KA0902_CPU$M_BCC_CACHE_SIZE_H = %X'C0000000';
literal KA0902_BCC$K_RESERVED = 0;      !  Reserved
literal KA0902_BCC$K_CACHE_SIZE_1MB = 1; !  Cache size is 1Mb
literal KA0902_BCC$K_CACHE_SIZE_4MB = 2; !  Cache size is 4Mb
literal KA0902_CPU$M_BCCE_MCE_L = %X'4';
literal KA0902_CPU$M_BCCE_CE_L = %X'8';
literal KA0902_CPU$M_BCCE_CNTRL_PAR_L = %X'100';
literal KA0902_CPU$M_BCCE_SH_L = %X'200';
literal KA0902_CPU$M_BCCE_DIRTY_L = %X'400';
literal KA0902_CPU$M_BCCE_VALID_L = %X'800';
literal KA0902_CPU$M_BCCE_BC_EDC_L = %X'20000';
literal KA0902_CPU$M_BCCE_EDC_SYND_0 = %X'1FC0000';
literal KA0902_CPU$M_BCCE_EDC_SYND_2 = %X'FE000000';
literal KA0902_CPU$M_BCCE_MCE_H = %X'4';
literal KA0902_CPU$M_BCCE_CE_H = %X'8';
literal KA0902_CPU$M_BCCE_READ_ONLY = %X'1FFF0';
literal KA0902_CPU$M_BCCE_BC_EDC_H = %X'20000';
literal KA0902_CPU$M_BCCE_EDC_SYND_1 = %X'1FC0000';
literal KA0902_CPU$M_BCCE_EDC_SYND_3 = %X'FE000000';
literal KA0902_CPU$M_BCCEA_BCMAP_OFF_L = %X'1FFFF';
literal KA0902_CPU$M_BCCEA_TAG_PAR_L = %X'40000';
literal KA0902_CPU$M_BCCEA_TAG_VALUE_L = %X'7FF80000';
literal KA0902_CPU$M_BCCEA_BCMAP_OFF_H = %X'1FFFF';
literal KA0902_CPU$M_BCCEA_TAG_PAR_H = %X'40000';
literal KA0902_CPU$M_BCCEA_TAG_VALUE_H = %X'7FF80000';
literal KA0902_CPU$M_BCUE_MPE_L = %X'1';
literal KA0902_CPU$M_BCUE_PE_L = %X'2';
literal KA0902_CPU$M_BCUE_MUNCE_L = %X'4';
literal KA0902_CPU$M_BCUE_UNCE_L = %X'8';
literal KA0902_CPU$M_BCUE_CTRL_PAR_L = %X'100';
literal KA0902_CPU$M_BCUE_SH_L = %X'200';
literal KA0902_CPU$M_BCUE_DIRTY_L = %X'400';
literal KA0902_CPU$M_BCUE_VALID_L = %X'800';
literal KA0902_CPU$M_BCUE_BC_EDC_L = %X'20000';
literal KA0902_CPU$M_BCUE_EDC_SYND_0 = %X'1FC0000';
literal KA0902_CPU$M_BCUE_EDC_SYND_2 = %X'FE000000';
literal KA0902_CPU$M_BCUE_MPE_H = %X'1';
literal KA0902_CPU$M_BCUE_PE_H = %X'2';
literal KA0902_CPU$M_BCUE_MUNCE_H = %X'4';
literal KA0902_CPU$M_BCUE_UNCE_H = %X'8';
literal KA0902_CPU$M_BCUE_BC_EDC_H = %X'20000';
literal KA0902_CPU$M_BCUE_EDC_SYND_1 = %X'1FC0000';
literal KA0902_CPU$M_BCUE_EDC_SYND_3 = %X'FE000000';
literal KA0902_CPU$M_BCUEA_BCMAP_OFF_L = %X'1FFFF';
literal KA0902_CPU$M_BCUEA_PTP_L = %X'20000';
literal KA0902_CPU$M_BCUEA_TP_L = %X'40000';
literal KA0902_CPU$M_BCUEA_TV_L = %X'7FF80000';
literal KA0902_CPU$M_BCUEA_FILL1_L = %X'80000000';
literal KA0902_CPU$M_BCUEA_BCMAP_OFF_H = %X'1FFFF';
literal KA0902_CPU$M_BCUEA_PTP_H = %X'20000';
literal KA0902_CPU$M_BCUEA_TP_H = %X'40000';
literal KA0902_CPU$M_BCUEA_TV_H = %X'7FF80000';
literal KA0902_CPU$M_BCUEA_FILL1_H = %X'80000000';
literal KA0902_CPU$M_DTER_MDTER_L = %X'1';
literal KA0902_CPU$M_DTER_DTER_L = %X'2';
literal KA0902_CPU$M_DTER_TOFF_L = %X'3FC';
literal KA0902_CPU$M_DTER_BANK0_TAG_L = %X'7FC00';
literal KA0902_CPU$M_DTER_BANK0_PAR_L = %X'80000';
literal KA0902_CPU$M_DTER_BANK1_TAG_L = %X'1FF00000';
literal KA0902_CPU$M_DTER_BANK1_PAR_L = %X'20000000';
literal KA0902_CPU$M_DTER_MDTER_H = %X'1';
literal KA0902_CPU$M_DTER_DTER_H = %X'2';
literal KA0902_CPU$M_DTER_TOFF_H = %X'3FC';
literal KA0902_CPU$M_DTER_BANK0_TAG_H = %X'7FC00';
literal KA0902_CPU$M_DTER_BANK0_PAR_H = %X'80000';
literal KA0902_CPU$M_DTER_BANK1_TAG_H = %X'1FF00000';
literal KA0902_CPU$M_DTER_BANK1_PAR_H = %X'20000000';
literal KA0902_CPU$M_CBCTL_DWP_L = %X'1';
literal KA0902_CPU$M_CBCTL_CAWP_L = %X'6';
literal KA0902_CPU$M_CBCTL_EPC_L = %X'8';
literal KA0902_CPU$M_CBCTL_FRC_SH_L = %X'10';
literal KA0902_CPU$M_CBCTL_CMDER_ID_L = %X'E0';
literal KA0902_CPU$M_CBCTL_ACM_L = %X'700';
literal KA0902_CPU$M_CBCTL_ENB_CI_L = %X'800';
literal KA0902_CPU$M_CBCTL_RD_L = %X'1000';
literal KA0902_CPU$M_CBCTL_QW_2_SEL_L = %X'2000';
literal KA0902_CPU$M_CBCTL_SEL_DRACK_L = %X'4000';
literal KA0902_CPU$M_CBCTL_DWP_H = %X'1';
literal KA0902_CPU$M_CBCTL_CAWP_H = %X'6';
literal KA0902_CPU$M_CBCTL_EPC_H = %X'8';
literal KA0902_CPU$M_CBCTL_FRC_SH_H = %X'10';
literal KA0902_CPU$M_CBCTL_CMDER_ID_H = %X'E0';
literal KA0902_CPU$M_CBCTL_ACM_H = %X'700';
literal KA0902_CPU$M_CBCTL_ENB_CI_H = %X'800';
literal KA0902_CPU$M_CBCTL_RD_H = %X'1000';
literal KA0902_CPU$M_CBCTL_QW_2_SEL_H = %X'2000';
literal KA0902_CPU$M_CBCTL_SEL_DRACK_H = %X'4000';
literal KA0902_CPU$M_CBE_DIAG_L = %X'2';
literal KA0902_CPU$M_CBE_CAP_L = %X'4';
literal KA0902_CPU$M_CBE_MCAP_L = %X'8';
literal KA0902_CPU$M_CBE_PE_WRD_L = %X'10';
literal KA0902_CPU$M_CBE_MPE_WRD_L = %X'20';
literal KA0902_CPU$M_CBE_PE_RD_L = %X'40';
literal KA0902_CPU$M_CBE_MPE_RD_L = %X'80';
literal KA0902_CPU$M_CBE_CA_PE_LW0 = %X'100';
literal KA0902_CPU$M_CBE_CA_PE_LW2 = %X'200';
literal KA0902_CPU$M_CBE_D_PE_LW0 = %X'400';
literal KA0902_CPU$M_CBE_D_PE_LW2 = %X'800';
literal KA0902_CPU$M_CBE_D_PE_LW4 = %X'1000';
literal KA0902_CPU$M_CBE_D_PE_LW6 = %X'2000';
literal KA0902_CPU$M_CBE_CA_NACK_L = %X'4000';
literal KA0902_CPU$M_CBE_WR_DATA_NACK_L = %X'8000';
literal KA0902_CPU$M_CBE_MCOUNT_L = %X'3F000000';
literal KA0902_CPU$M_CBE_MADR_VALID_L = %X'40000000';
literal KA0902_CPU$M_CBE_DIAG_H = %X'2';
literal KA0902_CPU$M_CBE_CAP_H = %X'4';
literal KA0902_CPU$M_CBE_MCAP_H = %X'8';
literal KA0902_CPU$M_CBE_PE_WRD_H = %X'10';
literal KA0902_CPU$M_CBE_MPE_WRD_H = %X'20';
literal KA0902_CPU$M_CBE_PE_RD_H = %X'40';
literal KA0902_CPU$M_CBE_MPE_RD_H = %X'80';
literal KA0902_CPU$M_CBE_CA_PE_LW1 = %X'100';
literal KA0902_CPU$M_CBE_CA_PE_LW3 = %X'200';
literal KA0902_CPU$M_CBE_D_PE_LW1 = %X'400';
literal KA0902_CPU$M_CBE_D_PE_LW3 = %X'800';
literal KA0902_CPU$M_CBE_D_PE_LW5 = %X'1000';
literal KA0902_CPU$M_CBE_D_PE_LW7 = %X'2000';
literal KA0902_CPU$M_CBE_UNDEFINED = %X'4000';
literal KA0902_CPU$M_CBE_UNDEFINED2 = %X'8000';
literal KA0902_CPU$M_CBE_MCOUNT_H = %X'3F000000';
literal KA0902_CPU$M_CBE_MADR_VALID_H = %X'40000000';
literal KA0902_CPU$M_CBEAL_SBO_L = %X'3';
literal KA0902_CPU$M_CBEAL_ADDR_CAD_L = %X'FFFFFFFC';
literal KA0902_CPU$M_CBEAL_SBO_H = %X'3';
literal KA0902_CPU$M_CBEAL_ADDR_CAD_H = %X'FFFFFFFC';
literal KA0902_CPU$M_CBEAH_SB0_L = %X'3';
literal KA0902_CPU$M_CBEAH_EA_L = %X'3FFFC';
literal KA0902_CPU$M_CBEAH_T_TYPE_L = %X'1C0000';
literal KA0902_CPU$M_CBEAH_CMDR_ID_L = %X'E00000';
literal KA0902_CPU$M_CBEAH_SB1_L = %X'FF000000';
literal KA0902_CPU$M_CBEAH_SB0_H = %X'3';
literal KA0902_CPU$M_CBEAH_EA_H = %X'3FFFC';
literal KA0902_CPU$M_CBEAH_T_TYPE_H = %X'1C0000';
literal KA0902_CPU$M_CBEAH_CMDR_ID_H = %X'E00000';
literal KA0902_CPU$M_CBEAH_SB1_H = %X'FF000000';
literal KA0902_CPU$M_PMBX_FILL1_L = %X'FFFFFFFF';
literal KA0902_CPU$M_PMBX_FILL1_H = %X'FFFFFFFF';
literal KA0902_CPU$M_IPIR_UNDEFINED = %X'1';
literal KA0902_CPU$M_IPIR_REQ_INT_CPU = %X'1';
literal KA0902_CPU$M_IPIR_REQ_NODE_HALT = %X'8';
literal KA0902_CPU$M_SIC_UNDEFINED0 = %X'1';
literal KA0902_CPU$M_SIC_UNDEFINED1 = %X'2';
literal KA0902_CPU$M_SIC_EIC = %X'4';
literal KA0902_CPU$M_SIC_UNDEFINED2 = %X'8';
literal KA0902_CPU$M_SIC_IT_ICLEAR = %X'1';
literal KA0902_CPU$M_SIC_SYS_EVT_CLR = %X'2';
literal KA0902_CPU$M_SIC_UNDEFINED3 = %X'4';
literal KA0902_CPU$M_SIC_NODE_HALT_CLR = %X'8';
literal KA0902_CPU$M_ADLK_LA_V_L = %X'1';
literal KA0902_CPU$M_ADLK_LA_L = %X'FFFFFFF8';
literal KA0902_CPU$M_ADLK_LA_V_H = %X'1';
literal KA0902_CPU$M_ADLK_LA_H = %X'FFFFFFF8';
literal KA0902_CPU$M_MADRL_VALID_L = %X'1';
literal KA0902_CPU$M_MADRL_T_TYPE_L = %X'2';
literal KA0902_CPU$M_MADRL_ADDRESS_L = %X'FFFFFFFC';
literal KA0902_CPU$M_MADRL_VALID_H = %X'1';
literal KA0902_CPU$M_MADRL_T_TYPE_H = %X'2';
literal KA0902_CPU$M_MADRL_ADDRESS_H = %X'FFFFFFFC';
literal KA0902_CPU$M_CRREVS_REV_L = %X'F';
literal KA0902_CPU$M_CRREVS_CPU_MODE_L = %X'10';
literal KA0902_CPU$M_CRREVS_C3_SPEED_L = %X'FE0';
literal KA0902_CPU$M_CRREVS_SB0_L = %X'1000';
literal KA0902_CPU$M_CRREVS_FILL1_L = %X'2000';
literal KA0902_CPU$M_CRREVS_IO_RETRY_L = %X'4000';
literal KA0902_CPU$M_CRREVS_PCH_INV_L = %X'200000';
literal KA0902_CPU$M_CRREVS_REV_H = %X'F';
literal KA0902_CPU$M_CRREVS_CPU_MODE_H = %X'10';
literal KA0902_CPU$M_CRREVS_C3_SPEED_H = %X'FE0';
literal KA0902_CPU$M_CRREVS_SB0_H = %X'1000';
literal KA0902_CPU$M_CRREVS_FILL1_H = %X'2000';
literal KA0902_CPU$M_CRREVS_IO_RETRY_H = %X'4000';
literal KA0902_CPU$M_CRREVS_PCH_INV_H = %X'200000';
literal KA0902_CPU$S_KA0902_CPU = 488;
!  B-Cache Control Register 0
macro KA0902_CPU$Q_BCC = 0,0,0,1 %;
literal KA0902_CPU$S_BCC = 8;
macro KA0902_CPU$L_BCC_L = 0,0,32,0 %;
macro KA0902_CPU$V_BCC_ENB_ALLOC_L = 0,0,1,0 %;
macro KA0902_CPU$V_BCC_FRC_FILL_SH_L = 0,1,1,0 %;
macro KA0902_CPU$V_BCC_ENB_TPC_L = 0,2,1,0 %;
macro KA0902_CPU$V_BCC_FILL_WTP_L = 0,3,1,0 %;
macro KA0902_CPU$V_BCC_FILL_WCP_L = 0,4,1,0 %;
macro KA0902_CPU$V_BCC_FILL_WDTP_L = 0,5,1,0 %;
macro KA0902_CPU$V_BCC_ENB_CEI_L = 0,6,1,0 %;
macro KA0902_CPU$V_BCC_ENB_EDCC_L = 0,7,1,0 %;
macro KA0902_CPU$V_BCC_ENB_EDC_CHK_L = 0,8,1,0 %;
macro KA0902_CPU$V_BCC_ENB_BC_CIO_L = 0,9,1,0 %;
macro KA0902_CPU$V_BCC_DIS_BLK_W_L = 0,10,1,0 %;
macro KA0902_CPU$V_BCC_ENB_BC_INIT_L = 0,11,1,0 %;
macro KA0902_CPU$V_BCC_FOR_EDCC_L = 0,12,1,0 %;
macro KA0902_CPU$V_BCC_SH_D_V_L = 0,13,3,0 %;
literal KA0902_CPU$S_BCC_SH_D_V_L = 3;
macro KA0902_CPU$V_BCC_EDC_L = 0,16,14,0 %;
literal KA0902_CPU$S_BCC_EDC_L = 14;
macro KA0902_CPU$V_BCC_CACHE_SIZE_L = 0,30,2,0 %;
literal KA0902_CPU$S_BCC_CACHE_SIZE_L = 2;
macro KA0902_CPU$L_BCC_H = 4,0,32,0 %;
macro KA0902_CPU$V_BCC_ENB_ALLOC_H = 4,0,1,0 %;
macro KA0902_CPU$V_BCC_FRC_FILL_SH_H = 4,1,1,0 %;
macro KA0902_CPU$V_BCC_ENB_TPC_H = 4,2,1,0 %;
macro KA0902_CPU$V_BCC_FILL_WTP_H = 4,3,1,0 %;
macro KA0902_CPU$V_BCC_FILL_WCP_H = 4,4,1,0 %;
macro KA0902_CPU$V_BCC_FILL_WDTP_H = 4,5,1,0 %;
macro KA0902_CPU$V_BCC_ENB_CEI_H = 4,6,1,0 %;
macro KA0902_CPU$V_BCC_ENB_EDCC_H = 4,7,1,0 %;
macro KA0902_CPU$V_BCC_ENB_EDC_CHK_H = 4,8,1,0 %;
macro KA0902_CPU$V_BCC_ENB_BC_CIO_H = 4,9,1,0 %;
macro KA0902_CPU$V_BCC_DIS_BLK_W_H = 4,10,1,0 %;
macro KA0902_CPU$V_BCC_ENB_BC_INIT_H = 4,11,1,0 %;
macro KA0902_CPU$V_BCC_FOR_EDCC_H = 4,12,1,0 %;
macro KA0902_CPU$V_BCC_SH_D_V_H = 4,13,3,0 %;
literal KA0902_CPU$S_BCC_SH_D_V_H = 3;
macro KA0902_CPU$V_BCC_EDC_L_H = 4,16,14,0 %;
literal KA0902_CPU$S_BCC_EDC_L_H = 14;
macro KA0902_CPU$V_BCC_CACHE_SIZE_H = 4,30,2,0 %;
literal KA0902_CPU$S_BCC_CACHE_SIZE_H = 2;
!  B-Cache Correctable Error Register, BCCE
macro KA0902_CPU$Q_BCCE = 32,0,0,1 %;
literal KA0902_CPU$S_BCCE = 8;
macro KA0902_CPU$L_BCCE_L = 32,0,32,0 %;
macro KA0902_CPU$V_BCCE_MCE_L = 32,2,1,0 %;
macro KA0902_CPU$V_BCCE_CE_L = 32,3,1,0 %;
macro KA0902_CPU$V_BCCE_CNTRL_PAR_L = 32,8,1,0 %;
macro KA0902_CPU$V_BCCE_SH_L = 32,9,1,0 %;
macro KA0902_CPU$V_BCCE_DIRTY_L = 32,10,1,0 %;
macro KA0902_CPU$V_BCCE_VALID_L = 32,11,1,0 %;
macro KA0902_CPU$V_BCCE_BC_EDC_L = 32,17,1,0 %;
macro KA0902_CPU$V_BCCE_EDC_SYND_0 = 32,18,7,0 %;
literal KA0902_CPU$S_BCCE_EDC_SYND_0 = 7;
macro KA0902_CPU$V_BCCE_EDC_SYND_2 = 32,25,7,0 %;
literal KA0902_CPU$S_BCCE_EDC_SYND_2 = 7;
macro KA0902_CPU$L_BCCE_H = 36,0,32,0 %;
macro KA0902_CPU$V_BCCE_MCE_H = 36,2,1,0 %;
macro KA0902_CPU$V_BCCE_CE_H = 36,3,1,0 %;
macro KA0902_CPU$V_BCCE_READ_ONLY = 36,4,13,0 %;
literal KA0902_CPU$S_BCCE_READ_ONLY = 13;
macro KA0902_CPU$V_BCCE_BC_EDC_H = 36,17,1,0 %;
macro KA0902_CPU$V_BCCE_EDC_SYND_1 = 36,18,7,0 %;
literal KA0902_CPU$S_BCCE_EDC_SYND_1 = 7;
macro KA0902_CPU$V_BCCE_EDC_SYND_3 = 36,25,7,0 %;
literal KA0902_CPU$S_BCCE_EDC_SYND_3 = 7;
!  B-Cache Correctable Error Register, BCCEA
macro KA0902_CPU$Q_BCCEA = 64,0,0,1 %;
literal KA0902_CPU$S_BCCEA = 8;
macro KA0902_CPU$L_BCCEA_L = 64,0,32,0 %;
macro KA0902_CPU$V_BCCEA_BCMAP_OFF_L = 64,0,17,0 %;
literal KA0902_CPU$S_BCCEA_BCMAP_OFF_L = 17;
macro KA0902_CPU$V_BCCEA_TAG_PAR_L = 64,18,1,0 %;
macro KA0902_CPU$V_BCCEA_TAG_VALUE_L = 64,19,12,0 %;
literal KA0902_CPU$S_BCCEA_TAG_VALUE_L = 12;
macro KA0902_CPU$L_BCCEA_H = 68,0,32,0 %;
macro KA0902_CPU$V_BCCEA_BCMAP_OFF_H = 68,0,17,0 %;
literal KA0902_CPU$S_BCCEA_BCMAP_OFF_H = 17;
macro KA0902_CPU$V_BCCEA_TAG_PAR_H = 68,18,1,0 %;
macro KA0902_CPU$V_BCCEA_TAG_VALUE_H = 68,19,12,0 %;
literal KA0902_CPU$S_BCCEA_TAG_VALUE_H = 12;
!  B-Cache UNCRectable Error Register, BCUE
macro KA0902_CPU$Q_BCUE = 96,0,0,1 %;
literal KA0902_CPU$S_BCUE = 8;
macro KA0902_CPU$L_BCUE_L = 96,0,32,0 %;
macro KA0902_CPU$V_BCUE_MPE_L = 96,0,1,0 %;
macro KA0902_CPU$V_BCUE_PE_L = 96,1,1,0 %;
macro KA0902_CPU$V_BCUE_MUNCE_L = 96,2,1,0 %;
macro KA0902_CPU$V_BCUE_UNCE_L = 96,3,1,0 %;
macro KA0902_CPU$V_BCUE_CTRL_PAR_L = 96,8,1,0 %;
macro KA0902_CPU$V_BCUE_SH_L = 96,9,1,0 %;
macro KA0902_CPU$V_BCUE_DIRTY_L = 96,10,1,0 %;
macro KA0902_CPU$V_BCUE_VALID_L = 96,11,1,0 %;
macro KA0902_CPU$V_BCUE_BC_EDC_L = 96,17,1,0 %;
macro KA0902_CPU$V_BCUE_EDC_SYND_0 = 96,18,7,0 %;
literal KA0902_CPU$S_BCUE_EDC_SYND_0 = 7;
macro KA0902_CPU$V_BCUE_EDC_SYND_2 = 96,25,7,0 %;
literal KA0902_CPU$S_BCUE_EDC_SYND_2 = 7;
macro KA0902_CPU$L_BCUE_H = 100,0,32,0 %;
macro KA0902_CPU$V_BCUE_MPE_H = 100,0,1,0 %;
macro KA0902_CPU$V_BCUE_PE_H = 100,1,1,0 %;
macro KA0902_CPU$V_BCUE_MUNCE_H = 100,2,1,0 %;
macro KA0902_CPU$V_BCUE_UNCE_H = 100,3,1,0 %;
macro KA0902_CPU$V_BCUE_BC_EDC_H = 100,17,1,0 %;
macro KA0902_CPU$V_BCUE_EDC_SYND_1 = 100,18,7,0 %;
literal KA0902_CPU$S_BCUE_EDC_SYND_1 = 7;
macro KA0902_CPU$V_BCUE_EDC_SYND_3 = 100,25,7,0 %;
literal KA0902_CPU$S_BCUE_EDC_SYND_3 = 7;
!  B-Cache UNCRectable Error Address Register, BCUEA
macro KA0902_CPU$Q_BCUEA = 128,0,0,1 %;
literal KA0902_CPU$S_BCUEA = 8;
macro KA0902_CPU$L_BCUEA_L = 128,0,32,0 %;
macro KA0902_CPU$V_BCUEA_BCMAP_OFF_L = 128,0,17,0 %;
literal KA0902_CPU$S_BCUEA_BCMAP_OFF_L = 17;
macro KA0902_CPU$V_BCUEA_PTP_L = 128,17,1,0 %;
macro KA0902_CPU$V_BCUEA_TP_L = 128,18,1,0 %;
macro KA0902_CPU$V_BCUEA_TV_L = 128,19,12,0 %;
literal KA0902_CPU$S_BCUEA_TV_L = 12;
macro KA0902_CPU$V_BCUEA_FILL1_L = 128,31,1,0 %;
macro KA0902_CPU$L_BCUEA_H = 132,0,32,0 %;
macro KA0902_CPU$V_BCUEA_BCMAP_OFF_H = 132,0,17,0 %;
literal KA0902_CPU$S_BCUEA_BCMAP_OFF_H = 17;
macro KA0902_CPU$V_BCUEA_PTP_H = 132,17,1,0 %;
macro KA0902_CPU$V_BCUEA_TP_H = 132,18,1,0 %;
macro KA0902_CPU$V_BCUEA_TV_H = 132,19,12,0 %;
literal KA0902_CPU$S_BCUEA_TV_H = 12;
macro KA0902_CPU$V_BCUEA_FILL1_H = 132,31,1,0 %;
!  Duplicate Tag Error Register DTER
macro KA0902_CPU$Q_DTER = 160,0,0,1 %;
literal KA0902_CPU$S_DTER = 8;
macro KA0902_CPU$L_DTER_L = 160,0,32,0 %;
macro KA0902_CPU$V_DTER_MDTER_L = 160,0,1,0 %;
macro KA0902_CPU$V_DTER_DTER_L = 160,1,1,0 %;
macro KA0902_CPU$V_DTER_TOFF_L = 160,2,8,0 %;
literal KA0902_CPU$S_DTER_TOFF_L = 8;
macro KA0902_CPU$V_DTER_BANK0_TAG_L = 160,10,9,0 %;
literal KA0902_CPU$S_DTER_BANK0_TAG_L = 9;
macro KA0902_CPU$V_DTER_BANK0_PAR_L = 160,19,1,0 %;
macro KA0902_CPU$V_DTER_BANK1_TAG_L = 160,20,9,0 %;
literal KA0902_CPU$S_DTER_BANK1_TAG_L = 9;
macro KA0902_CPU$V_DTER_BANK1_PAR_L = 160,29,1,0 %;
macro KA0902_CPU$L_DTER_H = 164,0,32,0 %;
macro KA0902_CPU$V_DTER_MDTER_H = 164,0,1,0 %;
macro KA0902_CPU$V_DTER_DTER_H = 164,1,1,0 %;
macro KA0902_CPU$V_DTER_TOFF_H = 164,2,8,0 %;
literal KA0902_CPU$S_DTER_TOFF_H = 8;
macro KA0902_CPU$V_DTER_BANK0_TAG_H = 164,10,9,0 %;
literal KA0902_CPU$S_DTER_BANK0_TAG_H = 9;
macro KA0902_CPU$V_DTER_BANK0_PAR_H = 164,19,1,0 %;
macro KA0902_CPU$V_DTER_BANK1_TAG_H = 164,20,9,0 %;
literal KA0902_CPU$S_DTER_BANK1_TAG_H = 9;
macro KA0902_CPU$V_DTER_BANK1_PAR_H = 164,29,1,0 %;
!  Cobra bus Control Register - CBCTL
macro KA0902_CPU$Q_CBCTL = 192,0,0,1 %;
literal KA0902_CPU$S_CBCTL = 8;
macro KA0902_CPU$L_CBCTL_L = 192,0,32,0 %;
macro KA0902_CPU$V_CBCTL_DWP_L = 192,0,1,0 %;
macro KA0902_CPU$V_CBCTL_CAWP_L = 192,1,2,0 %;
literal KA0902_CPU$S_CBCTL_CAWP_L = 2;
macro KA0902_CPU$V_CBCTL_EPC_L = 192,3,1,0 %;
macro KA0902_CPU$V_CBCTL_FRC_SH_L = 192,4,1,0 %;
macro KA0902_CPU$V_CBCTL_CMDER_ID_L = 192,5,3,0 %;
literal KA0902_CPU$S_CBCTL_CMDER_ID_L = 3;
macro KA0902_CPU$V_CBCTL_ACM_L = 192,8,3,0 %;
literal KA0902_CPU$S_CBCTL_ACM_L = 3;
macro KA0902_CPU$V_CBCTL_ENB_CI_L = 192,11,1,0 %;
macro KA0902_CPU$V_CBCTL_RD_L = 192,12,1,0 %;
macro KA0902_CPU$V_CBCTL_QW_2_SEL_L = 192,13,1,0 %;
macro KA0902_CPU$V_CBCTL_SEL_DRACK_L = 192,14,1,0 %;
macro KA0902_CPU$L_CBCTL_H = 196,0,32,0 %;
macro KA0902_CPU$V_CBCTL_DWP_H = 196,0,1,0 %;
macro KA0902_CPU$V_CBCTL_CAWP_H = 196,1,2,0 %;
literal KA0902_CPU$S_CBCTL_CAWP_H = 2;
macro KA0902_CPU$V_CBCTL_EPC_H = 196,3,1,0 %;
macro KA0902_CPU$V_CBCTL_FRC_SH_H = 196,4,1,0 %;
macro KA0902_CPU$V_CBCTL_CMDER_ID_H = 196,5,3,0 %;
literal KA0902_CPU$S_CBCTL_CMDER_ID_H = 3;
macro KA0902_CPU$V_CBCTL_ACM_H = 196,8,3,0 %;
literal KA0902_CPU$S_CBCTL_ACM_H = 3;
macro KA0902_CPU$V_CBCTL_ENB_CI_H = 196,11,1,0 %;
macro KA0902_CPU$V_CBCTL_RD_H = 196,12,1,0 %;
macro KA0902_CPU$V_CBCTL_QW_2_SEL_H = 196,13,1,0 %;
macro KA0902_CPU$V_CBCTL_SEL_DRACK_H = 196,14,1,0 %;
!  Cobra bus Error Register - CBE
macro KA0902_CPU$Q_CBE = 224,0,0,1 %;
literal KA0902_CPU$S_CBE = 8;
macro KA0902_CPU$L_CBE_L = 224,0,32,0 %;
macro KA0902_CPU$V_CBE_DIAG_L = 224,1,1,0 %;
macro KA0902_CPU$V_CBE_CAP_L = 224,2,1,0 %;
macro KA0902_CPU$V_CBE_MCAP_L = 224,3,1,0 %;
macro KA0902_CPU$V_CBE_PE_WRD_L = 224,4,1,0 %;
macro KA0902_CPU$V_CBE_MPE_WRD_L = 224,5,1,0 %;
macro KA0902_CPU$V_CBE_PE_RD_L = 224,6,1,0 %;
macro KA0902_CPU$V_CBE_MPE_RD_L = 224,7,1,0 %;
macro KA0902_CPU$V_CBE_CA_PE_LW0 = 224,8,1,0 %;
macro KA0902_CPU$V_CBE_CA_PE_LW2 = 224,9,1,0 %;
macro KA0902_CPU$V_CBE_D_PE_LW0 = 224,10,1,0 %;
macro KA0902_CPU$V_CBE_D_PE_LW2 = 224,11,1,0 %;
macro KA0902_CPU$V_CBE_D_PE_LW4 = 224,12,1,0 %;
macro KA0902_CPU$V_CBE_D_PE_LW6 = 224,13,1,0 %;
macro KA0902_CPU$V_CBE_CA_NACK_L = 224,14,1,0 %;
macro KA0902_CPU$V_CBE_WR_DATA_NACK_L = 224,15,1,0 %;
macro KA0902_CPU$V_CBE_MCOUNT_L = 224,24,6,0 %;
literal KA0902_CPU$S_CBE_MCOUNT_L = 6;
macro KA0902_CPU$V_CBE_MADR_VALID_L = 224,30,1,0 %;
macro KA0902_CPU$L_CBE_H = 228,0,32,0 %;
macro KA0902_CPU$V_CBE_DIAG_H = 228,1,1,0 %;
macro KA0902_CPU$V_CBE_CAP_H = 228,2,1,0 %;
macro KA0902_CPU$V_CBE_MCAP_H = 228,3,1,0 %;
macro KA0902_CPU$V_CBE_PE_WRD_H = 228,4,1,0 %;
macro KA0902_CPU$V_CBE_MPE_WRD_H = 228,5,1,0 %;
macro KA0902_CPU$V_CBE_PE_RD_H = 228,6,1,0 %;
macro KA0902_CPU$V_CBE_MPE_RD_H = 228,7,1,0 %;
macro KA0902_CPU$V_CBE_CA_PE_LW1 = 228,8,1,0 %;
macro KA0902_CPU$V_CBE_CA_PE_LW3 = 228,9,1,0 %;
macro KA0902_CPU$V_CBE_D_PE_LW1 = 228,10,1,0 %;
macro KA0902_CPU$V_CBE_D_PE_LW3 = 228,11,1,0 %;
macro KA0902_CPU$V_CBE_D_PE_LW5 = 228,12,1,0 %;
macro KA0902_CPU$V_CBE_D_PE_LW7 = 228,13,1,0 %;
macro KA0902_CPU$V_CBE_UNDEFINED = 228,14,1,0 %;
macro KA0902_CPU$V_CBE_UNDEFINED2 = 228,15,1,0 %;
macro KA0902_CPU$V_CBE_MCOUNT_H = 228,24,6,0 %;
literal KA0902_CPU$S_CBE_MCOUNT_H = 6;
macro KA0902_CPU$V_CBE_MADR_VALID_H = 228,30,1,0 %;
!  Cobra bus Error Address Low Register - CBEAL
macro KA0902_CPU$Q_CBEAL = 256,0,0,1 %;
literal KA0902_CPU$S_CBEAL = 8;
macro KA0902_CPU$L_CBEAL_L = 256,0,32,0 %;
macro KA0902_CPU$V_CBEAL_SBO_L = 256,0,2,0 %;
literal KA0902_CPU$S_CBEAL_SBO_L = 2;
macro KA0902_CPU$V_CBEAL_ADDR_CAD_L = 256,2,30,0 %;
literal KA0902_CPU$S_CBEAL_ADDR_CAD_L = 30;
macro KA0902_CPU$L_CBEAL_H = 260,0,32,0 %;
macro KA0902_CPU$V_CBEAL_SBO_H = 260,0,2,0 %;
literal KA0902_CPU$S_CBEAL_SBO_H = 2;
macro KA0902_CPU$V_CBEAL_ADDR_CAD_H = 260,2,30,0 %;
literal KA0902_CPU$S_CBEAL_ADDR_CAD_H = 30;
!  Cobra bus Error Address High Register - CBEAH
macro KA0902_CPU$Q_CBEAH = 288,0,0,1 %;
literal KA0902_CPU$S_CBEAH = 8;
macro KA0902_CPU$L_CBEAH_L = 288,0,32,0 %;
macro KA0902_CPU$V_CBEAH_SB0_L = 288,0,2,0 %;
literal KA0902_CPU$S_CBEAH_SB0_L = 2;
macro KA0902_CPU$V_CBEAH_EA_L = 288,2,16,0 %;
literal KA0902_CPU$S_CBEAH_EA_L = 16;
macro KA0902_CPU$V_CBEAH_T_TYPE_L = 288,18,3,0 %;
literal KA0902_CPU$S_CBEAH_T_TYPE_L = 3;
macro KA0902_CPU$V_CBEAH_CMDR_ID_L = 288,21,3,0 %;
literal KA0902_CPU$S_CBEAH_CMDR_ID_L = 3;
macro KA0902_CPU$V_CBEAH_SB1_L = 288,24,8,0 %;
literal KA0902_CPU$S_CBEAH_SB1_L = 8;
macro KA0902_CPU$L_CBEAH_H = 292,0,32,0 %;
macro KA0902_CPU$V_CBEAH_SB0_H = 292,0,2,0 %;
literal KA0902_CPU$S_CBEAH_SB0_H = 2;
macro KA0902_CPU$V_CBEAH_EA_H = 292,2,16,0 %;
literal KA0902_CPU$S_CBEAH_EA_H = 16;
macro KA0902_CPU$V_CBEAH_T_TYPE_H = 292,18,3,0 %;
literal KA0902_CPU$S_CBEAH_T_TYPE_H = 3;
macro KA0902_CPU$V_CBEAH_CMDR_ID_H = 292,21,3,0 %;
literal KA0902_CPU$S_CBEAH_CMDR_ID_H = 3;
macro KA0902_CPU$V_CBEAH_SB1_H = 292,24,8,0 %;
literal KA0902_CPU$S_CBEAH_SB1_H = 8;
!  Processor Mailbox Register - PMBX
macro KA0902_CPU$Q_PMBX = 320,0,0,1 %;
literal KA0902_CPU$S_PMBX = 8;
macro KA0902_CPU$L_PMBX_L = 320,0,32,0 %;
macro KA0902_CPU$V_PMBX_FILL1_L = 320,0,32,0 %;
literal KA0902_CPU$S_PMBX_FILL1_L = 32;
macro KA0902_CPU$L_PMBX_H = 324,0,32,0 %;
macro KA0902_CPU$V_PMBX_FILL1_H = 324,0,32,0 %;
literal KA0902_CPU$S_PMBX_FILL1_H = 32;
!  Interprocessor Interrupt Request Register - IPIR
macro KA0902_CPU$Q_IPIR = 352,0,0,1 %;
literal KA0902_CPU$S_IPIR = 8;
macro KA0902_CPU$L_IPIR_L = 352,0,32,0 %;
macro KA0902_CPU$V_IPIR_UNDEFINED = 352,0,1,0 %;
macro KA0902_CPU$L_IPIR_H = 356,0,32,0 %;
macro KA0902_CPU$V_IPIR_REQ_INT_CPU = 356,0,1,0 %;
macro KA0902_CPU$V_IPIR_REQ_NODE_HALT = 356,3,1,0 %;
!  System Interrupt Clear Register - SIC
macro KA0902_CPU$Q_SIC = 384,0,0,1 %;
literal KA0902_CPU$S_SIC = 8;
macro KA0902_CPU$L_SIC_L = 384,0,32,0 %;
macro KA0902_CPU$V_SIC_UNDEFINED0 = 384,0,1,0 %;
macro KA0902_CPU$V_SIC_UNDEFINED1 = 384,1,1,0 %;
macro KA0902_CPU$V_SIC_EIC = 384,2,1,0 %;
macro KA0902_CPU$V_SIC_UNDEFINED2 = 384,3,1,0 %;
macro KA0902_CPU$L_SIC_H = 388,0,32,0 %;
macro KA0902_CPU$V_SIC_IT_ICLEAR = 388,0,1,0 %;
macro KA0902_CPU$V_SIC_SYS_EVT_CLR = 388,1,1,0 %;
macro KA0902_CPU$V_SIC_UNDEFINED3 = 388,2,1,0 %;
macro KA0902_CPU$V_SIC_NODE_HALT_CLR = 388,3,1,0 %;
!  Address Lock Register - ADLK
macro KA0902_CPU$Q_ADLK = 416,0,0,1 %;
literal KA0902_CPU$S_ADLK = 8;
macro KA0902_CPU$L_ADLK_L = 416,0,32,0 %;
macro KA0902_CPU$V_ADLK_LA_V_L = 416,0,1,0 %;
macro KA0902_CPU$V_ADLK_LA_L = 416,3,29,0 %;
literal KA0902_CPU$S_ADLK_LA_L = 29;
macro KA0902_CPU$L_ADLK_H = 420,0,32,0 %;
macro KA0902_CPU$V_ADLK_LA_V_H = 420,0,1,0 %;
macro KA0902_CPU$V_ADLK_LA_H = 420,3,29,0 %;
literal KA0902_CPU$S_ADLK_LA_H = 29;
!  Miss Address Register - MADRL
macro KA0902_CPU$Q_MADRL = 448,0,0,1 %;
literal KA0902_CPU$S_MADRL = 8;
macro KA0902_CPU$L_MADRL_L = 448,0,32,0 %;
macro KA0902_CPU$V_MADRL_VALID_L = 448,0,1,0 %;
macro KA0902_CPU$V_MADRL_T_TYPE_L = 448,1,1,0 %;
macro KA0902_CPU$V_MADRL_ADDRESS_L = 448,2,30,0 %;
literal KA0902_CPU$S_MADRL_ADDRESS_L = 30;
macro KA0902_CPU$L_MADRL_H = 452,0,32,0 %;
macro KA0902_CPU$V_MADRL_VALID_H = 452,0,1,0 %;
macro KA0902_CPU$V_MADRL_T_TYPE_H = 452,1,1,0 %;
macro KA0902_CPU$V_MADRL_ADDRESS_H = 452,2,30,0 %;
literal KA0902_CPU$S_MADRL_ADDRESS_H = 30;
!  C3 revision Register - CRREVS
macro KA0902_CPU$Q_CRREVS = 480,0,0,1 %;
literal KA0902_CPU$S_CRREVS = 8;
macro KA0902_CPU$L_CRREVS_L = 480,0,32,0 %;
macro KA0902_CPU$V_CRREVS_REV_L = 480,0,4,0 %;
literal KA0902_CPU$S_CRREVS_REV_L = 4;
macro KA0902_CPU$V_CRREVS_CPU_MODE_L = 480,4,1,0 %;
macro KA0902_CPU$V_CRREVS_C3_SPEED_L = 480,5,7,0 %;
literal KA0902_CPU$S_CRREVS_C3_SPEED_L = 7;
macro KA0902_CPU$V_CRREVS_SB0_L = 480,12,1,0 %;
macro KA0902_CPU$V_CRREVS_IO_RETRY_L = 480,14,1,0 %;
macro KA0902_CPU$V_CRREVS_PCH_INV_L = 480,21,1,0 %;
macro KA0902_CPU$L_CRREVS_H = 484,0,32,0 %;
macro KA0902_CPU$V_CRREVS_REV_H = 484,0,4,0 %;
literal KA0902_CPU$S_CRREVS_REV_H = 4;
macro KA0902_CPU$V_CRREVS_CPU_MODE_H = 484,4,1,0 %;
macro KA0902_CPU$V_CRREVS_C3_SPEED_H = 484,5,7,0 %;
literal KA0902_CPU$S_CRREVS_C3_SPEED_H = 7;
macro KA0902_CPU$V_CRREVS_SB0_H = 484,12,1,0 %;
macro KA0902_CPU$V_CRREVS_IO_RETRY_H = 484,14,1,0 %;
macro KA0902_CPU$V_CRREVS_PCH_INV_H = 484,21,1,0 %;
literal KA0902_CPU$K_LENGTH = 488;
! 
!  Sable Memory Module register definitions
!                            
literal KA0902_SMM$M_CME_ES_L = %X'1';
literal KA0902_SMM$M_CME_SE_L = %X'2';
literal KA0902_SMM$M_CME_CA_PE_L = %X'4';
literal KA0902_SMM$M_CME_MCA_PE_L = %X'8';
literal KA0902_SMM$M_CME_WD_PE_L = %X'10';
literal KA0902_SMM$M_CME_MWD_PE_L = %X'20';
literal KA0902_SMM$M_CME_CA_PE_LW0 = %X'100';
literal KA0902_SMM$M_CME_CA_PE_LW2 = %X'200';
literal KA0902_SMM$M_CME_D_PE_LW0 = %X'400';
literal KA0902_SMM$M_CME_D_PE_LW2 = %X'800';
literal KA0902_SMM$M_CME_D_PE_LW4 = %X'1000';
literal KA0902_SMM$M_CME_D_PE_LW6 = %X'2000';
literal KA0902_SMM$M_CME_EUE_L = %X'10000';
literal KA0902_SMM$M_CME_MEUE_L = %X'20000';
literal KA0902_SMM$M_CME_ECE_L = %X'40000';
literal KA0902_SMM$M_CME_MECE_L = %X'80000';
literal KA0902_SMM$M_CME_ES_H = %X'1';
literal KA0902_SMM$M_CME_SE_H = %X'2';
literal KA0902_SMM$M_CME_CA_PE_H = %X'4';
literal KA0902_SMM$M_CME_MCA_PE_H = %X'8';
literal KA0902_SMM$M_CME_WD_PE_H = %X'10';
literal KA0902_SMM$M_CME_MWD_PE_H = %X'20';
literal KA0902_SMM$M_CME_CA_PE_LW1 = %X'100';
literal KA0902_SMM$M_CME_CA_PE_LW3 = %X'200';
literal KA0902_SMM$M_CME_D_PE_LW1 = %X'400';
literal KA0902_SMM$M_CME_D_PE_LW3 = %X'800';
literal KA0902_SMM$M_CME_D_PE_LW5 = %X'1000';
literal KA0902_SMM$M_CME_D_PE_LW7 = %X'2000';
literal KA0902_SMM$M_CME_EUE_H = %X'10000';
literal KA0902_SMM$M_CME_MEUE_H = %X'20000';
literal KA0902_SMM$M_CME_ECE_H = %X'40000';
literal KA0902_SMM$M_CME_MECE_H = %X'80000';
literal KA0902_SMM$M_CNFG_MID_L = %X'3';
literal KA0902_SMM$M_CNFG_DRAM_ACC_L = %X'8';
literal KA0902_SMM$M_CNFG_MSIZE_L = %X'F0';
literal KA0902_SMM$M_CNFG_DIAG_L = %X'100';
literal KA0902_SMM$M_CNFG_CSIC_REV_L = %X'F000';
literal KA0902_SMM$M_CNFG_ALT_CSR_L = %X'10000';
literal KA0902_SMM$M_CNFG_ILVM_L = %X'C0000';
literal KA0902_SMM$M_CNFG_ILVU_L = %X'300000';
literal KA0902_SMM$M_CNFG_BASE_ADR_L = %X'7F800000';
literal KA0902_SMM$M_CNFG_MEM_ENA_L = %X'80000000';
literal KA0902_SMM$M_CNFG_MID_H = %X'3';
literal KA0902_SMM$M_CNFG_DRAM_ACC_H = %X'8';
literal KA0902_SMM$M_CNFG_MSIZE_H = %X'F0';
literal KA0902_SMM$M_CNFG_DIAG_H = %X'100';
literal KA0902_SMM$M_CNFG_CSIC_REV_H = %X'F000';
literal KA0902_SMM$M_CNFG_ALT_CSR_H = %X'10000';
literal KA0902_SMM$M_CNFG_ILVM_H = %X'C0000';
literal KA0902_SMM$M_CNFG_ILVU_H = %X'300000';
literal KA0902_SMM$M_CNFG_BASE_ADR_H = %X'7F800000';
literal KA0902_SMM$M_CNFG_MEM_ENA_H = %X'80000000';
literal KA0902_SMM$M_EDC1_READ_CBITS_L = %X'FFF';
literal KA0902_SMM$M_EDC1_WR_CBITS_L = %X'FFF0000';
literal KA0902_SMM$M_EDC1_READ_CBITS_H = %X'FFF';
literal KA0902_SMM$M_EDC1_WR_CBITS_H = %X'FFF0000';
literal KA0902_SMM$M_EDC2_SYNDROME_L = %X'FFF';
literal KA0902_SMM$M_EDC2_SYNDROME_H = %X'FFF';
literal KA0902_SMM$M_EDCTL_SRB_L = %X'FFF';
literal KA0902_SMM$M_EDCTL_USCB_L = %X'1000';
literal KA0902_SMM$M_EDCTL_USWCB_L = %X'2000';
literal KA0902_SMM$M_EDCTL_DIPC_L = %X'4000';
literal KA0902_SMM$M_EDCTL_ENB_ES_L = %X'8000';
literal KA0902_SMM$M_EDCTL_SWCB_L = %X'FFF0000';
literal KA0902_SMM$M_EDCTL_CRDP_L = %X'10000000';
literal KA0902_SMM$M_EDCTL_ENB_CRDR_L = %X'20000000';
literal KA0902_SMM$M_EDCTL_DEDCCORR_L = %X'40000000';
literal KA0902_SMM$M_EDCTL_DEDCREPORT_L = %X'80000000';
literal KA0902_SMM$M_EDCTL_SRB_H = %X'FFF';
literal KA0902_SMM$M_EDCTL_USCB_H = %X'1000';
literal KA0902_SMM$M_EDCTL_USWCB_H = %X'2000';
literal KA0902_SMM$M_EDCTL_DIPC_H = %X'4000';
literal KA0902_SMM$M_EDCTL_ENB_ES_H = %X'8000';
literal KA0902_SMM$M_EDCTL_SWCB_H = %X'FFF0000';
literal KA0902_SMM$M_EDCTL_CRDP_H = %X'10000000';
literal KA0902_SMM$M_EDCTL_ENB_CRDR_H = %X'20000000';
literal KA0902_SMM$M_EDCTL_DEDCCORR_H = %X'40000000';
literal KA0902_SMM$M_EDCTL_DEDCREPORT_H = %X'80000000';
literal KA0902_SMM$M_SBCTRL_DSD_L = %X'1';
literal KA0902_SMM$M_SBCTRL_DSH_L = %X'2';
literal KA0902_SMM$M_SBCTRL_DSF_L = %X'4';
literal KA0902_SMM$M_SBCTRL_DSI_L = %X'8';
literal KA0902_SMM$M_SBCTRL_ERWD_L = %X'10';
literal KA0902_SMM$M_SBCTRL_FHB_L = %X'20';
literal KA0902_SMM$M_SBCTRL_FILL1_L = %X'C0';
literal KA0902_SMM$M_SBCTRL_HBSM_L = %X'100';
literal KA0902_SMM$M_SBCTRL_HBHF_L = %X'200';
literal KA0902_SMM$M_SBCTRL_FL_L = %X'400';
literal KA0902_SMM$M_SBCTRL_DSD_H = %X'1';
literal KA0902_SMM$M_SBCTRL_DSH_H = %X'2';
literal KA0902_SMM$M_SBCTRL_DSF_H = %X'4';
literal KA0902_SMM$M_SBCTRL_DSI_H = %X'8';
literal KA0902_SMM$M_SBCTRL_ERWD_H = %X'10';
literal KA0902_SMM$M_SBCTRL_FHB_H = %X'20';
literal KA0902_SMM$M_SBCTRL_FILL1_H = %X'C0';
literal KA0902_SMM$M_SBCTRL_HBSM_H = %X'100';
literal KA0902_SMM$M_SBCTRL_HBHF_H = %X'200';
literal KA0902_SMM$M_SBCTRL_FL_H = %X'400';
literal KA0902_SMM$M_RCTRL_RC_L = %X'FF';
literal KA0902_SMM$M_RCTRL_REF_ENB_L = %X'100';
literal KA0902_SMM$M_RCTRL_NUT_L = %X'1000';
literal KA0902_SMM$M_RCTRL_HIT_L = %X'2000';
literal KA0902_SMM$M_RCTRL_RC_H = %X'FF';
literal KA0902_SMM$M_RCTRL_REF_ENB_H = %X'100';
literal KA0902_SMM$M_RCTRL_NUT_H = %X'1000';
literal KA0902_SMM$M_RCTRL_HIT_H = %X'2000';
literal KA0902_SMM$M_CRDCTL_SM_L = %X'FFF';
literal KA0902_SMM$M_CRDCTL_BS_L = %X'3000';
literal KA0902_SMM$M_CRDCTL_CFE_L = %X'4000';
literal KA0902_SMM$M_CRDCTL_SM_H = %X'FFF';
literal KA0902_SMM$M_CRDCTL_BS_H = %X'3000';
literal KA0902_SMM$M_CRDCTL_CFE_H = %X'4000';
literal KA0902_SMM$S_KA0902_SMM = 296;
!  Sable Memory Module CSR0 Error Register
macro KA0902_SMM$Q_CME = 0,0,0,1 %;
literal KA0902_SMM$S_CME = 8;
macro KA0902_SMM$L_CME_L = 0,0,32,0 %;
macro KA0902_SMM$V_CME_ES_L = 0,0,1,0 %;
macro KA0902_SMM$V_CME_SE_L = 0,1,1,0 %;
macro KA0902_SMM$V_CME_CA_PE_L = 0,2,1,0 %;
macro KA0902_SMM$V_CME_MCA_PE_L = 0,3,1,0 %;
macro KA0902_SMM$V_CME_WD_PE_L = 0,4,1,0 %;
macro KA0902_SMM$V_CME_MWD_PE_L = 0,5,1,0 %;
macro KA0902_SMM$V_CME_CA_PE_LW0 = 0,8,1,0 %;
macro KA0902_SMM$V_CME_CA_PE_LW2 = 0,9,1,0 %;
macro KA0902_SMM$V_CME_D_PE_LW0 = 0,10,1,0 %;
macro KA0902_SMM$V_CME_D_PE_LW2 = 0,11,1,0 %;
macro KA0902_SMM$V_CME_D_PE_LW4 = 0,12,1,0 %;
macro KA0902_SMM$V_CME_D_PE_LW6 = 0,13,1,0 %;
macro KA0902_SMM$V_CME_EUE_L = 0,16,1,0 %;
macro KA0902_SMM$V_CME_MEUE_L = 0,17,1,0 %;
macro KA0902_SMM$V_CME_ECE_L = 0,18,1,0 %;
macro KA0902_SMM$V_CME_MECE_L = 0,19,1,0 %;
macro KA0902_SMM$L_CME_H = 4,0,32,0 %;
macro KA0902_SMM$V_CME_ES_H = 4,0,1,0 %;
macro KA0902_SMM$V_CME_SE_H = 4,1,1,0 %;
macro KA0902_SMM$V_CME_CA_PE_H = 4,2,1,0 %;
macro KA0902_SMM$V_CME_MCA_PE_H = 4,3,1,0 %;
macro KA0902_SMM$V_CME_WD_PE_H = 4,4,1,0 %;
macro KA0902_SMM$V_CME_MWD_PE_H = 4,5,1,0 %;
macro KA0902_SMM$V_CME_CA_PE_LW1 = 4,8,1,0 %;
macro KA0902_SMM$V_CME_CA_PE_LW3 = 4,9,1,0 %;
macro KA0902_SMM$V_CME_D_PE_LW1 = 4,10,1,0 %;
macro KA0902_SMM$V_CME_D_PE_LW3 = 4,11,1,0 %;
macro KA0902_SMM$V_CME_D_PE_LW5 = 4,12,1,0 %;
macro KA0902_SMM$V_CME_D_PE_LW7 = 4,13,1,0 %;
macro KA0902_SMM$V_CME_EUE_H = 4,16,1,0 %;
macro KA0902_SMM$V_CME_MEUE_H = 4,17,1,0 %;
macro KA0902_SMM$V_CME_ECE_H = 4,18,1,0 %;
macro KA0902_SMM$V_CME_MECE_H = 4,19,1,0 %;
!  Sable Memory Module CSR1 Command Trap 1
macro KA0902_SMM$Q_TRAP1 = 32,0,0,1 %;
literal KA0902_SMM$S_TRAP1 = 8;
macro KA0902_SMM$L_TRAP1_L = 32,0,32,0 %;
macro KA0902_SMM$L_TRAP1_H = 36,0,32,0 %;
!  Sable Memory Module CSR2 Command Trap 2
macro KA0902_SMM$Q_TRAP2 = 64,0,0,1 %;
literal KA0902_SMM$S_TRAP2 = 8;
macro KA0902_SMM$L_TRAP2_L = 64,0,32,0 %;
macro KA0902_SMM$L_TRAP2_H = 68,0,32,0 %;
!  Sable Memory Module CSR3 Configuration
macro KA0902_SMM$Q_CNFG = 96,0,0,1 %;
literal KA0902_SMM$S_CNFG = 8;
macro KA0902_SMM$L_CNFG_L = 96,0,32,0 %;
macro KA0902_SMM$V_CNFG_MID_L = 96,0,2,0 %;
literal KA0902_SMM$S_CNFG_MID_L = 2;
macro KA0902_SMM$V_CNFG_DRAM_ACC_L = 96,3,1,0 %;
macro KA0902_SMM$V_CNFG_MSIZE_L = 96,4,4,0 %;
literal KA0902_SMM$S_CNFG_MSIZE_L = 4;
macro KA0902_SMM$V_CNFG_DIAG_L = 96,8,1,0 %;
macro KA0902_SMM$V_CNFG_CSIC_REV_L = 96,12,4,0 %;
literal KA0902_SMM$S_CNFG_CSIC_REV_L = 4;
macro KA0902_SMM$V_CNFG_ALT_CSR_L = 96,16,1,0 %;
macro KA0902_SMM$V_CNFG_ILVM_L = 96,18,2,0 %;
literal KA0902_SMM$S_CNFG_ILVM_L = 2;
macro KA0902_SMM$V_CNFG_ILVU_L = 96,20,2,0 %;
literal KA0902_SMM$S_CNFG_ILVU_L = 2;
macro KA0902_SMM$V_CNFG_BASE_ADR_L = 96,23,8,0 %;
literal KA0902_SMM$S_CNFG_BASE_ADR_L = 8;
macro KA0902_SMM$V_CNFG_MEM_ENA_L = 96,31,1,0 %;
macro KA0902_SMM$L_CNFG_H = 100,0,32,0 %;
macro KA0902_SMM$V_CNFG_MID_H = 100,0,2,0 %;
literal KA0902_SMM$S_CNFG_MID_H = 2;
macro KA0902_SMM$V_CNFG_DRAM_ACC_H = 100,3,1,0 %;
macro KA0902_SMM$V_CNFG_MSIZE_H = 100,4,4,0 %;
literal KA0902_SMM$S_CNFG_MSIZE_H = 4;
macro KA0902_SMM$V_CNFG_DIAG_H = 100,8,1,0 %;
macro KA0902_SMM$V_CNFG_CSIC_REV_H = 100,12,4,0 %;
literal KA0902_SMM$S_CNFG_CSIC_REV_H = 4;
macro KA0902_SMM$V_CNFG_ALT_CSR_H = 100,16,1,0 %;
macro KA0902_SMM$V_CNFG_ILVM_H = 100,18,2,0 %;
literal KA0902_SMM$S_CNFG_ILVM_H = 2;
macro KA0902_SMM$V_CNFG_ILVU_H = 100,20,2,0 %;
literal KA0902_SMM$S_CNFG_ILVU_H = 2;
macro KA0902_SMM$V_CNFG_BASE_ADR_H = 100,23,8,0 %;
literal KA0902_SMM$S_CNFG_BASE_ADR_H = 8;
macro KA0902_SMM$V_CNFG_MEM_ENA_H = 100,31,1,0 %;
!  Sable Memory Module CSR4 EDC Status 1
macro KA0902_SMM$Q_EDC1 = 128,0,0,1 %;
literal KA0902_SMM$S_EDC1 = 8;
macro KA0902_SMM$L_EDC1_L = 128,0,32,0 %;
macro KA0902_SMM$V_EDC1_READ_CBITS_L = 128,0,12,0 %;
literal KA0902_SMM$S_EDC1_READ_CBITS_L = 12;
macro KA0902_SMM$V_EDC1_WR_CBITS_L = 128,16,12,0 %;
literal KA0902_SMM$S_EDC1_WR_CBITS_L = 12;
macro KA0902_SMM$L_EDC1_H = 132,0,32,0 %;
macro KA0902_SMM$V_EDC1_READ_CBITS_H = 132,0,12,0 %;
literal KA0902_SMM$S_EDC1_READ_CBITS_H = 12;
macro KA0902_SMM$V_EDC1_WR_CBITS_H = 132,16,12,0 %;
literal KA0902_SMM$S_EDC1_WR_CBITS_H = 12;
!  Sable Memory Module CSR5 EDC Status 2
macro KA0902_SMM$Q_EDC2 = 160,0,0,1 %;
literal KA0902_SMM$S_EDC2 = 8;
macro KA0902_SMM$L_EDC2_L = 160,0,32,0 %;
macro KA0902_SMM$V_EDC2_SYNDROME_L = 160,0,12,0 %;
literal KA0902_SMM$S_EDC2_SYNDROME_L = 12;
macro KA0902_SMM$L_EDC2_H = 164,0,32,0 %;
macro KA0902_SMM$V_EDC2_SYNDROME_H = 164,0,12,0 %;
literal KA0902_SMM$S_EDC2_SYNDROME_H = 12;
!  Sable Memory Module CSR6 EDC Control
macro KA0902_SMM$Q_EDCTL = 192,0,0,1 %;
literal KA0902_SMM$S_EDCTL = 8;
macro KA0902_SMM$L_EDCTL_L = 192,0,32,0 %;
macro KA0902_SMM$V_EDCTL_SRB_L = 192,0,12,0 %;
literal KA0902_SMM$S_EDCTL_SRB_L = 12;
macro KA0902_SMM$V_EDCTL_USCB_L = 192,12,1,0 %;
macro KA0902_SMM$V_EDCTL_USWCB_L = 192,13,1,0 %;
macro KA0902_SMM$V_EDCTL_DIPC_L = 192,14,1,0 %;
macro KA0902_SMM$V_EDCTL_ENB_ES_L = 192,15,1,0 %;
macro KA0902_SMM$V_EDCTL_SWCB_L = 192,16,12,0 %;
literal KA0902_SMM$S_EDCTL_SWCB_L = 12;
macro KA0902_SMM$V_EDCTL_CRDP_L = 192,28,1,0 %;
macro KA0902_SMM$V_EDCTL_ENB_CRDR_L = 192,29,1,0 %;
macro KA0902_SMM$V_EDCTL_DEDCCORR_L = 192,30,1,0 %;
macro KA0902_SMM$V_EDCTL_DEDCREPORT_L = 192,31,1,0 %;
macro KA0902_SMM$L_EDCTL_H = 196,0,32,0 %;
macro KA0902_SMM$V_EDCTL_SRB_H = 196,0,12,0 %;
literal KA0902_SMM$S_EDCTL_SRB_H = 12;
macro KA0902_SMM$V_EDCTL_USCB_H = 196,12,1,0 %;
macro KA0902_SMM$V_EDCTL_USWCB_H = 196,13,1,0 %;
macro KA0902_SMM$V_EDCTL_DIPC_H = 196,14,1,0 %;
macro KA0902_SMM$V_EDCTL_ENB_ES_H = 196,15,1,0 %;
macro KA0902_SMM$V_EDCTL_SWCB_H = 196,16,12,0 %;
literal KA0902_SMM$S_EDCTL_SWCB_H = 12;
macro KA0902_SMM$V_EDCTL_CRDP_H = 196,28,1,0 %;
macro KA0902_SMM$V_EDCTL_ENB_CRDR_H = 196,29,1,0 %;
macro KA0902_SMM$V_EDCTL_DEDCCORR_H = 196,30,1,0 %;
macro KA0902_SMM$V_EDCTL_DEDCREPORT_H = 196,31,1,0 %;
!  Sable Memory Module CSR7 Stream Buffer Control 
macro KA0902_SMM$Q_SBCTRL = 224,0,0,1 %;
literal KA0902_SMM$S_SBCTRL = 8;
macro KA0902_SMM$L_SBCTRL_L = 224,0,32,0 %;
macro KA0902_SMM$V_SBCTRL_DSD_L = 224,0,1,0 %;
macro KA0902_SMM$V_SBCTRL_DSH_L = 224,1,1,0 %;
macro KA0902_SMM$V_SBCTRL_DSF_L = 224,2,1,0 %;
macro KA0902_SMM$V_SBCTRL_DSI_L = 224,3,1,0 %;
macro KA0902_SMM$V_SBCTRL_ERWD_L = 224,4,1,0 %;
macro KA0902_SMM$V_SBCTRL_FHB_L = 224,5,1,0 %;
macro KA0902_SMM$V_SBCTRL_FILL1_L = 224,6,2,0 %;
literal KA0902_SMM$S_SBCTRL_FILL1_L = 2;
macro KA0902_SMM$V_SBCTRL_HBSM_L = 224,8,1,0 %;
macro KA0902_SMM$V_SBCTRL_HBHF_L = 224,9,1,0 %;
macro KA0902_SMM$V_SBCTRL_FL_L = 224,10,1,0 %;
macro KA0902_SMM$L_SBCTRL_H = 228,0,32,0 %;
macro KA0902_SMM$V_SBCTRL_DSD_H = 228,0,1,0 %;
macro KA0902_SMM$V_SBCTRL_DSH_H = 228,1,1,0 %;
macro KA0902_SMM$V_SBCTRL_DSF_H = 228,2,1,0 %;
macro KA0902_SMM$V_SBCTRL_DSI_H = 228,3,1,0 %;
macro KA0902_SMM$V_SBCTRL_ERWD_H = 228,4,1,0 %;
macro KA0902_SMM$V_SBCTRL_FHB_H = 228,5,1,0 %;
macro KA0902_SMM$V_SBCTRL_FILL1_H = 228,6,2,0 %;
literal KA0902_SMM$S_SBCTRL_FILL1_H = 2;
macro KA0902_SMM$V_SBCTRL_HBSM_H = 228,8,1,0 %;
macro KA0902_SMM$V_SBCTRL_HBHF_H = 228,9,1,0 %;
macro KA0902_SMM$V_SBCTRL_FL_H = 228,10,1,0 %;
!  Sable Memory Module CSR8 Refresh control
macro KA0902_SMM$Q_RCTRL = 256,0,0,1 %;
literal KA0902_SMM$S_RCTRL = 8;
macro KA0902_SMM$L_RCTRL_L = 256,0,32,0 %;
macro KA0902_SMM$V_RCTRL_RC_L = 256,0,8,0 %;
literal KA0902_SMM$S_RCTRL_RC_L = 8;
macro KA0902_SMM$V_RCTRL_REF_ENB_L = 256,8,1,0 %;
macro KA0902_SMM$V_RCTRL_NUT_L = 256,12,1,0 %;
macro KA0902_SMM$V_RCTRL_HIT_L = 256,13,1,0 %;
macro KA0902_SMM$L_RCTRL_H = 260,0,32,0 %;
macro KA0902_SMM$V_RCTRL_RC_H = 260,0,8,0 %;
literal KA0902_SMM$S_RCTRL_RC_H = 8;
macro KA0902_SMM$V_RCTRL_REF_ENB_H = 260,8,1,0 %;
macro KA0902_SMM$V_RCTRL_NUT_H = 260,12,1,0 %;
macro KA0902_SMM$V_RCTRL_HIT_H = 260,13,1,0 %;
!  Sable Memory Module CSR9 CRD Filter control
macro KA0902_SMM$Q_CRDCTL = 288,0,0,1 %;
literal KA0902_SMM$S_CRDCTL = 8;
macro KA0902_SMM$L_CRDCTL_L = 288,0,32,0 %;
macro KA0902_SMM$V_CRDCTL_SM_L = 288,0,12,0 %;
literal KA0902_SMM$S_CRDCTL_SM_L = 12;
macro KA0902_SMM$V_CRDCTL_BS_L = 288,12,2,0 %;
literal KA0902_SMM$S_CRDCTL_BS_L = 2;
macro KA0902_SMM$V_CRDCTL_CFE_L = 288,14,1,0 %;
macro KA0902_SMM$L_CRDCTL_H = 292,0,32,0 %;
macro KA0902_SMM$V_CRDCTL_SM_H = 292,0,12,0 %;
literal KA0902_SMM$S_CRDCTL_SM_H = 12;
macro KA0902_SMM$V_CRDCTL_BS_H = 292,12,2,0 %;
literal KA0902_SMM$S_CRDCTL_BS_H = 2;
macro KA0902_SMM$V_CRDCTL_CFE_H = 292,14,1,0 %;
literal KA0902_SMM$K_LENGTH = 296;
! 
!  DS1287A register definitions
!                            
literal KA0902_DS1287A$S_KA0902_DS1287A = 3624;
macro KA0902_DS1287A$L_PORT_INDEX = 3584,0,32,0 %;
macro KA0902_DS1287A$L_PORT_DATA = 3616,0,32,0 %;
! 
!  IIC register definitions
! 
literal KA0902_IIC$M_DATA_READ_DIR = %X'1';
literal KA0902_IIC$M_STATUS_BB = %X'1';
literal KA0902_IIC$M_STATUS_LAB = %X'2';
literal KA0902_IIC$M_STATUS_AAS = %X'4';
literal KA0902_IIC$M_STATUS_ADO = %X'8';
literal KA0902_IIC$M_STATUS_BER = %X'10';
literal KA0902_IIC$M_STATUS_STS = %X'20';
literal KA0902_IIC$M_STATUS_RES = %X'40';
literal KA0902_IIC$M_STATUS_PIN = %X'80';
literal KA0902_IIC$M_IIC_STATUS_FILL2 = %X'FFFFFF00';
literal KA0902_IIC$M_CMD_ACKB = %X'1';
literal KA0902_IIC$M_CMD_STO = %X'2';
literal KA0902_IIC$M_CMD_STA = %X'4';
literal KA0902_IIC$M_CMD_ENI = %X'8';
literal KA0902_IIC$M_CMD_S3 = %X'10';
literal KA0902_IIC$M_CMD_S2 = %X'20';
literal KA0902_IIC$M_CMD_ESO = %X'40';
literal KA0902_IIC$M_CMD_PIN = %X'80';
literal KA0902_IIC$M_IIC_CMD_FILL3 = %X'FFFFFF00';
literal KA0902_IIC$K_CPU0_EEPROM_SLAVE = 168; !  Slave address of CPU0  EEPROM
literal KA0902_IIC$K_CPU1_EEPROM_SLAVE = 170; !  Slave address of CPU0  EEPROM
literal KA0902_IIC$K_CPU2_EEPROM_SLAVE = 174; !  Slave address of CPU0  EEPROM
literal KA0902_IIC$K_CPU3_EEPROM_SLAVE = 162; !  Slave address of CPU0  EEPROM
literal KA0902_IIC$K_MEM0_EEPROM_SLAVE = 160; !  Slave address of MEM0  EEPROM
literal KA0902_IIC$K_MEM1_EEPROM_SLAVE = 162; !  Slave address of MEM1  EEPROM
literal KA0902_IIC$K_MEM2_EEPROM_SLAVE = 164; !  Slave address of MEM2  EEPROM
literal KA0902_IIC$K_MEM3_EEPROM_SLAVE = 166; !  Slave address of MEM3  EEPROM
literal KA0902_IIC$K_IO_EEPROM_SLAVE = 172; !  Slave address of I/O   EEPROM
literal KA0902_IIC$K_EXTIO_EEPROM_SLAVE = 174; !  Slave addr. of Ext.I/O EEPROM
literal KA0902_IIC$K_MASTER_SLAVE = 182; !  Slave address of master
literal KA0902_IIC$K_IIC_CLOCK = 28;    !  Clock speed 90khz + 12Mhz
literal KA0902_IIC$K_IIC_RETRY_MAX = 10; !  Maximum number of retrys
literal KA0902_IIC$S_KA0902_IIC = 42536;
macro KA0902_IIC$L_IIC_DATA = 42496,0,32,0 %;
macro KA0902_IIC$V_DATA_READ_DIR = 42496,0,1,0 %; !  Write the data
macro KA0902_IIC$L_IIC_STATUS = 42528,0,32,0 %;
macro KA0902_IIC$V_STATUS_BB = 42528,0,1,0 %; !  Bus Busy NOT
macro KA0902_IIC$V_STATUS_LAB = 42528,1,1,0 %; !  Lost Arbitration 
macro KA0902_IIC$V_STATUS_AAS = 42528,2,1,0 %; !  Addressed as Slave
macro KA0902_IIC$V_STATUS_ADO = 42528,3,1,0 %; !  Address 0/Last recieved bit
macro KA0902_IIC$V_STATUS_BER = 42528,4,1,0 %; !  Bus Error
macro KA0902_IIC$V_STATUS_STS = 42528,5,1,0 %; !  External Stop signal
macro KA0902_IIC$V_STATUS_RES = 42528,6,1,0 %; !  Reserved must be 0
macro KA0902_IIC$V_STATUS_PIN = 42528,7,1,0 %; !  Pending Interrupt NOT
macro KA0902_IIC$V_CMD_ACKB = 42528,0,1,0 %; !  Acknowledge after each byte
macro KA0902_IIC$V_CMD_STO = 42528,1,1,0 %; !  Send Stop condition
macro KA0902_IIC$V_CMD_STA = 42528,2,1,0 %; !  Send Start condition
macro KA0902_IIC$V_CMD_ENI = 42528,3,1,0 %; !  External Interrupt Enable
macro KA0902_IIC$V_CMD_S3 = 42528,4,1,0 %; !  Interrupt Vector Register
macro KA0902_IIC$V_CMD_S2 = 42528,5,1,0 %; !  Clock Register
macro KA0902_IIC$V_CMD_ESO = 42528,6,1,0 %; !  Enable serial output
macro KA0902_IIC$V_CMD_PIN = 42528,7,1,0 %; !  Pending Interrupt Not
! 
!  EISA register definitions
! 
literal KA0902_ESC$K_RID = 8;           !  Revision ID register
literal KA0902_ESC$K_MS = 64;           !  Mode Select register
literal KA0902_ESC$K_ESCID = 2;         !  EISA Config space enable
literal KA0902_ESC$K_SGRBA = 87;        !  Scatter Gather Base Address register
literal KA0902_ESC$K_PIRQ0 = 64;        !  PCI IRQ 0 register
literal KA0902_ESC$K_PIRQ1 = 65;        !  PCI IRQ 0 register
literal KA0902_ESC$K_PIRQ2 = 66;        !  PCI IRQ 0 register
literal KA0902_ESC$K_PIRQ3 = 67;        !  PCI IRQ 0 register
literal KA0902_ESC$K_EISAID0 = 80;      !  EISA ID register 0
literal KA0902_ESC$K_EISAID1 = 81;      !  EISA ID register 1
literal KA0902_ESC$K_EISAID2 = 82;      !  EISA ID register 2
literal KA0902_ESC$K_EISAID3 = 83;      !  EISA ID register 3
literal KA0902_ESC$K_CFG_ENABLE = 15;   !  Value of ESCID to enable config space
literal KA0902_ESC$S_KA0902_ESC = 35984;
macro KA0902_ESC$L_CFGAI = 1088,0,32,0 %; !  Configuration Address Index register
macro KA0902_ESC$L_CFGDI = 1120,0,32,0 %; !  Configuration Data Index register
macro KA0902_ESC$L_NMISC = 3112,0,32,0 %; !  NMI Status and Control register
macro KA0902_ESC$L_NMIESC = 35880,0,32,0 %; !  NMI Extended Status and Control
macro KA0902_ESC$L_LEBMG = 35976,0,32,0 %; !  Last EISA Bus Master Granted
!  Define index of...
 
!*** MODULE $KA0905DEF ***
literal KA0905$K_MAX_CPU_MODULES = 4;
literal KA0905$K_MAX_MEMORY_MODULES = 4;
! 
!  Gamma CPU register definitions
! 
literal KA0905_CPU$M_CREG_RN_0 = %X'F';
literal KA0905_CPU$M_CREG_FILL_01 = %X'FF0';
literal KA0905_CPU$M_CREG_EBSS_0 = %X'1000';
literal KA0905_CPU$M_CREG_FILL_02 = %X'FE000';
literal KA0905_CPU$M_CREG_EEDLY_0 = %X'100000';
literal KA0905_CPU$M_CREG_FILL_03 = %X'600000';
literal KA0905_CPU$M_CREG_EFF_0 = %X'800000';
literal KA0905_CPU$M_CREG_DIC_0 = %X'1000000';
literal KA0905_CPU$M_CREG_E4_0 = %X'2000000';
literal KA0905_CPU$M_CREG_AMB_0 = %X'4000000';
literal KA0905_CPU$M_CREG_ASD_0 = %X'8000000';
literal KA0905_CPU$M_CREG_CS_0 = %X'70000000';
literal KA0905_CPU$M_CREG_FILL_04 = %X'80000000';
literal KA0905_CPU$M_CREG_RN_1 = %X'F';
literal KA0905_CPU$M_CREG_ESI = %X'F0';
literal KA0905_CPU$M_CREG_EIOI = %X'300';
literal KA0905_CPU$M_CREG_EAIOI = %X'C00';
literal KA0905_CPU$M_CREG_EBSS_1 = %X'1000';
literal KA0905_CPU$M_CREG_FILL_05 = %X'FE000';
literal KA0905_CPU$M_CREG_EE_DLY_1 = %X'100000';
literal KA0905_CPU$M_CREG_FILL_06 = %X'600000';
literal KA0905_CPU$M_CREG_EFF_1 = %X'800000';
literal KA0905_CPU$M_CREG_DIC_1 = %X'1000000';
literal KA0905_CPU$M_CREG_E4_1 = %X'2000000';
literal KA0905_CPU$M_CREG_AMB_1 = %X'4000000';
literal KA0905_CPU$M_CREG_ASD_1 = %X'8000000';
literal KA0905_CPU$M_CREG_CS_1 = %X'70000000';
literal KA0905_CPU$M_CREG_FILL_07 = %X'80000000';
literal KA0905_CREG$K_RESERVED = 0;     !  Reserved
literal KA0905_CREG$K_CACHE_SIZE_1MB = 1; !  Cache size is 1Mb
literal KA0905_CREG$K_CACHE_SIZE_2MB = 2; !  Cache size is 2Mb
literal KA0905_CREG$K_CACHE_SIZE_4MB = 3; !  Cache size is 4Mb
literal KA0905_CREG$K_CACHE_SIZE_8MB = 4; !  Cache size is 8Mb
literal KA0905_CREG$K_CACHE_SIZE_16MB = 5; !  Cache size is 16Mb
literal KA0905_CPU$M_ESREG_EVBCEF_0 = %X'7';
literal KA0905_CPU$M_ESREG_FILL_01 = %X'8';
literal KA0905_CPU$M_ESREG_EVB_FEF_0 = %X'F0';
literal KA0905_CPU$M_ESREG_DTS_0 = %X'400';
literal KA0905_CPU$M_ESREG_FILL_02 = %X'800';
literal KA0905_CPU$M_ESREG_IBPE_0 = %X'1000';
literal KA0905_CPU$M_ESREG_IBEI_0 = %X'6000';
literal KA0905_CPU$M_ESREG_IBS_0 = %X'8000';
literal KA0905_CPU$M_ESREG_CBEF_0 = %X'FF0000';
literal KA0905_CPU$M_ESREG_CBS_0 = %X'1000000';
literal KA0905_CPU$M_ESREG_CBC_0 = %X'2000000';
literal KA0905_CPU$M_ESREG_FILL_03 = %X'C000000';
literal KA0905_CPU$M_ESREG_EVNR_0 = %X'10000000';
literal KA0905_CPU$M_ESREG_FILL_04 = %X'E0000000';
literal KA0905_CPU$M_ESREG_EVBCEF_1 = %X'7';
literal KA0905_CPU$M_ESREG_EVBCEI_1 = %X'8';
literal KA0905_CPU$M_ESREG_EVBFEF_1 = %X'F0';
literal KA0905_CPU$M_ESREG_DTS_1 = %X'400';
literal KA0905_CPU$M_ESREG_FILL_05 = %X'800';
literal KA0905_CPU$M_ESREG_IBPE_1 = %X'1000';
literal KA0905_CPU$M_ESREG_IBEI_1 = %X'6000';
literal KA0905_CPU$M_ESREG_IBS_1 = %X'8000';
literal KA0905_CPU$M_ESREG_CBEF_1 = %X'F0000';
literal KA0905_CPU$M_ESREG_FILL_06 = %X'F00000';
literal KA0905_CPU$M_ESREG_CBS_1 = %X'1000000';
literal KA0905_CPU$M_ESREG_CBC_1 = %X'2000000';
literal KA0905_CPU$M_ESREG_FILL_07 = %X'C000000';
literal KA0905_CPU$M_ESREG_EVNR_1 = %X'10000000';
literal KA0905_CPU$M_ESREG_EVSF_1 = %X'20000000';
literal KA0905_CPU$M_ESREG_FILL_08 = %X'C0000000';
literal KA0905_CPU$M_EVBCR_EACBPC_0 = %X'1';
literal KA0905_CPU$M_EVBCR_FILL_01 = %X'E';
literal KA0905_CPU$M_EVBCR_ECEI_0 = %X'10';
literal KA0905_CPU$M_EVBCR_EEC_0 = %X'20';
literal KA0905_CPU$M_EVBCR_EREC_0 = %X'40';
literal KA0905_CPU$M_EVBCR_FILL_02 = %X'7FFFF80';
literal KA0905_CPU$M_EVBCR_FFS = %X'8000000';
literal KA0905_CPU$M_EVBCR_RSFS = %X'10000000';
literal KA0905_CPU$M_EVBCR_FILL_03 = %X'E0000000';
literal KA0905_CPU$M_EVBCR_EACBPC_1 = %X'1';
literal KA0905_CPU$M_EVBCR_FILL_04 = %X'E';
literal KA0905_CPU$M_EVBCR_ECEI_1 = %X'10';
literal KA0905_CPU$M_EVBCR_EEC_1 = %X'20';
literal KA0905_CPU$M_EVBCR_EREC_1 = %X'40';
literal KA0905_CPU$M_EVBCR_DEEC_1 = %X'80';
literal KA0905_CPU$M_EVBCR_FILL_05 = %X'FFFFFF00';
literal KA0905_CPU$M_EVBVEAR_VEA_0 = %X'3FFFFFFF';
literal KA0905_CPU$M_EVBVEAR_FILL_01 = %X'C0000000';
literal KA0905_CPU$M_EVBVEAR_VEA_1 = %X'3FFFFFFF';
literal KA0905_CPU$M_EVBVEAR_FILL_02 = %X'C0000000';
literal KA0905_CPU$M_EVBCER_CE_0 = %X'3';
literal KA0905_CPU$M_EVBCER_RD_0 = %X'4';
literal KA0905_CPU$M_EVBCER_MCE_0 = %X'8';
literal KA0905_CPU$M_EVBCER_FILL_01 = %X'F0';
literal KA0905_CPU$M_EVBCER_ES_0 = %X'FF00';
literal KA0905_CPU$M_EVBCER_ES_2 = %X'FF0000';
literal KA0905_CPU$M_EVBCER_FILL_02 = %X'FF000000';
literal KA0905_CPU$M_EVBCER_CE_1 = %X'3';
literal KA0905_CPU$M_EVBCER_RD_1 = %X'4';
literal KA0905_CPU$M_EVBCER_MCE_1 = %X'8';
literal KA0905_CPU$M_EVBCER_FILL_03 = %X'F0';
literal KA0905_CPU$M_EVBCER_ES_1 = %X'FF00';
literal KA0905_CPU$M_EVBCER_ES_3 = %X'FF0000';
literal KA0905_CPU$M_EVBCER_FILL_04 = %X'FF000000';
literal KA0905_CPU$M_EVBCEAR_CEA_0 = %X'FFFFFFFF';
literal KA0905_CPU$M_EVBCEAR_CEA_1 = %X'FFFFFFFF';
literal KA0905_CPU$M_EVBUER_UE_0 = %X'3';
literal KA0905_CPU$M_EVBUER_RD_0 = %X'4';
literal KA0905_CPU$M_EVBUER_FILL_01 = %X'8';
literal KA0905_CPU$M_EVBUER_PEACB_0 = %X'10';
literal KA0905_CPU$M_EVBUER_PEVA_0 = %X'20';
literal KA0905_CPU$M_EVBUER_FILL_02 = %X'C0';
literal KA0905_CPU$M_EVBUER_ES_0 = %X'FF00';
literal KA0905_CPU$M_EVBUER_ES_2 = %X'FF0000';
literal KA0905_CPU$M_EVBUER_FILL_03 = %X'F000000';
literal KA0905_CPU$M_EVBUER_EVBCB_0 = %X'F0000000';
literal KA0905_CPU$M_EVBUER_UE_1 = %X'3';
literal KA0905_CPU$M_EVBUER_RD_1 = %X'4';
literal KA0905_CPU$M_EVBUER_FILL_04 = %X'8';
literal KA0905_CPU$M_EVBUER_PEACB_1 = %X'10';
literal KA0905_CPU$M_EVBUER_PEVA_1 = %X'20';
literal KA0905_CPU$M_EVBUER_FILL_05 = %X'C0';
literal KA0905_CPU$M_EVBUER_ES_1 = %X'FF00';
literal KA0905_CPU$M_EVBUER_ES_3 = %X'FF0000';
literal KA0905_CPU$M_EVBUER_FILL_06 = %X'F000000';
literal KA0905_CPU$M_EVBUER_EVBCB_1 = %X'F0000000';
literal KA0905_CPU$M_EVBUEAR_UEA_0 = %X'FFFFFFFF';
literal KA0905_CPU$M_EVBUEAR_UEA_1 = %X'FFFFFFFF';
literal KA0905_CPU$M_EVBRESV_FILL_01 = %X'FFFFFFFF';
literal KA0905_CPU$M_EVBRESV_FILL_02 = %X'FFFFFFFF';
literal KA0905_CPU$M_DTCTR_DTE_0 = %X'1';
literal KA0905_CPU$M_DTCTR_FILL_01 = %X'E';
literal KA0905_CPU$M_DTCTR_ECPC_0 = %X'10';
literal KA0905_CPU$M_DTCTR_FBCP = %X'20';
literal KA0905_CPU$M_DTCTR_FILL_02 = %X'C0';
literal KA0905_CPU$M_DTCTR_ETPC_0 = %X'100';
literal KA0905_CPU$M_DTCTR_FBTP = %X'200';
literal KA0905_CPU$M_DTCTR_FILL_03 = %X'C00';
literal KA0905_CPU$M_DTCTR_DTDM_0 = %X'1000';
literal KA0905_CPU$M_DTCTR_FILL_04 = %X'FFFFE000';
literal KA0905_CPU$M_DTCTR_DTE_1 = %X'1';
literal KA0905_CPU$M_DTCTR_FILL_05 = %X'E';
literal KA0905_CPU$M_DTCTR_ECPC_1 = %X'10';
literal KA0905_CPU$M_DTCTR_FILL_06 = %X'E0';
literal KA0905_CPU$M_DTCTR_ETPC_1 = %X'100';
literal KA0905_CPU$M_DTCTR_FILL_07 = %X'E00';
literal KA0905_CPU$M_DTCTR_DTDM_1 = %X'1000';
literal KA0905_CPU$M_DTCTR_FILL_08 = %X'FFFFE000';
literal KA0905_CPU$M_DTER_FILL_01 = %X'1F';
literal KA0905_CPU$M_DTER_DTEA = %X'FFFFE0';
literal KA0905_CPU$M_DTER_FILL_02 = %X'F000000';
literal KA0905_CPU$M_DTER_TCPE_0 = %X'10000000';
literal KA0905_CPU$M_DTER_FILL_03 = %X'60000000';
literal KA0905_CPU$M_DTER_TPE_0 = %X'80000000';
literal KA0905_CPU$M_DTER_FILL_04 = %X'FFFFFFF';
literal KA0905_CPU$M_DTER_TCPE_1 = %X'10000000';
literal KA0905_CPU$M_DTER_FILL_05 = %X'60000000';
literal KA0905_CPU$M_DTER_TPE_1 = %X'80000000';
literal KA0905_CPU$M_DTTCR_TCF = %X'7';
literal KA0905_CPU$M_DTTCR_TCPF = %X'8';
literal KA0905_CPU$M_DTTCR_FILL_01 = %X'10';
literal KA0905_CPU$M_DTTCR_AF = %X'FFFE0';
literal KA0905_CPU$M_DTTCR_MTAF = %X'F00000';
literal KA0905_CPU$M_DTTCR_PTF = %X'7F000000';
literal KA0905_CPU$M_DTTCR_TPF = %X'80000000';
literal KA0905_CPU$M_DTTCR_FILL_02 = %X'FFFFFFFF';
literal KA0905_CPU$M_DTTR_TC_0 = %X'7';
literal KA0905_CPU$M_DTTR_TCP_0 = %X'8';
literal KA0905_CPU$M_DTTR_FILL_01 = %X'FFFF0';
literal KA0905_CPU$M_DTTR_TD_0 = %X'7FF00000';
literal KA0905_CPU$M_DTTR_TP_0 = %X'80000000';
literal KA0905_CPU$M_DTTR_TC_1 = %X'7';
literal KA0905_CPU$M_DTTR_TCP_1 = %X'8';
literal KA0905_CPU$M_DTTR_FILL_02 = %X'FFFF0';
literal KA0905_CPU$M_DTTR_TD_1 = %X'7FF00000';
literal KA0905_CPU$M_DTTR_TP_1 = %X'80000000';
literal KA0905_CPU$M_DTRESV_FILL_01 = %X'FFFFFFFF';
literal KA0905_CPU$M_DTRESV_FILL_02 = %X'FFFFFFFF';
literal KA0905_CPU$M_IBCSR_FILL_01 = %X'F';
literal KA0905_CPU$M_IBCSR_IBPE_0 = %X'10';
literal KA0905_CPU$M_IBCSR_SCDIPE_0 = %X'20';
literal KA0905_CPU$M_IBCSR_CCDIPE_0 = %X'40';
literal KA0905_CPU$M_IBCSR_FILL_02 = %X'F80';
literal KA0905_CPU$M_IBCSR_EIPC_0 = %X'1000';
literal KA0905_CPU$M_IBCSR_DBIP_0 = %X'2000';
literal KA0905_CPU$M_IBCSR_FILL_03 = %X'FFFFC000';
literal KA0905_CPU$M_IBCSR_FILL_04 = %X'F';
literal KA0905_CPU$M_IBCSR_IBPE_1 = %X'10';
literal KA0905_CPU$M_IBCSR_SCDIPE_1 = %X'20';
literal KA0905_CPU$M_IBCSR_CCDIPE_1 = %X'40';
literal KA0905_CPU$M_IBCSR_FILL_05 = %X'F80';
literal KA0905_CPU$M_IBCSR_EIPC_1 = %X'1000';
literal KA0905_CPU$M_IBCSR_FILL_06 = %X'FFFFE000';
literal KA0905_CPU$M_IBEAR_CBCAC_0 = %X'FFFFFFFF';
literal KA0905_CPU$M_IBEAR_CBCAC_1 = %X'FFFFFFFF';
literal KA0905_CPU$M_ACR_CBE_0 = %X'1';
literal KA0905_CPU$M_ACR_FILL_01 = %X'E';
literal KA0905_CPU$M_ACR_BME_0 = %X'10';
literal KA0905_CPU$M_ACR_DME_0 = %X'20';
literal KA0905_CPU$M_ACR_FILL_02 = %X'C0';
literal KA0905_CPU$M_ACR_PME_0 = %X'100';
literal KA0905_CPU$M_ACR_BCRE_0 = %X'200';
literal KA0905_CPU$M_ACR_FILL_03 = %X'C00';
literal KA0905_CPU$M_ACR_DCBR_0 = %X'1000';
literal KA0905_CPU$M_ACR_FILL_04 = %X'FFFFE000';
literal KA0905_CPU$M_ACR_CBE_1 = %X'1';
literal KA0905_CPU$M_ACR_FILL_05 = %X'E';
literal KA0905_CPU$M_ACR_BME_1 = %X'10';
literal KA0905_CPU$M_ACR_DME_1 = %X'20';
literal KA0905_CPU$M_ACR_FILL_06 = %X'C0';
literal KA0905_CPU$M_ACR_PME_1 = %X'100';
literal KA0905_CPU$M_ACR_BCRE_1 = %X'200';
literal KA0905_CPU$M_ACR_FILL_07 = %X'C00';
literal KA0905_CPU$M_ACR_DCBR_1 = %X'1000';
literal KA0905_CPU$M_ACR_FILL_08 = %X'FFFFE000';
literal KA0905_CPU$M_CBCR_EPC_0 = %X'1';
literal KA0905_CPU$M_CBCR_DWP_0 = %X'2';
literal KA0905_CPU$M_CBCR_CAWP_0 = %X'4';
literal KA0905_CPU$M_CBCR_FILL_01 = %X'8';
literal KA0905_CPU$M_CBCR_FS = %X'10';
literal KA0905_CPU$M_CBCR_FILL_02 = %X'FE0';
literal KA0905_CPU$M_CBCR_ECBEI_0 = %X'1000';
literal KA0905_CPU$M_CBCR_FILL_03 = %X'E000';
literal KA0905_CPU$M_CBCR_DSRC = %X'10000';
literal KA0905_CPU$M_CBCR_FILL_04 = %X'FFFE0000';
literal KA0905_CPU$M_CBCR_EPC_1 = %X'1';
literal KA0905_CPU$M_CBCR_DWP_1 = %X'2';
literal KA0905_CPU$M_CBCR_CAWP_1 = %X'4';
literal KA0905_CPU$M_CBCR_FILL_05 = %X'F8';
literal KA0905_CPU$M_CBCR_CID = %X'700';
literal KA0905_CPU$M_CBCR_FILL_06 = %X'800';
literal KA0905_CPU$M_CBCR_ECBEI_1 = %X'1000';
literal KA0905_CPU$M_CBCR_FILL_07 = %X'FFFFE000';
literal KA0905_CPU$M_CBER_URE_0 = %X'1';
literal KA0905_CPU$M_CBER_FILL_01 = %X'E';
literal KA0905_CPU$M_CBER_CALLPE_0 = %X'10';
literal KA0905_CPU$M_CBER_CAHLPE_0 = %X'20';
literal KA0905_CPU$M_CBER_FILL_02 = %X'C0';
literal KA0905_CPU$M_CBER_PELW0WD = %X'100';
literal KA0905_CPU$M_CBER_PELW1WD = %X'200';
literal KA0905_CPU$M_CBER_PELW4WD = %X'400';
literal KA0905_CPU$M_CBER_PELW5WD = %X'800';
literal KA0905_CPU$M_CBER_FILL_03 = %X'F000';
literal KA0905_CPU$M_CBER_PELW0RD = %X'10000';
literal KA0905_CPU$M_CBER_PELW1RD = %X'20000';
literal KA0905_CPU$M_CBER_PELW4RD = %X'40000';
literal KA0905_CPU$M_CBER_PELW5RD = %X'80000';
literal KA0905_CPU$M_CBER_USR = %X'100000';
literal KA0905_CPU$M_CBER_FILL_04 = %X'E00000';
literal KA0905_CPU$M_CBER_CANA = %X'1000000';
literal KA0905_CPU$M_CBER_FILL_05 = %X'E000000';
literal KA0905_CPU$M_CBER_D0NA = %X'10000000';
literal KA0905_CPU$M_CBER_D1NA = %X'20000000';
literal KA0905_CPU$M_CBER_FILL_06 = %X'C0000000';
literal KA0905_CPU$M_CBER_UCR_1 = %X'1';
literal KA0905_CPU$M_CBER_FILL_07 = %X'E';
literal KA0905_CPU$M_CBER_CALLPE_1 = %X'10';
literal KA0905_CPU$M_CBER_CAHLPE_1 = %X'20';
literal KA0905_CPU$M_CBER_FILL_08 = %X'C0';
literal KA0905_CPU$M_CBER_PELW2WD = %X'100';
literal KA0905_CPU$M_CBER_PELW3WD = %X'200';
literal KA0905_CPU$M_CBER_PELW6WD = %X'400';
literal KA0905_CPU$M_CBER_PELW7WD = %X'800';
literal KA0905_CPU$M_CBER_FILL_09 = %X'F000';
literal KA0905_CPU$M_CBER_PELW2RD = %X'10000';
literal KA0905_CPU$M_CBER_PELW3RD = %X'20000';
literal KA0905_CPU$M_CBER_PELW6RD = %X'40000';
literal KA0905_CPU$M_CBER_PELW7RD = %X'80000';
literal KA0905_CPU$M_CBER_FILL_10 = %X'FFF00000';
literal KA0905_CPU$M_CBEALR_CBLA_0 = %X'FFFFFFFF';
literal KA0905_CPU$M_CBEALR_CBLA_1 = %X'FFFFFFFF';
literal KA0905_CPU$M_CBEAHR_CBHA_0 = %X'FFFFFFFF';
literal KA0905_CPU$M_CBEAHR_CBHA_1 = %X'FFFFFFFF';
literal KA0905_CPU$M_CBRESV_FILL_01 = %X'FFFFFFFF';
literal KA0905_CPU$M_CBRESV_FILL_02 = %X'FFFFFFFF';
literal KA0905_CPU$M_ALR_LAV_0 = %X'1';
literal KA0905_CPU$M_ALR_FILL_01 = %X'1E';
literal KA0905_CPU$M_ALR_LA_0 = %X'FFFFFFE0';
literal KA0905_CPU$M_ALR_LAV_1 = %X'1';
literal KA0905_CPU$M_ALR_FILL_02 = %X'1E';
literal KA0905_CPU$M_ALR_LA_1 = %X'FFFFFFE0';
literal KA0905_CPU$M_PMBR_DATA_0 = %X'FFFFFFFF';
literal KA0905_CPU$M_PMBR_DATA_1 = %X'FFFFFFFF';
literal KA0905_CPU$M_IIRR_FILL_0 = %X'FFFFFFFF';
literal KA0905_CPU$M_IIRR_FILL_02 = %X'FFF';
literal KA0905_CPU$M_IIRR_RHI = %X'1000';
literal KA0905_CPU$M_IIRR_FILL_03 = %X'E000';
literal KA0905_CPU$M_IIRR_II = %X'10000';
literal KA0905_CPU$M_IIRR_FILL_04 = %X'FFFE0000';
literal KA0905_CPU$M_SICR_CBEIC_0 = %X'1';
literal KA0905_CPU$M_SICR_FILL_01 = %X'FFFFFFFE';
literal KA0905_CPU$M_SICR_CBEIC_1 = %X'1';
literal KA0905_CPU$M_SICR_FILL_02 = %X'E';
literal KA0905_CPU$M_SICR_ITI = %X'10';
literal KA0905_CPU$M_SICR_FILL_03 = %X'E0';
literal KA0905_CPU$M_SICR_SEC = %X'100';
literal KA0905_CPU$M_SICR_FILL_04 = %X'E00';
literal KA0905_CPU$M_SICR_NHIC = %X'1000';
literal KA0905_CPU$M_SICR_FILL_05 = %X'E000';
literal KA0905_CPU$M_SICR_IIC = %X'10000';
literal KA0905_CPU$M_SICR_FILL_06 = %X'E0000';
literal KA0905_CPU$M_SICR_IOII = %X'300000';
literal KA0905_CPU$M_SICR_FILL_07 = %X'FFC00000';
literal KA0905_CPU$M_PMCR_SS_0 = %X'1';
literal KA0905_CPU$M_PMCR_FILL_01 = %X'E';
literal KA0905_CPU$M_PMCR_AM_0 = %X'30';
literal KA0905_CPU$M_PMCR_FILL_02 = %X'FC0';
literal KA0905_CPU$M_PMCR_SPMR10 = %X'F000';
literal KA0905_CPU$M_PMCR_SPMR9 = %X'F0000';
literal KA0905_CPU$M_PMCR_SPMR8 = %X'F00000';
literal KA0905_CPU$M_PMCR_SPMR7 = %X'F000000';
literal KA0905_CPU$M_PMCR_SPMR6 = %X'F0000000';
literal KA0905_CPU$M_PMCR_SS_1 = %X'1';
literal KA0905_CPU$M_PMCR_EPMO = %X'6';
literal KA0905_CPU$M_PMCR_FILL_03 = %X'8';
literal KA0905_CPU$M_PMCR_AM_1 = %X'30';
literal KA0905_CPU$M_PMCR_CIDMASK = %X'1C0';
literal KA0905_CPU$M_PMCR_CIDMATCH = %X'E00';
literal KA0905_CPU$M_PMCR_SPMR5 = %X'F000';
literal KA0905_CPU$M_PMCR_SPMR4 = %X'F0000';
literal KA0905_CPU$M_PMCR_SPMR3 = %X'F00000';
literal KA0905_CPU$M_PMCR_SPMR2 = %X'F000000';
literal KA0905_CPU$M_PMCR_SPMR1 = %X'F0000000';
literal KA0905_CPU$M_PMR1_C6 = %X'7FFFFFFF';
literal KA0905_CPU$M_PMR1_OF6 = %X'80000000';
literal KA0905_CPU$M_PMR1_C1 = %X'7FFFFFFF';
literal KA0905_CPU$M_PMR1_OF1 = %X'80000000';
literal KA0905_CPU$M_PMR2_C7 = %X'7FFFFFFF';
literal KA0905_CPU$M_PMR2_OF7 = %X'80000000';
literal KA0905_CPU$M_PMR2_C2 = %X'7FFFFFFF';
literal KA0905_CPU$M_PMR2_OF2 = %X'80000000';
literal KA0905_CPU$M_PMR3_C8 = %X'7FFFFFFF';
literal KA0905_CPU$M_PMR3_OF8 = %X'80000000';
literal KA0905_CPU$M_PMR3_C3 = %X'7FFFFFFF';
literal KA0905_CPU$M_PMR3_OF3 = %X'80000000';
literal KA0905_CPU$M_PMR4_C9 = %X'7FFFFFFF';
literal KA0905_CPU$M_PMR4_OF9 = %X'80000000';
literal KA0905_CPU$M_PMR4_C4 = %X'7FFFFFFF';
literal KA0905_CPU$M_PMR4_OF4 = %X'80000000';
literal KA0905_CPU$M_PMR5_C10 = %X'7FFFFFFF';
literal KA0905_CPU$M_PMR5_OF10 = %X'80000000';
literal KA0905_CPU$M_PMR5_C5 = %X'7FFFFFFF';
literal KA0905_CPU$M_PMR5_OF5 = %X'80000000';
literal KA0905_CPU$S_KA0905_CPU = 1000;
!  Configuration Register, CREG
macro KA0905_CPU$Q_CREG = 0,0,0,1 %;
literal KA0905_CPU$S_CREG = 8;
macro KA0905_CPU$L_CREG_L = 0,0,32,0 %;
macro KA0905_CPU$V_CREG_RN_0 = 0,0,4,0 %;
literal KA0905_CPU$S_CREG_RN_0 = 4;     !  Revision Number 0
macro KA0905_CPU$V_CREG_FILL_01 = 0,4,8,0 %;
literal KA0905_CPU$S_CREG_FILL_01 = 8;
macro KA0905_CPU$V_CREG_EBSS_0 = 0,12,1,0 %; !  Enable Bus sizing Support 0
macro KA0905_CPU$V_CREG_FILL_02 = 0,13,7,0 %;
literal KA0905_CPU$S_CREG_FILL_02 = 7;
macro KA0905_CPU$V_CREG_EEDLY_0 = 0,20,1,0 %; !  Enable EXCH DYL 0
macro KA0905_CPU$V_CREG_FILL_03 = 0,21,2,0 %;
literal KA0905_CPU$S_CREG_FILL_03 = 2;
macro KA0905_CPU$V_CREG_EFF_0 = 0,23,1,0 %; !  Enable Fast Fill 0
macro KA0905_CPU$V_CREG_DIC_0 = 0,24,1,0 %; !  Disable IDELBC-CSTALL 0
macro KA0905_CPU$V_CREG_E4_0 = 0,25,1,0 %; !  Enable 4IDLEBC 0
macro KA0905_CPU$V_CREG_AMB_0 = 0,26,1,0 %; !  Ack MB 0
macro KA0905_CPU$V_CREG_ASD_0 = 0,27,1,0 %; !  Ack Set Dirty 0
macro KA0905_CPU$V_CREG_CS_0 = 0,28,3,0 %;
literal KA0905_CPU$S_CREG_CS_0 = 3;     !  Cache Size 0
macro KA0905_CPU$V_CREG_FILL_04 = 0,31,1,0 %;
macro KA0905_CPU$L_CREG_H = 4,0,32,0 %;
macro KA0905_CPU$V_CREG_RN_1 = 4,0,4,0 %;
literal KA0905_CPU$S_CREG_RN_1 = 4;     !  Revision Number 1
macro KA0905_CPU$V_CREG_ESI = 4,4,4,0 %;
literal KA0905_CPU$S_CREG_ESI = 4;      !  Enable System Interrupts
macro KA0905_CPU$V_CREG_EIOI = 4,8,2,0 %;
literal KA0905_CPU$S_CREG_EIOI = 2;     !  Enable I/O Interrupts
macro KA0905_CPU$V_CREG_EAIOI = 4,10,2,0 %;
literal KA0905_CPU$S_CREG_EAIOI = 2;    !  Enable Alt I/O Interrupts
macro KA0905_CPU$V_CREG_EBSS_1 = 4,12,1,0 %; !  Enable Bus sizing Support 1
macro KA0905_CPU$V_CREG_FILL_05 = 4,13,7,0 %;
literal KA0905_CPU$S_CREG_FILL_05 = 7;
macro KA0905_CPU$V_CREG_EE_DLY_1 = 4,20,1,0 %; !  Enable EXCH DYL 1
macro KA0905_CPU$V_CREG_FILL_06 = 4,21,2,0 %;
literal KA0905_CPU$S_CREG_FILL_06 = 2;
macro KA0905_CPU$V_CREG_EFF_1 = 4,23,1,0 %; !  Enable Fast Fill 1
macro KA0905_CPU$V_CREG_DIC_1 = 4,24,1,0 %; !  Disable IDELBC-STALL 1
macro KA0905_CPU$V_CREG_E4_1 = 4,25,1,0 %; !  Enable 4IDLEBC 1
macro KA0905_CPU$V_CREG_AMB_1 = 4,26,1,0 %; !  Ack MB 1
macro KA0905_CPU$V_CREG_ASD_1 = 4,27,1,0 %; !  Ack Set Dirty 1
macro KA0905_CPU$V_CREG_CS_1 = 4,28,3,0 %;
literal KA0905_CPU$S_CREG_CS_1 = 3;     !  Cache Size 1
macro KA0905_CPU$V_CREG_FILL_07 = 4,31,1,0 %;
!  Error Summary Register, ESREG
macro KA0905_CPU$Q_ESREG = 32,0,0,1 %;
literal KA0905_CPU$S_ESREG = 8;
macro KA0905_CPU$L_ESREG_L = 32,0,32,0 %;
macro KA0905_CPU$V_ESREG_EVBCEF_0 = 32,0,3,0 %;
literal KA0905_CPU$S_ESREG_EVBCEF_0 = 3; !  EVB Correctable Error Field 0
macro KA0905_CPU$V_ESREG_FILL_01 = 32,3,1,0 %;
macro KA0905_CPU$V_ESREG_EVB_FEF_0 = 32,4,4,0 %;
literal KA0905_CPU$S_ESREG_EVB_FEF_0 = 4; !  EVB Fatal Error Field 0
macro KA0905_CPU$V_ESREG_DTS_0 = 32,10,1,0 %; !  DT Summary 0
macro KA0905_CPU$V_ESREG_FILL_02 = 32,11,1,0 %;
macro KA0905_CPU$V_ESREG_IBPE_0 = 32,12,1,0 %; !  IB Parity Error 0
macro KA0905_CPU$V_ESREG_IBEI_0 = 32,13,2,0 %;
literal KA0905_CPU$S_ESREG_IBEI_0 = 2;  !  IB Error Info 0
macro KA0905_CPU$V_ESREG_IBS_0 = 32,15,1,0 %; !  IB Summary 0
macro KA0905_CPU$V_ESREG_CBEF_0 = 32,16,8,0 %;
literal KA0905_CPU$S_ESREG_CBEF_0 = 8;  !  CB Error Field 0
macro KA0905_CPU$V_ESREG_CBS_0 = 32,24,1,0 %; !  CB Summary 0
macro KA0905_CPU$V_ESREG_CBC_0 = 32,25,1,0 %; !  CB CMDR 0
macro KA0905_CPU$V_ESREG_FILL_03 = 32,26,2,0 %;
literal KA0905_CPU$S_ESREG_FILL_03 = 2;
macro KA0905_CPU$V_ESREG_EVNR_0 = 32,28,1,0 %; !  EV Noresponse 0
macro KA0905_CPU$V_ESREG_FILL_04 = 32,29,3,0 %;
literal KA0905_CPU$S_ESREG_FILL_04 = 3;
macro KA0905_CPU$L_ESREG_H = 36,0,32,0 %;
macro KA0905_CPU$V_ESREG_EVBCEF_1 = 36,0,3,0 %;
literal KA0905_CPU$S_ESREG_EVBCEF_1 = 3; !  EVB Correctable Error Field 1
macro KA0905_CPU$V_ESREG_EVBCEI_1 = 36,3,1,0 %; !  EVB Correctable Error Int 1
macro KA0905_CPU$V_ESREG_EVBFEF_1 = 36,4,4,0 %;
literal KA0905_CPU$S_ESREG_EVBFEF_1 = 4; !  EVB Fatal Error Field 1
macro KA0905_CPU$V_ESREG_DTS_1 = 36,10,1,0 %; !  DT Summary 1
macro KA0905_CPU$V_ESREG_FILL_05 = 36,11,1,0 %;
macro KA0905_CPU$V_ESREG_IBPE_1 = 36,12,1,0 %; !  IB Parity Error 1
macro KA0905_CPU$V_ESREG_IBEI_1 = 36,13,2,0 %;
literal KA0905_CPU$S_ESREG_IBEI_1 = 2;  !  IB Error Info 1
macro KA0905_CPU$V_ESREG_IBS_1 = 36,15,1,0 %; !  IB Summary 1
macro KA0905_CPU$V_ESREG_CBEF_1 = 36,16,4,0 %;
literal KA0905_CPU$S_ESREG_CBEF_1 = 4;  !  CB Error Field 1
macro KA0905_CPU$V_ESREG_FILL_06 = 36,20,4,0 %;
literal KA0905_CPU$S_ESREG_FILL_06 = 4;
macro KA0905_CPU$V_ESREG_CBS_1 = 36,24,1,0 %; !  CB Summary 1
macro KA0905_CPU$V_ESREG_CBC_1 = 36,25,1,0 %; !  CB CMDR 1
macro KA0905_CPU$V_ESREG_FILL_07 = 36,26,2,0 %;
literal KA0905_CPU$S_ESREG_FILL_07 = 2;
macro KA0905_CPU$V_ESREG_EVNR_1 = 36,28,1,0 %; !  EV Noresponse 1
macro KA0905_CPU$V_ESREG_EVSF_1 = 36,29,1,0 %; !  EX Sysfail 1
macro KA0905_CPU$V_ESREG_FILL_08 = 36,30,2,0 %;
literal KA0905_CPU$S_ESREG_FILL_08 = 2;
!  EVBCR Control Register, EVBCR
macro KA0905_CPU$Q_EVBCR = 64,0,0,1 %;
literal KA0905_CPU$S_EVBCR = 8;
macro KA0905_CPU$L_EVBCR_L = 64,0,32,0 %;
macro KA0905_CPU$V_EVBCR_EACBPC_0 = 64,0,1,0 %; !  Enable Addr-CMD Bus Parity 0
macro KA0905_CPU$V_EVBCR_FILL_01 = 64,1,3,0 %;
literal KA0905_CPU$S_EVBCR_FILL_01 = 3;
macro KA0905_CPU$V_EVBCR_ECEI_0 = 64,4,1,0 %; !  Enable Corr Error Int 0
macro KA0905_CPU$V_EVBCR_EEC_0 = 64,5,1,0 %; !  Enable ECC Correction 0
macro KA0905_CPU$V_EVBCR_EREC_0 = 64,6,1,0 %; !  Enable Rattler ECC Checking 0
macro KA0905_CPU$V_EVBCR_FILL_02 = 64,7,20,0 %;
literal KA0905_CPU$S_EVBCR_FILL_02 = 20;
macro KA0905_CPU$V_EVBCR_FFS = 64,27,1,0 %; !  Force Filled Shared
macro KA0905_CPU$V_EVBCR_RSFS = 64,28,1,0 %; !  RMM STXC Filled Shared
macro KA0905_CPU$V_EVBCR_FILL_03 = 64,29,3,0 %;
literal KA0905_CPU$S_EVBCR_FILL_03 = 3;
macro KA0905_CPU$L_EVBCR_H = 68,0,32,0 %;
macro KA0905_CPU$V_EVBCR_EACBPC_1 = 68,0,1,0 %; !  Enable Addr-CMD Bus Parity 1
macro KA0905_CPU$V_EVBCR_FILL_04 = 68,1,3,0 %;
literal KA0905_CPU$S_EVBCR_FILL_04 = 3;
macro KA0905_CPU$V_EVBCR_ECEI_1 = 68,4,1,0 %; !  Enable Corr Error Int 1
macro KA0905_CPU$V_EVBCR_EEC_1 = 68,5,1,0 %; !  Enable ECC Correction 1
macro KA0905_CPU$V_EVBCR_EREC_1 = 68,6,1,0 %; !  Enable Rattler ECC Checking 1
macro KA0905_CPU$V_EVBCR_DEEC_1 = 68,7,1,0 %; !  Disable EV5 ECC Checking 1
macro KA0905_CPU$V_EVBCR_FILL_05 = 68,8,24,0 %;
literal KA0905_CPU$S_EVBCR_FILL_05 = 24;
!  EVB Victim Error Address Register, EVBVEAR
macro KA0905_CPU$Q_EVBVEAR = 96,0,0,1 %;
literal KA0905_CPU$S_EVBVEAR = 8;
macro KA0905_CPU$L_EVBVEAR_L = 96,0,32,0 %;
macro KA0905_CPU$V_EVBVEAR_VEA_0 = 96,0,30,0 %;
literal KA0905_CPU$S_EVBVEAR_VEA_0 = 30; !  Victim Err Address 0
macro KA0905_CPU$V_EVBVEAR_FILL_01 = 96,30,2,0 %;
literal KA0905_CPU$S_EVBVEAR_FILL_01 = 2;
macro KA0905_CPU$L_EVBVEAR_H = 100,0,32,0 %;
macro KA0905_CPU$V_EVBVEAR_VEA_1 = 100,0,30,0 %;
literal KA0905_CPU$S_EVBVEAR_VEA_1 = 30; !  Victim Err Address 1
macro KA0905_CPU$V_EVBVEAR_FILL_02 = 100,30,2,0 %;
literal KA0905_CPU$S_EVBVEAR_FILL_02 = 2;
!  EVB Correctable Error Register, EVBCER
macro KA0905_CPU$Q_EVBCER = 128,0,0,1 %;
literal KA0905_CPU$S_EVBCER = 8;
macro KA0905_CPU$L_EVBCER_L = 128,0,32,0 %;
macro KA0905_CPU$V_EVBCER_CE_0 = 128,0,2,0 %;
literal KA0905_CPU$S_EVBCER_CE_0 = 2;   !  Correctable Error 0
macro KA0905_CPU$V_EVBCER_RD_0 = 128,2,1,0 %; !  Read Dirty 0
macro KA0905_CPU$V_EVBCER_MCE_0 = 128,3,1,0 %; !  Missed correctable Error 0
macro KA0905_CPU$V_EVBCER_FILL_01 = 128,4,4,0 %;
literal KA0905_CPU$S_EVBCER_FILL_01 = 4;
macro KA0905_CPU$V_EVBCER_ES_0 = 128,8,8,0 %;
literal KA0905_CPU$S_EVBCER_ES_0 = 8;   !  ECC Syndrome 0
macro KA0905_CPU$V_EVBCER_ES_2 = 128,16,8,0 %;
literal KA0905_CPU$S_EVBCER_ES_2 = 8;   !  ECC Syndrome 2
macro KA0905_CPU$V_EVBCER_FILL_02 = 128,24,8,0 %;
literal KA0905_CPU$S_EVBCER_FILL_02 = 8;
macro KA0905_CPU$L_EVBCER_H = 132,0,32,0 %;
macro KA0905_CPU$V_EVBCER_CE_1 = 132,0,2,0 %;
literal KA0905_CPU$S_EVBCER_CE_1 = 2;   !  Correctable Error 1
macro KA0905_CPU$V_EVBCER_RD_1 = 132,2,1,0 %; !  Read Dirty 1
macro KA0905_CPU$V_EVBCER_MCE_1 = 132,3,1,0 %; !  Missed correctable Error 1
macro KA0905_CPU$V_EVBCER_FILL_03 = 132,4,4,0 %;
literal KA0905_CPU$S_EVBCER_FILL_03 = 4;
macro KA0905_CPU$V_EVBCER_ES_1 = 132,8,8,0 %;
literal KA0905_CPU$S_EVBCER_ES_1 = 8;   !  ECC Syndrome 1
macro KA0905_CPU$V_EVBCER_ES_3 = 132,16,8,0 %;
literal KA0905_CPU$S_EVBCER_ES_3 = 8;   !  ECC Syndrome 3
macro KA0905_CPU$V_EVBCER_FILL_04 = 132,24,8,0 %;
literal KA0905_CPU$S_EVBCER_FILL_04 = 8;
!  EVB Correctable Error Address Register, EVBCEAR
macro KA0905_CPU$Q_EVBCEAR = 160,0,0,1 %;
literal KA0905_CPU$S_EVBCEAR = 8;
macro KA0905_CPU$L_EVBCEAR_L = 160,0,32,0 %;
macro KA0905_CPU$V_EVBCEAR_CEA_0 = 160,0,32,0 %;
literal KA0905_CPU$S_EVBCEAR_CEA_0 = 32; !  Corr Err Addr 0
macro KA0905_CPU$L_EVBCEAR_H = 164,0,32,0 %;
macro KA0905_CPU$V_EVBCEAR_CEA_1 = 164,0,32,0 %;
literal KA0905_CPU$S_EVBCEAR_CEA_1 = 32; !  Corr Err Addr 1
!  EVB Uncorrectable Error Register, EVBUER
macro KA0905_CPU$Q_EVBUER = 192,0,0,1 %;
literal KA0905_CPU$S_EVBUER = 8;
macro KA0905_CPU$L_EVBUER_L = 192,0,32,0 %;
macro KA0905_CPU$V_EVBUER_UE_0 = 192,0,2,0 %;
literal KA0905_CPU$S_EVBUER_UE_0 = 2;   !  Uncorrectable Error 0
macro KA0905_CPU$V_EVBUER_RD_0 = 192,2,1,0 %; !  Read Dirty 0
macro KA0905_CPU$V_EVBUER_FILL_01 = 192,3,1,0 %;
macro KA0905_CPU$V_EVBUER_PEACB_0 = 192,4,1,0 %; !  Parity Err on Addr-CMD Bus 0
macro KA0905_CPU$V_EVBUER_PEVA_0 = 192,5,1,0 %; !  Parity Err on Victim Addr 0
macro KA0905_CPU$V_EVBUER_FILL_02 = 192,6,2,0 %;
literal KA0905_CPU$S_EVBUER_FILL_02 = 2;
macro KA0905_CPU$V_EVBUER_ES_0 = 192,8,8,0 %;
literal KA0905_CPU$S_EVBUER_ES_0 = 8;   !  ECC Syndrome 0
macro KA0905_CPU$V_EVBUER_ES_2 = 192,16,8,0 %;
literal KA0905_CPU$S_EVBUER_ES_2 = 8;   !  ECC Syndrome 2
macro KA0905_CPU$V_EVBUER_FILL_03 = 192,24,4,0 %;
literal KA0905_CPU$S_EVBUER_FILL_03 = 4;
macro KA0905_CPU$V_EVBUER_EVBCB_0 = 192,28,4,0 %;
literal KA0905_CPU$S_EVBUER_EVBCB_0 = 4; !  EVB CMD-Bus 0
macro KA0905_CPU$L_EVBUER_H = 196,0,32,0 %;
macro KA0905_CPU$V_EVBUER_UE_1 = 196,0,2,0 %;
literal KA0905_CPU$S_EVBUER_UE_1 = 2;   !  Uncorrectable Error 1
macro KA0905_CPU$V_EVBUER_RD_1 = 196,2,1,0 %; !  Read Dirty 1
macro KA0905_CPU$V_EVBUER_FILL_04 = 196,3,1,0 %;
macro KA0905_CPU$V_EVBUER_PEACB_1 = 196,4,1,0 %; !  Parity Err on Addr-CMD Bus 1
macro KA0905_CPU$V_EVBUER_PEVA_1 = 196,5,1,0 %; !  Parity Err on Victim Addr 1
macro KA0905_CPU$V_EVBUER_FILL_05 = 196,6,2,0 %;
literal KA0905_CPU$S_EVBUER_FILL_05 = 2;
macro KA0905_CPU$V_EVBUER_ES_1 = 196,8,8,0 %;
literal KA0905_CPU$S_EVBUER_ES_1 = 8;   !  ECC Syndrome 1
macro KA0905_CPU$V_EVBUER_ES_3 = 196,16,8,0 %;
literal KA0905_CPU$S_EVBUER_ES_3 = 8;   !  ECC Syndrome 3
macro KA0905_CPU$V_EVBUER_FILL_06 = 196,24,4,0 %;
literal KA0905_CPU$S_EVBUER_FILL_06 = 4;
macro KA0905_CPU$V_EVBUER_EVBCB_1 = 196,28,4,0 %;
literal KA0905_CPU$S_EVBUER_EVBCB_1 = 4; !  EVB CMD-Bus 1
!  EVB Uncorrectable Error Address Register, EVBUEAR
macro KA0905_CPU$Q_EVBUEAR = 224,0,0,1 %;
literal KA0905_CPU$S_EVBUEAR = 8;
macro KA0905_CPU$L_EVBUEAR_L = 224,0,32,0 %;
macro KA0905_CPU$V_EVBUEAR_UEA_0 = 224,0,32,0 %;
literal KA0905_CPU$S_EVBUEAR_UEA_0 = 32; !  Uncorr Err Address 0
macro KA0905_CPU$L_EVBUEAR_H = 228,0,32,0 %;
macro KA0905_CPU$V_EVBUEAR_UEA_1 = 228,0,32,0 %;
literal KA0905_CPU$S_EVBUEAR_UEA_1 = 32; !  Uncorr Err Address 1
!  EVB Reserver Register, EVBRESV
macro KA0905_CPU$Q_EVBRESV = 256,0,0,1 %;
literal KA0905_CPU$S_EVBRESV = 8;
macro KA0905_CPU$L_EVBRESV_L = 256,0,32,0 %;
macro KA0905_CPU$V_EVBRESV_FILL_01 = 256,0,32,0 %;
literal KA0905_CPU$S_EVBRESV_FILL_01 = 32;
macro KA0905_CPU$L_EVBRESV_H = 260,0,32,0 %;
macro KA0905_CPU$V_EVBRESV_FILL_02 = 260,0,32,0 %;
literal KA0905_CPU$S_EVBRESV_FILL_02 = 32;
!  Duplicate tag Control Register, DTCTR
macro KA0905_CPU$Q_DTCTR = 288,0,0,1 %;
literal KA0905_CPU$S_DTCTR = 8;
macro KA0905_CPU$L_DTCTR_L = 288,0,32,0 %;
macro KA0905_CPU$V_DTCTR_DTE_0 = 288,0,1,0 %; !  Duplicate Tag Enable 0
macro KA0905_CPU$V_DTCTR_FILL_01 = 288,1,3,0 %;
literal KA0905_CPU$S_DTCTR_FILL_01 = 3;
macro KA0905_CPU$V_DTCTR_ECPC_0 = 288,4,1,0 %; !  Ena ctrl Parity Checking 0
macro KA0905_CPU$V_DTCTR_FBCP = 288,5,1,0 %; !  Fill Bad Control Parity
macro KA0905_CPU$V_DTCTR_FILL_02 = 288,6,2,0 %;
literal KA0905_CPU$S_DTCTR_FILL_02 = 2;
macro KA0905_CPU$V_DTCTR_ETPC_0 = 288,8,1,0 %; !  Enable Tag Parity Checking 0
macro KA0905_CPU$V_DTCTR_FBTP = 288,9,1,0 %; !  Fill Bad Tag Parity
macro KA0905_CPU$V_DTCTR_FILL_03 = 288,10,2,0 %;
literal KA0905_CPU$S_DTCTR_FILL_03 = 2;
macro KA0905_CPU$V_DTCTR_DTDM_0 = 288,12,1,0 %; !  Duplicate Tag Diag Mode 0
macro KA0905_CPU$V_DTCTR_FILL_04 = 288,13,19,0 %;
literal KA0905_CPU$S_DTCTR_FILL_04 = 19;
macro KA0905_CPU$L_DTCTR_H = 292,0,32,0 %;
macro KA0905_CPU$V_DTCTR_DTE_1 = 292,0,1,0 %; !  Duplicate Tag Enable 1
macro KA0905_CPU$V_DTCTR_FILL_05 = 292,1,3,0 %;
literal KA0905_CPU$S_DTCTR_FILL_05 = 3;
macro KA0905_CPU$V_DTCTR_ECPC_1 = 292,4,1,0 %; !  Ena ctrl Parity Checking 1
macro KA0905_CPU$V_DTCTR_FILL_06 = 292,5,3,0 %;
literal KA0905_CPU$S_DTCTR_FILL_06 = 3;
macro KA0905_CPU$V_DTCTR_ETPC_1 = 292,8,1,0 %; !  Enable Tag Parity Checking 1
macro KA0905_CPU$V_DTCTR_FILL_07 = 292,9,3,0 %;
literal KA0905_CPU$S_DTCTR_FILL_07 = 3;
macro KA0905_CPU$V_DTCTR_DTDM_1 = 292,12,1,0 %; !  Duplicate Tag Diag Mode 1
macro KA0905_CPU$V_DTCTR_FILL_08 = 292,13,19,0 %;
literal KA0905_CPU$S_DTCTR_FILL_08 = 19;
!  Duplicate Tag Error Register, DTER
macro KA0905_CPU$Q_DTER = 320,0,0,1 %;
literal KA0905_CPU$S_DTER = 8;
macro KA0905_CPU$L_DTER_L = 320,0,32,0 %;
macro KA0905_CPU$V_DTER_FILL_01 = 320,0,5,0 %;
literal KA0905_CPU$S_DTER_FILL_01 = 5;
macro KA0905_CPU$V_DTER_DTEA = 320,5,19,0 %;
literal KA0905_CPU$S_DTER_DTEA = 19;    !  DTER Error Address
macro KA0905_CPU$V_DTER_FILL_02 = 320,24,4,0 %;
literal KA0905_CPU$S_DTER_FILL_02 = 4;
macro KA0905_CPU$V_DTER_TCPE_0 = 320,28,1,0 %; !  Tag Con Par Error 0
macro KA0905_CPU$V_DTER_FILL_03 = 320,29,2,0 %;
literal KA0905_CPU$S_DTER_FILL_03 = 2;
macro KA0905_CPU$V_DTER_TPE_0 = 320,31,1,0 %; !  Tag Parity Error 0
macro KA0905_CPU$L_DTER_H = 324,0,32,0 %;
macro KA0905_CPU$V_DTER_FILL_04 = 324,0,28,0 %;
literal KA0905_CPU$S_DTER_FILL_04 = 28;
macro KA0905_CPU$V_DTER_TCPE_1 = 324,28,1,0 %; !  Tag Con Par Error 1
macro KA0905_CPU$V_DTER_FILL_05 = 324,29,2,0 %;
literal KA0905_CPU$S_DTER_FILL_05 = 2;
macro KA0905_CPU$V_DTER_TPE_1 = 324,31,1,0 %; !  Tag Parity Error 1
!  Duplicate_Tag Test Control Register, DTTCR
macro KA0905_CPU$Q_DTTCR = 352,0,0,1 %;
literal KA0905_CPU$S_DTTCR = 8;
macro KA0905_CPU$L_DTTCR_L = 352,0,32,0 %;
macro KA0905_CPU$V_DTTCR_TCF = 352,0,3,0 %;
literal KA0905_CPU$S_DTTCR_TCF = 3;     !  Tag Control Field
macro KA0905_CPU$V_DTTCR_TCPF = 352,3,1,0 %; !  Tag Control Parity Field
macro KA0905_CPU$V_DTTCR_FILL_01 = 352,4,1,0 %;
macro KA0905_CPU$V_DTTCR_AF = 352,5,15,0 %;
literal KA0905_CPU$S_DTTCR_AF = 15;     !  Address Field
macro KA0905_CPU$V_DTTCR_MTAF = 352,20,4,0 %;
literal KA0905_CPU$S_DTTCR_MTAF = 4;    !  Mux Tag Address Field
macro KA0905_CPU$V_DTTCR_PTF = 352,24,7,0 %;
literal KA0905_CPU$S_DTTCR_PTF = 7;     !  Partial Tag Field
macro KA0905_CPU$V_DTTCR_TPF = 352,31,1,0 %; !  Tag Parity field
macro KA0905_CPU$L_DTTCR_H = 356,0,32,0 %;
macro KA0905_CPU$V_DTTCR_FILL_02 = 356,0,32,0 %;
literal KA0905_CPU$S_DTTCR_FILL_02 = 32;
!  Duplicate Tag Test Register, DTTR
macro KA0905_CPU$Q_DTTR = 384,0,0,1 %;
literal KA0905_CPU$S_DTTR = 8;
macro KA0905_CPU$L_DTTR_L = 384,0,32,0 %;
macro KA0905_CPU$V_DTTR_TC_0 = 384,0,3,0 %;
literal KA0905_CPU$S_DTTR_TC_0 = 3;     !  Tag Control 0
macro KA0905_CPU$V_DTTR_TCP_0 = 384,3,1,0 %; !  Tag Control Parity 0
macro KA0905_CPU$V_DTTR_FILL_01 = 384,4,16,0 %;
literal KA0905_CPU$S_DTTR_FILL_01 = 16;
macro KA0905_CPU$V_DTTR_TD_0 = 384,20,11,0 %;
literal KA0905_CPU$S_DTTR_TD_0 = 11;    !  Tag Data 0
macro KA0905_CPU$V_DTTR_TP_0 = 384,31,1,0 %; !  Tag Parity 0
macro KA0905_CPU$L_DTTR_H = 388,0,32,0 %;
macro KA0905_CPU$V_DTTR_TC_1 = 388,0,3,0 %;
literal KA0905_CPU$S_DTTR_TC_1 = 3;     !  Tag Control 1
macro KA0905_CPU$V_DTTR_TCP_1 = 388,3,1,0 %; !  Tag Control Parity 1
macro KA0905_CPU$V_DTTR_FILL_02 = 388,4,16,0 %;
literal KA0905_CPU$S_DTTR_FILL_02 = 16;
macro KA0905_CPU$V_DTTR_TD_1 = 388,20,11,0 %;
literal KA0905_CPU$S_DTTR_TD_1 = 11;    !  Tag Data 1
macro KA0905_CPU$V_DTTR_TP_1 = 388,31,1,0 %; !  Tag Parity 1
!  Duplicate Tag Reserve Register, DTRESV
macro KA0905_CPU$Q_DTRESV = 416,0,0,1 %;
literal KA0905_CPU$S_DTRESV = 8;
macro KA0905_CPU$L_DTRESV_L = 416,0,32,0 %;
macro KA0905_CPU$V_DTRESV_FILL_01 = 416,0,32,0 %;
literal KA0905_CPU$S_DTRESV_FILL_01 = 32;
macro KA0905_CPU$L_DTRESV_H = 420,0,32,0 %;
macro KA0905_CPU$V_DTRESV_FILL_02 = 420,0,32,0 %;
literal KA0905_CPU$S_DTRESV_FILL_02 = 32;
!  I-Bus Control and Status Register, IBCSR
macro KA0905_CPU$Q_IBCSR = 448,0,0,1 %;
literal KA0905_CPU$S_IBCSR = 8;
macro KA0905_CPU$L_IBCSR_L = 448,0,32,0 %;
macro KA0905_CPU$V_IBCSR_FILL_01 = 448,0,4,0 %;
literal KA0905_CPU$S_IBCSR_FILL_01 = 4;
macro KA0905_CPU$V_IBCSR_IBPE_0 = 448,4,1,0 %; !  I-bus Parity Error 0
macro KA0905_CPU$V_IBCSR_SCDIPE_0 = 448,5,1,0 %; !  Snoop Cyc During I-bus Par Error 0
macro KA0905_CPU$V_IBCSR_CCDIPE_0 = 448,6,1,0 %; !  CMDR Cyc During I-bus Par Error 0
macro KA0905_CPU$V_IBCSR_FILL_02 = 448,7,5,0 %;
literal KA0905_CPU$S_IBCSR_FILL_02 = 5;
macro KA0905_CPU$V_IBCSR_EIPC_0 = 448,12,1,0 %; !  Enable I-bus Par Checking 0
macro KA0905_CPU$V_IBCSR_DBIP_0 = 448,13,1,0 %; !  Drive Bad I-bus Parity 0
macro KA0905_CPU$V_IBCSR_FILL_03 = 448,14,18,0 %;
literal KA0905_CPU$S_IBCSR_FILL_03 = 18;
macro KA0905_CPU$L_IBCSR_H = 452,0,32,0 %;
macro KA0905_CPU$V_IBCSR_FILL_04 = 452,0,4,0 %;
literal KA0905_CPU$S_IBCSR_FILL_04 = 4;
macro KA0905_CPU$V_IBCSR_IBPE_1 = 452,4,1,0 %; !  I-bus Parity Error 1
macro KA0905_CPU$V_IBCSR_SCDIPE_1 = 452,5,1,0 %; !  Snoop Cyc During I-bus Par Error 1
macro KA0905_CPU$V_IBCSR_CCDIPE_1 = 452,6,1,0 %; !  CMDR Cyc During I-bus Par Error 1
macro KA0905_CPU$V_IBCSR_FILL_05 = 452,7,5,0 %;
literal KA0905_CPU$S_IBCSR_FILL_05 = 5;
macro KA0905_CPU$V_IBCSR_EIPC_1 = 452,12,1,0 %; !  Enable I-bus Par Checking 1
macro KA0905_CPU$V_IBCSR_FILL_06 = 452,13,19,0 %;
literal KA0905_CPU$S_IBCSR_FILL_06 = 19;
!  I-Bus Error Address Register, IBEAR
macro KA0905_CPU$Q_IBEAR = 480,0,0,1 %;
literal KA0905_CPU$S_IBEAR = 8;
macro KA0905_CPU$L_IBEAR_L = 480,0,32,0 %;
macro KA0905_CPU$V_IBEAR_CBCAC_0 = 480,0,32,0 %;
literal KA0905_CPU$S_IBEAR_CBCAC_0 = 32; !  C-bus2 CA cycle 0
macro KA0905_CPU$L_IBEAR_H = 484,0,32,0 %;
macro KA0905_CPU$V_IBEAR_CBCAC_1 = 484,0,32,0 %;
literal KA0905_CPU$S_IBEAR_CBCAC_1 = 32; !  C-bus2 CA cycle 1
!  Arbitrarion Control Register, ACR
macro KA0905_CPU$Q_ACR = 512,0,0,1 %;
literal KA0905_CPU$S_ACR = 8;
macro KA0905_CPU$L_ACR_L = 512,0,32,0 %;
macro KA0905_CPU$V_ACR_CBE_0 = 512,0,1,0 %; !  CBUS2 Equalizer 0
macro KA0905_CPU$V_ACR_FILL_01 = 512,1,3,0 %;
literal KA0905_CPU$S_ACR_FILL_01 = 3;
macro KA0905_CPU$V_ACR_BME_0 = 512,4,1,0 %; !  Bad Mode Enable 0
macro KA0905_CPU$V_ACR_DME_0 = 512,5,1,0 %; !  Donate Mode Enable 0
macro KA0905_CPU$V_ACR_FILL_02 = 512,6,2,0 %;
literal KA0905_CPU$S_ACR_FILL_02 = 2;
macro KA0905_CPU$V_ACR_PME_0 = 512,8,1,0 %; !  Pawn Mode Enable 0
macro KA0905_CPU$V_ACR_BCRE_0 = 512,9,1,0 %; !  BCREQ Enable 0
macro KA0905_CPU$V_ACR_FILL_03 = 512,10,2,0 %;
literal KA0905_CPU$S_ACR_FILL_03 = 2;
macro KA0905_CPU$V_ACR_DCBR_0 = 512,12,1,0 %; !  Disable CBUS2 Request 0
macro KA0905_CPU$V_ACR_FILL_04 = 512,13,19,0 %;
literal KA0905_CPU$S_ACR_FILL_04 = 19;
macro KA0905_CPU$L_ACR_H = 516,0,32,0 %;
macro KA0905_CPU$V_ACR_CBE_1 = 516,0,1,0 %; !  CBUS2 Equalizer 1
macro KA0905_CPU$V_ACR_FILL_05 = 516,1,3,0 %;
literal KA0905_CPU$S_ACR_FILL_05 = 3;
macro KA0905_CPU$V_ACR_BME_1 = 516,4,1,0 %; !  Bad Mode Enable 1
macro KA0905_CPU$V_ACR_DME_1 = 516,5,1,0 %; !  Donate Mode Enable 1
macro KA0905_CPU$V_ACR_FILL_06 = 516,6,2,0 %;
literal KA0905_CPU$S_ACR_FILL_06 = 2;
macro KA0905_CPU$V_ACR_PME_1 = 516,8,1,0 %; !  Pawn Mode Enable 1
macro KA0905_CPU$V_ACR_BCRE_1 = 516,9,1,0 %; !  BCREQ Enable 1
macro KA0905_CPU$V_ACR_FILL_07 = 516,10,2,0 %;
literal KA0905_CPU$S_ACR_FILL_07 = 2;
macro KA0905_CPU$V_ACR_DCBR_1 = 516,12,1,0 %; !  Disable CBUS2 Request 1
macro KA0905_CPU$V_ACR_FILL_08 = 516,13,19,0 %;
literal KA0905_CPU$S_ACR_FILL_08 = 19;
!  Cobra-bus2 Control Register, CBCR
macro KA0905_CPU$Q_CBCR = 544,0,0,1 %;
literal KA0905_CPU$S_CBCR = 8;
macro KA0905_CPU$L_CBCR_L = 544,0,32,0 %;
macro KA0905_CPU$V_CBCR_EPC_0 = 544,0,1,0 %; !  Enable Parity Checking 0
macro KA0905_CPU$V_CBCR_DWP_0 = 544,1,1,0 %; !  Data Wrong Parity 0
macro KA0905_CPU$V_CBCR_CAWP_0 = 544,2,1,0 %; !  C/A Wrong Parity 0
macro KA0905_CPU$V_CBCR_FILL_01 = 544,3,1,0 %;
macro KA0905_CPU$V_CBCR_FS = 544,4,1,0 %; !  Force Shared
macro KA0905_CPU$V_CBCR_FILL_02 = 544,5,7,0 %;
literal KA0905_CPU$S_CBCR_FILL_02 = 7;
macro KA0905_CPU$V_CBCR_ECBEI_0 = 544,12,1,0 %; !  Enable CBUS Err Interrupt 0
macro KA0905_CPU$V_CBCR_FILL_03 = 544,13,3,0 %;
literal KA0905_CPU$S_CBCR_FILL_03 = 3;
macro KA0905_CPU$V_CBCR_DSRC = 544,16,1,0 %; !  Dis Shared Response checking
macro KA0905_CPU$V_CBCR_FILL_04 = 544,17,15,0 %;
literal KA0905_CPU$S_CBCR_FILL_04 = 15;
macro KA0905_CPU$L_CBCR_H = 548,0,32,0 %;
macro KA0905_CPU$V_CBCR_EPC_1 = 548,0,1,0 %; !  Enable Parity Checking 1
macro KA0905_CPU$V_CBCR_DWP_1 = 548,1,1,0 %; !  Date Wrong Parity 1
macro KA0905_CPU$V_CBCR_CAWP_1 = 548,2,1,0 %; !  C/A Wrong Parity 1
macro KA0905_CPU$V_CBCR_FILL_05 = 548,3,5,0 %;
literal KA0905_CPU$S_CBCR_FILL_05 = 5;
macro KA0905_CPU$V_CBCR_CID = 548,8,3,0 %;
literal KA0905_CPU$S_CBCR_CID = 3;      !  Commander ID
macro KA0905_CPU$V_CBCR_FILL_06 = 548,11,1,0 %;
macro KA0905_CPU$V_CBCR_ECBEI_1 = 548,12,1,0 %; !  Enable CBUS Err Interrupt 0
macro KA0905_CPU$V_CBCR_FILL_07 = 548,13,19,0 %;
literal KA0905_CPU$S_CBCR_FILL_07 = 19;
!  Cobra-bus2 Error Register, CBER
macro KA0905_CPU$Q_CBER = 576,0,0,1 %;
literal KA0905_CPU$S_CBER = 8;
macro KA0905_CPU$L_CBER_L = 576,0,32,0 %;
macro KA0905_CPU$V_CBER_URE_0 = 576,0,1,0 %; !  Uncorrectable Read Error 0
macro KA0905_CPU$V_CBER_FILL_01 = 576,1,3,0 %;
literal KA0905_CPU$S_CBER_FILL_01 = 3;
macro KA0905_CPU$V_CBER_CALLPE_0 = 576,4,1,0 %; !  C/A Low LW Parity Err 0
macro KA0905_CPU$V_CBER_CAHLPE_0 = 576,5,1,0 %; !  C/A Hign LW Parity Err 0
macro KA0905_CPU$V_CBER_FILL_02 = 576,6,2,0 %;
literal KA0905_CPU$S_CBER_FILL_02 = 2;
macro KA0905_CPU$V_CBER_PELW0WD = 576,8,1,0 %; !  Parity Err LW0 Write Data
macro KA0905_CPU$V_CBER_PELW1WD = 576,9,1,0 %; !  Parity Err LW1 Write Data
macro KA0905_CPU$V_CBER_PELW4WD = 576,10,1,0 %; !  Parity Err LW4 Write Data
macro KA0905_CPU$V_CBER_PELW5WD = 576,11,1,0 %; !  Parity Err LW5 Write Data
macro KA0905_CPU$V_CBER_FILL_03 = 576,12,4,0 %;
literal KA0905_CPU$S_CBER_FILL_03 = 4;
macro KA0905_CPU$V_CBER_PELW0RD = 576,16,1,0 %; !  Parity Err LW0 Read Data
macro KA0905_CPU$V_CBER_PELW1RD = 576,17,1,0 %; !  Parity Err LW1 Read Data
macro KA0905_CPU$V_CBER_PELW4RD = 576,18,1,0 %; !  Parity Err LW4 Read Data
macro KA0905_CPU$V_CBER_PELW5RD = 576,19,1,0 %; !  Parity Err LW5 Read Data
macro KA0905_CPU$V_CBER_USR = 576,20,1,0 %; !  Unexpected Shared Response
macro KA0905_CPU$V_CBER_FILL_04 = 576,21,3,0 %;
literal KA0905_CPU$S_CBER_FILL_04 = 3;
macro KA0905_CPU$V_CBER_CANA = 576,24,1,0 %; !  C/A Not Acked
macro KA0905_CPU$V_CBER_FILL_05 = 576,25,3,0 %;
literal KA0905_CPU$S_CBER_FILL_05 = 3;
macro KA0905_CPU$V_CBER_D0NA = 576,28,1,0 %; !  Data 0 Not Acked
macro KA0905_CPU$V_CBER_D1NA = 576,29,1,0 %; !  Data 1 Not Acked
macro KA0905_CPU$V_CBER_FILL_06 = 576,30,2,0 %;
literal KA0905_CPU$S_CBER_FILL_06 = 2;
macro KA0905_CPU$L_CBER_H = 580,0,32,0 %;
macro KA0905_CPU$V_CBER_UCR_1 = 580,0,1,0 %; !  Uncorrectable Read Error 1
macro KA0905_CPU$V_CBER_FILL_07 = 580,1,3,0 %;
literal KA0905_CPU$S_CBER_FILL_07 = 3;
macro KA0905_CPU$V_CBER_CALLPE_1 = 580,4,1,0 %; !  C/A Low LW Parity Err 1
macro KA0905_CPU$V_CBER_CAHLPE_1 = 580,5,1,0 %; !  C/A High LW Parity Err 1
macro KA0905_CPU$V_CBER_FILL_08 = 580,6,2,0 %;
literal KA0905_CPU$S_CBER_FILL_08 = 2;
macro KA0905_CPU$V_CBER_PELW2WD = 580,8,1,0 %; !  Parity Err LW2 Write Data
macro KA0905_CPU$V_CBER_PELW3WD = 580,9,1,0 %; !  Parity Err LW3 Write Data
macro KA0905_CPU$V_CBER_PELW6WD = 580,10,1,0 %; !  Parity Err LW6 Write Data
macro KA0905_CPU$V_CBER_PELW7WD = 580,11,1,0 %; !  Parity Err LW7 Write Data
macro KA0905_CPU$V_CBER_FILL_09 = 580,12,4,0 %;
literal KA0905_CPU$S_CBER_FILL_09 = 4;
macro KA0905_CPU$V_CBER_PELW2RD = 580,16,1,0 %; !  Parity Err LW2 Read Data
macro KA0905_CPU$V_CBER_PELW3RD = 580,17,1,0 %; !  Parity Err LW3 Read Data
macro KA0905_CPU$V_CBER_PELW6RD = 580,18,1,0 %; !  Parity Err LW6 Read Data
macro KA0905_CPU$V_CBER_PELW7RD = 580,19,1,0 %; !  Parity Err LW7 Read Data
macro KA0905_CPU$V_CBER_FILL_10 = 580,20,12,0 %;
literal KA0905_CPU$S_CBER_FILL_10 = 12;
!  Cobra-bus2 Error Address Low Register, CBEALR
macro KA0905_CPU$Q_CBEALR = 608,0,0,1 %;
literal KA0905_CPU$S_CBEALR = 8;
macro KA0905_CPU$L_CBEALR_L = 608,0,32,0 %;
macro KA0905_CPU$V_CBEALR_CBLA_0 = 608,0,32,0 %;
literal KA0905_CPU$S_CBEALR_CBLA_0 = 32; !  CBus 2 Low Address 0
macro KA0905_CPU$L_CBEALR_H = 612,0,32,0 %;
macro KA0905_CPU$V_CBEALR_CBLA_1 = 612,0,32,0 %;
literal KA0905_CPU$S_CBEALR_CBLA_1 = 32; !  CBus 2 Low Address 1
!  Cobra-bus2 Error Address High Register, CBEAHR
macro KA0905_CPU$Q_CBEAHR = 640,0,0,1 %;
literal KA0905_CPU$S_CBEAHR = 8;
macro KA0905_CPU$L_CBEAHR_L = 640,0,32,0 %;
macro KA0905_CPU$V_CBEAHR_CBHA_0 = 640,0,32,0 %;
literal KA0905_CPU$S_CBEAHR_CBHA_0 = 32; !  CBus 2 High Addr 0
macro KA0905_CPU$L_CBEAHR_H = 644,0,32,0 %;
macro KA0905_CPU$V_CBEAHR_CBHA_1 = 644,0,32,0 %;
literal KA0905_CPU$S_CBEAHR_CBHA_1 = 32; !  CBus 2 High Addr 1
!  Cobra-bus2 Reserve Register, CBRESV
macro KA0905_CPU$Q_CBRESV = 672,0,0,1 %;
literal KA0905_CPU$S_CBRESV = 8;
macro KA0905_CPU$L_CBRESV_L = 672,0,32,0 %;
macro KA0905_CPU$V_CBRESV_FILL_01 = 672,0,32,0 %;
literal KA0905_CPU$S_CBRESV_FILL_01 = 32;
macro KA0905_CPU$L_CBRESV_H = 676,0,32,0 %;
macro KA0905_CPU$V_CBRESV_FILL_02 = 676,0,32,0 %;
literal KA0905_CPU$S_CBRESV_FILL_02 = 32;
!  Address Lock Register, ALR
macro KA0905_CPU$Q_ALR = 704,0,0,1 %;
literal KA0905_CPU$S_ALR = 8;
macro KA0905_CPU$L_ALR_L = 704,0,32,0 %;
macro KA0905_CPU$V_ALR_LAV_0 = 704,0,1,0 %; !  Lock Address Valid 0
macro KA0905_CPU$V_ALR_FILL_01 = 704,1,4,0 %;
literal KA0905_CPU$S_ALR_FILL_01 = 4;
macro KA0905_CPU$V_ALR_LA_0 = 704,5,27,0 %;
literal KA0905_CPU$S_ALR_LA_0 = 27;     !  Lock Address 0
macro KA0905_CPU$L_ALR_H = 708,0,32,0 %;
macro KA0905_CPU$V_ALR_LAV_1 = 708,0,1,0 %; !  Lock Address Valid 1
macro KA0905_CPU$V_ALR_FILL_02 = 708,1,4,0 %;
literal KA0905_CPU$S_ALR_FILL_02 = 4;
macro KA0905_CPU$V_ALR_LA_1 = 708,5,27,0 %;
literal KA0905_CPU$S_ALR_LA_1 = 27;     !  Lock Address 1
!  Processor Mailbox Register, PMBR
macro KA0905_CPU$Q_PMBR = 736,0,0,1 %;
literal KA0905_CPU$S_PMBR = 8;
macro KA0905_CPU$L_PMBR_L = 736,0,32,0 %;
macro KA0905_CPU$V_PMBR_DATA_0 = 736,0,32,0 %;
literal KA0905_CPU$S_PMBR_DATA_0 = 32;  !  Data 0
macro KA0905_CPU$L_PMBR_H = 740,0,32,0 %;
macro KA0905_CPU$V_PMBR_DATA_1 = 740,0,32,0 %;
literal KA0905_CPU$S_PMBR_DATA_1 = 32;  !  Data 1
!  Inter-processor Interrupt Request Register, IIRR
macro KA0905_CPU$Q_IIRR = 768,0,0,1 %;
literal KA0905_CPU$S_IIRR = 8;
macro KA0905_CPU$L_IIRR_L = 768,0,32,0 %;
macro KA0905_CPU$V_IIRR_FILL_0 = 768,0,32,0 %;
literal KA0905_CPU$S_IIRR_FILL_0 = 32;
macro KA0905_CPU$L_IIRR_H = 772,0,32,0 %;
macro KA0905_CPU$V_IIRR_FILL_02 = 772,0,12,0 %;
literal KA0905_CPU$S_IIRR_FILL_02 = 12;
macro KA0905_CPU$V_IIRR_RHI = 772,12,1,0 %; !  Requiest Halt Interrupt
macro KA0905_CPU$V_IIRR_FILL_03 = 772,13,3,0 %;
literal KA0905_CPU$S_IIRR_FILL_03 = 3;
macro KA0905_CPU$V_IIRR_II = 772,16,1,0 %; !  Interprocessor Interrupt
macro KA0905_CPU$V_IIRR_FILL_04 = 772,17,15,0 %;
literal KA0905_CPU$S_IIRR_FILL_04 = 15;
!  System Interrupt Clear Register, SICR
macro KA0905_CPU$Q_SICR = 800,0,0,1 %;
literal KA0905_CPU$S_SICR = 8;
macro KA0905_CPU$L_SICR_L = 800,0,32,0 %;
macro KA0905_CPU$V_SICR_CBEIC_0 = 800,0,1,0 %; !  CBus2 Err Interrupt Clear 0
macro KA0905_CPU$V_SICR_FILL_01 = 800,1,31,0 %;
literal KA0905_CPU$S_SICR_FILL_01 = 31;
macro KA0905_CPU$L_SICR_H = 804,0,32,0 %;
macro KA0905_CPU$V_SICR_CBEIC_1 = 804,0,1,0 %; !  CBus2 Err Interrupt Clear 1
macro KA0905_CPU$V_SICR_FILL_02 = 804,1,3,0 %;
literal KA0905_CPU$S_SICR_FILL_02 = 3;
macro KA0905_CPU$V_SICR_ITI = 804,4,1,0 %; !  Interval Timer Interrupt
macro KA0905_CPU$V_SICR_FILL_03 = 804,5,3,0 %;
literal KA0905_CPU$S_SICR_FILL_03 = 3;
macro KA0905_CPU$V_SICR_SEC = 804,8,1,0 %; !  System Event Clear
macro KA0905_CPU$V_SICR_FILL_04 = 804,9,3,0 %;
literal KA0905_CPU$S_SICR_FILL_04 = 3;
macro KA0905_CPU$V_SICR_NHIC = 804,12,1,0 %; !  Node Halt-Interrupt Clear
macro KA0905_CPU$V_SICR_FILL_05 = 804,13,3,0 %;
literal KA0905_CPU$S_SICR_FILL_05 = 3;
macro KA0905_CPU$V_SICR_IIC = 804,16,1,0 %; !  Interprocessor Int Clear
macro KA0905_CPU$V_SICR_FILL_06 = 804,17,3,0 %;
literal KA0905_CPU$S_SICR_FILL_06 = 3;
macro KA0905_CPU$V_SICR_IOII = 804,20,2,0 %;
literal KA0905_CPU$S_SICR_IOII = 2;     !  I/O Interrupt IRQ
macro KA0905_CPU$V_SICR_FILL_07 = 804,22,10,0 %;
literal KA0905_CPU$S_SICR_FILL_07 = 10;
!  Performance Monitor Control Register, PMCR
macro KA0905_CPU$Q_PMCR = 832,0,0,1 %;
literal KA0905_CPU$S_PMCR = 8;
macro KA0905_CPU$L_PMCR_L = 832,0,32,0 %;
macro KA0905_CPU$V_PMCR_SS_0 = 832,0,1,0 %; !  Start Stop 0
macro KA0905_CPU$V_PMCR_FILL_01 = 832,1,3,0 %;
literal KA0905_CPU$S_PMCR_FILL_01 = 3;
macro KA0905_CPU$V_PMCR_AM_0 = 832,4,2,0 %;
literal KA0905_CPU$S_PMCR_AM_0 = 2;     !  Address Match 0
macro KA0905_CPU$V_PMCR_FILL_02 = 832,6,6,0 %;
literal KA0905_CPU$S_PMCR_FILL_02 = 6;
macro KA0905_CPU$V_PMCR_SPMR10 = 832,12,4,0 %;
literal KA0905_CPU$S_PMCR_SPMR10 = 4;   !  Select PMR10
macro KA0905_CPU$V_PMCR_SPMR9 = 832,16,4,0 %;
literal KA0905_CPU$S_PMCR_SPMR9 = 4;    !  Select PMR9
macro KA0905_CPU$V_PMCR_SPMR8 = 832,20,4,0 %;
literal KA0905_CPU$S_PMCR_SPMR8 = 4;    !  Select PMR8
macro KA0905_CPU$V_PMCR_SPMR7 = 832,24,4,0 %;
literal KA0905_CPU$S_PMCR_SPMR7 = 4;    !  Select PMR7
macro KA0905_CPU$V_PMCR_SPMR6 = 832,28,4,0 %;
literal KA0905_CPU$S_PMCR_SPMR6 = 4;    !  Select PMR6
macro KA0905_CPU$L_PMCR_H = 836,0,32,0 %;
macro KA0905_CPU$V_PMCR_SS_1 = 836,0,1,0 %; !  Start Stop 1
macro KA0905_CPU$V_PMCR_EPMO = 836,1,2,0 %;
literal KA0905_CPU$S_PMCR_EPMO = 2;     !  Enable Perf Mon Output
macro KA0905_CPU$V_PMCR_FILL_03 = 836,3,1,0 %;
macro KA0905_CPU$V_PMCR_AM_1 = 836,4,2,0 %;
literal KA0905_CPU$S_PMCR_AM_1 = 2;     !  Address Match 1
macro KA0905_CPU$V_PMCR_CIDMASK = 836,6,3,0 %;
literal KA0905_CPU$S_PMCR_CIDMASK = 3;  !  CID Mask
macro KA0905_CPU$V_PMCR_CIDMATCH = 836,9,3,0 %;
literal KA0905_CPU$S_PMCR_CIDMATCH = 3; !  CIT Match
macro KA0905_CPU$V_PMCR_SPMR5 = 836,12,4,0 %;
literal KA0905_CPU$S_PMCR_SPMR5 = 4;    !  Select PMR5
macro KA0905_CPU$V_PMCR_SPMR4 = 836,16,4,0 %;
literal KA0905_CPU$S_PMCR_SPMR4 = 4;    !  Select PMR4
macro KA0905_CPU$V_PMCR_SPMR3 = 836,20,4,0 %;
literal KA0905_CPU$S_PMCR_SPMR3 = 4;    !  Select PMR3
macro KA0905_CPU$V_PMCR_SPMR2 = 836,24,4,0 %;
literal KA0905_CPU$S_PMCR_SPMR2 = 4;    !  Select PMR2
macro KA0905_CPU$V_PMCR_SPMR1 = 836,28,4,0 %;
literal KA0905_CPU$S_PMCR_SPMR1 = 4;    !  Select PMR1
!  Performance Monitor Register 1, PMR1
macro KA0905_CPU$Q_PMR1 = 864,0,0,1 %;
literal KA0905_CPU$S_PMR1 = 8;
macro KA0905_CPU$L_PMR1_L = 864,0,32,0 %;
macro KA0905_CPU$V_PMR1_C6 = 864,0,31,0 %;
literal KA0905_CPU$S_PMR1_C6 = 31;      !  Counter 6
macro KA0905_CPU$V_PMR1_OF6 = 864,31,1,0 %; !  Overflow 6
macro KA0905_CPU$L_PMR1_H = 868,0,32,0 %;
macro KA0905_CPU$V_PMR1_C1 = 868,0,31,0 %;
literal KA0905_CPU$S_PMR1_C1 = 31;      !  Counter 1
macro KA0905_CPU$V_PMR1_OF1 = 868,31,1,0 %; !  Overflow 1
!  Performance Monitor Register 2, PMR2
macro KA0905_CPU$Q_PMR2 = 896,0,0,1 %;
literal KA0905_CPU$S_PMR2 = 8;
macro KA0905_CPU$L_PMR2_L = 896,0,32,0 %;
macro KA0905_CPU$V_PMR2_C7 = 896,0,31,0 %;
literal KA0905_CPU$S_PMR2_C7 = 31;      !  Counter 7
macro KA0905_CPU$V_PMR2_OF7 = 896,31,1,0 %; !  Overflow 7
macro KA0905_CPU$L_PMR2_H = 900,0,32,0 %;
macro KA0905_CPU$V_PMR2_C2 = 900,0,31,0 %;
literal KA0905_CPU$S_PMR2_C2 = 31;      !  Counter 2
macro KA0905_CPU$V_PMR2_OF2 = 900,31,1,0 %; !  Overflow 2
!  Performance Monitor Register 3, PMR3
macro KA0905_CPU$Q_PMR3 = 928,0,0,1 %;
literal KA0905_CPU$S_PMR3 = 8;
macro KA0905_CPU$L_PMR3_L = 928,0,32,0 %;
macro KA0905_CPU$V_PMR3_C8 = 928,0,31,0 %;
literal KA0905_CPU$S_PMR3_C8 = 31;      !  Counter 8
macro KA0905_CPU$V_PMR3_OF8 = 928,31,1,0 %; !  Overflow 8
macro KA0905_CPU$L_PMR3_H = 932,0,32,0 %;
macro KA0905_CPU$V_PMR3_C3 = 932,0,31,0 %;
literal KA0905_CPU$S_PMR3_C3 = 31;      !  Counter 3
macro KA0905_CPU$V_PMR3_OF3 = 932,31,1,0 %; !  Overflow 3
!  Performance Monitor Register 4, PMR4
macro KA0905_CPU$Q_PMR4 = 960,0,0,1 %;
literal KA0905_CPU$S_PMR4 = 8;
macro KA0905_CPU$L_PMR4_L = 960,0,32,0 %;
macro KA0905_CPU$V_PMR4_C9 = 960,0,31,0 %;
literal KA0905_CPU$S_PMR4_C9 = 31;      !  Counter 9
macro KA0905_CPU$V_PMR4_OF9 = 960,31,1,0 %; !  Overflow 9
macro KA0905_CPU$L_PMR4_H = 964,0,32,0 %;
macro KA0905_CPU$V_PMR4_C4 = 964,0,31,0 %;
literal KA0905_CPU$S_PMR4_C4 = 31;      !  Counter 4
macro KA0905_CPU$V_PMR4_OF4 = 964,31,1,0 %; !  Overflow 4
!  Performance Monitor Register 5, PMR5
macro KA0905_CPU$Q_PMR5 = 992,0,0,1 %;
literal KA0905_CPU$S_PMR5 = 8;
macro KA0905_CPU$L_PMR5_L = 992,0,32,0 %;
macro KA0905_CPU$V_PMR5_C10 = 992,0,31,0 %;
literal KA0905_CPU$S_PMR5_C10 = 31;     !  Counter 10
macro KA0905_CPU$V_PMR5_OF10 = 992,31,1,0 %; !  Overflow 10
macro KA0905_CPU$L_PMR5_H = 996,0,32,0 %;
macro KA0905_CPU$V_PMR5_C5 = 996,0,31,0 %;
literal KA0905_CPU$S_PMR5_C5 = 31;      !  Counter 5
macro KA0905_CPU$V_PMR5_OF5 = 996,31,1,0 %; !  Overflow 5
literal KA0905_CPU$K_LENGTH = 1000;
 
!*** MODULE $KA0C05DEF ***
literal KA0C05_BSB$M_TLIPINT_MASK = %X'FFFF';
literal KA0C05_BSB$M_TLIOINT4_MASK = %X'FFFF';
literal KA0C05_BSB$M_TLIOINT4_IPL14 = %X'10000';
literal KA0C05_BSB$M_TLIOINT4_IPL15 = %X'20000';
literal KA0C05_BSB$M_TLIOINT4_IPL16 = %X'40000';
literal KA0C05_BSB$M_TLIOINT4_IPL17 = %X'80000';
literal KA0C05_BSB$M_TLIOINT5_MASK = %X'FFFF';
literal KA0C05_BSB$M_TLIOINT5_IPL14 = %X'10000';
literal KA0C05_BSB$M_TLIOINT5_IPL15 = %X'20000';
literal KA0C05_BSB$M_TLIOINT5_IPL16 = %X'40000';
literal KA0C05_BSB$M_TLIOINT5_IPL17 = %X'80000';
literal KA0C05_BSB$M_TLIOINT6_MASK = %X'FFFF';
literal KA0C05_BSB$M_TLIOINT6_IPL14 = %X'10000';
literal KA0C05_BSB$M_TLIOINT6_IPL15 = %X'20000';
literal KA0C05_BSB$M_TLIOINT6_IPL16 = %X'40000';
literal KA0C05_BSB$M_TLIOINT6_IPL17 = %X'80000';
literal KA0C05_BSB$M_TLIOINT7_MASK = %X'FFFF';
literal KA0C05_BSB$M_TLIOINT7_IPL14 = %X'10000';
literal KA0C05_BSB$M_TLIOINT7_IPL15 = %X'20000';
literal KA0C05_BSB$M_TLIOINT7_IPL16 = %X'40000';
literal KA0C05_BSB$M_TLIOINT7_IPL17 = %X'80000';
literal KA0C05_BSB$M_TLIOINT8_MASK = %X'FFFF';
literal KA0C05_BSB$M_TLIOINT8_IPL14 = %X'10000';
literal KA0C05_BSB$M_TLIOINT8_IPL15 = %X'20000';
literal KA0C05_BSB$M_TLIOINT8_IPL16 = %X'40000';
literal KA0C05_BSB$M_TLIOINT8_IPL17 = %X'80000';
literal KA0C05_BSB$S_KA0C05_BSB = 8200;
macro KA0C05_BSB$L_TLPRIVATE = 0,0,32,0 %;
macro KA0C05_BSB$b_f10 = 4,0,0,0 %;
literal KA0C05_BSB$s_f10 = 60;
macro KA0C05_BSB$L_TLIPINT = 64,0,32,0 %;
macro KA0C05_BSB$V_TLIPINT_MASK = 64,0,16,0 %;
literal KA0C05_BSB$S_TLIPINT_MASK = 16;
macro KA0C05_BSB$b_f20 = 68,0,0,0 %;
literal KA0C05_BSB$s_f20 = 188;
macro KA0C05_BSB$L_TLIOINT4 = 256,0,32,0 %;
macro KA0C05_BSB$V_TLIOINT4_MASK = 256,0,16,0 %;
literal KA0C05_BSB$S_TLIOINT4_MASK = 16;
macro KA0C05_BSB$V_TLIOINT4_IPL14 = 256,16,1,0 %;
macro KA0C05_BSB$V_TLIOINT4_IPL15 = 256,17,1,0 %;
macro KA0C05_BSB$V_TLIOINT4_IPL16 = 256,18,1,0 %;
macro KA0C05_BSB$V_TLIOINT4_IPL17 = 256,19,1,0 %;
macro KA0C05_BSB$b_fill30 = 260,0,0,0 %;
literal KA0C05_BSB$s_fill30 = 60;
macro KA0C05_BSB$L_TLIOINT5 = 320,0,32,0 %;
macro KA0C05_BSB$V_TLIOINT5_MASK = 320,0,16,0 %;
literal KA0C05_BSB$S_TLIOINT5_MASK = 16;
macro KA0C05_BSB$V_TLIOINT5_IPL14 = 320,16,1,0 %;
macro KA0C05_BSB$V_TLIOINT5_IPL15 = 320,17,1,0 %;
macro KA0C05_BSB$V_TLIOINT5_IPL16 = 320,18,1,0 %;
macro KA0C05_BSB$V_TLIOINT5_IPL17 = 320,19,1,0 %;
macro KA0C05_BSB$b_fill40 = 324,0,0,0 %;
literal KA0C05_BSB$s_fill40 = 60;
macro KA0C05_BSB$L_TLIOINT6 = 384,0,32,0 %;
macro KA0C05_BSB$V_TLIOINT6_MASK = 384,0,16,0 %;
literal KA0C05_BSB$S_TLIOINT6_MASK = 16;
macro KA0C05_BSB$V_TLIOINT6_IPL14 = 384,16,1,0 %;
macro KA0C05_BSB$V_TLIOINT6_IPL15 = 384,17,1,0 %;
macro KA0C05_BSB$V_TLIOINT6_IPL16 = 384,18,1,0 %;
macro KA0C05_BSB$V_TLIOINT6_IPL17 = 384,19,1,0 %;
macro KA0C05_BSB$b_fill50 = 388,0,0,0 %;
literal KA0C05_BSB$s_fill50 = 60;
macro KA0C05_BSB$L_TLIOINT7 = 448,0,32,0 %;
macro KA0C05_BSB$V_TLIOINT7_MASK = 448,0,16,0 %;
literal KA0C05_BSB$S_TLIOINT7_MASK = 16;
macro KA0C05_BSB$V_TLIOINT7_IPL14 = 448,16,1,0 %;
macro KA0C05_BSB$V_TLIOINT7_IPL15 = 448,17,1,0 %;
macro KA0C05_BSB$V_TLIOINT7_IPL16 = 448,18,1,0 %;
macro KA0C05_BSB$V_TLIOINT7_IPL17 = 448,19,1,0 %;
macro KA0C05_BSB$b_fill60 = 452,0,0,0 %;
literal KA0C05_BSB$s_fill60 = 60;
macro KA0C05_BSB$L_TLIOINT8 = 512,0,32,0 %;
macro KA0C05_BSB$V_TLIOINT8_MASK = 512,0,16,0 %;
literal KA0C05_BSB$S_TLIOINT8_MASK = 16;
macro KA0C05_BSB$V_TLIOINT8_IPL14 = 512,16,1,0 %;
macro KA0C05_BSB$V_TLIOINT8_IPL15 = 512,17,1,0 %;
macro KA0C05_BSB$V_TLIOINT8_IPL16 = 512,18,1,0 %;
macro KA0C05_BSB$V_TLIOINT8_IPL17 = 512,19,1,0 %;
macro KA0C05_BSB$b_fill70 = 516,0,0,0 %;
literal KA0C05_BSB$s_fill70 = 508;
macro KA0C05_BSB$L_TLWSDQR4 = 1024,0,32,0 %;
macro KA0C05_BSB$b_fill80 = 1028,0,0,0 %;
literal KA0C05_BSB$s_fill80 = 60;
macro KA0C05_BSB$L_TLWSDQR5 = 1088,0,32,0 %;
macro KA0C05_BSB$b_fill90 = 1092,0,0,0 %;
literal KA0C05_BSB$s_fill90 = 60;
macro KA0C05_BSB$L_TLWSDQR6 = 1152,0,32,0 %;
macro KA0C05_BSB$b_f100 = 1156,0,0,0 %;
literal KA0C05_BSB$s_f100 = 60;
macro KA0C05_BSB$L_TLWSDQR7 = 1216,0,32,0 %;
macro KA0C05_BSB$b_f110 = 1220,0,0,0 %;
literal KA0C05_BSB$s_f110 = 60;
macro KA0C05_BSB$L_TLWSDQR8 = 1280,0,32,0 %;
macro KA0C05_BSB$b_f120 = 1284,0,0,0 %;
literal KA0C05_BSB$s_f120 = 252;
macro KA0C05_BSB$L_TLRMDQRX = 1536,0,32,0 %;
macro KA0C05_BSB$b_f130 = 1540,0,0,0 %;
literal KA0C05_BSB$s_f130 = 60;
macro KA0C05_BSB$L_TLRMDQR8 = 1600,0,32,0 %;
macro KA0C05_BSB$b_f140 = 1604,0,0,0 %;
literal KA0C05_BSB$s_f140 = 444;
macro KA0C05_BSB$Q_TLRDRD = 2048,0,0,1 %;
literal KA0C05_BSB$S_TLRDRD = 8;
macro KA0C05_BSB$b_f150 = 2056,0,0,0 %;
literal KA0C05_BSB$s_f150 = 60;
macro KA0C05_BSB$L_TLRDRE = 2116,0,32,0 %;
macro KA0C05_BSB$b_f160 = 2120,0,0,0 %;
literal KA0C05_BSB$s_f160 = 4156;
macro KA0C05_BSB$L_TLMCR = 6276,0,32,0 %;
macro KA0C05_BSB$b_f170 = 6280,0,0,0 %;
literal KA0C05_BSB$s_f170 = 1916;
literal KA0C05_TLEP$M_TLDEV_DTYPE = %X'FFFF';
literal KA0C05_TLEP$M_TLDEV_SWREV = %X'FF0000';
literal KA0C05_TLEP$M_TLDEV_HWREV = %X'FF000000';
literal KA0C05_TLEP$M_TLBER_ATCE = %X'1';
literal KA0C05_TLEP$M_TLBER_APE = %X'2';
literal KA0C05_TLEP$M_TLBER_BBE = %X'4';
literal KA0C05_TLEP$M_TLBER_LKTO = %X'8';
literal KA0C05_TLEP$M_TLBER_NAE = %X'10';
literal KA0C05_TLEP$M_TLBER_RTCE = %X'20';
literal KA0C05_TLEP$M_TLBER_ACKTCE = %X'40';
literal KA0C05_TLEP$M_TLBER_MMRE = %X'80';
literal KA0C05_TLEP$M_TLBER_FNAE = %X'100';
literal KA0C05_TLEP$M_TLBER_REQDE = %X'200';
literal KA0C05_TLEP$M_TLBER_ATDE = %X'400';
literal KA0C05_TLEP$M_TLBER_UDE = %X'10000';
literal KA0C05_TLEP$M_TLBER_CWDE = %X'20000';
literal KA0C05_TLEP$M_TLBER_CRDE = %X'40000';
literal KA0C05_TLEP$M_TLBER_DS0 = %X'100000';
literal KA0C05_TLEP$M_TLBER_DS1 = %X'200000';
literal KA0C05_TLEP$M_TLBER_DS2 = %X'400000';
literal KA0C05_TLEP$M_TLBER_DS3 = %X'800000';
literal KA0C05_TLEP$M_TLBER_DTDE = %X'1000000';
literal KA0C05_TLEP$M_TLBER_FDTCE = %X'2000000';
literal KA0C05_TLEP$M_TLBER_UACKE = %X'4000000';
literal KA0C05_TLEP$M_TLBER_ABTCE = %X'8000000';
literal KA0C05_TLEP$M_TLBER_DCTCE = %X'10000000';
literal KA0C05_TLEP$M_TLBER_SEQE = %X'20000000';
literal KA0C05_TLEP$M_TLBER_DSE = %X'40000000';
literal KA0C05_TLEP$M_TLBER_DTO = %X'80000000';
literal KA0C05_TLEP$M_TLCNR_CWDD = %X'1';
literal KA0C05_TLEP$M_TLCNR_CRDD = %X'2';
literal KA0C05_TLEP$M_TLCNR_DTOD = %X'8';
literal KA0C05_TLEP$M_TLCNR_NODE_ID = %X'F0';
literal KA0C05_TLEP$M_TLCNR_VCNT = %X'F00';
literal KA0C05_TLEP$M_TLCNR_STF_A = %X'1000';
literal KA0C05_TLEP$M_TLCNR_STF_B = %X'2000';
literal KA0C05_TLEP$M_TLCNR_HALT_A = %X'100000';
literal KA0C05_TLEP$M_TLCNR_HALT_B = %X'200000';
literal KA0C05_TLEP$M_TLCNR_NRST = %X'40000000';
literal KA0C05_TLEP$M_TLCNR_LOFE = %X'80000000';
literal KA0C05_TLEP$M_VID_A = %X'F';
literal KA0C05_TLEP$M_VID_B = %X'F0';
literal KA0C05_TLEP$M_TLMMR0_INTMASK = %X'3';
literal KA0C05_TLEP$M_TLMMR0_ADRMASK = %X'F0';
literal KA0C05_TLEP$M_TLMMR0_INTLV = %X'700';
literal KA0C05_TLEP$M_TLMMR0_SBANK = %X'800';
literal KA0C05_TLEP$M_TLMMR0_ADDRESS = %X'3FFF000';
literal KA0C05_TLEP$M_TLMMR0_VALID = %X'80000000';
literal KA0C05_TLEP$M_TLMMR1_INTMASK = %X'3';
literal KA0C05_TLEP$M_TLMMR1_ADRMASK = %X'F0';
literal KA0C05_TLEP$M_TLMMR1_INTLV = %X'700';
literal KA0C05_TLEP$M_TLMMR1_SBANK = %X'800';
literal KA0C05_TLEP$M_TLMMR1_ADDRESS = %X'3FFF000';
literal KA0C05_TLEP$M_TLMMR1_VALID = %X'80000000';
literal KA0C05_TLEP$M_TLMMR2_INTMASK = %X'3';
literal KA0C05_TLEP$M_TLMMR2_ADRMASK = %X'F0';
literal KA0C05_TLEP$M_TLMMR2_INTLV = %X'700';
literal KA0C05_TLEP$M_TLMMR2_SBANK = %X'800';
literal KA0C05_TLEP$M_TLMMR2_ADDRESS = %X'3FFF000';
literal KA0C05_TLEP$M_TLMMR2_VALID = %X'80000000';
literal KA0C05_TLEP$M_TLMMR3_INTMASK = %X'3';
literal KA0C05_TLEP$M_TLMMR3_ADRMASK = %X'F0';
literal KA0C05_TLEP$M_TLMMR3_INTLV = %X'700';
literal KA0C05_TLEP$M_TLMMR3_SBANK = %X'800';
literal KA0C05_TLEP$M_TLMMR3_ADDRESS = %X'3FFF000';
literal KA0C05_TLEP$M_TLMMR3_VALID = %X'80000000';
literal KA0C05_TLEP$M_TLMMR4_INTMASK = %X'3';
literal KA0C05_TLEP$M_TLMMR4_ADRMASK = %X'F0';
literal KA0C05_TLEP$M_TLMMR4_INTLV = %X'700';
literal KA0C05_TLEP$M_TLMMR4_SBANK = %X'800';
literal KA0C05_TLEP$M_TLMMR4_ADDRESS = %X'3FFF000';
literal KA0C05_TLEP$M_TLMMR4_VALID = %X'80000000';
literal KA0C05_TLEP$M_TLMMR5_INTMASK = %X'3';
literal KA0C05_TLEP$M_TLMMR5_ADRMASK = %X'F0';
literal KA0C05_TLEP$M_TLMMR5_INTLV = %X'700';
literal KA0C05_TLEP$M_TLMMR5_SBANK = %X'800';
literal KA0C05_TLEP$M_TLMMR5_ADDRESS = %X'3FFF000';
literal KA0C05_TLEP$M_TLMMR5_VALID = %X'80000000';
literal KA0C05_TLEP$M_TLMMR6_INTMASK = %X'3';
literal KA0C05_TLEP$M_TLMMR6_ADRMASK = %X'F0';
literal KA0C05_TLEP$M_TLMMR6_INTLV = %X'700';
literal KA0C05_TLEP$M_TLMMR6_SBANK = %X'800';
literal KA0C05_TLEP$M_TLMMR6_ADDRESS = %X'3FFF000';
literal KA0C05_TLEP$M_TLMMR6_VALID = %X'80000000';
literal KA0C05_TLEP$M_TLMMR7_INTMASK = %X'3';
literal KA0C05_TLEP$M_TLMMR7_ADRMASK = %X'F0';
literal KA0C05_TLEP$M_TLMMR7_INTLV = %X'700';
literal KA0C05_TLEP$M_TLMMR7_SBANK = %X'800';
literal KA0C05_TLEP$M_TLMMR7_ADDRESS = %X'3FFF000';
literal KA0C05_TLEP$M_TLMMR7_VALID = %X'80000000';
literal KA0C05_TLEP$M_TLESR0_SYND0 = %X'FF';
literal KA0C05_TLEP$M_TLESR0_SYND1 = %X'FF00';
literal KA0C05_TLEP$M_TLESR0_TDE = %X'10000';
literal KA0C05_TLEP$M_TLESR0_TCE = %X'20000';
literal KA0C05_TLEP$M_TLESR0_DVTCE = %X'40000';
literal KA0C05_TLEP$M_TLESR0_UECC = %X'80000';
literal KA0C05_TLEP$M_TLESR0_CWECC = %X'100000';
literal KA0C05_TLEP$M_TLESR0_CRECC = %X'200000';
literal KA0C05_TLEP$M_TLESR0_CPU0 = %X'400000';
literal KA0C05_TLEP$M_TLESR0_CPU1 = %X'800000';
literal KA0C05_TLEP$M_TLESR0_LOFSYN = %X'80000000';
literal KA0C05_TLEP$M_TLESR1_SYND0 = %X'FF';
literal KA0C05_TLEP$M_TLESR1_SYND1 = %X'FF00';
literal KA0C05_TLEP$M_TLESR1_TDE = %X'10000';
literal KA0C05_TLEP$M_TLESR1_TCE = %X'20000';
literal KA0C05_TLEP$M_TLESR1_DVTCE = %X'40000';
literal KA0C05_TLEP$M_TLESR1_UECC = %X'80000';
literal KA0C05_TLEP$M_TLESR1_CWECC = %X'100000';
literal KA0C05_TLEP$M_TLESR1_CRECC = %X'200000';
literal KA0C05_TLEP$M_TLESR1_CPU0 = %X'400000';
literal KA0C05_TLEP$M_TLESR1_CPU1 = %X'800000';
literal KA0C05_TLEP$M_TLESR1_LOFSYN = %X'80000000';
literal KA0C05_TLEP$M_TLESR2_SYND0 = %X'FF';
literal KA0C05_TLEP$M_TLESR2_SYND1 = %X'FF00';
literal KA0C05_TLEP$M_TLESR2_TDE = %X'10000';
literal KA0C05_TLEP$M_TLESR2_TCE = %X'20000';
literal KA0C05_TLEP$M_TLESR2_DVTCE = %X'40000';
literal KA0C05_TLEP$M_TLESR2_UECC = %X'80000';
literal KA0C05_TLEP$M_TLESR2_CWECC = %X'100000';
literal KA0C05_TLEP$M_TLESR2_CRECC = %X'200000';
literal KA0C05_TLEP$M_TLESR2_CPU0 = %X'400000';
literal KA0C05_TLEP$M_TLESR2_CPU1 = %X'800000';
literal KA0C05_TLEP$M_TLESR2_LOFSYN = %X'80000000';
literal KA0C05_TLEP$M_TLESR3_SYND0 = %X'FF';
literal KA0C05_TLEP$M_TLESR3_SYND1 = %X'FF00';
literal KA0C05_TLEP$M_TLESR3_TDE = %X'10000';
literal KA0C05_TLEP$M_TLESR3_TCE = %X'20000';
literal KA0C05_TLEP$M_TLESR3_DVTCE = %X'40000';
literal KA0C05_TLEP$M_TLESR3_UECC = %X'80000';
literal KA0C05_TLEP$M_TLESR3_CWECC = %X'100000';
literal KA0C05_TLEP$M_TLESR3_CRECC = %X'200000';
literal KA0C05_TLEP$M_TLESR3_CPU0 = %X'400000';
literal KA0C05_TLEP$M_TLESR3_CPU1 = %X'800000';
literal KA0C05_TLEP$M_TLESR3_LOFSYN = %X'80000000';
literal KA0C05_TLEP$M_TLDIAG_FRIGN = %X'1';
literal KA0C05_TLEP$M_TLDIAG_DTWR = %X'2';
literal KA0C05_TLEP$M_TLDIAG_DTRD = %X'4';
literal KA0C05_TLEP$M_TLDIAG_DTCP = %X'8';
literal KA0C05_TLEP$M_TLDIAG_FVW = %X'10';
literal KA0C05_TLEP$M_TLDIAG_FAE = %X'20';
literal KA0C05_TLEP$M_TLDIAG_FCBE = %X'40';
literal KA0C05_TLEP$M_TLDIAG_FDBE = %X'80';
literal KA0C05_TLEP$M_TLDIAG_FDE = %X'F00';
literal KA0C05_TLEP$M_TLDIAG_FTW = %X'1000';
literal KA0C05_TLEP$M_TLDIAG_ASRT_FLT = %X'2000';
literal KA0C05_TLEP$M_TLDIAG_QWVAL_EN = %X'4000';
literal KA0C05_TLEP$M_TLDIAG_GSLOW = %X'8000';
literal KA0C05_TLEP$M_TLDTAGD_DTAG_PAR = %X'1';
literal KA0C05_TLEP$M_TLDTAGD_DTAG_DATA = %X'FFFFE';
literal KA0C05_TLEP$M_TLDTAGS_STATPAR = %X'1';
literal KA0C05_TLEP$M_TLDTAGS_STATD = %X'2';
literal KA0C05_TLEP$M_TLDTAGS_STATS = %X'4';
literal KA0C05_TLEP$M_TLDTAGS_STATV = %X'8';
literal KA0C05_TLEP$M_TLMCFG_CPU0DSBL = %X'1';
literal KA0C05_TLEP$M_TLMCFG_CPU1DSBL = %X'2';
literal KA0C05_TLEP$M_TLMCFG_BC_SIZE = %X'C';
literal KA0C05_TLEP$M_TLMCFG_LO_EN = %X'10';
literal KA0C05_TLEP$M_TLMCFG_RM_SIZE = %X'20';
literal KA0C05_TLEP$M_TLMCFG_BCIDLE = %X'3C0';
literal KA0C05_TLEP$M_TLMCFG_CQ_ENTRY = %X'1C00';
literal KA0C05_TLEP$M_TLMCFG_BQ_ENTRY = %X'E000';
literal KA0C05_TLEP$M_TLMCFG_SYS_DSBL = %X'10000';
literal KA0C05_TLEP$M_TLMCFG_EV5_DSBL = %X'20000';
literal KA0C05_TLEP$M_TLMCFG_FLT_DSBL = %X'40000';
literal KA0C05_TLEP$M_TLIMASK0_DUART0EN = %X'1';
literal KA0C05_TLEP$M_TLIMASK0_IPL14_EN = %X'2';
literal KA0C05_TLEP$M_TLIMASK0_IPL15_EN = %X'4';
literal KA0C05_TLEP$M_TLIMASK0_IPL16_EN = %X'8';
literal KA0C05_TLEP$M_TLIMASK0_IPL17_EN = %X'10';
literal KA0C05_TLEP$M_TLIMASK0_IP_EN = %X'20';
literal KA0C05_TLEP$M_TLIMASK0_INTIM_EN = %X'40';
literal KA0C05_TLEP$M_TLIMASK0_HALT_EN = %X'80';
literal KA0C05_TLEP$M_TLIMASK0_CP_EN = %X'100';
literal KA0C05_TLEP$M_TLIMASK1_DUART0EN = %X'1';
literal KA0C05_TLEP$M_TLIMASK1_IPL14_EN = %X'2';
literal KA0C05_TLEP$M_TLIMASK1_IPL15_EN = %X'4';
literal KA0C05_TLEP$M_TLIMASK1_IPL16_EN = %X'8';
literal KA0C05_TLEP$M_TLIMASK1_IPL17_EN = %X'10';
literal KA0C05_TLEP$M_TLIMASK1_IP_EN = %X'20';
literal KA0C05_TLEP$M_TLIMASK1_INTIM_EN = %X'40';
literal KA0C05_TLEP$M_TLIMASK1_HALT_EN = %X'80';
literal KA0C05_TLEP$M_TLIMASK1_CP_EN = %X'100';
literal KA0C05_TLEP$M_TLISUM0_DUART0INT = %X'1';
literal KA0C05_TLEP$M_TLISUM0_IPL14_INT = %X'2';
literal KA0C05_TLEP$M_TLISUM0_IPL15_INT = %X'4';
literal KA0C05_TLEP$M_TLISUM0_IPL16_INT = %X'8';
literal KA0C05_TLEP$M_TLISUM0_IPL17_INT = %X'10';
literal KA0C05_TLEP$M_TLISUM0_IP_INT = %X'20';
literal KA0C05_TLEP$M_TLISUM0_INTIM_INT = %X'40';
literal KA0C05_TLEP$M_TLISUM0_IPL14 = %X'F80';
literal KA0C05_TLEP$M_TLISUM0_IPL15 = %X'1F000';
literal KA0C05_TLEP$M_TLISUM0_IPL16 = %X'3E0000';
literal KA0C05_TLEP$M_TLISUM0_IPL17 = %X'7C00000';
literal KA0C05_TLEP$M_TLISUM0_CP_HALT = %X'8000000';
literal KA0C05_TLEP$M_TLISUM0_HALT = %X'10000000';
literal KA0C05_TLEP$M_TLISUM1_DUART0INT = %X'1';
literal KA0C05_TLEP$M_TLISUM1_IPL14_INT = %X'2';
literal KA0C05_TLEP$M_TLISUM1_IPL15_INT = %X'4';
literal KA0C05_TLEP$M_TLISUM1_IPL16_INT = %X'8';
literal KA0C05_TLEP$M_TLISUM1_IPL17_INT = %X'10';
literal KA0C05_TLEP$M_TLISUM1_IP_INT = %X'20';
literal KA0C05_TLEP$M_TLISUM1_INTIM_INT = %X'40';
literal KA0C05_TLEP$M_TLISUM1_IPL14 = %X'F80';
literal KA0C05_TLEP$M_TLISUM1_IPL15 = %X'1F000';
literal KA0C05_TLEP$M_TLISUM1_IPL16 = %X'3E0000';
literal KA0C05_TLEP$M_TLISUM1_IPL17 = %X'7C00000';
literal KA0C05_TLEP$M_TLISUM1_CP_HALT = %X'8000000';
literal KA0C05_TLEP$M_TLISUM1_HALT = %X'10000000';
literal KA0C05_TLEP$M_TLEPAERR_E2MAPE0 = %X'1';
literal KA0C05_TLEP$M_TLEPAERR_E2MAPE1 = %X'2';
literal KA0C05_TLEP$M_TLEPAERR_M2AAPE0 = %X'4';
literal KA0C05_TLEP$M_TLEPAERR_M2AAPE1 = %X'8';
literal KA0C05_TLEP$M_TLEPAERR_DTDPE = %X'10';
literal KA0C05_TLEP$M_TLEPAERR_DTSPE = %X'20';
literal KA0C05_TLEP$M_TLEPAERR_D2ACPE = %X'40';
literal KA0C05_TLEP$M_TLEPAERR_SYSDERR = %X'80';
literal KA0C05_TLEP$M_TLEPAERR_SYSFLT = %X'100';
literal KA0C05_TLEP$M_TLEPAERR_RD_ERR = %X'600';
literal KA0C05_TLEP$M_TLEPAERR_IBOXTO = %X'1800';
literal KA0C05_TLEP$M_TLEPAERR_RD_PEND = %X'6000';
literal KA0C05_TLEP$M_TLEPAERR_NXM = %X'8000';
literal KA0C05_TLEP$M_TLEPAERR_NO_ACK = %X'30000';
literal KA0C05_TLEP$M_TLEPDERR_A2DCPE = %X'1';
literal KA0C05_TLEP$M_TLEPDERR_D2DCPE0 = %X'2';
literal KA0C05_TLEP$M_TLEPDERR_GBTO = %X'4';
literal KA0C05_TLEP$M_TLEPMERR_A2MAPE0 = %X'1';
literal KA0C05_TLEP$M_TLEPMERR_A2MAPE1 = %X'2';
literal KA0C05_TLEP$M_TLEPMERR_D2MCPE = %X'4';
literal KA0C05_TLEP$M_TLEPMERR_D2DCPE1 = %X'8';
literal KA0C05_TLEP$M_TLEPMERR_D2DCPE2 = %X'10';
literal KA0C05_TLEP$M_TLEPMERR_D2DCPE3 = %X'20';
literal KA0C05_TLEP$M_TLEPMERR_RSTSTAT = %X'40';
literal KA0C05_TLEP$M_TLEP_VMG_5P = %X'1';
literal KA0C05_TLEP$M_TLEP_VMG_5M = %X'2';
literal KA0C05_TLEP$M_TLEP_VMG_3P = %X'4';
literal KA0C05_TLEP$M_TLEP_VMG_3M = %X'8';
literal KA0C05_TLEP$M_TLDMCMD_SIZE_512 = %X'1';
literal KA0C05_TLEP$M_TLDMCMD_SIZE_1K = %X'2';
literal KA0C05_TLEP$M_TLDMCMD_SIZE_2K = %X'4';
literal KA0C05_TLEP$M_TLDMCMD_SIZE_4K = %X'8';
literal KA0C05_TLEP$M_TLDMCMD_SIZE_8K = %X'10';
literal KA0C05_TLEP$M_TLDMCMD_CMD = %X'300';
literal KA0C05_TLEP$M_TLDMCMD_VALID = %X'800';
literal KA0C05_TLEP$M_TLDMCMD_RM_3 = %X'1000';
literal KA0C05_TLEP$M_TLDMCMD_RM_4 = %X'2000';
literal KA0C05_TLEP$M_TLDMCMD_RM_INLV = %X'4000';
literal KA0C05_TLEP$M_TLDMCMD_CPU_ID = %X'10000';
literal KA0C05_TLEP$M_TLDMCMD_IN_PROG = %X'100000';
literal KA0C05_TLEP$M_TLDMCMD_DONE = %X'200000';
literal KA0C05_TLEP$M_TLDMADRA_ADDR = %X'3FFFFFFF';
literal KA0C05_TLEP$M_TLDMADRB_ADDR = %X'3FFFFFFF';
literal KA0C05_TLEP$M_TLPM_CMD_CPUNUM = %X'1';
literal KA0C05_TLEP$M_TLPM_CMD_SET_SEL = %X'6';
literal KA0C05_TLEP$M_TLPM_CMD_VALID = %X'8';
literal KA0C05_TLEP$M_TLPM_CMD_READ_SET = %X'10';
literal KA0C05_TLEP$M_TLPM_CMD_OVRF_EN = %X'800';
literal KA0C05_TLEP$M_TLPM_CMD_TOT_CYC = %X'1000';
literal KA0C05_TLEP$M_TLPM_CMD_EV5_LAT = %X'2000';
literal KA0C05_TLEP$M_TLPM_CMD_RD_LAT = %X'4000';
literal KA0C05_TLEP$M_TLPM_CMD_SYS_OWN = %X'8000';
literal KA0C05_TLEP$M_TLPM_CMD_f2 = %X'10000';
literal KA0C05_TLEP$M_TLPM_CMD_LOCK = %X'20000';
literal KA0C05_TLEP$M_TLPM_CMD_MB = %X'40000';
literal KA0C05_TLEP$M_TLPM_CMD_SD_TOT = %X'80000';
literal KA0C05_TLEP$M_TLPM_CMD_SD_ACK = %X'100000';
literal KA0C05_TLEP$M_TLPM_CMD_RD_CSR = %X'200000';
literal KA0C05_TLEP$M_TLPM_CMD_RD = %X'400000';
literal KA0C05_TLEP$M_TLPM_CMD_RD_MOD = %X'800000';
literal KA0C05_TLEP$M_TLPM_CMD_RD_STC = %X'1000000';
literal KA0C05_TLEP$M_TLPM_CMD_VIC = %X'2000000';
literal KA0C05_TLEP$M_TLPM_CMD_WR_CSR = %X'4000000';
literal KA0C05_TLEP$M_TLPM_CMD_WR = %X'8000000';
literal KA0C05_TLEP$M_TLPM_CMD_WR_LOCK = %X'10000000';
literal KA0C05_TLEP$M_TLPM_CMD_INVAL = %X'20000000';
literal KA0C05_TLEP$M_TLPM_CMD_SET_SHR = %X'40000000';
literal KA0C05_TLEP$M_TLPM_CMD_RD_DIRT = %X'80000000';
literal KA0C05_TLEP$M_RM_REG0A_AEXT = %X'F';
literal KA0C05_TLEP$M_RM_REG0A_BADDR = %X'FFFFF00';
literal KA0C05_TLEP$M_RM_REG0A_VALID = %X'80000000';
literal KA0C05_TLEP$M_RM_REG0B_AEXT = %X'F';
literal KA0C05_TLEP$M_RM_REG0B_BADDR = %X'FFFFF00';
literal KA0C05_TLEP$M_RM_REG0B_VALID = %X'80000000';
literal KA0C05_TLEP$M_RM_REG1A_AEXT = %X'F';
literal KA0C05_TLEP$M_RM_REG1A_BADDR = %X'FFFFF00';
literal KA0C05_TLEP$M_RM_REG1A_VALID = %X'80000000';
literal KA0C05_TLEP$M_RM_REG1B_AEXT = %X'F';
literal KA0C05_TLEP$M_RM_REG1B_BADDR = %X'FFFFF00';
literal KA0C05_TLEP$M_RM_REG1B_VALID = %X'80000000';
literal KA0C05_TLEP$S_KA0C05_TLEP = 8064;
macro KA0C05_TLEP$L_TLDEV = 0,0,32,0 %;
macro KA0C05_TLEP$V_TLDEV_DTYPE = 0,0,16,0 %;
literal KA0C05_TLEP$S_TLDEV_DTYPE = 16;
macro KA0C05_TLEP$V_TLDEV_SWREV = 0,16,8,0 %;
literal KA0C05_TLEP$S_TLDEV_SWREV = 8;
macro KA0C05_TLEP$V_TLDEV_HWREV = 0,24,8,0 %;
literal KA0C05_TLEP$S_TLDEV_HWREV = 8;
macro KA0C05_TLEP$b_f200 = 4,0,0,0 %;
literal KA0C05_TLEP$s_f200 = 60;
macro KA0C05_TLEP$L_TLBER = 64,0,32,0 %;
macro KA0C05_TLEP$V_TLBER_ATCE = 64,0,1,0 %;
macro KA0C05_TLEP$V_TLBER_APE = 64,1,1,0 %;
macro KA0C05_TLEP$V_TLBER_BBE = 64,2,1,0 %;
macro KA0C05_TLEP$V_TLBER_LKTO = 64,3,1,0 %;
macro KA0C05_TLEP$V_TLBER_NAE = 64,4,1,0 %;
macro KA0C05_TLEP$V_TLBER_RTCE = 64,5,1,0 %;
macro KA0C05_TLEP$V_TLBER_ACKTCE = 64,6,1,0 %;
macro KA0C05_TLEP$V_TLBER_MMRE = 64,7,1,0 %;
macro KA0C05_TLEP$V_TLBER_FNAE = 64,8,1,0 %;
macro KA0C05_TLEP$V_TLBER_REQDE = 64,9,1,0 %;
macro KA0C05_TLEP$V_TLBER_ATDE = 64,10,1,0 %;
macro KA0C05_TLEP$V_TLBER_UDE = 64,16,1,0 %;
macro KA0C05_TLEP$V_TLBER_CWDE = 64,17,1,0 %;
macro KA0C05_TLEP$V_TLBER_CRDE = 64,18,1,0 %;
macro KA0C05_TLEP$V_TLBER_DS0 = 64,20,1,0 %;
macro KA0C05_TLEP$V_TLBER_DS1 = 64,21,1,0 %;
macro KA0C05_TLEP$V_TLBER_DS2 = 64,22,1,0 %;
macro KA0C05_TLEP$V_TLBER_DS3 = 64,23,1,0 %;
macro KA0C05_TLEP$V_TLBER_DTDE = 64,24,1,0 %;
macro KA0C05_TLEP$V_TLBER_FDTCE = 64,25,1,0 %;
macro KA0C05_TLEP$V_TLBER_UACKE = 64,26,1,0 %;
macro KA0C05_TLEP$V_TLBER_ABTCE = 64,27,1,0 %;
macro KA0C05_TLEP$V_TLBER_DCTCE = 64,28,1,0 %;
macro KA0C05_TLEP$V_TLBER_SEQE = 64,29,1,0 %;
macro KA0C05_TLEP$V_TLBER_DSE = 64,30,1,0 %;
macro KA0C05_TLEP$V_TLBER_DTO = 64,31,1,0 %;
macro KA0C05_TLEP$b_f210 = 68,0,0,0 %;
literal KA0C05_TLEP$s_f210 = 60;
macro KA0C05_TLEP$L_TLCNR = 128,0,32,0 %;
macro KA0C05_TLEP$V_TLCNR_CWDD = 128,0,1,0 %;
macro KA0C05_TLEP$V_TLCNR_CRDD = 128,1,1,0 %;
macro KA0C05_TLEP$V_TLCNR_DTOD = 128,3,1,0 %;
macro KA0C05_TLEP$V_TLCNR_NODE_ID = 128,4,4,0 %;
literal KA0C05_TLEP$S_TLCNR_NODE_ID = 4;
macro KA0C05_TLEP$V_TLCNR_VCNT = 128,8,4,0 %;
literal KA0C05_TLEP$S_TLCNR_VCNT = 4;
macro KA0C05_TLEP$V_TLCNR_STF_A = 128,12,1,0 %;
macro KA0C05_TLEP$V_TLCNR_STF_B = 128,13,1,0 %;
macro KA0C05_TLEP$V_TLCNR_HALT_A = 128,20,1,0 %;
macro KA0C05_TLEP$V_TLCNR_HALT_B = 128,21,1,0 %;
macro KA0C05_TLEP$V_TLCNR_NRST = 128,30,1,0 %;
macro KA0C05_TLEP$V_TLCNR_LOFE = 128,31,1,0 %;
macro KA0C05_TLEP$b_f220 = 132,0,0,0 %;
literal KA0C05_TLEP$s_f220 = 60;
macro KA0C05_TLEP$L_TLVID = 192,0,32,0 %;
macro KA0C05_TLEP$V_VID_A = 192,0,4,0 %;
literal KA0C05_TLEP$S_VID_A = 4;
macro KA0C05_TLEP$V_VID_B = 192,4,4,0 %;
literal KA0C05_TLEP$S_VID_B = 4;
macro KA0C05_TLEP$b_f230 = 196,0,0,0 %;
literal KA0C05_TLEP$s_f230 = 316;
macro KA0C05_TLEP$L_TLMMR0 = 512,0,32,0 %;
macro KA0C05_TLEP$V_TLMMR0_INTMASK = 512,0,2,0 %;
literal KA0C05_TLEP$S_TLMMR0_INTMASK = 2;
macro KA0C05_TLEP$V_TLMMR0_ADRMASK = 512,4,4,0 %;
literal KA0C05_TLEP$S_TLMMR0_ADRMASK = 4;
macro KA0C05_TLEP$V_TLMMR0_INTLV = 512,8,3,0 %;
literal KA0C05_TLEP$S_TLMMR0_INTLV = 3;
macro KA0C05_TLEP$V_TLMMR0_SBANK = 512,11,1,0 %;
macro KA0C05_TLEP$V_TLMMR0_ADDRESS = 512,12,14,0 %;
literal KA0C05_TLEP$S_TLMMR0_ADDRESS = 14;
macro KA0C05_TLEP$V_TLMMR0_VALID = 512,31,1,0 %;
macro KA0C05_TLEP$b_f240 = 516,0,0,0 %;
literal KA0C05_TLEP$s_f240 = 60;
macro KA0C05_TLEP$L_TLMMR1 = 576,0,32,0 %;
macro KA0C05_TLEP$V_TLMMR1_INTMASK = 576,0,2,0 %;
literal KA0C05_TLEP$S_TLMMR1_INTMASK = 2;
macro KA0C05_TLEP$V_TLMMR1_ADRMASK = 576,4,4,0 %;
literal KA0C05_TLEP$S_TLMMR1_ADRMASK = 4;
macro KA0C05_TLEP$V_TLMMR1_INTLV = 576,8,3,0 %;
literal KA0C05_TLEP$S_TLMMR1_INTLV = 3;
macro KA0C05_TLEP$V_TLMMR1_SBANK = 576,11,1,0 %;
macro KA0C05_TLEP$V_TLMMR1_ADDRESS = 576,12,14,0 %;
literal KA0C05_TLEP$S_TLMMR1_ADDRESS = 14;
macro KA0C05_TLEP$V_TLMMR1_VALID = 576,31,1,0 %;
macro KA0C05_TLEP$b_f250 = 580,0,0,0 %;
literal KA0C05_TLEP$s_f250 = 60;
macro KA0C05_TLEP$L_TLMMR2 = 640,0,32,0 %;
macro KA0C05_TLEP$V_TLMMR2_INTMASK = 640,0,2,0 %;
literal KA0C05_TLEP$S_TLMMR2_INTMASK = 2;
macro KA0C05_TLEP$V_TLMMR2_ADRMASK = 640,4,4,0 %;
literal KA0C05_TLEP$S_TLMMR2_ADRMASK = 4;
macro KA0C05_TLEP$V_TLMMR2_INTLV = 640,8,3,0 %;
literal KA0C05_TLEP$S_TLMMR2_INTLV = 3;
macro KA0C05_TLEP$V_TLMMR2_SBANK = 640,11,1,0 %;
macro KA0C05_TLEP$V_TLMMR2_ADDRESS = 640,12,14,0 %;
literal KA0C05_TLEP$S_TLMMR2_ADDRESS = 14;
macro KA0C05_TLEP$V_TLMMR2_VALID = 640,31,1,0 %;
macro KA0C05_TLEP$b_f260 = 644,0,0,0 %;
literal KA0C05_TLEP$s_f260 = 60;
macro KA0C05_TLEP$L_TLMMR3 = 704,0,32,0 %;
macro KA0C05_TLEP$V_TLMMR3_INTMASK = 704,0,2,0 %;
literal KA0C05_TLEP$S_TLMMR3_INTMASK = 2;
macro KA0C05_TLEP$V_TLMMR3_ADRMASK = 704,4,4,0 %;
literal KA0C05_TLEP$S_TLMMR3_ADRMASK = 4;
macro KA0C05_TLEP$V_TLMMR3_INTLV = 704,8,3,0 %;
literal KA0C05_TLEP$S_TLMMR3_INTLV = 3;
macro KA0C05_TLEP$V_TLMMR3_SBANK = 704,11,1,0 %;
macro KA0C05_TLEP$V_TLMMR3_ADDRESS = 704,12,14,0 %;
literal KA0C05_TLEP$S_TLMMR3_ADDRESS = 14;
macro KA0C05_TLEP$V_TLMMR3_VALID = 704,31,1,0 %;
macro KA0C05_TLEP$b_f270 = 708,0,0,0 %;
literal KA0C05_TLEP$s_f270 = 60;
macro KA0C05_TLEP$L_TLMMR4 = 768,0,32,0 %;
macro KA0C05_TLEP$V_TLMMR4_INTMASK = 768,0,2,0 %;
literal KA0C05_TLEP$S_TLMMR4_INTMASK = 2;
macro KA0C05_TLEP$V_TLMMR4_ADRMASK = 768,4,4,0 %;
literal KA0C05_TLEP$S_TLMMR4_ADRMASK = 4;
macro KA0C05_TLEP$V_TLMMR4_INTLV = 768,8,3,0 %;
literal KA0C05_TLEP$S_TLMMR4_INTLV = 3;
macro KA0C05_TLEP$V_TLMMR4_SBANK = 768,11,1,0 %;
macro KA0C05_TLEP$V_TLMMR4_ADDRESS = 768,12,14,0 %;
literal KA0C05_TLEP$S_TLMMR4_ADDRESS = 14;
macro KA0C05_TLEP$V_TLMMR4_VALID = 768,31,1,0 %;
macro KA0C05_TLEP$b_f280 = 772,0,0,0 %;
literal KA0C05_TLEP$s_f280 = 60;
macro KA0C05_TLEP$L_TLMMR5 = 832,0,32,0 %;
macro KA0C05_TLEP$V_TLMMR5_INTMASK = 832,0,2,0 %;
literal KA0C05_TLEP$S_TLMMR5_INTMASK = 2;
macro KA0C05_TLEP$V_TLMMR5_ADRMASK = 832,4,4,0 %;
literal KA0C05_TLEP$S_TLMMR5_ADRMASK = 4;
macro KA0C05_TLEP$V_TLMMR5_INTLV = 832,8,3,0 %;
literal KA0C05_TLEP$S_TLMMR5_INTLV = 3;
macro KA0C05_TLEP$V_TLMMR5_SBANK = 832,11,1,0 %;
macro KA0C05_TLEP$V_TLMMR5_ADDRESS = 832,12,14,0 %;
literal KA0C05_TLEP$S_TLMMR5_ADDRESS = 14;
macro KA0C05_TLEP$V_TLMMR5_VALID = 832,31,1,0 %;
macro KA0C05_TLEP$b_f290 = 836,0,0,0 %;
literal KA0C05_TLEP$s_f290 = 60;
macro KA0C05_TLEP$L_TLMMR6 = 896,0,32,0 %;
macro KA0C05_TLEP$V_TLMMR6_INTMASK = 896,0,2,0 %;
literal KA0C05_TLEP$S_TLMMR6_INTMASK = 2;
macro KA0C05_TLEP$V_TLMMR6_ADRMASK = 896,4,4,0 %;
literal KA0C05_TLEP$S_TLMMR6_ADRMASK = 4;
macro KA0C05_TLEP$V_TLMMR6_INTLV = 896,8,3,0 %;
literal KA0C05_TLEP$S_TLMMR6_INTLV = 3;
macro KA0C05_TLEP$V_TLMMR6_SBANK = 896,11,1,0 %;
macro KA0C05_TLEP$V_TLMMR6_ADDRESS = 896,12,14,0 %;
literal KA0C05_TLEP$S_TLMMR6_ADDRESS = 14;
macro KA0C05_TLEP$V_TLMMR6_VALID = 896,31,1,0 %;
macro KA0C05_TLEP$b_fill300 = 900,0,0,0 %;
literal KA0C05_TLEP$s_fill300 = 60;
macro KA0C05_TLEP$L_TLMMR7 = 960,0,32,0 %;
macro KA0C05_TLEP$V_TLMMR7_INTMASK = 960,0,2,0 %;
literal KA0C05_TLEP$S_TLMMR7_INTMASK = 2;
macro KA0C05_TLEP$V_TLMMR7_ADRMASK = 960,4,4,0 %;
literal KA0C05_TLEP$S_TLMMR7_ADRMASK = 4;
macro KA0C05_TLEP$V_TLMMR7_INTLV = 960,8,3,0 %;
literal KA0C05_TLEP$S_TLMMR7_INTLV = 3;
macro KA0C05_TLEP$V_TLMMR7_SBANK = 960,11,1,0 %;
macro KA0C05_TLEP$V_TLMMR7_ADDRESS = 960,12,14,0 %;
literal KA0C05_TLEP$S_TLMMR7_ADDRESS = 14;
macro KA0C05_TLEP$V_TLMMR7_VALID = 960,31,1,0 %;
macro KA0C05_TLEP$b_fill310 = 964,0,0,0 %;
literal KA0C05_TLEP$s_fill310 = 700;
macro KA0C05_TLEP$L_TLESR0 = 1664,0,32,0 %;
macro KA0C05_TLEP$V_TLESR0_SYND0 = 1664,0,8,0 %;
literal KA0C05_TLEP$S_TLESR0_SYND0 = 8;
macro KA0C05_TLEP$V_TLESR0_SYND1 = 1664,8,8,0 %;
literal KA0C05_TLEP$S_TLESR0_SYND1 = 8;
macro KA0C05_TLEP$V_TLESR0_TDE = 1664,16,1,0 %;
macro KA0C05_TLEP$V_TLESR0_TCE = 1664,17,1,0 %;
macro KA0C05_TLEP$V_TLESR0_DVTCE = 1664,18,1,0 %;
macro KA0C05_TLEP$V_TLESR0_UECC = 1664,19,1,0 %;
macro KA0C05_TLEP$V_TLESR0_CWECC = 1664,20,1,0 %;
macro KA0C05_TLEP$V_TLESR0_CRECC = 1664,21,1,0 %;
macro KA0C05_TLEP$V_TLESR0_CPU0 = 1664,22,1,0 %;
macro KA0C05_TLEP$V_TLESR0_CPU1 = 1664,23,1,0 %;
macro KA0C05_TLEP$V_TLESR0_LOFSYN = 1664,31,1,0 %;
macro KA0C05_TLEP$b_fill320 = 1668,0,0,0 %;
literal KA0C05_TLEP$s_fill320 = 60;
macro KA0C05_TLEP$L_TLESR1 = 1728,0,32,0 %;
macro KA0C05_TLEP$V_TLESR1_SYND0 = 1728,0,8,0 %;
literal KA0C05_TLEP$S_TLESR1_SYND0 = 8;
macro KA0C05_TLEP$V_TLESR1_SYND1 = 1728,8,8,0 %;
literal KA0C05_TLEP$S_TLESR1_SYND1 = 8;
macro KA0C05_TLEP$V_TLESR1_TDE = 1728,16,1,0 %;
macro KA0C05_TLEP$V_TLESR1_TCE = 1728,17,1,0 %;
macro KA0C05_TLEP$V_TLESR1_DVTCE = 1728,18,1,0 %;
macro KA0C05_TLEP$V_TLESR1_UECC = 1728,19,1,0 %;
macro KA0C05_TLEP$V_TLESR1_CWECC = 1728,20,1,0 %;
macro KA0C05_TLEP$V_TLESR1_CRECC = 1728,21,1,0 %;
macro KA0C05_TLEP$V_TLESR1_CPU0 = 1728,22,1,0 %;
macro KA0C05_TLEP$V_TLESR1_CPU1 = 1728,23,1,0 %;
macro KA0C05_TLEP$V_TLESR1_LOFSYN = 1728,31,1,0 %;
macro KA0C05_TLEP$b_fill330 = 1732,0,0,0 %;
literal KA0C05_TLEP$s_fill330 = 60;
macro KA0C05_TLEP$L_TLESR2 = 1792,0,32,0 %;
macro KA0C05_TLEP$V_TLESR2_SYND0 = 1792,0,8,0 %;
literal KA0C05_TLEP$S_TLESR2_SYND0 = 8;
macro KA0C05_TLEP$V_TLESR2_SYND1 = 1792,8,8,0 %;
literal KA0C05_TLEP$S_TLESR2_SYND1 = 8;
macro KA0C05_TLEP$V_TLESR2_TDE = 1792,16,1,0 %;
macro KA0C05_TLEP$V_TLESR2_TCE = 1792,17,1,0 %;
macro KA0C05_TLEP$V_TLESR2_DVTCE = 1792,18,1,0 %;
macro KA0C05_TLEP$V_TLESR2_UECC = 1792,19,1,0 %;
macro KA0C05_TLEP$V_TLESR2_CWECC = 1792,20,1,0 %;
macro KA0C05_TLEP$V_TLESR2_CRECC = 1792,21,1,0 %;
macro KA0C05_TLEP$V_TLESR2_CPU0 = 1792,22,1,0 %;
macro KA0C05_TLEP$V_TLESR2_CPU1 = 1792,23,1,0 %;
macro KA0C05_TLEP$V_TLESR2_LOFSYN = 1792,31,1,0 %;
macro KA0C05_TLEP$b_fill340 = 1796,0,0,0 %;
literal KA0C05_TLEP$s_fill340 = 60;
macro KA0C05_TLEP$L_TLESR3 = 1856,0,32,0 %;
macro KA0C05_TLEP$V_TLESR3_SYND0 = 1856,0,8,0 %;
literal KA0C05_TLEP$S_TLESR3_SYND0 = 8;
macro KA0C05_TLEP$V_TLESR3_SYND1 = 1856,8,8,0 %;
literal KA0C05_TLEP$S_TLESR3_SYND1 = 8;
macro KA0C05_TLEP$V_TLESR3_TDE = 1856,16,1,0 %;
macro KA0C05_TLEP$V_TLESR3_TCE = 1856,17,1,0 %;
macro KA0C05_TLEP$V_TLESR3_DVTCE = 1856,18,1,0 %;
macro KA0C05_TLEP$V_TLESR3_UECC = 1856,19,1,0 %;
macro KA0C05_TLEP$V_TLESR3_CWECC = 1856,20,1,0 %;
macro KA0C05_TLEP$V_TLESR3_CRECC = 1856,21,1,0 %;
macro KA0C05_TLEP$V_TLESR3_CPU0 = 1856,22,1,0 %;
macro KA0C05_TLEP$V_TLESR3_CPU1 = 1856,23,1,0 %;
macro KA0C05_TLEP$V_TLESR3_LOFSYN = 1856,31,1,0 %;
macro KA0C05_TLEP$b_fill350 = 1860,0,0,0 %;
literal KA0C05_TLEP$s_fill350 = 2236;
macro KA0C05_TLEP$L_TLDIAG = 4096,0,32,0 %;
macro KA0C05_TLEP$V_TLDIAG_FRIGN = 4096,0,1,0 %;
macro KA0C05_TLEP$V_TLDIAG_DTWR = 4096,1,1,0 %;
macro KA0C05_TLEP$V_TLDIAG_DTRD = 4096,2,1,0 %;
macro KA0C05_TLEP$V_TLDIAG_DTCP = 4096,3,1,0 %;
macro KA0C05_TLEP$V_TLDIAG_FVW = 4096,4,1,0 %;
macro KA0C05_TLEP$V_TLDIAG_FAE = 4096,5,1,0 %;
macro KA0C05_TLEP$V_TLDIAG_FCBE = 4096,6,1,0 %;
macro KA0C05_TLEP$V_TLDIAG_FDBE = 4096,7,1,0 %;
macro KA0C05_TLEP$V_TLDIAG_FDE = 4096,8,4,0 %;
literal KA0C05_TLEP$S_TLDIAG_FDE = 4;
macro KA0C05_TLEP$V_TLDIAG_FTW = 4096,12,1,0 %;
macro KA0C05_TLEP$V_TLDIAG_ASRT_FLT = 4096,13,1,0 %;
macro KA0C05_TLEP$V_TLDIAG_QWVAL_EN = 4096,14,1,0 %;
macro KA0C05_TLEP$V_TLDIAG_GSLOW = 4096,15,1,0 %;
macro KA0C05_TLEP$b_fill360 = 4100,0,0,0 %;
literal KA0C05_TLEP$s_fill360 = 60;
macro KA0C05_TLEP$L_TLDTAGD = 4160,0,32,0 %;
macro KA0C05_TLEP$V_TLDTAGD_DTAG_PAR = 4160,0,1,0 %;
macro KA0C05_TLEP$V_TLDTAGD_DTAG_DATA = 4160,1,19,0 %;
literal KA0C05_TLEP$S_TLDTAGD_DTAG_DATA = 19;
macro KA0C05_TLEP$b_fill370 = 4164,0,0,0 %;
literal KA0C05_TLEP$s_fill370 = 60;
macro KA0C05_TLEP$L_TLDTAGS = 4224,0,32,0 %;
macro KA0C05_TLEP$V_TLDTAGS_STATPAR = 4224,0,1,0 %;
macro KA0C05_TLEP$V_TLDTAGS_STATD = 4224,1,1,0 %;
macro KA0C05_TLEP$V_TLDTAGS_STATS = 4224,2,1,0 %;
macro KA0C05_TLEP$V_TLDTAGS_STATV = 4224,3,1,0 %;
macro KA0C05_TLEP$b_fill380 = 4228,0,0,0 %;
literal KA0C05_TLEP$s_fill380 = 60;
macro KA0C05_TLEP$L_TLMCFG = 4288,0,32,0 %;
macro KA0C05_TLEP$V_TLMCFG_CPU0DSBL = 4288,0,1,0 %;
macro KA0C05_TLEP$V_TLMCFG_CPU1DSBL = 4288,1,1,0 %;
macro KA0C05_TLEP$V_TLMCFG_BC_SIZE = 4288,2,2,0 %;
literal KA0C05_TLEP$S_TLMCFG_BC_SIZE = 2;
macro KA0C05_TLEP$V_TLMCFG_LO_EN = 4288,4,1,0 %;
macro KA0C05_TLEP$V_TLMCFG_RM_SIZE = 4288,5,1,0 %;
macro KA0C05_TLEP$V_TLMCFG_BCIDLE = 4288,6,4,0 %;
literal KA0C05_TLEP$S_TLMCFG_BCIDLE = 4;
macro KA0C05_TLEP$V_TLMCFG_CQ_ENTRY = 4288,10,3,0 %;
literal KA0C05_TLEP$S_TLMCFG_CQ_ENTRY = 3;
macro KA0C05_TLEP$V_TLMCFG_BQ_ENTRY = 4288,13,3,0 %;
literal KA0C05_TLEP$S_TLMCFG_BQ_ENTRY = 3;
macro KA0C05_TLEP$V_TLMCFG_SYS_DSBL = 4288,16,1,0 %;
macro KA0C05_TLEP$V_TLMCFG_EV5_DSBL = 4288,17,1,0 %;
macro KA0C05_TLEP$V_TLMCFG_FLT_DSBL = 4288,18,1,0 %;
macro KA0C05_TLEP$b_fill390 = 4292,0,0,0 %;
literal KA0C05_TLEP$s_fill390 = 60;
macro KA0C05_TLEP$L_TLIMASK0 = 4352,0,32,0 %;
macro KA0C05_TLEP$V_TLIMASK0_DUART0EN = 4352,0,1,0 %;
macro KA0C05_TLEP$V_TLIMASK0_IPL14_EN = 4352,1,1,0 %;
macro KA0C05_TLEP$V_TLIMASK0_IPL15_EN = 4352,2,1,0 %;
macro KA0C05_TLEP$V_TLIMASK0_IPL16_EN = 4352,3,1,0 %;
macro KA0C05_TLEP$V_TLIMASK0_IPL17_EN = 4352,4,1,0 %;
macro KA0C05_TLEP$V_TLIMASK0_IP_EN = 4352,5,1,0 %;
macro KA0C05_TLEP$V_TLIMASK0_INTIM_EN = 4352,6,1,0 %;
macro KA0C05_TLEP$V_TLIMASK0_HALT_EN = 4352,7,1,0 %;
macro KA0C05_TLEP$V_TLIMASK0_CP_EN = 4352,8,1,0 %;
macro KA0C05_TLEP$b_fill400 = 4356,0,0,0 %;
literal KA0C05_TLEP$s_fill400 = 60;
macro KA0C05_TLEP$L_TLIMASK1 = 4416,0,32,0 %;
macro KA0C05_TLEP$V_TLIMASK1_DUART0EN = 4416,0,1,0 %;
macro KA0C05_TLEP$V_TLIMASK1_IPL14_EN = 4416,1,1,0 %;
macro KA0C05_TLEP$V_TLIMASK1_IPL15_EN = 4416,2,1,0 %;
macro KA0C05_TLEP$V_TLIMASK1_IPL16_EN = 4416,3,1,0 %;
macro KA0C05_TLEP$V_TLIMASK1_IPL17_EN = 4416,4,1,0 %;
macro KA0C05_TLEP$V_TLIMASK1_IP_EN = 4416,5,1,0 %;
macro KA0C05_TLEP$V_TLIMASK1_INTIM_EN = 4416,6,1,0 %;
macro KA0C05_TLEP$V_TLIMASK1_HALT_EN = 4416,7,1,0 %;
macro KA0C05_TLEP$V_TLIMASK1_CP_EN = 4416,8,1,0 %;
macro KA0C05_TLEP$b_fill410 = 4420,0,0,0 %;
literal KA0C05_TLEP$s_fill410 = 60;
macro KA0C05_TLEP$L_TLISUM0 = 4480,0,32,0 %;
macro KA0C05_TLEP$V_TLISUM0_DUART0INT = 4480,0,1,0 %;
macro KA0C05_TLEP$V_TLISUM0_IPL14_INT = 4480,1,1,0 %;
macro KA0C05_TLEP$V_TLISUM0_IPL15_INT = 4480,2,1,0 %;
macro KA0C05_TLEP$V_TLISUM0_IPL16_INT = 4480,3,1,0 %;
macro KA0C05_TLEP$V_TLISUM0_IPL17_INT = 4480,4,1,0 %;
macro KA0C05_TLEP$V_TLISUM0_IP_INT = 4480,5,1,0 %;
macro KA0C05_TLEP$V_TLISUM0_INTIM_INT = 4480,6,1,0 %;
macro KA0C05_TLEP$V_TLISUM0_IPL14 = 4480,7,5,0 %;
literal KA0C05_TLEP$S_TLISUM0_IPL14 = 5;
macro KA0C05_TLEP$V_TLISUM0_IPL15 = 4480,12,5,0 %;
literal KA0C05_TLEP$S_TLISUM0_IPL15 = 5;
macro KA0C05_TLEP$V_TLISUM0_IPL16 = 4480,17,5,0 %;
literal KA0C05_TLEP$S_TLISUM0_IPL16 = 5;
macro KA0C05_TLEP$V_TLISUM0_IPL17 = 4480,22,5,0 %;
literal KA0C05_TLEP$S_TLISUM0_IPL17 = 5;
macro KA0C05_TLEP$V_TLISUM0_CP_HALT = 4480,27,1,0 %;
macro KA0C05_TLEP$V_TLISUM0_HALT = 4480,28,1,0 %;
macro KA0C05_TLEP$b_fill420 = 4484,0,0,0 %;
literal KA0C05_TLEP$s_fill420 = 60;
macro KA0C05_TLEP$L_TLISUM1 = 4544,0,32,0 %;
macro KA0C05_TLEP$V_TLISUM1_DUART0INT = 4544,0,1,0 %;
macro KA0C05_TLEP$V_TLISUM1_IPL14_INT = 4544,1,1,0 %;
macro KA0C05_TLEP$V_TLISUM1_IPL15_INT = 4544,2,1,0 %;
macro KA0C05_TLEP$V_TLISUM1_IPL16_INT = 4544,3,1,0 %;
macro KA0C05_TLEP$V_TLISUM1_IPL17_INT = 4544,4,1,0 %;
macro KA0C05_TLEP$V_TLISUM1_IP_INT = 4544,5,1,0 %;
macro KA0C05_TLEP$V_TLISUM1_INTIM_INT = 4544,6,1,0 %;
macro KA0C05_TLEP$V_TLISUM1_IPL14 = 4544,7,5,0 %;
literal KA0C05_TLEP$S_TLISUM1_IPL14 = 5;
macro KA0C05_TLEP$V_TLISUM1_IPL15 = 4544,12,5,0 %;
literal KA0C05_TLEP$S_TLISUM1_IPL15 = 5;
macro KA0C05_TLEP$V_TLISUM1_IPL16 = 4544,17,5,0 %;
literal KA0C05_TLEP$S_TLISUM1_IPL16 = 5;
macro KA0C05_TLEP$V_TLISUM1_IPL17 = 4544,22,5,0 %;
literal KA0C05_TLEP$S_TLISUM1_IPL17 = 5;
macro KA0C05_TLEP$V_TLISUM1_CP_HALT = 4544,27,1,0 %;
macro KA0C05_TLEP$V_TLISUM1_HALT = 4544,28,1,0 %;
macro KA0C05_TLEP$b_fill430 = 4548,0,0,0 %;
literal KA0C05_TLEP$s_fill430 = 60;
macro KA0C05_TLEP$L_TLCON00 = 4608,0,32,0 %;
macro KA0C05_TLEP$b_fill440 = 4612,0,0,0 %;
literal KA0C05_TLEP$s_fill440 = 60;
macro KA0C05_TLEP$L_TLCON00A = 4672,0,32,0 %;
macro KA0C05_TLEP$b_fill450 = 4676,0,0,0 %;
literal KA0C05_TLEP$s_fill450 = 60;
macro KA0C05_TLEP$L_TLCON00B = 4736,0,32,0 %;
macro KA0C05_TLEP$b_fill460 = 4740,0,0,0 %;
literal KA0C05_TLEP$s_fill460 = 60;
macro KA0C05_TLEP$L_TLCON00C = 4800,0,32,0 %;
macro KA0C05_TLEP$b_fill470 = 4804,0,0,0 %;
literal KA0C05_TLEP$s_fill470 = 60;
macro KA0C05_TLEP$L_TLCON10 = 4864,0,32,0 %;
macro KA0C05_TLEP$b_fill480 = 4868,0,0,0 %;
literal KA0C05_TLEP$s_fill480 = 60;
macro KA0C05_TLEP$L_TLCON10A = 4928,0,32,0 %;
macro KA0C05_TLEP$b_fill490 = 4932,0,0,0 %;
literal KA0C05_TLEP$s_fill490 = 60;
macro KA0C05_TLEP$L_TLCON10B = 4992,0,32,0 %;
macro KA0C05_TLEP$b_fill500 = 4996,0,0,0 %;
literal KA0C05_TLEP$s_fill500 = 60;
macro KA0C05_TLEP$L_TLCON10C = 5056,0,32,0 %;
macro KA0C05_TLEP$b_fill510 = 5060,0,0,0 %;
literal KA0C05_TLEP$s_fill510 = 60;
macro KA0C05_TLEP$L_TLCON01 = 5120,0,32,0 %;
macro KA0C05_TLEP$b_fill520 = 5124,0,0,0 %;
literal KA0C05_TLEP$s_fill520 = 60;
macro KA0C05_TLEP$L_TLCON11 = 5184,0,32,0 %;
macro KA0C05_TLEP$b_fill530 = 5188,0,0,0 %;
literal KA0C05_TLEP$s_fill530 = 188;
macro KA0C05_TLEP$L_TLEPAERR = 5376,0,32,0 %;
macro KA0C05_TLEP$V_TLEPAERR_E2MAPE0 = 5376,0,1,0 %;
macro KA0C05_TLEP$V_TLEPAERR_E2MAPE1 = 5376,1,1,0 %;
macro KA0C05_TLEP$V_TLEPAERR_M2AAPE0 = 5376,2,1,0 %;
macro KA0C05_TLEP$V_TLEPAERR_M2AAPE1 = 5376,3,1,0 %;
macro KA0C05_TLEP$V_TLEPAERR_DTDPE = 5376,4,1,0 %;
macro KA0C05_TLEP$V_TLEPAERR_DTSPE = 5376,5,1,0 %;
macro KA0C05_TLEP$V_TLEPAERR_D2ACPE = 5376,6,1,0 %;
macro KA0C05_TLEP$V_TLEPAERR_SYSDERR = 5376,7,1,0 %;
macro KA0C05_TLEP$V_TLEPAERR_SYSFLT = 5376,8,1,0 %;
macro KA0C05_TLEP$V_TLEPAERR_RD_ERR = 5376,9,2,0 %;
literal KA0C05_TLEP$S_TLEPAERR_RD_ERR = 2;
macro KA0C05_TLEP$V_TLEPAERR_IBOXTO = 5376,11,2,0 %;
literal KA0C05_TLEP$S_TLEPAERR_IBOXTO = 2;
macro KA0C05_TLEP$V_TLEPAERR_RD_PEND = 5376,13,2,0 %;
literal KA0C05_TLEP$S_TLEPAERR_RD_PEND = 2;
macro KA0C05_TLEP$V_TLEPAERR_NXM = 5376,15,1,0 %;
macro KA0C05_TLEP$V_TLEPAERR_NO_ACK = 5376,16,2,0 %;
literal KA0C05_TLEP$S_TLEPAERR_NO_ACK = 2;
macro KA0C05_TLEP$b_fill540 = 5380,0,0,0 %;
literal KA0C05_TLEP$s_fill540 = 60;
macro KA0C05_TLEP$L_TLEPDERR = 5440,0,32,0 %;
macro KA0C05_TLEP$V_TLEPDERR_A2DCPE = 5440,0,1,0 %;
macro KA0C05_TLEP$V_TLEPDERR_D2DCPE0 = 5440,1,1,0 %;
macro KA0C05_TLEP$V_TLEPDERR_GBTO = 5440,2,1,0 %;
macro KA0C05_TLEP$b_fill550 = 5444,0,0,0 %;
literal KA0C05_TLEP$s_fill550 = 60;
macro KA0C05_TLEP$L_TLEPMERR = 5504,0,32,0 %;
macro KA0C05_TLEP$V_TLEPMERR_A2MAPE0 = 5504,0,1,0 %;
macro KA0C05_TLEP$V_TLEPMERR_A2MAPE1 = 5504,1,1,0 %;
macro KA0C05_TLEP$V_TLEPMERR_D2MCPE = 5504,2,1,0 %;
macro KA0C05_TLEP$V_TLEPMERR_D2DCPE1 = 5504,3,1,0 %;
macro KA0C05_TLEP$V_TLEPMERR_D2DCPE2 = 5504,4,1,0 %;
macro KA0C05_TLEP$V_TLEPMERR_D2DCPE3 = 5504,5,1,0 %;
macro KA0C05_TLEP$V_TLEPMERR_RSTSTAT = 5504,6,1,0 %;
macro KA0C05_TLEP$b_fill560 = 5508,0,0,0 %;
literal KA0C05_TLEP$s_fill560 = 60;
macro KA0C05_TLEP$L_TLEP_VMG = 5568,0,32,0 %;
macro KA0C05_TLEP$V_TLEP_VMG_5P = 5568,0,1,0 %;
macro KA0C05_TLEP$V_TLEP_VMG_5M = 5568,1,1,0 %;
macro KA0C05_TLEP$V_TLEP_VMG_3P = 5568,2,1,0 %;
macro KA0C05_TLEP$V_TLEP_VMG_3M = 5568,3,1,0 %;
macro KA0C05_TLEP$b_fill570 = 5572,0,0,0 %;
literal KA0C05_TLEP$s_fill570 = 60;
macro KA0C05_TLEP$L_TLDMCMD = 5632,0,32,0 %;
macro KA0C05_TLEP$V_TLDMCMD_SIZE_512 = 5632,0,1,0 %;
macro KA0C05_TLEP$V_TLDMCMD_SIZE_1K = 5632,1,1,0 %;
macro KA0C05_TLEP$V_TLDMCMD_SIZE_2K = 5632,2,1,0 %;
macro KA0C05_TLEP$V_TLDMCMD_SIZE_4K = 5632,3,1,0 %;
macro KA0C05_TLEP$V_TLDMCMD_SIZE_8K = 5632,4,1,0 %;
macro KA0C05_TLEP$V_TLDMCMD_CMD = 5632,8,2,0 %;
literal KA0C05_TLEP$S_TLDMCMD_CMD = 2;
macro KA0C05_TLEP$V_TLDMCMD_VALID = 5632,11,1,0 %;
macro KA0C05_TLEP$V_TLDMCMD_RM_3 = 5632,12,1,0 %;
macro KA0C05_TLEP$V_TLDMCMD_RM_4 = 5632,13,1,0 %;
macro KA0C05_TLEP$V_TLDMCMD_RM_INLV = 5632,14,1,0 %;
macro KA0C05_TLEP$V_TLDMCMD_CPU_ID = 5632,16,1,0 %;
macro KA0C05_TLEP$V_TLDMCMD_IN_PROG = 5632,20,1,0 %;
macro KA0C05_TLEP$V_TLDMCMD_DONE = 5632,21,1,0 %;
macro KA0C05_TLEP$b_fill580 = 5636,0,0,0 %;
literal KA0C05_TLEP$s_fill580 = 124;
macro KA0C05_TLEP$L_TLDMADRA = 5760,0,32,0 %;
macro KA0C05_TLEP$V_TLDMADRA_ADDR = 5760,0,30,0 %;
literal KA0C05_TLEP$S_TLDMADRA_ADDR = 30;
macro KA0C05_TLEP$b_fill590 = 5764,0,0,0 %;
literal KA0C05_TLEP$s_fill590 = 60;
macro KA0C05_TLEP$L_TLDMADRB = 5824,0,32,0 %;
macro KA0C05_TLEP$V_TLDMADRB_ADDR = 5824,0,30,0 %;
literal KA0C05_TLEP$S_TLDMADRB_ADDR = 30;
macro KA0C05_TLEP$b_fill600 = 5828,0,0,0 %;
literal KA0C05_TLEP$s_fill600 = 316;
macro KA0C05_TLEP$L_TLPM_CMD = 6144,0,32,0 %;
macro KA0C05_TLEP$V_TLPM_CMD_CPUNUM = 6144,0,1,0 %;
macro KA0C05_TLEP$V_TLPM_CMD_SET_SEL = 6144,1,2,0 %;
literal KA0C05_TLEP$S_TLPM_CMD_SET_SEL = 2;
macro KA0C05_TLEP$V_TLPM_CMD_VALID = 6144,3,1,0 %;
macro KA0C05_TLEP$V_TLPM_CMD_READ_SET = 6144,4,1,0 %;
macro KA0C05_TLEP$V_TLPM_CMD_OVRF_EN = 6144,11,1,0 %;
macro KA0C05_TLEP$V_TLPM_CMD_TOT_CYC = 6144,12,1,0 %;
macro KA0C05_TLEP$V_TLPM_CMD_EV5_LAT = 6144,13,1,0 %;
macro KA0C05_TLEP$V_TLPM_CMD_RD_LAT = 6144,14,1,0 %;
macro KA0C05_TLEP$V_TLPM_CMD_SYS_OWN = 6144,15,1,0 %;
macro KA0C05_TLEP$V_TLPM_CMD_f2 = 6144,16,1,0 %;
macro KA0C05_TLEP$V_TLPM_CMD_LOCK = 6144,17,1,0 %;
macro KA0C05_TLEP$V_TLPM_CMD_MB = 6144,18,1,0 %;
macro KA0C05_TLEP$V_TLPM_CMD_SD_TOT = 6144,19,1,0 %;
macro KA0C05_TLEP$V_TLPM_CMD_SD_ACK = 6144,20,1,0 %;
macro KA0C05_TLEP$V_TLPM_CMD_RD_CSR = 6144,21,1,0 %;
macro KA0C05_TLEP$V_TLPM_CMD_RD = 6144,22,1,0 %;
macro KA0C05_TLEP$V_TLPM_CMD_RD_MOD = 6144,23,1,0 %;
macro KA0C05_TLEP$V_TLPM_CMD_RD_STC = 6144,24,1,0 %;
macro KA0C05_TLEP$V_TLPM_CMD_VIC = 6144,25,1,0 %;
macro KA0C05_TLEP$V_TLPM_CMD_WR_CSR = 6144,26,1,0 %;
macro KA0C05_TLEP$V_TLPM_CMD_WR = 6144,27,1,0 %;
macro KA0C05_TLEP$V_TLPM_CMD_WR_LOCK = 6144,28,1,0 %;
macro KA0C05_TLEP$V_TLPM_CMD_INVAL = 6144,29,1,0 %;
macro KA0C05_TLEP$V_TLPM_CMD_SET_SHR = 6144,30,1,0 %;
macro KA0C05_TLEP$V_TLPM_CMD_RD_DIRT = 6144,31,1,0 %;
macro KA0C05_TLEP$b_fill610 = 6148,0,0,0 %;
literal KA0C05_TLEP$s_fill610 = 60;
macro KA0C05_TLEP$L_TLPM_TOT_CYCLES = 6208,0,32,0 %;
macro KA0C05_TLEP$b_fill620 = 6212,0,0,0 %;
literal KA0C05_TLEP$s_fill620 = 60;
macro KA0C05_TLEP$L_TLPM_EV5_LAT = 6272,0,32,0 %;
macro KA0C05_TLEP$b_fill630 = 6276,0,0,0 %;
literal KA0C05_TLEP$s_fill630 = 60;
macro KA0C05_TLEP$L_TLPM_READ_LAT = 6336,0,32,0 %;
macro KA0C05_TLEP$b_fill640 = 6340,0,0,0 %;
literal KA0C05_TLEP$s_fill640 = 60;
macro KA0C05_TLEP$L_TLPM_OWNER = 6400,0,32,0 %;
macro KA0C05_TLEP$b_fill650 = 6404,0,0,0 %;
literal KA0C05_TLEP$s_fill650 = 60;
macro KA0C05_TLEP$L_TLPM_SILO = 6464,0,32,0 %;
macro KA0C05_TLEP$b_fill660 = 6468,0,0,0 %;
literal KA0C05_TLEP$s_fill660 = 60;
macro KA0C05_TLEP$L_TLPM_LOCK = 6528,0,32,0 %;
macro KA0C05_TLEP$b_fill670 = 6532,0,0,0 %;
literal KA0C05_TLEP$s_fill670 = 60;
macro KA0C05_TLEP$L_TLPM_MB = 6592,0,32,0 %;
macro KA0C05_TLEP$b_fill680 = 6596,0,0,0 %;
literal KA0C05_TLEP$s_fill680 = 60;
macro KA0C05_TLEP$L_TLPM_SD = 6656,0,32,0 %;
macro KA0C05_TLEP$b_fill690 = 6660,0,0,0 %;
literal KA0C05_TLEP$s_fill690 = 60;
macro KA0C05_TLEP$L_TLPM_SD_ACK = 6720,0,32,0 %;
macro KA0C05_TLEP$b_fill700 = 6724,0,0,0 %;
literal KA0C05_TLEP$s_fill700 = 60;
macro KA0C05_TLEP$L_TLPM_RD_CSR = 6784,0,32,0 %;
macro KA0C05_TLEP$b_fill710 = 6788,0,0,0 %;
literal KA0C05_TLEP$s_fill710 = 60;
macro KA0C05_TLEP$L_TLPM_RD_MISS = 6848,0,32,0 %;
macro KA0C05_TLEP$b_fill720 = 6852,0,0,0 %;
literal KA0C05_TLEP$s_fill720 = 60;
macro KA0C05_TLEP$L_TLPM_RD_MOD = 6912,0,32,0 %;
macro KA0C05_TLEP$b_fill730 = 6916,0,0,0 %;
literal KA0C05_TLEP$s_fill730 = 60;
macro KA0C05_TLEP$L_TLPM_RD_STC = 6976,0,32,0 %;
macro KA0C05_TLEP$b_fill740 = 6980,0,0,0 %;
literal KA0C05_TLEP$s_fill740 = 60;
macro KA0C05_TLEP$L_TLPM_VICTIM = 7040,0,32,0 %;
macro KA0C05_TLEP$b_fill750 = 7044,0,0,0 %;
literal KA0C05_TLEP$s_fill750 = 60;
macro KA0C05_TLEP$L_TLPM_WR_CSR = 7104,0,32,0 %;
macro KA0C05_TLEP$b_fill760 = 7108,0,0,0 %;
literal KA0C05_TLEP$s_fill760 = 60;
macro KA0C05_TLEP$L_TLPM_WR = 7168,0,32,0 %;
macro KA0C05_TLEP$b_fill770 = 7172,0,0,0 %;
literal KA0C05_TLEP$s_fill770 = 60;
macro KA0C05_TLEP$L_TLPM_WR_LOCK = 7232,0,32,0 %;
macro KA0C05_TLEP$b_fill780 = 7236,0,0,0 %;
literal KA0C05_TLEP$s_fill780 = 60;
macro KA0C05_TLEP$L_TLPM_INVAL = 7296,0,32,0 %;
macro KA0C05_TLEP$b_fill790 = 7300,0,0,0 %;
literal KA0C05_TLEP$s_fill790 = 60;
macro KA0C05_TLEP$L_TLPM_S_SHRD = 7360,0,32,0 %;
macro KA0C05_TLEP$b_fill800 = 7364,0,0,0 %;
literal KA0C05_TLEP$s_fill800 = 60;
macro KA0C05_TLEP$L_TLPM_RD = 7424,0,32,0 %;
macro KA0C05_TLEP$b_fill810 = 7428,0,0,0 %;
literal KA0C05_TLEP$s_fill810 = 60;
macro KA0C05_TLEP$L_TLPM_ASILO = 7488,0,32,0 %;
macro KA0C05_TLEP$b_fill820 = 7492,0,0,0 %;
literal KA0C05_TLEP$s_fill820 = 60;
macro KA0C05_TLEP$L_RM_REG0A = 7552,0,32,0 %;
macro KA0C05_TLEP$V_RM_REG0A_AEXT = 7552,0,4,0 %;
literal KA0C05_TLEP$S_RM_REG0A_AEXT = 4;
macro KA0C05_TLEP$V_RM_REG0A_BADDR = 7552,8,20,0 %;
literal KA0C05_TLEP$S_RM_REG0A_BADDR = 20;
macro KA0C05_TLEP$V_RM_REG0A_VALID = 7552,31,1,0 %;
macro KA0C05_TLEP$b_fill830 = 7556,0,0,0 %;
literal KA0C05_TLEP$s_fill830 = 60;
macro KA0C05_TLEP$L_RM_REG0B = 7616,0,32,0 %;
macro KA0C05_TLEP$V_RM_REG0B_AEXT = 7616,0,4,0 %;
literal KA0C05_TLEP$S_RM_REG0B_AEXT = 4;
macro KA0C05_TLEP$V_RM_REG0B_BADDR = 7616,8,20,0 %;
literal KA0C05_TLEP$S_RM_REG0B_BADDR = 20;
macro KA0C05_TLEP$V_RM_REG0B_VALID = 7616,31,1,0 %;
macro KA0C05_TLEP$b_fill840 = 7620,0,0,0 %;
literal KA0C05_TLEP$s_fill840 = 60;
macro KA0C05_TLEP$L_RM_REG1A = 7680,0,32,0 %;
macro KA0C05_TLEP$V_RM_REG1A_AEXT = 7680,0,4,0 %;
literal KA0C05_TLEP$S_RM_REG1A_AEXT = 4;
macro KA0C05_TLEP$V_RM_REG1A_BADDR = 7680,8,20,0 %;
literal KA0C05_TLEP$S_RM_REG1A_BADDR = 20;
macro KA0C05_TLEP$V_RM_REG1A_VALID = 7680,31,1,0 %;
macro KA0C05_TLEP$b_fill850 = 7684,0,0,0 %;
literal KA0C05_TLEP$s_fill850 = 60;
macro KA0C05_TLEP$L_RM_REG1B = 7744,0,32,0 %;
macro KA0C05_TLEP$V_RM_REG1B_AEXT = 7744,0,4,0 %;
literal KA0C05_TLEP$S_RM_REG1B_AEXT = 4;
macro KA0C05_TLEP$V_RM_REG1B_BADDR = 7744,8,20,0 %;
literal KA0C05_TLEP$S_RM_REG1B_BADDR = 20;
macro KA0C05_TLEP$V_RM_REG1B_VALID = 7744,31,1,0 %;
macro KA0C05_TLEP$b_fill860 = 7748,0,0,0 %;
literal KA0C05_TLEP$s_fill860 = 316;
literal KA0C05_TLMEM$M_TLDEV_DTYPE = %X'FFFF';
literal KA0C05_TLMEM$M_TLDEV_SWREV = %X'FF0000';
literal KA0C05_TLMEM$M_TLDEV_HWREV = %X'FF000000';
literal KA0C05_TLMEM$M_TLBER_ATCE = %X'1';
literal KA0C05_TLMEM$M_TLBER_APE = %X'2';
literal KA0C05_TLMEM$M_TLBER_BBE = %X'4';
literal KA0C05_TLMEM$M_TLBER_LKTO = %X'8';
literal KA0C05_TLMEM$M_TLBER_NAE = %X'10';
literal KA0C05_TLMEM$M_TLBER_RTCE = %X'20';
literal KA0C05_TLMEM$M_TLBER_ACKTCE = %X'40';
literal KA0C05_TLMEM$M_TLBER_MMRE = %X'80';
literal KA0C05_TLMEM$M_TLBER_FNAE = %X'100';
literal KA0C05_TLMEM$M_TLBER_REQDE = %X'200';
literal KA0C05_TLMEM$M_TLBER_ATDE = %X'400';
literal KA0C05_TLMEM$M_TLBER_UDE = %X'10000';
literal KA0C05_TLMEM$M_TLBER_CWDE = %X'20000';
literal KA0C05_TLMEM$M_TLBER_CRDE = %X'40000';
literal KA0C05_TLMEM$M_TLBER_DS0 = %X'100000';
literal KA0C05_TLMEM$M_TLBER_DS1 = %X'200000';
literal KA0C05_TLMEM$M_TLBER_DS2 = %X'400000';
literal KA0C05_TLMEM$M_TLBER_DS3 = %X'800000';
literal KA0C05_TLMEM$M_TLBER_DTDE = %X'1000000';
literal KA0C05_TLMEM$M_TLBER_FDTCE = %X'2000000';
literal KA0C05_TLMEM$M_TLBER_UACKE = %X'4000000';
literal KA0C05_TLMEM$M_TLBER_ABTCE = %X'8000000';
literal KA0C05_TLMEM$M_TLBER_DCTCE = %X'10000000';
literal KA0C05_TLMEM$M_TLBER_SEQE = %X'20000000';
literal KA0C05_TLMEM$M_TLBER_DSE = %X'40000000';
literal KA0C05_TLMEM$M_TLBER_DTO = %X'80000000';
literal KA0C05_TLMEM$M_TLCNR_CWDD = %X'1';
literal KA0C05_TLMEM$M_TLCNR_CRDD = %X'2';
literal KA0C05_TLMEM$M_TLCNR_LKTOD = %X'4';
literal KA0C05_TLMEM$M_TLCNR_DTOD = %X'8';
literal KA0C05_TLMEM$M_TLCNR_NODE_ID = %X'F0';
literal KA0C05_TLMEM$M_TLCNR_VCNT = %X'F00';
literal KA0C05_TLMEM$M_TLCNR_STF_A = %X'1000';
literal KA0C05_TLMEM$M_TLCNR_STF_B = %X'2000';
literal KA0C05_TLMEM$M_TLCNR_STF_C = %X'4000';
literal KA0C05_TLMEM$M_TLCNR_STF_D = %X'8000';
literal KA0C05_TLMEM$M_TLCNR_STF_E = %X'10000';
literal KA0C05_TLMEM$M_TLCNR_STF_F = %X'20000';
literal KA0C05_TLMEM$M_TLCNR_STF_G = %X'40000';
literal KA0C05_TLMEM$M_TLCNR_STF_H = %X'80000';
literal KA0C05_TLMEM$M_TLCNR_HALT_A = %X'100000';
literal KA0C05_TLMEM$M_TLCNR_HALT_B = %X'200000';
literal KA0C05_TLMEM$M_TLCNR_HALT_C = %X'400000';
literal KA0C05_TLMEM$M_TLCNR_HALT_D = %X'800000';
literal KA0C05_TLMEM$M_TLCNR_HALT_E = %X'1000000';
literal KA0C05_TLMEM$M_TLCNR_HALT_F = %X'2000000';
literal KA0C05_TLMEM$M_TLCNR_HALT_G = %X'4000000';
literal KA0C05_TLMEM$M_TLCNR_HALT_H = %X'8000000';
literal KA0C05_TLMEM$M_TLCNR_RSTSTAT = %X'10000000';
literal KA0C05_TLMEM$M_TLCNR_NRST = %X'40000000';
literal KA0C05_TLMEM$M_TLCNR_LOFE = %X'80000000';
literal KA0C05_TLMEM$M_VID_A = %X'F';
literal KA0C05_TLMEM$M_VID_B = %X'F0';
literal KA0C05_TLMEM$M_VID_C = %X'F00';
literal KA0C05_TLMEM$M_VID_D = %X'F000';
literal KA0C05_TLMEM$M_VID_E = %X'F0000';
literal KA0C05_TLMEM$M_VID_F = %X'F00000';
literal KA0C05_TLMEM$M_VID_G = %X'F000000';
literal KA0C05_TLMEM$M_VID_H = %X'F0000000';
literal KA0C05_TLMEM$M_TLFADR0_FADR = %X'FFFFFFF8';
literal KA0C05_TLMEM$M_TLFADR1_FADR = %X'FF';
literal KA0C05_TLMEM$M_TLFADR1_FCMD = %X'70000';
literal KA0C05_TLMEM$M_TLFADR1_FBANK = %X'F00000';
literal KA0C05_TLMEM$M_TLFADR1_ADRV = %X'1000000';
literal KA0C05_TLMEM$M_TLFADR1_CMDV = %X'2000000';
literal KA0C05_TLMEM$M_TLFADR1_BANKV = %X'4000000';
literal KA0C05_TLMEM$M_TLESR0_SYND0 = %X'FF';
literal KA0C05_TLMEM$M_TLESR0_SYND1 = %X'FF00';
literal KA0C05_TLMEM$M_TLESR0_TDE = %X'10000';
literal KA0C05_TLMEM$M_TLESR0_TCE = %X'20000';
literal KA0C05_TLMEM$M_TLESR0_DVTCE = %X'40000';
literal KA0C05_TLMEM$M_TLESR0_UECC = %X'80000';
literal KA0C05_TLMEM$M_TLESR0_CWECC = %X'100000';
literal KA0C05_TLMEM$M_TLESR0_CRECC = %X'200000';
literal KA0C05_TLMEM$M_TLESR0_LOFSYN = %X'80000000';
literal KA0C05_TLMEM$M_TLESR1_SYND0 = %X'FF';
literal KA0C05_TLMEM$M_TLESR1_SYND1 = %X'FF00';
literal KA0C05_TLMEM$M_TLESR1_TDE = %X'10000';
literal KA0C05_TLMEM$M_TLESR1_TCE = %X'20000';
literal KA0C05_TLMEM$M_TLESR1_DVTCE = %X'40000';
literal KA0C05_TLMEM$M_TLESR1_UECC = %X'80000';
literal KA0C05_TLMEM$M_TLESR1_CWECC = %X'100000';
literal KA0C05_TLMEM$M_TLESR1_CRECC = %X'200000';
literal KA0C05_TLMEM$M_TLESR1_LOFSYN = %X'80000000';
literal KA0C05_TLMEM$M_TLESR2_SYND0 = %X'FF';
literal KA0C05_TLMEM$M_TLESR2_SYND1 = %X'FF00';
literal KA0C05_TLMEM$M_TLESR2_TDE = %X'10000';
literal KA0C05_TLMEM$M_TLESR2_TCE = %X'20000';
literal KA0C05_TLMEM$M_TLESR2_DVTCE = %X'40000';
literal KA0C05_TLMEM$M_TLESR2_UECC = %X'80000';
literal KA0C05_TLMEM$M_TLESR2_CWECC = %X'100000';
literal KA0C05_TLMEM$M_TLESR2_CRECC = %X'200000';
literal KA0C05_TLMEM$M_TLESR2_LOFSYN = %X'80000000';
literal KA0C05_TLMEM$M_TLESR3_SYND0 = %X'FF';
literal KA0C05_TLMEM$M_TLESR3_SYND1 = %X'FF00';
literal KA0C05_TLMEM$M_TLESR3_TDE = %X'10000';
literal KA0C05_TLMEM$M_TLESR3_TCE = %X'20000';
literal KA0C05_TLMEM$M_TLESR3_DVTCE = %X'40000';
literal KA0C05_TLMEM$M_TLESR3_UECC = %X'80000';
literal KA0C05_TLMEM$M_TLESR3_CWECC = %X'100000';
literal KA0C05_TLMEM$M_TLESR3_CRECC = %X'200000';
literal KA0C05_TLMEM$M_TLESR3_LOFSYN = %X'80000000';
literal KA0C05_TLMEM$M_TLSECR_RCV_SDAT = %X'1';
literal KA0C05_TLMEM$M_TLSECR_XMT_SDAT = %X'2';
literal KA0C05_TLMEM$M_TLSECR_SCLK = %X'4';
literal KA0C05_TLMEM$M_TLMIR_INT = %X'7';
literal KA0C05_TLMEM$M_TLMIR_V = %X'80000000';
literal KA0C05_TLMEM$M_TLMCR_DTYP = %X'1';
literal KA0C05_TLMEM$M_TLMCR_STRN = %X'C';
literal KA0C05_TLMEM$M_TLMCR_DTR = %X'30';
literal KA0C05_TLMEM$M_TLMCR_DEFLT = %X'40';
literal KA0C05_TLMEM$M_TLMCR_SHRD = %X'100';
literal KA0C05_TLMEM$M_TLMCR_OPTION = %X'200';
literal KA0C05_TLMEM$M_TLMCR_BDC = %X'10000000';
literal KA0C05_TLMEM$M_TLMCR_BREN = %X'20000000';
literal KA0C05_TLMEM$M_TLMCR_BDIS = %X'40000000';
literal KA0C05_TLMEM$M_TLMCR_BAT = %X'80000000';
literal KA0C05_TLMEM$M_TLSTER_FSTR = %X'7';
literal KA0C05_TLMEM$M_TLSTER_STE0 = %X'10';
literal KA0C05_TLMEM$M_TLSTER_STE1 = %X'20';
literal KA0C05_TLMEM$M_TLSTER_STE2 = %X'40';
literal KA0C05_TLMEM$M_TLSTER_STE3 = %X'80';
literal KA0C05_TLMEM$M_TLMER_FSTR = %X'7';
literal KA0C05_TLMEM$M_TLMDRA_AMEN = %X'1';
literal KA0C05_TLMEM$M_TLMDRA_FRAPE = %X'2';
literal KA0C05_TLMEM$M_TLMDRA_FCAPE = %X'4';
literal KA0C05_TLMEM$M_TLMDRA_MMPS = %X'8';
literal KA0C05_TLMEM$M_TLMDRA_EXST = %X'10';
literal KA0C05_TLMEM$M_TLMDRA_FRUN = %X'20';
literal KA0C05_TLMEM$M_TLMDRA_POEM = %X'40';
literal KA0C05_TLMEM$M_TLMDRA_POEMC = %X'80';
literal KA0C05_TLMEM$M_TLMDRA_DEDA = %X'100';
literal KA0C05_TLMEM$M_TLMDRA_RFR = %X'30000000';
literal KA0C05_TLMEM$M_TLMDRA_BRFSH = %X'40000000';
literal KA0C05_TLMEM$M_TLMDRA_DRFSH = %X'80000000';
literal KA0C05_TLMEM$M_TLMDRB_MADR = %X'FFFFFFFF';
literal KA0C05_TLMEM$M_TLSTDERE_0_STE = %X'FFFF';
literal KA0C05_TLMEM$M_TLSTDERE_0_VRC = %X'70000';
literal KA0C05_TLMEM$M_TLDDR0_LOE = %X'1';
literal KA0C05_TLMEM$M_TLDDR0_CDER = %X'2';
literal KA0C05_TLMEM$M_TLDDR0_ICFR = %X'4';
literal KA0C05_TLMEM$M_TLDDR0_PAT = %X'8';
literal KA0C05_TLMEM$M_TLDDR0_CFLP = %X'70';
literal KA0C05_TLMEM$M_TLDDR0_DFLP = %X'3F00';
literal KA0C05_TLMEM$M_TLDDR0_EFLPC = %X'4000';
literal KA0C05_TLMEM$M_TLDDR0_EFLPD = %X'8000';
literal KA0C05_TLMEM$M_TLDDR0_MARG = %X'80000000';
literal KA0C05_TLMEM$M_TLSTDERE_1_STE = %X'FFFF';
literal KA0C05_TLMEM$M_TLSTDERE_1_VRC = %X'70000';
literal KA0C05_TLMEM$M_TLDDR1_LOE = %X'1';
literal KA0C05_TLMEM$M_TLDDR1_CDER = %X'2';
literal KA0C05_TLMEM$M_TLDDR1_ICFR = %X'4';
literal KA0C05_TLMEM$M_TLDDR1_PAT = %X'8';
literal KA0C05_TLMEM$M_TLDDR1_CFLP = %X'70';
literal KA0C05_TLMEM$M_TLDDR1_DFLP = %X'3F00';
literal KA0C05_TLMEM$M_TLDDR1_EFLPC = %X'4000';
literal KA0C05_TLMEM$M_TLDDR1_EFLPD = %X'8000';
literal KA0C05_TLMEM$M_TLDDR1_MARG = %X'80000000';
literal KA0C05_TLMEM$M_TLSTDERE_2_STE = %X'FFFF';
literal KA0C05_TLMEM$M_TLSTDERE_2_VRC = %X'70000';
literal KA0C05_TLMEM$M_TLDDR2_LOE = %X'1';
literal KA0C05_TLMEM$M_TLDDR2_CDER = %X'2';
literal KA0C05_TLMEM$M_TLDDR2_ICFR = %X'4';
literal KA0C05_TLMEM$M_TLDDR2_PAT = %X'8';
literal KA0C05_TLMEM$M_TLDDR2_CFLP = %X'70';
literal KA0C05_TLMEM$M_TLDDR2_DFLP = %X'3F00';
literal KA0C05_TLMEM$M_TLDDR2_EFLPC = %X'4000';
literal KA0C05_TLMEM$M_TLDDR2_EFLPD = %X'8000';
literal KA0C05_TLMEM$M_TLDDR2_MARG = %X'80000000';
literal KA0C05_TLMEM$M_TLSTDERE_3_STE = %X'FFFF';
literal KA0C05_TLMEM$M_TLSTDERE_3_VRC = %X'70000';
literal KA0C05_TLMEM$M_TLDDR3_LOE = %X'1';
literal KA0C05_TLMEM$M_TLDDR3_CDER = %X'2';
literal KA0C05_TLMEM$M_TLDDR3_ICFR = %X'4';
literal KA0C05_TLMEM$M_TLDDR3_PAT = %X'8';
literal KA0C05_TLMEM$M_TLDDR3_CFLP = %X'70';
literal KA0C05_TLMEM$M_TLDDR3_DFLP = %X'3F00';
literal KA0C05_TLMEM$M_TLDDR3_EFLPC = %X'4000';
literal KA0C05_TLMEM$M_TLDDR3_EFLPD = %X'8000';
literal KA0C05_TLMEM$M_TLDDR3_MARG = %X'80000000';
literal KA0C05_TLMEM$S_KA0C05_TLMEM = 40960;
macro KA0C05_TLMEM$L_TLDEV = 0,0,32,0 %;
macro KA0C05_TLMEM$V_TLDEV_DTYPE = 0,0,16,0 %;
literal KA0C05_TLMEM$S_TLDEV_DTYPE = 16;
macro KA0C05_TLMEM$V_TLDEV_SWREV = 0,16,8,0 %;
literal KA0C05_TLMEM$S_TLDEV_SWREV = 8;
macro KA0C05_TLMEM$V_TLDEV_HWREV = 0,24,8,0 %;
literal KA0C05_TLMEM$S_TLDEV_HWREV = 8;
macro KA0C05_TLMEM$b_fill900 = 4,0,0,0 %;
literal KA0C05_TLMEM$s_fill900 = 60;
macro KA0C05_TLMEM$L_TLBER = 64,0,32,0 %;
macro KA0C05_TLMEM$V_TLBER_ATCE = 64,0,1,0 %;
macro KA0C05_TLMEM$V_TLBER_APE = 64,1,1,0 %;
macro KA0C05_TLMEM$V_TLBER_BBE = 64,2,1,0 %;
macro KA0C05_TLMEM$V_TLBER_LKTO = 64,3,1,0 %;
macro KA0C05_TLMEM$V_TLBER_NAE = 64,4,1,0 %;
macro KA0C05_TLMEM$V_TLBER_RTCE = 64,5,1,0 %;
macro KA0C05_TLMEM$V_TLBER_ACKTCE = 64,6,1,0 %;
macro KA0C05_TLMEM$V_TLBER_MMRE = 64,7,1,0 %;
macro KA0C05_TLMEM$V_TLBER_FNAE = 64,8,1,0 %;
macro KA0C05_TLMEM$V_TLBER_REQDE = 64,9,1,0 %;
macro KA0C05_TLMEM$V_TLBER_ATDE = 64,10,1,0 %;
macro KA0C05_TLMEM$V_TLBER_UDE = 64,16,1,0 %;
macro KA0C05_TLMEM$V_TLBER_CWDE = 64,17,1,0 %;
macro KA0C05_TLMEM$V_TLBER_CRDE = 64,18,1,0 %;
macro KA0C05_TLMEM$V_TLBER_DS0 = 64,20,1,0 %;
macro KA0C05_TLMEM$V_TLBER_DS1 = 64,21,1,0 %;
macro KA0C05_TLMEM$V_TLBER_DS2 = 64,22,1,0 %;
macro KA0C05_TLMEM$V_TLBER_DS3 = 64,23,1,0 %;
macro KA0C05_TLMEM$V_TLBER_DTDE = 64,24,1,0 %;
macro KA0C05_TLMEM$V_TLBER_FDTCE = 64,25,1,0 %;
macro KA0C05_TLMEM$V_TLBER_UACKE = 64,26,1,0 %;
macro KA0C05_TLMEM$V_TLBER_ABTCE = 64,27,1,0 %;
macro KA0C05_TLMEM$V_TLBER_DCTCE = 64,28,1,0 %;
macro KA0C05_TLMEM$V_TLBER_SEQE = 64,29,1,0 %;
macro KA0C05_TLMEM$V_TLBER_DSE = 64,30,1,0 %;
macro KA0C05_TLMEM$V_TLBER_DTO = 64,31,1,0 %;
macro KA0C05_TLMEM$b_fill910 = 68,0,0,0 %;
literal KA0C05_TLMEM$s_fill910 = 60;
macro KA0C05_TLMEM$L_TLCNR = 128,0,32,0 %;
macro KA0C05_TLMEM$V_TLCNR_CWDD = 128,0,1,0 %;
macro KA0C05_TLMEM$V_TLCNR_CRDD = 128,1,1,0 %;
macro KA0C05_TLMEM$V_TLCNR_LKTOD = 128,2,1,0 %;
macro KA0C05_TLMEM$V_TLCNR_DTOD = 128,3,1,0 %;
macro KA0C05_TLMEM$V_TLCNR_NODE_ID = 128,4,4,0 %;
literal KA0C05_TLMEM$S_TLCNR_NODE_ID = 4;
macro KA0C05_TLMEM$V_TLCNR_VCNT = 128,8,4,0 %;
literal KA0C05_TLMEM$S_TLCNR_VCNT = 4;
macro KA0C05_TLMEM$V_TLCNR_STF_A = 128,12,1,0 %;
macro KA0C05_TLMEM$V_TLCNR_STF_B = 128,13,1,0 %;
macro KA0C05_TLMEM$V_TLCNR_STF_C = 128,14,1,0 %;
macro KA0C05_TLMEM$V_TLCNR_STF_D = 128,15,1,0 %;
macro KA0C05_TLMEM$V_TLCNR_STF_E = 128,16,1,0 %;
macro KA0C05_TLMEM$V_TLCNR_STF_F = 128,17,1,0 %;
macro KA0C05_TLMEM$V_TLCNR_STF_G = 128,18,1,0 %;
macro KA0C05_TLMEM$V_TLCNR_STF_H = 128,19,1,0 %;
macro KA0C05_TLMEM$V_TLCNR_HALT_A = 128,20,1,0 %;
macro KA0C05_TLMEM$V_TLCNR_HALT_B = 128,21,1,0 %;
macro KA0C05_TLMEM$V_TLCNR_HALT_C = 128,22,1,0 %;
macro KA0C05_TLMEM$V_TLCNR_HALT_D = 128,23,1,0 %;
macro KA0C05_TLMEM$V_TLCNR_HALT_E = 128,24,1,0 %;
macro KA0C05_TLMEM$V_TLCNR_HALT_F = 128,25,1,0 %;
macro KA0C05_TLMEM$V_TLCNR_HALT_G = 128,26,1,0 %;
macro KA0C05_TLMEM$V_TLCNR_HALT_H = 128,27,1,0 %;
macro KA0C05_TLMEM$V_TLCNR_RSTSTAT = 128,28,1,0 %;
macro KA0C05_TLMEM$V_TLCNR_NRST = 128,30,1,0 %;
macro KA0C05_TLMEM$V_TLCNR_LOFE = 128,31,1,0 %;
macro KA0C05_TLMEM$b_fill920 = 132,0,0,0 %;
literal KA0C05_TLMEM$s_fill920 = 60;
macro KA0C05_TLMEM$L_TLVID = 192,0,32,0 %;
macro KA0C05_TLMEM$V_VID_A = 192,0,4,0 %;
literal KA0C05_TLMEM$S_VID_A = 4;
macro KA0C05_TLMEM$V_VID_B = 192,4,4,0 %;
literal KA0C05_TLMEM$S_VID_B = 4;
macro KA0C05_TLMEM$V_VID_C = 192,8,4,0 %;
literal KA0C05_TLMEM$S_VID_C = 4;
macro KA0C05_TLMEM$V_VID_D = 192,12,4,0 %;
literal KA0C05_TLMEM$S_VID_D = 4;
macro KA0C05_TLMEM$V_VID_E = 192,16,4,0 %;
literal KA0C05_TLMEM$S_VID_E = 4;
macro KA0C05_TLMEM$V_VID_F = 192,20,4,0 %;
literal KA0C05_TLMEM$S_VID_F = 4;
macro KA0C05_TLMEM$V_VID_G = 192,24,4,0 %;
literal KA0C05_TLMEM$S_VID_G = 4;
macro KA0C05_TLMEM$V_VID_H = 192,28,4,0 %;
literal KA0C05_TLMEM$S_VID_H = 4;
macro KA0C05_TLMEM$b_fill930 = 196,0,0,0 %;
literal KA0C05_TLMEM$s_fill930 = 1340;
macro KA0C05_TLMEM$L_TLFADR0 = 1536,0,32,0 %;
macro KA0C05_TLMEM$V_TLFADR0_FADR = 1536,3,29,0 %;
literal KA0C05_TLMEM$S_TLFADR0_FADR = 29;
macro KA0C05_TLMEM$b_fill940 = 1540,0,0,0 %;
literal KA0C05_TLMEM$s_fill940 = 60;
macro KA0C05_TLMEM$L_TLFADR1 = 1600,0,32,0 %;
macro KA0C05_TLMEM$V_TLFADR1_FADR = 1600,0,8,0 %;
literal KA0C05_TLMEM$S_TLFADR1_FADR = 8;
macro KA0C05_TLMEM$V_TLFADR1_FCMD = 1600,16,3,0 %;
literal KA0C05_TLMEM$S_TLFADR1_FCMD = 3;
macro KA0C05_TLMEM$V_TLFADR1_FBANK = 1600,20,4,0 %;
literal KA0C05_TLMEM$S_TLFADR1_FBANK = 4;
macro KA0C05_TLMEM$V_TLFADR1_ADRV = 1600,24,1,0 %;
macro KA0C05_TLMEM$V_TLFADR1_CMDV = 1600,25,1,0 %;
macro KA0C05_TLMEM$V_TLFADR1_BANKV = 1600,26,1,0 %;
macro KA0C05_TLMEM$b_fill950 = 1604,0,0,0 %;
literal KA0C05_TLMEM$s_fill950 = 60;
macro KA0C05_TLMEM$L_TLESR0 = 1664,0,32,0 %;
macro KA0C05_TLMEM$V_TLESR0_SYND0 = 1664,0,8,0 %;
literal KA0C05_TLMEM$S_TLESR0_SYND0 = 8;
macro KA0C05_TLMEM$V_TLESR0_SYND1 = 1664,8,8,0 %;
literal KA0C05_TLMEM$S_TLESR0_SYND1 = 8;
macro KA0C05_TLMEM$V_TLESR0_TDE = 1664,16,1,0 %;
macro KA0C05_TLMEM$V_TLESR0_TCE = 1664,17,1,0 %;
macro KA0C05_TLMEM$V_TLESR0_DVTCE = 1664,18,1,0 %;
macro KA0C05_TLMEM$V_TLESR0_UECC = 1664,19,1,0 %;
macro KA0C05_TLMEM$V_TLESR0_CWECC = 1664,20,1,0 %;
macro KA0C05_TLMEM$V_TLESR0_CRECC = 1664,21,1,0 %;
macro KA0C05_TLMEM$V_TLESR0_LOFSYN = 1664,31,1,0 %;
macro KA0C05_TLMEM$b_fill960 = 1668,0,0,0 %;
literal KA0C05_TLMEM$s_fill960 = 60;
macro KA0C05_TLMEM$L_TLESR1 = 1728,0,32,0 %;
macro KA0C05_TLMEM$V_TLESR1_SYND0 = 1728,0,8,0 %;
literal KA0C05_TLMEM$S_TLESR1_SYND0 = 8;
macro KA0C05_TLMEM$V_TLESR1_SYND1 = 1728,8,8,0 %;
literal KA0C05_TLMEM$S_TLESR1_SYND1 = 8;
macro KA0C05_TLMEM$V_TLESR1_TDE = 1728,16,1,0 %;
macro KA0C05_TLMEM$V_TLESR1_TCE = 1728,17,1,0 %;
macro KA0C05_TLMEM$V_TLESR1_DVTCE = 1728,18,1,0 %;
macro KA0C05_TLMEM$V_TLESR1_UECC = 1728,19,1,0 %;
macro KA0C05_TLMEM$V_TLESR1_CWECC = 1728,20,1,0 %;
macro KA0C05_TLMEM$V_TLESR1_CRECC = 1728,21,1,0 %;
macro KA0C05_TLMEM$V_TLESR1_LOFSYN = 1728,31,1,0 %;
macro KA0C05_TLMEM$b_fill970 = 1732,0,0,0 %;
literal KA0C05_TLMEM$s_fill970 = 60;
macro KA0C05_TLMEM$L_TLESR2 = 1792,0,32,0 %;
macro KA0C05_TLMEM$V_TLESR2_SYND0 = 1792,0,8,0 %;
literal KA0C05_TLMEM$S_TLESR2_SYND0 = 8;
macro KA0C05_TLMEM$V_TLESR2_SYND1 = 1792,8,8,0 %;
literal KA0C05_TLMEM$S_TLESR2_SYND1 = 8;
macro KA0C05_TLMEM$V_TLESR2_TDE = 1792,16,1,0 %;
macro KA0C05_TLMEM$V_TLESR2_TCE = 1792,17,1,0 %;
macro KA0C05_TLMEM$V_TLESR2_DVTCE = 1792,18,1,0 %;
macro KA0C05_TLMEM$V_TLESR2_UECC = 1792,19,1,0 %;
macro KA0C05_TLMEM$V_TLESR2_CWECC = 1792,20,1,0 %;
macro KA0C05_TLMEM$V_TLESR2_CRECC = 1792,21,1,0 %;
macro KA0C05_TLMEM$V_TLESR2_LOFSYN = 1792,31,1,0 %;
macro KA0C05_TLMEM$b_fill980 = 1796,0,0,0 %;
literal KA0C05_TLMEM$s_fill980 = 60;
macro KA0C05_TLMEM$L_TLESR3 = 1856,0,32,0 %;
macro KA0C05_TLMEM$V_TLESR3_SYND0 = 1856,0,8,0 %;
literal KA0C05_TLMEM$S_TLESR3_SYND0 = 8;
macro KA0C05_TLMEM$V_TLESR3_SYND1 = 1856,8,8,0 %;
literal KA0C05_TLMEM$S_TLESR3_SYND1 = 8;
macro KA0C05_TLMEM$V_TLESR3_TDE = 1856,16,1,0 %;
macro KA0C05_TLMEM$V_TLESR3_TCE = 1856,17,1,0 %;
macro KA0C05_TLMEM$V_TLESR3_DVTCE = 1856,18,1,0 %;
macro KA0C05_TLMEM$V_TLESR3_UECC = 1856,19,1,0 %;
macro KA0C05_TLMEM$V_TLESR3_CWECC = 1856,20,1,0 %;
macro KA0C05_TLMEM$V_TLESR3_CRECC = 1856,21,1,0 %;
macro KA0C05_TLMEM$V_TLESR3_LOFSYN = 1856,31,1,0 %;
macro KA0C05_TLMEM$b_fill990 = 1860,0,0,0 %;
literal KA0C05_TLMEM$s_fill990 = 4284;
macro KA0C05_TLMEM$L_TLSECR = 6144,0,32,0 %;
macro KA0C05_TLMEM$V_TLSECR_RCV_SDAT = 6144,0,1,0 %;
macro KA0C05_TLMEM$V_TLSECR_XMT_SDAT = 6144,1,1,0 %;
macro KA0C05_TLMEM$V_TLSECR_SCLK = 6144,2,1,0 %;
macro KA0C05_TLMEM$b_f1000 = 6148,0,0,0 %;
literal KA0C05_TLMEM$s_f1000 = 60;
macro KA0C05_TLMEM$L_TLMIR = 6208,0,32,0 %;
macro KA0C05_TLMEM$V_TLMIR_INT = 6208,0,3,0 %;
literal KA0C05_TLMEM$S_TLMIR_INT = 3;
macro KA0C05_TLMEM$V_TLMIR_V = 6208,31,1,0 %;
macro KA0C05_TLMEM$b_f1010 = 6212,0,0,0 %;
literal KA0C05_TLMEM$s_f1010 = 60;
macro KA0C05_TLMEM$L_TLMCR = 6272,0,32,0 %;
macro KA0C05_TLMEM$V_TLMCR_DTYP = 6272,0,1,0 %;
macro KA0C05_TLMEM$V_TLMCR_STRN = 6272,2,2,0 %;
literal KA0C05_TLMEM$S_TLMCR_STRN = 2;
macro KA0C05_TLMEM$V_TLMCR_DTR = 6272,4,2,0 %;
literal KA0C05_TLMEM$S_TLMCR_DTR = 2;
macro KA0C05_TLMEM$V_TLMCR_DEFLT = 6272,6,1,0 %;
macro KA0C05_TLMEM$V_TLMCR_SHRD = 6272,8,1,0 %;
macro KA0C05_TLMEM$V_TLMCR_OPTION = 6272,9,1,0 %;
macro KA0C05_TLMEM$V_TLMCR_BDC = 6272,28,1,0 %;
macro KA0C05_TLMEM$V_TLMCR_BREN = 6272,29,1,0 %;
macro KA0C05_TLMEM$V_TLMCR_BDIS = 6272,30,1,0 %;
macro KA0C05_TLMEM$V_TLMCR_BAT = 6272,31,1,0 %;
macro KA0C05_TLMEM$b_f1020 = 6276,0,0,0 %;
literal KA0C05_TLMEM$s_f1020 = 60;
macro KA0C05_TLMEM$L_TLSTAIR = 6336,0,32,0 %;
macro KA0C05_TLMEM$b_f1030 = 6340,0,0,0 %;
literal KA0C05_TLMEM$s_f1030 = 60;
macro KA0C05_TLMEM$L_TLSTER = 6400,0,32,0 %;
macro KA0C05_TLMEM$V_TLSTER_FSTR = 6400,0,3,0 %;
literal KA0C05_TLMEM$S_TLSTER_FSTR = 3;
macro KA0C05_TLMEM$V_TLSTER_STE0 = 6400,4,1,0 %;
macro KA0C05_TLMEM$V_TLSTER_STE1 = 6400,5,1,0 %;
macro KA0C05_TLMEM$V_TLSTER_STE2 = 6400,6,1,0 %;
macro KA0C05_TLMEM$V_TLSTER_STE3 = 6400,7,1,0 %;
macro KA0C05_TLMEM$b_f1040 = 6404,0,0,0 %;
literal KA0C05_TLMEM$s_f1040 = 60;
macro KA0C05_TLMEM$L_TLMER = 6464,0,32,0 %;
macro KA0C05_TLMEM$V_TLMER_FSTR = 6464,0,3,0 %;
literal KA0C05_TLMEM$S_TLMER_FSTR = 3;
macro KA0C05_TLMEM$b_f1050 = 6468,0,0,0 %;
literal KA0C05_TLMEM$s_f1050 = 60;
macro KA0C05_TLMEM$L_TLMDRA = 6528,0,32,0 %;
macro KA0C05_TLMEM$V_TLMDRA_AMEN = 6528,0,1,0 %;
macro KA0C05_TLMEM$V_TLMDRA_FRAPE = 6528,1,1,0 %;
macro KA0C05_TLMEM$V_TLMDRA_FCAPE = 6528,2,1,0 %;
macro KA0C05_TLMEM$V_TLMDRA_MMPS = 6528,3,1,0 %;
macro KA0C05_TLMEM$V_TLMDRA_EXST = 6528,4,1,0 %;
macro KA0C05_TLMEM$V_TLMDRA_FRUN = 6528,5,1,0 %;
macro KA0C05_TLMEM$V_TLMDRA_POEM = 6528,6,1,0 %;
macro KA0C05_TLMEM$V_TLMDRA_POEMC = 6528,7,1,0 %;
macro KA0C05_TLMEM$V_TLMDRA_DEDA = 6528,8,1,0 %;
macro KA0C05_TLMEM$V_TLMDRA_RFR = 6528,28,2,0 %;
literal KA0C05_TLMEM$S_TLMDRA_RFR = 2;
macro KA0C05_TLMEM$V_TLMDRA_BRFSH = 6528,30,1,0 %;
macro KA0C05_TLMEM$V_TLMDRA_DRFSH = 6528,31,1,0 %;
macro KA0C05_TLMEM$b_f1060 = 6532,0,0,0 %;
literal KA0C05_TLMEM$s_f1060 = 60;
macro KA0C05_TLMEM$L_TLMDRB = 6592,0,32,0 %;
macro KA0C05_TLMEM$V_TLMDRB_MADR = 6592,0,32,0 %;
literal KA0C05_TLMEM$S_TLMDRB_MADR = 32;
macro KA0C05_TLMEM$b_f1070 = 6596,0,0,0 %;
literal KA0C05_TLMEM$s_f1070 = 1596;
macro KA0C05_TLMEM$L_TLSTDERA_0 = 8192,0,32,0 %;
macro KA0C05_TLMEM$b_f1080 = 8196,0,0,0 %;
literal KA0C05_TLMEM$s_f1080 = 60;
macro KA0C05_TLMEM$L_TLSTDERB_0 = 8256,0,32,0 %;
macro KA0C05_TLMEM$b_f1090 = 8260,0,0,0 %;
literal KA0C05_TLMEM$s_f1090 = 60;
macro KA0C05_TLMEM$L_TLSTDERC_0 = 8320,0,32,0 %;
macro KA0C05_TLMEM$b_f1100 = 8324,0,0,0 %;
literal KA0C05_TLMEM$s_f1100 = 60;
macro KA0C05_TLMEM$L_TLSTDERD_0 = 8384,0,32,0 %;
macro KA0C05_TLMEM$b_f1110 = 8388,0,0,0 %;
literal KA0C05_TLMEM$s_f1110 = 60;
macro KA0C05_TLMEM$L_TLSTDERE_0 = 8448,0,32,0 %;
macro KA0C05_TLMEM$V_TLSTDERE_0_STE = 8448,0,16,0 %;
literal KA0C05_TLMEM$S_TLSTDERE_0_STE = 16;
macro KA0C05_TLMEM$V_TLSTDERE_0_VRC = 8448,16,3,0 %;
literal KA0C05_TLMEM$S_TLSTDERE_0_VRC = 3;
macro KA0C05_TLMEM$b_f1120 = 8452,0,0,0 %;
literal KA0C05_TLMEM$s_f1120 = 60;
macro KA0C05_TLMEM$L_TLDDR0 = 8512,0,32,0 %;
macro KA0C05_TLMEM$V_TLDDR0_LOE = 8512,0,1,0 %;
macro KA0C05_TLMEM$V_TLDDR0_CDER = 8512,1,1,0 %;
macro KA0C05_TLMEM$V_TLDDR0_ICFR = 8512,2,1,0 %;
macro KA0C05_TLMEM$V_TLDDR0_PAT = 8512,3,1,0 %;
macro KA0C05_TLMEM$V_TLDDR0_CFLP = 8512,4,3,0 %;
literal KA0C05_TLMEM$S_TLDDR0_CFLP = 3;
macro KA0C05_TLMEM$V_TLDDR0_DFLP = 8512,8,6,0 %;
literal KA0C05_TLMEM$S_TLDDR0_DFLP = 6;
macro KA0C05_TLMEM$V_TLDDR0_EFLPC = 8512,14,1,0 %;
macro KA0C05_TLMEM$V_TLDDR0_EFLPD = 8512,15,1,0 %;
macro KA0C05_TLMEM$V_TLDDR0_MARG = 8512,31,1,0 %;
macro KA0C05_TLMEM$b_f1130 = 8516,0,0,0 %;
literal KA0C05_TLMEM$s_f1130 = 7868;
macro KA0C05_TLMEM$L_TLSTDERA_1 = 16384,0,32,0 %;
macro KA0C05_TLMEM$b_f1140 = 16388,0,0,0 %;
literal KA0C05_TLMEM$s_f1140 = 60;
macro KA0C05_TLMEM$L_TLSTDERB_1 = 16448,0,32,0 %;
macro KA0C05_TLMEM$b_f1150 = 16452,0,0,0 %;
literal KA0C05_TLMEM$s_f1150 = 60;
macro KA0C05_TLMEM$L_TLSTDERC_1 = 16512,0,32,0 %;
macro KA0C05_TLMEM$b_f1160 = 16516,0,0,0 %;
literal KA0C05_TLMEM$s_f1160 = 60;
macro KA0C05_TLMEM$L_TLSTDERD_1 = 16576,0,32,0 %;
macro KA0C05_TLMEM$b_f1170 = 16580,0,0,0 %;
literal KA0C05_TLMEM$s_f1170 = 60;
macro KA0C05_TLMEM$L_TLSTDERE_1 = 16640,0,32,0 %;
macro KA0C05_TLMEM$V_TLSTDERE_1_STE = 16640,0,16,0 %;
literal KA0C05_TLMEM$S_TLSTDERE_1_STE = 16;
macro KA0C05_TLMEM$V_TLSTDERE_1_VRC = 16640,16,3,0 %;
literal KA0C05_TLMEM$S_TLSTDERE_1_VRC = 3;
macro KA0C05_TLMEM$b_f1180 = 16644,0,0,0 %;
literal KA0C05_TLMEM$s_f1180 = 60;
macro KA0C05_TLMEM$L_TLDDR1 = 16704,0,32,0 %;
macro KA0C05_TLMEM$V_TLDDR1_LOE = 16704,0,1,0 %;
macro KA0C05_TLMEM$V_TLDDR1_CDER = 16704,1,1,0 %;
macro KA0C05_TLMEM$V_TLDDR1_ICFR = 16704,2,1,0 %;
macro KA0C05_TLMEM$V_TLDDR1_PAT = 16704,3,1,0 %;
macro KA0C05_TLMEM$V_TLDDR1_CFLP = 16704,4,3,0 %;
literal KA0C05_TLMEM$S_TLDDR1_CFLP = 3;
macro KA0C05_TLMEM$V_TLDDR1_DFLP = 16704,8,6,0 %;
literal KA0C05_TLMEM$S_TLDDR1_DFLP = 6;
macro KA0C05_TLMEM$V_TLDDR1_EFLPC = 16704,14,1,0 %;
macro KA0C05_TLMEM$V_TLDDR1_EFLPD = 16704,15,1,0 %;
macro KA0C05_TLMEM$V_TLDDR1_MARG = 16704,31,1,0 %;
macro KA0C05_TLMEM$b_f1190 = 16708,0,0,0 %;
literal KA0C05_TLMEM$s_f1190 = 7868;
macro KA0C05_TLMEM$L_TLSTDERA_2 = 24576,0,32,0 %;
macro KA0C05_TLMEM$b_f1200 = 24580,0,0,0 %;
literal KA0C05_TLMEM$s_f1200 = 60;
macro KA0C05_TLMEM$L_TLSTDERB_2 = 24640,0,32,0 %;
macro KA0C05_TLMEM$b_f1210 = 24644,0,0,0 %;
literal KA0C05_TLMEM$s_f1210 = 60;
macro KA0C05_TLMEM$L_TLSTDERC_2 = 24704,0,32,0 %;
macro KA0C05_TLMEM$b_f1220 = 24708,0,0,0 %;
literal KA0C05_TLMEM$s_f1220 = 60;
macro KA0C05_TLMEM$L_TLSTDERD_2 = 24768,0,32,0 %;
macro KA0C05_TLMEM$b_f1230 = 24772,0,0,0 %;
literal KA0C05_TLMEM$s_f1230 = 60;
macro KA0C05_TLMEM$L_TLSTDERE_2 = 24832,0,32,0 %;
macro KA0C05_TLMEM$V_TLSTDERE_2_STE = 24832,0,16,0 %;
literal KA0C05_TLMEM$S_TLSTDERE_2_STE = 16;
macro KA0C05_TLMEM$V_TLSTDERE_2_VRC = 24832,16,3,0 %;
literal KA0C05_TLMEM$S_TLSTDERE_2_VRC = 3;
macro KA0C05_TLMEM$b_f1240 = 24836,0,0,0 %;
literal KA0C05_TLMEM$s_f1240 = 60;
macro KA0C05_TLMEM$L_TLDDR2 = 24896,0,32,0 %;
macro KA0C05_TLMEM$V_TLDDR2_LOE = 24896,0,1,0 %;
macro KA0C05_TLMEM$V_TLDDR2_CDER = 24896,1,1,0 %;
macro KA0C05_TLMEM$V_TLDDR2_ICFR = 24896,2,1,0 %;
macro KA0C05_TLMEM$V_TLDDR2_PAT = 24896,3,1,0 %;
macro KA0C05_TLMEM$V_TLDDR2_CFLP = 24896,4,3,0 %;
literal KA0C05_TLMEM$S_TLDDR2_CFLP = 3;
macro KA0C05_TLMEM$V_TLDDR2_DFLP = 24896,8,6,0 %;
literal KA0C05_TLMEM$S_TLDDR2_DFLP = 6;
macro KA0C05_TLMEM$V_TLDDR2_EFLPC = 24896,14,1,0 %;
macro KA0C05_TLMEM$V_TLDDR2_EFLPD = 24896,15,1,0 %;
macro KA0C05_TLMEM$V_TLDDR2_MARG = 24896,31,1,0 %;
macro KA0C05_TLMEM$b_f1250 = 24900,0,0,0 %;
literal KA0C05_TLMEM$s_f1250 = 7868;
macro KA0C05_TLMEM$L_TLSTDERA_3 = 32768,0,32,0 %;
macro KA0C05_TLMEM$b_f1260 = 32772,0,0,0 %;
literal KA0C05_TLMEM$s_f1260 = 60;
macro KA0C05_TLMEM$L_TLSTDERB_3 = 32832,0,32,0 %;
macro KA0C05_TLMEM$b_f1270 = 32836,0,0,0 %;
literal KA0C05_TLMEM$s_f1270 = 60;
macro KA0C05_TLMEM$L_TLSTDERC_3 = 32896,0,32,0 %;
macro KA0C05_TLMEM$b_f1280 = 32900,0,0,0 %;
literal KA0C05_TLMEM$s_f1280 = 60;
macro KA0C05_TLMEM$L_TLSTDERD_3 = 32960,0,32,0 %;
macro KA0C05_TLMEM$b_f1290 = 32964,0,0,0 %;
literal KA0C05_TLMEM$s_f1290 = 60;
macro KA0C05_TLMEM$L_TLSTDERE_3 = 33024,0,32,0 %;
macro KA0C05_TLMEM$V_TLSTDERE_3_STE = 33024,0,16,0 %;
literal KA0C05_TLMEM$S_TLSTDERE_3_STE = 16;
macro KA0C05_TLMEM$V_TLSTDERE_3_VRC = 33024,16,3,0 %;
literal KA0C05_TLMEM$S_TLSTDERE_3_VRC = 3;
macro KA0C05_TLMEM$b_f1300 = 33028,0,0,0 %;
literal KA0C05_TLMEM$s_f1300 = 60;
macro KA0C05_TLMEM$L_TLDDR3 = 33088,0,32,0 %;
macro KA0C05_TLMEM$V_TLDDR3_LOE = 33088,0,1,0 %;
macro KA0C05_TLMEM$V_TLDDR3_CDER = 33088,1,1,0 %;
macro KA0C05_TLMEM$V_TLDDR3_ICFR = 33088,2,1,0 %;
macro KA0C05_TLMEM$V_TLDDR3_PAT = 33088,3,1,0 %;
macro KA0C05_TLMEM$V_TLDDR3_CFLP = 33088,4,3,0 %;
literal KA0C05_TLMEM$S_TLDDR3_CFLP = 3;
macro KA0C05_TLMEM$V_TLDDR3_DFLP = 33088,8,6,0 %;
literal KA0C05_TLMEM$S_TLDDR3_DFLP = 6;
macro KA0C05_TLMEM$V_TLDDR3_EFLPC = 33088,14,1,0 %;
macro KA0C05_TLMEM$V_TLDDR3_EFLPD = 33088,15,1,0 %;
macro KA0C05_TLMEM$V_TLDDR3_MARG = 33088,31,1,0 %;
macro KA0C05_TLMEM$b_f1310 = 33092,0,0,0 %;
literal KA0C05_TLMEM$s_f1310 = 7868;
literal KA0C05_TIOP$M_TLDEV_DTYPE = %X'FFFF';
literal KA0C05_TIOP$M_TLDEV_SWREV = %X'FF0000';
literal KA0C05_TIOP$M_TLDEV_HWREV = %X'FF000000';
literal KA0C05_TIOP$M_TLBER_ATCE = %X'1';
literal KA0C05_TIOP$M_TLBER_APE = %X'2';
literal KA0C05_TIOP$M_TLBER_BBE = %X'4';
literal KA0C05_TIOP$M_TLBER_LKTO = %X'8';
literal KA0C05_TIOP$M_TLBER_NAE = %X'10';
literal KA0C05_TIOP$M_TLBER_RTCE = %X'20';
literal KA0C05_TIOP$M_TLBER_ACKTCE = %X'40';
literal KA0C05_TIOP$M_TLBER_MMRE = %X'80';
literal KA0C05_TIOP$M_TLBER_FNAE = %X'100';
literal KA0C05_TIOP$M_TLBER_REQDE = %X'200';
literal KA0C05_TIOP$M_TLBER_ATDE = %X'400';
literal KA0C05_TIOP$M_TLBER_UDE = %X'10000';
literal KA0C05_TIOP$M_TLBER_CWDE = %X'20000';
literal KA0C05_TIOP$M_TLBER_CRDE = %X'40000';
literal KA0C05_TIOP$M_TLBER_DS0 = %X'100000';
literal KA0C05_TIOP$M_TLBER_DS1 = %X'200000';
literal KA0C05_TIOP$M_TLBER_DS2 = %X'400000';
literal KA0C05_TIOP$M_TLBER_DS3 = %X'800000';
literal KA0C05_TIOP$M_TLBER_DTDE = %X'1000000';
literal KA0C05_TIOP$M_TLBER_FDTCE = %X'2000000';
literal KA0C05_TIOP$M_TLBER_UACKE = %X'4000000';
literal KA0C05_TIOP$M_TLBER_ABTCE = %X'8000000';
literal KA0C05_TIOP$M_TLBER_DCTCE = %X'10000000';
literal KA0C05_TIOP$M_TLBER_SEQE = %X'20000000';
literal KA0C05_TIOP$M_TLBER_DSE = %X'40000000';
literal KA0C05_TIOP$M_TLBER_DTO = %X'80000000';
literal KA0C05_TIOP$M_TLCNR_CWDD = %X'1';
literal KA0C05_TIOP$M_TLCNR_CRDD = %X'2';
literal KA0C05_TIOP$M_TLCNR_LKTOD = %X'4';
literal KA0C05_TIOP$M_TLCNR_DTOD = %X'8';
literal KA0C05_TIOP$M_TLCNR_NODE_ID = %X'F0';
literal KA0C05_TIOP$M_TLCNR_VCNT = %X'F00';
literal KA0C05_TIOP$M_TLCNR_STF_A = %X'1000';
literal KA0C05_TIOP$M_TLCNR_STF_B = %X'2000';
literal KA0C05_TIOP$M_TLCNR_STF_C = %X'4000';
literal KA0C05_TIOP$M_TLCNR_STF_D = %X'8000';
literal KA0C05_TIOP$M_TLCNR_STF_E = %X'10000';
literal KA0C05_TIOP$M_TLCNR_STF_F = %X'20000';
literal KA0C05_TIOP$M_TLCNR_STF_G = %X'40000';
literal KA0C05_TIOP$M_TLCNR_STF_H = %X'80000';
literal KA0C05_TIOP$M_TLCNR_HALT_A = %X'100000';
literal KA0C05_TIOP$M_TLCNR_HALT_B = %X'200000';
literal KA0C05_TIOP$M_TLCNR_HALT_C = %X'400000';
literal KA0C05_TIOP$M_TLCNR_HALT_D = %X'800000';
literal KA0C05_TIOP$M_TLCNR_HALT_E = %X'1000000';
literal KA0C05_TIOP$M_TLCNR_HALT_F = %X'2000000';
literal KA0C05_TIOP$M_TLCNR_HALT_G = %X'4000000';
literal KA0C05_TIOP$M_TLCNR_HALT_H = %X'8000000';
literal KA0C05_TIOP$M_TLCNR_RSTSTAT = %X'10000000';
literal KA0C05_TIOP$M_TLCNR_NRST = %X'40000000';
literal KA0C05_TIOP$M_TLCNR_LOFE = %X'80000000';
literal KA0C05_TIOP$M_TLMMR0_INTMASK = %X'3';
literal KA0C05_TIOP$M_TLMMR0_ADRMASK = %X'F0';
literal KA0C05_TIOP$M_TLMMR0_INTLV = %X'700';
literal KA0C05_TIOP$M_TLMMR0_SBANK = %X'800';
literal KA0C05_TIOP$M_TLMMR0_ADDRESS = %X'3FFF000';
literal KA0C05_TIOP$M_TLMMR0_VALID = %X'80000000';
literal KA0C05_TIOP$M_TLMMR1_INTMASK = %X'3';
literal KA0C05_TIOP$M_TLMMR1_ADRMASK = %X'F0';
literal KA0C05_TIOP$M_TLMMR1_INTLV = %X'700';
literal KA0C05_TIOP$M_TLMMR1_SBANK = %X'800';
literal KA0C05_TIOP$M_TLMMR1_ADDRESS = %X'3FFF000';
literal KA0C05_TIOP$M_TLMMR1_VALID = %X'80000000';
literal KA0C05_TIOP$M_TLMMR2_INTMASK = %X'3';
literal KA0C05_TIOP$M_TLMMR2_ADRMASK = %X'F0';
literal KA0C05_TIOP$M_TLMMR2_INTLV = %X'700';
literal KA0C05_TIOP$M_TLMMR2_SBANK = %X'800';
literal KA0C05_TIOP$M_TLMMR2_ADDRESS = %X'3FFF000';
literal KA0C05_TIOP$M_TLMMR2_VALID = %X'80000000';
literal KA0C05_TIOP$M_TLMMR3_INTMASK = %X'3';
literal KA0C05_TIOP$M_TLMMR3_ADRMASK = %X'F0';
literal KA0C05_TIOP$M_TLMMR3_INTLV = %X'700';
literal KA0C05_TIOP$M_TLMMR3_SBANK = %X'800';
literal KA0C05_TIOP$M_TLMMR3_ADDRESS = %X'3FFF000';
literal KA0C05_TIOP$M_TLMMR3_VALID = %X'80000000';
literal KA0C05_TIOP$M_TLMMR4_INTMASK = %X'3';
literal KA0C05_TIOP$M_TLMMR4_ADRMASK = %X'F0';
literal KA0C05_TIOP$M_TLMMR4_INTLV = %X'700';
literal KA0C05_TIOP$M_TLMMR4_SBANK = %X'800';
literal KA0C05_TIOP$M_TLMMR4_ADDRESS = %X'3FFF000';
literal KA0C05_TIOP$M_TLMMR4_VALID = %X'80000000';
literal KA0C05_TIOP$M_TLMMR5_INTMASK = %X'3';
literal KA0C05_TIOP$M_TLMMR5_ADRMASK = %X'F0';
literal KA0C05_TIOP$M_TLMMR5_INTLV = %X'700';
literal KA0C05_TIOP$M_TLMMR5_SBANK = %X'800';
literal KA0C05_TIOP$M_TLMMR5_ADDRESS = %X'3FFF000';
literal KA0C05_TIOP$M_TLMMR5_VALID = %X'80000000';
literal KA0C05_TIOP$M_TLMMR6_INTMASK = %X'3';
literal KA0C05_TIOP$M_TLMMR6_ADRMASK = %X'F0';
literal KA0C05_TIOP$M_TLMMR6_INTLV = %X'700';
literal KA0C05_TIOP$M_TLMMR6_SBANK = %X'800';
literal KA0C05_TIOP$M_TLMMR6_ADDRESS = %X'3FFF000';
literal KA0C05_TIOP$M_TLMMR6_VALID = %X'80000000';
literal KA0C05_TIOP$M_TLMMR7_INTMASK = %X'3';
literal KA0C05_TIOP$M_TLMMR7_ADRMASK = %X'F0';
literal KA0C05_TIOP$M_TLMMR7_INTLV = %X'700';
literal KA0C05_TIOP$M_TLMMR7_SBANK = %X'800';
literal KA0C05_TIOP$M_TLMMR7_ADDRESS = %X'3FFF000';
literal KA0C05_TIOP$M_TLMMR7_VALID = %X'80000000';
literal KA0C05_TIOP$M_TLFADR0_FADR = %X'FFFFFFF8';
literal KA0C05_TIOP$M_TLFADR1_FADR = %X'FF';
literal KA0C05_TIOP$M_TLFADR1_FCMD = %X'70000';
literal KA0C05_TIOP$M_TLFADR1_FBANK = %X'F00000';
literal KA0C05_TIOP$M_TLFADR1_ADRV = %X'1000000';
literal KA0C05_TIOP$M_TLFADR1_CMDV = %X'2000000';
literal KA0C05_TIOP$M_TLFADR1_BANKV = %X'4000000';
literal KA0C05_TIOP$M_TLESR0_SYND0 = %X'FF';
literal KA0C05_TIOP$M_TLESR0_SYND1 = %X'FF00';
literal KA0C05_TIOP$M_TLESR0_TDE = %X'10000';
literal KA0C05_TIOP$M_TLESR0_TCE = %X'20000';
literal KA0C05_TIOP$M_TLESR0_DVTCE = %X'40000';
literal KA0C05_TIOP$M_TLESR0_UECC = %X'80000';
literal KA0C05_TIOP$M_TLESR0_CWECC = %X'100000';
literal KA0C05_TIOP$M_TLESR0_CRECC = %X'200000';
literal KA0C05_TIOP$M_TLESR0_LOFSYN = %X'80000000';
literal KA0C05_TIOP$M_TLESR1_SYND0 = %X'FF';
literal KA0C05_TIOP$M_TLESR1_SYND1 = %X'FF00';
literal KA0C05_TIOP$M_TLESR1_TDE = %X'10000';
literal KA0C05_TIOP$M_TLESR1_TCE = %X'20000';
literal KA0C05_TIOP$M_TLESR1_DVTCE = %X'40000';
literal KA0C05_TIOP$M_TLESR1_UECC = %X'80000';
literal KA0C05_TIOP$M_TLESR1_CWECC = %X'100000';
literal KA0C05_TIOP$M_TLESR1_CRECC = %X'200000';
literal KA0C05_TIOP$M_TLESR1_LOFSYN = %X'80000000';
literal KA0C05_TIOP$M_TLESR2_SYND0 = %X'FF';
literal KA0C05_TIOP$M_TLESR2_SYND1 = %X'FF00';
literal KA0C05_TIOP$M_TLESR2_TDE = %X'10000';
literal KA0C05_TIOP$M_TLESR2_TCE = %X'20000';
literal KA0C05_TIOP$M_TLESR2_DVTCE = %X'40000';
literal KA0C05_TIOP$M_TLESR2_UECC = %X'80000';
literal KA0C05_TIOP$M_TLESR2_CWECC = %X'100000';
literal KA0C05_TIOP$M_TLESR2_CRECC = %X'200000';
literal KA0C05_TIOP$M_TLESR2_LOFSYN = %X'80000000';
literal KA0C05_TIOP$M_TLESR3_SYND0 = %X'FF';
literal KA0C05_TIOP$M_TLESR3_SYND1 = %X'FF00';
literal KA0C05_TIOP$M_TLESR3_TDE = %X'10000';
literal KA0C05_TIOP$M_TLESR3_TCE = %X'20000';
literal KA0C05_TIOP$M_TLESR3_DVTCE = %X'40000';
literal KA0C05_TIOP$M_TLESR3_UECC = %X'80000';
literal KA0C05_TIOP$M_TLESR3_CWECC = %X'100000';
literal KA0C05_TIOP$M_TLESR3_CRECC = %X'200000';
literal KA0C05_TIOP$M_TLESR3_LOFSYN = %X'80000000';
literal KA0C05_TIOP$M_TLILID0_IDENT = %X'FFFF';
literal KA0C05_TIOP$M_TLILID1_IDENT = %X'FFFF';
literal KA0C05_TIOP$M_TLILID2_IDENT = %X'FFFF';
literal KA0C05_TIOP$M_TLILID3_IDENT = %X'FFFF';
literal KA0C05_TIOP$M_TLCPUMASK_MASK = %X'FFFF';
literal KA0C05_TIOP$M_TLRMR0A_MASK = %X'F';
literal KA0C05_TIOP$M_TLRMR0A_ILV_EN = %X'10';
literal KA0C05_TIOP$M_TLRMR0A_BADR = %X'FFFFF00';
literal KA0C05_TIOP$M_TLRMR0A_NVRAM = %X'40000000';
literal KA0C05_TIOP$M_TLRMR0A_VALID = %X'80000000';
literal KA0C05_TIOP$M_TLRMR0B_MASK = %X'F';
literal KA0C05_TIOP$M_TLRMR0B_ILV_EN = %X'10';
literal KA0C05_TIOP$M_TLRMR0B_BADR = %X'FFFFF00';
literal KA0C05_TIOP$M_TLRMR0B_NVRAM = %X'40000000';
literal KA0C05_TIOP$M_TLRMR0B_VALID = %X'80000000';
literal KA0C05_TIOP$M_TLRMR1A_MASK = %X'F';
literal KA0C05_TIOP$M_TLRMR1A_ILV_EN = %X'10';
literal KA0C05_TIOP$M_TLRMR1A_BADR = %X'FFFFF00';
literal KA0C05_TIOP$M_TLRMR1A_NVRAM = %X'40000000';
literal KA0C05_TIOP$M_TLRMR1A_VALID = %X'80000000';
literal KA0C05_TIOP$M_TLRMR1B_MASK = %X'F';
literal KA0C05_TIOP$M_TLRMR1B_ILV_EN = %X'10';
literal KA0C05_TIOP$M_TLRMR1B_BADR = %X'FFFFF00';
literal KA0C05_TIOP$M_TLRMR1B_NVRAM = %X'40000000';
literal KA0C05_TIOP$M_TLRMR1B_VALID = %X'80000000';
literal KA0C05_TIOP$M_TLICMSR_ARB_CTL = %X'3';
literal KA0C05_TIOP$M_TLICMSR_SUP_CTL = %X'C';
literal KA0C05_TIOP$M_TLICMSR_FORCE_ACK = %X'10';
literal KA0C05_TIOP$M_TLICMSR_RMNXM = %X'20';
literal KA0C05_TIOP$M_TLICMSR_ACK_DSBL = %X'40';
literal KA0C05_TIOP$M_TLICNSE_ACK_DROP = %X'4';
literal KA0C05_TIOP$M_TLICNSE_RMNXM = %X'8';
literal KA0C05_TIOP$M_TLICNSE_MBX_STAT = %X'F0';
literal KA0C05_TIOP$M_TLICNSE_OFLO = %X'F00';
literal KA0C05_TIOP$M_TLICNSE_PKT_E = %X'F000';
literal KA0C05_TIOP$M_TLICNSE_PAR_E = %X'F0000';
literal KA0C05_TIOP$M_TLICNSE_UP_HDP_IE = %X'300000';
literal KA0C05_TIOP$M_TLICNSE_INT_E = %X'400000';
literal KA0C05_TIOP$M_TLICNSE_DN_VRTX_E = %X'1800000';
literal KA0C05_TIOP$M_TLICNSE_UP_VRTX_E = %X'6000000';
literal KA0C05_TIOP$M_TLICNSE_IE = %X'8000000';
literal KA0C05_TIOP$M_TLICNSE_BUS_PE = %X'10000000';
literal KA0C05_TIOP$M_TLICNSE_WND_OFLO = %X'20000000';
literal KA0C05_TIOP$M_TLICNSE_RM_OFLO = %X'40000000';
literal KA0C05_TIOP$M_TLICNSE_INT_NSES = %X'80000000';
literal KA0C05_TIOP$M_TLICDR_IDP_PE = %X'1';
literal KA0C05_TIOP$M_TLICDR_DSE = %X'2';
literal KA0C05_TIOP$M_TLICDR_DTO = %X'4';
literal KA0C05_TIOP$M_TLICDR_DIS_CMD = %X'8';
literal KA0C05_TIOP$M_TLICDR_DIS_FLT = %X'10';
literal KA0C05_TIOP$M_TLICDR_CMD_PE = %X'20';
literal KA0C05_TIOP$M_TLICDR_BNK_BSY = %X'40';
literal KA0C05_TIOP$M_TLICDR_IDP_CMD_PE = %X'100';
literal KA0C05_TIOP$M_TLICDR_EN_HID = %X'80000000';
literal KA0C05_TIOP$M_TLICMTR_MBX_TIP = %X'F';
literal KA0C05_TIOP$M_TLICWRT_WIP = %X'F';
literal KA0C05_TIOP$M_TLIDPNSE_ERR = %X'1';
literal KA0C05_TIOP$M_TLIDPNSE_POK = %X'2';
literal KA0C05_TIOP$M_TLIDPNSE_CBLOK = %X'4';
literal KA0C05_TIOP$M_TLIDPNSE_POK_TRAN = %X'8';
literal KA0C05_TIOP$M_TLIDPNSE_SOFT_ERR = %X'10';
literal KA0C05_TIOP$M_TLIDPNSE_RM_M_ERR = %X'C00000';
literal KA0C05_TIOP$M_TLIDPNSE_CPE = %X'1000000';
literal KA0C05_TIOP$M_TLIDPNSE_UP_V_ERR = %X'6000000';
literal KA0C05_TIOP$M_TLIDPNSE_IE = %X'8000000';
literal KA0C05_TIOP$M_TLIDPNSE_PE = %X'10000000';
literal KA0C05_TIOP$M_TLIDPNSE_RESET = %X'80000000';
literal KA0C05_TIOP$M_TLIPMASK_CPU = %X'FFFF';
literal KA0C05_TIOP$M_TLIDPVR_VECTOR = %X'FFFF';
literal KA0C05_TIOP$M_TLIBR_RCV_SDAT = %X'1';
literal KA0C05_TIOP$M_TLIBR_XMT_SDAT = %X'2';
literal KA0C05_TIOP$M_TLIBR_SCLK = %X'4';
literal KA0C05_TIOP$S_KA0C05_TIOP = 16384;
macro KA0C05_TIOP$L_TLDEV = 0,0,32,0 %;
macro KA0C05_TIOP$V_TLDEV_DTYPE = 0,0,16,0 %;
literal KA0C05_TIOP$S_TLDEV_DTYPE = 16;
macro KA0C05_TIOP$V_TLDEV_SWREV = 0,16,8,0 %;
literal KA0C05_TIOP$S_TLDEV_SWREV = 8;
macro KA0C05_TIOP$V_TLDEV_HWREV = 0,24,8,0 %;
literal KA0C05_TIOP$S_TLDEV_HWREV = 8;
macro KA0C05_TIOP$b_f1400 = 4,0,0,0 %;
literal KA0C05_TIOP$s_f1400 = 60;
macro KA0C05_TIOP$L_TLBER = 64,0,32,0 %;
macro KA0C05_TIOP$V_TLBER_ATCE = 64,0,1,0 %;
macro KA0C05_TIOP$V_TLBER_APE = 64,1,1,0 %;
macro KA0C05_TIOP$V_TLBER_BBE = 64,2,1,0 %;
macro KA0C05_TIOP$V_TLBER_LKTO = 64,3,1,0 %;
macro KA0C05_TIOP$V_TLBER_NAE = 64,4,1,0 %;
macro KA0C05_TIOP$V_TLBER_RTCE = 64,5,1,0 %;
macro KA0C05_TIOP$V_TLBER_ACKTCE = 64,6,1,0 %;
macro KA0C05_TIOP$V_TLBER_MMRE = 64,7,1,0 %;
macro KA0C05_TIOP$V_TLBER_FNAE = 64,8,1,0 %;
macro KA0C05_TIOP$V_TLBER_REQDE = 64,9,1,0 %;
macro KA0C05_TIOP$V_TLBER_ATDE = 64,10,1,0 %;
macro KA0C05_TIOP$V_TLBER_UDE = 64,16,1,0 %;
macro KA0C05_TIOP$V_TLBER_CWDE = 64,17,1,0 %;
macro KA0C05_TIOP$V_TLBER_CRDE = 64,18,1,0 %;
macro KA0C05_TIOP$V_TLBER_DS0 = 64,20,1,0 %;
macro KA0C05_TIOP$V_TLBER_DS1 = 64,21,1,0 %;
macro KA0C05_TIOP$V_TLBER_DS2 = 64,22,1,0 %;
macro KA0C05_TIOP$V_TLBER_DS3 = 64,23,1,0 %;
macro KA0C05_TIOP$V_TLBER_DTDE = 64,24,1,0 %;
macro KA0C05_TIOP$V_TLBER_FDTCE = 64,25,1,0 %;
macro KA0C05_TIOP$V_TLBER_UACKE = 64,26,1,0 %;
macro KA0C05_TIOP$V_TLBER_ABTCE = 64,27,1,0 %;
macro KA0C05_TIOP$V_TLBER_DCTCE = 64,28,1,0 %;
macro KA0C05_TIOP$V_TLBER_SEQE = 64,29,1,0 %;
macro KA0C05_TIOP$V_TLBER_DSE = 64,30,1,0 %;
macro KA0C05_TIOP$V_TLBER_DTO = 64,31,1,0 %;
macro KA0C05_TIOP$b_f1410 = 68,0,0,0 %;
literal KA0C05_TIOP$s_f1410 = 60;
macro KA0C05_TIOP$L_TLCNR = 128,0,32,0 %;
macro KA0C05_TIOP$V_TLCNR_CWDD = 128,0,1,0 %;
macro KA0C05_TIOP$V_TLCNR_CRDD = 128,1,1,0 %;
macro KA0C05_TIOP$V_TLCNR_LKTOD = 128,2,1,0 %;
macro KA0C05_TIOP$V_TLCNR_DTOD = 128,3,1,0 %;
macro KA0C05_TIOP$V_TLCNR_NODE_ID = 128,4,4,0 %;
literal KA0C05_TIOP$S_TLCNR_NODE_ID = 4;
macro KA0C05_TIOP$V_TLCNR_VCNT = 128,8,4,0 %;
literal KA0C05_TIOP$S_TLCNR_VCNT = 4;
macro KA0C05_TIOP$V_TLCNR_STF_A = 128,12,1,0 %;
macro KA0C05_TIOP$V_TLCNR_STF_B = 128,13,1,0 %;
macro KA0C05_TIOP$V_TLCNR_STF_C = 128,14,1,0 %;
macro KA0C05_TIOP$V_TLCNR_STF_D = 128,15,1,0 %;
macro KA0C05_TIOP$V_TLCNR_STF_E = 128,16,1,0 %;
macro KA0C05_TIOP$V_TLCNR_STF_F = 128,17,1,0 %;
macro KA0C05_TIOP$V_TLCNR_STF_G = 128,18,1,0 %;
macro KA0C05_TIOP$V_TLCNR_STF_H = 128,19,1,0 %;
macro KA0C05_TIOP$V_TLCNR_HALT_A = 128,20,1,0 %;
macro KA0C05_TIOP$V_TLCNR_HALT_B = 128,21,1,0 %;
macro KA0C05_TIOP$V_TLCNR_HALT_C = 128,22,1,0 %;
macro KA0C05_TIOP$V_TLCNR_HALT_D = 128,23,1,0 %;
macro KA0C05_TIOP$V_TLCNR_HALT_E = 128,24,1,0 %;
macro KA0C05_TIOP$V_TLCNR_HALT_F = 128,25,1,0 %;
macro KA0C05_TIOP$V_TLCNR_HALT_G = 128,26,1,0 %;
macro KA0C05_TIOP$V_TLCNR_HALT_H = 128,27,1,0 %;
macro KA0C05_TIOP$V_TLCNR_RSTSTAT = 128,28,1,0 %;
macro KA0C05_TIOP$V_TLCNR_NRST = 128,30,1,0 %;
macro KA0C05_TIOP$V_TLCNR_LOFE = 128,31,1,0 %;
macro KA0C05_TIOP$b_f1420 = 132,0,0,0 %;
literal KA0C05_TIOP$s_f1420 = 380;
macro KA0C05_TIOP$L_TLMMR0 = 512,0,32,0 %;
macro KA0C05_TIOP$V_TLMMR0_INTMASK = 512,0,2,0 %;
literal KA0C05_TIOP$S_TLMMR0_INTMASK = 2;
macro KA0C05_TIOP$V_TLMMR0_ADRMASK = 512,4,4,0 %;
literal KA0C05_TIOP$S_TLMMR0_ADRMASK = 4;
macro KA0C05_TIOP$V_TLMMR0_INTLV = 512,8,3,0 %;
literal KA0C05_TIOP$S_TLMMR0_INTLV = 3;
macro KA0C05_TIOP$V_TLMMR0_SBANK = 512,11,1,0 %;
macro KA0C05_TIOP$V_TLMMR0_ADDRESS = 512,12,14,0 %;
literal KA0C05_TIOP$S_TLMMR0_ADDRESS = 14;
macro KA0C05_TIOP$V_TLMMR0_VALID = 512,31,1,0 %;
macro KA0C05_TIOP$b_f1440 = 516,0,0,0 %;
literal KA0C05_TIOP$s_f1440 = 60;
macro KA0C05_TIOP$L_TLMMR1 = 576,0,32,0 %;
macro KA0C05_TIOP$V_TLMMR1_INTMASK = 576,0,2,0 %;
literal KA0C05_TIOP$S_TLMMR1_INTMASK = 2;
macro KA0C05_TIOP$V_TLMMR1_ADRMASK = 576,4,4,0 %;
literal KA0C05_TIOP$S_TLMMR1_ADRMASK = 4;
macro KA0C05_TIOP$V_TLMMR1_INTLV = 576,8,3,0 %;
literal KA0C05_TIOP$S_TLMMR1_INTLV = 3;
macro KA0C05_TIOP$V_TLMMR1_SBANK = 576,11,1,0 %;
macro KA0C05_TIOP$V_TLMMR1_ADDRESS = 576,12,14,0 %;
literal KA0C05_TIOP$S_TLMMR1_ADDRESS = 14;
macro KA0C05_TIOP$V_TLMMR1_VALID = 576,31,1,0 %;
macro KA0C05_TIOP$b_f1450 = 580,0,0,0 %;
literal KA0C05_TIOP$s_f1450 = 60;
macro KA0C05_TIOP$L_TLMMR2 = 640,0,32,0 %;
macro KA0C05_TIOP$V_TLMMR2_INTMASK = 640,0,2,0 %;
literal KA0C05_TIOP$S_TLMMR2_INTMASK = 2;
macro KA0C05_TIOP$V_TLMMR2_ADRMASK = 640,4,4,0 %;
literal KA0C05_TIOP$S_TLMMR2_ADRMASK = 4;
macro KA0C05_TIOP$V_TLMMR2_INTLV = 640,8,3,0 %;
literal KA0C05_TIOP$S_TLMMR2_INTLV = 3;
macro KA0C05_TIOP$V_TLMMR2_SBANK = 640,11,1,0 %;
macro KA0C05_TIOP$V_TLMMR2_ADDRESS = 640,12,14,0 %;
literal KA0C05_TIOP$S_TLMMR2_ADDRESS = 14;
macro KA0C05_TIOP$V_TLMMR2_VALID = 640,31,1,0 %;
macro KA0C05_TIOP$b_f1460 = 644,0,0,0 %;
literal KA0C05_TIOP$s_f1460 = 60;
macro KA0C05_TIOP$L_TLMMR3 = 704,0,32,0 %;
macro KA0C05_TIOP$V_TLMMR3_INTMASK = 704,0,2,0 %;
literal KA0C05_TIOP$S_TLMMR3_INTMASK = 2;
macro KA0C05_TIOP$V_TLMMR3_ADRMASK = 704,4,4,0 %;
literal KA0C05_TIOP$S_TLMMR3_ADRMASK = 4;
macro KA0C05_TIOP$V_TLMMR3_INTLV = 704,8,3,0 %;
literal KA0C05_TIOP$S_TLMMR3_INTLV = 3;
macro KA0C05_TIOP$V_TLMMR3_SBANK = 704,11,1,0 %;
macro KA0C05_TIOP$V_TLMMR3_ADDRESS = 704,12,14,0 %;
literal KA0C05_TIOP$S_TLMMR3_ADDRESS = 14;
macro KA0C05_TIOP$V_TLMMR3_VALID = 704,31,1,0 %;
macro KA0C05_TIOP$b_f1470 = 708,0,0,0 %;
literal KA0C05_TIOP$s_f1470 = 60;
macro KA0C05_TIOP$L_TLMMR4 = 768,0,32,0 %;
macro KA0C05_TIOP$V_TLMMR4_INTMASK = 768,0,2,0 %;
literal KA0C05_TIOP$S_TLMMR4_INTMASK = 2;
macro KA0C05_TIOP$V_TLMMR4_ADRMASK = 768,4,4,0 %;
literal KA0C05_TIOP$S_TLMMR4_ADRMASK = 4;
macro KA0C05_TIOP$V_TLMMR4_INTLV = 768,8,3,0 %;
literal KA0C05_TIOP$S_TLMMR4_INTLV = 3;
macro KA0C05_TIOP$V_TLMMR4_SBANK = 768,11,1,0 %;
macro KA0C05_TIOP$V_TLMMR4_ADDRESS = 768,12,14,0 %;
literal KA0C05_TIOP$S_TLMMR4_ADDRESS = 14;
macro KA0C05_TIOP$V_TLMMR4_VALID = 768,31,1,0 %;
macro KA0C05_TIOP$b_f1480 = 772,0,0,0 %;
literal KA0C05_TIOP$s_f1480 = 60;
macro KA0C05_TIOP$L_TLMMR5 = 832,0,32,0 %;
macro KA0C05_TIOP$V_TLMMR5_INTMASK = 832,0,2,0 %;
literal KA0C05_TIOP$S_TLMMR5_INTMASK = 2;
macro KA0C05_TIOP$V_TLMMR5_ADRMASK = 832,4,4,0 %;
literal KA0C05_TIOP$S_TLMMR5_ADRMASK = 4;
macro KA0C05_TIOP$V_TLMMR5_INTLV = 832,8,3,0 %;
literal KA0C05_TIOP$S_TLMMR5_INTLV = 3;
macro KA0C05_TIOP$V_TLMMR5_SBANK = 832,11,1,0 %;
macro KA0C05_TIOP$V_TLMMR5_ADDRESS = 832,12,14,0 %;
literal KA0C05_TIOP$S_TLMMR5_ADDRESS = 14;
macro KA0C05_TIOP$V_TLMMR5_VALID = 832,31,1,0 %;
macro KA0C05_TIOP$b_f1490 = 836,0,0,0 %;
literal KA0C05_TIOP$s_f1490 = 60;
macro KA0C05_TIOP$L_TLMMR6 = 896,0,32,0 %;
macro KA0C05_TIOP$V_TLMMR6_INTMASK = 896,0,2,0 %;
literal KA0C05_TIOP$S_TLMMR6_INTMASK = 2;
macro KA0C05_TIOP$V_TLMMR6_ADRMASK = 896,4,4,0 %;
literal KA0C05_TIOP$S_TLMMR6_ADRMASK = 4;
macro KA0C05_TIOP$V_TLMMR6_INTLV = 896,8,3,0 %;
literal KA0C05_TIOP$S_TLMMR6_INTLV = 3;
macro KA0C05_TIOP$V_TLMMR6_SBANK = 896,11,1,0 %;
macro KA0C05_TIOP$V_TLMMR6_ADDRESS = 896,12,14,0 %;
literal KA0C05_TIOP$S_TLMMR6_ADDRESS = 14;
macro KA0C05_TIOP$V_TLMMR6_VALID = 896,31,1,0 %;
macro KA0C05_TIOP$b_f1500 = 900,0,0,0 %;
literal KA0C05_TIOP$s_f1500 = 60;
macro KA0C05_TIOP$L_TLMMR7 = 960,0,32,0 %;
macro KA0C05_TIOP$V_TLMMR7_INTMASK = 960,0,2,0 %;
literal KA0C05_TIOP$S_TLMMR7_INTMASK = 2;
macro KA0C05_TIOP$V_TLMMR7_ADRMASK = 960,4,4,0 %;
literal KA0C05_TIOP$S_TLMMR7_ADRMASK = 4;
macro KA0C05_TIOP$V_TLMMR7_INTLV = 960,8,3,0 %;
literal KA0C05_TIOP$S_TLMMR7_INTLV = 3;
macro KA0C05_TIOP$V_TLMMR7_SBANK = 960,11,1,0 %;
macro KA0C05_TIOP$V_TLMMR7_ADDRESS = 960,12,14,0 %;
literal KA0C05_TIOP$S_TLMMR7_ADDRESS = 14;
macro KA0C05_TIOP$V_TLMMR7_VALID = 960,31,1,0 %;
macro KA0C05_TIOP$b_f1510 = 964,0,0,0 %;
literal KA0C05_TIOP$s_f1510 = 572;
macro KA0C05_TIOP$L_TLFADR0 = 1536,0,32,0 %;
macro KA0C05_TIOP$V_TLFADR0_FADR = 1536,3,29,0 %;
literal KA0C05_TIOP$S_TLFADR0_FADR = 29;
macro KA0C05_TIOP$b_f1520 = 1540,0,0,0 %;
literal KA0C05_TIOP$s_f1520 = 60;
macro KA0C05_TIOP$L_TLFADR1 = 1600,0,32,0 %;
macro KA0C05_TIOP$V_TLFADR1_FADR = 1600,0,8,0 %;
literal KA0C05_TIOP$S_TLFADR1_FADR = 8;
macro KA0C05_TIOP$V_TLFADR1_FCMD = 1600,16,3,0 %;
literal KA0C05_TIOP$S_TLFADR1_FCMD = 3;
macro KA0C05_TIOP$V_TLFADR1_FBANK = 1600,20,4,0 %;
literal KA0C05_TIOP$S_TLFADR1_FBANK = 4;
macro KA0C05_TIOP$V_TLFADR1_ADRV = 1600,24,1,0 %;
macro KA0C05_TIOP$V_TLFADR1_CMDV = 1600,25,1,0 %;
macro KA0C05_TIOP$V_TLFADR1_BANKV = 1600,26,1,0 %;
macro KA0C05_TIOP$b_f1530 = 1604,0,0,0 %;
literal KA0C05_TIOP$s_f1530 = 60;
macro KA0C05_TIOP$L_TLESR0 = 1664,0,32,0 %;
macro KA0C05_TIOP$V_TLESR0_SYND0 = 1664,0,8,0 %;
literal KA0C05_TIOP$S_TLESR0_SYND0 = 8;
macro KA0C05_TIOP$V_TLESR0_SYND1 = 1664,8,8,0 %;
literal KA0C05_TIOP$S_TLESR0_SYND1 = 8;
macro KA0C05_TIOP$V_TLESR0_TDE = 1664,16,1,0 %;
macro KA0C05_TIOP$V_TLESR0_TCE = 1664,17,1,0 %;
macro KA0C05_TIOP$V_TLESR0_DVTCE = 1664,18,1,0 %;
macro KA0C05_TIOP$V_TLESR0_UECC = 1664,19,1,0 %;
macro KA0C05_TIOP$V_TLESR0_CWECC = 1664,20,1,0 %;
macro KA0C05_TIOP$V_TLESR0_CRECC = 1664,21,1,0 %;
macro KA0C05_TIOP$V_TLESR0_LOFSYN = 1664,31,1,0 %;
macro KA0C05_TIOP$b_f1540 = 1668,0,0,0 %;
literal KA0C05_TIOP$s_f1540 = 60;
macro KA0C05_TIOP$L_TLESR1 = 1728,0,32,0 %;
macro KA0C05_TIOP$V_TLESR1_SYND0 = 1728,0,8,0 %;
literal KA0C05_TIOP$S_TLESR1_SYND0 = 8;
macro KA0C05_TIOP$V_TLESR1_SYND1 = 1728,8,8,0 %;
literal KA0C05_TIOP$S_TLESR1_SYND1 = 8;
macro KA0C05_TIOP$V_TLESR1_TDE = 1728,16,1,0 %;
macro KA0C05_TIOP$V_TLESR1_TCE = 1728,17,1,0 %;
macro KA0C05_TIOP$V_TLESR1_DVTCE = 1728,18,1,0 %;
macro KA0C05_TIOP$V_TLESR1_UECC = 1728,19,1,0 %;
macro KA0C05_TIOP$V_TLESR1_CWECC = 1728,20,1,0 %;
macro KA0C05_TIOP$V_TLESR1_CRECC = 1728,21,1,0 %;
macro KA0C05_TIOP$V_TLESR1_LOFSYN = 1728,31,1,0 %;
macro KA0C05_TIOP$b_f1550 = 1732,0,0,0 %;
literal KA0C05_TIOP$s_f1550 = 60;
macro KA0C05_TIOP$L_TLESR2 = 1792,0,32,0 %;
macro KA0C05_TIOP$V_TLESR2_SYND0 = 1792,0,8,0 %;
literal KA0C05_TIOP$S_TLESR2_SYND0 = 8;
macro KA0C05_TIOP$V_TLESR2_SYND1 = 1792,8,8,0 %;
literal KA0C05_TIOP$S_TLESR2_SYND1 = 8;
macro KA0C05_TIOP$V_TLESR2_TDE = 1792,16,1,0 %;
macro KA0C05_TIOP$V_TLESR2_TCE = 1792,17,1,0 %;
macro KA0C05_TIOP$V_TLESR2_DVTCE = 1792,18,1,0 %;
macro KA0C05_TIOP$V_TLESR2_UECC = 1792,19,1,0 %;
macro KA0C05_TIOP$V_TLESR2_CWECC = 1792,20,1,0 %;
macro KA0C05_TIOP$V_TLESR2_CRECC = 1792,21,1,0 %;
macro KA0C05_TIOP$V_TLESR2_LOFSYN = 1792,31,1,0 %;
macro KA0C05_TIOP$b_f1560 = 1796,0,0,0 %;
literal KA0C05_TIOP$s_f1560 = 60;
macro KA0C05_TIOP$L_TLESR3 = 1856,0,32,0 %;
macro KA0C05_TIOP$V_TLESR3_SYND0 = 1856,0,8,0 %;
literal KA0C05_TIOP$S_TLESR3_SYND0 = 8;
macro KA0C05_TIOP$V_TLESR3_SYND1 = 1856,8,8,0 %;
literal KA0C05_TIOP$S_TLESR3_SYND1 = 8;
macro KA0C05_TIOP$V_TLESR3_TDE = 1856,16,1,0 %;
macro KA0C05_TIOP$V_TLESR3_TCE = 1856,17,1,0 %;
macro KA0C05_TIOP$V_TLESR3_DVTCE = 1856,18,1,0 %;
macro KA0C05_TIOP$V_TLESR3_UECC = 1856,19,1,0 %;
macro KA0C05_TIOP$V_TLESR3_CWECC = 1856,20,1,0 %;
macro KA0C05_TIOP$V_TLESR3_CRECC = 1856,21,1,0 %;
macro KA0C05_TIOP$V_TLESR3_LOFSYN = 1856,31,1,0 %;
macro KA0C05_TIOP$b_f1570 = 1860,0,0,0 %;
literal KA0C05_TIOP$s_f1570 = 700;
macro KA0C05_TIOP$L_TLILID0 = 2560,0,32,0 %;
macro KA0C05_TIOP$V_TLILID0_IDENT = 2560,0,16,0 %;
literal KA0C05_TIOP$S_TLILID0_IDENT = 16;
macro KA0C05_TIOP$b_f1580 = 2564,0,0,0 %;
literal KA0C05_TIOP$s_f1580 = 60;
macro KA0C05_TIOP$L_TLILID1 = 2624,0,32,0 %;
macro KA0C05_TIOP$V_TLILID1_IDENT = 2624,0,16,0 %;
literal KA0C05_TIOP$S_TLILID1_IDENT = 16;
macro KA0C05_TIOP$b_f1590 = 2628,0,0,0 %;
literal KA0C05_TIOP$s_f1590 = 60;
macro KA0C05_TIOP$L_TLILID2 = 2688,0,32,0 %;
macro KA0C05_TIOP$V_TLILID2_IDENT = 2688,0,16,0 %;
literal KA0C05_TIOP$S_TLILID2_IDENT = 16;
macro KA0C05_TIOP$b_f1600 = 2692,0,0,0 %;
literal KA0C05_TIOP$s_f1600 = 60;
macro KA0C05_TIOP$L_TLILID3 = 2752,0,32,0 %;
macro KA0C05_TIOP$V_TLILID3_IDENT = 2752,0,16,0 %;
literal KA0C05_TIOP$S_TLILID3_IDENT = 16;
macro KA0C05_TIOP$b_f1610 = 2756,0,0,0 %;
literal KA0C05_TIOP$s_f1610 = 60;
macro KA0C05_TIOP$L_TLCPUMASK = 2816,0,32,0 %;
macro KA0C05_TIOP$V_TLCPUMASK_MASK = 2816,0,16,0 %;
literal KA0C05_TIOP$S_TLCPUMASK_MASK = 16;
macro KA0C05_TIOP$b_f1620 = 2820,0,0,0 %;
literal KA0C05_TIOP$s_f1620 = 252;
macro KA0C05_TIOP$Q_TLMBPR = 3072,0,0,1 %;
literal KA0C05_TIOP$S_TLMBPR = 8;
macro KA0C05_TIOP$b_f1630 = 3080,0,0,0 %;
literal KA0C05_TIOP$s_f1630 = 4600;
macro KA0C05_TIOP$L_TLRMR0A = 7680,0,32,0 %;
macro KA0C05_TIOP$V_TLRMR0A_MASK = 7680,0,4,0 %;
literal KA0C05_TIOP$S_TLRMR0A_MASK = 4;
macro KA0C05_TIOP$V_TLRMR0A_ILV_EN = 7680,4,1,0 %;
macro KA0C05_TIOP$V_TLRMR0A_BADR = 7680,8,20,0 %;
literal KA0C05_TIOP$S_TLRMR0A_BADR = 20;
macro KA0C05_TIOP$V_TLRMR0A_NVRAM = 7680,30,1,0 %;
macro KA0C05_TIOP$V_TLRMR0A_VALID = 7680,31,1,0 %;
macro KA0C05_TIOP$b_f1640 = 7684,0,0,0 %;
literal KA0C05_TIOP$s_f1640 = 60;
macro KA0C05_TIOP$L_TLRMR0B = 7744,0,32,0 %;
macro KA0C05_TIOP$V_TLRMR0B_MASK = 7744,0,4,0 %;
literal KA0C05_TIOP$S_TLRMR0B_MASK = 4;
macro KA0C05_TIOP$V_TLRMR0B_ILV_EN = 7744,4,1,0 %;
macro KA0C05_TIOP$V_TLRMR0B_BADR = 7744,8,20,0 %;
literal KA0C05_TIOP$S_TLRMR0B_BADR = 20;
macro KA0C05_TIOP$V_TLRMR0B_NVRAM = 7744,30,1,0 %;
macro KA0C05_TIOP$V_TLRMR0B_VALID = 7744,31,1,0 %;
macro KA0C05_TIOP$b_f1650 = 7748,0,0,0 %;
literal KA0C05_TIOP$s_f1650 = 60;
macro KA0C05_TIOP$L_TLRMR1A = 7808,0,32,0 %;
macro KA0C05_TIOP$V_TLRMR1A_MASK = 7808,0,4,0 %;
literal KA0C05_TIOP$S_TLRMR1A_MASK = 4;
macro KA0C05_TIOP$V_TLRMR1A_ILV_EN = 7808,4,1,0 %;
macro KA0C05_TIOP$V_TLRMR1A_BADR = 7808,8,20,0 %;
literal KA0C05_TIOP$S_TLRMR1A_BADR = 20;
macro KA0C05_TIOP$V_TLRMR1A_NVRAM = 7808,30,1,0 %;
macro KA0C05_TIOP$V_TLRMR1A_VALID = 7808,31,1,0 %;
macro KA0C05_TIOP$b_f1660 = 7812,0,0,0 %;
literal KA0C05_TIOP$s_f1660 = 60;
macro KA0C05_TIOP$L_TLRMR1B = 7872,0,32,0 %;
macro KA0C05_TIOP$V_TLRMR1B_MASK = 7872,0,4,0 %;
literal KA0C05_TIOP$S_TLRMR1B_MASK = 4;
macro KA0C05_TIOP$V_TLRMR1B_ILV_EN = 7872,4,1,0 %;
macro KA0C05_TIOP$V_TLRMR1B_BADR = 7872,8,20,0 %;
literal KA0C05_TIOP$S_TLRMR1B_BADR = 20;
macro KA0C05_TIOP$V_TLRMR1B_NVRAM = 7872,30,1,0 %;
macro KA0C05_TIOP$V_TLRMR1B_VALID = 7872,31,1,0 %;
macro KA0C05_TIOP$b_f1670 = 7876,0,0,0 %;
literal KA0C05_TIOP$s_f1670 = 316;
macro KA0C05_TIOP$L_TLICMSR = 8192,0,32,0 %;
macro KA0C05_TIOP$V_TLICMSR_ARB_CTL = 8192,0,2,0 %;
literal KA0C05_TIOP$S_TLICMSR_ARB_CTL = 2;
macro KA0C05_TIOP$V_TLICMSR_SUP_CTL = 8192,2,2,0 %;
literal KA0C05_TIOP$S_TLICMSR_SUP_CTL = 2;
macro KA0C05_TIOP$V_TLICMSR_FORCE_ACK = 8192,4,1,0 %;
macro KA0C05_TIOP$V_TLICMSR_RMNXM = 8192,5,1,0 %;
macro KA0C05_TIOP$V_TLICMSR_ACK_DSBL = 8192,6,1,0 %;
macro KA0C05_TIOP$b_f1700 = 8196,0,0,0 %;
literal KA0C05_TIOP$s_f1700 = 60;
macro KA0C05_TIOP$L_TLICNSE = 8256,0,32,0 %;
macro KA0C05_TIOP$V_TLICNSE_ACK_DROP = 8256,2,1,0 %;
macro KA0C05_TIOP$V_TLICNSE_RMNXM = 8256,3,1,0 %;
macro KA0C05_TIOP$V_TLICNSE_MBX_STAT = 8256,4,4,0 %;
literal KA0C05_TIOP$S_TLICNSE_MBX_STAT = 4;
macro KA0C05_TIOP$V_TLICNSE_OFLO = 8256,8,4,0 %;
literal KA0C05_TIOP$S_TLICNSE_OFLO = 4;
macro KA0C05_TIOP$V_TLICNSE_PKT_E = 8256,12,4,0 %;
literal KA0C05_TIOP$S_TLICNSE_PKT_E = 4;
macro KA0C05_TIOP$V_TLICNSE_PAR_E = 8256,16,4,0 %;
literal KA0C05_TIOP$S_TLICNSE_PAR_E = 4;
macro KA0C05_TIOP$V_TLICNSE_UP_HDP_IE = 8256,20,2,0 %;
literal KA0C05_TIOP$S_TLICNSE_UP_HDP_IE = 2;
macro KA0C05_TIOP$V_TLICNSE_INT_E = 8256,22,1,0 %;
macro KA0C05_TIOP$V_TLICNSE_DN_VRTX_E = 8256,23,2,0 %;
literal KA0C05_TIOP$S_TLICNSE_DN_VRTX_E = 2;
macro KA0C05_TIOP$V_TLICNSE_UP_VRTX_E = 8256,25,2,0 %;
literal KA0C05_TIOP$S_TLICNSE_UP_VRTX_E = 2;
macro KA0C05_TIOP$V_TLICNSE_IE = 8256,27,1,0 %;
macro KA0C05_TIOP$V_TLICNSE_BUS_PE = 8256,28,1,0 %;
macro KA0C05_TIOP$V_TLICNSE_WND_OFLO = 8256,29,1,0 %;
macro KA0C05_TIOP$V_TLICNSE_RM_OFLO = 8256,30,1,0 %;
macro KA0C05_TIOP$V_TLICNSE_INT_NSES = 8256,31,1,0 %;
macro KA0C05_TIOP$b_f1710 = 8260,0,0,0 %;
literal KA0C05_TIOP$s_f1710 = 60;
macro KA0C05_TIOP$L_TLICDR = 8320,0,32,0 %;
macro KA0C05_TIOP$V_TLICDR_IDP_PE = 8320,0,1,0 %;
macro KA0C05_TIOP$V_TLICDR_DSE = 8320,1,1,0 %;
macro KA0C05_TIOP$V_TLICDR_DTO = 8320,2,1,0 %;
macro KA0C05_TIOP$V_TLICDR_DIS_CMD = 8320,3,1,0 %;
macro KA0C05_TIOP$V_TLICDR_DIS_FLT = 8320,4,1,0 %;
macro KA0C05_TIOP$V_TLICDR_CMD_PE = 8320,5,1,0 %;
macro KA0C05_TIOP$V_TLICDR_BNK_BSY = 8320,6,1,0 %;
macro KA0C05_TIOP$V_TLICDR_IDP_CMD_PE = 8320,8,1,0 %;
macro KA0C05_TIOP$V_TLICDR_EN_HID = 8320,31,1,0 %;
macro KA0C05_TIOP$b_f1720 = 8324,0,0,0 %;
literal KA0C05_TIOP$s_f1720 = 60;
macro KA0C05_TIOP$L_TLICMTR = 8384,0,32,0 %;
macro KA0C05_TIOP$V_TLICMTR_MBX_TIP = 8384,0,4,0 %;
literal KA0C05_TIOP$S_TLICMTR_MBX_TIP = 4;
macro KA0C05_TIOP$b_f1730 = 8388,0,0,0 %;
literal KA0C05_TIOP$s_f1730 = 60;
macro KA0C05_TIOP$L_TLICWRT = 8448,0,32,0 %;
macro KA0C05_TIOP$V_TLICWRT_WIP = 8448,0,4,0 %;
literal KA0C05_TIOP$S_TLICWRT_WIP = 4;
macro KA0C05_TIOP$b_f1740 = 8452,0,0,0 %;
literal KA0C05_TIOP$s_f1740 = 60;
macro KA0C05_TIOP$L_TLIDPNSE1 = 8512,0,32,0 %;
macro KA0C05_TIOP$V_TLIDPNSE_ERR = 8512,0,1,0 %;
macro KA0C05_TIOP$V_TLIDPNSE_POK = 8512,1,1,0 %;
macro KA0C05_TIOP$V_TLIDPNSE_CBLOK = 8512,2,1,0 %;
macro KA0C05_TIOP$V_TLIDPNSE_POK_TRAN = 8512,3,1,0 %;
macro KA0C05_TIOP$V_TLIDPNSE_SOFT_ERR = 8512,4,1,0 %;
macro KA0C05_TIOP$V_TLIDPNSE_RM_M_ERR = 8512,22,2,0 %;
literal KA0C05_TIOP$S_TLIDPNSE_RM_M_ERR = 2;
macro KA0C05_TIOP$V_TLIDPNSE_CPE = 8512,24,1,0 %;
macro KA0C05_TIOP$V_TLIDPNSE_UP_V_ERR = 8512,25,2,0 %;
literal KA0C05_TIOP$S_TLIDPNSE_UP_V_ERR = 2;
macro KA0C05_TIOP$V_TLIDPNSE_IE = 8512,27,1,0 %;
macro KA0C05_TIOP$V_TLIDPNSE_PE = 8512,28,1,0 %;
macro KA0C05_TIOP$V_TLIDPNSE_RESET = 8512,31,1,0 %;
macro KA0C05_TIOP$b_f1750 = 8516,0,0,0 %;
literal KA0C05_TIOP$s_f1750 = 60;
macro KA0C05_TIOP$L_TLIDPDR1 = 8576,0,32,0 %;
macro KA0C05_TIOP$b_f1760 = 8580,0,0,0 %;
literal KA0C05_TIOP$s_f1760 = 188;
macro KA0C05_TIOP$L_TLIDPNSE2 = 8768,0,32,0 %;
macro KA0C05_TIOP$b_f1770 = 8772,0,0,0 %;
literal KA0C05_TIOP$s_f1770 = 60;
macro KA0C05_TIOP$L_TLIDPDR2 = 8832,0,32,0 %;
macro KA0C05_TIOP$b_f1780 = 8836,0,0,0 %;
literal KA0C05_TIOP$s_f1780 = 188;
macro KA0C05_TIOP$L_TLIDPNSE3 = 9024,0,32,0 %;
macro KA0C05_TIOP$b_f1790 = 9028,0,0,0 %;
literal KA0C05_TIOP$s_f1790 = 60;
macro KA0C05_TIOP$L_TLIDPDR3 = 9088,0,32,0 %;
macro KA0C05_TIOP$b_f1800 = 9092,0,0,0 %;
literal KA0C05_TIOP$s_f1800 = 1724;
macro KA0C05_TIOP$L_TLIDPNSE0 = 10816,0,32,0 %;
macro KA0C05_TIOP$b_f1810 = 10820,0,0,0 %;
literal KA0C05_TIOP$s_f1810 = 60;
macro KA0C05_TIOP$L_TLIDPDR0 = 10880,0,32,0 %;
macro KA0C05_TIOP$b_f1820 = 10884,0,0,0 %;
literal KA0C05_TIOP$s_f1820 = 60;
macro KA0C05_TIOP$L_TLIPMASK = 10944,0,32,0 %;
macro KA0C05_TIOP$V_TLIPMASK_CPU = 10944,0,16,0 %;
literal KA0C05_TIOP$S_TLIPMASK_CPU = 16;
macro KA0C05_TIOP$b_fill830 = 10948,0,0,0 %;
literal KA0C05_TIOP$s_fill830 = 124;
macro KA0C05_TIOP$L_TLIDPVR = 11072,0,32,0 %;
macro KA0C05_TIOP$V_TLIDPVR_VECTOR = 11072,0,16,0 %;
literal KA0C05_TIOP$S_TLIDPVR_VECTOR = 16;
macro KA0C05_TIOP$b_f1840 = 11076,0,0,0 %;
literal KA0C05_TIOP$s_f1840 = 60;
macro KA0C05_TIOP$L_TLIDPMSR = 11136,0,32,0 %;
macro KA0C05_TIOP$b_f1850 = 11140,0,0,0 %;
literal KA0C05_TIOP$s_f1850 = 60;
macro KA0C05_TIOP$L_TLIBR = 11200,0,32,0 %;
macro KA0C05_TIOP$V_TLIBR_RCV_SDAT = 11200,0,1,0 %;
macro KA0C05_TIOP$V_TLIBR_XMT_SDAT = 11200,1,1,0 %;
macro KA0C05_TIOP$V_TLIBR_SCLK = 11200,2,1,0 %;
macro KA0C05_TIOP$b_f1860 = 11204,0,0,0 %;
literal KA0C05_TIOP$s_f1860 = 5180;
literal KA0C05_UART0B$S_KA0C05_UART0B = 8192;
macro KA0C05_UART0B$L_UART0B_RR0 = 0,0,32,0 %;
macro KA0C05_UART0B$b_f2000 = 4,0,0,0 %;
literal KA0C05_UART0B$s_f2000 = 60;
macro KA0C05_UART0B$L_UART0B_RR8 = 64,0,32,0 %;
macro KA0C05_UART0B$b_f2010 = 68,0,0,0 %;
literal KA0C05_UART0B$s_f2010 = 60;
macro KA0C05_UART0B$L_UART0A_RR0 = 128,0,32,0 %;
macro KA0C05_UART0B$b_f2020 = 132,0,0,0 %;
literal KA0C05_UART0B$s_f2020 = 60;
macro KA0C05_UART0B$L_UART0A_RR8 = 192,0,32,0 %;
macro KA0C05_UART0B$b_f2030 = 196,0,0,0 %;
literal KA0C05_UART0B$s_f2030 = 7996;
literal KA0C05_UART1B$S_KA0C05_UART1B = 8192;
macro KA0C05_UART1B$L_UART1B_RR0 = 0,0,32,0 %;
macro KA0C05_UART1B$L_UART1B_WR0 = 0,0,32,0 %;
macro KA0C05_UART1B$b_f2040 = 4,0,0,0 %;
literal KA0C05_UART1B$s_f2040 = 60;
macro KA0C05_UART1B$L_UART1B_RR8 = 64,0,32,0 %;
macro KA0C05_UART1B$b_f2050 = 68,0,0,0 %;
literal KA0C05_UART1B$s_f2050 = 60;
macro KA0C05_UART1B$L_UART1A_RR0 = 128,0,32,0 %;
macro KA0C05_UART1B$b_f2060 = 132,0,0,0 %;
literal KA0C05_UART1B$s_f2060 = 60;
macro KA0C05_UART1B$L_UART1A_RR8 = 192,0,32,0 %;
macro KA0C05_UART1B$b_f2070 = 196,0,0,0 %;
literal KA0C05_UART1B$s_f2070 = 7996;
literal KA0C05_WATCH$M_WATCH_CSRA_RS = %X'F';
literal KA0C05_WATCH$M_WATCH_CSRA_DV = %X'70';
literal KA0C05_WATCH$M_WATCH_CSRA_UIP = %X'80';
literal KA0C05_WATCH$M_WATCH_CSRB_DSE = %X'1';
literal KA0C05_WATCH$M_WATCH_CSRB_24_12 = %X'2';
literal KA0C05_WATCH$M_WATCH_CSRB_DM = %X'4';
literal KA0C05_WATCH$M_WATCH_CSRB_SQWE = %X'8';
literal KA0C05_WATCH$M_WATCH_CSRB_UIE = %X'10';
literal KA0C05_WATCH$M_WATCH_CSRB_AIE = %X'20';
literal KA0C05_WATCH$M_WATCH_CSRB_PIE = %X'40';
literal KA0C05_WATCH$M_WATCH_CSRB_SET = %X'80';
literal KA0C05_WATCH$M_WATCH_CSRC_UF = %X'10';
literal KA0C05_WATCH$M_WATCH_CSRC_AF = %X'20';
literal KA0C05_WATCH$M_WATCH_CSRC_PF = %X'40';
literal KA0C05_WATCH$M_WATCH_CSRC_IRQF = %X'80';
literal KA0C05_WATCH$M_WATCH_CSRD_VRT = %X'80';
literal KA0C05_WATCH$S_KA0C05_WATCH = 8192;
macro KA0C05_WATCH$L_WATCH_SECONDS = 0,0,32,0 %;
macro KA0C05_WATCH$b_fill3000 = 4,0,0,0 %;
literal KA0C05_WATCH$s_fill3000 = 124;
macro KA0C05_WATCH$L_WATCH_MINUTES = 128,0,32,0 %;
macro KA0C05_WATCH$b_fill3010 = 132,0,0,0 %;
literal KA0C05_WATCH$s_fill3010 = 124;
macro KA0C05_WATCH$L_WATCH_HOURS = 256,0,32,0 %;
macro KA0C05_WATCH$b_fill3020 = 260,0,0,0 %;
literal KA0C05_WATCH$s_fill3020 = 188;
macro KA0C05_WATCH$L_WATCH_DOM = 448,0,32,0 %;
macro KA0C05_WATCH$b_fill3030 = 452,0,0,0 %;
literal KA0C05_WATCH$s_fill3030 = 60;
macro KA0C05_WATCH$L_WATCH_MONTH = 512,0,32,0 %;
macro KA0C05_WATCH$b_fill3040 = 516,0,0,0 %;
literal KA0C05_WATCH$s_fill3040 = 60;
macro KA0C05_WATCH$L_WATCH_YEAR = 576,0,32,0 %;
macro KA0C05_WATCH$b_fill3050 = 580,0,0,0 %;
literal KA0C05_WATCH$s_fill3050 = 60;
macro KA0C05_WATCH$L_WATCH_CSRA = 640,0,32,0 %;
macro KA0C05_WATCH$V_WATCH_CSRA_RS = 640,0,4,0 %;
literal KA0C05_WATCH$S_WATCH_CSRA_RS = 4;
macro KA0C05_WATCH$V_WATCH_CSRA_DV = 640,4,3,0 %;
literal KA0C05_WATCH$S_WATCH_CSRA_DV = 3;
macro KA0C05_WATCH$V_WATCH_CSRA_UIP = 640,7,1,0 %;
macro KA0C05_WATCH$b_fill3060 = 644,0,0,0 %;
literal KA0C05_WATCH$s_fill3060 = 60;
macro KA0C05_WATCH$L_WATCH_CSRB = 704,0,32,0 %;
macro KA0C05_WATCH$V_WATCH_CSRB_DSE = 704,0,1,0 %;
macro KA0C05_WATCH$V_WATCH_CSRB_24_12 = 704,1,1,0 %;
macro KA0C05_WATCH$V_WATCH_CSRB_DM = 704,2,1,0 %;
macro KA0C05_WATCH$V_WATCH_CSRB_SQWE = 704,3,1,0 %;
macro KA0C05_WATCH$V_WATCH_CSRB_UIE = 704,4,1,0 %;
macro KA0C05_WATCH$V_WATCH_CSRB_AIE = 704,5,1,0 %;
macro KA0C05_WATCH$V_WATCH_CSRB_PIE = 704,6,1,0 %;
macro KA0C05_WATCH$V_WATCH_CSRB_SET = 704,7,1,0 %;
macro KA0C05_WATCH$b_fill3070 = 708,0,0,0 %;
literal KA0C05_WATCH$s_fill3070 = 60;
macro KA0C05_WATCH$L_WATCH_CSRC = 768,0,32,0 %;
macro KA0C05_WATCH$V_WATCH_CSRC_UF = 768,4,1,0 %;
macro KA0C05_WATCH$V_WATCH_CSRC_AF = 768,5,1,0 %;
macro KA0C05_WATCH$V_WATCH_CSRC_PF = 768,6,1,0 %;
macro KA0C05_WATCH$V_WATCH_CSRC_IRQF = 768,7,1,0 %;
macro KA0C05_WATCH$b_fill3080 = 772,0,0,0 %;
literal KA0C05_WATCH$s_fill3080 = 60;
macro KA0C05_WATCH$L_WATCH_CSRD = 832,0,32,0 %;
macro KA0C05_WATCH$V_WATCH_CSRD_VRT = 832,7,1,0 %;
macro KA0C05_WATCH$b_fill3090 = 836,0,0,0 %;
literal KA0C05_WATCH$s_fill3090 = 60;
macro KA0C05_WATCH$L_WATCH_RAM = 896,0,32,0 %;
macro KA0C05_WATCH$b_fill3100 = 900,0,0,0 %;
literal KA0C05_WATCH$s_fill3100 = 7292;
literal KA0C05_GBUS$M_GWHAMI_CPU = %X'1';
literal KA0C05_GBUS$M_GWHAMI_NID = %X'E';
literal KA0C05_GBUS$M_GWHAMI_BAD = %X'10';
literal KA0C05_GBUS$M_GWHAMI_CONWIN = %X'20';
literal KA0C05_GBUS$M_GWHAMI_MFG_MODE = %X'40';
literal KA0C05_GBUS$M_GMISCR_CACSIZ = %X'3';
literal KA0C05_GBUS$M_GMISCR_PROCCNT = %X'4';
literal KA0C05_GBUS$M_GMISCR_SECURE = %X'8';
literal KA0C05_GBUS$M_GMISCR_RUN = %X'10';
literal KA0C05_GBUS$M_GMISCR_CONWIN0 = %X'40';
literal KA0C05_GBUS$M_GMISCR_CONWIN1 = %X'80';
literal KA0C05_GBUS$M_GMISCW_DRIVE_BAD = %X'4';
literal KA0C05_GBUS$M_GMISCW_FPROM_WE = %X'8';
literal KA0C05_GBUS$M_GMISCW_DRIVE_RUN = %X'10';
literal KA0C05_GBUS$M_GMISCW_DRV_CONWIN = %X'20';
literal KA0C05_GBUS$M_GMISCW_CONWIN0 = %X'40';
literal KA0C05_GBUS$M_GMISCW_CONWIN1 = %X'80';
literal KA0C05_GBUS$M_GSERNUM_CLK = %X'1';
literal KA0C05_GBUS$M_GSERNUM_RCV_DATA = %X'2';
literal KA0C05_GBUS$M_GSERNUM_XMT_DATA = %X'4';
literal KA0C05_GBUS$M_GSERNUM_EXPSEL = %X'18';
literal KA0C05_GBUS$M_GSERNUM_PIUB = %X'20';
literal KA0C05_GBUS$M_GSERNUM_PIUA = %X'40';
literal KA0C05_GBUS$M_GSERNUM_STP = %X'80';
literal KA0C05_GBUS$S_KA0C05_GBUS = 73728;
macro KA0C05_GBUS$L_GWHAMI = 0,0,32,0 %;
macro KA0C05_GBUS$V_GWHAMI_CPU = 0,0,1,0 %;
macro KA0C05_GBUS$V_GWHAMI_NID = 0,1,3,0 %;
literal KA0C05_GBUS$S_GWHAMI_NID = 3;
macro KA0C05_GBUS$V_GWHAMI_BAD = 0,4,1,0 %;
macro KA0C05_GBUS$V_GWHAMI_CONWIN = 0,5,1,0 %;
macro KA0C05_GBUS$V_GWHAMI_MFG_MODE = 0,6,1,0 %;
macro KA0C05_GBUS$b_fill3110 = 4,0,0,0 %;
literal KA0C05_GBUS$s_fill3110 = 8188;
macro KA0C05_GBUS$L_GBUS_LED0 = 8192,0,32,0 %;
macro KA0C05_GBUS$b_fill3120 = 8196,0,0,0 %;
literal KA0C05_GBUS$s_fill3120 = 8188;
macro KA0C05_GBUS$L_GBUS_LED1 = 16384,0,32,0 %;
macro KA0C05_GBUS$b_fill3130 = 16388,0,0,0 %;
literal KA0C05_GBUS$s_fill3130 = 8188;
macro KA0C05_GBUS$L_GBUS_LED2 = 24576,0,32,0 %;
macro KA0C05_GBUS$b_fill3140 = 24580,0,0,0 %;
literal KA0C05_GBUS$s_fill3140 = 8188;
macro KA0C05_GBUS$L_GMISCR = 32768,0,32,0 %;
macro KA0C05_GBUS$V_GMISCR_CACSIZ = 32768,0,2,0 %;
literal KA0C05_GBUS$S_GMISCR_CACSIZ = 2;
macro KA0C05_GBUS$V_GMISCR_PROCCNT = 32768,2,1,0 %;
macro KA0C05_GBUS$V_GMISCR_SECURE = 32768,3,1,0 %;
macro KA0C05_GBUS$V_GMISCR_RUN = 32768,4,1,0 %;
macro KA0C05_GBUS$V_GMISCR_CONWIN0 = 32768,6,1,0 %;
macro KA0C05_GBUS$V_GMISCR_CONWIN1 = 32768,7,1,0 %;
macro KA0C05_GBUS$b_fill3150 = 32772,0,0,0 %;
literal KA0C05_GBUS$s_fill3150 = 8188;
macro KA0C05_GBUS$L_GMISCW = 40960,0,32,0 %;
macro KA0C05_GBUS$V_GMISCW_DRIVE_BAD = 40960,2,1,0 %;
macro KA0C05_GBUS$V_GMISCW_FPROM_WE = 40960,3,1,0 %;
macro KA0C05_GBUS$V_GMISCW_DRIVE_RUN = 40960,4,1,0 %;
macro KA0C05_GBUS$V_GMISCW_DRV_CONWIN = 40960,5,1,0 %;
macro KA0C05_GBUS$V_GMISCW_CONWIN0 = 40960,6,1,0 %;
macro KA0C05_GBUS$V_GMISCW_CONWIN1 = 40960,7,1,0 %;
macro KA0C05_GBUS$b_fill3160 = 40964,0,0,0 %;
literal KA0C05_GBUS$s_fill3160 = 8188;
macro KA0C05_GBUS$L_GBUS_TLSBRST = 49152,0,32,0 %;
macro KA0C05_GBUS$b_fill3170 = 49156,0,0,0 %;
literal KA0C05_GBUS$s_fill3170 = 8188;
macro KA0C05_GBUS$L_GSERNUM = 57344,0,32,0 %;
macro KA0C05_GBUS$V_GSERNUM_CLK = 57344,0,1,0 %;
macro KA0C05_GBUS$V_GSERNUM_RCV_DATA = 57344,1,1,0 %;
macro KA0C05_GBUS$V_GSERNUM_XMT_DATA = 57344,2,1,0 %;
macro KA0C05_GBUS$V_GSERNUM_EXPSEL = 57344,3,2,0 %;
literal KA0C05_GBUS$S_GSERNUM_EXPSEL = 2;
macro KA0C05_GBUS$V_GSERNUM_PIUB = 57344,5,1,0 %;
macro KA0C05_GBUS$V_GSERNUM_PIUA = 57344,6,1,0 %;
macro KA0C05_GBUS$V_GSERNUM_STP = 57344,7,1,0 %;
macro KA0C05_GBUS$b_fill3180 = 57348,0,0,0 %;
literal KA0C05_GBUS$s_fill3180 = 8188;
macro KA0C05_GBUS$L_GBUS_TEST = 65536,0,32,0 %;
macro KA0C05_GBUS$b_fill3190 = 65540,0,0,0 %;
literal KA0C05_GBUS$s_fill3190 = 8188;
literal S_KA0C05DEF = 73728;            !  Old size name, synonym for KA0C05$S_KA0C05
literal KA0C05_CMD$K_NOP = 0;
literal KA0C05_CMD$K_VICTIM = 1;
literal KA0C05_CMD$K_BUS_READ = 2;
literal KA0C05_CMD$K_BUS_WRITE = 3;
literal KA0C05_CMD$K_READ_BANK_LOCK = 4;
literal KA0C05_CMD$K_WRITE_BANK_UNLOCK = 5;
literal KA0C05_CMD$K_CSR_READ = 6;
literal KA0C05_CMD$K_CSR_WRITE = 7;
 
!*** MODULE $MCHECK0C05DEF ***
literal MCHECK0C05$M_TLDEV_DTYPE = %X'FFFF';
literal MCHECK0C05$M_TLDEV_SWREV = %X'FF0000';
literal MCHECK0C05$M_TLDEV_HWREV = %X'FF000000';
literal MCHECK0C05$S_TLDEV = 8;
macro MCHECK0C05$L_TLDEV = 0,0,32,0 %;
macro MCHECK0C05$V_TLDEV_DTYPE = 0,0,16,0 %;
literal MCHECK0C05$S_TLDEV_DTYPE = 16;
macro MCHECK0C05$V_TLDEV_SWREV = 0,16,8,0 %;
literal MCHECK0C05$S_TLDEV_SWREV = 8;
macro MCHECK0C05$V_TLDEV_HWREV = 0,24,8,0 %;
literal MCHECK0C05$S_TLDEV_HWREV = 8;
literal MCHECK0C05$M_TLBER_ATCE = %X'1';
literal MCHECK0C05$M_TLBER_APE = %X'2';
literal MCHECK0C05$M_TLBER_BBE = %X'4';
literal MCHECK0C05$M_TLBER_LKTO = %X'8';
literal MCHECK0C05$M_TLBER_NAE = %X'10';
literal MCHECK0C05$M_TLBER_RTCE = %X'20';
literal MCHECK0C05$M_TLBER_ACKTCE = %X'40';
literal MCHECK0C05$M_TLBER_MMRE = %X'80';
literal MCHECK0C05$M_TLBER_FNAE = %X'100';
literal MCHECK0C05$M_TLBER_REQDE = %X'200';
literal MCHECK0C05$M_TLBER_ATDE = %X'400';
literal MCHECK0C05$M_TLBER_UDE = %X'10000';
literal MCHECK0C05$M_TLBER_CWDE = %X'20000';
literal MCHECK0C05$M_TLBER_CRDE = %X'40000';
literal MCHECK0C05$M_TLBER_DS0 = %X'100000';
literal MCHECK0C05$M_TLBER_DS1 = %X'200000';
literal MCHECK0C05$M_TLBER_DS2 = %X'400000';
literal MCHECK0C05$M_TLBER_DS3 = %X'800000';
literal MCHECK0C05$M_TLBER_DTDE = %X'1000000';
literal MCHECK0C05$M_TLBER_FDTCE = %X'2000000';
literal MCHECK0C05$M_TLBER_UACKE = %X'4000000';
literal MCHECK0C05$M_TLBER_ABTCE = %X'8000000';
literal MCHECK0C05$M_TLBER_DCTCE = %X'10000000';
literal MCHECK0C05$M_TLBER_SEQE = %X'20000000';
literal MCHECK0C05$M_TLBER_DSE = %X'40000000';
literal MCHECK0C05$M_TLBER_DTO = %X'80000000';
literal MCHECK0C05$S_TLBER = 8;
macro MCHECK0C05$L_TLBER = 0,0,32,0 %;
macro MCHECK0C05$V_TLBER_ATCE = 0,0,1,0 %;
macro MCHECK0C05$V_TLBER_APE = 0,1,1,0 %;
macro MCHECK0C05$V_TLBER_BBE = 0,2,1,0 %;
macro MCHECK0C05$V_TLBER_LKTO = 0,3,1,0 %;
macro MCHECK0C05$V_TLBER_NAE = 0,4,1,0 %;
macro MCHECK0C05$V_TLBER_RTCE = 0,5,1,0 %;
macro MCHECK0C05$V_TLBER_ACKTCE = 0,6,1,0 %;
macro MCHECK0C05$V_TLBER_MMRE = 0,7,1,0 %;
macro MCHECK0C05$V_TLBER_FNAE = 0,8,1,0 %;
macro MCHECK0C05$V_TLBER_REQDE = 0,9,1,0 %;
macro MCHECK0C05$V_TLBER_ATDE = 0,10,1,0 %;
macro MCHECK0C05$V_TLBER_UDE = 0,16,1,0 %;
macro MCHECK0C05$V_TLBER_CWDE = 0,17,1,0 %;
macro MCHECK0C05$V_TLBER_CRDE = 0,18,1,0 %;
macro MCHECK0C05$V_TLBER_DS0 = 0,20,1,0 %;
macro MCHECK0C05$V_TLBER_DS1 = 0,21,1,0 %;
macro MCHECK0C05$V_TLBER_DS2 = 0,22,1,0 %;
macro MCHECK0C05$V_TLBER_DS3 = 0,23,1,0 %;
macro MCHECK0C05$V_TLBER_DTDE = 0,24,1,0 %;
macro MCHECK0C05$V_TLBER_FDTCE = 0,25,1,0 %;
macro MCHECK0C05$V_TLBER_UACKE = 0,26,1,0 %;
macro MCHECK0C05$V_TLBER_ABTCE = 0,27,1,0 %;
macro MCHECK0C05$V_TLBER_DCTCE = 0,28,1,0 %;
macro MCHECK0C05$V_TLBER_SEQE = 0,29,1,0 %;
macro MCHECK0C05$V_TLBER_DSE = 0,30,1,0 %;
macro MCHECK0C05$V_TLBER_DTO = 0,31,1,0 %;
literal MCHECK0C05$M_TLCNR_CWDD = %X'1';
literal MCHECK0C05$M_TLCNR_CRDD = %X'2';
literal MCHECK0C05$M_TLCNR_LKTOD = %X'4';
literal MCHECK0C05$M_TLCNR_DTOD = %X'8';
literal MCHECK0C05$M_TLCNR_NODE_ID = %X'F0';
literal MCHECK0C05$M_TLCNR_VCNT = %X'F00';
literal MCHECK0C05$M_TLCNR_STF_A = %X'1000';
literal MCHECK0C05$M_TLCNR_STF_B = %X'2000';
literal MCHECK0C05$M_TLCNR_STF_C = %X'4000';
literal MCHECK0C05$M_TLCNR_STF_D = %X'8000';
literal MCHECK0C05$M_TLCNR_STF_E = %X'10000';
literal MCHECK0C05$M_TLCNR_STF_F = %X'20000';
literal MCHECK0C05$M_TLCNR_STF_G = %X'40000';
literal MCHECK0C05$M_TLCNR_STF_H = %X'80000';
literal MCHECK0C05$M_TLCNR_HALT_A = %X'100000';
literal MCHECK0C05$M_TLCNR_HALT_B = %X'200000';
literal MCHECK0C05$M_TLCNR_HALT_C = %X'400000';
literal MCHECK0C05$M_TLCNR_HALT_D = %X'800000';
literal MCHECK0C05$M_TLCNR_HALT_E = %X'1000000';
literal MCHECK0C05$M_TLCNR_HALT_F = %X'2000000';
literal MCHECK0C05$M_TLCNR_HALT_G = %X'4000000';
literal MCHECK0C05$M_TLCNR_HALT_H = %X'8000000';
literal MCHECK0C05$M_TLCNR_RSTSTAT = %X'10000000';
literal MCHECK0C05$M_TLCNR_NRST = %X'40000000';
literal MCHECK0C05$M_TLCNR_LOFE = %X'80000000';
literal MCHECK0C05$S_TLCNR = 8;
macro MCHECK0C05$L_TLCNR = 0,0,32,0 %;
macro MCHECK0C05$V_TLCNR_CWDD = 0,0,1,0 %;
macro MCHECK0C05$V_TLCNR_CRDD = 0,1,1,0 %;
macro MCHECK0C05$V_TLCNR_LKTOD = 0,2,1,0 %;
macro MCHECK0C05$V_TLCNR_DTOD = 0,3,1,0 %;
macro MCHECK0C05$V_TLCNR_NODE_ID = 0,4,4,0 %;
literal MCHECK0C05$S_TLCNR_NODE_ID = 4;
macro MCHECK0C05$V_TLCNR_VCNT = 0,8,4,0 %;
literal MCHECK0C05$S_TLCNR_VCNT = 4;
macro MCHECK0C05$V_TLCNR_STF_A = 0,12,1,0 %;
macro MCHECK0C05$V_TLCNR_STF_B = 0,13,1,0 %;
macro MCHECK0C05$V_TLCNR_STF_C = 0,14,1,0 %;
macro MCHECK0C05$V_TLCNR_STF_D = 0,15,1,0 %;
macro MCHECK0C05$V_TLCNR_STF_E = 0,16,1,0 %;
macro MCHECK0C05$V_TLCNR_STF_F = 0,17,1,0 %;
macro MCHECK0C05$V_TLCNR_STF_G = 0,18,1,0 %;
macro MCHECK0C05$V_TLCNR_STF_H = 0,19,1,0 %;
macro MCHECK0C05$V_TLCNR_HALT_A = 0,20,1,0 %;
macro MCHECK0C05$V_TLCNR_HALT_B = 0,21,1,0 %;
macro MCHECK0C05$V_TLCNR_HALT_C = 0,22,1,0 %;
macro MCHECK0C05$V_TLCNR_HALT_D = 0,23,1,0 %;
macro MCHECK0C05$V_TLCNR_HALT_E = 0,24,1,0 %;
macro MCHECK0C05$V_TLCNR_HALT_F = 0,25,1,0 %;
macro MCHECK0C05$V_TLCNR_HALT_G = 0,26,1,0 %;
macro MCHECK0C05$V_TLCNR_HALT_H = 0,27,1,0 %;
macro MCHECK0C05$V_TLCNR_RSTSTAT = 0,28,1,0 %;
macro MCHECK0C05$V_TLCNR_NRST = 0,30,1,0 %;
macro MCHECK0C05$V_TLCNR_LOFE = 0,31,1,0 %;
literal MCHECK0C05$M_VID_A = %X'F';
literal MCHECK0C05$M_VID_B = %X'F0';
literal MCHECK0C05$M_VID_C = %X'F00';
literal MCHECK0C05$M_VID_D = %X'F000';
literal MCHECK0C05$M_VID_E = %X'F0000';
literal MCHECK0C05$M_VID_F = %X'F00000';
literal MCHECK0C05$M_VID_G = %X'F000000';
literal MCHECK0C05$M_VID_H = %X'F0000000';
literal MCHECK0C05$S_TLVID = 8;
macro MCHECK0C05$L_TLVID = 0,0,32,0 %;
macro MCHECK0C05$V_VID_A = 0,0,4,0 %;
literal MCHECK0C05$S_VID_A = 4;
macro MCHECK0C05$V_VID_B = 0,4,4,0 %;
literal MCHECK0C05$S_VID_B = 4;
macro MCHECK0C05$V_VID_C = 0,8,4,0 %;
literal MCHECK0C05$S_VID_C = 4;
macro MCHECK0C05$V_VID_D = 0,12,4,0 %;
literal MCHECK0C05$S_VID_D = 4;
macro MCHECK0C05$V_VID_E = 0,16,4,0 %;
literal MCHECK0C05$S_VID_E = 4;
macro MCHECK0C05$V_VID_F = 0,20,4,0 %;
literal MCHECK0C05$S_VID_F = 4;
macro MCHECK0C05$V_VID_G = 0,24,4,0 %;
literal MCHECK0C05$S_VID_G = 4;
macro MCHECK0C05$V_VID_H = 0,28,4,0 %;
literal MCHECK0C05$S_VID_H = 4;
literal MCHECK0C05$M_TLESR0_SYND0 = %X'FF';
literal MCHECK0C05$M_TLESR0_SYND1 = %X'FF00';
literal MCHECK0C05$M_TLESR0_TDE = %X'10000';
literal MCHECK0C05$M_TLESR0_TCE = %X'20000';
literal MCHECK0C05$M_TLESR0_DVTCE = %X'40000';
literal MCHECK0C05$M_TLESR0_UECC = %X'80000';
literal MCHECK0C05$M_TLESR0_CWECC = %X'100000';
literal MCHECK0C05$M_TLESR0_CRECC = %X'200000';
literal MCHECK0C05$M_TLESR0_LOFSYN = %X'80000000';
literal MCHECK0C05$S_TLESR0 = 8;
macro MCHECK0C05$L_TLESR0 = 0,0,32,0 %;
macro MCHECK0C05$V_TLESR0_SYND0 = 0,0,8,0 %;
literal MCHECK0C05$S_TLESR0_SYND0 = 8;
macro MCHECK0C05$V_TLESR0_SYND1 = 0,8,8,0 %;
literal MCHECK0C05$S_TLESR0_SYND1 = 8;
macro MCHECK0C05$V_TLESR0_TDE = 0,16,1,0 %;
macro MCHECK0C05$V_TLESR0_TCE = 0,17,1,0 %;
macro MCHECK0C05$V_TLESR0_DVTCE = 0,18,1,0 %;
macro MCHECK0C05$V_TLESR0_UECC = 0,19,1,0 %;
macro MCHECK0C05$V_TLESR0_CWECC = 0,20,1,0 %;
macro MCHECK0C05$V_TLESR0_CRECC = 0,21,1,0 %;
macro MCHECK0C05$V_TLESR0_LOFSYN = 0,31,1,0 %;
literal MCHECK0C05$M_TLESR1_SYND0 = %X'FF';
literal MCHECK0C05$M_TLESR1_SYND1 = %X'FF00';
literal MCHECK0C05$M_TLESR1_TDE = %X'10000';
literal MCHECK0C05$M_TLESR1_TCE = %X'20000';
literal MCHECK0C05$M_TLESR1_DVTCE = %X'40000';
literal MCHECK0C05$M_TLESR1_UECC = %X'80000';
literal MCHECK0C05$M_TLESR1_CWECC = %X'100000';
literal MCHECK0C05$M_TLESR1_CRECC = %X'200000';
literal MCHECK0C05$M_TLESR1_LOFSYN = %X'80000000';
literal MCHECK0C05$S_TLESR1 = 8;
macro MCHECK0C05$L_TLESR1 = 0,0,32,0 %;
macro MCHECK0C05$V_TLESR1_SYND0 = 0,0,8,0 %;
literal MCHECK0C05$S_TLESR1_SYND0 = 8;
macro MCHECK0C05$V_TLESR1_SYND1 = 0,8,8,0 %;
literal MCHECK0C05$S_TLESR1_SYND1 = 8;
macro MCHECK0C05$V_TLESR1_TDE = 0,16,1,0 %;
macro MCHECK0C05$V_TLESR1_TCE = 0,17,1,0 %;
macro MCHECK0C05$V_TLESR1_DVTCE = 0,18,1,0 %;
macro MCHECK0C05$V_TLESR1_UECC = 0,19,1,0 %;
macro MCHECK0C05$V_TLESR1_CWECC = 0,20,1,0 %;
macro MCHECK0C05$V_TLESR1_CRECC = 0,21,1,0 %;
macro MCHECK0C05$V_TLESR1_LOFSYN = 0,31,1,0 %;
literal MCHECK0C05$M_TLESR2_SYND0 = %X'FF';
literal MCHECK0C05$M_TLESR2_SYND1 = %X'FF00';
literal MCHECK0C05$M_TLESR2_TDE = %X'10000';
literal MCHECK0C05$M_TLESR2_TCE = %X'20000';
literal MCHECK0C05$M_TLESR2_DVTCE = %X'40000';
literal MCHECK0C05$M_TLESR2_UECC = %X'80000';
literal MCHECK0C05$M_TLESR2_CWECC = %X'100000';
literal MCHECK0C05$M_TLESR2_CRECC = %X'200000';
literal MCHECK0C05$M_TLESR2_LOFSYN = %X'80000000';
literal MCHECK0C05$S_TLESR2 = 8;
macro MCHECK0C05$L_TLESR2 = 0,0,32,0 %;
macro MCHECK0C05$V_TLESR2_SYND0 = 0,0,8,0 %;
literal MCHECK0C05$S_TLESR2_SYND0 = 8;
macro MCHECK0C05$V_TLESR2_SYND1 = 0,8,8,0 %;
literal MCHECK0C05$S_TLESR2_SYND1 = 8;
macro MCHECK0C05$V_TLESR2_TDE = 0,16,1,0 %;
macro MCHECK0C05$V_TLESR2_TCE = 0,17,1,0 %;
macro MCHECK0C05$V_TLESR2_DVTCE = 0,18,1,0 %;
macro MCHECK0C05$V_TLESR2_UECC = 0,19,1,0 %;
macro MCHECK0C05$V_TLESR2_CWECC = 0,20,1,0 %;
macro MCHECK0C05$V_TLESR2_CRECC = 0,21,1,0 %;
macro MCHECK0C05$V_TLESR2_LOFSYN = 0,31,1,0 %;
literal MCHECK0C05$M_TLESR3_SYND0 = %X'FF';
literal MCHECK0C05$M_TLESR3_SYND1 = %X'FF00';
literal MCHECK0C05$M_TLESR3_TDE = %X'10000';
literal MCHECK0C05$M_TLESR3_TCE = %X'20000';
literal MCHECK0C05$M_TLESR3_DVTCE = %X'40000';
literal MCHECK0C05$M_TLESR3_UECC = %X'80000';
literal MCHECK0C05$M_TLESR3_CWECC = %X'100000';
literal MCHECK0C05$M_TLESR3_CRECC = %X'200000';
literal MCHECK0C05$M_TLESR3_LOFSYN = %X'80000000';
literal MCHECK0C05$S_TLESR3 = 8;
macro MCHECK0C05$L_TLESR3 = 0,0,32,0 %;
macro MCHECK0C05$V_TLESR3_SYND0 = 0,0,8,0 %;
literal MCHECK0C05$S_TLESR3_SYND0 = 8;
macro MCHECK0C05$V_TLESR3_SYND1 = 0,8,8,0 %;
literal MCHECK0C05$S_TLESR3_SYND1 = 8;
macro MCHECK0C05$V_TLESR3_TDE = 0,16,1,0 %;
macro MCHECK0C05$V_TLESR3_TCE = 0,17,1,0 %;
macro MCHECK0C05$V_TLESR3_DVTCE = 0,18,1,0 %;
macro MCHECK0C05$V_TLESR3_UECC = 0,19,1,0 %;
macro MCHECK0C05$V_TLESR3_CWECC = 0,20,1,0 %;
macro MCHECK0C05$V_TLESR3_CRECC = 0,21,1,0 %;
macro MCHECK0C05$V_TLESR3_LOFSYN = 0,31,1,0 %;
literal MCHECK0C05$M_TLMCFG_CPU0DSBL = %X'1';
literal MCHECK0C05$M_TLMCFG_CPU1DSBL = %X'2';
literal MCHECK0C05$M_TLMCFG_BC_SIZE = %X'C';
literal MCHECK0C05$M_TLMCFG_LO_EN = %X'10';
literal MCHECK0C05$M_TLMCFG_RM_SIZE = %X'20';
literal MCHECK0C05$M_TLMCFG_BCIDLETIM = %X'3C0';
literal MCHECK0C05$M_TLMCFG_CQ_ENTRY = %X'1C00';
literal MCHECK0C05$M_TLMCFG_BQ_ENTRY = %X'E000';
literal MCHECK0C05$M_TLMCFG_SYS_DSBL = %X'10000';
literal MCHECK0C05$M_TLMCFG_EV5_DSBL = %X'20000';
literal MCHECK0C05$M_TLMCFG_FLT_DSBL = %X'40000';
literal MCHECK0C05$S_TLMCFG = 8;
macro MCHECK0C05$L_TLMCFG = 0,0,32,0 %;
macro MCHECK0C05$V_TLMCFG_CPU0DSBL = 0,0,1,0 %;
macro MCHECK0C05$V_TLMCFG_CPU1DSBL = 0,1,1,0 %;
macro MCHECK0C05$V_TLMCFG_BC_SIZE = 0,2,2,0 %;
literal MCHECK0C05$S_TLMCFG_BC_SIZE = 2;
macro MCHECK0C05$V_TLMCFG_LO_EN = 0,4,1,0 %;
macro MCHECK0C05$V_TLMCFG_RM_SIZE = 0,5,1,0 %;
macro MCHECK0C05$V_TLMCFG_BCIDLETIM = 0,6,4,0 %;
literal MCHECK0C05$S_TLMCFG_BCIDLETIM = 4;
macro MCHECK0C05$V_TLMCFG_CQ_ENTRY = 0,10,3,0 %;
literal MCHECK0C05$S_TLMCFG_CQ_ENTRY = 3;
macro MCHECK0C05$V_TLMCFG_BQ_ENTRY = 0,13,3,0 %;
literal MCHECK0C05$S_TLMCFG_BQ_ENTRY = 3;
macro MCHECK0C05$V_TLMCFG_SYS_DSBL = 0,16,1,0 %;
macro MCHECK0C05$V_TLMCFG_EV5_DSBL = 0,17,1,0 %;
macro MCHECK0C05$V_TLMCFG_FLT_DSBL = 0,18,1,0 %;
literal MCHECK0C05$M_TLIMASK0_DUART0EN = %X'1';
literal MCHECK0C05$M_TLIMASK0_IPL14_EN = %X'2';
literal MCHECK0C05$M_TLIMASK0_IPL15_EN = %X'4';
literal MCHECK0C05$M_TLIMASK0_IPL16_EN = %X'8';
literal MCHECK0C05$M_TLIMASK0_IPL17_EN = %X'10';
literal MCHECK0C05$M_TLIMASK0_IP_EN = %X'20';
literal MCHECK0C05$M_TLIMASK0_INTIM_EN = %X'40';
literal MCHECK0C05$M_TLIMASK0_HALT_EN = %X'80';
literal MCHECK0C05$M_TLIMASK0_CP_EN = %X'100';
literal MCHECK0C05$S_TLIMASK0 = 8;
macro MCHECK0C05$L_TLIMASK0 = 0,0,32,0 %;
macro MCHECK0C05$V_TLIMASK0_DUART0EN = 0,0,1,0 %;
macro MCHECK0C05$V_TLIMASK0_IPL14_EN = 0,1,1,0 %;
macro MCHECK0C05$V_TLIMASK0_IPL15_EN = 0,2,1,0 %;
macro MCHECK0C05$V_TLIMASK0_IPL16_EN = 0,3,1,0 %;
macro MCHECK0C05$V_TLIMASK0_IPL17_EN = 0,4,1,0 %;
macro MCHECK0C05$V_TLIMASK0_IP_EN = 0,5,1,0 %;
macro MCHECK0C05$V_TLIMASK0_INTIM_EN = 0,6,1,0 %;
macro MCHECK0C05$V_TLIMASK0_HALT_EN = 0,7,1,0 %;
macro MCHECK0C05$V_TLIMASK0_CP_EN = 0,8,1,0 %;
literal MCHECK0C05$M_TLIMASK1_DUART0EN = %X'1';
literal MCHECK0C05$M_TLIMASK1_IPL14_EN = %X'2';
literal MCHECK0C05$M_TLIMASK1_IPL15_EN = %X'4';
literal MCHECK0C05$M_TLIMASK1_IPL16_EN = %X'8';
literal MCHECK0C05$M_TLIMASK1_IPL17_EN = %X'10';
literal MCHECK0C05$M_TLIMASK1_IP_EN = %X'20';
literal MCHECK0C05$M_TLIMASK1_INTIM_EN = %X'40';
literal MCHECK0C05$M_TLIMASK1_HALT_EN = %X'80';
literal MCHECK0C05$M_TLIMASK1_CP_EN = %X'100';
literal MCHECK0C05$S_TLIMASK1 = 8;
macro MCHECK0C05$L_TLIMASK1 = 0,0,32,0 %;
macro MCHECK0C05$V_TLIMASK1_DUART0EN = 0,0,1,0 %;
macro MCHECK0C05$V_TLIMASK1_IPL14_EN = 0,1,1,0 %;
macro MCHECK0C05$V_TLIMASK1_IPL15_EN = 0,2,1,0 %;
macro MCHECK0C05$V_TLIMASK1_IPL16_EN = 0,3,1,0 %;
macro MCHECK0C05$V_TLIMASK1_IPL17_EN = 0,4,1,0 %;
macro MCHECK0C05$V_TLIMASK1_IP_EN = 0,5,1,0 %;
macro MCHECK0C05$V_TLIMASK1_INTIM_EN = 0,6,1,0 %;
macro MCHECK0C05$V_TLIMASK1_HALT_EN = 0,7,1,0 %;
macro MCHECK0C05$V_TLIMASK1_CP_EN = 0,8,1,0 %;
literal MCHECK0C05$M_TLISUM0_DUART0INT = %X'1';
literal MCHECK0C05$M_TLISUM0_IPL14_INT = %X'2';
literal MCHECK0C05$M_TLISUM0_IPL15_INT = %X'4';
literal MCHECK0C05$M_TLISUM0_IPL16_INT = %X'8';
literal MCHECK0C05$M_TLISUM0_IPL17_INT = %X'10';
literal MCHECK0C05$M_TLISUM0_IP_INT = %X'20';
literal MCHECK0C05$M_TLISUM0_INTIM_INT = %X'40';
literal MCHECK0C05$M_TLISUM0_IPL14 = %X'F80';
literal MCHECK0C05$M_TLISUM0_IPL15 = %X'1F000';
literal MCHECK0C05$M_TLISUM0_IPL16 = %X'3E0000';
literal MCHECK0C05$M_TLISUM0_IPL17 = %X'7C00000';
literal MCHECK0C05$M_TLISUM0_CP_HALT = %X'8000000';
literal MCHECK0C05$M_TLISUM0_HALT = %X'10000000';
literal MCHECK0C05$S_TLISUM0 = 8;
macro MCHECK0C05$L_TLISUM0 = 0,0,32,0 %;
macro MCHECK0C05$V_TLISUM0_DUART0INT = 0,0,1,0 %;
macro MCHECK0C05$V_TLISUM0_IPL14_INT = 0,1,1,0 %;
macro MCHECK0C05$V_TLISUM0_IPL15_INT = 0,2,1,0 %;
macro MCHECK0C05$V_TLISUM0_IPL16_INT = 0,3,1,0 %;
macro MCHECK0C05$V_TLISUM0_IPL17_INT = 0,4,1,0 %;
macro MCHECK0C05$V_TLISUM0_IP_INT = 0,5,1,0 %;
macro MCHECK0C05$V_TLISUM0_INTIM_INT = 0,6,1,0 %;
macro MCHECK0C05$V_TLISUM0_IPL14 = 0,7,5,0 %;
literal MCHECK0C05$S_TLISUM0_IPL14 = 5;
macro MCHECK0C05$V_TLISUM0_IPL15 = 0,12,5,0 %;
literal MCHECK0C05$S_TLISUM0_IPL15 = 5;
macro MCHECK0C05$V_TLISUM0_IPL16 = 0,17,5,0 %;
literal MCHECK0C05$S_TLISUM0_IPL16 = 5;
macro MCHECK0C05$V_TLISUM0_IPL17 = 0,22,5,0 %;
literal MCHECK0C05$S_TLISUM0_IPL17 = 5;
macro MCHECK0C05$V_TLISUM0_CP_HALT = 0,27,1,0 %;
macro MCHECK0C05$V_TLISUM0_HALT = 0,28,1,0 %;
literal MCHECK0C05$M_TLISUM1_DUART0INT = %X'1';
literal MCHECK0C05$M_TLISUM1_IPL14_INT = %X'2';
literal MCHECK0C05$M_TLISUM1_IPL15_INT = %X'4';
literal MCHECK0C05$M_TLISUM1_IPL16_INT = %X'8';
literal MCHECK0C05$M_TLISUM1_IPL17_INT = %X'10';
literal MCHECK0C05$M_TLISUM1_IP_INT = %X'20';
literal MCHECK0C05$M_TLISUM1_INTIM_INT = %X'40';
literal MCHECK0C05$M_TLISUM1_IPL14 = %X'F80';
literal MCHECK0C05$M_TLISUM1_IPL15 = %X'1F000';
literal MCHECK0C05$M_TLISUM1_IPL16 = %X'3E0000';
literal MCHECK0C05$M_TLISUM1_IPL17 = %X'7C00000';
literal MCHECK0C05$M_TLISUM1_CP_HALT = %X'8000000';
literal MCHECK0C05$M_TLISUM1_HALT = %X'10000000';
literal MCHECK0C05$S_TLISUM1 = 8;
macro MCHECK0C05$L_TLISUM1 = 0,0,32,0 %;
macro MCHECK0C05$V_TLISUM1_DUART0INT = 0,0,1,0 %;
macro MCHECK0C05$V_TLISUM1_IPL14_INT = 0,1,1,0 %;
macro MCHECK0C05$V_TLISUM1_IPL15_INT = 0,2,1,0 %;
macro MCHECK0C05$V_TLISUM1_IPL16_INT = 0,3,1,0 %;
macro MCHECK0C05$V_TLISUM1_IPL17_INT = 0,4,1,0 %;
macro MCHECK0C05$V_TLISUM1_IP_INT = 0,5,1,0 %;
macro MCHECK0C05$V_TLISUM1_INTIM_INT = 0,6,1,0 %;
macro MCHECK0C05$V_TLISUM1_IPL14 = 0,7,5,0 %;
literal MCHECK0C05$S_TLISUM1_IPL14 = 5;
macro MCHECK0C05$V_TLISUM1_IPL15 = 0,12,5,0 %;
literal MCHECK0C05$S_TLISUM1_IPL15 = 5;
macro MCHECK0C05$V_TLISUM1_IPL16 = 0,17,5,0 %;
literal MCHECK0C05$S_TLISUM1_IPL16 = 5;
macro MCHECK0C05$V_TLISUM1_IPL17 = 0,22,5,0 %;
literal MCHECK0C05$S_TLISUM1_IPL17 = 5;
macro MCHECK0C05$V_TLISUM1_CP_HALT = 0,27,1,0 %;
macro MCHECK0C05$V_TLISUM1_HALT = 0,28,1,0 %;
literal MCHECK0C05$M_TLEPAERR_E2MAPE0 = %X'1';
literal MCHECK0C05$M_TLEPAERR_E2MAPE1 = %X'2';
literal MCHECK0C05$M_TLEPAERR_M2AAPE0 = %X'4';
literal MCHECK0C05$M_TLEPAERR_M2AAPE1 = %X'8';
literal MCHECK0C05$M_TLEPAERR_DTDPE = %X'10';
literal MCHECK0C05$M_TLEPAERR_DTSPE = %X'20';
literal MCHECK0C05$M_TLEPAERR_D2ACPE = %X'40';
literal MCHECK0C05$M_TLEPAERR_SYSDERR = %X'80';
literal MCHECK0C05$M_TLEPAERR_SYSFLT = %X'100';
literal MCHECK0C05$M_TLEPAERR_RD_ERR = %X'600';
literal MCHECK0C05$M_TLEPAERR_IBOXTO = %X'1800';
literal MCHECK0C05$M_TLEPAERR_RD_PEND = %X'6000';
literal MCHECK0C05$M_TLEPAERR_CSR_W_NXM = %X'8000';
literal MCHECK0C05$M_TLEPAERR_NO_ACK = %X'30000';
literal MCHECK0C05$S_TLEPAERR = 8;
macro MCHECK0C05$L_TLEPAERR = 0,0,32,0 %;
macro MCHECK0C05$V_TLEPAERR_E2MAPE0 = 0,0,1,0 %;
macro MCHECK0C05$V_TLEPAERR_E2MAPE1 = 0,1,1,0 %;
macro MCHECK0C05$V_TLEPAERR_M2AAPE0 = 0,2,1,0 %;
macro MCHECK0C05$V_TLEPAERR_M2AAPE1 = 0,3,1,0 %;
macro MCHECK0C05$V_TLEPAERR_DTDPE = 0,4,1,0 %;
macro MCHECK0C05$V_TLEPAERR_DTSPE = 0,5,1,0 %;
macro MCHECK0C05$V_TLEPAERR_D2ACPE = 0,6,1,0 %;
macro MCHECK0C05$V_TLEPAERR_SYSDERR = 0,7,1,0 %;
macro MCHECK0C05$V_TLEPAERR_SYSFLT = 0,8,1,0 %;
macro MCHECK0C05$V_TLEPAERR_RD_ERR = 0,9,2,0 %;
literal MCHECK0C05$S_TLEPAERR_RD_ERR = 2;
macro MCHECK0C05$V_TLEPAERR_IBOXTO = 0,11,2,0 %;
literal MCHECK0C05$S_TLEPAERR_IBOXTO = 2;
macro MCHECK0C05$V_TLEPAERR_RD_PEND = 0,13,2,0 %;
literal MCHECK0C05$S_TLEPAERR_RD_PEND = 2;
macro MCHECK0C05$V_TLEPAERR_CSR_W_NXM = 0,15,1,0 %;
macro MCHECK0C05$V_TLEPAERR_NO_ACK = 0,16,2,0 %;
literal MCHECK0C05$S_TLEPAERR_NO_ACK = 2;
literal MCHECK0C05$M_TLEPDERR_A2DCPE = %X'1';
literal MCHECK0C05$M_TLEPDERR_D2DCPE0 = %X'2';
literal MCHECK0C05$M_TLEPDERR_GBTO = %X'4';
literal MCHECK0C05$S_TLEPDERR = 8;
macro MCHECK0C05$L_TLEPDERR = 0,0,32,0 %;
macro MCHECK0C05$V_TLEPDERR_A2DCPE = 0,0,1,0 %;
macro MCHECK0C05$V_TLEPDERR_D2DCPE0 = 0,1,1,0 %;
macro MCHECK0C05$V_TLEPDERR_GBTO = 0,2,1,0 %;
literal MCHECK0C05$M_TLEPMERR_A2MAPE0 = %X'1';
literal MCHECK0C05$M_TLEPMERR_A2MAPE1 = %X'2';
literal MCHECK0C05$M_TLEPMERR_D2MCPE = %X'4';
literal MCHECK0C05$M_TLEPMERR_D2DCPE1 = %X'8';
literal MCHECK0C05$M_TLEPMERR_D2DCPE2 = %X'10';
literal MCHECK0C05$M_TLEPMERR_D2DCPE3 = %X'20';
literal MCHECK0C05$M_TLEPMERR_RSTSTAT = %X'40';
literal MCHECK0C05$S_TLEPMERR = 8;
macro MCHECK0C05$L_TLEPMERR = 0,0,32,0 %;
macro MCHECK0C05$V_TLEPMERR_A2MAPE0 = 0,0,1,0 %;
macro MCHECK0C05$V_TLEPMERR_A2MAPE1 = 0,1,1,0 %;
macro MCHECK0C05$V_TLEPMERR_D2MCPE = 0,2,1,0 %;
macro MCHECK0C05$V_TLEPMERR_D2DCPE1 = 0,3,1,0 %;
macro MCHECK0C05$V_TLEPMERR_D2DCPE2 = 0,4,1,0 %;
macro MCHECK0C05$V_TLEPMERR_D2DCPE3 = 0,5,1,0 %;
macro MCHECK0C05$V_TLEPMERR_RSTSTAT = 0,6,1,0 %;
literal MCHECK0C05$M_GWHAMI_CPU = %X'1';
literal MCHECK0C05$M_GWHAMI_NID = %X'E';
literal MCHECK0C05$M_GWHAMI_TLSB_BAD = %X'10';
literal MCHECK0C05$M_GWHAMI_TLSB_CONWIN = %X'20';
literal MCHECK0C05$M_GWHAMI_MNFG_MODE = %X'40';
literal MCHECK0C05$S_WHAMI = 8;
macro MCHECK0C05$L_GWHAMI = 0,0,32,0 %;
macro MCHECK0C05$V_GWHAMI_CPU = 0,0,1,0 %;
macro MCHECK0C05$V_GWHAMI_NID = 0,1,3,0 %;
literal MCHECK0C05$S_GWHAMI_NID = 3;
macro MCHECK0C05$V_GWHAMI_TLSB_BAD = 0,4,1,0 %;
macro MCHECK0C05$V_GWHAMI_TLSB_CONWIN = 0,5,1,0 %;
macro MCHECK0C05$V_GWHAMI_MNFG_MODE = 0,6,1,0 %;
literal CPU0C05$K_ecc_max_count = 32;
!  Note that %xB2D05E00 equals 5 minutes in 100 nanosecond units
literal CPU0C05$K_ecc_threshold = -1294967296;
 
!*** MODULE $KA0E04DEF ***
literal KA0E04$M_IOC_PCI_CFG_CYC = %X'3';
literal KA0E04$M_IOC_CERR = %X'10';
literal KA0E04$M_IOC_CLOST = %X'20';
literal KA0E04$M_IOC_PCI_SOFT_RST = %X'40';
literal KA0E04$M_IOC_TLB_EN = %X'80';
literal KA0E04$M_IOC_HAE = %X'F8000000';
literal KA0E04$M_STAT0_CMD = %X'F';
literal KA0E04$M_STAT0_ERR = %X'10';
literal KA0E04$M_STAT0_LOST = %X'20';
literal KA0E04$M_STAT0_T_HIT = %X'40';
literal KA0E04$M_STAT0_T_REF = %X'80';
literal KA0E04$M_STAT0_CODE = %X'700';
literal KA0E04$M_STAT0_P_NBR = %X'FFFFE000';
literal KA0E04$M_WBASE0_WBASE = %X'FFF00000';
literal KA0E04$M_WBASE0_SG = %X'100000000';
literal KA0E04$M_WBASE0_WEN = %X'200000000';
literal KA0E04$M_WBASE1_WBASE = %X'FFF00000';
literal KA0E04$M_WBASE1_SG = %X'100000000';
literal KA0E04$M_WBASE1_WEN = %X'200000000';
literal KA0E04$M_WMASK0_WMASK = %X'FFF00000';
literal KA0E04$M_WMASK1_WMASK = %X'FFF00000';
literal KA0E04$M_TBASE0_TBASE = %X'FFF00000';
literal KA0E04$M_TBASE1_TBASE = %X'FFFFFC00';
literal KA0E04$S_KA0E04 = 424;
macro KA0E04$Q_IOC = 0,0,0,0 %;
literal KA0E04$S_IOC = 8;
macro KA0E04$V_IOC_PCI_CFG_CYC = 0,0,2,0 %;
literal KA0E04$S_IOC_PCI_CFG_CYC = 2;
macro KA0E04$V_IOC_CERR = 0,4,1,0 %;
macro KA0E04$V_IOC_CLOST = 0,5,1,0 %;
macro KA0E04$V_IOC_PCI_SOFT_RST = 0,6,1,0 %;
macro KA0E04$V_IOC_TLB_EN = 0,7,1,0 %;
macro KA0E04$V_IOC_HAE = 0,27,5,0 %;
literal KA0E04$S_IOC_HAE = 5;
macro KA0E04$b_fill1 = 8,0,0,1 %;
literal KA0E04$s_fill1 = 56;            !  this should pad from PA 180000008 to 180000040
macro KA0E04$Q_IOC_STAT0 = 64,0,0,0 %;
literal KA0E04$S_IOC_STAT0 = 8;
macro KA0E04$V_STAT0_CMD = 64,0,4,0 %;
literal KA0E04$S_STAT0_CMD = 4;
macro KA0E04$V_STAT0_ERR = 64,4,1,0 %;
macro KA0E04$V_STAT0_LOST = 64,5,1,0 %;
macro KA0E04$V_STAT0_T_HIT = 64,6,1,0 %;
macro KA0E04$V_STAT0_T_REF = 64,7,1,0 %;
macro KA0E04$V_STAT0_CODE = 64,8,3,0 %;
literal KA0E04$S_STAT0_CODE = 3;
macro KA0E04$V_STAT0_P_NBR = 64,13,19,0 %;
literal KA0E04$S_STAT0_P_NBR = 19;
macro KA0E04$b_fill2 = 72,0,0,1 %;
literal KA0E04$s_fill2 = 24;            !  pad from PA 1.8000.0048 to 1.8000.0060
macro KA0E04$Q_IOC_STAT1 = 96,0,0,0 %;
literal KA0E04$S_IOC_STAT1 = 8;
macro KA0E04$b_fill3 = 104,0,0,1 %;
literal KA0E04$s_fill3 = 24;            !  pad from PA 1.8000.0068 to 1.8000.0080
macro KA0E04$Q_IOC_TBIA = 128,0,0,0 %;
literal KA0E04$S_IOC_TBIA = 8;
macro KA0E04$b_fill4 = 136,0,0,1 %;
literal KA0E04$s_fill4 = 120;           !  pad from PA 1.8000.0088 to 1.8000.0100
macro KA0E04$Q_IOC_WBASE0 = 256,0,0,0 %;
literal KA0E04$S_IOC_WBASE0 = 8;
macro KA0E04$V_WBASE0_WBASE = 256,20,12,0 %;
literal KA0E04$S_WBASE0_WBASE = 12;
macro KA0E04$V_WBASE0_SG = 260,0,1,0 %;
macro KA0E04$V_WBASE0_WEN = 260,1,1,0 %;
macro KA0E04$b_fill5 = 264,0,0,1 %;
literal KA0E04$s_fill5 = 24;            !  pad from PA 1.8000.0108 to 1.8000.0120
macro KA0E04$Q_IOC_WBASE1 = 288,0,0,0 %;
literal KA0E04$S_IOC_WBASE1 = 8;
macro KA0E04$V_WBASE1_WBASE = 288,20,12,0 %;
literal KA0E04$S_WBASE1_WBASE = 12;
macro KA0E04$V_WBASE1_SG = 292,0,1,0 %;
macro KA0E04$V_WBASE1_WEN = 292,1,1,0 %;
macro KA0E04$b_fill6 = 296,0,0,1 %;
literal KA0E04$s_fill6 = 24;            !  pad from PA 1.8000.0128 to 1.8000.0140
macro KA0E04$Q_IOC_WMASK0 = 320,0,0,0 %;
literal KA0E04$S_IOC_WMASK0 = 8;
macro KA0E04$V_WMASK0_WMASK = 320,20,12,0 %;
literal KA0E04$S_WMASK0_WMASK = 12;
macro KA0E04$b_fill7 = 328,0,0,1 %;
literal KA0E04$s_fill7 = 24;            !  pad from PA 1.8000.0148 to 1.8000.0160
macro KA0E04$Q_IOC_WMASK1 = 352,0,0,0 %;
literal KA0E04$S_IOC_WMASK1 = 8;
macro KA0E04$V_WMASK1_WMASK = 352,20,12,0 %;
literal KA0E04$S_WMASK1_WMASK = 12;
macro KA0E04$b_fill8 = 360,0,0,1 %;
literal KA0E04$s_fill8 = 24;            !  pad from PA 1.8000.0168 to 1.8000.0180
macro KA0E04$Q_IOC_TBASE0 = 384,0,0,0 %;
literal KA0E04$S_IOC_TBASE0 = 8;
macro KA0E04$V_TBASE0_TBASE = 384,20,12,0 %;
literal KA0E04$S_TBASE0_TBASE = 12;
macro KA0E04$b_fill9 = 392,0,0,1 %;
literal KA0E04$s_fill9 = 24;            !  pad from PA 1.8000.0188 to 1.8000.01A0
macro KA0E04$Q_IOC_TBASE1 = 416,0,0,0 %;
literal KA0E04$S_IOC_TBASE1 = 8;
macro KA0E04$V_TBASE1_TBASE = 416,10,22,0 %;
literal KA0E04$S_TBASE1_TBASE = 22;
literal KA0E04$K_OPDRIVER_XMT_ISR = 1;
literal KA0E04$K_OPDRIVER_RCV_ISR = 12;
 
!*** MODULE $KA0F05DEF ***
literal KA0F05$M_CIA_CTRL_PCI_EN = %X'1';
literal KA0F05$M_CIA_CTRL_PCI_LOCK_EN = %X'2';
literal KA0F05$M_CIA_CTRL_PCI_LOOP_EN = %X'4';
literal KA0F05$M_CIA_CTRL_FST_BB_EN = %X'8';
literal KA0F05$M_CIA_CTRL_MST_EN = %X'10';
literal KA0F05$M_CIA_CTRL_MEM_EN = %X'20';
literal KA0F05$M_CIA_CTRL_REQ64_EN = %X'40';
literal KA0F05$M_CIA_CTRL_ACK64_EN = %X'80';
literal KA0F05$M_CIA_CTRL_ADDR_PE_EN = %X'100';
literal KA0F05$M_CIA_CTRL_PERR_EN = %X'200';
literal KA0F05$M_CIA_CTRL_FILL_ERR_EN = %X'400';
literal KA0F05$M_CIA_CTRL_ECC_CHK_EN = %X'1000';
literal KA0F05$M_CIA_CTRL_CACK_EN_PE = %X'2000';
literal KA0F05$M_CIA_CTRL_CON_IDLE_BC = %X'4000';
literal KA0F05$M_CIA_CTRL_CSR_IOA_BYP = %X'8000';
literal KA0F05$M_CIA_CTRL_IO_FLUSH_REQ = %X'10000';
literal KA0F05$M_CIA_CTRL_CPU_FLUSH_REQ = %X'20000';
literal KA0F05$M_CIA_CTRL_ARB_EV5_EN = %X'40000';
literal KA0F05$M_CIA_CTRL_EN_ARB_LINK = %X'80000';
literal KA0F05$M_CIA_CTRL_RD_TYP = %X'300000';
literal KA0F05$M_CIA_CTRL_RL_TYP = %X'3000000';
literal KA0F05$M_CIA_CTRL_RM_TYP = %X'30000000';
literal KA0F05$M_CIA_CNFG_PCI_WIDTH = %X'100';
literal KA0F05$M_CIA_CNFG_IOD_WIDTH = %X'10000';
literal KA0F05$M_HAE_MEM_REG_3 = %X'FC';
literal KA0F05$M_HAE_MEM_REG_2 = %X'F800';
literal KA0F05$M_HAE_MEM_REG_1 = %X'E0000000';
literal KA0F05$M_HAE_IO = %X'FE000000';
literal KA0F05$M_FROM_EN = %X'1';
literal KA0F05$M_USE_CHECK = %X'2';
literal KA0F05$M_FPE_PCI = %X'30000000';
literal KA0F05$M_FPE_TO_EV5 = %X'80000000';
literal KA0F05$M_CPU_ERR0_ADDR = %X'FFFFFFF0';
literal KA0F05$M_CPU_ERR1_3432 = %X'7';
literal KA0F05$M_CPU_ERR1_39 = %X'80';
literal KA0F05$M_CPU_ERR1_CMD = %X'F00';
literal KA0F05$M_CPU_ERR1_INT4_VALID = %X'F000';
literal KA0F05$M_CPU_ERR1_AC_PAR = %X'200000';
literal KA0F05$M_CPU_ERR1_FPE = %X'40000000';
literal KA0F05$M_CPU_ERR1_PE = %X'80000000';
literal KA0F05$M_ERR_CORR_ECC = %X'1';
literal KA0F05$M_ERR_UNC_ECC = %X'2';
literal KA0F05$M_ERR_CPU_PE = %X'4';
literal KA0F05$M_ERR_MEM_NEM = %X'8';
literal KA0F05$M_ERR_PCI_SERR = %X'10';
literal KA0F05$M_ERR_PCI_PERR = %X'20';
literal KA0F05$M_ERR_PCI_ADR_PE = %X'40';
literal KA0F05$M_ERR_M_ABORT = %X'80';
literal KA0F05$M_ERR_T_ABORT = %X'100';
literal KA0F05$M_ERR_PA_PTE_INV = %X'200';
literal KA0F05$M_ERR_FROM_WRT_ERR = %X'400';
literal KA0F05$M_ERR_IOA_TIMEOUT = %X'800';
literal KA0F05$M_ERR_LOST_CORR_ECC = %X'10000';
literal KA0F05$M_ERR_LOST_UNC_ECC = %X'20000';
literal KA0F05$M_ERR_LOST_CPU_PE = %X'40000';
literal KA0F05$M_ERR_LOST_MEM_NEM = %X'80000';
literal KA0F05$M_ERR_LOST_PCI_SERR = %X'100000';
literal KA0F05$M_ERR_LOST_PCI_PERR = %X'200000';
literal KA0F05$M_ERR_LOST_PCI_ADR_PE = %X'400000';
literal KA0F05$M_ERR_LOST_M_ABORT = %X'800000';
literal KA0F05$M_ERR_LOST_T_ABORT = %X'1000000';
literal KA0F05$M_ERR_LOST_PA_PTE_INV = %X'2000000';
literal KA0F05$M_ERR_LOST_FROM_WRT_ERR = %X'4000000';
literal KA0F05$M_ERR_LOST_IOA_TIMEOUT = %X'8000000';
literal KA0F05$M_ERR_VALID = %X'80000000';
literal DM_K_IDLE = 0;
literal DM_K_RESTART = 4096;
literal DM_K_IOW_64 = 8192;
literal DM_K_IOW_32 = 12288;
literal DM_K_R_4 = 16384;
literal DM_K_NONE = 20480;
literal DM_K_DMA_RD = 24576;
literal DM_K_DMA_WR = 28672;
literal DM_K_GRU_WR = 32768;
literal DM_K_GRU_RD = 36864;
literal DM_K_CSR_RD = 40960;
literal DM_K_PCI_RD = 45056;
literal KA0F05$M_STAT_MEM_SOURCE = %X'2';
literal KA0F05$M_STAT_IO_QUEUE = %X'3C';
literal KA0F05$M_STAT_CPU_QUEUE = %X'1C0';
literal KA0F05$M_STAT_TLB_MISS = %X'200';
literal KA0F05$M_STAT_DM_STAT = %X'3C00';
literal KA0F05$M_STAT_PA_CPU_RES = %X'C000';
literal KA0F05$M_MASK_CORR_ECC_ERR = %X'1';
literal KA0F05$M_MASK_UNC_ECC_ERR = %X'2';
literal KA0F05$M_MASK_CPU_PE = %X'4';
literal KA0F05$M_MASK_MEM_NEM = %X'8';
literal KA0F05$M_MASK_PCI_SERR = %X'10';
literal KA0F05$M_MASK_PCI_PERR = %X'20';
literal KA0F05$M_MASK_PCI_ADR_PE = %X'40';
literal KA0F05$M_MASK_M_ABORT = %X'80';
literal KA0F05$M_MASK_T_ABORT = %X'100';
literal KA0F05$M_MASK_PA_PTE_INV = %X'200';
literal KA0F05$M_MASK_FROM_WRT_ERR = %X'400';
literal KA0F05$M_MASK_IOA_TIMEOUT = %X'800';
literal KA0F05$M_CIA_SYNDROME = %X'FF';
literal KA0F05$M_MPSR0_ADDR_H = %X'FFFFFFF0';
literal KA0F05$M_MPSR1_ADDR_H = %X'3';
literal KA0F05$M_MPSR1_ADDR_39 = %X'80';
literal KA0F05$M_MPSR1_CMD_H = %X'F00';
literal KA0F05$M_MPSR1_PORT_MASK = %X'F000';
literal KA0F05$M_MPSR1_SEQ_ST = %X'F0000';
literal KA0F05$M_MPSR1_PORT_SRC = %X'100000';
literal KA0F05$M_MPSR1_SET_SEL = %X'1F000000';
literal KA0F05$M_PCIE_CMD = %X'F';
literal KA0F05$M_PCIE_LOCK_STATE = %X'10';
literal KA0F05$M_PCIE_DAC_CYCLE = %X'20';
literal KA0F05$M_PCIE_WINDOW = %X'F00';
literal KA0F05$M_PCIE_MSTR_STATE = %X'F0000';
literal KA0F05$M_PCIE_TRGT_STATE = %X'700000';
literal KA0F05$M_MCR_MEM_SIZE = %X'1';
literal KA0F05$M_MCR_CACHE_SIZE = %X'70';
literal KA0F05$M_MCR_REF_RATE = %X'3FF00';
literal KA0F05$M_MCR_REF_BURST = %X'C0000';
literal KA0F05$M_MCR_TMG_R0 = %X'300000';
literal KA0F05$M_MCR_LONG_CBR_CAS = %X'400000';
literal KA0F05$M_MCR_DLY_IDLE_BC = %X'C000000';
literal KA0F05$M_MCR_EARLY_IDLE_BC = %X'20000000';
literal KA0F05$M_MBA0_S0_VALID = %X'1';
literal KA0F05$M_MBA0_ROW_TYPE = %X'6';
literal KA0F05$M_MBA0_MASK = %X'1F0';
literal KA0F05$M_MBA0_S1_VALID = %X'8000';
literal KA0F05$M_MBA0_PATTERN = %X'3FF0000';
literal KA0F05$M_MBA0_TIMING = %X'30000000';
literal KA0F05$M_MBA0_RESERVED_5 = %X'C0000000';
literal KA0F05$M_MBA2_S0_VALID = %X'1';
literal KA0F05$M_MBA2_ROW_TYPE = %X'6';
literal KA0F05$M_MBA2_MASK = %X'1F0';
literal KA0F05$M_MBA2_S1_VALID = %X'8000';
literal KA0F05$M_MBA2_PATTERN = %X'3FF0000';
literal KA0F05$M_MBA2_TIMING = %X'30000000';
literal KA0F05$M_MBA4_S0_VALID = %X'1';
literal KA0F05$M_MBA4_ROW_TYPE = %X'6';
literal KA0F05$M_MBA4_MASK = %X'1F0';
literal KA0F05$M_MBA4_S1_VALID = %X'8000';
literal KA0F05$M_MBA4_PATTERN = %X'3FF0000';
literal KA0F05$M_MBA4_TIMING = %X'30000000';
literal KA0F05$M_MBA6_S0_VALID = %X'1';
literal KA0F05$M_MBA6_ROW_TYPE = %X'6';
literal KA0F05$M_MBA6_MASK = %X'1F0';
literal KA0F05$M_MBA6_S1_VALID = %X'8000';
literal KA0F05$M_MBA6_PATTERN = %X'3FF0000';
literal KA0F05$M_MBA6_TIMING = %X'30000000';
literal KA0F05$M_MBA8_S0_VALID = %X'1';
literal KA0F05$M_MBA8_ROW_TYPE = %X'6';
literal KA0F05$M_MBA8_MASK = %X'1F0';
literal KA0F05$M_MBA8_S1_VALID = %X'8000';
literal KA0F05$M_MBA8_PATTERN = %X'3FF0000';
literal KA0F05$M_MBA8_TIMING = %X'30000000';
literal KA0F05$M_MBAA_S0_VALID = %X'1';
literal KA0F05$M_MBAA_ROW_TYPE = %X'6';
literal KA0F05$M_MBAA_MASK = %X'1F0';
literal KA0F05$M_MBAA_S1_VALID = %X'8000';
literal KA0F05$M_MBAA_PATTERN = %X'3FF0000';
literal KA0F05$M_MBAA_TIMING = %X'30000000';
literal KA0F05$M_MBAC_S0_VALID = %X'1';
literal KA0F05$M_MBAC_ROW_TYPE = %X'6';
literal KA0F05$M_MBAC_MASK = %X'1F0';
literal KA0F05$M_MBAC_S1_VALID = %X'8000';
literal KA0F05$M_MBAC_PATTERN = %X'3FF0000';
literal KA0F05$M_MBAC_TIMING = %X'30000000';
literal KA0F05$M_MBAE_S0_VALID = %X'1';
literal KA0F05$M_MBAE_ROW_TYPE = %X'6';
literal KA0F05$M_MBAE_MASK = %X'1F0';
literal KA0F05$M_MBAE_S1_VALID = %X'8000';
literal KA0F05$M_MBAE_PATTERN = %X'3FF0000';
literal KA0F05$M_MBAE_TIMING = %X'30000000';
literal KA0F05$M_TMG0_R1 = %X'3';
literal KA0F05$M_TMG0_R2 = %X'C';
literal KA0F05$M_TMG0_R3 = %X'30';
literal KA0F05$M_TMG0_R4 = %X'C0';
literal KA0F05$M_TMG0_R5 = %X'300';
literal KA0F05$M_TMG0_R6 = %X'C00';
literal KA0F05$M_TMG0_W1 = %X'7000';
literal KA0F05$M_TMG0_W4 = %X'38000';
literal KA0F05$M_TMG0_PRE = %X'40000';
literal KA0F05$M_TMG0_V3 = %X'180000';
literal KA0F05$M_TMG0_V4 = %X'600000';
literal KA0F05$M_TMG0_V5 = %X'3000000';
literal KA0F05$M_TMG0_V6 = %X'C000000';
literal KA0F05$M_TMG0_RV = %X'30000000';
literal KA0F05$M_TMG0_RD_DLY = %X'C0000000';
literal KA0F05$M_TMG1_R1 = %X'3';
literal KA0F05$M_TMG1_R2 = %X'C';
literal KA0F05$M_TMG1_R3 = %X'30';
literal KA0F05$M_TMG1_R4 = %X'C0';
literal KA0F05$M_TMG1_R5 = %X'300';
literal KA0F05$M_TMG1_R6 = %X'C00';
literal KA0F05$M_TMG1_W1 = %X'7000';
literal KA0F05$M_TMG1_W4 = %X'38000';
literal KA0F05$M_TMG1_PRE = %X'40000';
literal KA0F05$M_TMG1_V3 = %X'180000';
literal KA0F05$M_TMG1_V4 = %X'600000';
literal KA0F05$M_TMG1_V5 = %X'3000000';
literal KA0F05$M_TMG1_V6 = %X'C000000';
literal KA0F05$M_TMG1_RV = %X'30000000';
literal KA0F05$M_TMG1_RD_DLY = %X'C0000000';
literal KA0F05$M_TMG2_R1 = %X'3';
literal KA0F05$M_TMG2_R2 = %X'C';
literal KA0F05$M_TMG2_R3 = %X'30';
literal KA0F05$M_TMG2_R4 = %X'C0';
literal KA0F05$M_TMG2_R5 = %X'300';
literal KA0F05$M_TMG2_R6 = %X'C00';
literal KA0F05$M_TMG2_W1 = %X'7000';
literal KA0F05$M_TMG2_W4 = %X'38000';
literal KA0F05$M_TMG2_PRE = %X'40000';
literal KA0F05$M_TMG2_V3 = %X'180000';
literal KA0F05$M_TMG2_V4 = %X'600000';
literal KA0F05$M_TMG2_V5 = %X'3000000';
literal KA0F05$M_TMG2_V6 = %X'C000000';
literal KA0F05$M_TMG2_RV = %X'30000000';
literal KA0F05$M_TMG2_RD_DLY = %X'C0000000';
literal KA0F05$M_TBIA_CSR_WR_DATA = %X'3';
literal KA0F05$M_WBASE0_W_EN = %X'1';
literal KA0F05$M_WBASE0_SG_EN = %X'2';
literal KA0F05$M_WBASE0_MEMCS_EN = %X'4';
literal KA0F05$M_WBASE0_DAC_EN = %X'8';
literal KA0F05$M_WBASE0_BASE = %X'FFF00000';
literal KA0F05$M_WMASK0_MASK = %X'FFF00000';
literal KA0F05$M_TBASE0_BASE = %X'FFFFFF00';
literal KA0F05$M_WBASE1_W_EN = %X'1';
literal KA0F05$M_WBASE1_SG_EN = %X'2';
literal KA0F05$M_WBASE1_MEMCS_EN = %X'4';
literal KA0F05$M_WBASE1_DAC_EN = %X'8';
literal KA0F05$M_WBASE1_BASE = %X'FFF00000';
literal KA0F05$M_WMASK1_MASK = %X'FFF00000';
literal KA0F05$M_TBASE1_BASE = %X'FFFFFF00';
literal KA0F05$M_WBASE2_W_EN = %X'1';
literal KA0F05$M_WBASE2_SG_EN = %X'2';
literal KA0F05$M_WBASE2_MEMCS_EN = %X'4';
literal KA0F05$M_WBASE2_DAC_EN = %X'8';
literal KA0F05$M_WBASE2_BASE = %X'FFF00000';
literal KA0F05$M_WMASK2_MASK = %X'FFF00000';
literal KA0F05$M_TBASE2_BASE = %X'FFFFFF00';
literal KA0F05$M_WBASE3_W_EN = %X'1';
literal KA0F05$M_WBASE3_SG_EN = %X'2';
literal KA0F05$M_WBASE3_MEMCS_EN = %X'4';
literal KA0F05$M_WBASE3_DAC_EN = %X'8';
literal KA0F05$M_WBASE3_BASE = %X'FFF00000';
literal KA0F05$M_WMASK3_MASK = %X'FFF00000';
literal KA0F05$M_TBASE3_BASE = %X'FFFFFF00';
literal KA0F05$M_DAC_BASE = %X'FF';
literal KA0F05$M_LTB0_VALID = %X'1';
literal KA0F05$M_LTB0_LOCKED = %X'2';
literal KA0F05$M_LTB0_DAC = %X'4';
literal KA0F05$M_LTB0_TAG = %X'FFFF8000';
literal KA0F05$M_LTB1_VALID = %X'1';
literal KA0F05$M_LTB1_LOCKED = %X'2';
literal KA0F05$M_LTB1_DAC = %X'4';
literal KA0F05$M_LTB1_TAG = %X'FFFF8000';
literal KA0F05$M_LTB2_VALID = %X'1';
literal KA0F05$M_LTB2_LOCKED = %X'2';
literal KA0F05$M_LTB2_DAC = %X'4';
literal KA0F05$M_LTB2_TAG = %X'FFFF8000';
literal KA0F05$M_LTB3_VALID = %X'1';
literal KA0F05$M_LTB3_LOCKED = %X'2';
literal KA0F05$M_LTB3_DAC = %X'4';
literal KA0F05$M_LTB3_TAG = %X'FFFF8000';
literal KA0F05$M_TB0_VALID = %X'1';
literal KA0F05$M_TB0_DAC = %X'4';
literal KA0F05$M_TB0_TAG = %X'FFFF8000';
literal KA0F05$M_TB1_VALID = %X'1';
literal KA0F05$M_TB1_DAC = %X'4';
literal KA0F05$M_TB1_TAG = %X'FFFF8000';
literal KA0F05$M_TB2_VALID = %X'1';
literal KA0F05$M_TB2_DAC = %X'4';
literal KA0F05$M_TB2_TAG = %X'FFFF8000';
literal KA0F05$M_TB3_VALID = %X'1';
literal KA0F05$M_TB3_DAC = %X'4';
literal KA0F05$M_TB3_TAG = %X'FFFF8000';
literal KA0F05$M_TB0_PAGE0_VALID = %X'1';
literal KA0F05$M_TB0_PAGE0_ADDR = %X'3FFFFE';
literal KA0F05$M_TB0_PAGE1_VALID = %X'1';
literal KA0F05$M_TB0_PAGE1_ADDR = %X'3FFFFE';
literal KA0F05$M_TB0_PAGE2_VALID = %X'1';
literal KA0F05$M_TB0_PAGE2_ADDR = %X'3FFFFE';
literal KA0F05$M_TB0_PAGE3_VALID = %X'1';
literal KA0F05$M_TB0_PAGE3_ADDR = %X'3FFFFE';
literal KA0F05$M_TB1_PAGE0_VALID = %X'1';
literal KA0F05$M_TB1_PAGE0_ADDR = %X'3FFFFE';
literal KA0F05$M_TB1_PAGE1_VALID = %X'1';
literal KA0F05$M_TB1_PAGE1_ADDR = %X'3FFFFE';
literal KA0F05$M_TB1_PAGE2_VALID = %X'1';
literal KA0F05$M_TB1_PAGE2_ADDR = %X'3FFFFE';
literal KA0F05$M_TB1_PAGE3_VALID = %X'1';
literal KA0F05$M_TB1_PAGE3_ADDR = %X'3FFFFE';
literal KA0F05$M_TB2_PAGE0_VALID = %X'1';
literal KA0F05$M_TB2_PAGE0_ADDR = %X'3FFFFE';
literal KA0F05$M_TB2_PAGE1_VALID = %X'1';
literal KA0F05$M_TB2_PAGE1_ADDR = %X'3FFFFE';
literal KA0F05$M_TB2_PAGE2_VALID = %X'1';
literal KA0F05$M_TB2_PAGE2_ADDR = %X'3FFFFE';
literal KA0F05$M_TB2_PAGE3_VALID = %X'1';
literal KA0F05$M_TB2_PAGE3_ADDR = %X'3FFFFE';
literal KA0F05$M_TB3_PAGE0_VALID = %X'1';
literal KA0F05$M_TB3_PAGE0_ADDR = %X'3FFFFE';
literal KA0F05$M_TB3_PAGE1_VALID = %X'1';
literal KA0F05$M_TB3_PAGE1_ADDR = %X'3FFFFE';
literal KA0F05$M_TB3_PAGE2_VALID = %X'1';
literal KA0F05$M_TB3_PAGE2_ADDR = %X'3FFFFE';
literal KA0F05$M_TB3_PAGE3_VALID = %X'1';
literal KA0F05$M_TB3_PAGE3_ADDR = %X'3FFFFE';
literal KA0F05$M_TB4_PAGE0_VALID = %X'1';
literal KA0F05$M_TB4_PAGE0_ADDR = %X'3FFFFE';
literal KA0F05$M_TB4_PAGE1_VALID = %X'1';
literal KA0F05$M_TB4_PAGE1_ADDR = %X'3FFFFE';
literal KA0F05$M_TB4_PAGE2_VALID = %X'1';
literal KA0F05$M_TB4_PAGE2_ADDR = %X'3FFFFE';
literal KA0F05$M_TB4_PAGE3_VALID = %X'1';
literal KA0F05$M_TB4_PAGE3_ADDR = %X'3FFFFE';
literal KA0F05$M_TB5_PAGE0_VALID = %X'1';
literal KA0F05$M_TB5_PAGE0_ADDR = %X'3FFFFE';
literal KA0F05$M_TB5_PAGE1_VALID = %X'1';
literal KA0F05$M_TB5_PAGE1_ADDR = %X'3FFFFE';
literal KA0F05$M_TB5_PAGE2_VALID = %X'1';
literal KA0F05$M_TB5_PAGE2_ADDR = %X'3FFFFE';
literal KA0F05$M_TB5_PAGE3_VALID = %X'1';
literal KA0F05$M_TB5_PAGE3_ADDR = %X'3FFFFE';
literal KA0F05$M_TB6_PAGE0_VALID = %X'1';
literal KA0F05$M_TB6_PAGE0_ADDR = %X'3FFFFE';
literal KA0F05$M_TB6_PAGE1_VALID = %X'1';
literal KA0F05$M_TB6_PAGE1_ADDR = %X'3FFFFE';
literal KA0F05$M_TB6_PAGE2_VALID = %X'1';
literal KA0F05$M_TB6_PAGE2_ADDR = %X'3FFFFE';
literal KA0F05$M_TB6_PAGE3_VALID = %X'1';
literal KA0F05$M_TB6_PAGE3_ADDR = %X'3FFFFE';
literal KA0F05$M_TB7_PAGE0_VALID = %X'1';
literal KA0F05$M_TB7_PAGE0_ADDR = %X'3FFFFE';
literal KA0F05$M_TB7_PAGE1_VALID = %X'1';
literal KA0F05$M_TB7_PAGE1_ADDR = %X'3FFFFE';
literal KA0F05$M_TB7_PAGE2_VALID = %X'1';
literal KA0F05$M_TB7_PAGE2_ADDR = %X'3FFFFE';
literal KA0F05$M_TB7_PAGE3_VALID = %X'1';
literal KA0F05$M_TB7_PAGE3_ADDR = %X'3FFFFE';
literal KA0F05$M_GRU_INT_CLR = %X'1';
literal KA0F05$M_GRU_CNFG_CLK_DIV = %X'F0';
literal KA0F05$M_GRU_CNFG_CACHE_SP = %X'1800';
literal KA0F05$M_GRU_CNFG_CACHE_SZ = %X'E000';
literal KA0F05$M_GRU_CNFG_MMB0_CFG = %X'F0000';
literal KA0F05$M_GRU_CNFG_MMB1_CFG = %X'F000000';
literal KA0F05$M_GRU_CNFG_SS7_MMB0 = %X'3';
literal KA0F05$M_GRU_CNFG_SS6_MMB0 = %X'C';
literal KA0F05$M_GRU_CNFG_SS5_MMB0 = %X'30';
literal KA0F05$M_GRU_CNFG_SS4_MMB0 = %X'C0';
literal KA0F05$M_GRU_CNFG_SS3_MMB0 = %X'300';
literal KA0F05$M_GRU_CNFG_SS2_MMB0 = %X'C00';
literal KA0F05$M_GRU_CNFG_SS1_MMB0 = %X'3000';
literal KA0F05$M_GRU_CNFG_SS0_MMB0 = %X'C000';
literal KA0F05$M_GRU_CNFG_SS7_MMB1 = %X'30000';
literal KA0F05$M_GRU_CNFG_SS6_MMB1 = %X'C0000';
literal KA0F05$M_GRU_CNFG_SS5_MMB1 = %X'300000';
literal KA0F05$M_GRU_CNFG_SS4_MMB1 = %X'C00000';
literal KA0F05$M_GRU_CNFG_SS3_MMB1 = %X'3000000';
literal KA0F05$M_GRU_CNFG_SS2_MMB1 = %X'C000000';
literal KA0F05$M_GRU_CNFG_SS1_MMB1 = %X'30000000';
literal KA0F05$M_GRU_CNFG_SS0_MMB1 = %X'C0000000';
literal KA0F05$S_KA0F05 = 59656;
!  CIA ASIC revision 8740000080
macro KA0F05$L_PCI_CIA_REV = 128,0,32,1 %;
macro KA0F05$B_CIA_REV = 128,0,8,1 %;   !  CIA revision
!  PCI master latency timeout  87400000C0
macro KA0F05$L_PCI_LAT = 192,0,32,1 %;
macro KA0F05$B_PCI_LATENCY = 193,0,8,1 %; !  CIA revision
!  CIA Control register	8740000100
macro KA0F05$L_CIA_CTL = 256,0,32,1 %;
macro KA0F05$V_CIA_CTRL_PCI_EN = 256,0,1,0 %; ! CIA disable/enable resets to PCI	
macro KA0F05$V_CIA_CTRL_PCI_LOCK_EN = 256,1,1,0 %; ! CIA locks from PCI enable
macro KA0F05$V_CIA_CTRL_PCI_LOOP_EN = 256,2,1,0 %; ! CIA loopback enable 
macro KA0F05$V_CIA_CTRL_FST_BB_EN = 256,3,1,0 %; ! CIA fast back-to-back enable 
macro KA0F05$V_CIA_CTRL_MST_EN = 256,4,1,0 %; ! CIA is a PCI master enable 
macro KA0F05$V_CIA_CTRL_MEM_EN = 256,5,1,0 %; ! CIA is a PCI target enable
macro KA0F05$V_CIA_CTRL_REQ64_EN = 256,6,1,0 %; ! CIA will request 64bit PCI txactions
macro KA0F05$V_CIA_CTRL_ACK64_EN = 256,7,1,0 %; ! CIA will accept 64bit PCI  txactions
macro KA0F05$V_CIA_CTRL_ADDR_PE_EN = 256,8,1,0 %; ! CIA will check address parity enable
macro KA0F05$V_CIA_CTRL_PERR_EN = 256,9,1,0 %; ! CIA will check PCI data enable
macro KA0F05$V_CIA_CTRL_FILL_ERR_EN = 256,10,1,0 %; ! CIA will assert fill_err enable
macro KA0F05$V_CIA_CTRL_ECC_CHK_EN = 256,12,1,0 %; ! CIA checks IOD data enable
macro KA0F05$V_CIA_CTRL_CACK_EN_PE = 256,13,1,0 %; ! CIA checks c/a parity on CACK
macro KA0F05$V_CIA_CTRL_CON_IDLE_BC = 256,14,1,0 %; ! CIA generated contig. IDLE_BC
macro KA0F05$V_CIA_CTRL_CSR_IOA_BYP = 256,15,1,0 %; ! CIA bypasses I/O addr queue
macro KA0F05$V_CIA_CTRL_IO_FLUSH_REQ = 256,16,1,0 %; ! Controls response to PCI FLUSH_REQ
macro KA0F05$V_CIA_CTRL_CPU_FLUSH_REQ = 256,17,1,0 %; ! Controls response to PCI FLUSH_REQ
macro KA0F05$V_CIA_CTRL_ARB_EV5_EN = 256,18,1,0 %; ! Enable bypass path ev5 to mem/io
macro KA0F05$V_CIA_CTRL_EN_ARB_LINK = 256,19,1,0 %;
macro KA0F05$V_CIA_CTRL_RD_TYP = 256,20,2,0 %;
literal KA0F05$S_CIA_CTRL_RD_TYP = 2;   ! Control prefetch algorithm RD
macro KA0F05$V_CIA_CTRL_RL_TYP = 256,24,2,0 %;
literal KA0F05$S_CIA_CTRL_RL_TYP = 2;   ! Control prefetch algorithm RL
macro KA0F05$V_CIA_CTRL_RM_TYP = 256,28,2,0 %;
literal KA0F05$S_CIA_CTRL_RM_TYP = 2;   ! Control prefetch algorithm RM
!  CIA Config => Size information of the two busses 8740000200
macro KA0F05$L_CIA_CONFIG = 512,0,32,1 %;
macro KA0F05$V_CIA_CNFG_PCI_WIDTH = 512,8,1,0 %; !  Bit is set -> 64bit PCI
macro KA0F05$V_CIA_CNFG_IOD_WIDTH = 512,16,1,0 %; !  Bit is set -> 64bit IOD
!  HAE MEM => Extends sparse space addr to full 32 bits 8740000400
macro KA0F05$L_HAE_MEM = 1024,0,32,1 %;
macro KA0F05$V_HAE_MEM_REG_3 = 1024,2,6,0 %;
literal KA0F05$S_HAE_MEM_REG_3 = 6;     !  High order sparse bits
macro KA0F05$V_HAE_MEM_REG_2 = 1024,11,5,0 %;
literal KA0F05$S_HAE_MEM_REG_2 = 5;     !  High order sparse bits
macro KA0F05$V_HAE_MEM_REG_1 = 1024,29,3,0 %;
literal KA0F05$S_HAE_MEM_REG_1 = 3;     !  High order sparse bits
!  HAE IO => Extends sparse space addr to full 32 bits 8740000440
macro KA0F05$L_HAE_IO = 1088,0,32,1 %;
macro KA0F05$V_HAE_IO = 1088,25,7,0 %;
literal KA0F05$S_HAE_IO = 7;            !  High order sparse bits
!  CFG => Low two address bits during access to PCI COnfig space 8740000480
macro KA0F05$L_CFG = 1152,0,32,1 %;
macro KA0F05$V_CFG_BITS = 1152,0,2,0 %; !  Low order bits of config space ref
!  CACK_EN Enable CIA's response to EV5 commands 840000600
macro KA0F05$L_CACK_EN = 1536,0,32,1 %;
macro KA0F05$V_CACK_EN_BITS = 1536,0,4,0 %; !  Control CIA's response to EV5
!  CIA_DIAG  Diagnostic control enable 840002000
macro KA0F05$L_CIA_DIAG = 8192,0,32,1 %;
macro KA0F05$V_FROM_EN = 8192,0,1,0 %;  !  FROM write enable
macro KA0F05$V_USE_CHECK = 8192,1,1,0 %; !  USed with DIA_CHECK for ECC testing
macro KA0F05$V_FPE_PCI = 8192,28,2,0 %;
literal KA0F05$S_FPE_PCI = 2;           !  Force bad parity on PCI
macro KA0F05$V_FPE_TO_EV5 = 8192,31,1,0 %; !  Force parity error
!  DIAG_CHECK   Diagnostic used to write a known ECC pattern 840003000
macro KA0F05$L_DIAG_CHECK = 12288,0,32,1 %;
macro KA0F05$B_DIAG_CHECK_ECC = 12288,0,8,1 %; !  ECC to be used
!  Perf Monitor counts 8740004000
macro KA0F05$L_PERF_MONITOR = 16384,0,32,1 %;
!  Perf Monitor control  8740004040
macro KA0F05$L_PERF_CONTROL = 16448,0,32,1 %;
!  CPU Error reigster 0 8740008000
macro KA0F05$L_CPU_ERR0 = 32768,0,32,1 %;
macro KA0F05$V_CPU_ERR0_ADDR = 32768,4,28,0 %;
literal KA0F05$S_CPU_ERR0_ADDR = 28;    !  Bad addr on EV5 interface error
!  CPU error register 1 8740008040
macro KA0F05$L_CPU_ERR1 = 32832,0,32,1 %;
macro KA0F05$V_CPU_ERR1_3432 = 32832,0,3,0 %;
literal KA0F05$S_CPU_ERR1_3432 = 3;     !  CPU addr <34:32> on error
macro KA0F05$V_CPU_ERR1_39 = 32832,7,1,0 %; !  CPU addr <39> on error
macro KA0F05$V_CPU_ERR1_CMD = 32832,8,4,0 %;
literal KA0F05$S_CPU_ERR1_CMD = 4;      !  CPU command
macro KA0F05$V_CPU_ERR1_INT4_VALID = 32832,12,4,0 %;
literal KA0F05$S_CPU_ERR1_INT4_VALID = 4; !  INT4 valid bits
macro KA0F05$V_CPU_ERR1_AC_PAR = 32832,21,1,0 %; !  Parity bit from CPU Addr/cmd
macro KA0F05$V_CPU_ERR1_FPE = 32832,30,1,0 %; ! Copy of csr bit to force bad parity
macro KA0F05$V_CPU_ERR1_PE = 32832,31,1,0 %; ! IF set, CPU detected PE.
!  CIA Error reigster  8740008200
macro KA0F05$L_CIA_ERR = 33280,0,32,1 %;
macro KA0F05$V_ERR_CORR_ECC = 33280,0,1,0 %; !  [0]
macro KA0F05$V_ERR_UNC_ECC = 33280,1,1,0 %; !  [1]
macro KA0F05$V_ERR_CPU_PE = 33280,2,1,0 %; !  [2]
macro KA0F05$V_ERR_MEM_NEM = 33280,3,1,0 %; !  [3]
macro KA0F05$V_ERR_PCI_SERR = 33280,4,1,0 %; !  [4]
macro KA0F05$V_ERR_PCI_PERR = 33280,5,1,0 %; !  [5]
macro KA0F05$V_ERR_PCI_ADR_PE = 33280,6,1,0 %; !  [6]
macro KA0F05$V_ERR_M_ABORT = 33280,7,1,0 %; !  [7]
macro KA0F05$V_ERR_T_ABORT = 33280,8,1,0 %; !  [8]
macro KA0F05$V_ERR_PA_PTE_INV = 33280,9,1,0 %; !  [9]
macro KA0F05$V_ERR_FROM_WRT_ERR = 33280,10,1,0 %; !  [10]
macro KA0F05$V_ERR_IOA_TIMEOUT = 33280,11,1,0 %; !  [11]
macro KA0F05$V_ERR_LOST_CORR_ECC = 33280,16,1,0 %;
macro KA0F05$V_ERR_LOST_UNC_ECC = 33280,17,1,0 %;
macro KA0F05$V_ERR_LOST_CPU_PE = 33280,18,1,0 %;
macro KA0F05$V_ERR_LOST_MEM_NEM = 33280,19,1,0 %;
macro KA0F05$V_ERR_LOST_PCI_SERR = 33280,20,1,0 %;
macro KA0F05$V_ERR_LOST_PCI_PERR = 33280,21,1,0 %;
macro KA0F05$V_ERR_LOST_PCI_ADR_PE = 33280,22,1,0 %;
macro KA0F05$V_ERR_LOST_M_ABORT = 33280,23,1,0 %;
macro KA0F05$V_ERR_LOST_T_ABORT = 33280,24,1,0 %;
macro KA0F05$V_ERR_LOST_PA_PTE_INV = 33280,25,1,0 %;
macro KA0F05$V_ERR_LOST_FROM_WRT_ERR = 33280,26,1,0 %;
macro KA0F05$V_ERR_LOST_IOA_TIMEOUT = 33280,27,1,0 %;
macro KA0F05$V_ERR_VALID = 33280,31,1,0 %;
! 
!  CIA Error status register - 0x8740008240
! 
macro KA0F05$L_CIA_STAT = 33344,0,32,1 %;
macro KA0F05$V_STAT_MEM_SOURCE = 33344,1,1,0 %; !  [3]
macro KA0F05$V_STAT_IO_QUEUE = 33344,2,4,0 %;
literal KA0F05$S_STAT_IO_QUEUE = 4;     !  [7:4]
macro KA0F05$V_STAT_CPU_QUEUE = 33344,6,3,0 %;
literal KA0F05$S_STAT_CPU_QUEUE = 3;    !  [10:8]
macro KA0F05$V_STAT_TLB_MISS = 33344,9,1,0 %; !  [11]
macro KA0F05$V_STAT_DM_STAT = 33344,10,4,0 %;
literal KA0F05$S_STAT_DM_STAT = 4;      !  [15:12]
macro KA0F05$V_STAT_PA_CPU_RES = 33344,14,2,0 %;
literal KA0F05$S_STAT_PA_CPU_RES = 2;   !  [17:16]
! 
! 
!  CIA Error mask register - 0x8740008280
! 
macro KA0F05$L_CIA_ERROR_MASK = 33408,0,32,1 %;
macro KA0F05$V_MASK_CORR_ECC_ERR = 33408,0,1,0 %; !  [0]
macro KA0F05$V_MASK_UNC_ECC_ERR = 33408,1,1,0 %; !  [1]
macro KA0F05$V_MASK_CPU_PE = 33408,2,1,0 %; !  [2]
macro KA0F05$V_MASK_MEM_NEM = 33408,3,1,0 %; !  [3]
macro KA0F05$V_MASK_PCI_SERR = 33408,4,1,0 %; !  [4]
macro KA0F05$V_MASK_PCI_PERR = 33408,5,1,0 %; !  [5]
macro KA0F05$V_MASK_PCI_ADR_PE = 33408,6,1,0 %; !  [6]
macro KA0F05$V_MASK_M_ABORT = 33408,7,1,0 %; !  [7]
macro KA0F05$V_MASK_T_ABORT = 33408,8,1,0 %; !  [8]
macro KA0F05$V_MASK_PA_PTE_INV = 33408,9,1,0 %; !  [9]
macro KA0F05$V_MASK_FROM_WRT_ERR = 33408,10,1,0 %; !  [10]
macro KA0F05$V_MASK_IOA_TIMEOUT = 33408,11,1,0 %; !  [11]
! 
!  CIA Error Syndrome register  - 0x8740008300
! 
macro KA0F05$L_CIA_SYND = 33536,0,32,1 %;
macro KA0F05$R_CIA_SYND_BITS = 33536,0,32,0 %;
macro KA0F05$V_CIA_SYNDROME = 33536,0,8,0 %;
literal KA0F05$S_CIA_SYNDROME = 8;
! 
!  CIA Memory Port status register 0 - 0x8740008400
! 
macro KA0F05$L_CIA_MPSR0 = 33792,0,32,1 %;
macro KA0F05$V_MPSR0_ADDR_H = 33792,4,28,0 %;
literal KA0F05$S_MPSR0_ADDR_H = 28;
! 
!  CIA Memory Port status register 1 - 0x8740008440
! 
macro KA0F05$L_CIA_MPSR1 = 33856,0,32,1 %;
macro KA0F05$V_MPSR1_ADDR_H = 33856,0,2,0 %;
literal KA0F05$S_MPSR1_ADDR_H = 2;      !  [1:0]
macro KA0F05$V_MPSR1_ADDR_39 = 33856,7,1,0 %; !  [7]
macro KA0F05$V_MPSR1_CMD_H = 33856,8,4,0 %;
literal KA0F05$S_MPSR1_CMD_H = 4;       !  [11:8]
macro KA0F05$V_MPSR1_PORT_MASK = 33856,12,4,0 %;
literal KA0F05$S_MPSR1_PORT_MASK = 4;   !  [15:12]
macro KA0F05$V_MPSR1_SEQ_ST = 33856,16,4,0 %;
literal KA0F05$S_MPSR1_SEQ_ST = 4;      !  [19:16] 
macro KA0F05$V_MPSR1_PORT_SRC = 33856,20,1,0 %; !  [20]
macro KA0F05$V_MPSR1_SET_SEL = 33856,24,5,0 %;
literal KA0F05$S_MPSR1_SET_SEL = 5;     !  [28:24]
! 
!  PCI Error register 0 - 0x8740008800
! 
macro KA0F05$L_CIA_PCIE0 = 34816,0,32,1 %;
macro KA0F05$V_PCIE_CMD = 34816,0,4,0 %;
literal KA0F05$S_PCIE_CMD = 4;          !  [3:0]
macro KA0F05$V_PCIE_LOCK_STATE = 34816,4,1,0 %; !  [4]
macro KA0F05$V_PCIE_DAC_CYCLE = 34816,5,1,0 %; !  [5]
macro KA0F05$V_PCIE_WINDOW = 34816,8,4,0 %;
literal KA0F05$S_PCIE_WINDOW = 4;       !  [11:8]
macro KA0F05$V_PCIE_MSTR_STATE = 34816,16,4,0 %;
literal KA0F05$S_PCIE_MSTR_STATE = 4;   !  [19:16]
macro KA0F05$V_PCIE_TRGT_STATE = 34816,20,3,0 %;
literal KA0F05$S_PCIE_TRGT_STATE = 3;   !  [22:20]
! 
!  CIA PCI error  register 1 - 0x8740008840
! 
macro KA0F05$L_PCIE1_MEM_ADDR_H = 34880,0,32,1 %;
! 
!  Memory Configuration Register - 0x8750000000
! 
macro KA0F05$L_MEM_MCR = 40960,0,32,1 %;
macro KA0F05$V_MCR_MEM_SIZE = 40960,0,1,0 %; !  
macro KA0F05$V_MCR_CACHE_SIZE = 40960,4,3,0 %;
literal KA0F05$S_MCR_CACHE_SIZE = 3;    ! 
macro KA0F05$V_MCR_REF_RATE = 40960,8,10,0 %;
literal KA0F05$S_MCR_REF_RATE = 10;     ! 
macro KA0F05$V_MCR_REF_BURST = 40960,18,2,0 %;
literal KA0F05$S_MCR_REF_BURST = 2;     ! 
macro KA0F05$V_MCR_TMG_R0 = 40960,20,2,0 %;
literal KA0F05$S_MCR_TMG_R0 = 2;        ! 
macro KA0F05$V_MCR_LONG_CBR_CAS = 40960,22,1,0 %; ! 
macro KA0F05$V_MCR_DLY_IDLE_BC = 40960,26,2,0 %;
literal KA0F05$S_MCR_DLY_IDLE_BC = 2;   ! 
macro KA0F05$V_MCR_EARLY_IDLE_BC = 40960,29,1,0 %; ! 
! 
!  Memory Base Address 0  Register - 0x8750000600
! 
macro KA0F05$L_MEM_MBA0 = 42496,0,32,1 %;
macro KA0F05$V_MBA0_S0_VALID = 42496,0,1,0 %; !  
macro KA0F05$V_MBA0_ROW_TYPE = 42496,1,2,0 %;
literal KA0F05$S_MBA0_ROW_TYPE = 2;     ! 
macro KA0F05$V_MBA0_MASK = 42496,4,5,0 %;
literal KA0F05$S_MBA0_MASK = 5;         ! 
macro KA0F05$V_MBA0_S1_VALID = 42496,15,1,0 %; !  
macro KA0F05$V_MBA0_PATTERN = 42496,16,10,0 %;
literal KA0F05$S_MBA0_PATTERN = 10;     !  
macro KA0F05$V_MBA0_TIMING = 42496,28,2,0 %;
literal KA0F05$S_MBA0_TIMING = 2;       ! 
! 
!  Memory Base Address 2  Register - 0x8750000680
! 
macro KA0F05$L_MEM_MBA2 = 42624,0,32,1 %;
macro KA0F05$V_MBA2_S0_VALID = 42624,0,1,0 %; !  
macro KA0F05$V_MBA2_ROW_TYPE = 42624,1,2,0 %;
literal KA0F05$S_MBA2_ROW_TYPE = 2;     ! 
macro KA0F05$V_MBA2_MASK = 42624,4,5,0 %;
literal KA0F05$S_MBA2_MASK = 5;         ! 
macro KA0F05$V_MBA2_S1_VALID = 42624,15,1,0 %; !  
macro KA0F05$V_MBA2_PATTERN = 42624,16,10,0 %;
literal KA0F05$S_MBA2_PATTERN = 10;     !  
macro KA0F05$V_MBA2_TIMING = 42624,28,2,0 %;
literal KA0F05$S_MBA2_TIMING = 2;       ! 
! 
!  Memory Base Address 4  Register - 0x8750000700
! 
macro KA0F05$L_MEM_MBA4 = 42752,0,32,1 %;
macro KA0F05$V_MBA4_S0_VALID = 42752,0,1,0 %; !  
macro KA0F05$V_MBA4_ROW_TYPE = 42752,1,2,0 %;
literal KA0F05$S_MBA4_ROW_TYPE = 2;     ! 
macro KA0F05$V_MBA4_MASK = 42752,4,5,0 %;
literal KA0F05$S_MBA4_MASK = 5;         ! 
macro KA0F05$V_MBA4_S1_VALID = 42752,15,1,0 %; !  
macro KA0F05$V_MBA4_PATTERN = 42752,16,10,0 %;
literal KA0F05$S_MBA4_PATTERN = 10;     !  
macro KA0F05$V_MBA4_TIMING = 42752,28,2,0 %;
literal KA0F05$S_MBA4_TIMING = 2;       ! 
! 
!  Memory Base Address 6  Register - 0x8750000780
! 
macro KA0F05$L_MEM_MBA6 = 42880,0,32,1 %;
macro KA0F05$V_MBA6_S0_VALID = 42880,0,1,0 %; !  
macro KA0F05$V_MBA6_ROW_TYPE = 42880,1,2,0 %;
literal KA0F05$S_MBA6_ROW_TYPE = 2;     ! 
macro KA0F05$V_MBA6_MASK = 42880,4,5,0 %;
literal KA0F05$S_MBA6_MASK = 5;         ! 
macro KA0F05$V_MBA6_S1_VALID = 42880,15,1,0 %; !  
macro KA0F05$V_MBA6_PATTERN = 42880,16,10,0 %;
literal KA0F05$S_MBA6_PATTERN = 10;     !  
macro KA0F05$V_MBA6_TIMING = 42880,28,2,0 %;
literal KA0F05$S_MBA6_TIMING = 2;       ! 
! 
!  Memory Base Address 8  Register - 0x8750000800
! 
macro KA0F05$L_MEM_MBA8 = 43008,0,32,1 %;
macro KA0F05$V_MBA8_S0_VALID = 43008,0,1,0 %; !  
macro KA0F05$V_MBA8_ROW_TYPE = 43008,1,2,0 %;
literal KA0F05$S_MBA8_ROW_TYPE = 2;     ! 
macro KA0F05$V_MBA8_MASK = 43008,4,5,0 %;
literal KA0F05$S_MBA8_MASK = 5;         ! 
macro KA0F05$V_MBA8_S1_VALID = 43008,15,1,0 %; !  
macro KA0F05$V_MBA8_PATTERN = 43008,16,10,0 %;
literal KA0F05$S_MBA8_PATTERN = 10;     !  
macro KA0F05$V_MBA8_TIMING = 43008,28,2,0 %;
literal KA0F05$S_MBA8_TIMING = 2;       ! 
! 
!  Memory Base Address 10  Register - 0x8750000880
! 
macro KA0F05$L_MEM_MBAA = 43136,0,32,1 %;
macro KA0F05$V_MBAA_S0_VALID = 43136,0,1,0 %; !  
macro KA0F05$V_MBAA_ROW_TYPE = 43136,1,2,0 %;
literal KA0F05$S_MBAA_ROW_TYPE = 2;     ! 
macro KA0F05$V_MBAA_MASK = 43136,4,5,0 %;
literal KA0F05$S_MBAA_MASK = 5;         ! 
macro KA0F05$V_MBAA_S1_VALID = 43136,15,1,0 %; !  
macro KA0F05$V_MBAA_PATTERN = 43136,16,10,0 %;
literal KA0F05$S_MBAA_PATTERN = 10;     !  
macro KA0F05$V_MBAA_TIMING = 43136,28,2,0 %;
literal KA0F05$S_MBAA_TIMING = 2;       ! 
! 
!  Memory Base Address C  Register - 0x8750000900
! 
macro KA0F05$L_MEM_MBAC = 43264,0,32,1 %;
macro KA0F05$V_MBAC_S0_VALID = 43264,0,1,0 %; !  
macro KA0F05$V_MBAC_ROW_TYPE = 43264,1,2,0 %;
literal KA0F05$S_MBAC_ROW_TYPE = 2;     ! 
macro KA0F05$V_MBAC_MASK = 43264,4,5,0 %;
literal KA0F05$S_MBAC_MASK = 5;         ! 
macro KA0F05$V_MBAC_S1_VALID = 43264,15,1,0 %; !  
macro KA0F05$V_MBAC_PATTERN = 43264,16,10,0 %;
literal KA0F05$S_MBAC_PATTERN = 10;     !  
macro KA0F05$V_MBAC_TIMING = 43264,28,2,0 %;
literal KA0F05$S_MBAC_TIMING = 2;       ! 
! 
!  Memory Base Address E  Register - 0x8750000980
! 
macro KA0F05$L_MEM_MBAE = 43392,0,32,1 %;
macro KA0F05$V_MBAE_S0_VALID = 43392,0,1,0 %; !  
macro KA0F05$V_MBAE_ROW_TYPE = 43392,1,2,0 %;
literal KA0F05$S_MBAE_ROW_TYPE = 2;     ! 
macro KA0F05$V_MBAE_MASK = 43392,4,5,0 %;
literal KA0F05$S_MBAE_MASK = 5;         ! 
macro KA0F05$V_MBAE_S1_VALID = 43392,15,1,0 %; !  
macro KA0F05$V_MBAE_PATTERN = 43392,16,10,0 %;
literal KA0F05$S_MBAE_PATTERN = 10;     !  
macro KA0F05$V_MBAE_RESERVED_3 = 43392,26,2,0 %;
literal KA0F05$S_MBAE_RESERVED_3 = 2;   ! 
macro KA0F05$V_MBAE_TIMING = 43392,28,2,0 %;
literal KA0F05$S_MBAE_TIMING = 2;       ! 
! 
!  Memory Timing Register 0 - 0x8750000B00
! 
macro KA0F05$L_MEM_TMG0 = 43776,0,32,1 %;
macro KA0F05$V_TMG0_R1 = 43776,0,2,0 %;
literal KA0F05$S_TMG0_R1 = 2;           !  
macro KA0F05$V_TMG0_R2 = 43776,2,2,0 %;
literal KA0F05$S_TMG0_R2 = 2;           !  
macro KA0F05$V_TMG0_R3 = 43776,4,2,0 %;
literal KA0F05$S_TMG0_R3 = 2;           !  
macro KA0F05$V_TMG0_R4 = 43776,6,2,0 %;
literal KA0F05$S_TMG0_R4 = 2;           !  
macro KA0F05$V_TMG0_R5 = 43776,8,2,0 %;
literal KA0F05$S_TMG0_R5 = 2;           !  
macro KA0F05$V_TMG0_R6 = 43776,10,2,0 %;
literal KA0F05$S_TMG0_R6 = 2;           !  
macro KA0F05$V_TMG0_W1 = 43776,12,3,0 %;
literal KA0F05$S_TMG0_W1 = 3;           !  
macro KA0F05$V_TMG0_W4 = 43776,15,3,0 %;
literal KA0F05$S_TMG0_W4 = 3;           !  
macro KA0F05$V_TMG0_PRE = 43776,18,1,0 %; !  
macro KA0F05$V_TMG0_V3 = 43776,19,2,0 %;
literal KA0F05$S_TMG0_V3 = 2;           !  
macro KA0F05$V_TMG0_V4 = 43776,21,2,0 %;
literal KA0F05$S_TMG0_V4 = 2;           !  
macro KA0F05$V_TMG0_V5 = 43776,24,2,0 %;
literal KA0F05$S_TMG0_V5 = 2;           !  
macro KA0F05$V_TMG0_V6 = 43776,26,2,0 %;
literal KA0F05$S_TMG0_V6 = 2;           !  
macro KA0F05$V_TMG0_RV = 43776,28,2,0 %;
literal KA0F05$S_TMG0_RV = 2;           !  
macro KA0F05$V_TMG0_RD_DLY = 43776,30,2,0 %;
literal KA0F05$S_TMG0_RD_DLY = 2;       !  
! 
!  Memory Timing Register 1 - 0x8750000B40
! 
macro KA0F05$L_MEM_TMG1 = 43840,0,32,1 %;
macro KA0F05$V_TMG1_R1 = 43840,0,2,0 %;
literal KA0F05$S_TMG1_R1 = 2;           !  
macro KA0F05$V_TMG1_R2 = 43840,2,2,0 %;
literal KA0F05$S_TMG1_R2 = 2;           !  
macro KA0F05$V_TMG1_R3 = 43840,4,2,0 %;
literal KA0F05$S_TMG1_R3 = 2;           !  
macro KA0F05$V_TMG1_R4 = 43840,6,2,0 %;
literal KA0F05$S_TMG1_R4 = 2;           !  
macro KA0F05$V_TMG1_R5 = 43840,8,2,0 %;
literal KA0F05$S_TMG1_R5 = 2;           !  
macro KA0F05$V_TMG1_R6 = 43840,10,2,0 %;
literal KA0F05$S_TMG1_R6 = 2;           !  
macro KA0F05$V_TMG1_W1 = 43840,12,3,0 %;
literal KA0F05$S_TMG1_W1 = 3;           !  
macro KA0F05$V_TMG1_W4 = 43840,15,3,0 %;
literal KA0F05$S_TMG1_W4 = 3;           !  
macro KA0F05$V_TMG1_PRE = 43840,18,1,0 %; !  
macro KA0F05$V_TMG1_V3 = 43840,19,2,0 %;
literal KA0F05$S_TMG1_V3 = 2;           !  
macro KA0F05$V_TMG1_V4 = 43840,21,2,0 %;
literal KA0F05$S_TMG1_V4 = 2;           !  
macro KA0F05$V_TMG1_V5 = 43840,24,2,0 %;
literal KA0F05$S_TMG1_V5 = 2;           !  
macro KA0F05$V_TMG1_V6 = 43840,26,2,0 %;
literal KA0F05$S_TMG1_V6 = 2;           !  
macro KA0F05$V_TMG1_RV = 43840,28,2,0 %;
literal KA0F05$S_TMG1_RV = 2;           !  
macro KA0F05$V_TMG1_RD_DLY = 43840,30,2,0 %;
literal KA0F05$S_TMG1_RD_DLY = 2;       !  
! 
!  Memory Timing Register 2 - 0x8750000B80
! 
macro KA0F05$L_MEM_TMG2 = 43904,0,32,1 %;
macro KA0F05$V_TMG2_R1 = 43904,0,2,0 %;
literal KA0F05$S_TMG2_R1 = 2;           !  
macro KA0F05$V_TMG2_R2 = 43904,2,2,0 %;
literal KA0F05$S_TMG2_R2 = 2;           !  
macro KA0F05$V_TMG2_R3 = 43904,4,2,0 %;
literal KA0F05$S_TMG2_R3 = 2;           !  
macro KA0F05$V_TMG2_R4 = 43904,6,2,0 %;
literal KA0F05$S_TMG2_R4 = 2;           !  
macro KA0F05$V_TMG2_R5 = 43904,8,2,0 %;
literal KA0F05$S_TMG2_R5 = 2;           !  
macro KA0F05$V_TMG2_R6 = 43904,10,2,0 %;
literal KA0F05$S_TMG2_R6 = 2;           !  
macro KA0F05$V_TMG2_W1 = 43904,12,3,0 %;
literal KA0F05$S_TMG2_W1 = 3;           !  
macro KA0F05$V_TMG2_W4 = 43904,15,3,0 %;
literal KA0F05$S_TMG2_W4 = 3;           !  
macro KA0F05$V_TMG2_PRE = 43904,18,1,0 %; !  
macro KA0F05$V_TMG2_V3 = 43904,19,2,0 %;
literal KA0F05$S_TMG2_V3 = 2;           !  
macro KA0F05$V_TMG2_V4 = 43904,21,2,0 %;
literal KA0F05$S_TMG2_V4 = 2;           !  
macro KA0F05$V_TMG2_V5 = 43904,24,2,0 %;
literal KA0F05$S_TMG2_V5 = 2;           !  
macro KA0F05$V_TMG2_V6 = 43904,26,2,0 %;
literal KA0F05$S_TMG2_V6 = 2;           !  
macro KA0F05$V_TMG2_RV = 43904,28,2,0 %;
literal KA0F05$S_TMG2_RV = 2;           !  
macro KA0F05$V_TMG2_RD_DLY = 43904,30,2,0 %;
literal KA0F05$S_TMG2_RD_DLY = 2;       !  
! 
!  PCI Scatter/Gather TBIA  - 0x8760000100
! 
macro KA0F05$B_FILL345 = 49152,0,0,0 %;
literal KA0F05$S_FILL345 = 256;
macro KA0F05$L_PCI_TBIA = 49408,0,32,1 %;
macro KA0F05$V_TBIA_CSR_WR_DATA = 49408,0,2,0 %;
literal KA0F05$S_TBIA_CSR_WR_DATA = 2;  !  
! 
!  PCI Window Base 0   - 0x8760000400
! 
macro KA0F05$L_PCI_WBASE0 = 50176,0,32,1 %;
macro KA0F05$V_WBASE0_W_EN = 50176,0,1,0 %; !  
macro KA0F05$V_WBASE0_SG_EN = 50176,1,1,0 %; !  enable scatter/gather
macro KA0F05$V_WBASE0_MEMCS_EN = 50176,2,1,0 %; !  enable MEMCS
macro KA0F05$V_WBASE0_DAC_EN = 50176,3,1,0 %; !  enable 64BIT PCI
macro KA0F05$V_WBASE0_BASE = 50176,20,12,0 %;
literal KA0F05$S_WBASE0_BASE = 12;
! 
!  PCI Window Mask 0   - 0x8760000440
! 
macro KA0F05$L_PCI_WMASK0 = 50240,0,32,1 %;
macro KA0F05$V_WMASK0_MASK = 50240,20,12,0 %;
literal KA0F05$S_WMASK0_MASK = 12;
! 
!  PCI Window Translated Base 0   - 0x8760000480
! 
macro KA0F05$L_PCI_TBASE0 = 50304,0,32,1 %;
macro KA0F05$V_TBASE0_BASE = 50304,8,24,0 %;
literal KA0F05$S_TBASE0_BASE = 24;
! *****
! 
!  PCI Window Base 1   - 0x8760000500
! 
macro KA0F05$L_PCI_WBASE1 = 50432,0,32,1 %;
macro KA0F05$V_WBASE1_W_EN = 50432,0,1,0 %; !  
macro KA0F05$V_WBASE1_SG_EN = 50432,1,1,0 %; !  enable scatter/gather
macro KA0F05$V_WBASE1_MEMCS_EN = 50432,2,1,0 %; !  enable MEMCS
macro KA0F05$V_WBASE1_DAC_EN = 50432,3,1,0 %; !  enable 64BIT PCI
macro KA0F05$V_WBASE1_BASE = 50432,20,12,0 %;
literal KA0F05$S_WBASE1_BASE = 12;
! 
!  PCI Window Mask 1   - 0x8760000540
! 
macro KA0F05$L_PCI_WMASK1 = 50496,0,32,1 %;
macro KA0F05$V_WMASK1_MASK = 50496,20,12,0 %;
literal KA0F05$S_WMASK1_MASK = 12;
! 
!  PCI Window Translated Base 1   - 0x8760000580
! 
macro KA0F05$L_PCI_TBASE1 = 50560,0,32,1 %;
macro KA0F05$V_TBASE1_BASE = 50560,8,24,0 %;
literal KA0F05$S_TBASE1_BASE = 24;
! 
!  PCI Window Base 2   - 0x8760000600
! 
macro KA0F05$L_PCI_WBASE2 = 50688,0,32,1 %;
macro KA0F05$V_WBASE2_W_EN = 50688,0,1,0 %; !  
macro KA0F05$V_WBASE2_SG_EN = 50688,1,1,0 %; !  enable scatter/gather
macro KA0F05$V_WBASE2_MEMCS_EN = 50688,2,1,0 %; !  enable MEMCS
macro KA0F05$V_WBASE2_DAC_EN = 50688,3,1,0 %; !  enable 64BIT PCI
macro KA0F05$V_WBASE2_BASE = 50688,20,12,0 %;
literal KA0F05$S_WBASE2_BASE = 12;
! 
!  PCI Window Mask 2   - 0x8760000640
! 
macro KA0F05$L_PCI_WMASK2 = 50752,0,32,1 %;
macro KA0F05$V_WMASK2_MASK = 50752,20,12,0 %;
literal KA0F05$S_WMASK2_MASK = 12;
! 
!  PCI Window Translated Base 2   - 0x8760000680
! 
macro KA0F05$L_PCI_TBASE2 = 50816,0,32,1 %;
macro KA0F05$V_TBASE2_BASE = 50816,8,24,0 %;
literal KA0F05$S_TBASE2_BASE = 24;
! 
!  PCI Window Base 3   - 0x8760000700
! 
macro KA0F05$L_PCI_WBASE3 = 50944,0,32,1 %;
macro KA0F05$V_WBASE3_W_EN = 50944,0,1,0 %; !  
macro KA0F05$V_WBASE3_SG_EN = 50944,1,1,0 %; !  enable scatter/gather
macro KA0F05$V_WBASE3_MEMCS_EN = 50944,2,1,0 %; !  enable MEMCS
macro KA0F05$V_WBASE3_DAC_EN = 50944,3,1,0 %; !  enable 64BIT PCI
macro KA0F05$V_WBASE3_BASE = 50944,20,12,0 %;
literal KA0F05$S_WBASE3_BASE = 12;
! 
!  PCI Window Mask 3   - 0x8760000740
! 
macro KA0F05$L_PCI_WMASK3 = 51008,0,32,1 %;
macro KA0F05$V_WMASK3_MASK = 51008,20,12,0 %;
literal KA0F05$S_WMASK3_MASK = 12;
! 
!  PCI Window Translated Base 3   - 0x8760000780
! 
macro KA0F05$L_PCI_TBASE3 = 51072,0,32,1 %;
macro KA0F05$V_TBASE3_BASE = 51072,8,24,0 %;
literal KA0F05$S_TBASE3_BASE = 24;
! 
!  PCI DAC Base Register    - 0x87600007C0
! 
macro KA0F05$L_PCI_DAC = 51136,0,32,1 %;
macro KA0F05$V_DAC_BASE = 51136,0,8,0 %;
literal KA0F05$S_DAC_BASE = 8;
! 
!  PCI Lockable TB Tag 0- 0x8760000800
! 
macro KA0F05$L_PCI_LTB0 = 51200,0,32,1 %;
macro KA0F05$V_LTB0_VALID = 51200,0,1,0 %; !  
macro KA0F05$V_LTB0_LOCKED = 51200,1,1,0 %; !  enable scatter/gather
macro KA0F05$V_LTB0_DAC = 51200,2,1,0 %; !  enable 64BIT PCI
macro KA0F05$V_LTB0_TAG = 51200,15,17,0 %;
literal KA0F05$S_LTB0_TAG = 17;
! 
!  PCI Lockable TB Tag 1- 0x8760000840
! 
macro KA0F05$L_PCI_LTB1 = 51264,0,32,1 %;
macro KA0F05$V_LTB1_VALID = 51264,0,1,0 %; !  
macro KA0F05$V_LTB1_LOCKED = 51264,1,1,0 %; !  enable scatter/gather
macro KA0F05$V_LTB1_DAC = 51264,2,1,0 %; !  enable 64BIT PCI
macro KA0F05$V_LTB1_TAG = 51264,15,17,0 %;
literal KA0F05$S_LTB1_TAG = 17;
! 
!  PCI Lockable TB Tag 2- 0x8760000880
! 
macro KA0F05$L_PCI_LTB2 = 51328,0,32,1 %;
macro KA0F05$V_LTB2_VALID = 51328,0,1,0 %; !  
macro KA0F05$V_LTB2_LOCKED = 51328,1,1,0 %; !  enable scatter/gather
macro KA0F05$V_LTB2_DAC = 51328,2,1,0 %; !  enable 64BIT PCI
macro KA0F05$V_LTB2_TAG = 51328,15,17,0 %;
literal KA0F05$S_LTB2_TAG = 17;
! 
!  PCI Lockable TB Tag 3- 0x87600008C0
! 
macro KA0F05$L_PCI_LTB3 = 51392,0,32,1 %;
macro KA0F05$V_LTB3_VALID = 51392,0,1,0 %; !  
macro KA0F05$V_LTB3_LOCKED = 51392,1,1,0 %; !  enable scatter/gather
macro KA0F05$V_LTB3_DAC = 51392,2,1,0 %; !  enable 64BIT PCI
macro KA0F05$V_LTB3_TAG = 51392,15,17,0 %;
literal KA0F05$S_LTB3_TAG = 17;
! 
!  PCI TB Tag 0- 0x8760000900
! 
macro KA0F05$L_PCI_TB0 = 51456,0,32,1 %;
macro KA0F05$V_TB0_VALID = 51456,0,1,0 %; !  
macro KA0F05$V_TB0_DAC = 51456,2,1,0 %; !  enable 64BIT PCI
macro KA0F05$V_TB0_TAG = 51456,15,17,0 %;
literal KA0F05$S_TB0_TAG = 17;
! 
!  PCI TB Tag 1 - 0x8760000940
! 
macro KA0F05$L_PCI_TB1 = 51520,0,32,1 %;
macro KA0F05$V_TB1_VALID = 51520,0,1,0 %; !  
macro KA0F05$V_TB1_DAC = 51520,2,1,0 %; !  enable 64BIT PCI
macro KA0F05$V_TB1_TAG = 51520,15,17,0 %;
literal KA0F05$S_TB1_TAG = 17;
! 
!  PCI TB Tag 2 - 0x8760000980
! 
macro KA0F05$L_PCI_TB2 = 51584,0,32,1 %;
macro KA0F05$V_TB2_VALID = 51584,0,1,0 %; !  
macro KA0F05$V_TB2_DAC = 51584,2,1,0 %; !  enable 64BIT PCI
macro KA0F05$V_TB2_TAG = 51584,15,17,0 %;
literal KA0F05$S_TB2_TAG = 17;
! 
!  PCI TB Tag 3- 0x87600009C0
! 
macro KA0F05$L_PCI_TB3 = 51648,0,32,1 %;
macro KA0F05$V_TB3_VALID = 51648,0,1,0 %; !  
macro KA0F05$V_TB3_DAC = 51648,2,1,0 %; !  enable 64BIT PCI
macro KA0F05$V_TB3_TAG = 51648,15,17,0 %;
literal KA0F05$S_TB3_TAG = 17;
! 
!  PCI TB0 Page 0- 0x8760001000
! 
macro KA0F05$L_PCI_TB0_PAGE0 = 53248,0,32,1 %;
macro KA0F05$V_TB0_PAGE0_VALID = 53248,0,1,0 %; !  
macro KA0F05$V_TB0_PAGE0_ADDR = 53248,1,21,0 %;
literal KA0F05$S_TB0_PAGE0_ADDR = 21;
! 
!  PCI TB0 Page 1 - 0x8760001040
! 
macro KA0F05$L_PCI_TB0_PAGE1 = 53312,0,32,1 %;
macro KA0F05$V_TB0_PAGE1_VALID = 53312,0,1,0 %; !  
macro KA0F05$V_TB0_PAGE1_ADDR = 53312,1,21,0 %;
literal KA0F05$S_TB0_PAGE1_ADDR = 21;
! 
!  PCI TB0 Page 2 - 0x8760001080
! 
macro KA0F05$L_PCI_TB0_PAGE2 = 53376,0,32,1 %;
macro KA0F05$V_TB0_PAGE2_VALID = 53376,0,1,0 %; !  
macro KA0F05$V_TB0_PAGE2_ADDR = 53376,1,21,0 %;
literal KA0F05$S_TB0_PAGE2_ADDR = 21;
! 
!  PCI TB0 Page 3- 0x87600010C0
! 
macro KA0F05$L_PCI_TB0_PAGE3 = 53440,0,32,1 %;
macro KA0F05$V_TB0_PAGE3_VALID = 53440,0,1,0 %; !  
macro KA0F05$V_TB0_PAGE3_ADDR = 53440,1,21,0 %;
literal KA0F05$S_TB0_PAGE3_ADDR = 21;
! 
!  PCI TB1 Page 0- 0x8760001100
! 
macro KA0F05$L_PCI_TB1_PAGE0 = 53504,0,32,1 %;
macro KA0F05$V_TB1_PAGE0_VALID = 53504,0,1,0 %; !  
macro KA0F05$V_TB1_PAGE0_ADDR = 53504,1,21,0 %;
literal KA0F05$S_TB1_PAGE0_ADDR = 21;
! 
!  PCI TB1 Page 1 - 0x8760001140
! 
macro KA0F05$L_PCI_TB1_PAGE1 = 53568,0,32,1 %;
macro KA0F05$V_TB1_PAGE1_VALID = 53568,0,1,0 %; !  
macro KA0F05$V_TB1_PAGE1_ADDR = 53568,1,21,0 %;
literal KA0F05$S_TB1_PAGE1_ADDR = 21;
! 
!  PCI TB1 Page 2 - 0x8760001180
! 
macro KA0F05$L_PCI_TB1_PAGE2 = 53632,0,32,1 %;
macro KA0F05$V_TB1_PAGE2_VALID = 53632,0,1,0 %; !  
macro KA0F05$V_TB1_PAGE2_ADDR = 53632,1,21,0 %;
literal KA0F05$S_TB1_PAGE2_ADDR = 21;
! 
!  PCI TB1 Page 3- 0x87600011C0
! 
macro KA0F05$L_PCI_TB1_PAGE3 = 53696,0,32,1 %;
macro KA0F05$V_TB1_PAGE3_VALID = 53696,0,1,0 %; !  
macro KA0F05$V_TB1_PAGE3_ADDR = 53696,1,21,0 %;
literal KA0F05$S_TB1_PAGE3_ADDR = 21;
! 
!  PCI TB2 Page 0- 0x8760001200
! 
macro KA0F05$L_PCI_TB2_PAGE0 = 53760,0,32,1 %;
macro KA0F05$V_TB2_PAGE0_VALID = 53760,0,1,0 %; !  
macro KA0F05$V_TB2_PAGE0_ADDR = 53760,1,21,0 %;
literal KA0F05$S_TB2_PAGE0_ADDR = 21;
! 
!  PCI TB2 Page 1 - 0x8760001240
! 
macro KA0F05$L_PCI_TB2_PAGE1 = 53824,0,32,1 %;
macro KA0F05$V_TB2_PAGE1_VALID = 53824,0,1,0 %; !  
macro KA0F05$V_TB2_PAGE1_ADDR = 53824,1,21,0 %;
literal KA0F05$S_TB2_PAGE1_ADDR = 21;
! 
!  PCI TB2 Page 2 - 0x8760001280
! 
macro KA0F05$L_PCI_TB2_PAGE2 = 53888,0,32,1 %;
macro KA0F05$V_TB2_PAGE2_VALID = 53888,0,1,0 %; !  
macro KA0F05$V_TB2_PAGE2_ADDR = 53888,1,21,0 %;
literal KA0F05$S_TB2_PAGE2_ADDR = 21;
! 
!  PCI TB2 Page 3- 0x87600012C0
! 
macro KA0F05$L_PCI_TB2_PAGE3 = 53952,0,32,1 %;
macro KA0F05$V_TB2_PAGE3_VALID = 53952,0,1,0 %; !  
macro KA0F05$V_TB2_PAGE3_ADDR = 53952,1,21,0 %;
literal KA0F05$S_TB2_PAGE3_ADDR = 21;
! 
!  PCI TB3 Page 0- 0x8760001300
! 
macro KA0F05$L_PCI_TB3_PAGE0 = 54016,0,32,1 %;
macro KA0F05$V_TB3_PAGE0_VALID = 54016,0,1,0 %; !  
macro KA0F05$V_TB3_PAGE0_ADDR = 54016,1,21,0 %;
literal KA0F05$S_TB3_PAGE0_ADDR = 21;
! 
!  PCI TB3 Page 1 - 0x8760001340
! 
macro KA0F05$L_PCI_TB3_PAGE1 = 54080,0,32,1 %;
macro KA0F05$V_TB3_PAGE1_VALID = 54080,0,1,0 %; !  
macro KA0F05$V_TB3_PAGE1_ADDR = 54080,1,21,0 %;
literal KA0F05$S_TB3_PAGE1_ADDR = 21;
! 
!  PCI TB3 Page 2 - 0x8760001380
! 
macro KA0F05$L_PCI_TB3_PAGE2 = 54144,0,32,1 %;
macro KA0F05$V_TB3_PAGE2_VALID = 54144,0,1,0 %; !  
macro KA0F05$V_TB3_PAGE2_ADDR = 54144,1,21,0 %;
literal KA0F05$S_TB3_PAGE2_ADDR = 21;
! 
!  PCI TB3 Page 3- 0x87600013C0
! 
macro KA0F05$L_PCI_TB3_PAGE3 = 54208,0,32,1 %;
macro KA0F05$V_TB3_PAGE3_VALID = 54208,0,1,0 %; !  
macro KA0F05$V_TB3_PAGE3_ADDR = 54208,1,21,0 %;
literal KA0F05$S_TB3_PAGE3_ADDR = 21;
! 
!  PCI TB4 Page 0- 0x8760001400
! 
macro KA0F05$L_PCI_TB4_PAGE0 = 54272,0,32,1 %;
macro KA0F05$V_TB4_PAGE0_VALID = 54272,0,1,0 %; !  
macro KA0F05$V_TB4_PAGE0_ADDR = 54272,1,21,0 %;
literal KA0F05$S_TB4_PAGE0_ADDR = 21;
! 
!  PCI TB4 Page 1 - 0x8760001440
! 
macro KA0F05$L_PCI_TB4_PAGE1 = 54336,0,32,1 %;
macro KA0F05$V_TB4_PAGE1_VALID = 54336,0,1,0 %; !  
macro KA0F05$V_TB4_PAGE1_ADDR = 54336,1,21,0 %;
literal KA0F05$S_TB4_PAGE1_ADDR = 21;
! 
!  PCI TB4 Page 2 - 0x8760001480
! 
macro KA0F05$L_PCI_TB4_PAGE2 = 54400,0,32,1 %;
macro KA0F05$V_TB4_PAGE2_VALID = 54400,0,1,0 %; !  
macro KA0F05$V_TB4_PAGE2_ADDR = 54400,1,21,0 %;
literal KA0F05$S_TB4_PAGE2_ADDR = 21;
! 
!  PCI TB4 Page 3- 0x87600014C0
! 
macro KA0F05$L_PCI_TB4_PAGE3 = 54464,0,32,1 %;
macro KA0F05$V_TB4_PAGE3_VALID = 54464,0,1,0 %; !  
macro KA0F05$V_TB4_PAGE3_ADDR = 54464,1,21,0 %;
literal KA0F05$S_TB4_PAGE3_ADDR = 21;
! 
!  PCI TB5 Page 0- 0x8760001500
! 
macro KA0F05$L_PCI_TB5_PAGE0 = 54528,0,32,1 %;
macro KA0F05$V_TB5_PAGE0_VALID = 54528,0,1,0 %; !  
macro KA0F05$V_TB5_PAGE0_ADDR = 54528,1,21,0 %;
literal KA0F05$S_TB5_PAGE0_ADDR = 21;
! 
!  PCI TB5 Page 1 - 0x8760001540
! 
macro KA0F05$L_PCI_TB5_PAGE1 = 54592,0,32,1 %;
macro KA0F05$V_TB5_PAGE1_VALID = 54592,0,1,0 %; !  
macro KA0F05$V_TB5_PAGE1_ADDR = 54592,1,21,0 %;
literal KA0F05$S_TB5_PAGE1_ADDR = 21;
! 
!  PCI TB5 Page 2 - 0x8760001580
! 
macro KA0F05$L_PCI_TB5_PAGE2 = 54656,0,32,1 %;
macro KA0F05$V_TB5_PAGE2_VALID = 54656,0,1,0 %; !  
macro KA0F05$V_TB5_PAGE2_ADDR = 54656,1,21,0 %;
literal KA0F05$S_TB5_PAGE2_ADDR = 21;
! 
!  PCI TB5 Page 3- 0x87600015C0
! 
macro KA0F05$L_PCI_TB5_PAGE3 = 54720,0,32,1 %;
macro KA0F05$V_TB5_PAGE3_VALID = 54720,0,1,0 %; !  
macro KA0F05$V_TB5_PAGE3_ADDR = 54720,1,21,0 %;
literal KA0F05$S_TB5_PAGE3_ADDR = 21;
! 
!  PCI TB6 Page 0- 0x8760001600
! 
macro KA0F05$L_PCI_TB6_PAGE0 = 54784,0,32,1 %;
macro KA0F05$V_TB6_PAGE0_VALID = 54784,0,1,0 %; !  
macro KA0F05$V_TB6_PAGE0_ADDR = 54784,1,21,0 %;
literal KA0F05$S_TB6_PAGE0_ADDR = 21;
! 
!  PCI TB6 Page 1 - 0x8760001640
! 
macro KA0F05$L_PCI_TB6_PAGE1 = 54848,0,32,1 %;
macro KA0F05$V_TB6_PAGE1_VALID = 54848,0,1,0 %; !  
macro KA0F05$V_TB6_PAGE1_ADDR = 54848,1,21,0 %;
literal KA0F05$S_TB6_PAGE1_ADDR = 21;
! 
!  PCI TB6 Page 2 - 0x8760001680
! 
macro KA0F05$L_PCI_TB6_PAGE2 = 54912,0,32,1 %;
macro KA0F05$V_TB6_PAGE2_VALID = 54912,0,1,0 %; !  
macro KA0F05$V_TB6_PAGE2_ADDR = 54912,1,21,0 %;
literal KA0F05$S_TB6_PAGE2_ADDR = 21;
! 
!  PCI TB6 Page 3- 0x87600016C0
! 
macro KA0F05$L_PCI_TB6_PAGE3 = 54976,0,32,1 %;
macro KA0F05$V_TB6_PAGE3_VALID = 54976,0,1,0 %; !  
macro KA0F05$V_TB6_PAGE3_ADDR = 54976,1,21,0 %;
literal KA0F05$S_TB6_PAGE3_ADDR = 21;
! 
!  PCI TB7 Page 0- 0x8760001700
! 
macro KA0F05$L_PCI_TB7_PAGE0 = 55040,0,32,1 %;
macro KA0F05$V_TB7_PAGE0_VALID = 55040,0,1,0 %; !  
macro KA0F05$V_TB7_PAGE0_ADDR = 55040,1,21,0 %;
literal KA0F05$S_TB7_PAGE0_ADDR = 21;
! 
!  PCI TB7 Page 1 - 0x8760001740
! 
macro KA0F05$L_PCI_TB7_PAGE1 = 55104,0,32,1 %;
macro KA0F05$V_TB7_PAGE1_VALID = 55104,0,1,0 %; !  
macro KA0F05$V_TB7_PAGE1_ADDR = 55104,1,21,0 %;
literal KA0F05$S_TB7_PAGE1_ADDR = 21;
! 
!  PCI TB7 Page 2 - 0x8760001780
! 
macro KA0F05$L_PCI_TB7_PAGE2 = 55168,0,32,1 %;
macro KA0F05$V_TB7_PAGE2_VALID = 55168,0,1,0 %; !  
macro KA0F05$V_TB7_PAGE2_ADDR = 55168,1,21,0 %;
literal KA0F05$S_TB7_PAGE2_ADDR = 21;
! 
!  PCI TB7 Page 3- 0x87600017C0
! 
macro KA0F05$L_PCI_TB7_PAGE3 = 55232,0,32,1 %;
macro KA0F05$V_TB7_PAGE3_VALID = 55232,0,1,0 %; !  
macro KA0F05$V_TB7_PAGE3_ADDR = 55232,1,21,0 %;
literal KA0F05$S_TB7_PAGE3_ADDR = 21;
! 
!  GRU Interrupt request  register  - 0x8780000000
! 
macro KA0F05$L_GRU_INT_REQ = 57344,0,32,1 %;
! 
!  GRU Interrupt mask  register  - 0x8780000040
! 
macro KA0F05$L_GRU_INT_MASK = 57408,0,32,1 %;
! 
!  GRU Interrupt Level/edge select  register  - 0x8780000080
! 
macro KA0F05$L_GRU_INT_EDGE = 57472,0,32,1 %;
! 
!  GRU Interrupt High/Low select register  - 0x87800000C0
! 
macro KA0F05$L_GRU_INT_HILO = 57536,0,32,1 %;
! 
!  GRU Interrupt clear  register  - 0x8780000100
! 
macro KA0F05$L_GRU_INT_CLEAR = 57600,0,32,1 %;
macro KA0F05$V_GRU_INT_CLR = 57600,0,1,0 %; !  
macro KA0F05$V_FILL = 57600,1,31,0 %;
literal KA0F05$S_FILL = 31;
! 
!  GRU Cache and Memory Config register  - 0x8780000200
! 
macro KA0F05$L_GRU_CACHE_CONFIG = 57856,0,32,1 %;
macro KA0F05$V_GRU_CNFG_CLK_DIV = 57856,4,4,0 %;
literal KA0F05$S_GRU_CNFG_CLK_DIV = 4;  !  
macro KA0F05$V_GRU_CNFG_CACHE_SP = 57856,11,2,0 %;
literal KA0F05$S_GRU_CNFG_CACHE_SP = 2; !  
macro KA0F05$V_GRU_CNFG_CACHE_SZ = 57856,13,3,0 %;
literal KA0F05$S_GRU_CNFG_CACHE_SZ = 3; !  
macro KA0F05$V_GRU_CNFG_MMB0_CFG = 57856,16,4,0 %;
literal KA0F05$S_GRU_CNFG_MMB0_CFG = 4; !  
macro KA0F05$V_GRU_CNFG_MMB1_CFG = 57856,24,4,0 %;
literal KA0F05$S_GRU_CNFG_MMB1_CFG = 4; !  
! 
!  GRU SET Memory Config register  - 0x8780000300
! 
macro KA0F05$L_GRU_SET_CONFIG = 58112,0,32,1 %;
macro KA0F05$V_GRU_CNFG_SS7_MMB0 = 58112,0,2,0 %;
literal KA0F05$S_GRU_CNFG_SS7_MMB0 = 2; !  
macro KA0F05$V_GRU_CNFG_SS6_MMB0 = 58112,2,2,0 %;
literal KA0F05$S_GRU_CNFG_SS6_MMB0 = 2; !  
macro KA0F05$V_GRU_CNFG_SS5_MMB0 = 58112,4,2,0 %;
literal KA0F05$S_GRU_CNFG_SS5_MMB0 = 2; !  
macro KA0F05$V_GRU_CNFG_SS4_MMB0 = 58112,6,2,0 %;
literal KA0F05$S_GRU_CNFG_SS4_MMB0 = 2; !  
macro KA0F05$V_GRU_CNFG_SS3_MMB0 = 58112,8,2,0 %;
literal KA0F05$S_GRU_CNFG_SS3_MMB0 = 2; !  
macro KA0F05$V_GRU_CNFG_SS2_MMB0 = 58112,10,2,0 %;
literal KA0F05$S_GRU_CNFG_SS2_MMB0 = 2; !  
macro KA0F05$V_GRU_CNFG_SS1_MMB0 = 58112,12,2,0 %;
literal KA0F05$S_GRU_CNFG_SS1_MMB0 = 2; !  
macro KA0F05$V_GRU_CNFG_SS0_MMB0 = 58112,14,2,0 %;
literal KA0F05$S_GRU_CNFG_SS0_MMB0 = 2; !  
macro KA0F05$V_GRU_CNFG_SS7_MMB1 = 58112,16,2,0 %;
literal KA0F05$S_GRU_CNFG_SS7_MMB1 = 2; !  
macro KA0F05$V_GRU_CNFG_SS6_MMB1 = 58112,18,2,0 %;
literal KA0F05$S_GRU_CNFG_SS6_MMB1 = 2; !  
macro KA0F05$V_GRU_CNFG_SS5_MMB1 = 58112,20,2,0 %;
literal KA0F05$S_GRU_CNFG_SS5_MMB1 = 2; !  
macro KA0F05$V_GRU_CNFG_SS4_MMB1 = 58112,22,2,0 %;
literal KA0F05$S_GRU_CNFG_SS4_MMB1 = 2; !  
macro KA0F05$V_GRU_CNFG_SS3_MMB1 = 58112,24,2,0 %;
literal KA0F05$S_GRU_CNFG_SS3_MMB1 = 2; !  
macro KA0F05$V_GRU_CNFG_SS2_MMB1 = 58112,26,2,0 %;
literal KA0F05$S_GRU_CNFG_SS2_MMB1 = 2; !  
macro KA0F05$V_GRU_CNFG_SS1_MMB1 = 58112,28,2,0 %;
literal KA0F05$S_GRU_CNFG_SS1_MMB1 = 2; !  
macro KA0F05$V_GRU_CNFG_SS0_MMB1 = 58112,30,2,0 %;
literal KA0F05$S_GRU_CNFG_SS0_MMB1 = 2; !  
! 
!  GRU LED register  - 0x8780000800
! 
macro KA0F05$L_GRU_LED = 59392,0,32,1 %;
! 
!  GRU LED register  - 0x8780000900
! 
macro KA0F05$L_GRU_RESET = 59648,0,32,1 %;
! 
!  DS1287A register definitions
!                            
literal KA0F05_DS1287A$S_KA0F05_DS1287A = 3624;
macro KA0F05_DS1287A$L_PORT_INDEX = 3584,0,32,0 %;
macro KA0F05_DS1287A$L_PORT_DATA = 3616,0,32,0 %;
 
!*** MODULE $KDZDEF ***
! +
!  KDZ11 Offset Definitions for Registers Accessible Through BI Node Private
!   Space.  Note that in making these registers available in virtual space,
!   we have only mapped real registers.  Therefore these virtual offsets are
!   different than the hardware physical offsets.
! -
literal KDZ$M_PCNTL_RSTRT = %X'1';
literal KDZ$M_PCNTL_PHYLOG = %X'2';
literal KDZ$M_PCNTL_SECENB = %X'4';
literal KDZ$M_PCNTL_STINIT = %X'8';
literal KDZ$M_PCNTL_STFAST = %X'10';
literal KDZ$M_PCNTL_ENBAPT = %X'20';
literal KDZ$M_PCNTL_STPASS = %X'40';
literal KDZ$M_PCNTL_RUN = %X'80';
literal KDZ$M_PCNTL_CLREVL = %X'200';
literal KDZ$M_PCNTL_WRMEM = %X'400';
literal KDZ$M_PCNTL_EV4 = %X'800';
literal KDZ$M_PCNTL_EV3 = %X'1000';
literal KDZ$M_PCNTL_EV2 = %X'2000';
literal KDZ$M_PCNTL_EV1 = %X'4000';
literal KDZ$M_PCNTL_EV0 = %X'8000';
literal KDZ$M_PCNTL_WWPO = %X'10000';
literal KDZ$M_PCNTL_NIDIS = %X'80000';
literal KDZ$M_PCNTL_CNSLIE = %X'100000';
literal KDZ$M_PCNTL_CNSLCL = %X'200000';
literal KDZ$M_PCNTL_CNSLIN = %X'400000';
literal KDZ$M_PCNTL_WWPE = %X'800000';
literal KDZ$M_PCNTL_RXDONE = %X'1000000';
literal KDZ$M_PCNTL_RXSTAT = %X'2000000';
literal KDZ$M_PCNTL_CLRIPI = %X'4000000';
literal KDZ$M_PCNTL_IPINTR = %X'8000000';
literal KDZ$M_PCNTL_CRDIE = %X'10000000';
literal KDZ$M_PCNTL_CLRCRD = %X'20000000';
literal KDZ$M_PCNTL_CRDINT = %X'40000000';
literal KDZ$S_KDZDEF = 44032;           !  Old size name - synonym
literal KDZ$S_KDZ = 44032;
! 
!  BIIC registers - here we reserve space for the 256 bytes that these
! 		    registers occupy and we also fill out the virtual page to
! 		    512 bytes so that other items appear on page boundaries.
! 		    Being able to address the BIIC via these virtual addresses
! 		    allows a Scorpio CPU to determine its own node number.
! 		    That is, a reference here is via node private space and
! 		    always addresses a nodes own registers via a loop back
! 		    request.
! 
macro KDZ$B_BIICBASE = 0,0,8,0 %;       ! BIIC register Base
! 
!  Port Control CSR register
! 
macro KDZ$L_PCNTL = 512,0,32,0 %;       ! Port Control CSR Register
macro KDZ$V_PCNTL_RSTRT = 512,0,1,0 %;  !  (RO) Front Panel Switch
!   selecting RSTRT/HALT
macro KDZ$V_PCNTL_PHYLOG = 512,1,1,0 %; !  (RO) Backplane Bit
!   selecting PHYS/LOG Console
macro KDZ$V_PCNTL_SECENB = 512,2,1,0 %; !  (RO) Front Panel Switch
!   to lock out console input
macro KDZ$V_PCNTL_STINIT = 512,3,1,0 %; !  Self-Test INIT.
macro KDZ$V_PCNTL_STFAST = 512,4,1,0 %; !  (RO) Backplane bit to
!   select Fast Self-Test.
macro KDZ$V_PCNTL_ENBAPT = 512,5,1,0 %; !  Enable APT.
macro KDZ$V_PCNTL_STPASS = 512,6,1,0 %; !  Self-Test Pass.
macro KDZ$V_PCNTL_RUN = 512,7,1,0 %;    !  1=>Program mode,0=>Console
macro KDZ$V_PCNTL_CLREVL = 512,9,1,0 %; !  Clear Event Lock
macro KDZ$V_PCNTL_WRMEM = 512,10,1,0 %; !  Write Memory Bit
macro KDZ$V_PCNTL_EV4 = 512,11,1,0 %;   !  Event Bits - These
macro KDZ$V_PCNTL_EV3 = 512,12,1,0 %;   !   RO bits are event
macro KDZ$V_PCNTL_EV2 = 512,13,1,0 %;   !   codes from BIIC to
macro KDZ$V_PCNTL_EV1 = 512,14,1,0 %;   !   allow CPU to monitor
macro KDZ$V_PCNTL_EV0 = 512,15,1,0 %;   !   BI status
macro KDZ$V_PCNTL_WWPO = 512,16,1,0 %;  !  Write Wrong Parity Odd
macro KDZ$V_PCNTL_NIDIS = 512,19,1,0 %; !  Disable NI Lance
macro KDZ$V_PCNTL_CNSLIE = 512,20,1,0 %; !  Console Interrupt Enable
macro KDZ$V_PCNTL_CNSLCL = 512,21,1,0 %; !  Clear Console Interrupt
macro KDZ$V_PCNTL_CNSLIN = 512,22,1,0 %; !  Console Interrupt RCVD
macro KDZ$V_PCNTL_WWPE = 512,23,1,0 %;  !  Write Wrong Parity Even
macro KDZ$V_PCNTL_RXDONE = 512,24,1,0 %; !  RX Done Interrupt
macro KDZ$V_PCNTL_RXSTAT = 512,25,1,0 %; !  RX Status Interrupt
macro KDZ$V_PCNTL_CLRIPI = 512,26,1,0 %; !  Clear IP Interrupt
macro KDZ$V_PCNTL_IPINTR = 512,27,1,0 %; !  IP Interrupt RCVD
macro KDZ$V_PCNTL_CRDIE = 512,28,1,0 %; !  CRD Interrupt Enable
macro KDZ$V_PCNTL_CLRCRD = 512,29,1,0 %; !  Clear CRD Interrupt
macro KDZ$V_PCNTL_CRDINT = 512,30,1,0 %; !  CRD Interrupt RCVD
! 
!  NI Packet Buffer
! 
macro KDZ$B_NIBUF = 1024,0,8,0 %;       ! NI Packet Buffer Base
! 
!  EEPROM
! 
macro KDZ$B_EEPROM = 33792,0,8,0 %;     ! EEPROM Base
! 
!  NI Data Register
! 
macro KDZ$L_NIDATA = 41984,0,32,0 %;    !  NI Data Register
! 
!  NI Address Register
! 
macro KDZ$L_NIADDR = 42496,0,32,1 %;    !  NI Address Register
! 
!  RCX50 Registers
!                                                          
macro KDZ$B_RCX50 = 43008,0,8,0 %;      !  RCX50 Registers
! 
!  Watch Chip Registers
! 
macro KDZ$B_WATCH = 43520,0,8,0 %;      !  Watch Chip Registers
 
!*** MODULE $KFDDEF ***
! 
!  KNOWN FILE DEVICE AND DIRECTORY BLOCK DEFINITIONS
! 
literal KFD$C_LENGTH = 17;              !  Length of fixed area of kfd entry 
literal KFD$S_KFDDEF = 17;              !  Old size name - synonym
literal KFD$S_KFD = 17;
macro KFD$L_LINK = 0,0,32,1 %;          !  Device, Directory, Extension (KFD) list link
macro KFD$L_KFELIST = 4,0,32,1 %;       !  Ordered Known file entry list header
macro KFD$W_SIZE = 8,0,16,0 %;          !  Size of block 
macro KFD$B_TYPE = 10,0,8,0 %;          !  Structure type 
macro KFD$B_SPARE = 11,0,8,0 %;         !  spare
macro KFD$W_REFCNT = 12,0,16,0 %;       !  Number of KFE's with same KFD
macro KFD$B_DEVLEN = 14,0,8,0 %;        !  Length of Device string
macro KFD$B_DIRLEN = 15,0,8,0 %;        !  Length of Directory string
macro KFD$B_DDTSTRLEN = 16,0,8,0 %;     !  Length of Device, Directory, Type (DDT) string
macro KFD$T_DDTSTR = 17,0,0,0 %;        !  Offset to DDT string
 
!*** MODULE $KFEDEF ***
! 
!  KNOWN FILE ENTRY DEFINITIONS
! 
literal KFE$M_PROTECT = %X'1';
literal KFE$M_LIM = %X'2';
literal KFE$M_PROCPRIV = %X'4';
literal KFE$M_OPEN = %X'8';
literal KFE$M_HDRRES = %X'10';
literal KFE$M_SHARED = %X'20';
literal KFE$M_KFE_NAMING = %X'40';
literal KFE$M_FILL_1 = %X'80';
literal KFE$M_NOPURGE = %X'100';
literal KFE$M_ACCOUNT = %X'200';
literal KFE$M_WRITEABLE = %X'400';
literal KFE$M_EXEONLY = %X'800';
literal KFE$M_DISCONTIGUOUS = %X'1000';
literal KFE$M_DELETE_PEND = %X'2000';
literal KFE$M_VERSION_SAFE = %X'4000';
literal KFE$M_DATA_RESIDENT = %X'8000';
literal KFE$K_LENGTH = 73;              !  Length of fixed area of KFE entry 
literal KFE$C_LENGTH = 73;              !  Length of fixed area of KFE entry 
literal KFE$K_MAXLEN = 112;             !  Max KFE length (includes max filename)
literal KFE$C_MAXLEN = 112;             !  Max KFE length (includes max filename)
literal KFE$K_NUMBER_OF_FLAGS = 16;     !  Number of flag bits used.
literal KFE$S_KFEDEF = 73;              !  Old size name - synonym
literal KFE$S_KFE = 73;
macro KFE$L_HSHLNK = 0,0,32,1 %;        !  Known file Hash table link 
macro KFE$L_KFELINK = 4,0,32,1 %;       !  Ordered Known file entry list link
macro KFE$W_SIZE = 8,0,16,0 %;          !  Size of block 
macro KFE$B_TYPE = 10,0,8,0 %;          !  Structure type 
macro KFE$B_HSHIDX = 11,0,8,0 %;        !  KFE hash table index (index into vector of HSHQ's) 
macro KFE$L_KFD = 12,0,32,1 %;          !  Device, Directory, Type block
macro KFE$R_FLAGS_OVERLAY = 16,0,16,0 %;
macro KFE$W_FLAGS = 16,0,16,0 %;        !  Flags word 
macro KFE$R_FLAGS_BITS = 16,0,16,0 %;
macro KFE$V_PROTECT = 16,0,1,0 %;       !  Known file was installed protected 
macro KFE$V_LIM = 16,1,1,0 %;           !  Linkable image 
macro KFE$V_PROCPRIV = 16,2,1,0 %;      !  Use process privilege mask 
macro KFE$V_OPEN = 16,3,1,0 %;          !  Image installed /OPEN
macro KFE$V_HDRRES = 16,4,1,0 %;        !  Image header block is resident 
macro KFE$V_SHARED = 16,5,1,0 %;        !  Image is shared 
macro KFE$V_KFE_NAMING = 16,6,1,0 %;    !  use KFE based name for global sections
macro KFE$V_NOPURGE = 16,8,1,0 %;       !  Image entry may not be purged
macro KFE$V_ACCOUNT = 16,9,1,0 %;       !  Image level accounting
macro KFE$V_WRITEABLE = 16,10,1,0 %;    !  Global sections are writeable
macro KFE$V_EXEONLY = 16,11,1,0 %;      !  Image has only execute access allowed
macro KFE$V_DISCONTIGUOUS = 16,12,1,0 %; !  Image has resident sections
macro KFE$V_DELETE_PEND = 16,13,1,0 %;  !  Delete pending on KFE
macro KFE$V_VERSION_SAFE = 16,14,1,0 %; !  Image is exempt from system version checks
macro KFE$V_DATA_RESIDENT = 16,15,1,0 %; !  Image has resident read-only data sections
! 
!  Add new bits before this line.  This is so that we can keep the count of the number
!  of flag bits used as accurate as possible.
! 
!  Count of flag bits used.
macro KFE$W_GBLSECCNT = 18,0,16,0 %;    !  Global section count if shared 
macro KFE$L_USECNT = 20,0,32,0 %;       !  Usage counter 
macro KFE$R_WINDOW_OVERLAY = 24,0,32,0 %;
macro KFE$L_WCB = 24,0,32,1 %;          !  WCB address if open 
macro KFE$R_WINDOW_FIELDS = 24,0,32,0 %;
macro KFE$R_FID_OVERLAY = 24,0,16,0 %;
macro KFE$W_FID = 24,0,16,0 %;          !  File id 
macro KFE$W_FID_NUM = 24,0,16,0 %;      !  File number field of file id 
macro KFE$W_FID_SEQ = 26,0,16,0 %;      !  File sequence number field of file id 
macro KFE$R_IMGHDR_OVERLAY = 28,0,32,0 %;
macro KFE$L_IMGHDR = 28,0,32,1 %;       !  Image header address if resident 
macro KFE$W_FID_RVN = 28,0,16,0 %;      !  Relative volume number field of file id 
macro KFE$Q_PROCPRIV = 32,0,0,0 %;
literal KFE$S_PROCPRIV = 8;             !  Process privilege mask 
macro KFE$B_MATCHCTL = 40,0,8,0 %;      !  Global section match control 
macro KFE$W_AMECOD = 42,0,16,0 %;       !  Image header code specifying AME 
macro KFE$L_IDENT = 44,0,32,0 %;        !  Global section ident value 
macro KFE$L_ORB = 48,0,32,1 %;          !  Address of Object Rights Block
macro KFE$W_SHRCNT = 52,0,16,0 %;       !  High water mark for sharing
macro KFE$L_KFERES_PTR = 56,0,32,1 %;   !  Pointer to resident section description 
macro KFE$L_REF_COUNT = 60,0,32,0 %;    !  Reference count
macro KFE$L_PRIV_ISD_CNT = 64,0,32,0 %; !  Private, non-stack ISDs
macro KFE$L_IMAGE_SIZE = 68,0,32,0 %;   !  Size in bytes of installed image (if image header is opened)
macro KFE$B_FILNAMLEN = 72,0,8,0 %;     !  Length of file name
macro KFE$T_FILNAM = 73,0,0,0 %;        !  Offset to file name
 
!*** MODULE $KFE52DEF ***
! 
!  CIRRUS CIO module related definitions
! 
literal KFE52RAM$M_REV = %X'7FF';
literal KFE52RAM$M_SERIALNO = %X'3FF800';
literal KFE52RAM$M_MODULEID = %X'3C00000';
literal KFE52RAM$S_RAMDEF = 8;          !  Old size name - synonym
literal KFE52RAM$S_CIRRAM = 8;
macro KFE52RAM$L_MODDATA = 0,0,32,0 %;  !  
macro KFE52RAM$V_REV = 0,0,11,0 %;
literal KFE52RAM$S_REV = 11;            !  Module revision filed
macro KFE52RAM$V_SERIALNO = 0,11,11,0 %;
literal KFE52RAM$S_SERIALNO = 11;       !  Module serial number
macro KFE52RAM$V_MODULEID = 0,22,4,0 %;
literal KFE52RAM$S_MODULEID = 4;        !  Module id type
macro KFE52RAM$L_MODSTATUS = 4,0,32,0 %; !  Module status
literal KFE52RAM$K_MOD_GOOD = 179;      !  Good module status
literal KFE52RAM$K_MOD_BAD = 76;        !  Bad module status
literal KFE52RAM$L_TRDB = 13312;        !  Trace RAM data block
!  SLIM offsets and definitions
literal SLI520$M_TCA = %X'7C';
literal SLI520$M_TESTPTRS = %X'80';
literal SLI520$M_DIAGMODE = %X'100';
literal SLI520$M_DMASEL = %X'400';
literal SLI520$M_DISARB = %X'800';
literal SLI520$S_SLIMDEF = 4;           !  Old size name - synonym
literal SLI520$S_CIRSLIM = 4;
macro SLI520$L_ICSR0 = 0,0,32,0 %;      !  II32 Control register
macro SLI520$V_TCA = 0,2,5,0 %;
literal SLI520$S_TCA = 5;               !  Trace RAM number
macro SLI520$V_TESTPTRS = 0,7,1,0 %;    !  Test pointers
macro SLI520$V_DIAGMODE = 0,8,1,0 %;    !  Diagnostic mode
macro SLI520$V_DMASEL = 0,10,1,0 %;     !  DMA select
macro SLI520$V_DISARB = 0,11,1,0 %;     !  Disable arbitration
!  FIREWALL offsets
literal FIR520$S_FIRDEF = 48;           !  Old size name - synonym
literal FIR520$S_CIRFIR = 48;
macro FIR520$L_INTVEC0 = 0,0,32,0 %;    !  SWIFT
macro FIR520$L_INTVEC1 = 4,0,32,0 %;    !  LANCE
macro FIR520$L_INTVEC2 = 8,0,32,0 %;    !  Not used
macro FIR520$L_INTVEC3 = 12,0,32,0 %;   !  PCM
macro FIR520$L_UCCRVEC = 16,0,32,0 %;   !  UCCR (read only)
macro FIR520$L_DCCRVEC = 20,0,32,0 %;   !  DCCR (read only)
macro FIR520$L_WINVEC = 28,0,32,0 %;    !  Vector that has won interrupt arbitration
macro FIR520$L_IPL = 32,0,32,0 %;       !  IPL settings for INTVEC0 - INTVEC3 (Interrupt Level)
macro FIR520$L_IMR = 36,0,32,0 %;       !  Interrupt Mask Register
macro FIR520$L_ICS = 40,0,32,0 %;       !  Interrupt Control/Status register.
macro FIR520$L_PCMVEC = 44,0,32,0 %;    !  PCM
!  SCB offsets per section of the second page of the SCB. The second page
!  of the SCB is divided into 16 sections each of which correspond to
!  a slot (TR) number.
literal KA520SCB$S_CIRCSCBDEF = 20;     !  Old size name - synonym
literal KA520SCB$S_CIRSCB = 20;
macro KA520SCB$L_CONI = 0,0,32,0 %;     !  Console input
macro KA520SCB$L_CONO = 4,0,32,0 %;     !  Console output
macro KA520SCB$L_LANCE = 8,0,32,0 %;    !  LANCE
macro KA520SCB$L_SWIFT = 12,0,32,0 %;   !  SWIFT
macro KA520SCB$L_PCM = 16,0,32,0 %;     !  PCM
!  The physical byte offsets of various register from the beginning of a CIO
!  module.
literal KFE52$K_COMM_RAM = 0;           !  COMM RAM
literal KFE52$K_COMM_SIZE = 65536;      !  COMM RAM size
literal KFE52$K_SL_RAM = 65536;         !  SWIFT/LANCE RAM
literal KFE52$K_SL_SIZE = 196608;       !  SWIFT/LANCE RAM size
literal KFE52$K_LANCE_RAM = 65536;      !  LANCE RAM
literal KFE52$K_LANCE_SIZE = 65536;     !  LANCE RAM size
literal KFE52$K_SWIFT_RAM = 131072;     !  SWIFT RAM
literal KFE52$K_SWIFT_SIZE = 131072;    !  SWIFT RAM size
literal KFE52$K_ETH_ADR_ROM = 9043968;  !  Ethernet address ROM
literal KFE52$K_SSC_CSR = 9699328;      !  SSC CSR and RAM
literal KFE52$K_SSC_TOY_CLOCK = 9699436; !  SSC TOY clock
literal KFE52$K_FIREWALL = 10485760;    !  Firewall registers
literal KFE52$K_DMA_BCNT = 10489856;    !  DMA byte count
literal KFE52$K_DMA_STL = 10489860;     !  DMA sub transfer length
literal KFE52$K_DMA_STS = 10489864;     !  DMA status
literal KFE52$K_PCM_CSR = 10498048;     !  PCM CSR
literal KFE52$K_FW_CSR = 10502144;      !  Firewall CSR
literal KFE52$K_CONS_CSR = 10510336;    !  Console registers
literal KFE52$K_SLIM_CSR = 12582912;    !  SLIM CSR
literal KFE52$K_SWIFT_CSR = 12582976;   !  SWIFT CSR
literal KFE52$K_LANCE_CSR = 12583040;   !  LANCE CSR
!  CONSOLE REGISTER offsets and definitions
literal CON520$M_UTYP = %X'100';
literal CON520$M_UID = %X'E00';
literal CON520$M_UBRK = %X'1000';
literal CON520$M_UEIE = %X'2000';
literal CON520$M_UFIE = %X'4000';
literal CON520$M_UBSY = %X'8000';
literal CON520$M_DTYP = %X'100';
literal CON520$M_DID = %X'E00';
literal CON520$M_DEIE = %X'2000';
literal CON520$M_DFIE = %X'4000';
literal CON520$M_DBSY = %X'8000';
literal CON520$S_CONDEF = 8;            !  Old size name - synonym
literal CON520$S_CIRCON = 8;
macro CON520$L_UCCR = 0,0,32,0 %;       !  UPWARD Console Communication Register
macro CON520$V_UDATA = 0,0,8,0 %;
literal CON520$S_UDATA = 8;             !  Data
macro CON520$V_UTYP = 0,8,1,0 %;        !  Type
macro CON520$V_UID = 0,9,3,0 %;
literal CON520$S_UID = 3;               !  ID
macro CON520$V_UBRK = 0,12,1,0 %;       !  CIO module Broken
macro CON520$V_UEIE = 0,13,1,0 %;       !  Empty Interrupt enable
macro CON520$V_UFIE = 0,14,1,0 %;       !  Full Interrupt enable
macro CON520$V_UBSY = 0,15,1,0 %;       !  Busy
macro CON520$L_DCCR = 4,0,32,0 %;       !  DOWNWARD Console Communication Register
macro CON520$V_DDATA = 4,0,8,0 %;
literal CON520$S_DDATA = 8;             !  Data
macro CON520$V_DTYP = 4,8,1,0 %;        !  Type
macro CON520$V_DID = 4,9,3,0 %;
literal CON520$S_DID = 3;               !  ID
macro CON520$V_DEIE = 4,13,1,0 %;       !  Empty interrupt enable
macro CON520$V_DFIE = 4,14,1,0 %;       !  Full Interrupt enable
macro CON520$V_DBSY = 4,15,1,0 %;       !  Busy
literal FWCSR520$M_TRACE_READ = %X'1';
literal FWCSR520$M_CPU_WRITE = %X'2';
literal FWCSR520$M_CPU_READ = %X'4';
literal FWCSR520$M_CPU_XCHK_ENA = %X'8';
literal FWCSR520$M_FW_LOCK = %X'10';
literal FWCSR520$M_II32_DRV = %X'20';
literal FWCSR520$M_DMR_ENA = %X'40';
literal FWCSR520$M_DIAG_MODE = %X'80';
literal FWCSR520$M_IO_XCHK_ERR = %X'100';
literal FWCSR520$M_DIAG_XCHK = %X'200';
literal FWCSR520$M_IO_XCHK_ENA = %X'400';
literal FWCSR520$M_MBZ = %X'800';
literal FWCSR520$M_RAIL_ID = %X'1000';
literal FWCSR520$M_SLOT_ID = %X'E000';
literal FWCSR520$S_FWCSRDEF = 4;        !  Old size name - synonym
literal FWCSR520$S_CIRFWCSR = 4;
macro FWCSR520$L_FWCSR = 0,0,32,0 %;    !  Firewall Control register
macro FWCSR520$V_TRACE_READ = 0,0,1,0 %; !  Read Trace RAMs
macro FWCSR520$V_CPU_WRITE = 0,1,1,0 %; !  CVAX write downward console
macro FWCSR520$V_CPU_READ = 0,2,1,0 %;  !  CVAX read upward console
macro FWCSR520$V_CPU_XCHK_ENA = 0,3,1,0 %; !  CVAX crosscheck enable
macro FWCSR520$V_FW_LOCK = 0,4,1,0 %;   !  Firewall lock
macro FWCSR520$V_II32_DRV = 0,5,1,0 %;  !  1132(T) drive
macro FWCSR520$V_DMR_ENA = 0,6,1,0 %;   !  DMR enable
macro FWCSR520$V_DIAG_MODE = 0,7,1,0 %; !  Diagnostic mode
macro FWCSR520$V_IO_XCHK_ERR = 0,8,1,0 %; !  UVAX crosscheck error
macro FWCSR520$V_DIAG_XCHK = 0,9,1,0 %; !  Diagnostic crosscheck bit
macro FWCSR520$V_IO_XCHK_ENA = 0,10,1,0 %; !  UVAX crosscheck enable
macro FWCSR520$V_MBZ = 0,11,1,0 %;      !  Must be zero
macro FWCSR520$V_RAIL_ID = 0,12,1,0 %;  !  Rail ID
macro FWCSR520$V_SLOT_ID = 0,13,3,0 %;
literal FWCSR520$S_SLOT_ID = 3;         !  Slot ID
macro FWCSR520$V_UNUSED = 0,16,16,0 %;
literal FWCSR520$S_UNUSED = 16;         !  Unused
 
!*** MODULE $KFERESDEF ***
! 
!  KNOWN FILE ENTRY DEFINITIONS FOR RESIDENT SECTIONS
!  
!  Note:  The image activator also copies this structure and
! 	  expands the structure to represent the image's data
! 	  sections which have been compressed in process space.
! 
literal KFERES$M_SHARE_LINK = %X'1';
literal KFERES$K_FIXED_LENGTH = 32;
literal KFERES$C_FIXED_LENGTH = 32;
literal KFERES$S_KFERESDEF = 32;        !  Old size name - synonym
literal KFERES$S_KFERES = 32;
macro KFERES$L_KFE = 0,0,32,1 %;        !  Back pointer to KFE
macro KFERES$L_COUNT = 4,0,32,0 %;      !  Count of resident sections
macro KFERES$W_SIZE = 8,0,16,0 %;       !  Size of block 
macro KFERES$B_TYPE = 10,0,8,0 %;       !  Structure type 
macro KFERES$B_SUBTYPE = 11,0,8,0 %;    !  Subtype
macro KFERES$L_DATA_COUNT = 12,0,32,0 %; !  Count of data sections
macro KFERES$L_FIXUP_BUFFER = 16,0,32,1 %; !  Pointer to fixup buffer
macro KFERES$L_FIXUP_SIZE = 20,0,32,0 %; !  Size of fixup buffer
macro KFERES$R_FLAGS_OVERLAY = 24,0,32,0 %;
macro KFERES$L_FLAGS = 24,0,32,0 %;     !  Flags field
macro KFERES$R_FLAGS_BITS = 24,0,8,0 %;
macro KFERES$V_SHARE_LINK = 24,0,1,0 %; !  Image is installed in a special way
!  to gain maximum performance (linkage
!  has been made shareable).
macro KFERES$L_START_ADDRESS = 28,0,32,1 %; !  For images installed with shareable
!  linkage, this is the starting P1 address
macro KFERES$T_SECTIONS = 32,0,0,0 %;   !  Offset to sections
literal KFERES$K_READ_ONLY_DATA = 1;
literal KFERES$K_CODE = 2;
literal KFERES$K_DZRO = 3;
literal KFERES$K_WRT = 4;
literal KFERES$K_LINKAGE = 5;
literal KFERES$M_SHARESECT = %X'1';
literal KFERES$C_SECTION_LENGTH = 24;
literal KFERES$K_SECTION_LENGTH = 24;
literal KFERES$S_KFERESDEF_SECTION = 24; !  Old size name - synonym
literal KFERES$S_KFERES_SECTION = 24;
macro KFERES$L_VA = 0,0,32,1 %;         !  Starting VA
macro KFERES$L_LENGTH = 4,0,32,0 %;     !  Length in bytes
macro KFERES$L_VBN = 8,0,32,0 %;        !  Starting VBN in image file
macro KFERES$L_IMAGE_OFFSET = 12,0,32,1 %; !  VA offset in image
macro KFERES$L_SECTION_TYPE = 16,0,32,0 %; !  Type of section
macro KFERES$L_SECTION_FLAGS = 20,0,32,0 %; !  Name attributes
macro KFERES$V_SHARESECT = 20,0,1,0 %;  !  Section is shareable
 
!*** MODULE $KFHDEF ***
! 
!  KNOWN FILE IMAGE HEADER DEFINITIONS	*** obsolete, to be removed ***
! 
literal KFH$K_LENGTH = 12;              ! LENGTH OF OVERHEAD AREA 
literal KFH$C_LENGTH = 12;              ! LENGTH OF OVERHEAD AREA 
literal KFH$S_KFHDEF = 12;
! 
literal KFH$S_KFH = 12;
macro KFH$L_BUFEND = 0,0,32,1 %;        ! ADDRESS OF END OF KNOWN FILE HEADER 
macro KFH$L_KFIADR = 4,0,32,1 %;        ! ADDRESS OF ASSOCIATED KNOWN FILE ENTRY 
macro KFH$W_SIZE = 8,0,16,0 %;          ! SIZE OF DYNAMIC STRUCTURE 
macro KFH$B_TYPE = 10,0,8,0 %;          ! DYNAMIC STRUCTURE TYPE 
!  THE REMAINDER OF THIS STRUCTURE CONTAINS THE IMAGE HEADER OF THE
!  SPECIFIED KNOWN FILE.  THE LOCATION KFI$L_IMGHDR IN THE KNOWN FILE
!  ENTRY POINTS KFH$C_LENGTH INTO THIS STRUCTURE, I.E AT THE IMAGE HEADER
!  ITSELF.
! 
 
!*** MODULE $KFIDEF ***
! 
!  KNOWN FILE ENTRY DEFINITIONS 	*** obsolete, to be removed ***
! 
literal KFI$M_KFIHD = %X'1';
literal KFI$M_FILIDOPEN = %X'2';
literal KFI$M_DONOTOPEN = %X'4';
literal KFI$M_NOREPLACE = %X'40';
literal KFI$M_MARKDEL = %X'80';
literal KFI$K_KFIHDLEN = 20;            ! LENGTH OF KFI HEADER FIXED PORTION 
literal KFI$C_KFIHDLEN = 20;            ! LENGTH OF KFI HEADER FIXED PORTION 
literal KFI$M_KFISEQ = %X'3';
literal KFI$M_KP_OPEN = %X'1';
literal KFI$M_KP_RESHDR = %X'2';
literal KFI$M_KP_SHARED = %X'4';
literal KFI$M_PROTECT = %X'8';
literal KFI$M_LIM = %X'40';
literal KFI$M_PROCPRIV = %X'80';
literal KFI$M_IS_RESHDR = %X'100';
literal KFI$M_IS_SHARED = %X'200';
literal KFI$M_SHMIDENT = %X'4000';
literal KFI$M_COMPATMOD = %X'8000';
literal KFI$K_LENGTH = 52;              ! LENGTH OF FIXED AREA OF KFI ENTRY 
literal KFI$C_LENGTH = 52;              ! LENGTH OF FIXED AREA OF KFI ENTRY 
literal KFI$S_KFIDEF = 52;              !  Old size name - synonym
literal KFI$S_KFI = 52;
macro KFI$L_KFIQFL = 0,0,32,1 %;        ! KNOWN FILE QUEUE FORWARD LINK 
macro KFI$L_KFIQBL = 4,0,32,1 %;        ! KNOWN FILE QUEUE BACK LINK 
macro KFI$W_SIZE = 8,0,16,0 %;          ! SIZE OF BLOCK 
macro KFI$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE 
macro KFI$B_KFICTL = 11,0,8,0 %;        ! CONTROL BITS 
macro KFI$V_KFIHD = 11,0,1,0 %;         ! KNOWN FILE HEADER BLOCK 
macro KFI$V_FILIDOPEN = 11,1,1,0 %;     ! OPEN BY FILE ID IF SET 
macro KFI$V_DONOTOPEN = 11,2,1,0 %;     ! DO NOT OPEN THE FILE IF SET 
macro KFI$V_NOREPLACE = 11,6,1,0 %;     ! DELETE AND DO NOT REPLACE ENTRY 
macro KFI$V_MARKDEL = 11,7,1,0 %;       ! ENTRY IS TO BE DELETED 
macro KFI$B_DEVUCB = 12,0,8,0 %;        ! DEVICE UCB OFFSET 
macro KFI$B_DEVNAM = 12,0,8,0 %;        ! NAME THE ABOVE CONSISTENTLY 
macro KFI$B_DIRNAM = 13,0,8,0 %;        ! DIRECTORY NAME STRING OFFSET 
macro KFI$B_FILNAM = 14,0,8,0 %;        ! FILE NAME STRING OFFSET 
macro KFI$B_TYPNAM = 15,0,8,0 %;        ! FILE TYPE STRING OFFSET 
macro KFI$W_REFCNT = 16,0,16,0 %;       ! REFERENCE COUNT 
macro KFI$B_KFIQNUM = 18,0,8,0 %;       ! KFIQ NUMBER (INDEX INTO VECTOR OF KFIQ'S) 
macro KFI$B_KFISEQ = 19,0,8,0 %;        ! KNOWN FILE ENTRY SEQUENCE NUMBER 
macro KFI$V_KFISEQ = 19,0,2,0 %;
literal KFI$S_KFISEQ = 2;               ! SEQUENCE NUMBER FIELD 
macro KFI$W_FLAGS = 20,0,16,0 %;        ! FLAGS WORD 
macro KFI$V_KP_OPEN = 20,0,1,0 %;       ! KEEP THE IMAGE FILE OPEN 
macro KFI$V_KP_RESHDR = 20,1,1,0 %;     ! MAKE IMAGE HEADER RESIDENT 
macro KFI$V_KP_SHARED = 20,2,1,0 %;     ! MAKE IMAGE SHARED 
macro KFI$V_PROTECT = 20,3,1,0 %;       ! KNOWN FILE WAS INSTALLED PROTECTED 
macro KFI$V_LIM = 20,6,1,0 %;           ! LINKABLE IMAGE 
macro KFI$V_PROCPRIV = 20,7,1,0 %;      ! USE PROCESS PRIVILEGE MASK 
macro KFI$V_IS_RESHDR = 20,8,1,0 %;     ! IMAGE HEADER BLOCK IS RESIDENT 
macro KFI$V_IS_SHARED = 20,9,1,0 %;     ! IMAGE IS SHARED 
macro KFI$V_SHMIDENT = 20,14,1,0 %;     ! SHARED MEMORY IDENT ALREADY SET 
macro KFI$V_COMPATMOD = 20,15,1,0 %;    ! IMAGE IS COMPATABILITY MODE 
macro KFI$W_GBLSECCNT = 22,0,16,0 %;    ! GLOBAL SECTION COUNT IF SHARED 
macro KFI$L_USECNT = 24,0,32,0 %;       ! USAGE COUNTER 
macro KFI$L_WINDOW = 28,0,32,1 %;       ! WCB ADDRESS IF OPEN 
macro KFI$W_FID = 28,0,16,0 %;          ! FILE ID 
macro KFI$W_FID_NUM = 28,0,16,0 %;      ! FILE NUMBER FIELD OF FILE ID 
macro KFI$W_FID_SEQ = 30,0,16,0 %;      ! FILE SEQUENCE NUMBER FIELD OF FILE ID 
macro KFI$L_IMGHDR = 32,0,32,1 %;       ! IMAGE HEADER ADDRESS IF RESIDENT 
macro KFI$W_FID_RVN = 32,0,16,0 %;      ! RELATIVE VOLUME NUMBER FIELD OF FILE ID 
macro KFI$Q_PROCPRIV = 36,0,0,0 %;
literal KFI$S_PROCPRIV = 8;             ! PROCESS PRIVILEGE MASK 
macro KFI$B_MATCHCTL = 44,0,8,0 %;      ! GLOBAL SECTION MATCH CONTROL 
macro KFI$W_AMECOD = 46,0,16,0 %;       ! IMAGE HEADER CODE SPECIFYING AME 
macro KFI$L_IDENT = 48,0,32,0 %;        ! GLOBAL SECTION IDENT VALUE 
 
!*** MODULE $KFPDEF ***
! 
!  KNOWN FILE POINTER BLOCK DEFINITIONS 	*** obsolete, to be removed ***
! 
literal KFP$S_KFPDEF = 16;
literal KFP$S_KFP = 16;
macro KFP$B_QUECOUNT = 0,0,8,0 %;       ! INDEX OF LAST KNOWN FILE LIST IN USE 
macro KFP$W_SIZE = 8,0,16,0 %;          ! SIZE OF POINTER BLOCK IN BYTES 
macro KFP$B_TYPE = 10,0,8,0 %;          ! POINTER BLOCK TYPE 
macro KFP$B_TYPE1 = 11,0,8,0 %;         ! TYPE OF STRUCTURE POINTED TO 
macro KFP$L_QUE0 = 12,0,32,0 %;         ! POINTER TO KNOWN FILE QUEUE 0 
 
!*** MODULE $KFPBDEF ***
! 
!  KNOWN FILE POINTER BLOCK DEFINITIONS
! 
literal KFPB$K_LENGTH = 16;             !  Length of pointer block
literal KFPB$C_LENGTH = 16;             !  Length of pointer block
literal KFPB$S_KFPBDEF = 16;
literal KFPB$S_KFPB = 16;
macro KFPB$L_KFDLST = 0,0,32,1 %;       !  Device, Directory, Extension (KFD) list link
macro KFPB$L_KFEHSHTAB = 4,0,32,1 %;    !  Address of Known file name hash table
macro KFPB$W_SIZE = 8,0,16,0 %;         !  Size of pointer block in bytes 
macro KFPB$B_TYPE = 10,0,8,0 %;         !  Pointer block type 
macro KFPB$B_SPARE = 11,0,8,0 %;        !  spare byte
macro KFPB$W_KFDLSTCNT = 12,0,16,0 %;   !  Number of entries in KFD list
macro KFPB$W_HSHTABLEN = 14,0,16,0 %;   !  Length of Hash table
 
!*** MODULE $KFRHDEF ***
! 
!  KNOWN FILE RESIDENT IMAGE HEADER DEFINITIONS
! 
literal KFRH$K_LENGTH = 12;             !  Length of overhead area 
literal KFRH$C_LENGTH = 12;             !  Length of overhead area 
literal KFRH$S_KFRHDEF = 12;            !  Old size name - synonym
! 
literal KFRH$S_KFRH = 12;
macro KFRH$L_BUFEND = 0,0,32,1 %;       !  Address of end of known file header 
macro KFRH$W_ALIAS = 4,0,16,0 %;        !  Use secondary name on activation
macro KFRH$W_SIZE = 8,0,16,0 %;         !  Size of dynamic structure 
macro KFRH$B_TYPE = 10,0,8,0 %;         !  Dynamic structure type 
macro KFRH$B_HDRVER = 11,0,8,0 %;       !  Image header version
macro KFRH$T_IHD = 12,0,0,0 %;          !  Offset to decoded Image Header
!  THE REMAINDER OF THIS STRUCTURE CONTAINS THE IMAGE HEADER OF THE
!  SPECIFIED KNOWN FILE.  THE LOCATION KFE$L_IMGHDR IN THE KNOWN FILE
!  ENTRY POINTS KFRH$C_LENGTH INTO THIS STRUCTURE, I.E AT THE IMAGE HEADER
!  ITSELF.
! 
 
!*** MODULE $KPBDEF ***
! +
!  KPB - Kernel Process Block
! 
!  The Kernel Process Block contains the saved registers, state and
!  stack pointer for a kernel process.
! 
!  The KPB consists of 5 areas:
! 
! 		1  Base,
! 		2a Scheduling,
! 		2b VMS Special Parameters,
! 		3  Spinlock,
! 		4  Debug, and
! 		5  General Parameters
! 
!  The KPB can be used in one of two general types: the VMS executive sofware
!  type (VEST) and the fully general type (FGT).
! 
!  In the VEST KPB, the relationship of KPB sections 1 thru 3 are fixed into
!  the relationship shown in this structure defintion file.  Since the
!  relationships between the VEST KPB fields are fixed, all major fields
!  can be addressed relative to a single pointer register.  This reduces
!  the number of indirect reference operations and increases performance.
!  The penality for the improved performance is a non-dynamic structure
!  format.  In VEST KPBs, the Spinlock area is optional.  This causes the
!  Debug area to be variably located.  Typically, VEST KPBs do not use the 
!  General Parameters area.
! 
!  In the FGT KPB, only the KPB Base section has the format described in
!  this structure definition file.  In addition, the KPB VMS Special
!  Parameters section is not present in FGT KPBs.  Since the KPB Base size
!  is fixed, the KPB Scheduling section can be referenced using offsets from
!  the KPB base pointer register.  All other sections are variable sized,
!  and must be referenced through the pointers provided in the KPB Base.
! 
!  *NB* - The length of each integer numbered area above is rounded to an
! 	  integral number of quadwords.
! 
!  This module also symbolically defines the flags parameter value calls
!  to EXE$KP_ALLOCATE_KPB.
! 
! -
literal KPBDBG$K_PC_VEC_CNT = 8;        !  Size of PC vector
literal KPBDBG$S_KPBDBG = 48;
macro KPBDBG$IS_START_TIME = 0,0,32,0 %; !  Time of last start/restart
macro KPBDBG$IS_START_COUNT = 4,0,32,0 %; !  Count of STARTs
macro KPBDBG$IS_RESTART_COUNT = 8,0,32,0 %; !  Count of RESTARTs
macro KPBDBG$IS_VEC_INDEX = 12,0,32,0 %; !  PC vector index
macro KPBDBG$IS_PC_VEC = 16,0,0,0 %;
literal KPBDBG$S_PC_VEC = 32;           !  PC trace vector
literal KPBDBG$K_LENGTH = 48;           !  Length of KPB Debug section
literal KPBDBG$S_KPBDBGDEF = 48;        !  Old size name, synonym for  KPBDBG$S_KPBDBG
literal KPBSPL$S_KPBSPL = 8;
macro KPBSPL$PS_SPL_STALL_RTN = 0,0,32,1 %; !  Spinlock STALL handling routine pointer
macro KPBSPL$PS_SPL_RESTRT_RTN = 4,0,32,1 %; !  Spinlock RESTART handling routine pointer
literal KPBSPL$K_LENGTH = 8;            !  Length of KPB Spinlock section
literal KPBSPL$S_KPBSPLDEF = 8;         !  Old size name, synonym for  KPBSPL$S_KPBSPL
literal KPBSCH$S_KPBSCH = 80;
macro KPBSCH$PS_SCH_STALL_RTN = 0,0,32,1 %; !  Scheduling STALL handling routine pointer
macro KPBSCH$PS_SCH_RESTRT_RTN = 4,0,32,1 %; !  Scheduling RESTART handling routine pointer
macro KPBSCH$PS_FKBLK = 8,0,32,1 %;     !  pointer to a fork BLOCK
macro KPBSCH$PS_FQFL = 16,0,32,1 %;     !     fork queue flink
macro KPBSCH$PS_FQBL = 20,0,32,1 %;     !     fork queue blink
macro KPBSCH$IW_FKB_SIZE = 24,0,16,0 %; !     fork block size
macro KPBSCH$IB_FKB_TYPE = 26,0,8,0 %;  !     fork block type
macro KPBSCH$IB_FLCK = 27,0,8,0 %;      !     fork lock
macro KPBSCH$PS_FPC = 28,0,32,1 %;      !     fork PC
macro KPBSCH$Q_FR3 = 32,0,0,1 %;
literal KPBSCH$S_FR3 = 8;               !     fork R3
macro KPBSCH$Q_FR4 = 40,0,0,1 %;
literal KPBSCH$S_FR4 = 8;               !     fork R4
macro KPBSCH$PS_TQFL = 16,0,32,1 %;     !     timer queue flink
macro KPBSCH$PS_TQBL = 20,0,32,1 %;     !     timer queue blink
macro KPBSCH$IW_TQE_SIZE = 24,0,16,0 %; !     TQE size
macro KPBSCH$IB_TQE_TYPE = 26,0,8,0 %;  !     TQE type
macro KPBSCH$IB_RQTYPE = 27,0,8,0 %;    !     timer request type
macro KPBSCH$PS_TQE_FPC = 28,0,32,1 %;  !     timer routine pointer
macro KPBSCH$Q_TQE_FR3 = 32,0,0,1 %;
literal KPBSCH$S_TQE_FR3 = 8;           !     timer routine R3
macro KPBSCH$Q_TQE_FR4 = 40,0,0,1 %;
literal KPBSCH$S_TQE_FR4 = 8;           !     timer routine R4
macro KPBSCH$IQ_TIME = 48,0,0,1 %;
literal KPBSCH$S_TIME = 8;              !     timer due time
literal KPBSCH$K_LENGTH = 80;           !  Length of KPB Scheduling section
literal KPBSCH$S_KPBSCHDEF = 80;        !  Old size name, synonym for  KPBSCH$S_KPBSCH
literal KP$M_VEST = %X'4';
literal KP$M_SPLOCK = %X'20';
literal KP$M_DEBUG = %X'40';
literal KP$M_DEALLOC_AT_END = %X'100';
literal KP$M_IO = 292;                  !  The right flags for I/O
literal KP$M_LKMGR = 4;                 !  The right flags for the lock manager
literal KP$S_KPFLAGS = 4;
macro KP$V_VEST = 0,2,1,0 %;            !  KPB VEST format required
macro KP$V_SPLOCK = 0,5,1,0 %;          !  Spinlock   (3) area required
macro KP$V_DEBUG = 0,6,1,0 %;           !  Debug      (4) area present
macro KP$V_DEALLOC_AT_END = 0,8,1,0 %;  !  KP_END should call KP_DEALLOCATE
literal KP$S_KPDEF = 4;                 !  Old size name, synonym for  KP$S_KPFLAGS
literal KPB$K_MIN_IO_STACK = 8192;      !  Minimum I/O stack size in bytes
literal KPB$K_MAX_MPW_STACK = 8192;     !  Maximum stack needed for page writes
literal KPB$M_VALID = %X'1';
literal KPB$M_ACTIVE = %X'2';
literal KPB$M_VEST = %X'4';
literal KPB$M_DELETING = %X'8';
literal KPB$M_SCHED = %X'10';
literal KPB$M_SPLOCK = %X'20';
literal KPB$M_DEBUG = %X'40';
literal KPB$M_PARAM = %X'80';
literal KPB$M_DEALLOC_AT_END = %X'100';
literal KPB$M_BYPASS_CACHE = %X'200';
literal KPB$M_HLL_MASK = %X'400';
literal KPB$M_RESERVED_CACHE = %X'800';
literal KPREG$K_MIN_REG_MASK = 738258944; !  Minimum register mask
literal KPREG$K_MIN_IO_REG_MASK = 738259004; !  Min I/O register mask
literal KPREG$K_ERR_REG_MASK = -738263037; !  Error mask
literal KPREG$K_HLL_REG_MASK = 738263036; !  Default HLL mask
literal KPB$K_LENGTH = 56;              !  Length of KPB base section
literal KPB$K_TQE_LENGTH = 64;
!  length of TQE block 
literal KPB$K_NON_VEST_LENGTH = 136;    !  End of NON_VEST KPB offsets
!   Begin VMS Special Parameters Area
literal KPB$K_KEEP = 1;
literal KPB$K_RELEASE = 2;
literal KPB$K_LOW = 3;
literal KPB$K_HIGH = 4;
literal KPB$K_SCH_LENGTH = 184;         !  Length of KPB + SCH
literal KPB$S_KPB = 192;
macro KPB$PS_FLINK = 0,0,32,1 %;        !  Forward link
macro KPB$PS_BLINK = 4,0,32,1 %;        !  Backward link
macro KPB$IW_SIZE = 8,0,16,0 %;         !  Structure size in bytes
macro KPB$IB_TYPE = 10,0,8,0 %;         !  Structure type
macro KPB$IB_SUBTYPE = 11,0,8,0 %;      !  Structure subtype
macro KPB$IS_STACK_SIZE = 12,0,32,0 %;  !  Stack size in bytes
macro KPB$IS_FLAGS = 16,0,32,0 %;       !  Flags bitmask
macro KPB$V_VALID = 16,0,1,0 %;         !  KPB is valid
macro KPB$V_ACTIVE = 16,1,1,0 %;        !  KPB is in active use
macro KPB$V_VEST = 16,2,1,0 %;          !  KPB is VEST format
macro KPB$V_DELETING = 16,3,1,0 %;      !  KPB is being deleted
macro KPB$V_SCHED = 16,4,1,0 %;         !  Scheduling (2) area present
macro KPB$V_SPLOCK = 16,5,1,0 %;        !  Spinlock   (3) area present
macro KPB$V_DEBUG = 16,6,1,0 %;         !  Debug      (4) area present
macro KPB$V_PARAM = 16,7,1,0 %;         !  Parameter  (5) area present
macro KPB$V_DEALLOC_AT_END = 16,8,1,0 %; !  KP_END should call KP_DEALLOCATE
macro KPB$V_BYPASS_CACHE = 16,9,1,0 %;  !  Don't cache KPB on deallocation
macro KPB$V_HLL_MASK = 16,10,1,0 %;     !  Register mask is HLL_REG_MASK
macro KPB$V_RESERVED_CACHE = 16,11,1,0 %; !  Use reserved KPB cache
macro KPB$PS_SAVED_SP = 20,0,32,1 %;    !  Previous stack pointer
macro KPB$IS_REG_MASK = 24,0,32,0 %;    !  Register save mask
macro KPB$PS_STACK_BASE = 28,0,32,1 %;  !  Stack base address
macro KPB$PS_STACK_SP = 32,0,32,1 %;    !  Current SP
macro KPB$PS_SCH_PTR = 36,0,32,1 %;     !  Address of SCH area
macro KPB$PS_SPL_PTR = 40,0,32,1 %;     !  Address of SPL area
macro KPB$PS_DBG_PTR = 44,0,32,1 %;     !  Address of DBG area
macro KPB$PS_PRM_PTR = 48,0,32,1 %;     !  Address of PRM area
macro KPB$IS_PRM_LENGTH = 52,0,32,0 %;  !  Length of PRM area
macro KPB$PS_SCH_STALL_RTN = 56,0,32,1 %; !  Scheduling STALL handling routine pointer
macro KPB$PS_SCH_RESTRT_RTN = 60,0,32,1 %; !  Scheduling RESTART handling routine pointer
macro KPB$PS_FKBLK = 64,0,32,1 %;       !  pointer to a fork block
macro KPB$PS_FQFL = 72,0,32,1 %;        !     fork queue flink
macro KPB$PS_FQBL = 76,0,32,1 %;        !     fork queue blink
macro KPB$IW_FKB_SIZE = 80,0,16,0 %;    !     fork block size
macro KPB$IB_FKB_TYPE = 82,0,8,0 %;     !     fork block type
macro KPB$IB_FLCK = 83,0,8,0 %;         !     fork lock
macro KPB$PS_FPC = 84,0,32,1 %;         !     fork PC
macro KPB$Q_FR3 = 88,0,0,1 %;
literal KPB$S_FR3 = 8;                  !     fork R3
macro KPB$Q_FR4 = 96,0,0,1 %;
literal KPB$S_FR4 = 8;                  !     fork R4
macro KPB$PS_TQFL = 72,0,32,1 %;        !     timer queue flink
macro KPB$PS_TQBL = 76,0,32,1 %;        !     timer queue blink
macro KPB$IW_TQE_SIZE = 80,0,16,0 %;    !     TQE size
macro KPB$IB_TQE_TYPE = 82,0,8,0 %;     !     TQE type
macro KPB$IB_RQTYPE = 83,0,8,0 %;       !     timer request type
macro KPB$PS_TQE_FPC = 84,0,32,1 %;     !     timer routine pointer
macro KPB$Q_TQE_FR3 = 88,0,0,1 %;
literal KPB$S_TQE_FR3 = 8;              !     timer routine R3
macro KPB$Q_TQE_FR4 = 96,0,0,1 %;
literal KPB$S_TQE_FR4 = 8;              !     timer routine R4
macro KPB$IQ_TIME = 104,0,0,1 %;
literal KPB$S_TIME = 8;                 !     timer due time
!   (VEST KPB's only)
macro KPB$PS_UCB = 136,0,32,1 %;        !    UCB address
macro KPB$PS_IRP = 140,0,32,1 %;        !    IRP address
! 	  vestioblks union fill;
macro KPB$IS_TIMEOUT_TIME = 144,0,32,0 %; !    WFI%%CH time out time
macro KPB$IS_RESTORE_IPL = 148,0,32,0 %; !    WFI%%CH IPL to restore
macro KPB$IS_CHANNEL_DATA = 152,0,32,0 %; !    WFI%%CH/REQCHN channel data
macro KPB$PS_SCSI_PTR1 = 156,0,32,1 %;  !    SCSI gen. struc ptr #1
macro KPB$PS_SCSI_PTR2 = 160,0,32,1 %;  !    SCSI gen. struc ptr #2
macro KPB$PS_SCSI_SCDRP = 164,0,32,1 %; !    SCSI transfer SCDRP addr.
macro KPB$IS_TIMEOUT = 168,0,32,0 %;    !    time out time
macro KPB$IS_NEWIPL = 172,0,32,0 %;     !    IPL to restore
macro KPB$PS_DLCK = 176,0,32,1 %;       !    device spin lock
! 	end vestio;
macro KPB$PS_LKB = 136,0,32,1 %;        !    LKB address
macro KPB$PS_SPL_STALL_RTN = 184,0,32,1 %; !  Spinlock STALL handling routine pointer
macro KPB$PS_SPL_RESTRT_RTN = 188,0,32,1 %; !  Spinlock RESTART handling routine pointer
literal KPB$K_SPL_LENGTH = 192;         !  Length of KPB + SCH + SPL
literal KPB$S_KPBDEF = 192;             !  Old size name, synonym for KPB$S_KPB
 
!*** MODULE $LCADEF ***
literal LCA$L_MEM_BCR0_L = 536870912;
literal LCA$L_MEM_BCR0_H = 1;
literal LCA$L_MEM_BCR1_L = 536870920;
literal LCA$L_MEM_BCR1_H = 1;
literal LCA$L_MEM_BCR2_L = 536870928;
literal LCA$L_MEM_BCR2_H = 1;
literal LCA$L_MEM_BCR3_L = 536870936;
literal LCA$L_MEM_BCR3_H = 1;
literal LCA$L_MEM_BMR0_L = 536870944;
literal LCA$L_MEM_BMR0_H = 1;
literal LCA$L_MEM_BMR1_L = 536870952;
literal LCA$L_MEM_BMR1_H = 1;
literal LCA$L_MEM_BMR2_L = 536870960;
literal LCA$L_MEM_BMR2_H = 1;
literal LCA$L_MEM_BMR3_L = 536870968;
literal LCA$L_MEM_BMR3_H = 1;
literal LCA$L_MEM_BTR0_L = 536870976;
literal LCA$L_MEM_BTR0_H = 1;
literal LCA$L_MEM_BTR1_L = 536870984;
literal LCA$L_MEM_BTR1_H = 1;
literal LCA$L_MEM_BTR2_L = 536870992;
literal LCA$L_MEM_BTR2_H = 1;
literal LCA$L_MEM_BTR3_L = 536871000;
literal LCA$L_MEM_BTR3_H = 1;
literal LCA$L_MEM_GTR_L = 536871008;
literal LCA$L_MEM_GTR_H = 1;
literal LCA$L_MEM_ESR_L = 536871016;
literal LCA$L_MEM_ESR_H = 1;
literal LCA$L_MEM_EAR_L = 536871024;
literal LCA$L_MEM_EAR_H = 1;
literal LCA$L_MEM_CAR_L = 536871032;
literal LCA$L_MEM_CAR_H = 1;
literal LCA$L_MEM_VGR_L = 536871040;
literal LCA$L_MEM_VGR_H = 1;
literal LCA$L_MEM_PLM_L = 536871048;
literal LCA$L_MEM_PLM_H = 1;
literal LCA$L_MEM_FOR_L = 536871056;
literal LCA$L_MEM_FOR_H = 1;
literal LCA$L_IOC_HAE_PA_L = -2147483648;
literal LCA$L_IOC_HAE_PA_H = 1;
literal LCA$L_IOC_CFG_CYC_PA_L = -2147483648;
literal LCA$L_IOC_CFG_CYC_PA_H = 32;
literal LCA$L_IOC_STAT0_PA_L = -2147483584;
literal LCA$L_IOC_STAT0_PA_H = 1;
literal LCA$L_IOC_STAT1_PA_L = -2147483552;
literal LCA$L_IOC_STAT1_PA_H = 1;
literal LCA$L_IOC_TBIA_PA_L = -2147483520;
literal LCA$L_IOC_TBIA_PA_H = 1;
literal LCA$L_IOC_TB_ENA_PA_L = -2147483648;
literal LCA$L_IOC_TB_ENA_PA_H = 160;
literal LCA$L_PCI_SFT_RST_PA_L = -2147483648;
literal LCA$L_PCI_SFT_RST_PA_H = 192;
literal LCA$L_PCI_PAR_DIS_PA_L = -2147483648;
literal LCA$L_PCI_PAR_DIS_PA_H = 224;
literal LCA$L_IOC_W_BASE0_PA_L = -2147483392;
literal LCA$L_IOC_W_BASE0_PA_H = 1;
literal LCA$L_IOC_W_BASE1_PA_L = -2147483360;
literal LCA$L_IOC_W_BASE1_PA_H = 1;
literal LCA$L_IOC_W_MASK0_PA_L = -2147483328;
literal LCA$L_IOC_W_MASK0_PA_H = 1;
literal LCA$L_IOC_W_MASK1_PA_L = -2147483296;
literal LCA$L_IOC_W_MASK1_PA_H = 1;
literal LCA$L_IOC_T_BASE0_PA_L = -2147483264;
literal LCA$L_IOC_T_BASE0_PA_H = 1;
literal LCA$L_IOC_T_BASE1_PA_L = -2147483232;
literal LCA$L_IOC_T_BASE1_PA_H = 1;
literal LCA$L_IOC_TB_TAG0_PA_L = -2130706432;
literal LCA$L_IOC_TB_TAG0_PA_H = 1;
literal LCA$L_IOC_TB_TAG1_PA_L = -2130706400;
literal LCA$L_IOC_TB_TAG1_PA_H = 1;
literal LCA$L_IOC_TB_TAG2_PA_L = -2130706368;
literal LCA$L_IOC_TB_TAG2_PA_H = 1;
literal LCA$L_IOC_TB_TAG3_PA_L = -2130706336;
literal LCA$L_IOC_TB_TAG3_PA_H = 1;
literal LCA$L_IOC_TB_TAG4_PA_L = -2130706304;
literal LCA$L_IOC_TB_TAG4_PA_H = 1;
literal LCA$L_IOC_TB_TAG5_PA_L = -2130706272;
literal LCA$L_IOC_TB_TAG5_PA_H = 1;
literal LCA$L_IOC_TB_TAG6_PA_L = -2130706240;
literal LCA$L_IOC_TB_TAG6_PA_H = 1;
literal LCA$L_IOC_TB_TAG7_PA_L = -2130706208;
literal LCA$L_IOC_TB_TAG7_PA_H = 1;
literal LCA$L_IOC_IACK_SC_PA_L = -1610612736;
literal LCA$L_IOC_IACK_SC_PA_H = 1;
literal LCA$L_PCI_IO_PA_L = -1073741824;
literal LCA$L_PCI_IO_PA_H = 1;
literal LCA$L_PCI_CFG_PA_L = -536870912;
literal LCA$L_PCI_CFG_PA_H = 1;
literal LCA$L_PCI_SPARSE_MEM_PA_L = 0;
literal LCA$L_PCI_SPARSE_MEM_PA_H = 2;
literal LCA$L_PCI_DENSE_MEM_PA_L = 0;
literal LCA$L_PCI_DENSE_MEM_PA_H = 3;
literal LCA$M_HAE_BITS = %X'F8000000';
literal LCA$M_CFG_AD = %X'3';
literal LCA$M_STAT0_CMD = %X'F';
literal LCA$M_IOC_ERR = %X'10';
literal LCA$M_IOC_LOST_ERR = %X'20';
literal LCA$M_IOC_T_HIT = %X'40';
literal LCA$M_IOC_T_REF = %X'80';
literal LCA$M_IOC_ERR_CODE = %X'700';
literal LCA$M_STAT1_ADDR = %X'FFFFFFFF';
literal LCA$M_TB_EN = %X'80';
literal LCA$M_PCI_SFT_RESET = %X'40';
literal LCA$M_PCI_PAR_DIS = %X'20';
literal LCA$M_W_BASE0_BITS = %X'FFF00000';
literal LCA$M_W_BASE0_SG = %X'100000000';
literal LCA$M_W_BASE0_WEN = %X'200000000';
literal LCA$M_W_BASE1_BITS = %X'FFF00000';
literal LCA$M_W_BASE1_SG = %X'100000000';
literal LCA$M_W_BASE1_WEN = %X'200000000';
literal LCA$M_W_MASK0_BITS = %X'FFF00000';
literal LCA$M_W_MASK1_BITS = %X'FFF00000';
literal LCA$M_T_BASE0_BITS = %X'FFFFFC00';
literal LCA$M_T_BASE1_BITS = %X'FFFFFC00';
literal LCA$M_TB_TAG0_BITS = %X'FFFFE000';
literal LCA$M_TB_TAG1_BITS = %X'FFFFE000';
literal LCA$M_TB_TAG2_BITS = %X'FFFFE000';
literal LCA$M_TB_TAG3_BITS = %X'FFFFE000';
literal LCA$M_TB_TAG4_BITS = %X'FFFFE000';
literal LCA$M_TB_TAG5_BITS = %X'FFFFE000';
literal LCA$M_TB_TAG6_BITS = %X'FFFFE000';
literal LCA$M_TB_TAG7_BITS = %X'FFFFE000';
literal LCA$S_LCA = 24576;
macro LCA$Q_BCR0 = 0,0,0,1 %;
literal LCA$S_BCR0 = 8;
macro LCA$Q_BCR1 = 8,0,0,1 %;
literal LCA$S_BCR1 = 8;
macro LCA$Q_BCR2 = 16,0,0,1 %;
literal LCA$S_BCR2 = 8;
macro LCA$Q_BCR3 = 24,0,0,1 %;
literal LCA$S_BCR3 = 8;
macro LCA$Q_BMR0 = 32,0,0,1 %;
literal LCA$S_BMR0 = 8;
macro LCA$Q_BMR1 = 40,0,0,1 %;
literal LCA$S_BMR1 = 8;
macro LCA$Q_BMR2 = 48,0,0,1 %;
literal LCA$S_BMR2 = 8;
macro LCA$Q_BMR3 = 56,0,0,1 %;
literal LCA$S_BMR3 = 8;
macro LCA$Q_BTR0 = 64,0,0,1 %;
literal LCA$S_BTR0 = 8;
macro LCA$Q_BTR1 = 72,0,0,1 %;
literal LCA$S_BTR1 = 8;
macro LCA$Q_BTR2 = 80,0,0,1 %;
literal LCA$S_BTR2 = 8;
macro LCA$Q_BTR3 = 88,0,0,1 %;
literal LCA$S_BTR3 = 8;
macro LCA$Q_GTR = 96,0,0,1 %;
literal LCA$S_GTR = 8;
macro LCA$Q_ESR = 104,0,0,1 %;
literal LCA$S_ESR = 8;
macro LCA$Q_EAR = 112,0,0,1 %;
literal LCA$S_EAR = 8;
macro LCA$Q_CAR = 120,0,0,1 %;
literal LCA$S_CAR = 8;
macro LCA$Q_VGR = 128,0,0,1 %;
literal LCA$S_VGR = 8;
macro LCA$Q_PLM = 136,0,0,1 %;
literal LCA$S_PLM = 8;
macro LCA$Q_FOR = 144,0,0,1 %;
literal LCA$S_FOR = 8;
macro LCA$Q_HAE = 8192,0,0,1 %;
literal LCA$S_HAE = 8;
macro LCA$V_HAE_BITS = 8192,27,5,0 %;
macro LCA$Q_PCI_CFG_CYC = 8224,0,0,1 %;
literal LCA$S_PCI_CFG_CYC = 8;
macro LCA$V_CFG_AD = 8224,0,2,0 %;
literal LCA$S_CFG_AD = 2;
macro LCA$Q_STAT0 = 8256,0,0,1 %;
literal LCA$S_STAT0 = 8;
macro LCA$V_STAT0_CMD = 8256,0,4,0 %;
literal LCA$S_STAT0_CMD = 4;
macro LCA$V_IOC_ERR = 8256,4,1,0 %;
macro LCA$V_IOC_LOST_ERR = 8256,5,1,0 %;
macro LCA$V_IOC_T_HIT = 8256,6,1,0 %;
macro LCA$V_IOC_T_REF = 8256,7,1,0 %;
macro LCA$V_IOC_ERR_CODE = 8256,8,3,0 %;
literal LCA$S_IOC_ERR_CODE = 3;
macro LCA$Q_STAT1 = 8288,0,0,1 %;
literal LCA$S_STAT1 = 8;
macro LCA$V_STAT1_ADDR = 8288,0,32,0 %;
literal LCA$S_STAT1_ADDR = 32;
macro LCA$Q_TBIA = 8320,0,0,1 %;
literal LCA$S_TBIA = 8;
macro LCA$Q_TB_ENA = 8352,0,0,1 %;
literal LCA$S_TB_ENA = 8;
macro LCA$V_TB_EN = 8352,7,1,0 %;
macro LCA$Q_PCI_SFT_RST = 8384,0,0,1 %;
literal LCA$S_PCI_SFT_RST = 8;
macro LCA$V_PCI_SFT_RESET = 8384,6,1,0 %;
macro LCA$Q_PCI_PAR_DIS = 8416,0,0,1 %;
literal LCA$S_PCI_PAR_DIS = 8;
macro LCA$V_PCI_PAR_DIS = 8416,5,1,0 %;
macro LCA$Q_W_BASE0 = 8448,0,0,1 %;
literal LCA$S_W_BASE0 = 8;
macro LCA$V_W_BASE0_BITS = 8448,20,12,0 %;
macro LCA$V_W_BASE0_SG = 8452,0,1,0 %;
macro LCA$V_W_BASE0_WEN = 8452,1,1,0 %;
macro LCA$Q_W_BASE1 = 8480,0,0,1 %;
literal LCA$S_W_BASE1 = 8;
macro LCA$V_W_BASE1_BITS = 8480,20,12,0 %;
macro LCA$V_W_BASE1_SG = 8484,0,1,0 %;
macro LCA$V_W_BASE1_WEN = 8484,1,1,0 %;
macro LCA$Q_W_MASK0 = 8512,0,0,1 %;
literal LCA$S_W_MASK0 = 8;
macro LCA$V_W_MASK0_BITS = 8512,20,12,0 %;
macro LCA$Q_W_MASK1 = 8544,0,0,1 %;
literal LCA$S_W_MASK1 = 8;
macro LCA$V_W_MASK1_BITS = 8544,20,12,0 %;
macro LCA$Q_T_BASE0 = 8576,0,0,1 %;
literal LCA$S_T_BASE0 = 8;
macro LCA$V_T_BASE0_BITS = 8576,10,22,0 %;
macro LCA$Q_T_BASE1 = 8608,0,0,1 %;
literal LCA$S_T_BASE1 = 8;
macro LCA$V_T_BASE1_BITS = 8608,10,22,0 %;
macro LCA$Q_TB_TAG0 = 16384,0,0,1 %;
literal LCA$S_TB_TAG0 = 8;
macro LCA$V_TB_TAG0_BITS = 16384,13,19,0 %;
macro LCA$Q_TB_TAG1 = 16416,0,0,1 %;
literal LCA$S_TB_TAG1 = 8;
macro LCA$V_TB_TAG1_BITS = 16416,13,19,0 %;
macro LCA$Q_TB_TAG2 = 16448,0,0,1 %;
literal LCA$S_TB_TAG2 = 8;
macro LCA$V_TB_TAG2_BITS = 16448,13,19,0 %;
macro LCA$Q_TB_TAG3 = 16480,0,0,1 %;
literal LCA$S_TB_TAG3 = 8;
macro LCA$V_TB_TAG3_BITS = 16480,13,19,0 %;
macro LCA$Q_TB_TAG4 = 16512,0,0,1 %;
literal LCA$S_TB_TAG4 = 8;
macro LCA$V_TB_TAG4_BITS = 16512,13,19,0 %;
macro LCA$Q_TB_TAG5 = 16544,0,0,1 %;
literal LCA$S_TB_TAG5 = 8;
macro LCA$V_TB_TAG5_BITS = 16544,13,19,0 %;
macro LCA$Q_TB_TAG6 = 16576,0,0,1 %;
literal LCA$S_TB_TAG6 = 8;
macro LCA$V_TB_TAG6_BITS = 16576,13,19,0 %;
macro LCA$Q_TB_TAG7 = 16608,0,0,1 %;
literal LCA$S_TB_TAG7 = 8;
macro LCA$V_TB_TAG7_BITS = 16608,13,19,0 %;
literal LCA$K_LENGTH = 24576;
! 
!  DS1287A register definitions
!                            
literal LCA_DS1287A$S_LCA_DS1287A = 3624;
macro LCA_DS1287A$L_PORT_INDEX = 3584,0,32,0 %;
macro LCA_DS1287A$L_PORT_DATA = 3616,0,32,0 %;
 
!*** MODULE $LCKCTXDEF ***
! +
!  LCKCTX - LOCK CONTEXT BLOCK
! 
! -
literal LCKCTX$M_BUSY = %X'1';
literal LCKCTX$M_CANCEL = %X'2';
literal LCKCTX$M_CMP_RQD = %X'4';
literal LCKCTX$K_FIX_LEN = 76;          !  FIXED LENGTH
literal LCKCTX$C_FIX_LEN = 76;          !  FIXED LENGTH
literal LCKCTX$S_LCKCTXDEF = 77;
literal LCKCTX$S_LCKCTX = 77;
macro LCKCTX$L_FQFL = 0,0,32,1 %;       !  FORWARD LINK
macro LCKCTX$L_FQBL = 4,0,32,1 %;       !  BACKWARD LINK
macro LCKCTX$W_SIZE = 8,0,16,0 %;       !  SIZE
macro LCKCTX$B_TYPE = 10,0,8,0 %;       !  TYPE
macro LCKCTX$B_FLCK = 11,0,8,0 %;       !  FORK LOCK
macro LCKCTX$L_FPC = 12,0,32,0 %;       !  FORK PC
macro LCKCTX$Q_FR3 = 16,0,0,1 %;
literal LCKCTX$S_FR3 = 8;               !  FORK R3
macro LCKCTX$Q_FR4 = 24,0,0,1 %;
literal LCKCTX$S_FR4 = 8;               !  FORK R4
macro LCKCTX$L_FLAGS = 32,0,32,0 %;     !  FLAGS
macro LCKCTX$V_BUSY = 32,0,1,0 %;       !  BUSY
macro LCKCTX$V_CANCEL = 32,1,1,0 %;     !  OPERATION CANCELED
macro LCKCTX$V_CMP_RQD = 32,2,1,0 %;    !  COMPLETION REQUIRED
macro LCKCTX$L_LKB = 36,0,32,1 %;       !  LKB ADDRESS
macro LCKCTX$L_CR3 = 40,0,32,0 %;       !  CALLER'S R3
macro LCKCTX$L_CR4 = 44,0,32,0 %;       !  CALLER'S R4
macro LCKCTX$L_CR5 = 48,0,32,0 %;       !  CALLER'S R5
macro LCKCTX$L_CTX_PRM1 = 52,0,32,0 %;  !  CONTET PARAMETER 1
macro LCKCTX$L_CTX_PRM2 = 56,0,32,0 %;  !  CONTET PARAMETER 2
macro LCKCTX$L_CTX_PRM3 = 60,0,32,0 %;  !  CONTET PARAMETER 3
macro LCKCTX$L_CRETADR = 64,0,32,1 %;   !  CALLER'S RETURN ADDRESS
macro LCKCTX$L_RET1 = 68,0,32,1 %;      !  STORAGE FOR SECOND RETURN
macro LCKCTX$L_TMP1 = 72,0,32,1 %;      !  TEMPORARY STORAGE
macro LCKCTX$L_CPLADR = 36,0,32,1 %;    !  COMPLETION NOTIFICATION ADDR
macro LCKCTX$L_CPLPRM = 40,0,32,0 %;    !  CONTEXT PARAMETER
macro LCKCTX$B_ARGS = 76,0,8,1 %;
literal LCKCTX$S_ARGS = 1;              !  VARIABLE PART
 
!*** MODULE $LCKDLBDEF ***
! +
!  LCKDLB - Lock manager deadlock context block
! -
literal LCKDLB$K_LENGTH = 32;           !  Length of LCKDLB
literal LCKDLB$C_LENGTH = 32;           !  Length of LCKDLB
literal LCKDLB$S_LCKDLB = 32;
macro LCKDLB$L_MAXERNG = 0,0,32,0 %;
macro LCKDLB$L_MAXSRNG = 4,0,32,0 %;
macro LCKDLB$L_SR2 = 8,0,32,0 %;
macro LCKDLB$L_SR3 = 12,0,32,0 %;
macro LCKDLB$L_SR4 = 16,0,32,0 %;
macro LCKDLB$L_SR5 = 20,0,32,0 %;
macro LCKDLB$L_SR6 = 24,0,32,0 %;
macro LCKDLB$L_PREV = 28,0,32,0 %;
 
!*** MODULE $LCKMGRDEF ***
! +
!  This macro defines the bit definitions for the global Lock Manager
!  cell LCK$GL_FLAGS.
! 
! -
literal LCKMGR$M_CLUINT = %X'1';
literal LCKMGR$M_LCKINT = %X'2';
literal LCKMGR$M_CHK_BTR = %X'4';
literal LCKMGR$M_FRK_ENBL = %X'8';
literal LCKMGR$M_COMPAT_DYNRM = %X'10';
literal LCKMGR$M_COMPAT_RNGLCK = %X'20';
literal LCKMGR$M_COMPAT_MULTITASK = %X'40';
literal LCKMGR$M_COMPAT_CWPS = %X'80';
literal LCKMGR$M_RM1SEC = %X'100';
literal LCKMGR$S_LCKMGRDEF = 2;         !  Old size name - synonym
literal LCKMGR$S_LCKMGR = 2;
macro LCKMGR$V_CLUINT = 0,0,1,0 %;      !  CLuster Init Complete
macro LCKMGR$V_LCKINT = 0,1,1,0 %;      !  Lock Manager Init Complete
macro LCKMGR$V_CHK_BTR = 0,2,1,0 %;     !  Check for better master
macro LCKMGR$V_FRK_ENBL = 0,3,1,0 %;    !  Fork interface enabled
macro LCKMGR$V_COMPAT_DYNRM = 0,4,1,0 %; !  Use old (V5.2) remastering algorithm
macro LCKMGR$V_COMPAT_RNGLCK = 0,5,1,0 %; !  node that does not support range locking is present
macro LCKMGR$V_COMPAT_MULTITASK = 0,6,1,0 %; !  node that does not support multitasking is present
macro LCKMGR$V_COMPAT_CWPS = 0,7,1,0 %; !  node that does not support cwps is present
macro LCKMGR$V_RM1SEC = 0,8,1,0 %;      !  use 1 second activity scan
! 
!  Define threshold values for dynamic remastering.
! 
literal lckmgr$K_RM8SEC_ACT_THRSH = 80;
literal lckmgr$K_RM8SEC_SYS_THRSH = 80;
literal lckmgr$K_RM1SEC_ACT_THRSH = 10;
literal lckmgr$K_RM1SEC_SYS_THRSH = 10;
!  Definitions for response codes for lock manager front end routines.
!  
! 
literal FRTN$K_QUEIT = 0;               !  request must be queued
literal FRTN$K_GRNT1 = 1;               !  request is compatible
literal FRTN$K_GRNT2 = 2;               !  rqst is compat, max-modes computed, grant waiters
literal FRTN$K_GRNT3 = 3;               !  rqst is compat, max-mode not computed, grant waiters
literal FRTN$S_FRTN_CODES = 1;          !  front end routine response codes
macro FRTN$B_CODES = 0,0,8,0 %;
! 
! 	Lock manager routine handling definitions
! 
literal LCK$K_CH_CVT_GRANTED = 1;
literal LCK$K_CH_QUEUED_EXIT = 2;
literal LCK$K_CH_CVTNOTQED = 3;
literal LCK$K_CH_LOCAL_CVT = 4;
literal LCK$K_CH_FORK_EXIT = 5;
! 
! 	Lock manager routine handling definitions
! 
literal LCK$K_LH_LOCAL_LOCK = 1;
literal LCK$K_LH_SYNC_EXIT = 2;
literal LCK$K_LH_QUEUED_EXIT = 3;
literal LCK$K_LH_NOT_QUEUED = 4;
literal LCK$K_LH_FORK_EXIT = 5;
 
!*** MODULE $LDBDEF ***
! 
!  $LOAD_DRIVER Data Block
! 
literal LDB$M_DDB = %X'1';
literal LDB$M_CRB = %X'2';
literal LDB$M_IDB = %X'4';
literal LDB$M_UCB = %X'8';
literal LDB$M_LINKED_UCB = %X'10';
literal LDB$M_NOADAP = %X'20';
literal LDB$M_CRBBLT = %X'40';
literal LDB$M_SCBVEC = %X'80';
literal LDB$M_REMOTE = %X'100';
literal LDB$M_SCS = %X'200';
literal LDB$M_SCSI_PORT = %X'400';
literal LDB$M_ADD_UNIT = %X'800';
literal LDB$K_MAXVEC = 32;              !  maximum # of interrupt vectors per device
literal LDB$K_LENGTH = 532;
literal LDB$C_LENGTH = 532;
literal LDB$S_LDBDEF = 532;             !  Old size name - synonym
literal LDB$S_LDB = 532;
macro LDB$PS_FLINK = 0,0,32,1 %;        !  Link to next LDB
macro LDB$PS_BLINK = 4,0,32,1 %;        !  Link to previous LDB
macro LDB$W_SIZE = 8,0,16,0 %;          !  size of this structure
macro LDB$B_TYPE = 10,0,8,0 %;          !  structure type
macro LDB$B_SUBTYPE = 11,0,8,0 %;       !  structure subtype
!  Status information
macro LDB$L_FLAGS = 12,0,32,0 %;        !  control and status flags
macro LDB$V_DDB = 12,0,1,0 %;           !  built a DDB
macro LDB$V_CRB = 12,1,1,0 %;           !  built a CRB
macro LDB$V_IDB = 12,2,1,0 %;           !  built an IDB
macro LDB$V_UCB = 12,3,1,0 %;           !  built a UCB
macro LDB$V_LINKED_UCB = 12,4,1,0 %;    !  UCB has been linked into DDB chain
macro LDB$V_NOADAP = 12,5,1,0 %;        !  connect to NULL adapter
macro LDB$V_CRBBLT = 12,6,1,0 %;        !  SYSLOA_CRB item was specified
macro LDB$V_SCBVEC = 12,7,1,0 %;        !  VECTOR is offset into SCB
macro LDB$V_REMOTE = 12,8,1,0 %;        !  device is on a remote system
macro LDB$V_SCS = 12,9,1,0 %;           !  associated driver requires SCS
macro LDB$V_SCSI_PORT = 12,10,1,0 %;    !  device is a SCSI port
macro LDB$V_ADD_UNIT = 12,11,1,0 %;     !  may be an "add unit" request
!  Input items
macro LDB$L_UNIT = 16,0,32,0 %;         !  unit number to connect
macro LDB$Q_CSR = 20,0,0,0 %;
literal LDB$S_CSR = 8;                  !  CSR "magic number"
macro LDB$Q_SYSID = 28,0,0,0 %;
literal LDB$S_SYSID = 8;                !  SCS SYSID of controller
macro LDB$L_VECTOR = 36,0,0,0 %;
literal LDB$S_VECTOR = 128;             !  byte offset into SCB/vector table
macro LDB$L_NUMVEC = 164,0,32,0 %;      !  number of interrupt vectors
macro LDB$L_MAXUNITS = 168,0,32,0 %;    !  maximum number of units allowed
!  Input/Output items
macro LDB$Q_DLVR_DATA = 172,0,0,0 %;
literal LDB$S_DLVR_DATA = 8;            !  working copy of deliver data
macro LDB$PS_USER_DLVR = 180,0,32,1 %;  !  address of caller's deliver data
macro LDB$L_NUMUNITS = 184,0,32,1 %;    !  number of units to connect now
!  Output items
macro LDB$PS_ADP = 188,0,32,1 %;        !  address of ADaPter control block
macro LDB$PS_DPT = 192,0,32,1 %;        !  address of Driver Prologue Table
macro LDB$PS_SB = 196,0,32,1 %;         !  address of System Block
macro LDB$PS_DDB = 200,0,32,1 %;        !  address of Device Data Block
macro LDB$PS_CRB = 204,0,32,1 %;        !  address of Channel Request Block
macro LDB$PS_IDB = 208,0,32,1 %;        !  address of Interrupt Dispatch Block
macro LDB$PS_UCB = 212,0,32,1 %;        !  address of Unit Control Block
macro LDB$PS_FORK = 216,0,32,1 %;       !  address of associated fork block
!  Working data
macro LDB$PS_LASTDDB = 220,0,32,1 %;    !  DDB address returned by IOC$SEARCHALL
macro LDB$IL_DPT_MAXUNITS = 224,0,32,1 %; !  DPT's view of MAXUNITS
macro LDB$T_DPT_NAME = 228,0,0,0 %;
literal LDB$S_DPT_NAME = 16;            !  name stored in ASCIC format
macro LDB$IB_DPT_NAMELEN = 228,0,8,0 %; !  character count in DPT_NAME
macro LDB$T_DPT_NAMESTR = 229,0,0,0 %;
literal LDB$S_DPT_NAMESTR = 15;         !  actual string
macro LDB$IL_DEVLEN = 244,0,32,1 %;     !  length of device name in DEVNAM
macro LDB$PS_SEARCHNAME = 248,0,32,1 %; !  name used for IOC$SEARCHALL
macro LDB$IL_DDB_NAMELEN = 252,0,32,1 %; !  length of DEVNAM copied to DDB
macro LDB$PS_DDB_NAME = 256,0,32,1 %;   !  beginning of name to copy to DDB
macro LDB$T_DEVNAM = 260,0,0,0 %;
literal LDB$S_DEVNAM = 16;              !  name of device being connected
macro LDB$T_DRVNAM = 276,0,0,0 %;
literal LDB$S_DRVNAM = 256;             !  name stored in ASCIC format
macro LDB$IB_DRVNAMLEN = 276,0,8,0 %;   !  character count in DRVNAM
macro LDB$T_DRVNAMSTR = 277,0,0,0 %;
literal LDB$S_DRVNAMSTR = 255;          !  actual string
 
!*** MODULE $LDRDEF ***
literal LDR$M_PAG = %X'1';
literal LDR$M_UNL = %X'2';
literal LDR$M_OVR = %X'4';
literal LDR$M_USER_BUF = %X'8';
literal LDR$M_NO_SLICE = %X'10';
literal LDR$S_LDR_DYN = 4;
macro LDR$V_PAG = 0,0,1,0 %;            !  If set, paging is disabled
macro LDR$V_UNL = 0,1,1,0 %;            !  Image is unloadable
macro LDR$V_OVR = 0,2,1,0 %;            !  If set, do not overlay image
macro LDR$V_USER_BUF = 0,3,1,0 %;       !  Optional user buffer 
!  is specified on input
macro LDR$V_NO_SLICE = 0,4,1,0 %;       !  Image is not to be sliced
!  during load.
 
!*** MODULE $LDRHPDEF ***
literal LDRHP$K_CODE = 0;               !  execlet code UR
literal LDRHP$K_DATA = 1;               !  execlet data URKW
literal LDRHP$K_EXEC_DATA = 2;          !  exec data area ERKW
literal LDRHP$K_RES_CODE = 3;           !  resident code UR
literal LDRHP$K_RES_DATA = 4;           !  resident data URKW
literal LDRHP$K_NUM_TYPES = 5;          !  number of page types
literal LDRHP$M_ALLOC_FAIL = %X'1';
literal LDRHP$M_RELEASED = %X'2';
literal LDRHP$C_LENGTH = 96;
literal LDRHP$K_LENGTH = 96;
literal LDRHP$S_LDRHPDEF = 96;          !  Old size name - synonym
literal LDRHP$S_LDRHP = 96;
macro LDRHP$Q_TYPE = 0,0,0,0 %;
literal LDRHP$S_TYPE = 8;               !  type, code or data page
macro LDRHP$L_TYPE_L = 0,0,32,0 %;
macro LDRHP$L_TYPE_H = 4,0,32,0 %;
macro LDRHP$Q_SIZE = 8,0,0,0 %;
literal LDRHP$S_SIZE = 8;               !  size of huge page
macro LDRHP$L_SIZE_L = 8,0,32,0 %;
macro LDRHP$L_SIZE_H = 12,0,32,0 %;
macro LDRHP$Q_VA = 16,0,0,1 %;
literal LDRHP$S_VA = 8;                 !  Base VA of huge page
macro LDRHP$L_VA_L = 16,0,32,1 %;
macro LDRHP$L_VA_H = 20,0,32,1 %;
macro LDRHP$Q_PA = 24,0,0,1 %;
literal LDRHP$S_PA = 8;                 !  Base PA of huge page
macro LDRHP$L_PA_L = 24,0,32,1 %;
macro LDRHP$L_PA_H = 28,0,32,1 %;
macro LDRHP$Q_SLICE_SIZE = 32,0,0,0 %;
literal LDRHP$S_SLICE_SIZE = 8;         !  size of allocation quantity
macro LDRHP$L_SLICE_SIZE_L = 32,0,32,0 %;
macro LDRHP$L_SLICE_SIZE_H = 36,0,32,0 %;
macro LDRHP$Q_NEXT_SLICE = 40,0,0,0 %;
literal LDRHP$S_NEXT_SLICE = 8;         !  next available slice in page
macro LDRHP$L_NEXT_SLICE_L = 40,0,32,0 %;
macro LDRHP$L_NEXT_SLICE_H = 44,0,32,0 %;
macro LDRHP$Q_FREE_SLICES = 48,0,0,0 %;
literal LDRHP$S_FREE_SLICES = 8;        !  free slices in page
macro LDRHP$L_FREE_SLICES_L = 48,0,32,0 %;
macro LDRHP$L_FREE_SLICES_H = 52,0,32,0 %;
macro LDRHP$Q_USED_SLICES = 56,0,0,0 %;
literal LDRHP$S_USED_SLICES = 8;        !  used slices in page
macro LDRHP$L_USED_SLICES_L = 56,0,32,0 %;
macro LDRHP$L_USED_SLICES_H = 60,0,32,0 %;
macro LDRHP$Q_STARTUP_PAGES = 64,0,0,0 %;
literal LDRHP$S_STARTUP_PAGES = 8;      !  pages in use when LDR$WRAPUP runs
macro LDRHP$L_STARTUP_PAGES_L = 64,0,32,0 %;
macro LDRHP$L_STARTUP_PAGES_H = 68,0,32,0 %;
macro LDRHP$Q_BITMAP_SIZE = 72,0,0,0 %;
literal LDRHP$S_BITMAP_SIZE = 8;        !  size of huge page bitmap
macro LDRHP$L_BITMAP_SIZE_L = 72,0,32,0 %;
macro LDRHP$L_BITMAP_SIZE_H = 76,0,32,0 %;
macro LDRHP$Q_BITMAP_VA = 80,0,0,1 %;
literal LDRHP$S_BITMAP_VA = 8;          !  base VA of huge page bitmap
macro LDRHP$L_BITMAP_VA_L = 80,0,32,1 %;
macro LDRHP$L_BITMAP_VA_H = 84,0,32,1 %;
macro LDRHP$Q_FLAGS = 88,0,0,0 %;
literal LDRHP$S_FLAGS = 8;              !  flags
macro LDRHP$R_FLAGS_BITS = 88,0,8,0 %;
macro LDRHP$V_ALLOC_FAIL = 88,0,1,0 %;  !  allocation attempt failed
macro LDRHP$V_RELEASED = 88,1,1,0 %;    !  unused pfns have been released
macro LDRHP$L_FLAGS_L = 88,0,32,0 %;
macro LDRHP$L_FLAGS_H = 92,0,32,0 %;
 
!*** MODULE $LDRIMGDEF ***
literal LDRIMG$M_NOT_XQP = %X'1';
literal LDRIMG$M_DELAY_INIT = %X'2';
literal LDRIMG$M_NO_PFN_DB = %X'4';
literal LDRIMG$M_NOOVERLAY = %X'8';
literal LDRIMG$M_CAN_UNL = %X'10';
literal LDRIMG$M_UNL_PEN = %X'20';
literal LDRIMG$M_SYNC = %X'40';
literal LDRIMG$M_VALID = %X'80';
literal LDRIMG$M_GSTVA_VALID = %X'100';
literal LDRIMG$M_PAGED_RELOC = %X'200';
literal LDRIMG$M_NONPAGED_RELOC = %X'400';
literal LDRIMG$M_PAGED_FIXUPS = %X'800';
literal LDRIMG$M_NONPAGED_FIXUPS = %X'1000';
literal LDRIMG$M_SECOND_PASS_FIXUP = %X'2000';
literal LDRIMG$M_NO_SLICE = %X'4000';
literal LDRIMG$M_DYN_LOAD = %X'8000';
literal LDRIMG$M_NPAGED_LOAD = %X'10000';
literal LDRIMG$C_LENGTH = 272;
literal LDRIMG$K_LENGTH = 272;
literal LDRIMG$S_LDRIMGDEF = 272;       !  Old size name - synonym
literal LDRIMG$S_LDRIMG = 272;
macro LDRIMG$L_FLINK = 0,0,32,1 %;      !  forward link
macro LDRIMG$L_BLINK = 4,0,32,1 %;      !  backward link
macro LDRIMG$W_SIZE = 8,0,16,0 %;       !  structure size
macro LDRIMG$B_TYPE = 10,0,8,0 %;       !  DYN$C_LOADCODE	
macro LDRIMG$B_IMGNAMLEN = 12,0,8,0 %;  !  count for image name
macro LDRIMG$T_IMGNAM = 13,0,0,0 %;
literal LDRIMG$S_IMGNAM = 39;           !  image name string
macro LDRIMG$L_BASE = 52,0,32,1 %;      !  base virtual address
macro LDRIMG$L_PAGE_COUNT = 56,0,32,1 %; !  image size in pages
macro LDRIMG$R_FLAGS_OVERLAY = 60,0,32,0 %;
macro LDRIMG$L_FLAGS = 60,0,32,0 %;     !  status flags
macro LDRIMG$R_FLAGS_BITS = 60,0,24,0 %;
macro LDRIMG$V_NOT_XQP = 60,0,1,0 %;    !  not opened by XQP
macro LDRIMG$V_DELAY_INIT = 60,1,1,0 %; !  needs delayed initialization
macro LDRIMG$V_NO_PFN_DB = 60,2,1,0 %;  !  no PFN data base when loaded
macro LDRIMG$V_NOOVERLAY = 60,3,1,0 %;  !  not overlaid by bugcheck 
macro LDRIMG$V_CAN_UNL = 60,4,1,0 %;    !  unloadable exec image 
macro LDRIMG$V_UNL_PEN = 60,5,1,0 %;    !  exec image unload is pending 
macro LDRIMG$V_SYNC = 60,6,1,0 %;       !  synchronize access to this block
macro LDRIMG$V_VALID = 60,7,1,0 %;      !  contents of this block are valid 
macro LDRIMG$V_GSTVA_VALID = 60,8,1,0 %; !  GSTVA contains a valid address
macro LDRIMG$V_PAGED_RELOC = 60,9,1,0 %; !  paged relocations done
macro LDRIMG$V_NONPAGED_RELOC = 60,10,1,0 %; !  nonpaged relocations done
macro LDRIMG$V_PAGED_FIXUPS = 60,11,1,0 %; !  paged fix-ups done
macro LDRIMG$V_NONPAGED_FIXUPS = 60,12,1,0 %; !  Non-paged fix-ups done
macro LDRIMG$V_SECOND_PASS_FIXUP = 60,13,1,0 %; !  2nd pass fixup required
macro LDRIMG$V_NO_SLICE = 60,14,1,0 %;  !  execlet not sliced
macro LDRIMG$V_DYN_LOAD = 60,15,1,0 %;  !  loaded by dynamic loader
macro LDRIMG$V_NPAGED_LOAD = 60,16,1,0 %; !  paged code loaded nonpaged
macro LDRIMG$Q_LINKTIME = 64,0,0,0 %;
literal LDRIMG$S_LINKTIME = 8;          !  link time
macro LDRIMG$L_VERSION = 72,0,32,1 %;   !  image version
macro LDRIMG$L_NONPAG_R_BASE = 76,0,32,1 %; !  nonpaged read-only base
macro LDRIMG$L_NONPAG_R_LEN = 80,0,32,1 %; !  nonpaged read-only length
macro LDRIMG$L_NONPAG_R_VBN = 84,0,32,1 %; !  nonpaged read-only vbn
macro LDRIMG$L_NONPAG_R_OFFSET = 88,0,32,1 %; !  nonpaged read-only image offset
macro LDRIMG$L_NONPAG_R_END = 92,0,32,1 %; !  nonpaged read-only end offset
macro LDRIMG$L_NONPAG_W_BASE = 96,0,32,1 %; !  nonpaged writable base
macro LDRIMG$L_NONPAG_W_LEN = 100,0,32,1 %; !  nonpaged writable length
macro LDRIMG$L_NONPAG_W_VBN = 104,0,32,1 %; !  nonpaged writable vbn
macro LDRIMG$L_NONPAG_W_OFFSET = 108,0,32,1 %; !  nonpaged writable image offset 
macro LDRIMG$L_NONPAG_W_END = 112,0,32,1 %; !  nonpaged writable end offset
macro LDRIMG$L_PAG_R_BASE = 116,0,32,1 %; !  paged read-only base
macro LDRIMG$L_PAG_R_LEN = 120,0,32,1 %; !  paged read-only length
macro LDRIMG$L_PAG_R_VBN = 124,0,32,1 %; !  paged read-only vbn
macro LDRIMG$L_PAG_R_OFFSET = 128,0,32,1 %; !  paged read-only image offset
macro LDRIMG$L_PAG_R_END = 132,0,32,1 %; !  paged read-only end offset
macro LDRIMG$L_PAG_W_BASE = 136,0,32,1 %; !  paged writable base
macro LDRIMG$L_PAG_W_LEN = 140,0,32,1 %; !  paged writable length
macro LDRIMG$L_PAG_W_VBN = 144,0,32,1 %; !  paged writable vbn
macro LDRIMG$L_PAG_W_OFFSET = 148,0,32,1 %; !  paged writable image offset
macro LDRIMG$L_PAG_W_END = 152,0,32,1 %; !  paged writable end offset
macro LDRIMG$L_FIXUP_BASE = 156,0,32,1 %; !  base VA of fixup section
macro LDRIMG$L_FIXUP_LEN = 160,0,32,1 %; !  size of fixup section
macro LDRIMG$L_FIXUP_VBN = 164,0,32,1 %; !  fixup section vbn
macro LDRIMG$L_FIXUP_OFFSET = 168,0,32,1 %; !  fixup section image offset
macro LDRIMG$L_FIXUP_END = 172,0,32,1 %; !  fixup end offset
macro LDRIMG$L_INIT_BASE = 176,0,32,1 %; !  base VA of initialization code
macro LDRIMG$L_INIT_LEN = 180,0,32,1 %; !  size of initialization code
macro LDRIMG$L_INIT_VBN = 184,0,32,1 %; !  initialization section vbn
macro LDRIMG$L_INIT_OFFSET = 188,0,32,1 %; !  init code image offset 
macro LDRIMG$L_INIT_END = 192,0,32,1 %; !  init code end offset
macro LDRIMG$W_PAG_R_STX = 196,0,16,1 %; !  section table index (read-only)
macro LDRIMG$W_PAG_W_STX = 198,0,16,1 %; !  section table index (writable)
macro LDRIMG$L_WCB = 200,0,32,1 %;      !  WCB pointer
macro LDRIMG$L_INIT_RTN = 204,0,32,1 %; !  delayed initialization routine
macro LDRIMG$L_PID = 208,0,32,1 %;      !  pid of proc attempting load
macro LDRIMG$L_CHAN = 212,0,32,1 %;     !  chan number
macro LDRIMG$L_BASIMGVEC = 216,0,32,1 %; !  VA of list of base image vectors 
macro LDRIMG$L_NUM_BASVEC = 220,0,32,1 %; !  number of base image contributions  
macro LDRIMG$L_SEQ = 224,0,32,1 %;      !  sequence no. 
macro LDRIMG$L_UNLVEC = 228,0,32,1 %;   !  VA of unload routine vector
macro LDRIMG$L_REFCNT = 232,0,32,1 %;   !  number of references pending
macro LDRIMG$L_SYMVVA = 236,0,32,1 %;   !  Address of symbol vector
macro LDRIMG$L_SYMVVA_END = 240,0,32,1 %; !  End Address of symbol vector
macro LDRIMG$L_GST = 244,0,32,1 %;      !  Address of entire global symbol table.
macro LDRIMG$L_GSTPAGES = 248,0,32,1 %; !  GST page count
macro LDRIMG$L_GSTVA = 252,0,32,1 %;    !  Address of loader's global symbol table.
macro LDRIMG$L_SPFVA = 256,0,32,1 %;    !  Address of 2nd pass fixup symbol table.
macro LDRIMG$L_SSVEC = 260,0,32,1 %;    !  Address of system service vectors
macro LDRIMG$L_SYMVEC0 = 264,0,32,1 %;  !  Address of first symbol vector
macro LDRIMG$L_SYMVEC1 = 268,0,32,1 %;  !  Address of second symbol vector
literal LDRIMG$C_ISD_LENGTH = 20;
literal LDRIMG$K_ISD_LENGTH = 20;
literal LDRIMG$S_ISD_OVERLAY = 20;
macro LDRIMG$L_ISD_BASE = 0,0,32,1 %;   !  Overlay image section base
macro LDRIMG$L_ISD_LEN = 4,0,32,1 %;    !  overlay image section length
macro LDRIMG$L_ISD_VBN = 8,0,32,1 %;    !  overlay image section VBN
macro LDRIMG$L_ISD_OFFSET = 12,0,32,1 %; !  overlay image section offset
macro LDRIMG$L_ISD_END = 16,0,32,1 %;   !  overlay image section end
 
!*** MODULE $LIRDEF ***
! +
!  $LIRDEF - LOADABLE IMAGE RECORD DEFINITION
! 
!  A LOADABLE IMAGE RECORD DEFINES A ALTERNATE EXEC IMAGE THAT CAN
!  BE LOADED BY INIT OR SYSINIT INTO THE SYSTEM.
! -
literal LIR$K_ID = 257;                 !  LIR ID plus version
literal LIR$K_INIT = 0;                 !    INIT 
literal LIR$K_SYSINIT = 1;              !    SYSINIT
literal LIR$K_WARNING = 0;              !    WARNING
literal LIR$K_SUCCESS = 1;              !    SUCCESS
literal LIR$K_ERROR = 2;                !    ERROR
literal LIR$K_INFORMATION = 3;          !    INFORMATION
literal LIR$K_FIXED = 8;                !  Length of fixed portion
literal LIR$C_FIXED = 8;                !  Length of fixed portion
literal LIR$K_LENGTH = 256;             ! Length of LIR
literal LIR$C_LENGTH = 256;             ! Length of LIR 
literal LIR$S_LIRDEF = 8;               !  Old size name - synonym
literal LIR$S_LIR = 8;
macro LIR$W_ID = 0,0,16,0 %;            !  LIR ID field
macro LIR$W_PHASE = 2,0,16,0 %;         !  LIR phase indicator
!  LIR phase values
macro LIR$W_SEVERITY = 4,0,16,0 %;      !  LIR severity indicator
!  LIR severity values
macro LIR$B_ERR_LEN = 6,0,8,0 %;        !  Error message length
macro LIR$B_ERR_OFF = 7,0,8,0 %;        !  Error message offset
macro LIR$T_IMAGE_NAME = 8,0,0,0 %;     !  Start of image name counted string
 
!*** MODULE $LKBDEF ***
! +
!  LKB - LOCK BLOCK
! 
!  LOCK BLOCKS ARE USED TO REPRESENT LOCK REQUESTS (ONE BLOCK FOR EACH
!  REQUEST).  LOCK BLOCKS HAVE AN ENTRY IN THE LOCK ID TABLE POINTING
!  TO THEM AND ARE LINKED ONTO ONE OF THREE QUEUES IN A RESOURCE BLOCK (RSB)
! -
literal LKB$M_PKAST = %X'10';
literal LKB$M_NODELETE = %X'20';
literal LKB$M_QUOTA = %X'40';
literal LKB$M_KAST = %X'80';
literal LKB$M_DCPLAST = %X'1';
literal LKB$M_DBLKAST = %X'2';
literal LKB$M_ASYNC = %X'4';
literal LKB$M_BLKASTQED = %X'8';
literal LKB$M_MSTCPY = %X'10';
literal LKB$M_NOQUOTA = %X'20';
literal LKB$M_TIMOUTQ = %X'40';
literal LKB$M_WASSYSOWN = %X'80';
literal LKB$M_CVTTOSYS = %X'100';
literal LKB$M_PROTECT = %X'200';
literal LKB$M_RESEND = %X'400';
literal LKB$M_RM_RBRQD = %X'800';
literal LKB$M_FLOCK = %X'1000';
literal LKB$M_IP = %X'2000';
literal LKB$M_CACHED = %X'4000';
literal LKB$M_RNGBLK = %X'8000';
literal LKB$M_BRL = %X'10000';
literal LKB$M_NEWSUBRNG = %X'20000';
literal LKB$M_CVTSUBRNG = %X'40000';
literal LKB$M_RNGCHG = %X'80000';
literal LKB$M_2PC_IP = %X'100000';
literal LKB$M_2PC_PEND = %X'200000';
literal LKB$M_BLKASTFLG = %X'400000';
literal LKB$M_GRSUBRNG = %X'800000';
literal LKB$M_PCACHED = %X'1000000';
literal LKB$M_VALBLKRD = %X'2000000';
literal LKB$M_VALBLKWRT = %X'4000000';
literal LKB$K_ACBLEN = 64;              ! LENGTH OF ACB PORTION OF LKB 
literal LKB$C_ACBLEN = 64;              ! LENGTH OF ACB PORTION OF LKB 
literal LKB$K_GRANTED = 1;              !  GRANTED
literal LKB$K_CONVERT = 0;              !  CONVERSION
literal LKB$K_WAITING = -1;             !  WAITING
literal LKB$K_RETRY = -2;               !  RETRY REQUEST
literal LKB$K_SCSWAIT = -3;             !  SCS WAIT
literal LKB$K_RSPNOTQED = -4;           !  RESPONSE NOT QUEUED
literal LKB$K_RSPQUEUED = -5;           !  RESPONSE QUEUED
literal LKB$K_RSPGRANTD = -6;           !  RESPONSE GRANTED
literal LKB$K_RSPDOLOCL = -7;           !  RESPONSE DO LOCALLY
literal LKB$K_RSPRESEND = -8;           !  RESPONSE RESEND
literal LKB$K_RSPWAIT = -9;             !  RESPONSE WAIT
literal LKB$K_RSP2PCRDY = -10;          !  Response Ready
literal LKB$K_RSPFATAL = -11;           !  Fatal Message response
literal LKB$K_LENGTH = 140;             ! LENGTH OF LKB 
literal LKB$C_LENGTH = 140;             ! LENGTH OF LKB 
literal LKB$S_LKBDEF = 140;             !  Old size name - synonym
literal LKB$S_LKB = 140;
macro LKB$L_ASTQFL = 0,0,32,1 %;        ! AST QUEUE FORWARD LINK 
macro LKB$L_ASTQBL = 4,0,32,1 %;        ! AST QUEUE BACKWARD LINK 
macro LKB$W_SIZE = 8,0,16,0 %;          ! SIZE OF LKB IN BYTES 
macro LKB$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE 
macro LKB$B_RMOD = 11,0,8,0 %;          ! ACCESS MODE OF REQUEST 
macro LKB$V_MODE = 11,0,2,0 %;
literal LKB$S_MODE = 2;                 !  MODE SUBFIELD 
macro LKB$V_PKAST = 11,4,1,0 %;         !  PIGGY BACK SPECIAL KERNEL AST 
macro LKB$V_NODELETE = 11,5,1,0 %;      !  DON'T DELETE ACB ON DELIVERY 
macro LKB$V_QUOTA = 11,6,1,0 %;         !  ACCOUNT FOR QUOTA 
macro LKB$V_KAST = 11,7,1,0 %;          !  SPECIAL KERNEL AST 
macro LKB$L_PID = 12,0,32,0 %;          ! PROCESS ID OF REQUESTING PROCESS 
macro LKB$L_AST = 16,0,32,1 %;          ! ADDRESS OF AST ROUTINE 
macro LKB$W_RQSEQNM = 16,0,16,0 %;      ! REQUEST SEQ. NUMBER 
macro LKB$L_ASTPRM = 20,0,32,0 %;       ! AST PARAMETER 
macro LKB$L_EPID = 20,0,32,0 %;         ! EPID (MASTER COPIES ONLY)
macro LKB$L_KAST = 32,0,32,1 %;         ! SPECIAL KERNEL AST ADDRESS 
macro LKB$L_DUETIME = 32,0,32,0 %;      ! DUETIME FOR WAITING LOCKS 
macro LKB$L_CPLASTADR = 36,0,32,1 %;    ! ADDRESS OF COMPLETION AST ROUTINE 
macro LKB$L_BLKASTADR = 40,0,32,1 %;    ! ADDRESS OF BLOCKING AST ROUTINE 
macro LKB$L_LKSB = 44,0,32,1 %;         ! ADDRESS OF LOCK STATUS BLOCK 
macro LKB$L_DLCKPRI = 44,0,32,0 %;      ! DEADLOCK PRIORITY (MASTER COPIES)
macro LKB$L_FLAGS = 48,0,32,0 %;        ! USER SPECIFIED FLAGS 
macro LKB$L_STATUS = 52,0,32,0 %;       ! INTERNAL STATUS 
macro LKB$V_DCPLAST = 52,0,1,0 %;       !  DELIVER COMPLETION AST 
macro LKB$V_DBLKAST = 52,1,1,0 %;       !  DELIVER BLOCKING AST 
macro LKB$V_ASYNC = 52,2,1,0 %;         !  REQUEST COMPLETED ASYNCHRONOUSLY 
macro LKB$V_BLKASTQED = 52,3,1,0 %;     !  BLOCKING AST HAS BEEN QUEUED 
macro LKB$V_MSTCPY = 52,4,1,0 %;        !  LKB IS A MASTER COPY
macro LKB$V_NOQUOTA = 52,5,1,0 %;       !  DON'T CHARGE QUOTA
macro LKB$V_TIMOUTQ = 52,6,1,0 %;       !  LKB IS ON TIMEOUT QUEUE 
macro LKB$V_WASSYSOWN = 52,7,1,0 %;     !  WAS SYSTEM OWNED LOCK
macro LKB$V_CVTTOSYS = 52,8,1,0 %;      !  CVT BACK TO SYS. OWNED
macro LKB$V_PROTECT = 52,9,1,0 %;       !  PROTECTED LOCK
macro LKB$V_RESEND = 52,10,1,0 %;       !  RESEND DURING FAILOVER
macro LKB$V_RM_RBRQD = 52,11,1,0 %;     !  REMASTER REBUILD REQUIRED
macro LKB$V_FLOCK = 52,12,1,0 %;        !  FORK LOCK
macro LKB$V_IP = 52,13,1,0 %;           !  OPERATION IN PROGRESS
macro LKB$V_CACHED = 52,14,1,0 %;       !  LKB is in cache
macro LKB$V_RNGBLK = 52,15,1,0 %;       !  Range block specified 
!  These bitfields must start on a byte boundry
macro LKB$V_BRL = 52,16,1,0 %;          !  indicate byte range lock
macro LKB$V_NEWSUBRNG = 52,17,1,0 %;    !  new sub-range request 
macro LKB$V_CVTSUBRNG = 52,18,1,0 %;    !  sub-range cvt request 
macro LKB$V_RNGCHG = 52,19,1,0 %;       !  changing range 
macro LKB$V_2PC_IP = 52,20,1,0 %;       !  two phase op in progress
macro LKB$V_2PC_PEND = 52,21,1,0 %;     !  two phase op pending
macro LKB$V_BLKASTFLG = 52,22,1,0 %;    !  indicates blkast specified
macro LKB$V_GRSUBRNG = 52,23,1,0 %;     !  granted sub-range lock
macro LKB$V_PCACHED = 52,24,1,0 %;      !  LKB is to be cached
macro LKB$V_VALBLKRD = 52,25,1,0 %;     !  indicates read access to value block
macro LKB$V_VALBLKWRT = 52,26,1,0 %;    !  indicates write access to value block
macro LKB$L_LKST1 = 56,0,32,0 %;        ! FIRST LOCK STATUS LONGWORD 
macro LKB$L_LKST2 = 60,0,32,0 %;        ! SECOND LOCK STATUS LONGWORD 
macro LKB$L_LKID = 60,0,32,0 %;         ! LOCK ID 
macro LKB$V_INDEX = 60,0,24,0 %;
literal LKB$S_INDEX = 24;               !  index
macro LKB$V_SEQN = 60,24,8,0 %;
literal LKB$S_SEQN = 8;                 !  sequence number
macro LKB$B_RQMODE = 64,0,8,0 %;        ! REQUEST MODE 
macro LKB$B_GRMODE = 65,0,8,0 %;        ! GRANTED MODE 
macro LKB$B_STATE = 66,0,8,0 %;         ! LOCK STATE 
! LOCK STATE VALUES
macro LKB$B_EFN = 67,0,8,0 %;           ! EVENT FLAG NUMBER 
macro LKB$L_SQFL = 68,0,32,1 %;         ! STATE QUEUE FORWARD LINK 
macro LKB$L_SQBL = 72,0,32,1 %;         ! STATE QUEUE BACKWARD LINK 
macro LKB$L_OWNQFL = 76,0,32,1 %;       ! OWNER QUEUE FORWARD LINK 
macro LKB$L_OWNQBL = 80,0,32,1 %;       ! OWNER QUEUE BACKWARD LINK 
macro LKB$L_PARENT = 84,0,32,1 %;       ! ADDRESS OF PARENT LKB 
macro LKB$W_REFCNT = 88,0,16,0 %;       ! SUB LKB REFERENCE COUNT 
macro LKB$B_TSLT = 90,0,8,0 %;          ! TIMESTAMP LIFETIME
macro LKB$L_RSB = 92,0,32,1 %;          ! ADDRESS OF OWNER RSB 
macro LKB$L_REMLKID = 96,0,32,0 %;      ! REMOTE LOCK ID
macro LKB$L_CSID = 100,0,32,0 %;        ! CLUSTER SYSTEM ID (MASTER ONLY)
macro LKB$L_OLDASTPRM = 100,0,32,0 %;   ! OLD AST PARAMETER
macro LKB$L_OLDBLKAST = 104,0,32,1 %;   ! OLD BLOCKING AST ADDR,
macro LKB$L_LCKCTX = 108,0,32,1 %;      ! ADDRESS OF CONTEXT BLOCK
macro LKB$L_PRIORITY = 112,0,32,0 %;    ! REQUEST PRIORITY
macro LKB$L_RQSTSRNG = 116,0,32,1 %;    ! Starting byte of req range
macro LKB$L_RQSTERNG = 120,0,32,1 %;    ! Ending byte of req range
macro LKB$L_GRNTSRNG = 124,0,32,1 %;    ! Starting byte of granted range
macro LKB$L_GRNTERNG = 128,0,32,1 %;    ! Ending byte of granted range
macro LKB$L_TSKPID = 132,0,32,0 %;      ! Task id
macro LKB$L_RSDMID = 136,0,32,0 %;      ! RESOURCE DOMAIN ID
 
!*** MODULE $LMBDEF ***
! +
!   LMB	-  Logical Memory Block
! 
!   Logical Memory Block definitions (for subsetted crash dumps)
!   Layout of each Logical Memory Block and accompanying hole descriptor.
!   Logical Memory Blocks are portions of selective memory dumps.  "Holes"
!   refer to areas of invalid or inaccessible virtual address space at the
!   time of the dump.
! -
literal LMB$C_SPT = 0;                  !  System Page Table
literal LMB$C_S0 = 1;                   !  S0 system space
literal LMB$C_GBL = 2;                  !  Global pages
literal LMB$C_PROCESS = 3;              !  Process memory
literal LMB$K_HOLE_LENGTH = 8;
literal LMB$C_HOLE_LENGTH = 8;
!  Size of each hole table entry.
literal LMB$K_LENGTH = 32;              !  Logical mem block length
literal LMB$C_LENGTH = 32;              !  Logical mem block length
literal LMB$S_LMBDEF = 32;              !  Old size name - synonym    
literal LMB$S_LMB = 32;
macro LMB$L_TYPE = 0,0,32,0 %;          !  Type of LMB
!  LMB flavors
macro LMB$L_EXP_LENGTH = 4,0,32,0 %;    !  LMB data expected length (blocks)
macro LMB$L_ACT_LENGTH = 8,0,32,0 %;    !  LMB data actual length (blocks)
macro LMB$L_TIME_CHECK = 12,0,32,0 %;   !  Ones-complement of EMB$Q_CR_TIME
macro LMB$L_SPT_FILLER = 16,0,32,0 %;
macro LMB$L_SPTLEN = 20,0,32,0 %;       !  Length of SPT 
macro LMB$L_SPTADR = 24,0,32,1 %;       !  SVA of the start of SPT + GPT
macro LMB$L_HOLE_TBL = 16,0,32,0 %;     !  VBN in dump of start of the table
!  describing the holes in the S0
!  virtual address space.
macro LMB$L_TOTAL_HOLES = 20,0,32,0 %;  !  Count of holes in S0 space
macro LMB$L_PCBADR = 24,0,32,1 %;       !  SVA of this process's PCB
macro LMB$L_BAD_MEM_PTRS = 28,0,32,0 %; !  Offset of bad memory descriptor
!  list. List terminates with -1 or
!  at end of LMB block 1.
!  Offset is from start of LMB block 1.
macro LMB$L_HOLE_START_VA = 0,0,32,1 %; !  Starting VA for this hole
macro LMB$L_HOLE_TOTAL_PAGES = 4,0,32,0 %; !  Running total of pages of holes
!  up to the starting VA of this hole
!  Offset to get to the next hole
!  table entry.
macro LMB$L_BAD_MEM_START = 0,0,32,1 %; !  Starting VA of bad memory section
macro LMB$L_BAD_MEM_END = 4,0,32,1 %;   !  Ending VA of bad memory section
macro LMB$L_BAD_MEM_NEXT = 8,0,32,0 %;  !  Size of one entry in bad memory table
 
!*** MODULE $LMFITMDEF ***
! +
!  LMFITMDEF - LMF internal item-list definitions
! 
!  Items lists used by the internal routines LMF$LOAD and LMF$UNLOAD,
!  which manipulate the on-disk and in-memory License databases.
!  These routines now have a callable interface, and the caller needs
!  access to these item codes.
! -
!  These are the item codes passed from the LMF utility to the callable
!  routines in the item list.  New codes should be added to the end.
literal LMF$k_ldb = 0;
literal LMF$k_producer = 1;
literal LMF$k_product = 2;
literal LMF$k_version = 3;
literal LMF$k_issuer = 4;
literal LMF$k_comment = 5;
literal LMF$k_authorization = 6;
literal LMF$k_units = 7;
literal LMF$k_availability = 8;
literal LMF$k_activity = 9;
literal LMF$k_token = 10;
literal LMF$k_termination = 11;
literal LMF$k_date = 12;
literal LMF$k_hardware_id = 13;
literal LMF$k_checksum = 14;
literal LMF$K_INCLUDE = 15;
literal LMF$k_exclude = 16;
literal LMF$k_options = 17;
literal LMF$k_output_name = 18;
literal LMF$k_extinct_qualifier = 19;
literal LMF$k_load_qualifier = 20;
literal LMF$k_cust_termination = 21;
literal LMF$k_cust_date = 22;
literal LMF$k_full_qualifier = 23;
literal LMF$k_brief_qualifier = 24;
literal LMF$k_creation_date = 25;
literal LMF$K_LMF_version_number = 26;
literal LMF$k_creating_username = 27;
literal LMF$k_log_qualifier = 28;
 
!*** MODULE $LGIDEF ***
literal LGI$C_LENGTH = 24;              !  Data structure length
literal LGI$K_LENGTH = 24;              !  Data structure length
literal LGI$C_CHARTIME = 15;            !  Terminal driver timeout value
literal LGI$K_CHARTIME = 15;            !  Terminal driver timeout value
literal LGI$S_LGIDATDEF = 24;           !  Old size name - synonym
literal LGI$S_LGIDAT = 24;
macro LGI$L_ORIGUIC = 0,0,32,0 %;       !  Original UIC at job creation time
macro LGI$T_OUTFNM = 4,0,0,0 %;
literal LGI$S_OUTFNM = 20;              !  For batch, file name/type of output
!  for spooling log file in batch jobs
literal LGI$M_OPENACCT = %X'1';
literal LGI$M_PASSWORD = %X'2';
literal LGI$M_PASSWORD2 = %X'4';
literal LGI$_PRIMARY_PASSWORD = 1;      !  primary password
literal LGI$_SECONDARY_PASSWORD = 2;    !  secondary password
literal LGI$_SOURCE_NODE = 3;           !  source nodename
literal LGI$_SOURCE_ID = 4;             !  source id (username)
literal LGI$_SOURCE_ADDRESS = 5;        !  source DECnet address
literal LGI$_SOURCE_TERMINAL = 6;       !  source terminal
literal LGI$_PARENT_USERNAME = 7;       !  parent username
literal LGI$_PARENT_PID = 8;            !  parent PID
literal LGI$_JOB_TYPE = 9;              !  job type
literal LGI$_MAX_CODE = 10;             !  last item code (plus one)
literal LGI$S_LGIAUTHDEF = 4;           !  Old size name - synonym
literal LGI$S_LGIAUTH = 4;
macro LGI$L_AUTH_FLAGS = 0,0,32,0 %;
macro LGI$V_OPENACCT = 0,0,1,0 %;       !  account requires no passwords
macro LGI$V_PASSWORD = 0,1,1,0 %;       !  account has primary password
macro LGI$V_PASSWORD2 = 0,2,1,0 %;      !  account has secondary password
literal LGI$_DISUSER_STOP = 1;          !  stop on error
literal LGI$_DISUSER_RETURN = 2;        !  return on error
literal LGI$_VALIDATE_STOP = 1;         !  stop on error
literal LGI$_VALIDATE_RETURN = 2;       !  return on error
literal LGI$_GET_INPUT_STOP = 0;        !  stop on error
literal LGI$_GET_INPUT_HANGUP = 1;      !  hangup quietly on error
literal LGI$_GET_INPUT_RETURN_TMO = 2;  !  return on timout
literal LGI$M_NET_PROXY = %X'1';
literal LGI$M_NET_PREAUTH = %X'2';
literal LGI$M_NET_DEFAULT_USER = %X'4';
literal LGI$M_NET_PROXY_OK = %X'8';
literal LGI$M_NET_REM_INFO_PRESENT = %X'10';
literal LGI$S_LGINETDEF = 2;            !  Old size name - synonym
literal LGI$S_LGINET = 2;
macro LGI$W_NET_AUTH_FLAGS = 0,0,16,0 %;
macro LGI$V_NET_PROXY = 0,0,1,0 %;      !  DECNET wants proxy login
macro LGI$V_NET_PREAUTH = 0,1,1,0 %;    !  DECNET has authenticated
macro LGI$V_NET_DEFAULT_USER = 0,2,1,0 %; !  DECNET application or session
!  database has username
macro LGI$V_NET_PROXY_OK = 0,3,1,0 %;   !  (local use) proxy validated
macro LGI$V_NET_REM_INFO_PRESENT = 0,4,1,0 %; !  Phase V provided rem info
literal LGI$S_LGIARG_VECTOR = 136;
macro LGI$ICB_GET_INPUT = 0,0,32,0 %;   !  Addresses of callbacks
macro LGI$ICB_DECW_IDENT = 4,0,32,0 %;
macro LGI$ICB_DECW_AUTH = 8,0,32,0 %;
macro LGI$ICB_GET_SYSPWD = 12,0,32,0 %;
macro LGI$ICB_USERPROMPT = 16,0,32,0 %;
macro LGI$ICB_USERPARSE = 20,0,32,0 %;
macro LGI$ICB_AUTOLOGIN = 24,0,32,0 %;
macro LGI$ICB_PASSWORD = 28,0,32,0 %;
macro LGI$ICB_CHECK_PASS = 32,0,32,0 %;
macro LGI$ICB_VALIDATE = 36,0,32,0 %;
macro LGI$ICB_ACCTEXPIRED = 40,0,32,0 %;
macro LGI$ICB_PWDEXPIRED = 44,0,32,0 %;
macro LGI$ICB_DISUSER = 48,0,32,0 %;
macro LGI$ICB_MODALHOURS = 52,0,32,0 %;
macro LGI$A_ICR_CREPRC_FLAGS = 56,0,32,0 %; !  Addresses of variables
macro LGI$A_ICR_JOB_TYPE = 60,0,32,0 %;
macro LGI$A_ICR_SUBPROCESS = 64,0,32,0 %;
macro LGI$A_ICR_TERMINAL_DEV = 68,0,32,0 %;
macro LGI$A_ICR_TT_PHYDEVNAM = 72,0,32,0 %;
macro LGI$A_ICR_TT_ACCPORNAM = 76,0,32,0 %;
macro LGI$A_ICR_CLINAME = 80,0,32,0 %;
macro LGI$A_ICR_CLITABLES = 84,0,32,0 %;
macro LGI$A_ICR_NCB = 88,0,32,0 %;
macro LGI$A_ICR_LOGLINK = 92,0,32,0 %;
macro LGI$A_ICR_REM_NODE_NAM = 96,0,32,0 %;
macro LGI$A_ICR_REM_ID = 100,0,32,0 %;
macro LGI$A_ICR_UAF_RECORD = 104,0,32,0 %;
macro LGI$A_ICR_INPUT_RAB = 108,0,32,0 %;
macro LGI$A_ICR_AUTOLOGIN = 112,0,32,0 %;
macro LGI$A_ICR_USERNAME = 116,0,32,0 %;
macro LGI$A_ICR_PWD1 = 120,0,32,0 %;
macro LGI$A_ICR_PWD2 = 124,0,32,0 %;
macro LGI$A_ICR_PWDCOUNT = 128,0,32,0 %;
macro LGI$A_ICR_NETFLAGS = 132,0,32,0 %;
literal LGI$ICR_INIT = 4;
literal LGI$ICR_IACT_START = 8;
literal LGI$ICR_DECWINIT = 12;
literal LGI$ICR_IDENTIFY = 16;
literal LGI$ICR_AUTHENTICATE = 20;
literal LGI$ICR_CHKRESTRICT = 24;
literal LGI$ICR_FINISH = 28;
literal LGI$ICR_LOGOUT = 32;
literal LGI$ICR_JOBSTEP = 36;
literal LGI$ICR_CHKLICENSE = 40;
literal LGI$S_LGICALLOUT_VECTOR = 44;
macro LGI$L_ICR_ENTRY_COUNT = 0,0,32,0 %;
macro LGI$A_ICR_INIT = 4,0,32,0 %;
macro LGI$A_ICR_IACT_START = 8,0,32,0 %;
macro LGI$A_ICR_DECWINIT = 12,0,32,0 %;
macro LGI$A_ICR_IDENTIFY = 16,0,32,0 %;
macro LGI$A_ICR_AUTHENTICATE = 20,0,32,0 %;
macro LGI$A_ICR_CHKRESTRICT = 24,0,32,0 %;
macro LGI$A_ICR_FINISH = 28,0,32,0 %;
macro LGI$A_ICR_LOGOUT = 32,0,32,0 %;
macro LGI$A_ICR_JOBSTEP = 36,0,32,0 %;
macro LGI$A_ICR_CHKLICENSE = 40,0,32,0 %;
 
!*** MODULE $LOGDEF ***
! +
!  LOG - LOGICAL NAME BLOCK
! 
!  THERE IS ONE LOGICAL NAME BLOCK FOR EACH LOGICAL NAME ASSIGNMENT IN A
!  SYSTEM. LOGICAL NAME BLOCKS CAN BE LINKED INTO ONE OF THREE TABLES:
!         1. A PER PROCESS TABLE.
!         2. A GROUP WIDE TABLE.
!         3. THE SYSTEM WIDE TABLE.
! -
literal LOG$K_LENGTH = 20;              ! LENGTH OF FIXED PART OF LOG 
literal LOG$C_LENGTH = 20;              ! LENGTH OF FIXED PART OF LOG 
literal LOG$C_SYSTEM = 0;               ! SYSTEM NAME TABLE 
literal LOG$C_GROUP = 1;                ! GROUP NAME TABLE 
literal LOG$C_PROCESS = 2;              ! PROCESS NAME TABLE 
! 
literal LOG$C_NAMLENGTH = 64;           ! MAXIMUM LENGTH OF LOGICAL NAME STRING 
literal LOG$S_LOGDEF = 20;              !  Old size name - synonym
literal LOG$S_LOGNAME = 20;
macro LOG$L_LTFL = 0,0,32,1 %;          ! LOGICAL TABLE FORWARD LINK 
macro LOG$L_LTBL = 4,0,32,1 %;          ! LOGICAL TABLE BACKWARD LINK 
macro LOG$W_SIZE = 8,0,16,0 %;          ! SIZE OF LOG IN BYTES 
macro LOG$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE FOR LOG 
macro LOG$B_TABLE = 11,0,8,0 %;         ! LOGICAL NAME TABLE TYPE 
macro LOG$W_GROUP = 12,0,16,0 %;        ! CREATOR GROUP NUMBER 
macro LOG$B_AMOD = 14,0,8,0 %;          ! ACCESS MODE OF CREATOR 
macro LOG$L_MBXUCB = 16,0,32,1 %;       ! MAILBOX UCB ADDRESS 
macro LOG$T_NAME = 20,0,0,0 %;          ! START OF LOGICAL NAME 
! 
!  LOGICAL NAME TABLE NUMBERS
! 
!  MAXIMUM LENGTH OF LOGICAL NAME STRING
! 
 
!*** MODULE $LNMSTRDEF ***
literal LNMB$M_NO_ALIAS = %X'1';
literal LNMB$M_CONFINE = %X'2';
literal LNMB$M_CRELOG = %X'4';
literal LNMB$M_TABLE = %X'8';
literal LNMB$M_NODELETE = %X'10';
literal LNMB$S_LNMBDEF = 33;            !  Old size name - synonym
literal LNMB$S_LNMB = 33;
macro LNMB$L_FLINK = 0,0,32,1 %;        !  Forward link in list
macro LNMB$L_BLINK = 4,0,32,1 %;        !  Backward link in list
macro LNMB$W_SIZE = 8,0,16,0 %;         !  Size of LNMB in bytes
macro LNMB$B_TYPE = 10,0,8,0 %;         !  Structure type for LNMB
macro LNMB$B_PAD = 11,0,8,1 %;          !  Align to longword boundary
macro LNMB$L_ACMODE = 12,0,32,0 %;      !  Owner access mode / integrity level byte
macro LNMB$L_TABLE = 16,0,32,1 %;       !  Logical name table header address
macro LNMB$L_LNMX = 20,0,32,1 %;        !  Pointer to first LNMX
macro LNMB$R_FLAG_BITS = 24,0,32,0 %;
macro LNMB$L_FLAGS = 24,0,32,0 %;       !  Name attributes
macro LNMB$R_BITS = 24,0,8,0 %;
literal LNMB$S_BITS = 1;
macro LNMB$V_NO_ALIAS = 24,0,1,0 %;     !  Do not allow outer mode alias
macro LNMB$V_CONFINE = 24,1,1,0 %;      !  Do not copy into subprocess
macro LNMB$V_CRELOG = 24,2,1,0 %;       !  Created with old $CRELOG service
macro LNMB$V_TABLE = 24,3,1,0 %;        !  This is a table name
macro LNMB$V_NODELETE = 24,4,1,0 %;     !  Do not allow this table to be deleted
macro LNMB$L_NAMELEN = 28,0,32,0 %;     !  Length of logical name string
macro LNMB$T_NAME = 32,0,8,0 %;         !  Name string
!  Translation blocks follow name -
!  pointed to by LNMB$L_LNMX
literal LNMX$M_CONCEALED = %X'1';
literal LNMX$M_TERMINAL = %X'2';
literal LNMX$C_HSHFCN = -128;           !  Hash function value
literal LNMX$C_BACKPTR = -127;          !  Backpointer translation
literal LNMX$C_TABLE = -126;            !  Logical name table header
literal LNMX$C_IGNORED_INDEX = -125;    !  Modified back pointer for process-private names
literal LNMX$S_LNMXDEF = 25;            !  Old size name - synonym
literal LNMX$S_LNMX = 25;
macro LNMX$R_FLAG_BITS = 0,0,32,0 %;
macro LNMX$L_FLAGS = 0,0,32,0 %;        !  Translation attributes
macro LNMX$R_BITS = 0,0,8,0 %;
literal LNMX$S_BITS = 1;
macro LNMX$V_CONCEALED = 0,0,1,0 %;     !  Do not display result of translation
macro LNMX$V_TERMINAL = 0,1,1,0 %;      !  Do not retranslate result of translation
macro LNMX$L_INDEX = 4,0,32,1 %;        !  Translation index
macro LNMX$L_HASH = 8,0,32,1 %;         !  Hash code for logical names in directories
macro LNMX$L_NEXT = 12,0,32,1 %;        !  Pointer to next lnmx
macro LNMX$L_PAD = 16,0,32,0 %;         !  Padding to keep quadword alignment
macro LNMX$L_XLEN = 20,0,32,0 %;        !  Length of translation string
macro LNMX$T_XLATION = 24,0,8,0 %;      !  Translation string 
!  Additional translation blocks follow xlation - 
!  pointed to by LNMX$L_NEXT.
literal LNMTH$M_SHAREABLE = %X'1';
literal LNMTH$M_DIRECTORY = %X'2';
literal LNMTH$M_GROUP = %X'4';
literal LNMTH$M_SYSTEM = %X'8';
literal LNMTH$K_LENGTH = 40;            !  Length of header
literal LNMTH$S_LNMTHDEF = 40;          !  Old size name - synonym
literal LNMTH$S_LNMTH = 40;
macro LNMTH$R_FLAG_BITS = 0,0,32,0 %;
macro LNMTH$L_FLAGS = 0,0,32,0 %;       !  Logical name table flags
macro LNMTH$R_BITS = 0,0,8,0 %;
literal LNMTH$S_BITS = 1;
macro LNMTH$V_SHAREABLE = 0,0,1,0 %;    !  Logical name table is shareable (S0 space)
macro LNMTH$V_DIRECTORY = 0,1,1,0 %;    !  Logical name table is a directory table
macro LNMTH$V_GROUP = 0,2,1,0 %;        !  Logical name table is a group logical name table
macro LNMTH$V_SYSTEM = 0,3,1,0 %;       !  Logical name table is the system logical name table
macro LNMTH$L_HASH = 4,0,32,1 %;        !  Address of hash table
macro LNMTH$L_ORB = 8,0,32,1 %;         !  Address of Object Rights Block
macro LNMTH$L_NAME = 12,0,32,1 %;       !  Address of containing LNMB block
macro LNMTH$L_PARENT = 16,0,32,1 %;     !  Address of parent table
macro LNMTH$L_CHILD = 20,0,32,1 %;      !  Address of a child table
macro LNMTH$L_SIBLING = 24,0,32,1 %;    !  Address of a sibling table
macro LNMTH$L_QTABLE = 28,0,32,1 %;     !  Address of table holding quota
macro LNMTH$L_BYTESLM = 32,0,32,1 %;    !  Initial quota
macro LNMTH$L_BYTES = 36,0,32,1 %;      !  Remaining quota
literal LNMC$K_NUM_ENTRIES = 25;        !  Number of table header entries.
literal LNMC$K_LENGTH = 128;            !  Length of header
literal LNMC$S_LNMCDEF = 128;           !  Old size name - synonym
literal LNMC$S_LNMC = 128;
macro LNMC$L_FLINK = 0,0,32,1 %;        !  Forward link in list
macro LNMC$L_BLINK = 4,0,32,1 %;        !  Backward link in list
macro LNMC$W_SIZE = 8,0,16,0 %;         !  Size of LNMC in bytes
macro LNMC$B_TYPE = 10,0,8,0 %;         !  Structure type for LNMC
macro LNMC$B_MODE = 11,0,8,0 %;         !  Access mode
macro LNMC$L_CACHEINDX = 12,0,32,0 %;   !  Current entry number
macro LNMC$L_TBLADDR = 16,0,32,1 %;     !  Logical name table name address
macro LNMC$L_PROCDIRSEQ = 20,0,32,0 %;  !  Process directory sequence number
macro LNMC$L_SYSDIRSEQ = 24,0,32,0 %;   !  System directory sequence number
macro LNMC$L_ENTRY = 28,0,0,1 %;
literal LNMC$S_ENTRY = 100;             !  Logical name table header addresses
literal LNMHSH$C_BUCKET = 12;           !  Length of fixed part of LNMHSH
literal LNMHSH$K_BUCKET = 12;           !  Length of fixed part of LNMHSH
literal LNMHSH$S_LNMHSHDEF = 12;        !  Old size name - synonym
literal LNMHSH$S_LNMHSH = 12;
macro LNMHSH$L_MASK = 0,0,32,0 %;       !  Mask for hash value
macro LNMHSH$W_SIZE = 8,0,16,0 %;       !  Size of LNMHSH in bytes
macro LNMHSH$B_TYPE = 10,0,8,0 %;       !  Structure type for LNMHSH
 
!*** MODULE $MBADEF ***
! +
!  MASSBUS ADAPTER REGISTER OFFSET DEFINITIONS
! -
literal MBA$M_CSR_OT = %X'200000';
literal MBA$M_CSR_PU = %X'400000';
literal MBA$M_CSR_PD = %X'800000';
literal MBA$M_CSR_XMFLT = %X'4000000';
literal MBA$M_CSR_MT = %X'8000000';
literal MBA$M_CSR_URD = %X'20000000';
literal MBA$M_CSR_WS = %X'40000000';
literal MBA$M_CSR_PE = %X'80000000';
literal MBA$M_CR_INIT = %X'1';
literal MBA$M_CR_ABORT = %X'2';
literal MBA$M_CR_IE = %X'4';
literal MBA$M_SR_RDTO = %X'1';
literal MBA$M_SR_ISTO = %X'2';
literal MBA$M_SR_RDS = %X'4';
literal MBA$M_SR_ERCONF = %X'8';
literal MBA$M_SR_INVMAP = %X'10';
literal MBA$M_SR_MAPPE = %X'20';
literal MBA$M_SR_MDPE = %X'40';
literal MBA$M_SR_MBEXC = %X'80';
literal MBA$M_SR_MXF = %X'100';
literal MBA$M_SR_WCKLWR = %X'200';
literal MBA$M_SR_WCKUPR = %X'400';
literal MBA$M_SR_DLT = %X'800';
literal MBA$M_SR_DTABT = %X'1000';
literal MBA$M_SR_DTCOMP = %X'2000';
literal MBA$M_SR_SPE = %X'4000';
literal MBA$M_SR_ATTN = %X'10000';
literal MBA$M_SR_MCPE = %X'20000';
literal MBA$M_SR_NED = %X'40000';
literal MBA$M_SR_PGE = %X'80000';
literal MBA$M_SR_CBHUNG = %X'800000';
literal MBA$M_SR_CRD = %X'20000000';
literal MBA$M_SR_NRCONF = %X'40000000';
literal MBA$M_SR_DTBUSY = %X'80000000';
literal MBA$M_ERROR = 942079;           !  PROGRAM ERROR 
literal MBA$S_MBADEF = 3072;            !  Old size name - synonym
literal MBA$S_MBA = 3072;
macro MBA$L_CSR = 0,0,32,0 %;           ! CONFIGURATION STATUS REGISTER 
macro MBA$V_CSR_ADCOD = 0,0,8,0 %;
literal MBA$S_CSR_ADCOD = 8;            !  ADAPTER CODE FIELD 
macro MBA$V_CSR_OT = 0,21,1,0 %;        !  OVER TEMPERATURE 
macro MBA$V_CSR_PU = 0,22,1,0 %;        !  ADAPTER POWER UP 
macro MBA$V_CSR_PD = 0,23,1,0 %;        !  ADAPTER POWER DOWN 
macro MBA$V_CSR_XMFLT = 0,26,1,0 %;     !  TRANSMITTER FAULT 
macro MBA$V_CSR_MT = 0,27,1,0 %;        !  MULTIPLE TRANSMITTERS 
macro MBA$V_CSR_URD = 0,29,1,0 %;       !  UNEXPECTED READ DATA 
macro MBA$V_CSR_WS = 0,30,1,0 %;        !  WRITE SEQUENCE DATA 
macro MBA$V_CSR_PE = 0,31,1,0 %;        !  SBI PARITY ERROR 
macro MBA$L_CR = 4,0,32,0 %;            ! CONTROL REGISTER 
macro MBA$V_CR_INIT = 4,0,1,0 %;        !  ADAPTER INITIALIZATION 
macro MBA$V_CR_ABORT = 4,1,1,0 %;       !  ABORT OPERATION 
macro MBA$V_CR_IE = 4,2,1,0 %;          !  INTERRUPT ENABLE 
macro MBA$L_SR = 8,0,32,0 %;            ! STATUS REGISTER 
macro MBA$V_SR_RDTO = 8,0,1,0 %;        !  READ DATA TIMEOUT 
macro MBA$V_SR_ISTO = 8,1,1,0 %;        !  INTERFACE SEQUENCE TIMEOUT 
macro MBA$V_SR_RDS = 8,2,1,0 %;         !  READ DATA SUBSTITUTE 
macro MBA$V_SR_ERCONF = 8,3,1,0 %;      !  ERROR CONFIRMATION 
macro MBA$V_SR_INVMAP = 8,4,1,0 %;      !  INVALID MAP REGISTER 
macro MBA$V_SR_MAPPE = 8,5,1,0 %;       !  MAP PARITY ERROR 
macro MBA$V_SR_MDPE = 8,6,1,0 %;        !  MASSBUS DATA PARITY ERROR 
macro MBA$V_SR_MBEXC = 8,7,1,0 %;       !  MASSBUS EXCEPTION 
macro MBA$V_SR_MXF = 8,8,1,0 %;         !  MISSED TRANSFER ERROR 
macro MBA$V_SR_WCKLWR = 8,9,1,0 %;      !  WRITE CHECK ERROR LOWER BYTE 
macro MBA$V_SR_WCKUPR = 8,10,1,0 %;     !  WRITE CHECK ERROR UPPER BYTE 
macro MBA$V_SR_DLT = 8,11,1,0 %;        !  DATA LATE ERROR 
macro MBA$V_SR_DTABT = 8,12,1,0 %;      !  DATA TRANSFER ABORTED 
macro MBA$V_SR_DTCOMP = 8,13,1,0 %;     !  DATA TRANSFER COMPLETE 
macro MBA$V_SR_SPE = 8,14,1,0 %;        !  SILO PARITY ERROR 
macro MBA$V_SR_ATTN = 8,16,1,0 %;       !  MASSBUS ATTENTION 
macro MBA$V_SR_MCPE = 8,17,1,0 %;       !  MASSBUS COMTROL PARITY ERROR 
macro MBA$V_SR_NED = 8,18,1,0 %;        !  NONEXISTENT DRIVE 
macro MBA$V_SR_PGE = 8,19,1,0 %;        !  PROGRAM ERROR 
macro MBA$V_SR_CBHUNG = 8,23,1,0 %;     !  CB HUNG 
macro MBA$V_SR_CRD = 8,29,1,0 %;        !  CORRECTED READ DATA 
macro MBA$V_SR_NRCONF = 8,30,1,0 %;     !  NO RESPONSE CONFIRMATION 
macro MBA$V_SR_DTBUSY = 8,31,1,0 %;     !  DATA TRANSFER BUSY 
!  ERROR BITS 
macro MBA$L_VAR = 12,0,32,1 %;          ! VIRTUAL ADDRESS REGISTER 
macro MBA$L_BCR = 16,0,32,0 %;          ! BYTE COUNT REGISTER 
macro MBA$L_DR = 20,0,32,0 %;           ! DIAGNOSTIC REGISTER 
macro MBA$L_SELMR = 24,0,32,0 %;        ! SELECTED MAP REGISTER 
macro MBA$L_ERB = 1024,0,32,1 %;        ! BASE ADDRESS OF EXTERNAL REGISTERS 
macro MBA$V_ERB_UNIT = 1024,7,3,0 %;
literal MBA$S_ERB_UNIT = 3;             !  DRIVE UNIT NUMBER 
macro MBA$L_AS = 1040,0,32,0 %;         ! ATTENTION SUMMARY REGISTER 
!  TO POSITION TO 2048
macro MBA$L_MAP = 2048,0,0,0 %;
literal MBA$S_MAP = 1024;               ! MAP REGISTERS 
 
!*** MODULE $MBXDEF ***
! +
!  SHARED MEMORY MAILBOX CONTROL BLOCK DEFINITIONS
! 
!  THERE IS ONE MAILBOX CONTROL BLOCK FOR EACH MAILBOX IN SHARED
!  MEMORY.  ANY PROCESSOR THAT WANTS TO ACCESS THE MAILBOX CREATES
!  A UCB TO CONTROL ACCESS TO THE MAILBOX.
! -
literal MBX$M_ALLOC = %X'1';
literal MBX$M_VALID = %X'2';
literal MBX$M_DELPEND = %X'4';
literal MBX$M_QUOTALCK = %X'8';
literal MBX$K_LENGTH = 48;              ! LENGTH OF STRUCTURE 
literal MBX$C_LENGTH = 48;              ! LENGTH OF STRUCTURE 
literal MBX$S_MBXDEF = 48;
literal MBX$S_MBX = 48;
macro MBX$Q_MSG = 0,0,0,0 %;
literal MBX$S_MSG = 8;                  ! MESSAGE QUEUE LISTHEAD 
macro MBX$B_FLAGS = 8,0,8,0 %;          ! FLAGS 
macro MBX$V_ALLOC = 8,0,1,0 %;          !  MAILBOX ALLOCATED 
macro MBX$V_VALID = 8,1,1,0 %;          !  MAILBOX INITIALIZED AND USEABLE 
macro MBX$V_DELPEND = 8,2,1,0 %;        !  DELETE PENDING 
macro MBX$V_QUOTALCK = 8,3,1,0 %;       !  QUOTA/COUNT MODIFICATION LOCK 
macro MBX$B_CREATPORT = 9,0,8,0 %;      ! PORT NUMBER OF MAILBOX CREATOR 
macro MBX$W_UNIT = 10,0,16,0 %;         ! MAILBOX UNIT NUMBER 
macro MBX$W_REF = 12,0,16,0 %;          ! REFERENCE FLAGS (1 BIT/PORT) 
macro MBX$W_READER = 14,0,16,0 %;       ! WAITING READER (1 BIT/PORT) 
macro MBX$W_READAST = 16,0,16,0 %;      ! WAITING READ AST (1 BIT/PORT) 
macro MBX$W_WRITAST = 18,0,16,0 %;      ! WAITING WRITE AST (1 BIT/PORT) 
macro MBX$W_MAXMSG = 20,0,16,0 %;       ! MAXIMUM MESSAGE SIZE 
macro MBX$W_MSGCNT = 22,0,16,0 %;       ! CURRENT NUMBER OF MESSAGES 
macro MBX$W_BUFFQUO = 24,0,16,0 %;      ! BUFFER QUOTA 
macro MBX$W_PROT = 26,0,16,0 %;         ! PROTECTION MASK 
macro MBX$L_OWNUIC = 28,0,32,0 %;       ! OWNER UIC 
macro MBX$T_NAME = 32,0,0,0 %;
literal MBX$S_NAME = 16;                ! MAILBOX NAME (COUNTED STRING) 
!  *** THE LENGTH OF THIS STRUCTURE MUST BE AN EVEN MULTIPLE OF 8 ***
!  *** BECAUSE THE MESSAGE QUEUE HEADER MUST BE QUADWORD ALIGNED ***
 
!*** MODULE MCBDEF IDENT X-2 ***
literal MCB$S_MCB = 24;
macro MCB$L_FLINK = 0,0,32,1 %;         !  Queue forward link
macro MCB$L_BLINK = 4,0,32,1 %;         !  Queue backward link
macro MCB$W_SIZE = 8,0,16,0 %;          !  Size of data structure
macro MCB$B_TYPE = 10,0,8,0 %;          !  Type DYN$C_SM 
macro MCB$B_SUBTYPE = 11,0,8,0 %;       !  Subtype DYN$C_SM_MCB
macro MCB$L_VCB = 12,0,32,1 %;          !  Address of VCB for mount
macro MCB$L_IMCV = 16,0,32,0 %;         !  Internal mount context value
macro MCB$L_EMCV = 20,0,32,0 %;         !  External mount context value
literal MCB$S_MCBDEF = 24;              !  Old size name, synonym for MCB$S_MCB
 
!*** MODULE $MCHKDEF ***
! +
!  MACHINE CHECK ERROR RECOVERY BLOCK MASK BIT DEFFINITIONS
!  BITS USED TO FILTER AND TEST FOR ERROR TYPES
! -             
literal MCHK$M_LOG = %X'1';
literal MCHK$M_MCK = %X'2';
literal MCHK$M_NEXM = %X'4';
literal MCHK$M_SYSLOA = %X'8';
literal MCHK$S_MCHKBITDEF = 1;          !  Old size name - synonym
literal MCHK$S_MCHKBIT = 1;
macro MCHK$V_LOG = 0,0,1,0 %;           !  Inhibit error log for the error 
macro MCHK$V_MCK = 0,1,1,0 %;           !  Protect against machine checks 
macro MCHK$V_NEXM = 0,2,1,0 %;          !  Protect against non-existent memory 
macro MCHK$V_SYSLOA = 0,3,1,0 %;        !  Protect against recursive entry to handler
!  Offset to state saved on the stack by EXE$MCHECK_PROTECT
literal MCHK$K_LEN = 224;               !  Length of structure
literal MCHK$S_MCHKSAVDEF = 224;        !  Old size name - synonym
literal MCHK$S_MCHKSAV = 224;
macro MCHK$IQ_SAVED_IPL = 0,0,0,0 %;
literal MCHK$S_SAVED_IPL = 8;
macro MCHK$IQ_SAVED_MASK_SP = 8,0,0,0 %;
literal MCHK$S_SAVED_MASK_SP = 8;
macro MCHK$IQ_SAVED_R02 = 16,0,0,0 %;
literal MCHK$S_SAVED_R02 = 8;
macro MCHK$IQ_SAVED_R03 = 24,0,0,0 %;
literal MCHK$S_SAVED_R03 = 8;
macro MCHK$IQ_SAVED_R04 = 32,0,0,0 %;
literal MCHK$S_SAVED_R04 = 8;
macro MCHK$IQ_SAVED_R05 = 40,0,0,0 %;
literal MCHK$S_SAVED_R05 = 8;
macro MCHK$IQ_SAVED_R06 = 48,0,0,0 %;
literal MCHK$S_SAVED_R06 = 8;
macro MCHK$IQ_SAVED_R07 = 56,0,0,0 %;
literal MCHK$S_SAVED_R07 = 8;
macro MCHK$IQ_SAVED_R08 = 64,0,0,0 %;
literal MCHK$S_SAVED_R08 = 8;
macro MCHK$IQ_SAVED_R09 = 72,0,0,0 %;
literal MCHK$S_SAVED_R09 = 8;
macro MCHK$IQ_SAVED_R10 = 80,0,0,0 %;
literal MCHK$S_SAVED_R10 = 8;
macro MCHK$IQ_SAVED_R11 = 88,0,0,0 %;
literal MCHK$S_SAVED_R11 = 8;
macro MCHK$IQ_SAVED_R12 = 96,0,0,0 %;
literal MCHK$S_SAVED_R12 = 8;
macro MCHK$IQ_SAVED_R13 = 104,0,0,0 %;
literal MCHK$S_SAVED_R13 = 8;
macro MCHK$IQ_SAVED_R14 = 112,0,0,0 %;
literal MCHK$S_SAVED_R14 = 8;
macro MCHK$IQ_SAVED_R15 = 120,0,0,0 %;
literal MCHK$S_SAVED_R15 = 8;
macro MCHK$IQ_SAVED_R16 = 128,0,0,0 %;
literal MCHK$S_SAVED_R16 = 8;
macro MCHK$IQ_SAVED_R17 = 136,0,0,0 %;
literal MCHK$S_SAVED_R17 = 8;
macro MCHK$IQ_SAVED_R26 = 144,0,0,0 %;
literal MCHK$S_SAVED_R26 = 8;
macro MCHK$IQ_SAVED_R29 = 152,0,0,0 %;
literal MCHK$S_SAVED_R29 = 8;
macro MCHK$IQ_SAVED_F02 = 160,0,0,0 %;
literal MCHK$S_SAVED_F02 = 8;
macro MCHK$IQ_SAVED_F03 = 168,0,0,0 %;
literal MCHK$S_SAVED_F03 = 8;
macro MCHK$IQ_SAVED_F04 = 176,0,0,0 %;
literal MCHK$S_SAVED_F04 = 8;
macro MCHK$IQ_SAVED_F05 = 184,0,0,0 %;
literal MCHK$S_SAVED_F05 = 8;
macro MCHK$IQ_SAVED_F06 = 192,0,0,0 %;
literal MCHK$S_SAVED_F06 = 8;
macro MCHK$IQ_SAVED_F07 = 200,0,0,0 %;
literal MCHK$S_SAVED_F07 = 8;
macro MCHK$IQ_SAVED_F08 = 208,0,0,0 %;
literal MCHK$S_SAVED_F08 = 8;
macro MCHK$IQ_SAVED_F09 = 216,0,0,0 %;
literal MCHK$S_SAVED_F09 = 8;
 
!*** MODULE $MCJDEF ***
! 
!  Magic Cookie Jar (to contain platform independent mapping IOHANDLES)
! 
literal MCJ$K_HEADER_LEN = 16;
literal MCJ$S_MCJ = 32;
macro MCJ$PS_IDB = 0,0,32,1 %;          !  back pointer to IDB
macro MCJ$L_CRUMB_COUNT = 4,0,32,0 %;   !  number of handles MCJ will hold
macro MCJ$W_SIZE = 8,0,16,0 %;          !  size of MCJ
macro MCJ$B_TYPE = 10,0,8,0 %;          !  DYN$C_MISC
macro MCJ$B_SUBTYPE = 11,0,8,0 %;       !  DYN$C_MCJ
macro MCJ$Q_COOKIES = 16,0,0,0 %;
literal MCJ$S_COOKIES = 16;             !  Minimum sized list
macro MCJ$Q_ENTRIES = 16,0,0,0 %;
literal MCJ$S_ENTRIES = 16;             !  minimum sized list (preferred name)
literal MCJ$K_LENGTH = 32;
 
!*** MODULE $MFADEF ***
! +
!  MFA - MESSAGE FILE ARRAY
! 
!  There is one Message File Array on any system. The array is a set of
!   pointers to message files, both SYSMSG and file used by exec-lets.
! -
literal MFA$K_LENGTH = 8;               !  Length of MFA header
literal MFA$C_LENGTH = 8;               !  Length of MFA header
literal MFA$S_MFADEF = 12;
literal MFA$S_MFA = 12;
macro MFA$W_SIZE = 0,0,16,0 %;          !  Size of the array in bytes
macro MFA$W_FILCNT = 2,0,16,0 %;        !  Number of file pointers stored
macro MFA$W_BUGCNT = 4,0,16,0 %;        !  Count of events that shouldnt happen
macro MFA$W_RSRVD = 6,0,16,0 %;         !  Reserved, lonword align structure
macro MFA$L_PTR_BASE = 8,0,32,0 %;      !  Offset to first address
 
!*** MODULE MMECBDEF IDENT X-4 ***
literal MMECB$M_UNLOAD = %X'1';
literal MMECB$M_ALLOC = %X'2';
literal MMECB$M_BACKUP_FILE = %X'4';
literal MMECB$M_CLOSE_READ = %X'8';
literal MMECB$M_CLOSE_WRITE = %X'10';
literal MMECB$M_CONTINUATION_VOLUME = %X'20';
literal MMECB$M_DEALLOCATE = %X'40';
literal MMECB$M_DEVICE_AVAIL = %X'80';
literal MMECB$M_DEVICE_UNAVAIL = %X'100';
literal MMECB$M_DISMOUNT = %X'200';
literal MMECB$M_DISPLAY_MESSAGE = %X'400';
literal MMECB$M_EOV_READ = %X'800';
literal MMECB$M_EOV_WRITE = %X'1000';
literal MMECB$M_INITIALIZE = %X'2000';
literal MMECB$M_MOUNT = %X'4000';
literal MMECB$M_MOUNT_REQUEST = %X'8000';
literal MMECB$M_NEWVOL_REQUEST = %X'10000';
literal MMECB$M_NOTIFY_DEVICE = %X'20000';
literal MMECB$M_OPCOM_ACP = %X'40000';
literal MMECB$M_OPCOM_MOUNT = %X'80000';
literal MMECB$M_OPEN_READ = %X'100000';
literal MMECB$M_OPEN_WRITE = %X'200000';
literal MMECB$M_VOLUME_ONLINE = %X'400000';
literal MMECB$M_BACKUP_END = %X'800000';
literal MMECB$M_BACKUP_START = %X'1000000';
literal MMECB$M_WRITE_REQUEST = %X'2000000';
literal MMECB$M_MOUNT_END = %X'4000000';
literal MMECB$M_INIT_END = %X'8000000';
literal MMECB$M_NEWVOL_END = %X'10000000';
literal MMECB$M_DMTPRCDEL = %X'20000000';
literal MMECB$S_MMECB = 32;
macro MMECB$W_FACILITY = 0,0,16,0 %;    !  TMS facility code
macro MMECB$W_MBUNIT = 2,0,16,0 %;      !  Mailbox unit number
macro MMECB$L_PID = 4,0,32,0 %;         !  Pid of TMS process
macro MMECB$W_SIZE = 8,0,16,0 %;        !  Control block size
macro MMECB$B_TYPE = 10,0,8,0 %;        !  BLOCK TYPE CODE
macro MMECB$B_SUBTYPE = 11,0,8,0 %;     !  BLOCK SUBTYPE CODE
macro MMECB$L_MBXUCB = 12,0,32,1 %;     !  Mailbox UCB address
macro MMECB$Q_ROUTINE_MASK = 16,0,0,0 %;
literal MMECB$S_ROUTINE_MASK = 8;
macro MMECB$V_UNLOAD = 16,0,1,0 %;
macro MMECB$V_ALLOC = 16,1,1,0 %;
macro MMECB$V_BACKUP_FILE = 16,2,1,0 %;
macro MMECB$V_CLOSE_READ = 16,3,1,0 %;
macro MMECB$V_CLOSE_WRITE = 16,4,1,0 %;
macro MMECB$V_CONTINUATION_VOLUME = 16,5,1,0 %;
macro MMECB$V_DEALLOCATE = 16,6,1,0 %;
macro MMECB$V_DEVICE_AVAIL = 16,7,1,0 %;
macro MMECB$V_DEVICE_UNAVAIL = 16,8,1,0 %;
macro MMECB$V_DISMOUNT = 16,9,1,0 %;
macro MMECB$V_DISPLAY_MESSAGE = 16,10,1,0 %;
macro MMECB$V_EOV_READ = 16,11,1,0 %;
macro MMECB$V_EOV_WRITE = 16,12,1,0 %;
macro MMECB$V_INITIALIZE = 16,13,1,0 %;
macro MMECB$V_MOUNT = 16,14,1,0 %;
macro MMECB$V_MOUNT_REQUEST = 16,15,1,0 %;
macro MMECB$V_NEWVOL_REQUEST = 16,16,1,0 %;
macro MMECB$V_NOTIFY_DEVICE = 16,17,1,0 %;
macro MMECB$V_OPCOM_ACP = 16,18,1,0 %;
macro MMECB$V_OPCOM_MOUNT = 16,19,1,0 %;
macro MMECB$V_OPEN_READ = 16,20,1,0 %;
macro MMECB$V_OPEN_WRITE = 16,21,1,0 %;
macro MMECB$V_VOLUME_ONLINE = 16,22,1,0 %;
macro MMECB$V_BACKUP_END = 16,23,1,0 %;
macro MMECB$V_BACKUP_START = 16,24,1,0 %;
macro MMECB$V_WRITE_REQUEST = 16,25,1,0 %;
macro MMECB$V_MOUNT_END = 16,26,1,0 %;
macro MMECB$V_INIT_END = 16,27,1,0 %;
macro MMECB$V_NEWVOL_END = 16,28,1,0 %;
macro MMECB$V_DMTPRCDEL = 16,29,1,0 %;
macro MMECB$L_MCL_FLINK = 24,0,32,1 %;  !  Mount context list forward link
macro MMECB$L_MCL_BLINK = 28,0,32,1 %;  !  Mount context list backward link
literal MMECB$S_MMECBDEF = 32;          !  Old size name, synonym for MMECB$S_MMECB
literal MME$M_WAS_RUNNING = %X'1';
literal MME$S_MMEFLAGS = 1;
macro MME$B_FLAGS_MASK = 0,0,8,0 %;
macro MME$V_WAS_RUNNING = 0,0,1,0 %;
 
!*** MODULE $MMGDEF ***
literal MMG$M_NOWAIT = 2;               !  Don't allow FREWSLE to resource wait
literal MMG$V_NOWAIT = 1;               !   on modified list back pressure
literal MMG$M_NOLASTUPD = 1;            !  Don't allow FREWSLE to update WSLAST
literal MMG$V_NOLASTUPD = 0;            !   (prevent WSLAST/WSSIZE interactions)
literal MMG$M_TICK_ENABLE = 1;          !  TICKING enable bit
literal MMG$V_TICK_ENABLE = 0;          !   (MMG$GB_CTLFLAGS)
literal MMG$M_TROLL_ENABLE = 2;         !  TROLLING enable bit
literal MMG$V_TROLL_ENABLE = 1;         !   (MMG$GB_CTLFLAGS)
literal MMG$M_TICK_ACT = 1;             !  TICKING activate bit
literal MMG$V_TICK_ACT = 0;             !   (MMG$GL_RECLAIM_FLAGS)
literal MMG$C_PTSPACE_OFFSET = 8;       !  Use L1PTE #1 to map page tables
literal MMG$K_PTSPACE_OFFSET = 8;       !  Use L1PTE #1 to map page tables
!         -F        ,B,0                        /* ending address of negated structure
!  (needed to obtain length definition)
literal MMG$K_LENGTH = -40;             !  size of scratch area 
literal MMG$C_LENGTH = -40;             !  size of scratch area 
literal MMG$M_DELGBLDON = %X'1';
literal MMG$M_CHGPAGFIL = %X'1';
literal MMG$M_NOWAIT_IPL0 = %X'2';
literal MMG$M_NO_OVERMAP = %X'4';
literal MMG$M_PARTIAL_FIRST = %X'8';
literal MMG$M_PARTIAL_LAST = %X'10';
literal MMG$M_NO_IRP_DELETE = %X'20';
literal MMG$M_DELPAG_NOP = %X'40';
literal MMG$M_CLUSTER_DEL = %X'80';
literal MMG$S_MMGDEF = 41;              !  Old size name - synonym
literal MMG$S_MMG = 41;
macro MMG$L_PGFLCNT = -40,0,32,1 %;     !  remaining page file quota
macro MMG$L_PAGCNT = -36,0,32,1 %;      !  Buffer Object page count
macro MMG$L_EFBLK = -36,0,32,1 %;       !  stored end-of-file block from WCB 
macro MMG$L_VFYFLAGS = -32,0,32,0 %;    !  verified section flags and maximum 
!   access mode for writing
macro MMG$L_SVSTARTVA = -28,0,32,1 %;   !  saved starting virtual address 
macro MMG$L_PAGESUBR = -24,0,32,1 %;    !  address of per page subroutine 
macro MMG$L_SAVRETADR = -20,0,32,1 %;   !  saved return address range 
macro MMG$L_CALLEDIPL = -16,0,32,1 %;   !  caller's IPL 
macro MMG$L_PER_PAGE = -12,0,32,0 %;    !  per-page processing context area
macro MMG$V_DELGBLDON = -12,0,1,0 %;    !  global pages in this range already deleted
macro MMG$L_ACCESS_MODE = -8,0,32,0 %;  !  maximized read access mode 
macro MMG$L_MMG_FLAGS = -4,0,32,0 %;    !  memory management control flags
macro MMG$V_CHGPAGFIL = -4,0,1,0 %;     !  charge page file for this PTE 
macro MMG$V_NOWAIT_IPL0 = -4,1,1,0 %;   !  abort instead of dropping to 0
macro MMG$V_NO_OVERMAP = -4,2,1,0 %;    !  don't overmap
macro MMG$V_PARTIAL_FIRST = -4,3,1,0 %; !  1st PTE mapped must be marked 'partial'
macro MMG$V_PARTIAL_LAST = -4,4,1,0 %;  !  last PTE mapped must be marked 'partial'
macro MMG$V_NO_IRP_DELETE = -4,5,1,0 %; !  Don't delete IRP when returning to
!  mainline (UPDSEC)
macro MMG$V_DELPAG_NOP = -4,6,1,0 %;    !  DELPAG skipped a page
macro MMG$V_CLUSTER_DEL = -4,7,1,0 %;   !  DELPAG may do clustered deletions
 
!*** MODULE $MPWDEF ***
literal MPW$C_IDLE = 0;
literal MPW$C_MAINTAIN = 1;
literal MPW$C_SVAPTE = 2;
literal MPW$C_OPCCRASH = 3;
literal MPW$C_MAXSTATE = 4;
literal MPW$C_DPTSCAN = 0;
literal MPW$C_DGBLSC = 1;
literal MPW$C_RELPHD = 2;
literal MPW$C_FREELIM = 3;
literal MPW$C_MPWCHECK = 4;
literal MPW$C_CRASH = 5;
literal MPW$C_MAXID = 6;
literal MPW$M_RCODE = %X'FF';
literal MPW$M_RMODIFIERS = %X'FF00';
literal MPW$M_RESERVED = %X'FF0000';
literal MPW$M_IDCODE = %X'FF000000';
literal MPW$M_LOLIMIT = %X'100';
literal MPW$S_MPWDEF = 4;               !  Old size name - synonym
literal MPW$S_MPW = 4;
!  Basic request code/modifiers structure
macro MPW$V_RCODE = 0,0,8,0 %;
literal MPW$S_RCODE = 8;                !  Request Code Field
macro MPW$V_RMODIFIERS = 0,8,8,0 %;
literal MPW$S_RMODIFIERS = 8;           !  Request Modifiers Field
macro MPW$V_RESERVED = 0,16,8,0 %;
literal MPW$S_RESERVED = 8;
macro MPW$V_IDCODE = 0,24,8,0 %;
literal MPW$S_IDCODE = 8;               !  Requestor ID code Field
!  Request modifiers for MAINTAIN request
macro MPW$V_LOLIMIT = 0,8,1,0 %;        !  New MPL low limit specified in R1
 
!*** MODULE $MTLDEF ***
! +
!  MOUNTED VOLUME LIST ENTRY. ONE SUCH ENTRY APPEARS IN THE PROCESS MOUNTED
!  VOLUME LIST FOR EACH VOLUME MOUNTED BY THE PROCESS AS /SHARE OR /NOSHARE.
!  IN ADDITION, EACH VOLUME MOUNTED /SYSTEM OR /GROUP HAS AN ENTRY IN THE
!  SYSTEM WIDE MOUNTED VOLUME LIST.
! -
literal MTL$K_LENGTH = 28;              !  LENGTH OF STRUCTURE 
literal MTL$C_LENGTH = 28;              !  LENGTH OF STRUCTURE 
literal MTL$S_MTLDEF = 28;
literal MTL$S_MTL = 28;
macro MTL$L_MTLFL = 0,0,32,1 %;         !  FORWARD LIST POINTER 
macro MTL$L_MTLBL = 4,0,32,1 %;         !  BACK LIST POINTER 
macro MTL$W_SIZE = 8,0,16,0 %;          !  STRUCTURE SIZE IN BYTES 
macro MTL$B_TYPE = 10,0,8,0 %;          !  STRUCTURE TYPE CODE 
macro MTL$B_STATUS = 11,0,8,0 %;        !  STATUS BYTE 
macro MTL$V_VOLSET = 11,0,1,0 %;        !  ENTRY IS FOR A VOLUME SET 
macro MTL$V_RVTVCB = 11,1,1,0 %;        !  Entry is for a RVT/VCB volume set
macro MTL$L_UCB = 12,0,32,1 %;          !  POINTER TO DEVICE UCB 
macro MTL$L_LOGNAME = 16,0,32,1 %;      !  POINTER TO ASSOCIATED LOGICAL NAME
macro MTL$L_LOGNAM2 = 20,0,32,1 %;      !  POINTER TO ALTERNATE LOGICAL NAME 
 
!*** MODULE $MUTEXDEF ***
! +
!  QUADWORD MUTEX DEFINITIONS
! -
literal MUTEX$M_WRT = %X'1';
literal MUTEX$M_INTERLOCK = %X'1';
literal MUTEX$S_MUTEXDEF = 8;           !  Old size name, synonym for MUTEX$S_MUTEX
literal MUTEX$S_MUTEX = 8;
macro MUTEX$W_STS = 0,0,16,0 %;         !  STATUS BITS 
macro MUTEX$V_WRT = 0,0,1,0 %;          !  WRITE PENDING OR IN PROGRESS 
macro MUTEX$V_INTERLOCK = 0,0,1,0 %;    !  INTERLOCK ACCESS TO MUTEX
macro MUTEX$L_OWNCNT = 4,0,32,0 %;      !  OWNERSHIP COUNT 
 
!*** MODULE $MTXDEF ***
! +
!  LONGWORD MUTEX DEFINITIONS (OLD STYLE)
! -
literal MTX$S_MTXDEF = 4;               !  Old size name, synonym for MTX$S_MTX
literal MTX$S_MTX = 4;
macro MTX$R_MTX_OVERLAY = 0,0,32,0 %;
macro MTX$V_WRT = 0,16,1,0 %;           !  WRITE PENDING OR IN PROGRESS 
macro MTX$V_INTERLOCK = 0,17,1,0 %;     !  INTERLOCK ACCESS TO MUTEX
macro MTX$W_OWNCNT = 0,0,16,0 %;        ! OWNERSHIP COUNT 
macro MTX$W_STS = 2,0,16,0 %;           ! STATUS BITS 
 
!*** MODULE $MPMDEF ***
! +
!  MULTIPORT MEMORY (MA780/MA750) ADAPTER REGISTER OFFSET DEFINITIONS
! -
! 
!  The UETP for the MA780 depends on some of the following definitions.  Please
!  let someone in that group know if the definitions change substantially.
! 
literal MPM$C_PORTS = 4;                ! MAXIMUM NUMBER OF PORTS PER MEMORY 
literal MPM$M_CSR_PORT = %X'3';
literal MPM$M_CSR_ADCOD = %X'FF';
literal MPM$M_CSR_PU = %X'400000';
literal MPM$M_CSR_PD = %X'800000';
literal MPM$M_CSR_XMFLT = %X'4000000';
literal MPM$M_CSR_MT = %X'8000000';
literal MPM$M_CSR_IS = %X'10000000';
literal MPM$M_CSR_WS = %X'40000000';
literal MPM$M_CSR_PE = %X'80000000';
literal MPM$C_CSR_TYPE = 64;            !  MULTIPORT ADAPTER TYPE CODE 
literal MPM$M_CR_MIE = %X'1';
literal MPM$M_CR_EIE = %X'2';
literal MPM$M_CR_ERRS = %X'FF000000';
literal MPM$M_SR_EIE = %X'2';
literal MPM$M_SR_SS = %X'2000';
literal MPM$M_SR_IDL = %X'4000';
literal MPM$M_SR_IT = %X'8000';
literal MPM$M_SR_AGP = %X'10000000';
literal MPM$M_SR_XDF = %X'20000000';
literal MPM$M_SR_MXF = %X'40000000';
literal MPM$M_SR_ACA = %X'80000000';
literal MPM$M_INV_ID = %X'FFFF';
literal MPM$M_INV_MEMSZ = %X'70000';
literal MPM$M_INV_STADR = %X'7FF00000';
literal MPM$M_INV_CACHF = %X'80000000';
literal MPM$M_ERR_ELR = %X'10000000';
literal MPM$M_ERR_HI = %X'20000000';
literal MPM$M_ERR_ICRD = %X'40000000';
literal MPM$M_ERR_IMP = %X'80000000';
literal MPM$M_CSR1_MIA = %X'400';
literal MPM$S_MPMDEF = 40;              !  Old size name - synonym
literal MPM$S_MPM = 40;
macro MPM$L_CSR = 0,0,32,0 %;           ! CONFIGURATION STATUS REGISTER 
macro MPM$V_CSR_PORT = 0,0,2,0 %;
literal MPM$S_CSR_PORT = 2;             !  PORT NUMBER 
macro MPM$V_CSR_ADCOD = 0,0,8,0 %;
literal MPM$S_CSR_ADCOD = 8;            !  ADAPTER CODE FIELD 
macro MPM$V_CSR_PU = 0,22,1,0 %;        !  ADAPTER POWER UP 
macro MPM$V_CSR_PD = 0,23,1,0 %;        !  ADAPTER POWER DOWN 
macro MPM$V_CSR_XMFLT = 0,26,1,0 %;     !  TRANSMITTER FAULT 
macro MPM$V_CSR_MT = 0,27,1,0 %;        !  MULTIPLE TRANSMITTERS 
macro MPM$V_CSR_IS = 0,28,1,0 %;        !  INTERLOCK SEQUENCE 
macro MPM$V_CSR_WS = 0,30,1,0 %;        !  WRITE SEQUENCE DATA 
macro MPM$V_CSR_PE = 0,31,1,0 %;        !  SBI PARITY ERROR 
macro MPM$L_CR = 4,0,32,0 %;            ! CONTROL REGISTER 
macro MPM$V_CR_MIE = 4,0,1,0 %;         !  MASTER INTERRUPT ENABLE 
macro MPM$V_CR_EIE = 4,1,1,0 %;         !  ERROR INTERRUPT ENABLE 
macro MPM$V_CR_ERRS = 4,24,8,0 %;
literal MPM$S_CR_ERRS = 8;              !  PORT INTERFACE ERRORS 
macro MPM$L_SR = 8,0,32,0 %;            ! STATUS REGISTER 
macro MPM$V_SR_EIE = 8,1,1,0 %;         !  ERROR INTERRUPT ENABLE 
macro MPM$V_SR_SS = 8,13,1,0 %;         !  SINGLE STEP 
macro MPM$V_SR_IDL = 8,14,1,0 %;        !  INVALIDATE DATA LOST IN MPC 
macro MPM$V_SR_IT = 8,15,1,0 %;         !  INTERLOCK TIMEOUT 
macro MPM$V_SR_AGP = 8,28,1,0 %;        !  ADMI GRANT PARITY ERROR 
macro MPM$V_SR_XDF = 8,29,1,0 %;        !  XMIT DURING FAULT 
macro MPM$V_SR_MXF = 8,30,1,0 %;        !  MULTIPLE XMITTER FAULT 
macro MPM$V_SR_ACA = 8,31,1,0 %;        !  ADMI COMMAND ABORT 
macro MPM$L_INV = 12,0,32,0 %;          ! INVALIDATION CONTROL REGISTER 
macro MPM$V_INV_ID = 12,0,16,0 %;
literal MPM$S_INV_ID = 16;              !  CACHED DEVICE NEXUS ID'S 
macro MPM$V_INV_MEMSZ = 12,16,3,0 %;
literal MPM$S_INV_MEMSZ = 3;            !  MEMORY SIZE (256KB BOARDS) 
macro MPM$V_INV_STADR = 12,20,11,0 %;
literal MPM$S_INV_STADR = 11;           !  STARTING SBI ADDR OF MEMORY 
macro MPM$V_INV_CACHF = 12,31,1,0 %;    !  CACHED FORCE (IGNORE ID'S) 
macro MPM$L_ERR = 16,0,32,0 %;          ! ARRAY ERROR REGISTER 
macro MPM$V_ERR_ELR = 16,28,1,0 %;      !  ERROR LOG REQUEST 
macro MPM$V_ERR_HI = 16,29,1,0 %;       !  HIGH ERROR RATE 
macro MPM$V_ERR_ICRD = 16,30,1,0 %;     !  INHIBIT CRD ERRORS 
macro MPM$V_ERR_IMP = 16,31,1,0 %;      !  INVALIDATE MAP PARITY ERROR 
macro MPM$L_CSR0 = 20,0,32,0 %;         ! CONFIGURATION STATUS REGISTER 0 
macro MPM$V_CSR0_POW = 20,4,4,0 %;
literal MPM$S_CSR0_POW = 4;             !  PER PORT POWER STATUS 
macro MPM$V_CSR0_ERR = 20,8,4,0 %;
literal MPM$S_CSR0_ERR = 4;             !  PER PORT ERROR STATUS 
macro MPM$V_CSR0_ONL = 20,12,4,0 %;
literal MPM$S_CSR0_ONL = 4;             !  PER PORT ONLINE STATUS 
macro MPM$L_CSR1 = 24,0,32,0 %;         ! CONFIGURATION STATUS REGISTER 1 
macro MPM$V_CSR1_MIA = 24,10,1,0 %;     !  MULTIPLE INTERLOCK ACCEPTED 
macro MPM$L_MR = 28,0,32,0 %;           ! MAINTENANCE REGISTER 
macro MPM$V_MR_UNIT = 28,14,2,0 %;
literal MPM$S_MR_UNIT = 2;              !  MEMORY UNIT NUMBER 
macro MPM$L_IIR = 32,0,32,0 %;          ! INTERPORT INTERRUPT REQUEST REGISTER 
macro MPM$V_IIR_STS = 32,0,16,0 %;
literal MPM$S_IIR_STS = 16;             !  STATUS BITS (WRITE TO CLEAR) 
macro MPM$V_IIR_CTL = 32,16,16,0 %;
literal MPM$S_IIR_CTL = 16;             !  CONTROL BITS (WRITE TO SET STATUS BITS) 
macro MPM$L_IIE = 36,0,32,0 %;          ! INTERPORT INTERRUPT ENABLE REGISTER 
macro MPM$V_IIE_STS = 36,0,16,0 %;
literal MPM$S_IIE_STS = 16;             !  CONTROL BITS (WRITE TO CLEAR) 
macro MPM$V_IIE_CTL = 36,16,16,0 %;
literal MPM$S_IIE_CTL = 16;             !  STATUS BITS (WRITE TO SET STATUS BITS) 
 
!*** MODULE $MSLGDEF ***
! +
!  MSLG, MScp error LoG message definitions
!  	These definitions describe the format of the error log messages 
!  	generated by MSCP and TMSCP devices.
! -
! 
! 	Generic MSCP/TMSCP error log entry format
! 
literal MSLG$M_LF_SQNRS = %X'1';
literal MSLG$M_LF_RPLER = %X'10';
literal MSLG$M_LF_BBR = %X'20';
literal MSLG$M_LF_CONT = %X'40';
literal MSLG$M_LF_SUCC = %X'80';
literal MSLG$K_CNT_ERR = 0;
literal MSLG$K_BUS_ADDR = 1;
literal MSLG$K_DISK_TRN = 2;
literal MSLG$K_SDI = 3;
literal MSLG$K_SML_DSK = 4;
literal MSLG$K_TAPE_TRN = 5;
literal MSLG$K_STI_ERR = 6;
literal MSLG$K_STI_DEL = 7;
literal MSLG$K_STI_FEL = 8;
literal MSLG$K_REPLACE = 9;
literal MSLG$K_LDR_ERR = 10;
literal MSLG$S_MSLG_CNT_ERR = 23;       !  Old size name for MSLG_CNT_ERR aggregate
literal MSLG$S_MSLG_BUS_ADDR = 28;      !   Old size name for MSLG_BUS_ADDR  aggregate
literal MSLG$M_LFR_BR = %X'400';
literal MSLG$M_LFR_RI = %X'800';
literal MSLG$M_LFR_RF = %X'1000';
literal MSLG$M_LFR_TE = %X'2000';
literal MSLG$M_LFR_FE = %X'4000';
literal MSLG$M_LFR_RP = %X'8000';
literal MSLG$S_MSLG_SML_DSK = 41;       !  Old size name for MSLG_SML_DSK aggregate.
literal MSLG$S_GENERIC_MSCP_ERRLOG = 44;
macro MSLG$L_CMD_REF = 0,0,32,0 %;      !  Command reference number 
macro MSLG$W_UNIT = 4,0,16,0 %;         !  Unit number 
macro MSLG$W_SEQ_NUM = 6,0,16,0 %;      !  Sequence Number
macro MSLG$B_FORMAT = 8,0,8,0 %;        !  Format
macro MSLG$B_FLAGS = 9,0,8,0 %;         !  Error Log Message Flags
macro MSLG$V_LF_SQNRS = 9,0,1,0 %;      !    Sequence Number Reset
macro MSLG$V_LF_RPLER = 9,4,1,0 %;      !    Error during replacement
macro MSLG$V_LF_BBR = 9,5,1,0 %;        !    Bad block replacement request
macro MSLG$V_LF_CONT = 9,6,1,0 %;       !    Operation continuing
macro MSLG$V_LF_SUCC = 9,7,1,0 %;       !    Operation successful
macro MSLG$W_EVENT = 10,0,16,0 %;       !  Event Code
macro MSLG$Q_CNT_ID = 12,0,0,0 %;
literal MSLG$S_CNT_ID = 8;              !  Controller ID
macro MSLG$B_CNT_SVR = 20,0,8,0 %;      !  Controller software version
macro MSLG$B_CNT_HVR = 21,0,8,0 %;      !  Controller hardware version
macro MSLG$W_MULT_UNT = 22,0,16,0 %;    !  Multi-unit Code
macro MSLG$Z_CNT_ERR = 22,0,8,1 %;      !  Controller dependent data - previously contained
!  in MSLG_CNT_ERR  aggregate 
!  Controller Error (MSLG$K_CNT_ERR)
macro MSLG$Q_UNIT_ID = 24,0,0,0 %;
literal MSLG$S_UNIT_ID = 8;             !  Unit ID
macro MSLG$L_BUS_ADDR = 24,0,32,1 %;    !   Host Memory Access Error (MSLG$K_BUS_ADDR)
!   Bus Address - previously contained in
!   MSLG_BUS_ADDR aggregate
macro MSLG$B_UNIT_SVR = 32,0,8,0 %;     !  Unit software version
macro MSLG$B_UNIT_HVR = 33,0,8,0 %;     !  Unit hardware version
macro MSLG$B_LEVEL = 34,0,8,0 %;        !  Level
macro MSLG$B_RETRY = 35,0,8,0 %;        !  Retry
macro MSLG$W_SDE_CYL = 34,0,16,0 %;     !  Cylinder - used in MSLG_SML_DSK for MSLG$K_SML_DSK
macro MSLG$W_RPL_FLGS = 34,0,16,0 %;    !  Replace Flags - used in MSLG_REPLACE for MSLG$K_REPLACE
macro MSLG$V_LFR_BR = 34,10,1,0 %;      !   Bad RBN
macro MSLG$V_LFR_RI = 34,11,1,0 %;      !   RCT inconsistent
macro MSLG$V_LFR_RF = 34,12,1,0 %;      !   Reformat error
macro MSLG$V_LFR_TE = 34,13,1,0 %;      !   Tertiary revector
macro MSLG$V_LFR_FE = 34,14,1,0 %;      !   Forced error (data not recovered)
macro MSLG$V_LFR_RP = 34,15,1,0 %;      !   Replace attempted (block really bad)
macro MSLG$L_VOL_SER = 36,0,32,0 %;     !  Volume Serial Number (disks)
macro MSLG$L_GAP_CNT = 36,0,32,0 %;     !  Position - object count (tapes)
macro MSLG$B_FMTR_SVR = 40,0,8,0 %;     !  Formatter software version
macro MSLG$B_FMTR_HVR = 41,0,8,0 %;     !  Formatter hardware version
macro MSLG$L_HDR_CODE = 40,0,32,0 %;    !  Header Code	- from MSLG_DISK_TRN aggregate for
! 		  Disk Transfer Error (MSLG$K_DISK_TRN) 
macro MSLG$L_BAD_LBN = 40,0,32,0 %;     !  Bad LBN - from MSLG_REPLACE aggregate for 
! 		  Bad Block Replacement Attempted (MSLG$K_REPLACE
macro MSLG$Z_SML_DSK = 40,0,8,1 %;      !  Controller or device dependent - used in MSLG_SML_DSK
macro MSLG$Q_ML_ID = 36,0,0,0 %;
literal MSLG$S_ML_ID = 8;               !  Media loader identifier -  
!  used in MSLG_LDR_ERR for MSLG$K_LDR_ERR
! 
!   Controller Error (MSLG$K_CNT_ERR)
!   
!   Aggregate MSLG_CNT_ERR has been removed and it's fields have been 
!   incorporated into GENERIC_MSCP_ERRLOG.  The following fields are
!   specific to this error:
!       CNT_ERR byte tag Z;                         /* Controller dependent data - this field is now 
! 
!   Host Memory Access Error (MSLG$K_BUS_ADDR)
! 
!   Aggregate MSLG_BUS_ADDR has been removed and it's fields have been 
!   incorporated into GENERIC_MSCP_ERRLOG.  The following fields are
!   specific to this error:
!     BUS_ADDR longword unsigned;                 /* Bus Address
! 
!   Disk Transfer Error (MSLG$K_DISK_TRN)
! 
literal MSLG$K_DISK_TRN_MSGSIZ = 44;    !  Size of DISK_TRN_ERROR msg.
literal MSLG$S_MSLG_DISK_TRN = 45;
!  HDR_CODE - is now located in GENERIC_MSCP_ERRLOG
macro MSLG$Z_DISK_TRN = 44,0,8,1 %;     !  Controller or disk dependent data
! 
!   SDI Error (MSLG$K_SDI)
! 
literal MSLG$S_MSLG_SDI = 56;
macro MSLG$Z_SDI = 44,0,0,0 %;
literal MSLG$S_SDI = 12;                !  SDI Information
! 
!   Small Disk Error (MSLG$K_SML_DSK)
! 
!   Aggregate MSLG_SML_DSK has been removed and it's fields have been 
!   incorporated into GENERIC_MSCP_ERRLOG.  The following fields are
!   specific to this error:
!       SDE_CYL word unsigned;                      /* Cylinder
! 	SML_DSK byte tag Z;                         /* Controller or device dependent
! 
!   Tape Transfer Error (MSLG$K_STI_ERR)
! 
! 	There are no special field definitions for tape transfer errors at this time.
! 
!   STI communication or command failure (MSLG$K_STI_ERR)
!   STI drive error log (MSLG$K_STI_DEL)
!   STI formatter error log (MSLG$K_STI_FEL)
! 
literal MSLG$S_MSLG_STI_ERR = 64;
macro MSLG$Z_STI = 44,0,0,0 %;
literal MSLG$S_STI = 20;                !  STI Information
! 
!   Bad Block Replacement Attempted (MSLG$K_REPLACE)
! 
literal MSLG$K_REPLACE_MSGSIZ = 54;     !  Size of REPLACE msg for BBR error logging
literal MSLG$S_MSLG_REPLACE = 54;
!  Replace Flags now located in GENERIC_MSCP_ERRLOG
macro MSLG$L_OLD_RBN = 44,0,32,0 %;     !  Previous RBN
macro MSLG$L_NEW_RBN = 48,0,32,0 %;     !  New RBN
macro MSLG$W_CAUSE = 52,0,16,0 %;       !  Event code causing replacement
! 
!   Media Loader Errors (MSLG$K_LDR_ERR)
! 
literal MSLG$S_MSLG_LDR_ERR = 49;
! The following fields have been moved to GENERIC_MSCP_ERRLOG
macro MSLG$B_ML_SVR = 44,0,8,0 %;       !  Media loader software version
macro MSLG$B_ML_HVR = 45,0,8,0 %;       !  Media loader hardware version
macro MSLG$W_ML_UNIT = 46,0,16,0 %;     !  Media loader unit number
macro MSLG$Z_LDR_ERR = 48,0,8,1 %;      !  Controller dependent data 
 
!*** MODULE $MSCPDEF ***
! ++
!  MSCP (Mass Storage Control Protocol) Definitions
! 
! 	These definitions describe the format of the command and end message 
! 	packets exchanged under MSCP between the host and the controller.
! --
literal MSCP$M_EU_NO = %X'FF';
literal MSCP$M_EU_SUBU = %X'7';
literal MSCP$M_EU_SUBC = %X'F8';
literal MSCP$K_EMS_CNSL = 0;
literal MSCP$K_EMS_RP = 1;
literal MSCP$K_EMS_RM = 2;
literal MSCP$K_EMS_RK = 3;
literal MSCP$K_EMS_RL = 4;
literal MSCP$K_EMS_RX = 5;
literal MSCP$K_EMS_FD1 = 6;
literal MSCP$K_EMS_FD2 = 7;
literal MSCP$K_EMS_FD3 = 8;
literal MSCP$K_EMS_FD4 = 9;
literal MSCP$K_EMS_FD5 = 10;
literal MSCP$K_EMS_FD6 = 11;
literal MSCP$K_EMS_FD7 = 12;
literal MSCP$K_EMS_FD8 = 13;
literal MSCP$M_EU_CTYPE = %X'F00';
literal MSCP$K_EMD_OLD = 0;
literal MSCP$K_EMD_UDA = 1;
literal MSCP$K_EMD_HSC = 2;
literal MSCP$K_EMD_AZT = 3;
literal MSCP$K_EMD_RDRX = 4;
literal MSCP$K_EMD_EMUL = 5;
literal MSCP$M_EU_DESIG = %X'7000';
literal MSCP$M_SHADOW = %X'8000';
literal MSCP$M_OP_ATTN = %X'40';
literal MSCP$M_OP_END = %X'80';
literal MSCP$M_MD_SEREC = %X'100';
literal MSCP$M_MD_SECOR = %X'200';
literal MSCP$M_MD_CLSEX = %X'2000';
literal MSCP$M_MD_COMP = %X'4000';
literal MSCP$M_MD_WRSEQ = %X'10';
literal MSCP$M_MD_WBKVL = %X'20';
literal MSCP$M_MD_WBKNV = %X'40';
literal MSCP$M_MD_SSHDW = %X'80';
literal MSCP$M_MD_SCCHL = %X'400';
literal MSCP$M_MD_SCCHH = %X'800';
literal MSCP$M_MD_ERROR = %X'1000';
literal MSCP$M_MD_EXPRS = %X'8000';
literal MSCP$M_MD_REWND = %X'2';
literal MSCP$M_MD_OBJCT = %X'4';
literal MSCP$M_MD_REVRS = %X'8';
literal MSCP$M_MD_UNLOD = %X'10';
literal MSCP$M_MD_IMMED = %X'40';
literal MSCP$M_MD_DLEOT = %X'80';
literal MSCP$M_MD_CDATL = %X'1000';
literal MSCP$M_MD_SPNDW = %X'1';
literal MSCP$M_MD_ALLCD = %X'2';
literal MSCP$M_MD_DSOLV = %X'10';
literal MSCP$M_MD_FLENU = %X'1';
literal MSCP$M_MD_VOLTL = %X'2';
literal MSCP$M_MD_NXUNT = %X'1';
literal MSCP$M_MD_RIP = %X'1';
literal MSCP$M_MD_IGNMF = %X'2';
literal MSCP$M_MD_STWRP = %X'4';
literal MSCP$M_MD_CLWBL = %X'8';
literal MSCP$M_MD_SHDSP = %X'10';
literal MSCP$M_MD_EXCAC = %X'20';
literal MSCP$M_MD_PRIMR = %X'1';
literal MSCP$M_MD_CRNPR = %X'1';
literal MSCP$M_MD_ENRWR = %X'10';
literal MSCP$M_MD_TBC = %X'8000';
literal MSCP$M_MD_HISLO = %X'8';
literal MSCP$M_MD_SUPWL = %X'10';
literal MSCP$M_MD_REUSE = %X'80';
literal MSCP$M_MD_LOCSU = %X'1';
literal MSCP$M_MD_ESTCP = %X'2';
literal MSCP$M_MD_RETCP = %X'4';
literal MSCP$S_MSCP_MODIFIERS = 12;     !  MSCP_MODIFIERS used to be an aggregate.
!  We need to generate the old size field
literal MSCP$M_EF_CPRET = %X'1';
literal MSCP$M_EF_DLS = %X'2';
literal MSCP$M_EF_PLS = %X'4';
literal MSCP$M_EF_EOT = %X'8';
literal MSCP$M_EF_SEREX = %X'10';
literal MSCP$M_EF_ERLOG = %X'20';
literal MSCP$M_EF_BBLKU = %X'40';
literal MSCP$M_EF_BBLKR = %X'80';
literal MSCP$M_EF_HISLO = %X'4';
literal MSCP$M_EF_ALLOF = %X'8';
literal MSCP$M_ST_MASK = %X'1F';
literal MSCP$K_ST_SUCC = 0;
literal MSCP$K_ST_ICMD = 1;
literal MSCP$K_ST_ABRTD = 2;
literal MSCP$K_ST_OFFLN = 3;
literal MSCP$K_ST_AVLBL = 4;
literal MSCP$K_ST_MFMTE = 5;
literal MSCP$K_ST_WRTPR = 6;
literal MSCP$K_ST_COMP = 7;
literal MSCP$K_ST_DATA = 8;
literal MSCP$K_ST_HSTBF = 9;
literal MSCP$K_ST_CNTLR = 10;
literal MSCP$K_ST_DRIVE = 11;
literal MSCP$K_ST_FMTER = 12;
literal MSCP$K_ST_BOT = 13;
literal MSCP$K_ST_TAPEM = 14;
literal MSCP$K_ST_SHST = 12;
literal MSCP$K_ST_WHEAE = 13;
literal MSCP$K_ST_RDTRN = 16;
literal MSCP$K_ST_PLOST = 17;
literal MSCP$K_ST_PRESE = 18;
literal MSCP$K_ST_LED = 19;
literal MSCP$K_ST_BBR = 20;
literal MSCP$K_ST_IPARM = 21;
literal MSCP$K_ST_INFO = 22;
literal MSCP$K_ST_LOADR = 23;
literal MSCP$K_ST_HOST = 24;
literal MSCP$K_ST_UNREC = 20;
literal MSCP$K_ST_SBCERR = 30;
literal MSCP$K_ST_DIAG = 31;
literal MSCP$K_ST_SBCOD = 32;
literal MSCP$M_ST_SBCOD = %X'FFE0';
literal MSCP$K_SC_NORML = 0;            !  Normal
literal MSCP$K_SC_SDIGN = 1;            !  Spin Down IGNored
literal MSCP$K_SC_STCON = 2;            !  STill CONnected
literal MSCP$K_SC_DUPUN = 4;            !  DUPlicate UNit number
literal MSCP$K_SC_ALONL = 8;            !  ALready ONLine
literal MSCP$K_SC_STONL = 16;           !  STill ONLine
literal MSCP$K_SC_EOT = 32;             !  EOT encountered (tapes only)
literal MSCP$K_SC_INREP = 32;           !  INcomplete REPlacement (disks only)
literal MSCP$K_SC_IVRCT = 64;           !  InValid RCT (disks only)
literal MSCP$K_SC_RDONY = 128;          !  ReaD ONlY volume format
literal MSCP$M_SC_SDIGN = %X'20';
literal MSCP$M_SC_STCON = %X'40';
literal MSCP$M_SC_DUPUN = %X'80';
literal MSCP$M_SC_ALONL = %X'100';
literal MSCP$M_SC_STONL = %X'200';
literal MSCP$M_SC_EOT = %X'400';
literal MSCP$M_SC_INREP = %X'400';
literal MSCP$M_SC_IVRCT = %X'800';
literal MSCP$M_SC_RDONY = %X'1000';
literal MSCP$K_SC_INVML = 0;            !  INValid Message Length
!  Unit-Offline Subcode Values
literal MSCP$K_SC_UNKNO = 0;            !  UNKoNOwn unit or online to another controller
literal MSCP$K_SC_NOVOL = 1;            !  NO VOLume mounted or drive disabled (RUN/STOP)
literal MSCP$K_SC_INOPR = 2;            !  unit is INOPeRative
literal MSCP$K_SC_UDSBL = 8;            !  Unit disabled by field service or diagnostic
literal MSCP$K_SC_EXUSE = 16;           !  Exclusive use
literal MSCP$K_SC_LDR = 32;             !  Loader cycle error
literal MSCP$M_SC_NOVOL = %X'20';
literal MSCP$M_SC_INOPR = %X'40';
literal MSCP$M_SC_UDSBL = %X'100';
literal MSCP$M_SC_EXUSE = %X'200';
literal MSCP$M_SC_LDR = %X'400';
literal MSCP$K_SC_CPYIP = 2;            !  Copy in progress
literal MSCP$K_SC_NOMEM = 4;            !  No members in shadow set
literal MSCP$K_SC_ALUSE = 32;           !  Already in use
literal MSCP$M_SC_CPYIP = %X'40';
literal MSCP$M_SC_NOMEM = %X'80';
literal MSCP$M_SC_ALUSE = %X'400';
literal MSCP$K_SC_IVHD = 2;
literal MSCP$K_SC_NOSYNC = 3;
literal MSCP$K_SC_SSCM = 4;
literal MSCP$K_SC_NO512 = 5;
literal MSCP$K_SC_NOFMT = 6;
literal MSCP$K_SC_ECCER = 7;
literal MSCP$K_SC_RCTBD = 8;
literal MSCP$K_SC_NORBL = 9;
!  Write-Protected Subcode Values
literal MSCP$K_SC_DATAL = 8;            !  Unit is DATA Loss write protected (data safety)
literal MSCP$K_SC_SOFTW = 128;          !  Unit is SOFTWare protected 
literal MSCP$K_SC_HARDW = 256;          !  Unit is HARDWare protected 
literal MSCP$M_SC_DATAL = %X'100';
literal MSCP$M_SC_SOFTW = %X'1000';
literal MSCP$M_SC_HARDW = %X'2000';
literal MSCP$K_SC_FRCER = 0;            !  Forced Error (disks)
literal MSCP$K_SC_LGE = 0;              !  Long Gap Encountered (tapes)
literal MSCP$K_SC_MEDIA = 3;            !  Media error.
!  Host Buffer Access Error Subcode Values
literal MSCP$K_SC_ODDTA = 1;
literal MSCP$K_SC_ODDBC = 2;
literal MSCP$K_SC_NXM = 3;
literal MSCP$K_SC_MPAR = 4;
literal MSCP$K_SC_IVPTE = 5;
literal MSCP$K_SC_IVBFN = 6;
literal MSCP$K_SC_BLENV = 7;
literal MSCP$K_SC_ACVIO = 8;
!  Controller Error Subcode Values
literal MSCP$K_SC_DLATE = 1;
literal MSCP$K_SC_EDCER = 2;
literal MSCP$K_SC_DTSTR = 3;
literal MSCP$K_SC_IEDC = 4;
literal MSCP$K_SC_LACIN = 5;
literal MSCP$K_SC_LACOU = 6;
literal MSCP$K_SC_LACCB = 7;
literal MSCP$K_SC_OVRUN = 8;
literal MSCP$K_SC_MEMER = 9;
literal MSCP$K_SC_REMRSRC = 10;
literal MSCP$K_SC_RCONL = 20;
literal MSCP$K_SC_RCONF = 21;
literal MSCP$K_SC_BADSA = 22;
literal MSCP$K_SC_NOSER = 23;
literal MSCP$K_SC_NORES = 24;
literal MSCP$K_SC_NOCRE = 25;
literal MSCP$K_SC_BADPR = 26;
literal MSCP$K_SC_NEGAK = 27;
literal MSCP$K_SC_TMOUT = 28;
literal MSCP$K_SC_LCONF = 29;
literal MSCP$K_SC_DISCN = 30;
!  Bad Block Replacement Subcode Values
literal MSCP$K_SC_BBROK = 0;
literal MSCP$K_SC_NOTRP = 1;
literal MSCP$K_SC_RPLFL = 2;
literal MSCP$K_SC_ICRCT = 3;
literal MSCP$K_SC_DRVER = 4;
literal MSCP$K_SC_RCTFULL = 5;
literal MSCP$K_SC_RECURFAIL = 6;
!  Unrecognized Media Subcode Values
literal MSCP$K_SC_NOTAPEFMT = 1;
!  Invalid Parameter Subcode Values
literal MSCP$K_SC_IVKLN = 1;
literal MSCP$K_SC_IVKTY = 2;
literal MSCP$K_SC_IVKVL = 3;
!  Media Loader Error Subcode Values
literal MSCP$K_SC_ML_TMO = 1;
literal MSCP$K_SC_ML_TXERR = 2;
literal MSCP$K_SC_ML_PRTCL = 3;
literal MSCP$K_SC_ML_ERROR = 4;
!  Host Error Subcode Values
literal MSCP$K_SC_SEGUNDR = 1;
!  Write History Entry Access Error Subcode Values
literal MSCP$K_SC_ALLOF = 1;
literal MSCP$K_SC_TABFU = 2;
literal MSCP$K_SC_NOENT = 8;
literal MSCP$M_SC_ALLOF = %X'2';
literal MSCP$M_SC_TABFU = %X'4';
literal MSCP$M_SC_NOENT = %X'10';
literal MSCP$K_SC_DCDC = 3;
!  Subcommand Error Status or Event Subcode Values
literal MSCP$K_SC_DST_TIMOUT = 1;
literal MSCP$K_SC_DST_INCSTA = 2;
literal MSCP$K_SC_DST_UNRCOV = 4;
literal MSCP$K_SC_SRC_TIMOUT = 1025;
literal MSCP$K_SC_SRC_INCSTA = 1026;
literal MSCP$K_SC_SRC_UNRCOV = 1028;
literal MSCP$S_MSCP_SUBCODES = 12;
literal MSCP$S_MSCP_BASIC_PKT = 12;
macro MSCP$L_CMD_REF = 0,0,32,0 %;      !  Command reference number
macro MSCP$W_UNIT = 4,0,16,0 %;         !  Unit number
macro MSCP$V_EU_NO = 4,0,8,0 %;
literal MSCP$S_EU_NO = 8;               !  Emulated unit number
macro MSCP$V_EU_SUBU = 4,0,3,0 %;
literal MSCP$S_EU_SUBU = 3;             !  Old-style unit number
macro MSCP$V_EU_SUBC = 4,3,5,0 %;
literal MSCP$S_EU_SUBC = 5;             !  Old-style controller subtype
macro MSCP$V_EU_CTYPE = 4,8,4,0 %;
literal MSCP$S_EU_CTYPE = 4;            !  Emulated controller type
macro MSCP$V_EU_DESIG = 4,12,3,0 %;
literal MSCP$S_EU_DESIG = 3;            !  Emulated controller designator
macro MSCP$V_SHADOW = 4,15,1,0 %;       !  Shadow unit
macro MSCP$B_CNT_ALCS = 4,0,8,0 %;
macro MSCP$W_SEQ_NUM = 6,0,16,0 %;      !  Sequence number (LAST error log)
macro MSCP$B_OPCODE = 8,0,8,0 %;        !  MSCP operation code
macro MSCP$V_OP_ATTN = 8,6,1,0 %;       !  Attention message
macro MSCP$V_OP_END = 8,7,1,0 %;        !  End message
macro MSCP$W_MODIFIER = 10,0,16,0 %;    !  MSCP command modifiers
!  Generic MSCP Modifiers
macro MSCP$V_MD_SEREC = 10,8,1,0 %;     !    Suppress error recovery
macro MSCP$V_MD_SECOR = 10,9,1,0 %;     !    Suppress error correction
macro MSCP$V_MD_CLSEX = 10,13,1,0 %;    !    Clear serious exception
macro MSCP$V_MD_COMP = 10,14,1,0 %;     !    Compare
macro MSCP$V_MD_WRSEQ = 10,4,1,0 %;     !    Write shadow set 1 unit at a time
macro MSCP$V_MD_WBKVL = 10,5,1,0 %;     !    Write-back (volatile)
macro MSCP$V_MD_WBKNV = 10,6,1,0 %;     !    Write-back (non-volatile)
macro MSCP$V_MD_SSHDW = 10,7,1,0 %;     !    Suppress Shadowing
macro MSCP$V_MD_SCCHL = 10,10,1,0 %;    !    Suppress caching (low speed)
macro MSCP$V_MD_SCCHH = 10,11,1,0 %;    !    Suppress caching (high speed)
macro MSCP$V_MD_ERROR = 10,12,1,0 %;    !    Force error
macro MSCP$V_MD_EXPRS = 10,15,1,0 %;    !    Express request
macro MSCP$V_MD_REWND = 10,1,1,0 %;     !    Rewind
macro MSCP$V_MD_OBJCT = 10,2,1,0 %;     !    Object count
macro MSCP$V_MD_REVRS = 10,3,1,0 %;     !    Reverse
macro MSCP$V_MD_UNLOD = 10,4,1,0 %;     !    Unload
macro MSCP$V_MD_IMMED = 10,6,1,0 %;     !    Request immediate completion
macro MSCP$V_MD_DLEOT = 10,7,1,0 %;     !    Request detect LEOT
macro MSCP$V_MD_CDATL = 10,12,1,0 %;    !    Clear Cached Data Lost
macro MSCP$V_MD_SPNDW = 10,0,1,0 %;     !    Spin down
macro MSCP$V_MD_ALLCD = 10,1,1,0 %;     !    All class drivers
macro MSCP$V_MD_DSOLV = 10,4,1,0 %;     !    Disolve shadow set
macro MSCP$V_MD_FLENU = 10,0,1,0 %;     !    Flush entire unit
macro MSCP$V_MD_VOLTL = 10,1,1,0 %;     !    Flush volitile only
macro MSCP$V_MD_NXUNT = 10,0,1,0 %;     !    Next unit
macro MSCP$V_MD_RIP = 10,0,1,0 %;       !    Allow self-destruct (online only)
macro MSCP$V_MD_IGNMF = 10,1,1,0 %;     !    Ignore media format error (online only)
macro MSCP$V_MD_STWRP = 10,2,1,0 %;     !    Enable Set Write Protect
macro MSCP$V_MD_CLWBL = 10,3,1,0 %;     !    Clear Write-Back Data Lost
macro MSCP$V_MD_SHDSP = 10,4,1,0 %;     !    Shadow Unit Specified
macro MSCP$V_MD_EXCAC = 10,5,1,0 %;     !    Exclusive access
macro MSCP$V_MD_PRIMR = 10,0,1,0 %;     !    Primary replacement block
macro MSCP$V_MD_CRNPR = 10,0,1,0 %;     !     Connection Reference Number Present
macro MSCP$V_MD_ENRWR = 10,4,1,0 %;     !    Enable Re-Write Error Recovery (tapes)
macro MSCP$V_MD_TBC = 10,15,1,0 %;      !    To-be-continued (segmented tapes)
macro MSCP$V_MD_HISLO = 10,3,1,0 %;     !    History Log
macro MSCP$V_MD_SUPWL = 10,4,1,0 %;     !    Supplementary Write Log
macro MSCP$V_MD_REUSE = 10,7,1,0 %;     !    Reuse Entry
macro MSCP$V_MD_LOCSU = 10,0,1,0 %;     !    Local Source Unit
macro MSCP$V_MD_ESTCP = 10,1,1,0 %;     !    Establish Communications Paths 
macro MSCP$V_MD_RETCP = 10,2,1,0 %;     !    Retain Communications Paths
!  to keep the output compatible.
macro MSCP$B_FLAGS = 9,0,8,0 %;         !  End message flags
macro MSCP$V_EF_CPRET = 9,0,1,0 %;      !  Communication Paths Retained
macro MSCP$V_EF_DLS = 9,1,1,0 %;        !  Cached Data Lost (tapes only)
macro MSCP$V_EF_PLS = 9,2,1,0 %;        !  Position Lost (tapes only)
macro MSCP$V_EF_EOT = 9,3,1,0 %;        !  End of Tape Encountered (tapes only)
macro MSCP$V_EF_SEREX = 9,4,1,0 %;      !  Serious exception (tapes only)
macro MSCP$V_EF_ERLOG = 9,5,1,0 %;      !  Error log generated
macro MSCP$V_EF_BBLKU = 9,6,1,0 %;      !  Bad block unreported (disks only)
macro MSCP$V_EF_BBLKR = 9,7,1,0 %;      !  Bad block reported (disks only)
macro MSCP$V_EF_HISLO = 9,2,1,0 %;      !  History Logged
macro MSCP$V_EF_ALLOF = 9,3,1,0 %;      !  Allocation Failure
macro MSCP$W_STATUS = 10,0,16,0 %;      !  End message status
macro MSCP$V_ST_MASK = 10,0,5,0 %;
literal MSCP$S_ST_MASK = 5;             !  Status code bits
macro MSCP$V_ST_SBCOD = 10,5,11,0 %;
literal MSCP$S_ST_SBCOD = 11;           !  Subcode bits
!  Success Subcode Values
macro MSCP$V_SC_SDIGN = 10,5,1,0 %;     !  Spin Down IGNored
macro MSCP$V_SC_STCON = 10,6,1,0 %;     !  STill CONnected
macro MSCP$V_SC_DUPUN = 10,7,1,0 %;     !  DUPlicate UNit number
macro MSCP$V_SC_ALONL = 10,8,1,0 %;     !  ALready ONLine
macro MSCP$V_SC_STONL = 10,9,1,0 %;     !  STill ONLine
macro MSCP$V_SC_EOT = 10,10,1,0 %;      !  EOT encountered (tapes only)
macro MSCP$V_SC_INREP = 10,10,1,0 %;    !  INcomplete REPlacement (disks only)
macro MSCP$V_SC_IVRCT = 10,11,1,0 %;    !  InValid RCT (disks only)
macro MSCP$V_SC_RDONY = 10,12,1,0 %;    !  ReaD ONlY volume format
!  Invalid Command Subcode Values
macro MSCP$V_SC_NOVOL = 10,5,1,0 %;     !  NO VOLume mounted or drive disabled (RUN/STOP)
macro MSCP$V_SC_INOPR = 10,6,1,0 %;     !  unit is INOPeRative
macro MSCP$V_SC_UDSBL = 10,8,1,0 %;     !  Unit disabled by field service or diagnostic
macro MSCP$V_SC_EXUSE = 10,9,1,0 %;     !  Exclusive use
macro MSCP$V_SC_LDR = 10,10,1,0 %;      !  Loader cycle error
!  Unit-Available Subcode Values
macro MSCP$V_SC_CPYIP = 10,6,1,0 %;     !  Copy in progress
macro MSCP$V_SC_NOMEM = 10,7,1,0 %;     !  No members in shadow set
macro MSCP$V_SC_ALUSE = 10,10,1,0 %;    !  Already in use
!  Media Format Error Subcode Values
macro MSCP$V_SC_DATAL = 10,8,1,0 %;     !  Unit is DATA Loss write protected (data safety)
macro MSCP$V_SC_SOFTW = 10,12,1,0 %;    !  Unit is SOFTWare protected 
macro MSCP$V_SC_HARDW = 10,13,1,0 %;    !  Unit is HARDWare protected 
!  Data Error Subcode Values
macro MSCP$V_SC_ALLOF = 10,1,1,0 %;
macro MSCP$V_SC_TABFU = 10,2,1,0 %;
macro MSCP$V_SC_NOENT = 10,4,1,0 %;
!  Informational Event Subcode
literal MSCP$K_OP_ABORT = 1;            !  Abort
literal MSCP$K_OP_ACCES = 16;           !  Access
literal MSCP$K_OP_ACCNM = 5;            !  Access non-volatile memory
literal MSCP$K_OP_AVAIL = 8;            !  Available
literal MSCP$K_OP_CMPCD = 17;           !  Compare Controller Data
literal MSCP$K_OP_COMP = 32;            !  Compare Host Data
literal MSCP$K_OP_DSPLY = 6;            !  Display
literal MSCP$K_OP_DTACP = 11;           !  Determine Access Paths
literal MSCP$K_OP_DCD = 13;             !  Disk Copy Data
literal MSCP$K_OP_ERASE = 18;           !  Erase
literal MSCP$K_OP_ERGAP = 22;           !  Erase Gap (tapes only)
literal MSCP$K_OP_FLUSH = 19;           !  Flush
literal MSCP$K_OP_FMT = 24;             !  Format (as in floppy disks)
literal MSCP$K_OP_GTCMD = 2;            !  Get Command Status
literal MSCP$K_OP_GTUNM = 7;            !  Get Unit Name
literal MSCP$K_OP_GTUNT = 3;            !  Get Unit Status
literal MSCP$K_OP_GTLDR = 7;            !  Get Loader Status
literal MSCP$K_OP_MOVE = 12;            !  Move Media
literal MSCP$K_OP_ONLIN = 9;            !  Online
literal MSCP$K_OP_RCEDC = 35;           !  Read Controller Encryption/Decryption Code
literal MSCP$K_OP_READ = 33;            !  Read
literal MSCP$K_OP_REPLC = 20;           !  Replace
literal MSCP$K_OP_REPOS = 37;           !  Reposition (tapes only)
literal MSCP$K_OP_STCON = 4;            !  Set Controller Characteristics
literal MSCP$K_OP_STUNT = 10;           !  Set Unit Characteristics
literal MSCP$K_OP_TERCO = 48;           !  Terminate Class Driver/Server Connection
literal MSCP$K_OP_WRITE = 34;           !  Write
literal MSCP$K_OP_WRITM = 36;           !  Write Tape Mark
literal MSCP$K_OP_WRHIM = 25;           !  Write History Management
!  MSCP End Message Codes
literal MSCP$K_OP_END = 128;            !  End Message Flag
!  MSCP Attention Message Codes (listed in alphabetical order)
literal MSCP$K_OP_ACPTH = 66;           !  Access Path
literal MSCP$K_OP_AVATN = 64;           !  Available
literal MSCP$K_OP_DUPUN = 65;           !  Duplicate Unit Number
literal MSCP$M_SLUN = %X'4000';
literal MSCP$K_SLUN_RSVP = 32767;       !  SLUN to request unit number for this controller
literal MSCP$S_GENERIC_MSCP = 14;
!  MSCP Command Operation Codes (defined in alphabetical order)
macro MSCP$V_SLUN = 12,14,1,0 %;        !  Server Local Unit Number flag
!  Aggregates MSCP_MODIFIERS and MSCP_SUBCODES have been 
!  incorporated into the GENERIC_MSCP aggregate.
!  Definitions for MSCP Transfer Commands
! 
!  Also the FORMAT command, which includes a                            
!  buffer descriptor just like transfer commands.
literal MSCP$K_FMT_DFLT = 0;            ! 	device's default
literal MSCP$K_FMT_SING = 1;            ! 	single density
literal MSCP$K_FMT_DOUB = 2;            ! 	double density
literal MSCP$K_FMT_RX33 = 282;          ! 	RX33 - ISO DIS8630-1985
literal MSCP$S_TRANSFER_COMMANDS = 52;
macro MSCP$L_BYTE_CNT = 12,0,32,0 %;    !  Byte count
macro MSCP$B_BUFFER = 16,0,0,0 %;
literal MSCP$S_BUFFER = 12;             !  Buffer descriptor
macro MSCP$L_LBN = 28,0,32,0 %;         !    Logical block number
macro MSCP$L_FRST_BAD = 28,0,32,0 %;    !    First bad block
macro MSCP$L_FMT_FUNC = 28,0,32,0 %;    !    Format function
macro MSCP$L_KEY_ID = 32,0,32,0 %;      !  Key identifier
macro MSCP$L_KEY_LGH = 36,0,32,0 %;     !  Key length
macro MSCP$L_KEY_BUF = 40,0,0,0 %;
literal MSCP$S_KEY_BUF = 12;            !  Key buffer descriptor
macro MSCP$L_POSITION = 28,0,32,0 %;    !  Position (object count)
macro MSCP$L_TAPEREC = 32,0,32,0 %;     !  Tape record byte count
!  Definitions for Abort and Get Command Status Commands and End Messages
literal MSCP$S_ABORT_GTCMD = 20;
macro MSCP$L_OUT_REF = 12,0,32,0 %;     !  Outstanding reference number
macro MSCP$L_CMD_STS = 16,0,32,0 %;     !  Command status
!  Definitions for the Access Non-Volatile Memory Command and End Message
literal MSCP$K_ANM_READ = 0;
literal MSCP$K_ANM_EXCG = 1;
literal MSCP$K_ANM_TSST = 2;
literal MSCP$S_ACCNM = 56;
macro MSCP$L_ANM_SIZE = 12,0,32,0 %;    !  Non-Volatile Memory Size
macro MSCP$L_ANM_OFFS = 16,0,32,0 %;    !  Offset into Non-Volatile Memory
macro MSCP$W_ANM_OPER = 20,0,16,0 %;    !  Non-Volatile Memory Access Operation
macro MSCP$W_ANM_DLGH = 22,0,16,0 %;    !  Data Length
macro MSCP$T_ANM_MEMD = 24,0,0,0 %;
literal MSCP$S_ANM_MEMD = 32;           !  Memory Data
!  Definitions for Display Command and End Message
literal MSCP$S_DISPLAY_CMD = 32;
macro MSCP$W_DITEM = 12,0,16,0 %;       !  Item code
macro MSCP$W_DMODE = 14,0,16,0 %;       !  Mode
macro MSCP$T_DTEXT = 16,0,0,0 %;
literal MSCP$S_DTEXT = 16;              !  Display text
!  Definitions for the Get Unit Status Command and End Message
literal MSCP$M_UF_CMPRD = %X'1';
literal MSCP$M_UF_CMPWR = %X'2';
literal MSCP$M_UF_WBKNV = %X'40';
literal MSCP$M_UF_WRTPD = %X'100';
literal MSCP$M_UF_EXACC = %X'400';
literal MSCP$M_UF_SCCHH = %X'800';
literal MSCP$M_UF_WRTPS = %X'1000';
literal MSCP$M_UF_WRTPH = %X'2000';
literal MSCP$M_UF_576 = %X'4';
literal MSCP$M_UF_WHL = %X'8';
literal MSCP$M_UF_RMVBL = %X'80';
literal MSCP$M_UF_SSMST = %X'200';
literal MSCP$M_UF_SSMEM = %X'4000';
literal MSCP$M_UF_REPLC = %X'8000';
literal MSCP$M_UF_CACFL = %X'4';
literal MSCP$M_UF_EWRER = %X'8';
literal MSCP$M_UF_VARSP = %X'10';
literal MSCP$M_UF_VSMSU = %X'20';
literal MSCP$M_UF_LOADR = %X'200';
literal MSCP$M_UF_CACH = %X'8000';
literal MSCP$M_SLUN_C = %X'1F';
literal MSCP$M_SLUN_D1 = %X'3E0';
literal MSCP$M_SLUN_D0 = %X'7C00';
literal MSCP$M_MTYP_N = %X'7F';
literal MSCP$M_MTYP_A2 = %X'F80';
literal MSCP$M_MTYP_A1 = %X'1F000';
literal MSCP$M_MTYP_A0 = %X'3E0000';
literal MSCP$M_MTYP_D1 = %X'7C00000';
literal MSCP$M_MTYP_D0 = %X'F8000000';
literal MSCP$K_CM_NOCPY = 0;
literal MSCP$K_CM_COPY = 1;
literal MSCP$K_CM_MGCPY = 2;
literal MSCP$K_CM_MMRG = 3;
literal MSCP$M_TF_800 = %X'1';
literal MSCP$M_TF_PE = %X'2';
literal MSCP$M_TF_GCR = %X'4';
literal MSCP$M_TF_BLK = %X'8';
literal MSCP$M_TF_NOR = %X'1';
literal MSCP$M_TF_BHD = %X'2';
literal MSCP$M_TF_DN2 = %X'4';
literal MSCP$M_TF_DN3 = %X'8';
literal MSCP$M_TF_T87 = %X'10';
literal MSCP$M_TF_T87C = %X'20';
literal MSCP$M_TF_ENH = %X'2';
literal MSCP$M_TF_NDC = %X'4';
literal MSCP$M_TF_EDC = %X'8';
literal MSCP$M_TF_DCP = %X'2';
literal MSCP$M_TF_X82 = %X'1';
literal MSCP$M_TF_X85 = %X'2';
literal MSCP$M_TF_X5C = %X'4';
literal MSCP$K_TC_OLD = 0;
literal MSCP$K_TC_9TR = 256;
literal MSCP$K_TC_CTP = 512;
literal MSCP$K_TC_HPC = 768;
literal MSCP$K_TC_WOD = 1024;
literal MSCP$K_TC_DAT = 1280;
literal MSCP$K_TC_8MM = 1536;
literal MSCP$K_TC_QIC = 1792;
literal MSCP$M_TF_MASK = 255;           !  Density field mask
literal MSCP$K_TF_CODE = 256;           !  Format code multiplier
literal MSCP$S_ONLIN_STUNT = 44;        !  DISK_TAPE was previously contained in aggregate
!  ONLIN_STUNT.  Although,the aggregate was deleted,
literal MSCP$S_GTUNT = 50;
macro MSCP$W_MULT_UNT = 12,0,16,0 %;    !  Multi-unit code
macro MSCP$W_UNT_FLGS = 14,0,16,0 %;    !  Unit flags
macro MSCP$V_UF_CMPRD = 14,0,1,0 %;     !    Compare reads 
macro MSCP$V_UF_CMPWR = 14,1,1,0 %;     !    Compare writes 
macro MSCP$V_UF_WBKNV = 14,6,1,0 %;     !    Write-back (non-volatile) [disks only]
macro MSCP$V_UF_WRTPD = 14,8,1,0 %;     !    Write protect (data safety)
macro MSCP$V_UF_EXACC = 14,10,1,0 %;    !    Exclusive access
macro MSCP$V_UF_SCCHH = 14,11,1,0 %;    !    Suppress caching (High speed) 
macro MSCP$V_UF_WRTPS = 14,12,1,0 %;    !    Write protect (software) 
macro MSCP$V_UF_WRTPH = 14,13,1,0 %;    !    Write protect (hardware)
macro MSCP$V_UF_576 = 14,2,1,0 %;       !    576 byte sectors
macro MSCP$V_UF_WHL = 14,3,1,0 %;       !    Write History Logging Support 
macro MSCP$V_UF_RMVBL = 14,7,1,0 %;     !    Removeable media
macro MSCP$V_UF_SSMST = 14,9,1,0 %;     !    Shadow set master
macro MSCP$V_UF_SSMEM = 14,14,1,0 %;    !    Shadow set member
macro MSCP$V_UF_REPLC = 14,15,1,0 %;    !    Controller initiated bad block replacement
macro MSCP$V_UF_CACFL = 14,2,1,0 %;     !    Cache flushed
macro MSCP$V_UF_EWRER = 14,3,1,0 %;     !    Enhanced Write Error Recovery
macro MSCP$V_UF_VARSP = 14,4,1,0 %;     !    Variable speed unit
macro MSCP$V_UF_VSMSU = 14,5,1,0 %;     !    Variable speed mode suppression
macro MSCP$V_UF_LOADR = 14,9,1,0 %;     !    Media Loader Present
macro MSCP$V_UF_CACH = 14,15,1,0 %;     !    Write-back Caching
macro MSCP$Q_UNIT_ID = 20,0,0,0 %;
literal MSCP$S_UNIT_ID = 8;             !  Unit identifier
macro MSCP$L_EXCL_LBA = 20,0,32,1 %;    !  Excluded LBN area address [disks only]
macro MSCP$L_EXCL_LBC = 24,0,32,0 %;    !  Excluded LBN block count [disks only]
macro MSCP$L_SLUN_ALLOCLS = 20,0,32,0 %;
macro MSCP$W_SLUN_UNIT = 24,0,16,0 %;
macro MSCP$W_SLUN_DEVNAME = 26,0,16,0 %;
macro MSCP$V_SLUN_C = 26,0,5,0 %;
literal MSCP$S_SLUN_C = 5;
macro MSCP$V_SLUN_D1 = 26,5,5,0 %;
literal MSCP$S_SLUN_D1 = 5;
macro MSCP$V_SLUN_D0 = 26,10,5,0 %;
literal MSCP$S_SLUN_D0 = 5;
macro MSCP$L_DEV_PARM = 28,0,32,0 %;    !  Device dependent parameters
macro MSCP$L_MEDIA_ID = 28,0,32,0 %;    !  Media type identifier
macro MSCP$V_MTYP_N = 28,0,7,0 %;
literal MSCP$S_MTYP_N = 7;              !    Media # (i.e. 7 of RK07)
macro MSCP$V_MTYP_A2 = 28,7,5,0 %;
literal MSCP$S_MTYP_A2 = 5;             !    Media name char.
macro MSCP$V_MTYP_A1 = 28,12,5,0 %;
literal MSCP$S_MTYP_A1 = 5;             !    Media name continued
macro MSCP$V_MTYP_A0 = 28,17,5,0 %;
literal MSCP$S_MTYP_A0 = 5;             !      "    "      "
macro MSCP$V_MTYP_D1 = 28,22,5,0 %;
literal MSCP$S_MTYP_D1 = 5;             !    Dev mnemonic char.
macro MSCP$V_MTYP_D0 = 28,27,5,0 %;
literal MSCP$S_MTYP_D0 = 5;             !    Mnemonic continued
macro MSCP$W_SHDW_UNT = 32,0,16,0 %;    !  Shadow unit
macro MSCP$W_COPY_MOD = 34,0,16,0 %;    !  Copy mode
macro MSCP$W_SHDW_STS = 34,0,16,0 %;    !  Shadow unit status
macro MSCP$W_FORMAT = 32,0,16,0 %;      !  Original (Old) format
macro MSCP$V_TF_800 = 32,0,1,0 %;       !   NRZI 800 bpi
macro MSCP$V_TF_PE = 32,1,1,0 %;        !   Phase encoded 1600 bpi
macro MSCP$V_TF_GCR = 32,2,1,0 %;       !   Group code recording 6250 bpi
macro MSCP$V_TF_BLK = 32,3,1,0 %;       !   Block format (TK50)
macro MSCP$V_TF_NOR = 32,0,1,0 %;       !   Normal (low) density (833 bpi TK50)
macro MSCP$V_TF_BHD = 32,1,1,0 %;       !   Block mode High Density (1250 bpi TK70)
macro MSCP$V_TF_DN2 = 32,2,1,0 %;       !   Block mode Density 2 (TF85 compatible)
macro MSCP$V_TF_DN3 = 32,3,1,0 %;       !   Block mode Density 3 (TF86 compatible)
macro MSCP$V_TF_T87 = 32,4,1,0 %;       !   Tx87 compatible
macro MSCP$V_TF_T87C = 32,5,1,0 %;      !   Tx87 compatible compressed
macro MSCP$V_TF_ENH = 32,1,1,0 %;       !   Enhanced density
macro MSCP$V_TF_NDC = 32,2,1,0 %;       !   NOR with data comp.
macro MSCP$V_TF_EDC = 32,3,1,0 %;       !   ENH with data comp.
macro MSCP$V_TF_DCP = 32,1,1,0 %;       !  DAT compacted density
macro MSCP$V_TF_X82 = 32,0,1,0 %;       !   EXABYTE-8200 Compatible Density
macro MSCP$V_TF_X85 = 32,1,1,0 %;       !   EXABYTE-8500 Compatible Density
macro MSCP$V_TF_X5C = 32,2,1,0 %;       !   EXABYTE-8500 Compacted Density
macro MSCP$W_SPEED = 34,0,16,0 %;       !  Speed
macro MSCP$W_TRACK = 36,0,16,0 %;       !  Track size
macro MSCP$W_GROUP = 38,0,16,0 %;       !  Group size
macro MSCP$W_CYLINDER = 40,0,16,0 %;    !  Cylinder size
macro MSCP$B_UNIT_SVR = 42,0,8,0 %;     !  Unit software version
macro MSCP$B_UNIT_HVR = 43,0,8,0 %;     !  Unit hardware version
macro MSCP$W_RCT_SIZE = 44,0,16,0 %;    !  RCT size
macro MSCP$B_RBNS = 46,0,8,0 %;         !  RBNs per track
macro MSCP$B_RCT_CPYS = 47,0,8,0 %;     !  Number of RCT copies
macro MSCP$W_LOAD_AVAIL = 48,0,16,0 %;  !  Controller load available (VMS server load balancing)
macro MSCP$W_FORMENU = 36,0,16,0 %;     !  Format menu
macro MSCP$B_FREECAP = 38,0,8,0 %;      !  Free capacity
!  Definitions for Online and Set Unit Characteristics Command and End Messages
macro MSCP$L_UNT_SIZE = 36,0,32,0 %;    !  Unit size
macro MSCP$L_VOL_SER = 40,0,32,0 %;     !  Volume serial number
macro MSCP$L_MAXWTREC = 36,0,32,0 %;    !  Maximum write record size
macro MSCP$W_NOISEREC = 40,0,16,0 %;    !  Noise record
!  we still have to generate the size field.
!  Definitions for the Read Controller Encrypt/Decrypt Code Command and End Message
literal MSCP$S_RCEDC = 36;
macro MSCP$L_CODE = 32,0,32,0 %;        !  Encrypt/Decrypt Code Length
!  Definitions for the Replace Command and End Message (disks only)
literal MSCP$S_REPLC = 16;
macro MSCP$L_RBN = 12,0,32,0 %;         !  Replacement block number
!  Definitions for the Reposition Command and End Message (tapes only)
literal MSCP$S_REPOS = 20;
macro MSCP$L_REC_CNT = 12,0,32,0 %;     !  Record/Object count
macro MSCP$L_TMGP_CNT = 16,0,32,0 %;    !  Tape mark count
macro MSCP$L_RCSKIPED = 12,0,32,0 %;    !  Records skipped
macro MSCP$L_TMSKIPED = 16,0,32,0 %;    !  Tape markes skipped
!  Definitions for the Set Controller Characteristics Command and End Message
literal MSCP$M_CF_576 = %X'1';
literal MSCP$M_CF_SHADW = %X'2';
literal MSCP$M_CF_MLTHS = %X'4';
literal MSCP$M_CF_LDCD = %X'8';
literal MSCP$M_CF_THIS = %X'10';
literal MSCP$M_CF_OTHER = %X'20';
literal MSCP$M_CF_MISC = %X'40';
literal MSCP$M_CF_ATTN = %X'80';
literal MSCP$M_CF_RDCD = %X'100';
literal MSCP$M_CF_WHL = %X'200';
literal MSCP$M_CF_RDO = %X'400';
literal MSCP$M_CF_LOAD = %X'2000';
literal MSCP$M_CF_EDCRP = %X'4000';
literal MSCP$M_CF_REPLC = %X'8000';
literal MSCP$M_CF_SRT = %X'8000';
literal MSCP$K_CL_CNTRL = 1;
literal MSCP$K_CL_DISK = 2;
literal MSCP$K_CL_TAPE = 3;
literal MSCP$K_CL_D144 = 4;
literal MSCP$K_CL_LDR = 5;
!   MSCP Controller Model
literal MSCP$K_CM_HSC50 = 1;
literal MSCP$K_CM_UDA50 = 2;
literal MSCP$K_CM_RC25 = 3;
literal MSCP$K_CM_EMULA = 4;
literal MSCP$K_CM_TU81 = 5;
literal MSCP$K_CM_UDA52 = 6;
literal MSCP$K_CM_UDA50A = 6;
literal MSCP$K_CM_RDRX = 7;
literal MSCP$K_CM_TOPS = 8;
literal MSCP$K_CM_TK50 = 9;
literal MSCP$K_CM_TQK50 = 9;
literal MSCP$K_CM_RUX50 = 10;
literal MSCP$K_CM_AIO = 12;
literal MSCP$K_CM_KFBTA = 12;
literal MSCP$K_CM_KDA50 = 13;
literal MSCP$K_CM_TK70 = 14;
literal MSCP$K_CM_TQK70 = 14;
literal MSCP$K_CM_RV20 = 15;
literal MSCP$K_CM_RRD50 = 16;
literal MSCP$K_CM_RRD50Q = 16;
literal MSCP$K_CM_KDB50 = 18;
literal MSCP$K_CM_RQDX3 = 19;
literal MSCP$K_CM_RQDX4 = 20;
literal MSCP$K_CM_DSSI_DISK = 21;
literal MSCP$K_CM_DSSI_TAPE = 22;
literal MSCP$K_CM_DSSI_DSKTAP = 23;
literal MSCP$K_CM_DSSI_OTHER = 24;
literal MSCP$K_CM_TUK50 = 25;
literal MSCP$K_CM_RRD50U = 26;
literal MSCP$K_CM_KDM70 = 27;
literal MSCP$K_CM_TQL70 = 28;
literal MSCP$K_CM_TM32 = 29;
literal MSCP$K_CM_HSC70 = 32;
literal MSCP$K_CM_HSC40 = 33;
literal MSCP$K_CM_HSC60 = 34;
literal MSCP$K_CM_HSC90 = 35;
literal MSCP$K_CM_RN20 = 36;
literal MSCP$K_CM_ENE10 = 37;
literal MSCP$K_CM_TN10 = 38;
literal MSCP$K_CM_HSJ40 = 40;
literal MSCP$K_CM_HSC65 = 41;
literal MSCP$K_CM_HSC95 = 42;
literal MSCP$K_CM_KSB50 = 64;
literal MSCP$K_CM_TK50_DEBNT = 65;
literal MSCP$K_CM_TBK70 = 66;
literal MSCP$K_CM_TBK7L = 68;
literal MSCP$K_CM_RF30 = 96;
literal MSCP$K_CM_RF71 = 97;
literal MSCP$K_CM_TF85 = 98;
literal MSCP$K_CM_TF70 = 99;
literal MSCP$K_CM_RF31 = 100;
literal MSCP$K_CM_RF72 = 101;
literal MSCP$K_CM_RF73 = 102;
literal MSCP$K_CM_RF32 = 103;
literal MSCP$K_CM_RF35 = 104;
literal MSCP$K_CM_RF36 = 108;
literal MSCP$K_CM_RF74 = 109;
literal MSCP$K_CM_TF86 = 110;
literal MSCP$K_CM_HSD20 = 111;
literal MSCP$K_CM_RF75 = 112;
literal MSCP$K_CM_RF37 = 114;
literal MSCP$K_CM_HSX50 = 128;
literal MSCP$K_CM_ULTRIX = 248;
literal MSCP$K_CM_SVS = 249;
literal MSCP$S_STCON = 34;
!  Allocation class (CNT_ALCS) is now part of union
!  with UNIT structure in MSCP_BASIC_PKT
macro MSCP$W_VERSION = 12,0,16,0 %;     !  MSCP version
macro MSCP$W_CNT_FLGS = 14,0,16,0 %;    !  Controller flags
macro MSCP$V_CF_576 = 14,0,1,0 %;       !    576 byte sectors [disks only]
macro MSCP$V_CF_SHADW = 14,1,1,0 %;     !    Shadowing [disks only]
macro MSCP$V_CF_MLTHS = 14,2,1,0 %;     !    Multi-Host
macro MSCP$V_CF_LDCD = 14,3,1,0 %;      !    Local Disk Copy Data
macro MSCP$V_CF_THIS = 14,4,1,0 %;      !    Enable this host's error log
macro MSCP$V_CF_OTHER = 14,5,1,0 %;     !    Enable other host's error log
macro MSCP$V_CF_MISC = 14,6,1,0 %;      !    Enable miscellaneous error log
macro MSCP$V_CF_ATTN = 14,7,1,0 %;      !    Enable attention messages
macro MSCP$V_CF_RDCD = 14,8,1,0 %;      !    Remote Disk Copy Data
macro MSCP$V_CF_WHL = 14,9,1,0 %;       !    Write History Logging Support
macro MSCP$V_CF_RDO = 14,10,1,0 %;      !    Restricted DISK COPY DATA Operations
macro MSCP$V_CF_LOAD = 14,13,1,0 %;     !    Controller returns load available information
macro MSCP$V_CF_EDCRP = 14,14,1,0 %;    !    Data Encrypt/Decrypt Supported
macro MSCP$V_CF_REPLC = 14,15,1,0 %;    !    Controller Initiated Bad Block Replacement [disks only]
macro MSCP$V_CF_SRT = 14,15,1,0 %;      !     Segemented Record Transfer
macro MSCP$W_HST_TMO = 16,0,16,0 %;     !  Host timeout
macro MSCP$W_CNT_TMO = 16,0,16,0 %;     !  Controller timeout
macro MSCP$B_CNT_SVR = 18,0,8,0 %;      !  Controller software version
macro MSCP$B_CNT_HVR = 19,0,8,0 %;      !  Controller hardware version
macro MSCP$Q_TIME = 20,0,0,0 %;
literal MSCP$S_TIME = 8;                !  Quad-word date-time
macro MSCP$Q_CNT_ID = 20,0,0,0 %;
literal MSCP$S_CNT_ID = 8;              !  Controller ID
macro MSCP$L_MAXBCNT = 28,0,32,0 %;     !  Maximum supported byte count
macro MSCP$W_CONN_REF = 32,0,16,0 %;    !  Connection reference number
!   Controller and Unit identifier Classes. (Device Class)
!  Definitions for Disk Data Copy Commands and End Messages
literal MSCP$K_MIN_SIZ = 12;            !  Shortest Command
literal MSCP$C_MIN_SIZ = 12;            !  Shortest Command
literal MSCP$K_MXCMDLEN = 36;           !  Longest Command
literal MSCP$C_MXCMDLEN = 36;           !  Longest Command
literal MSCP$K_DCDCMDLEN = 60;          !  DCD Command
literal MSCP$C_DCDCMDLEN = 60;          !  DCD Command
literal MSCP$K_LEN = 50;                !  Longest End Message
literal MSCP$C_LEN = 50;                !  Longest End Message
literal MSCP$S_DCD = 60;
macro MSCP$L_LBCOUNT = 12,0,32,0 %;     !  Logical block count
macro MSCP$W_SRC_UNUM = 16,0,16,0 %;    !  Source unit number
macro MSCP$Q_SRC_UID = 20,0,0,0 %;
literal MSCP$S_SRC_UID = 8;             !  Source unit identifier
macro MSCP$L_DEST_LBN = 28,0,32,0 %;    !  Destination LBN
macro MSCP$W_HRN = 32,0,16,0 %;         !  HRN or Entloc
macro MSCP$W_ENT_ID = 34,0,16,0 %;      !  Entry ID
macro MSCP$L_SRC_LBN = 40,0,32,0 %;     !  Source LBN
macro MSCP$Q_PORT_ADR = 44,0,0,0 %;
literal MSCP$S_PORT_ADR = 8;            !  Source unit's subsystem port address
macro MSCP$Q_SYS_ADR = 52,0,0,0 %;
literal MSCP$S_SYS_ADR = 8;             !  Source unit's subsystem system address
macro MSCP$Z_SBC_STS = 16,0,0,0 %;
literal MSCP$S_SBC_STS = 16;            !  Subcommand status
macro MSCP$W_ENT_LOC = 32,0,16,0 %;     !  Entry locator
!  Definitions for Write History Management Commands and End Messages
literal MSCP$K_WHM_DALL = 1;
literal MSCP$K_WHM_DHRN = 2;
literal MSCP$K_WHM_DELO = 3;
literal MSCP$K_WHM_RALL = 4;
literal MSCP$K_WHM_RHRN = 5;
literal MSCP$K_WHM_DAFC = 6;
literal MSCP$S_WRHIM = 32;
macro MSCP$B_WRHIS_BD = 16,0,0,0 %;
literal MSCP$S_WRHIS_BD = 12;           !  Write history buffer descriptor
macro MSCP$W_UNIT_AL = 16,0,16,0 %;     !  Unit allocated
macro MSCP$W_SERV_AL = 18,0,16,0 %;     !  Server allocated
macro MSCP$W_SERV_UNAL = 20,0,16,0 %;   !  Server unallocated
macro MSCP$W_OPER = 28,0,16,0 %;        !  Operation
macro MSCP$W_COUNT = 28,0,16,0 %;       !  Count
macro MSCP$W_OFFSET = 30,0,16,0 %;      !  Offset
!  Definitions for Write History Entry
literal WHIS$M_ET_TLIB = %X'4000';
literal WHIS$M_ET_ERR = %X'8000';
literal WHIS$K_WRITELOGLEN = 16;        !  Write log length
literal WHIS$C_WRITELOGLEN = 16;        ! 
literal WHIS$S_WRITE_LOG_ENTRY = 16;
macro WHIS$W_ELO = 0,0,16,0 %;          !  Entry Locator
macro WHIS$W_UNIT = 2,0,16,0 %;         !  Unit Number
macro WHIS$L_LENGTH = 4,0,32,0 %;       !  Transfer Length
macro WHIS$L_LBN = 8,0,32,0 %;          !  Starting Logical Block Number
macro WHIS$W_HRN = 12,0,16,0 %;         !  Host Reference Number
macro WHIS$W_ENTFLGS = 14,0,16,0 %;     !  Entry Flags
macro WHIS$V_ET_TLIB = 14,14,1,0 %;
macro WHIS$V_ET_ERR = 14,15,1,0 %;
!  Definitions for GET UNIT NAME command and end message
literal MSCP$S_GET_UNIT_NAME = 44;
macro MSCP$L_DDR_NAMELEN = 12,0,32,0 %; !  Length of dynamic name
macro MSCP$T_DDR_NAME = 16,0,0,0 %;
literal MSCP$S_DDR_NAME = 28;           !  Dynamic name string
 
!*** MODULE $MVLDEF ***
! +
!  MAGNETIC TAPE VOLUME LIST
!  THIS STRUCTURE DESCRIBES THE VOLUMES IN A VOLUME SET
! -
literal MVL$K_FIXLEN = 36;              ! LENGTH OF FIXED AREA OF STRUCTURE 
literal MVL$C_FIXLEN = 36;              ! LENGTH OF FIXED AREA OF STRUCTURE 
literal MVL$S_MVLDEF = 36;
literal MVL$S_MVL = 36;
macro MVL$L_VCB = 0,0,32,1 %;           ! ADDRESS OF VCB 
macro MVL$W_SIZE = 8,0,16,0 %;          ! SIZE OF STRUCTURE 
macro MVL$B_TYPE = 10,0,8,0 %;          ! TYPE OF STRUCTURE 
macro MVL$B_NVOLS = 11,0,8,0 %;         ! NUMBER OF VOLUMES IN VOLUME SET 
macro MVL$T_SET_ID = 12,0,0,0 %;
literal MVL$S_SET_ID = 6;               ! FILE SET ID FOR THE VOLUME SET 
macro MVL$B_VOL_ACC = 18,0,8,0 %;       ! VOLUME ACCESSIBILTY CHARACTER DEFAULT 
macro MVL$B_MOU_PRV = 19,0,8,0 %;       ! USER'S MOUNT TIME PRIVILEGES 
macro MVL$V_VOLPRO = 19,0,1,0 %;        ! VOLPRO PRIVILEGE 
macro MVL$V_OVRPRO = 19,1,1,0 %;        ! OVERRIDE PRIVILEGE (BYPASS,SYSPRV,VOLPRO) 
macro MVL$V_OPER = 19,2,1,0 %;          ! OPER PRIVILEDGE
macro MVL$T_VOLOWNER = 20,0,0,0 %;
literal MVL$S_VOLOWNER = 14;            !  VOL1 ONER IDENTIFIER  FIELD
macro MVL$B_STDVER = 34,0,8,0 %;        !  ANSI VERSION OF VOLUME SET
!  THE FOLLOWING STRUCTURE IN REPEATED IN MVL FOR EACH REEL IN VOLUME SET
literal MVL$K_LENGTH = 8;               ! LENGTH OF STRUCTURE 
literal MVL$C_LENGTH = 8;               ! LENGTH OF STRUCTURE 
literal MVL$S_MVLDEF1 = 8;
literal MVL$S_MVL1 = 8;
macro MVL$T_VOLLBL = 0,0,0,0 %;
literal MVL$S_VOLLBL = 6;               ! VOLUME LABEL 
macro MVL$B_RVN = 6,0,8,0 %;            ! RELATIVE UNIT NUMBER 
macro MVL$B_STATUS = 7,0,8,0 %;         ! STATUS OF VOLUME 
macro MVL$V_MOUNTED = 7,0,1,0 %;        ! REEL IS MOUNTED 
macro MVL$V_UNUSED = 7,1,1,0 %;         ! IS THIS ENTRY IN USE 
macro MVL$V_OVERIDE = 7,2,1,0 %;        ! CAN OVERRIDE PROTECTION ON THIS REEL 
 
!*** MODULE $MVMSLDEF ***
! ++
!   $MVMSLDEF - mount verification messages list structure definition
! 
! 	The MVMSL provides a mechanism for communicating information about 
! 	mount verification messages to device driver special mount 
! 	verification processing routines.
! --
literal MVMSL$M_NOSUFFIX = %X'1';
literal MVMSL$M_SUPRESS = %X'2';
literal MVMSL$K_LENGTH = 8;             !  Length of a MVMSL entry.
literal MVMSL$S_MVMSLDEF = 13;
literal MVMSL$S_MVMSL = 13;
macro MVMSL$B_MAXIDX = -5,0,8,0 %;      !  Maximum legal MVMSL index.
macro MVMSL$L_SNDMSGOFF = -4,0,32,1 %;  !  Offset from MVMSL base to SEND_MESSAGE routine
macro MVMSL$W_MSG_CODE = 0,0,16,0 %;    !  The MSG$_ code for this entry.
macro MVMSL$W_FLAGS = 2,0,16,0 %;       !  Processing flags:
macro MVMSL$V_NOSUFFIX = 2,0,1,0 %;     ! 	Do not add suffix.
macro MVMSL$V_SUPRESS = 2,1,1,0 %;      ! 	May be suppressed.
macro MVMSL$L_TEXTOFF = 4,0,32,1 %;     !  Offset from MVMSL base to ASCIC message text.
 
!*** MODULE $NAFDEF ***
! ++
! 
!  Structure for network proxy login file, NETUAF.DAT (VMS version 4.x)
! 
! --
literal NAF$M_TASK = %X'1';
literal NAF$M_BATCH = %X'2';
literal NAF$M_INTERACTIVE = %X'4';
literal NAF$K_LENGTH = 100;             !  Length of record 
literal NAF$C_LENGTH = 100;             !  Length of record 
literal NAF$S_NAFDEF = 100;
literal NAF$S_NAF = 100;
macro NAF$T_REMNAME = 0,0,0,0 %;
literal NAF$S_REMNAME = 64;             !  Combined nodename and remote username 
macro NAF$T_NODE = 0,0,0,0 %;
literal NAF$S_NODE = 32;                !  Node name 
macro NAF$T_REMUSER = 32,0,0,0 %;
literal NAF$S_REMUSER = 32;             !  Remote username 
macro NAF$T_LOCALUSER = 64,0,0,0 %;
literal NAF$S_LOCALUSER = 32;           !  Local username 
macro NAF$L_FLAGS = 96,0,32,1 %;        !  Flags longword
macro NAF$V_TASK = 96,0,1,0 %;          !  Allow task=0 access
macro NAF$V_BATCH = 96,1,1,0 %;         !  Allow batch jobs
macro NAF$V_INTERACTIVE = 96,2,1,0 %;   !  Allow interactive login
 
!*** MODULE $NAFV5DEF ***
! ++
! 
!  Structure for network proxy login file, NETPROXY.DAT
! 
! --
literal NAFV5$C_PROXY_FIXEDLEN = 4;
literal NAFV5$K_PROXY_FIXEDLEN = 4;
literal NAFV5$C_DEFPROXY = 1;           !  Default proxy account
literal NAFV5$C_PROXY = 2;              !  NONdefault proxy account
literal NAFV5$C_MAXPROXY = 15;          !  Max number of proxy accounts
literal NAFV5$K_MAXPROXY = 15;          !  Max number of proxy accounts
literal NAFV5$C_MAXPROXYLEN = 32;       !  Max length of proxy string
literal NAFV5$K_MAXPROXYLEN = 32;       !  Max length of proxy string
literal NAFV5$S_NAFV5PROXY = 4;
macro NAFV5$W_PROXYLEN = 0,0,16,0 %;    !  String length
macro NAFV5$W_TYPE = 2,0,16,0 %;        !  Type field
macro NAFV5$T_PROXY = 4,0,0,0 %;        !  Local proxy account name
literal NAFV5$M_TASK = %X'1';
literal NAFV5$M_BATCH = %X'2';
literal NAFV5$M_INTERACTIVE = %X'4';
literal NAFV5$M_UIC = %X'8';
literal NAFV5$K_FIXEDLEN = 76;          !  Length of fixed part of record 
literal NAFV5$C_FIXEDLEN = 76;          !  Length of fixed part of record 
literal NAFV5$C_FORMAT1 = 1;            !  format version #
literal NAFV5$K_FORMAT1 = 1;            !  format version #
!  Define the max record size
literal NAFV5$C_MAXREC = 656;
literal NAFV5$K_MAXREC = 656;
literal NAFV5$S_NAFV5DEF = 76;          !  Old size name - synonym
literal NAFV5$S_NAFV5 = 76;
macro NAFV5$W_FORMAT = 0,0,16,0 %;      !  Record format version
macro NAFV5$W_RECLEN = 2,0,16,0 %;      !  Record length
macro NAFV5$W_NODELEN = 4,0,16,0 %;     !  Length of remote node string
macro NAFV5$W_REMUSERLEN = 6,0,16,0 %;  !  Length of remote user string
macro NAFV5$L_FLAGS = 8,0,32,1 %;       !  Flags longword
macro NAFV5$V_TASK = 8,0,1,0 %;         !  Allow task=0 access
macro NAFV5$V_BATCH = 8,1,1,0 %;        !  Allow batch jobs
macro NAFV5$V_INTERACTIVE = 8,2,1,0 %;  !  Allow interactive login
macro NAFV5$V_UIC = 8,3,1,0 %;          !  Remote user uses UIC authentication
macro NAFV5$T_REMNAME = 12,0,0,0 %;
literal NAFV5$S_REMNAME = 64;           !  Combined nodename and remote username 
macro NAFV5$T_NODE = 12,0,0,0 %;
literal NAFV5$S_NODE = 32;              !  Node name 
macro NAFV5$T_REMUSER = 44,0,0,0 %;
literal NAFV5$S_REMUSER = 32;           !  Remote username 
macro NAFV5$L_REMUIC = 44,0,32,0 %;     !  Remote UIC
macro NAFV5$W_REMUIC_MEM = 44,0,16,0 %; !  Member number
macro NAFV5$W_REMUIC_GRP = 46,0,16,0 %; !  Group number
 
!*** MODULE $NDTDEF ***
! +
!  NEXUS DEVICE AND ADAPTER TYPE CODES
! -
! DEFINE CONSTANT TYPE CODES 
literal NDT$_MEM4NI = 8;                ! MEMORY, 4K NOT INTERLEAVED 
literal NDT$_MEM4I = 9;                 ! MEMORY, 4K INTERLEAVED 
literal NDT$_MEM16NI = 16;              ! MEMORY, 16K NOT INTERLEAVED 
literal NDT$_MEM16I = 17;               ! MEMORY, 16K INTERLEAVED 
literal NDT$_MEM1664NI = 18;            ! MEMORY, 16K AND 64K MIXED
literal NDT$_MB = 32;                   ! MBA 0,1,2, OR 3 
literal NDT$_UB0 = 40;                  ! UB ADAPTER OR INTERCONNECT 0, 
literal NDT$_UB1 = 41;                  !  1, 
literal NDT$_UB2 = 42;                  !  2, 
literal NDT$_UB3 = 43;                  !  OR 3 
literal NDT$_DR32 = 48;                 ! DR32 0,1,2,... 
literal NDT$_CI = 56;                   ! CI780'S, CI750'S 
literal NDT$_MPM0 = 64;                 ! MULTIPORT MEMORY 0, 
literal NDT$_MPM1 = 65;                 !  1, 
literal NDT$_MPM2 = 66;                 !  2, 
literal NDT$_MPM3 = 67;                 !  OR 3 
literal NDT$_DISK9 = 81;                !  Disk on 009
literal NDT$_TERM9 = 82;                !  Terminal on 009
literal NDT$_TAPE9 = 83;                !  Tape on 009
literal NDT$_PRTR9 = 84;                !  Printer on 009
literal NDT$_SFUN9 = 85;                !  Spec. func. ctrllr. on 009
literal NDT$_USER9 = 86;                !  User-defined device on 009
literal NDT$_MEM64NIL = 104;            ! 64K NON-INTERLEAVED MEM, LOWER CONTROLLER 
literal NDT$_MEM64EIL = 105;            ! 64K EXTERNALLY INTERLEAVED MEM, LOWER 
literal NDT$_MEM64NIU = 106;            ! 64K NON-INTERLEAVED MEM, UPPER CONTROLLER 
literal NDT$_MEM64EIU = 107;            ! 64K EXTERNALLY INTERLEAVED MEM, UPPER 
literal NDT$_MEM64I = 108;              ! 64K INTERNALLY INTERLEAVED MEMORY 
literal NDT$_MEM256NIL = 112;           ! 256K NON-INTERLEAVED MEM, LOWER CONTROLLER 
literal NDT$_MEM256EIL = 113;           ! 256K EXTERNALLY INTERLEAVED MEM, LOWER 
literal NDT$_MEM256NIU = 114;           ! 256K NON-INTERLEAVED MEM, UPPER CONTROLLER 
literal NDT$_MEM256EIU = 115;           ! 256K EXTERNALLY INTERLEAVED MEM, UPPER 
literal NDT$_MEM256I = 116;             ! 256K INTERNALLY INTERLEAVED MEMORY 
literal NDT$_KA410 = 128;               ! VAXstar system
literal NDT$_KA420 = 128;               ! PVAX system
literal NDT$_KA640 = 129;               ! MAYFAIR II system
literal NDT$_SHAC = 130;
literal NDT$_SGEC = 131;
literal NDT$_KA520CIO = 132;            !  CIRRUS CIO module
literal NDT$_KA520COMM = 133;           !  CIRRUS COMM module
literal NDT$_KA43 = 134;
literal NDT$_KA440 = 135;
literal NDT$_KA46 = 135;
!  BI node device types.  Note low word is hardware device type on BI.
!   High order word (i.e. the 8000) distinguishes device as a BI device.
!  First BI memory nodes
literal NDT$_SCORMEM = -2147483647;     !  Scorpio Memory
!  Then other BI devices
literal NDT$_BIMFA = -2147483391;       !  BI Multi-Function Adapter
literal NDT$_BUA = -2147483390;         !  BI UNIBUS adapter
literal NDT$_BLA = -2147483389;         !  BI LESI adapter
literal NDT$_KDZ11 = -2147483387;       !  KDZ11 processor
literal NDT$_KA810 = -2147483387;       !  KA810 processor
literal NDT$_NBI = -2147483386;         !  BI-NMI Adapter
literal NDT$_XBIB = -2147475193;        !  BI-XMI Adapter
literal NDT$_XBIB_PLUS = -2147475185;   !  BI-XMI Plus Adapter
literal NDT$_BCA = -2147483384;         !  BI-CI Adapter
literal NDT$_BICOMBO = -2147483383;     !  BI Combo Board
literal NDT$_BCI750 = -2147483381;      !  Interim BI-CI Adapter
literal NDT$_BIACP = -2147483380;       !  Aurora Processor Module
literal NDT$_BDA = -2147483378;         !  BI-to-Disk Adapter
literal NDT$_BSA = -2147467004;         !  BI-to-SI Adapter
literal NDT$_KSB50 = -2147467004;       !  BI-to-SI Adapter
literal NDT$_AIO = -2147466995;         !  Aurora I/O Module
literal NDT$_KFBTA = -2147466995;       !  Aurora I/O Module
literal NDT$_AIE_TK = -2147466997;      !  Aurora I/O Extension Module
literal NDT$_AIE_TKNI = -2147466994;    !  Aurora I/O Extension Module
literal NDT$_AIE_NI = -2147466993;      !  Aurora I/O Extension Module
literal NDT$_DEBNT = -2147466993;       !  Aurora I/O Extension Module
literal NDT$_DSB32 = -2147483382;       !  BI-Hi speed sync comm adapter
literal NDT$_LACP = -2147466996;        !  BI-VAXstation 8000 graphics adapter
literal NDT$_DEBNI = -2147483368;       !  AIE varient
literal NDT$_KWB = -2147450853;         !  BI_KWB32 module
!  XMI node device types.  Note low word is hardware device type on XMI.
literal NDT$_CIXCD = 3077;              !  CI port CIXCD adapter
literal NDT$_KFMSA = 2064;              !  DSSI port KFMSA adapter
literal NDT$_XCP = 32769;               !  Calypso/CVAX CPU
literal NDT$_XRP = 32898;               !  RIGEL CPU
literal NDT$_XMA = 16385;               !  XMI Memory
literal NDT$_XBI = 8193;                !  XBI Adapter
literal NDT$_XWATCH = 3076;             !  XWATCH Adapter
literal NDT$_XJA = 4097;                !  XJA Adapter
literal NDT$_AXA = 4098;                !  AXA Adapter
literal NDT$_HSX50 = 3106;
literal NDT$_KDM70 = 3106;
literal NDT$_XBI_PLUS = 8194;           !  XBI-Plus adapter
literal NDT$_X1202 = 32896;             !  Mariah CPU
literal NDT$_DEMNA = 3075;              !  NI port - DEMNA adapter
literal NDT$_XSA = 2085;                !  XMI-SCSI adapter
literal NDT$_LAMB = 4138;               !  Laser-XMI adapter
literal NDT$_XZA_SCSI = 3126;           !  XMI-SCSI adapter
literal NDT$_XZA_DSSI = 3121;           !  XMI-DSSI adapter
literal NDT$_CIMNA = 3119;              !  XMI-CI adapter
literal NDT$_DEMFA = 2083;              !  XMI-FDDI adapter
!  MBUS node devices.
literal NDT$_MBUS_FTAM = -1878982655;   ! Tape adapter
literal NDT$_MBUS_FQAM = -1878982399;   ! QBUS adapter
literal NDT$_MBUS_LEGSS = -1878982654;  ! LEGSS graphics
literal NDT$_MBUS_FWIOM = -1878982652;  ! I/O module
literal NDT$_MBUS_KA60 = -1878982392;   ! Dual CVAX CPU
literal NDT$_MBUS_8MB = -1878917104;    ! 8MB memory
literal NDT$_MBUS_16MB = -1878916848;   ! 16MB memory
literal NDT$_MBUS_32MB = -1878916336;   ! 32MB memory
literal NDT$_MBUS_32MBA = -1878916080;  ! 32MB memory
literal NDT$_MBUS_64MB = -1878915824;   ! 64MB memory
literal NDT$_MBUS_128MB = -1878915312;  ! 128MB memory
literal NDT$_MBUS_8MBFS = -1862402032;  ! 8MB Firestarter
!  (TYC0002) keep UCODE constants for CI boot adapters here
literal UCODE_CI780 = 1;
literal UCODE_BCA = 2;
literal UCODE_BCA_ONBOARD = 3;
literal UCODE_ONBOARD = 4;
literal NDT$_KA0302_EV5_CPU = 49152;
literal NDT$_KA0302_EV3_4MB = 32768;
literal NDT$_KA0302_EV4_4MB = 32769;
literal NDT$_KA0302_NV_4MB = 32770;
literal NDT$_KA0302_EV3_1MB = 32771;
literal NDT$_KA0302_EV4_1MB = 32772;
literal NDT$_KA0302_NV_1MB = 32773;
literal NDT$_KA0302_LEPMEM = 16385;
literal NDT$_KA0302_MEM = 16384;
literal NDT$_KA0302_IOP = 8192;
literal NDT$_KA0C05_TLEP = 32784;
literal NDT$_KA0C05_TLEP_EV5_1MB = 32784;
literal NDT$_KA0C05_TLEP_EV5_4MB = 32785;
literal NDT$_KA0C05_TLEP_EV5_16MB = 32786;
literal NDT$_KA0C05_TLEP_2EV5_1MB = 32787;
literal NDT$_KA0C05_TLEP_2EV5_4MB = 32788;
literal NDT$_KA0C05_TLEP_2EV5_16MB = 32789;
literal NDT$_KA0C05_NV_MEM = 17408;
literal NDT$_KA0C05_TMEM = 20480;
literal NDT$_KA0C05_TIOP = 8192;
literal NDT$_KA0C05_ITIOP = 8224;
literal NDT$_FLAG = 12032;
literal NDT$_HPC = 61184;
literal NDT$_FVME_VENDOR_ID = 50336627; !  Vendor ID, FBUS-VME adapter
literal NDT$_FVME = 100663297;          !  FBUS-VME adapter software version
literal NDT$_DEANA = 100745216;         !  Module number = B2005
literal NDT$_FCA = 100728832;           !  Module number = B2004
literal NDT$_FZA = 100777984;           !  Module number = B2007
literal NDT$_FFA = 100761600;           !  Module number = B2006
literal NDT$_FBE = 101711872;           !  FBE is an exception
literal NDT$_KA0202_FBUS = 842022912;   !  Cobra Fbus bridge
literal NDT$_KA0302_FBUS = 858800128;   !  Laser Fbus bridge
literal NDT$_KA0C05_FBUS = 875577344;   !  TLaser Fbus bridge
literal NDT$_PMAD = 1145130320;
literal NDT$_PMAD_AA_H = 541147437;
literal NDT$_PMAF = 1178684752;
literal NDT$_PMAF_AA_H = 541147437;
literal NDT$_PMAF_CA_H = 541147949;
literal NDT$_PMAF_FA_H = 541148717;
literal NDT$_PMAF_FD_H = 541345325;
literal NDT$_PMAF_FS_H = 542328365;
literal NDT$_PMAF_FU_H = 542459437;
literal NDT$_PMAZ = 1514229072;
literal NDT$_PMAZB_AA_H = 1094790466;
literal NDT$_PMAZC_AA_H = 1094790467;
literal NDT$_PMAB = 1111575888;
literal NDT$_PMABV_AA_H = 1094790486;
literal NDT$_AV01 = 825251393;
literal NDT$_AV01B_AA_H = 1094790466;
literal NDT$_PMAG = 1195461968;
literal NDT$_PMAG_JA_H = 541149741;
literal NDT$_PMAG_FA_H = 541148717;
literal NDT$_PMAGB_BA_H = 1094856002;
literal NDT$_PMAGD_AA_H = 1094790468;
literal NDT$_PMAGC_H = 538976323;
literal NDT$_PMAGC_AA_H = 1094790467;
literal NDT$_PMAGC_BA_H = 1094856003;
literal NDT$_PMAGC_DA_H = 1094987075;
literal NDT$_PMAGD_H = 538976324;
literal NDT$_PMAGC_EA_H = 1095052611;
literal NDT$_PMAG_CA_H = 541147949;
literal NDT$_PMAG_DA_H = 541148205;
literal NDT$_DELTA = 1414284612;
literal NDT$_DELTA_H = 538976321;
literal NDT$_KZTS = 1398037067;
literal NDT$_KZTSA_AA_H = 1094790465;
literal NDT$_KZTSA_BA_H = 1094856001;
literal NDT$_PMAT = 1413565776;
literal NDT$_PMAT_AA_H = 541147437;
literal NDT$_OTTO = 1330926671;
literal NDT$_OTTO_H = 538976288;
literal NDT$_DGLTA = 1414285124;
literal NDT$_DGLTA_H = 1095118145;
literal NDT$_EISA_SYSTEM_BOARD = 22;
literal NDT$_AHA1742A = 33591300;
literal NDT$_AHA1740 = 16814084;
literal NDT$_DEPCA = 541238032;
literal NDT$_CPQ3011 = 288362766;
literal NDT$_CPQ3021 = 556798222;
literal NDT$_CPQ3111 = 288428302;
literal NDT$_CPQ3112 = 305205518;
literal NDT$_CPQ3121 = 556863758;
literal NDT$_CPQ3122 = 573640974;
literal NDT$_CPQ3201 = 20058382;
literal NDT$_CPQ3202 = 36835598;
literal NDT$_CPQ3231 = 825364750;
literal NDT$_CPQ3232 = 842141966;
literal NDT$_PRO6000 = 6311746;
literal NDT$_PRO6001 = 23088962;
literal NDT$_PRO6002 = 39866178;
literal NDT$_DEFEA = 19964688;
literal NDT$_DEFEA_2 = 36741904;
literal NDT$_KFESA = 3056400;
literal NDT$_KFESB = 19833616;
literal NDT$_KFESC = 36610832;
literal NDT$_KFESD = 53388048;
literal NDT$_MLX0075 = 1962973237;
literal NDT$_MLX0077 = 1996527669;
literal NDT$_DEC4250 = 1346544400;
literal NDT$_DEC3003 = 53519120;
literal NDT$_AHA1742A_FLOPPY = 1347374150;
literal NDT$_NS16450 = 91216;
literal NDT$_PC4XD_SERIAL = 1395934032;
literal NDT$_PC4XD_PARALLEL = 1278493520;
literal NDT$_DIGIBOARD = 1229408580;
literal NDT$_PARALLEL_PORT = 1414680656;
literal NDT$_SERIAL_PORT = 1414680659;
literal NDT$_DE200 = 808600900;
literal NDT$_AHA_1540 = 808727857;
literal NDT$_SOUND_BOARD = 1314213715;
literal NDT$_WD90C24 = 809059415;
literal NDT$_KBD = 4473419;
literal NDT$_MOUS = 1398099789;
literal NDT$_COM1 = 827150147;
literal NDT$_COM2 = 843927363;
literal NDT$_FLOP = 1347374150;
literal NDT$_DE20 = 808600900;
literal NDT$_LPT1 = 827609164;
literal NDT$_DW11 = 825317188;
literal NDT$_DT20 = 808604740;
literal NDT$_PCXB = 1113080656;
literal NDT$_DIGITAL_PCI_VENDOR_ID = 4113;
literal NDT$_PBB = 69649;
literal NDT$_TULIP = 135185;
literal NDT$_FOCUS = 200721;
literal NDT$_TGA = 266257;
literal NDT$_PVIC = 397329;
literal NDT$_ZEPHYR = 462865;
literal NDT$_KZPSA = 528401;
literal NDT$_DC21140 = 593937;
literal NDT$_TGA2 = 856081;
literal NDT$_PFI = 987153;
literal NDT$_DC21041 = 1314833;
literal NDT$_DGLPB = 1445905;
literal NDT$_PVPCI = 1511441;
literal NDT$_PCIRM = 1576977;
literal NDT$_CIPCA = 106958997;
literal NDT$_NCR53C810 = 69632;
literal NDT$_NCR53C810A = 331776;
literal NDT$_SATURN = 75792518;
literal NDT$_MERCURY = 75661446;
literal NDT$_QLOGIC = 270536823;
literal NDT$_PCMCIA_PD6729 = 285216787;
literal NDT$_MYLEX = 69737;
literal NDT$_PCI1280 = 808586769;
literal NDT$_MACH32 = 1096290306;
literal NDT$_MACH64 = 1196953602;
literal NDT$_MACH64C = 1129844738;
literal NDT$_DEC864 = -2000661709;
literal NDT$_FAX_MODEM = 5783878;
literal NDT$_XIRCOM = 5128524;
literal NDT$_NCR53C710 = 1;
literal NDT$_DC253 = 2;
literal NDT$_SCRIPT_RAM = 3;
literal NDT$_DS1287 = 4;
literal NDT$_Z85C30 = 5;
literal NDT$_EEROM = 6;
literal NDT$_NIADRROM = 7;
literal NDT$_FEPROM = 8;
literal NDT$_PCD8584 = 9;
literal NDT$_NCR53C710_DSSI = 10;
literal NDT$_TC_INTERFACE = 11;
literal NDT$_SCSI_INTERFACE = 12;
literal NDT$_CXTURBO = 13;
literal NDT$_COREIO = 14;
literal NDT$_NCR53C94 = 15;
literal NDT$_LANCE = 16;
literal NDT$_AMD79C30 = 17;
literal NDT$_KA0202_CPU = 18;
literal NDT$_KA0202_MEM = 19;
literal NDT$_KA0202_IO = 20;
literal NDT$_VTI82C106_PP = 21;
literal NDT$_KA0902_CPU = 23;
literal NDT$_KA0902_MEM = 24;
literal NDT$_KA0902_IIO = 25;
literal NDT$_KA0902_EIO = 26;
 
!*** MODULE $NMBDEF ***
! +
! 
!  FORMAT OF THE FILE NAME BLOCK. THE FILE NAME BLOCK IS USED AS AN INTERNAL
!  INTERFACE TO THE DIRECTORY SCAN ROUTINE, AND IS ALSO THE FORMAT OF A
!  DIRECTORY RECORD.
! 
! -    
literal NMB$K_DIRENTRY = 16;            !  LENGTH OF DIRECTORY ENTRY 
literal NMB$C_DIRENTRY = 16;            !  LENGTH OF DIRECTORY ENTRY 
literal NMB$M_ALLVER = %X'8';
literal NMB$M_ALLTYP = %X'10';
literal NMB$M_ALLNAM = %X'20';
literal NMB$M_WILD = %X'100';
literal NMB$M_NEWVER = %X'200';
literal NMB$M_SUPERSEDE = %X'400';
literal NMB$M_FINDFID = %X'800';
literal NMB$M_LOWVER = %X'4000';
literal NMB$M_HIGHVER = %X'8000';
literal NMB$K_LENGTH = 40;              !  LENGTH OF NAME BLOCK 
literal NMB$C_LENGTH = 40;              !  LENGTH OF NAME BLOCK 
literal NMB$S_NMBDEF = 40;
literal NMB$S_NMB = 40;
macro NMB$W_FID = 0,0,0,0 %;
literal NMB$S_FID = 6;                  !  FILE ID 
macro NMB$W_FID_NUM = 0,0,16,0 %;       !  FID - FILE NUMBER 
macro NMB$W_FID_SEQ = 2,0,16,0 %;       !  FID - FILE SEQUENCE NUMBER 
macro NMB$W_FID_RVN = 4,0,16,0 %;       !  FID - RELATIVE VOLUME NUMBER 
macro NMB$W_NAME = 6,0,0,0 %;
literal NMB$S_NAME = 6;                 !  FILE NAME (RAD-50) 
macro NMB$W_TYPE = 12,0,16,0 %;         !  FILE TYPE (RAD-50) 
macro NMB$W_VERSION = 14,0,16,1 %;      !  VERSION NUMBER 
macro NMB$W_FLAGS = 16,0,16,0 %;        !  NAME STATUS FLAGS 
macro NMB$V_ALLVER = 16,3,1,0 %;        !  MATCH ALL VERSIONS 
macro NMB$V_ALLTYP = 16,4,1,0 %;        !  MATCH ALL TYPES 
macro NMB$V_ALLNAM = 16,5,1,0 %;        !  MATCH ALL NAMES 
macro NMB$V_WILD = 16,8,1,0 %;          !  WILD CARDS IN FILE NAME 
macro NMB$V_NEWVER = 16,9,1,0 %;        !  MAXIMIZE VERSION NUMBER 
macro NMB$V_SUPERSEDE = 16,10,1,0 %;    !  SUPERSEDE EXISTING FILE 
macro NMB$V_FINDFID = 16,11,1,0 %;      !  SEARCH FOR FILE ID 
macro NMB$V_LOWVER = 16,14,1,0 %;       !  LOWER VERSION OF FILE EXISTS 
macro NMB$V_HIGHVER = 16,15,1,0 %;      !  HIGHER VERSION OF FILE EXISTS 
macro NMB$B_ASCNAMSIZ = 18,0,8,0 %;
macro NMB$T_ASCNAMTXT = 19,0,0,0 %;
literal NMB$S_ASCNAMTXT = 19;
macro NMB$W_CONTEXT = 38,0,16,0 %;      !  START POINT FOR NEXT FIND 
 
!*** MODULE NPOOL_DATA ***
! +
!  DEFINITION OF SYSTEM PRIMITIVES LOCAL NON-PAGED POOL DATA
! -
literal IOC_C_INVALID_ADDRESS = -8388608; !  4G - 8M
literal IOC_C_MAXLISTPKT = 5120;        !  Max. lookaside list size
literal IOC_C_NPAGGRNMSK = 63;          !  Mask for rounding
literal IOC_C_NPAGGRNBITS = 6;          !  Granularity = 2^6
literal IOC_C_NUMLISTS = 80;            !  = 5120 / 64
literal IOC_C_IRPLIST = 0;
literal IOC_C_RECLAIMINTERVAL = 8;
literal IOC_C_VARALLOCBYTES = 12;
literal IOC_C_RINGBUF = 16;
literal IOC_C_NEXTNPH = 20;
literal IOC_C_SRPLIST = 24;
literal IOC_C_RINGBUFCNT = 32;
literal IOC_C_LISTATTEMPTS = 36;
literal IOC_C_LISTFAILS = 40;
literal IOC_C_LISTDEALLOCS = 44;
literal IOC_C_FILLER = 48;
literal IOC_C_LISTHEADS = 56;
literal S_NPOOL_DATA = 704;
macro IOC_GQ_IRPLIST = 0,0,0,0 %;
literal S_IOC_GQ_IRPLIST = 8;
macro IOC_GL_RECLAIMINTERVAL = 8,0,32,0 %;
macro IOC_GL_VARALLOCBYTES = 12,0,32,0 %;
macro IOC_AR_RINGBUF = 16,0,32,0 %;
macro IOC_AR_NEXTNPH = 20,0,32,0 %;
macro IOC_GQ_SRPLIST = 24,0,0,0 %;
literal S_IOC_GQ_SRPLIST = 8;
macro IOC_GL_RINGBUFCNT = 32,0,32,0 %;
macro IOC_AR_LISTATTEMPTS = 36,0,32,0 %;
macro IOC_AR_LISTFAILS = 40,0,32,0 %;
macro IOC_AR_LISTDEALLOCS = 44,0,32,0 %;
macro IOC_GL_FILLER = 48,0,0,0 %;
literal S_IOC_GL_FILLER = 8;
macro IOC_GQ_LISTHEADS = 56,0,0,0 %;
literal S_IOC_GQ_LISTHEADS = 648;
 
!*** MODULE $NPHDEF ***
! +
!  DEFINITION OF NON-PAGED POOL HISTORY RECORD IN RING BUFFER
! -
literal NPH$C_ALONONPAGED = 0;          !  Caller was EXE$ALONONPAGED
literal NPH$C_ALONPAGVAR = 1;           !  Caller was EXE$ALONPAGVAR
literal NPH$C_DEANONPAGED = 2;          !  Caller was EXE$DEANONPAGED
literal NPH$C_DEANONPGDSIZ = 3;         !  Caller was EXE$DEANONPGDSIZ
literal NPH$S_NPHDEF = 16;              !  Old size name - synonym
literal NPH$S_NPH = 16;
macro NPH$L_PC = 0,0,32,1 %;            !  PC of caller's caller
macro NPH$L_ADDR = 4,0,32,1 %;          !  Addr. of pkt being manip.
macro NPH$W_SIZE = 8,0,16,0 %;          !  Size of pkt. being manip.
macro NPH$B_TYPE = 10,0,8,0 %;          !  Pkt. type
macro NPH$B_RMOD = 11,0,8,0 %;          !  Pkt. RMOD or subtype
macro NPH$L_FUNCTION = 12,0,32,0 %;     !  Function of caller
 
!*** MODULE $NSAARGDEF ***
! +
!  Security Auditing argument list definitions
! -
! +
!  Argument list header offset definitions
! -
literal NSA$M_ARG_FLAG_ALARM = %X'1';
literal NSA$M_ARG_FLAG_JOURN = %X'2';
literal NSA$M_ARG_FLAG_MANDY = %X'4';
literal NSA$C_ARGHDR_LENGTH = 12;
literal NSA$K_ARGHDR_LENGTH = 12;
literal NSA$S_NSAARGHDRDEF = 12;        !  Old size name - synonym
literal NSA$S_NSAARGHDR = 12;
macro NSA$L_ARG_COUNT = 0,0,32,0 %;     !  Argument list count
macro NSA$L_ARG_ID = 4,0,32,0 %;        !  Record identification longword
macro NSA$W_ARG_TYPE = 4,0,16,0 %;      !  Record type
macro NSA$W_ARG_SUBTYPE = 6,0,16,0 %;   !  Record subtype
macro NSA$B_ARG_FLAG = 8,0,8,0 %;       !  Flags byte
macro NSA$V_ARG_FLAG_ALARM = 8,0,1,0 %; !  Generate alarm for this record
macro NSA$V_ARG_FLAG_JOURN = 8,1,1,0 %; !  Journal this record
macro NSA$V_ARG_FLAG_MANDY = 8,2,1,0 %; !  Mandatory auditing
macro NSA$B_ARG_PKTNUM = 9,0,8,0 %;     !  Number of packets
macro NSA$T_ARG_SPARE = 10,0,16,0 %;
literal NSA$S_ARG_SPARE = 2;            !  Spare bytes
macro NSA$T_ARG_LIST = 12,0,0,0 %;
! +
!  Data packet argument passing mechanism definitions
! -
literal NSA$K_ARG_MECH_BYTE = 0;        !  Byte value
literal NSA$K_ARG_MECH_WORD = 1;        !  Word value
literal NSA$K_ARG_MECH_LONG = 2;        !  Longword value
literal NSA$K_ARG_MECH_QUAD = 3;        !  Quadword value
literal NSA$K_ARG_MECH_DESCR = 4;       !  Descriptor
literal NSA$K_ARG_MECH_ADESCR = 5;      !  Address of descriptor
literal NSA$K_ARG_MECHNUM = 6;
! +
!  Argument list definitions
! -
!  File access
literal NSA$C_ARG1_LENGTH = 52;
literal NSA$K_ARG1_LENGTH = 52;
literal NSA$S_NSAARG1DEF = 52;          !  Old size name - synonym
literal NSA$S_NSAARG1 = 52;
macro NSA$L_ARG1_FACMOD_TM = 12,0,32,0 %; !  FACMOD type and mechanism 
macro NSA$L_ARG1_FACMOD = 16,0,32,0 %;  !  File access mode
macro NSA$L_ARG1_FILNAM_TM = 20,0,32,0 %; !  FILNAM type and mechanism
macro NSA$L_ARG1_FILNAM_SIZ = 24,0,32,0 %; !  File name size
macro NSA$L_ARG1_FILNAM_PTR = 28,0,32,0 %; !  File name address
macro NSA$L_ARG1_IMGNAM_TM = 32,0,32,0 %; !  IMGNAM type and mechanism
macro NSA$Q_ARG1_IMGNAM = 36,0,0,0 %;
literal NSA$S_ARG1_IMGNAM = 8;          !  Image name
macro NSA$L_ARG1_PRIVUSED_TM = 44,0,32,0 %; !  PRIVUSED type and mechanism
macro NSA$L_ARG1_PRIVUSED = 48,0,32,0 %; !  Privileges used for access
!  Volume mount
literal NSA$C_ARG2_LENGTH = 96;
literal NSA$K_ARG2_LENGTH = 96;
literal NSA$S_NSAARG2DEF = 96;          !  Old size name - synonym
literal NSA$S_NSAARG2 = 96;
macro NSA$L_ARG2_UIC_TM = 12,0,32,0 %;  !  UIC type and mechanism 
macro NSA$L_ARG2_UIC = 16,0,32,0 %;     !  Volume UIC
macro NSA$L_ARG2_VOLPRO_TM = 20,0,32,0 %; !  VOLPRO type and mechanism
macro NSA$L_ARG2_VOLPRO = 24,0,32,0 %;  !  Volume protection 
macro NSA$L_ARG2_MOUFLG_TM = 28,0,32,0 %; !  MOUFLG type and mechanism
macro NSA$L_ARG2_MOUFLG = 32,0,32,0 %;  !  Mount flags
macro NSA$L_ARG2_IMGNAM_TM = 36,0,32,0 %; !  IMGNAM type and mechanism
macro NSA$Q_ARG2_IMGNAM = 40,0,0,0 %;
literal NSA$S_ARG2_IMGNAM = 8;          !  Image name
macro NSA$L_ARG2_DEVNAM_TM = 48,0,32,0 %; !  DEVNAM type and mechanism
macro NSA$L_ARG2_DEVNAM_SIZ = 52,0,32,0 %; !  Device name size
macro NSA$L_ARG2_DEVNAM_PTR = 56,0,32,0 %; !  Device name address
macro NSA$L_ARG2_LOGNAM_TM = 60,0,32,0 %; !  LOGNAM type and mechanism
macro NSA$L_ARG2_LOGNAM_SIZ = 64,0,32,0 %; !  Logical name size
macro NSA$L_ARG2_LOGNAM_PTR = 68,0,32,0 %; !  Logical name address
macro NSA$L_ARG2_VOLNAM_TM = 72,0,32,0 %; !  VOLNAM type and mechanism
macro NSA$L_ARG2_VOLNAM_SIZ = 76,0,32,0 %; !  Volume name size
macro NSA$L_ARG2_VOLNAM_PTR = 80,0,32,0 %; !  Volume name address
macro NSA$L_ARG2_VOLSNAM_TM = 84,0,32,0 %; !  VOLSNAM type and mechanism
macro NSA$L_ARG2_VOLSNAM_SIZ = 88,0,32,0 %; !  Volume set name size
macro NSA$L_ARG2_VOLSNAM_PTR = 92,0,32,0 %; !  Volume set name address
!  Volume dismount
literal NSA$C_ARG3_LENGTH = 80;
literal NSA$K_ARG3_LENGTH = 80;
literal NSA$S_NSAARG3DEF = 80;          !  Old size name - synonym
literal NSA$S_NSAARG3 = 80;
macro NSA$L_ARG3_DMOUFLG_TM = 12,0,32,0 %; !  DMOUFLG type and mechanism
macro NSA$L_ARG3_DMOUFLG = 16,0,32,0 %; !  Dismount flags
macro NSA$L_ARG3_IMGNAM_TM = 20,0,32,0 %; !  IMGNAM type and mechanism
macro NSA$Q_ARG3_IMGNAM = 24,0,0,0 %;
literal NSA$S_ARG3_IMGNAM = 8;          !  Image name
macro NSA$L_ARG3_DEVNAM_TM = 32,0,32,0 %; !  DEVNAM type and mechanism
macro NSA$L_ARG3_DEVNAM_SIZ = 36,0,32,0 %; !  Device name size
macro NSA$L_ARG3_DEVNAM_PTR = 40,0,32,0 %; !  Device name address
macro NSA$L_ARG3_LOGNAM_TM = 44,0,32,0 %; !  LOGNAM type and mechanism
macro NSA$L_ARG3_LOGNAM_SIZ = 48,0,32,0 %; !  Logical name size
macro NSA$L_ARG3_LOGNAM_PTR = 52,0,32,0 %; !  Logical name address
macro NSA$L_ARG3_VOLNAM_TM = 56,0,32,0 %; !  VOLNAM type and mechanism
macro NSA$L_ARG3_VOLNAM_SIZ = 60,0,32,0 %; !  Volume name size
macro NSA$L_ARG3_VOLNAM_PTR = 64,0,32,0 %; !  Volume name address
macro NSA$L_ARG3_VOLSNAM_TM = 68,0,32,0 %; !  VOLSNAM type and mechanism
macro NSA$L_ARG3_VOLSNAM_SIZ = 72,0,32,0 %; !  Volume set name size
macro NSA$L_ARG3_VOLSNAM_PTR = 76,0,32,0 %; !  Volume set name address
!  Global section access
literal NSA$C_ARG4_LENGTH = 64;
literal NSA$K_ARG4_LENGTH = 64;
literal NSA$S_NSAARG4DEF = 64;          !  Old size name - synonym
literal NSA$S_NSAARG4 = 64;
macro NSA$L_ARG4_FACMOD_TM = 12,0,32,0 %; !  FACMOD type and mechanism 
macro NSA$L_ARG4_FACMOD = 16,0,32,0 %;  !  File access mode
macro NSA$L_ARG4_FILNAM_TM = 20,0,32,0 %; !  FILNAM type and mechanism
macro NSA$L_ARG4_FILNAM_SIZ = 24,0,32,0 %; !  File name size
macro NSA$L_ARG4_FILNAM_PTR = 28,0,32,0 %; !  File name address
macro NSA$L_ARG4_IMGNAM_TM = 32,0,32,0 %; !  IMGNAM type and mechanism
macro NSA$Q_ARG4_IMGNAM = 36,0,0,0 %;
literal NSA$S_ARG4_IMGNAM = 8;          !  Image name
macro NSA$L_ARG4_SECNAM_TM = 44,0,32,0 %; !  SECNAM type and mechanism
macro NSA$L_ARG4_SECNAM_SIZ = 48,0,32,0 %; !  File name size
macro NSA$L_ARG4_SECNAM_PTR = 52,0,32,0 %; !  File name address
macro NSA$L_ARG4_PRIVUSED_TM = 56,0,32,0 %; !  PRIVUSED type and mechanism
macro NSA$L_ARG4_PRIVUSED = 60,0,32,0 %; !  Privileges used for access
 
!*** MODULE $NSABDEF ***
! 
!  Define the layout of the Non-discretionary Security Audit Block.
! 
!  The NSAB is the structure which is passed to the internal auditing entry
!  point (NSA$AUDIT_EVENT) and contains a list of audit packets along with
!  a couple of flags.
! 
literal NSAB$M_NONPAGED = %X'1';
literal NSAB$M_NUKENSAB = %X'2';
literal NSAB$C_HDR_LENGTH = 72;
literal NSAB$K_HDR_LENGTH = 72;
literal NSAB$S_NSABDEF = 72;
literal NSAB$S_NSAB = 72;
macro NSAB$L_FLINK = 0,0,32,1 %;        !  FLINK
macro NSAB$L_BLINK = 4,0,32,1 %;        !  BLINK
macro NSAB$L_SIZE = 8,0,32,0 %;         !  size of NSAB buffer
macro NSAB$L_TYPE = 12,0,32,0 %;        !  type of structure (DYN$C_NSAB)
macro NSAB$L_FLAGS = 16,0,32,0 %;       !  miscellaneous flags
macro NSAB$V_NONPAGED = 16,0,1,0 %;     !  message entry is non-paged pool
macro NSAB$V_NUKENSAB = 16,1,1,0 %;     !  force NSAB deallocation
macro NSAB$L_SUPPLIED = 20,0,32,0 %;    !  supplied packet mask
macro NSAB$L_BASEADDR = 24,0,32,1 %;    !  address of NSAB to deallocate
macro NSAB$L_AUDIT_BLOCK = 28,0,32,1 %; !  address of audit buffer
macro NSAB$B_ACB = 32,0,0,0 %;
literal NSAB$S_ACB = 36;                !  ACB used to wake audit server
macro NSAB$L_SENDER_EPID = 68,0,32,0 %; !  sender's EPID
 
!*** MODULE $NSAEVTDEF ***
! +
!  Non-Discretionary Security Auditing event definitions.  This macro defines
!  the bits which are used to enable alarm and audit events for each class of
!  system security relevant event.  This definition also defines the format of
!  the mandatory process auditing event vectors.
! -
literal NSA$S_NSAAXPDEF = 40;           !  Old size name - synonym
literal NSA$S_NSAAXP = 40;
macro NSA$L_EVT_FAILURE = 8,0,32,0 %;   !  Access failures event mask
macro NSA$L_EVT_SUCCESS = 12,0,32,0 %;  !  Successful access event mask
macro NSA$L_EVT_SYSPRV = 16,0,32,0 %;   !  Success due to SYSPRV event mask
macro NSA$L_EVT_BYPASS = 20,0,32,0 %;   !  Success due to BYPASS event mask
macro NSA$L_EVT_UPGRADE = 24,0,32,0 %;  !  Success due to UPGRADE event mask
macro NSA$L_EVT_DOWNGRADE = 28,0,32,0 %; !  Success due to DOWNGRADE event mask
macro NSA$L_EVT_GRPPRV = 32,0,32,0 %;   !  Success due to GRPPRV event mask
macro NSA$L_EVT_READALL = 36,0,32,0 %;  !  Success due to READALL event mask
literal NSA$K_NUM_OBJECT_ACCESS = 8;    !  number of privileged access arrays
literal NSA$M_EVT_CREATION = %X'1';
literal NSA$M_EVT_DEACCESS = %X'2';
literal NSA$M_EVT_DELETION = %X'4';
literal NSA$K_NUM_ACC_OTHER = 3;        !  number of "other" bits
literal NSA$K_ACCESS_LENGTH = 36;       !  size of object access event mask
literal NSA$S_NSAACCDEF = 36;           !  Old size name - synonym
literal NSA$S_NSAACC = 36;
macro NSA$L_ACC_FAILURE = 0,0,32,0 %;   !  Access failures event mask
macro NSA$L_ACC_SUCCESS = 4,0,32,0 %;   !  Successful access event mask
macro NSA$L_ACC_SYSPRV = 8,0,32,0 %;    !  Success due to SYSPRV event mask
macro NSA$L_ACC_BYPASS = 12,0,32,0 %;   !  Success due to BYPASS event mask
macro NSA$L_ACC_UPGRADE = 16,0,32,0 %;  !  Success due to UPGRADE event mask
macro NSA$L_ACC_DOWNGRADE = 20,0,32,0 %; !  Success due to DOWNGRADE event mask
macro NSA$L_ACC_GRPPRV = 24,0,32,0 %;   !  Success due to GRPPRV event mask
macro NSA$L_ACC_READALL = 28,0,32,0 %;  !  Success due to READALL event mask
macro NSA$L_ACC_OTHER = 32,0,32,0 %;    !  other object-specific events
macro NSA$V_EVT_CREATION = 32,0,1,0 %;  !  object creation
macro NSA$V_EVT_DEACCESS = 32,1,1,0 %;  !  object deaccess
macro NSA$V_EVT_DELETION = 32,2,1,0 %;  !  object delete (devices)
literal NSA$M_EVT_ACL = %X'1';
literal NSA$M_EVT_MOUNT = %X'2';
literal NSA$M_EVT_UAF = %X'4';
literal NSA$M_EVT_INSTAL = %X'8';
literal NSA$M_EVT_AUDIT = %X'10';
literal NSA$M_EVT_CUSTOMER = %X'20';
literal NSA$M_EVT_CSS = %X'40';
literal NSA$M_EVT_LP = %X'80';
literal NSA$M_EVT_SYSTIME = %X'100';
literal NSA$M_EVT_SYSGEN = %X'200';
literal NSA$M_EVT_IDENTIFIER = %X'400';
literal NSA$M_EVT_CONNECTION = %X'800';
literal NSA$M_EVT_NCP = %X'1000';
literal NSA$M_EVT_AUTHENTICATION = %X'2000';
literal NSA$K_NUM_SYS_EVENTS = 14;      !  number of system event types
literal NSA$K_NUM_LOGIN_EVENTS = 4;     !  number of login event types
literal NSA$K_NUM_PRIV_EVENTS = 2;      !  number of priv audit event types
literal NSA$M_PRC_CREPRC = %X'1';
literal NSA$M_PRC_DELPRC = %X'2';
literal NSA$M_PRC_SCHDWK = %X'4';
literal NSA$M_PRC_CANWAK = %X'8';
literal NSA$M_PRC_WAKE = %X'10';
literal NSA$M_PRC_SUSPND = %X'20';
literal NSA$M_PRC_RESUME = %X'40';
literal NSA$M_PRC_GRANTID = %X'80';
literal NSA$M_PRC_REVOKID = %X'100';
literal NSA$M_PRC_GETJPI = %X'200';
literal NSA$M_PRC_FORCEX = %X'400';
literal NSA$M_PRC_SIGPRC = %X'800';
literal NSA$M_PRC_SETPRI = %X'1000';
literal NSA$M_PRC_PRCTERM = %X'2000';
literal NSA$K_NUM_PROCESS_EVENTS = 14;  !  number of process control bits
literal NSA$M_EVT_ILLFORMED = %X'1';
literal NSA$K_NUM_AUDIT_EVENTS = 1;     !  number of audit event types
literal NSA$C_EVT_LENGTH = 40;          !  size of alarm or audit event mask
literal NSA$K_EVT_LENGTH = 40;          !  size of alarm or audit event mask
literal NSA$S_NSAEVTDEF = 40;           !  Old size name - synonym
literal NSA$S_NSAEVT = 40;
macro NSA$L_EVT_SYS = 0,0,32,0 %;       !  miscellaneous system event mask
macro NSA$V_EVT_ACL = 0,0,1,0 %;        !  ACL requested alarms and audits
macro NSA$V_EVT_MOUNT = 0,1,1,0 %;      !  MOUNT and DISMOUNT requests
!  modifications made to the system
macro NSA$V_EVT_UAF = 0,2,1,0 %;        !   or network authorization files
macro NSA$V_EVT_INSTAL = 0,3,1,0 %;     !  INSTALL operations
macro NSA$V_EVT_AUDIT = 0,4,1,0 %;      !  SET AUDIT operations (obsolete)
macro NSA$V_EVT_CUSTOMER = 0,5,1,0 %;   !  Customer events
macro NSA$V_EVT_CSS = 0,6,1,0 %;        !  CSS events
macro NSA$V_EVT_LP = 0,7,1,0 %;         !  LP events
macro NSA$V_EVT_SYSTIME = 0,8,1,0 %;    !  System time modification
macro NSA$V_EVT_SYSGEN = 0,9,1,0 %;     !  SYSGEN parameter modification
macro NSA$V_EVT_IDENTIFIER = 0,10,1,0 %; !  Identifier auditing (as privilege)
macro NSA$V_EVT_CONNECTION = 0,11,1,0 %; !  Connection auditing
macro NSA$V_EVT_NCP = 0,12,1,0 %;       !  NCP command line auditing
macro NSA$V_EVT_AUTHENTICATION = 0,13,1,0 %; !  DAS auditing
macro NSA$B_EVT_LOGB = 4,0,8,0 %;       !  breakin detection event mask
macro NSA$B_EVT_LOGI = 5,0,8,0 %;       !  login event mask
macro NSA$B_EVT_LOGF = 6,0,8,0 %;       !  login failure event mask
macro NSA$B_EVT_LOGO = 7,0,8,0 %;       !  logout event mask
macro NSA$Q_PRVAUD_SUCCESS = 8,0,0,0 %;
literal NSA$S_PRVAUD_SUCCESS = 8;       !  successfull privilege audit mask
macro NSA$Q_PRVAUD_FAILURE = 16,0,0,0 %;
literal NSA$S_PRVAUD_FAILURE = 8;       !  successfull privilege audit mask
macro NSA$L_EVT_PROCESS = 24,0,32,0 %;  !  process control auditing
macro NSA$V_PRC_CREPRC = 24,0,1,0 %;    !  Create process
macro NSA$V_PRC_DELPRC = 24,1,1,0 %;    !  Delete process
macro NSA$V_PRC_SCHDWK = 24,2,1,0 %;    !  Schedule process wakeup
macro NSA$V_PRC_CANWAK = 24,3,1,0 %;    !  Cancel process wakeup
macro NSA$V_PRC_WAKE = 24,4,1,0 %;      !  Wake process
macro NSA$V_PRC_SUSPND = 24,5,1,0 %;    !  Suspend process
macro NSA$V_PRC_RESUME = 24,6,1,0 %;    !  Resume process
macro NSA$V_PRC_GRANTID = 24,7,1,0 %;   !  Grant identifier
macro NSA$V_PRC_REVOKID = 24,8,1,0 %;   !  Revoke identifier
macro NSA$V_PRC_GETJPI = 24,9,1,0 %;    !  Get job or process information
macro NSA$V_PRC_FORCEX = 24,10,1,0 %;   !  Force image exit
macro NSA$V_PRC_SIGPRC = 24,11,1,0 %;   !  Signal process (undocumented)
macro NSA$V_PRC_SETPRI = 24,12,1,0 %;   !  Set process priority
macro NSA$V_PRC_PRCTERM = 24,13,1,0 %;  !  Detect process termination (undocumented)
macro NSA$L_EVT_AUDIT = 28,0,32,0 %;    !  miscellaneous audit event mask
macro NSA$V_EVT_ILLFORMED = 28,0,1,0 %; !  Ill-formed TCB audit
literal NSA$M_EVT_LOG_BAT = %X'1';
literal NSA$M_EVT_LOG_DIA = %X'2';
literal NSA$M_EVT_LOG_LOC = %X'4';
literal NSA$M_EVT_LOG_REM = %X'8';
literal NSA$M_EVT_LOG_NET = %X'10';
literal NSA$M_EVT_LOG_SUB = %X'20';
literal NSA$M_EVT_LOG_DET = %X'40';
literal NSA$M_EVT_LOG_SRV = %X'80';
literal NSA$K_NUM_JOB_TYPES = 8;        !  number of job types
literal NSA$S_NSAEVTLOGBITS = 1;
macro NSA$V_EVT_LOG_BAT = 0,0,1,0 %;    !  batch
macro NSA$V_EVT_LOG_DIA = 0,1,1,0 %;    !  dialup
macro NSA$V_EVT_LOG_LOC = 0,2,1,0 %;    !  local
macro NSA$V_EVT_LOG_REM = 0,3,1,0 %;    !  remote
macro NSA$V_EVT_LOG_NET = 0,4,1,0 %;    !  network
macro NSA$V_EVT_LOG_SUB = 0,5,1,0 %;    !  subprocess
macro NSA$V_EVT_LOG_DET = 0,6,1,0 %;    !  detached process
macro NSA$V_EVT_LOG_SRV = 0,7,1,0 %;    !  server thread
literal NSA$C_OLD_EVT_LENGTH = 40;
literal NSA$K_OLD_EVT_LENGTH = 40;
literal NSA$S_NSAOLDEVTDEF = 40;        !  Old size name - synonym
literal NSA$S_NSAOLDEVT = 40;
! ****************************************************************************
!  The following file access masks must be contiguous and in the current order
! ****************************************************************************
macro NSA$L_OLD_EVT_FAILURE = 8,0,32,0 %; !  Access failures event mask
macro NSA$L_OLD_EVT_SUCCESS = 12,0,32,0 %; !  Successful access event mask
macro NSA$L_OLD_EVT_SYSPRV = 16,0,32,0 %; !  Success due to SYSPRV event mask
macro NSA$L_OLD_EVT_BYPASS = 20,0,32,0 %; !  Success due to BYPASS event mask
macro NSA$L_OLD_EVT_UPGRADE = 24,0,32,0 %; !  Success due to UPGRADE event mask
macro NSA$L_OLD_EVT_DOWNGRADE = 28,0,32,0 %; !  Success due to DOWNGRADE event mask
macro NSA$L_OLD_EVT_GRPPRV = 32,0,32,0 %; !  Success due to GRPPRV event mask
macro NSA$L_OLD_EVT_READALL = 36,0,32,0 %; !  Success due to READALL event mask
! ****************************************************************************
!  End of file access masks
! ****************************************************************************
literal NSA$S_ALARM_NAME = 32;          !  maximum length of an alarm name
literal NSA$S_AUDIT_NAME = 65;          !  maximum length of an audit name
literal NSA$S_IMAGE_NAME = 1022;        !  maximum size of an image name (XQP)
literal NSA$S_JOURNAL_NAME = 65;        !  maximum length of alarm or audit name
literal NSA$K_MAX_JOURNALS = 1;         !  maximum number of alarm or audit journals
literal NSA$S_MSGFILNAM = 32;           !  maximum size of message file name
literal NSA$K_SCRATCH_PAGES = 10;       !  number of scratch P1 pages (NSA$A_SCRATCH)
literal NSA$K_SCRATCH_LENGTH = 5120;    !  byte length of P1 scratch space
literal NSA$S_NSACONDEF = 4;            !  Old size name - synonym
literal NSA$S_NSACON = 4;
literal NSA$S_SYSUAF_FIELDS = 8;
macro NSA$Q_SYSUAF_FIELDS = 0,0,0,0 %;  !  SYSUAF flags:
macro NSA$V_SYSUAF_ACCESS = 0,0,1,0 %;  !   ACCESS modified (obsolete)
macro NSA$V_SYSUAF_ACCOUNT = 0,1,1,0 %; !   ACCOUNT modified
macro NSA$V_SYSUAF_ASTLM = 0,2,1,0 %;   !   ASTLM modified
macro NSA$V_SYSUAF_BATCH = 0,3,1,0 %;   !   BATCH modified
macro NSA$V_SYSUAF_BIOLM = 0,4,1,0 %;   !   BIOLM modified
macro NSA$V_SYSUAF_BYTLM = 0,5,1,0 %;   !   BYTLM modified
macro NSA$V_SYSUAF_CLI = 0,6,1,0 %;     !   CLI modified
macro NSA$V_SYSUAF_CLITABLES = 0,7,1,0 %; !   CLITABLES modified
macro NSA$V_SYSUAF_CPUTIME = 0,8,1,0 %; !   CPUTIME modified
macro NSA$V_SYSUAF_DEFPRIVILEGES = 0,9,1,0 %; !   DEFPRIVILEGES modified
macro NSA$V_SYSUAF_DEVICE = 0,10,1,0 %; !   DEVICE modified
macro NSA$V_SYSUAF_DIALUP = 0,11,1,0 %; !   DIALUP modified
macro NSA$V_SYSUAF_DIOLM = 0,12,1,0 %;  !   DIOLM modified
macro NSA$V_SYSUAF_DIRECTORY = 0,13,1,0 %; !   DIRECTORY modified
macro NSA$V_SYSUAF_ENQLM = 0,14,1,0 %;  !   ENQLM modified
macro NSA$V_SYSUAF_EXPIRATION = 0,15,1,0 %; !   EXPIRATION modified
macro NSA$V_SYSUAF_FILLM = 0,16,1,0 %;  !   FILLM modified
macro NSA$V_SYSUAF_FLAGS = 0,17,1,0 %;  !   FLAGS modified
macro NSA$V_SYSUAF_INTERACTIVE = 0,18,1,0 %; !   INTERACTIVE modified (obsolete)
macro NSA$V_SYSUAF_JTQUOTA = 0,19,1,0 %; !   JTQUOTA modified
macro NSA$V_SYSUAF_LGICMD = 0,20,1,0 %; !   LGICMD modified
macro NSA$V_SYSUAF_LOCAL = 0,21,1,0 %;  !   LOCAL modified
macro NSA$V_SYSUAF_MAXDETACH = 0,22,1,0 %; !   MAXDETACH modified
macro NSA$V_SYSUAF_MAXJOBS = 0,23,1,0 %; !   MAXJOBS modified
macro NSA$V_SYSUAF_MAXACCTJOBS = 0,24,1,0 %; !   MAXACCTJOBS modified
macro NSA$V_SYSUAF_NETWORK = 0,25,1,0 %; !   NETWORK modified
macro NSA$V_SYSUAF_OWNER = 0,26,1,0 %;  !   OWNER modified
macro NSA$V_SYSUAF_PASSWORD = 0,27,1,0 %; !   PASSWORD modified
macro NSA$V_SYSUAF_PBYTLM = 0,28,1,0 %; !   PBYTLM modified
macro NSA$V_SYSUAF_PFLAGS = 0,29,1,0 %; !   PFLAGS modified (obsolete)
macro NSA$V_SYSUAF_P_RESTRICT = 0,30,1,0 %; !   P_RESTRICT modified (obsolete)
macro NSA$V_SYSUAF_PGFLQUOTA = 0,31,1,0 %; !   PGFLQUOTA modified
macro NSA$V_SYSUAF_PRCLM = 4,0,1,0 %;   !   PRCLM modified
macro NSA$V_SYSUAF_PRIMEDAYS = 4,1,1,0 %; !   PRIMEDAYS modified
macro NSA$V_SYSUAF_PRIORITY = 4,2,1,0 %; !   PRIORITY modified
macro NSA$V_SYSUAF_PRIVILEGES = 4,3,1,0 %; !   PRIVILEGES modified
macro NSA$V_SYSUAF_PWDLIFETIME = 4,4,1,0 %; !   PWDLIFETIME modified
macro NSA$V_SYSUAF_PWDMINIMUM = 4,5,1,0 %; !   PWDMINIMUM modified
macro NSA$V_SYSUAF_QUEPRIORITY = 4,6,1,0 %; !   QUEPRIORITY modified
macro NSA$V_SYSUAF_REMOTE = 4,7,1,0 %;  !   REMOTE modified
macro NSA$V_SYSUAF_SFLAGS = 4,8,1,0 %;  !   SFLAGS modified (obsolete)
macro NSA$V_SYSUAF_S_RESTRICT = 4,9,1,0 %; !   S_RESTRICT modified (obsolete)
macro NSA$V_SYSUAF_SHRFILLM = 4,10,1,0 %; !   SHRFILLM modified
macro NSA$V_SYSUAF_TQELM = 4,11,1,0 %;  !   TQELM modified
macro NSA$V_SYSUAF_UIC = 4,12,1,0 %;    !   UIC modified
macro NSA$V_SYSUAF_WSDEFAULT = 4,13,1,0 %; !   WSDEFAULT modified
macro NSA$V_SYSUAF_WSEXTENT = 4,14,1,0 %; !   WSEXTENT modified
macro NSA$V_SYSUAF_WSQUOTA = 4,15,1,0 %; !   WSQUOTA modified
macro NSA$V_SYSUAF_ENCRYPT = 4,16,1,0 %; !   PRIMARY password hash algorithm modified
macro NSA$V_SYSUAF_ENCRYPT2 = 4,17,1,0 %; !   SECONDARY password hash algorithm modified
macro NSA$V_SYSUAF_SALT = 4,18,1,0 %;   !   SALT modified
macro NSA$V_SYSUAF_PASSWORD2 = 4,19,1,0 %; !   Secondary PASSWORD modified
macro NSA$V_SYSUAF_PWD_DATE = 4,20,1,0 %; !   Password expiration date
macro NSA$V_SYSUAF_PWD2_DATE = 4,21,1,0 %; !   Secondary password expiration date
macro NSA$V_SYSUAF_LOGFAILS = 4,22,1,0 %; !   LOGFAILS modified
macro NSA$V_SYSUAF_LASTLOGIN_I = 4,23,1,0 %; !   LASTLOGIN_I modified
macro NSA$V_SYSUAF_LASTLOGIN_N = 4,24,1,0 %; !   LASTLOGIN_N modified
macro NSA$V_SYSUAF_MIN_CLASS = 4,25,1,0 %; !   MIN_CLASS modified
macro NSA$V_SYSUAF_MAX_CLASS = 4,26,1,0 %; !   MAX_CLASS modified
macro NSA$V_SYSUAF_USER_DATA = 4,27,1,0 %; !   user data area modified
macro NSA$V_SYSUAF_DEF_CLASS = 4,28,1,0 %; !   DEF_CLASS modified
literal NSA$S_FIELD_TBL_ENTRY = 16;
macro NSA$L_FLD_NAME = 0,0,32,0 %;      !  Address of ascid field name
macro NSA$W_FLD_OFFSET = 4,0,16,0 %;    !  Offset into record
macro NSA$W_FLD_SIZE = 6,0,16,0 %;      !  Size of field
macro NSA$L_FLD_FMT_RTN = 8,0,32,1 %;   !  Format routine
macro NSA$L_FLD_FMT_P1 = 12,0,32,0 %;   !  Parameter to format rtn
literal NSA$M_SUM_FILE = %X'1';
literal NSA$M_SUM_PRIV = %X'2';
literal NSA$M_SUM_DEJAVU = %X'80000000';
literal NSA$S_NSASUMMARYBITS = 4;
macro NSA$V_SUM_FILE = 0,0,1,0 %;       !  file access auditing enabled
macro NSA$V_SUM_PRIV = 0,1,1,0 %;       !  privilege auditing enabled
macro NSA$V_SUM_DEJAVU = 0,31,1,0 %;    !  auditing running in past
 
!*** MODULE $NSAFAIDEF ***
! 
!  Define the security auditing failure mode vectors.
! 
literal NSA$M_FAIL_WAIT = %X'1';
literal NSA$M_FAIL_CRASH = %X'2';
literal NSA$M_FAIL_IGNORE = %X'4';
literal NSA$M_MSG_LOST = %X'1';
literal NSA$C_FAI_LENGTH = 12;
literal NSA$K_FAI_LENGTH = 12;
literal NSA$S_NSAFAIDEF = 12;
literal NSA$S_NSAFAI = 12;
macro NSA$W_FAILURE_MODE = 0,0,16,0 %;
macro NSA$V_FAIL_WAIT = 0,0,1,0 %;      !  Wait for resources
macro NSA$V_FAIL_CRASH = 0,1,1,0 %;     !  Crash the system
macro NSA$V_FAIL_IGNORE = 0,2,1,0 %;    !  Drop failed audits
macro NSA$W_FAILURE_FLAGS = 2,0,16,0 %;
macro NSA$V_MSG_LOST = 2,0,1,0 %;       !  Alarms lost message written?
macro NSA$L_LOST_COUNT = 4,0,32,0 %;    !  Failure count
macro NSA$W_SIZE = 8,0,16,0 %;          !  Stucture size
macro NSA$B_TYPE = 10,0,8,0 %;          !  Structure type (DYN$C_NSA)
macro NSA$B_SUBTYPE = 11,0,8,0 %;       !  Structure subtype (DYN$C_NSA_FAILURE)
 
!*** MODULE $NSAIDTDEF ***
! +
!  Security Auditing Impure Data Table offset definitions
! -
literal NSA$C_IDT_LENGTH = 4794;
literal NSA$K_IDT_LENGTH = 4794;
literal NSA$K_IDT_PAGES = 10;           !  Number of pages for IDT
literal NSA$S_NSAIDTDEF = 4794;
literal NSA$S_NSAIDT = 4794;
macro NSA$T_IDT_ALARM_HDR = 0,0,0,0 %;
literal NSA$S_IDT_ALARM_HDR = 46;       !  Alarm header buffer
macro NSA$T_IDT_RECORD_BUF = 46,0,0,0 %;
literal NSA$S_IDT_RECORD_BUF = 1024;    !  Record buffer
macro NSA$Q_IDT_RECORD_DESCR = 1070,0,0,0 %;
literal NSA$S_IDT_RECORD_DESCR = 8;     !  Record buffer descriptor
macro NSA$T_IDT_RECORD_DT = 1078,0,0,0 %;
literal NSA$S_IDT_RECORD_DT = 128;      !  Record descriptor table
!  audit journal channel number)
 
!*** MODULE $NSAIFPDEF ***
literal NSAP$M_MANDATORY = %X'1';
literal NSAP$M_PRIVMASK = %X'2';
literal NSAP$M_PROCPRIV = %X'4';
literal NSAP$M_AUTHPRIV = %X'8';
literal NSAP$M_AUDIT = %X'10';
literal NSAP$M_ALTPRIV = %X'20';
literal NSAP$M_IDENTIFIER = %X'40';
literal NSAP$M_INTERNAL = %X'80';
literal NSAP$M_IMAGEID = %X'100';
literal NSAP$M_ONEBIT = %X'200';
literal NSAP$M_NOPROBE = %X'400';
literal NSAP$M_FLUSH = %X'800';
literal NSAP$M_SERVER = %X'1000';
literal NSAP$M_NOFAILAUD = %X'2000';
literal NSAP$M_NOSUCCAUD = %X'4000';
literal NSAP$K_LENGTH = 28;             !  size of input potion of control block
literal NSAP$S_NSAIFPDEF = 28;
literal NSAP$S_NSAIFP = 28;
macro NSAP$L_FLAGS = 0,0,32,0 %;
macro NSAP$V_MANDATORY = 0,0,1,0 %;     !  force privilege audit
macro NSAP$V_PRIVMASK = 0,1,1,0 %;      !  caller supplied address of privilege mask
macro NSAP$V_PROCPRIV = 0,2,1,0 %;      !  check permanent privilege mask
macro NSAP$V_AUTHPRIV = 0,3,1,0 %;      !  check authorized privilege mask
macro NSAP$V_AUDIT = 0,4,1,0 %;         !  privilege audit required
macro NSAP$V_ALTPRIV = 0,5,1,0 %;       !  check alternate mask supplied by caller
macro NSAP$V_IDENTIFIER = 0,6,1,0 %;    !  check identifier instead of privilege
macro NSAP$V_INTERNAL = 0,7,1,0 %;      !  privilege check being performed on behalf of TCB
macro NSAP$V_IMAGEID = 0,8,1,0 %;       !  identifier was located in image rights list segment
macro NSAP$V_ONEBIT = 0,9,1,0 %;        !  privilege mask contained only a single bit
macro NSAP$V_NOPROBE = 0,10,1,0 %;      !  do not probe item list
macro NSAP$V_FLUSH = 0,11,1,0 %;        !  force audit server buffer flush
macro NSAP$V_SERVER = 0,12,1,0 %;       !  audit from trusted (TCB) server
macro NSAP$V_NOFAILAUD = 0,13,1,0 %;    !  do not audit failures
macro NSAP$V_NOSUCCAUD = 0,14,1,0 %;    !  do not audit success
macro NSAP$L_AUDIT_MASK = 4,0,32,0 %;   !  audit mask (NSA$W_FLAGS)
macro NSAP$L_AUDIT_LIST = 8,0,32,1 %;   !  address of optional audit message itemlist
macro NSAP$L_MESSAGE = 12,0,32,0 %;     !  privilege audit message code ($NSA)
macro NSAP$L_AUDSTS = 12,0,32,0 %;      !  privilege audit return status
macro NSAP$Q_ALTPRIV = 16,0,0,0 %;
literal NSAP$S_ALTPRIV = 8;             !  alternate privilege mask to check
macro NSAP$Q_PRIV = 16,0,0,0 %;
literal NSAP$S_PRIV = 8;                !  mask of privileges that were checked (success)
macro NSAP$Q_AUDPRIV = 16,0,0,0 %;
literal NSAP$S_AUDPRIV = 8;             !  mask of privileges to audit (success/failure)
macro NSAP$Q_FAILPRIV = 16,0,0,0 %;
literal NSAP$S_FAILPRIV = 8;            !  mask of privileges that caller lacked (failure)
macro NSAP$L_IDENTIFIER = 16,0,32,0 %;  !  identifier to check
macro NSAP$L_REPLY_MAILBOX = 24,0,32,1 %; !  reply mailbox descriptor address
 
!*** MODULE $NSASDEF ***
!  Define the layout of the structure returned by NSA$SIZE_NSAB.
literal NSAS$M_NOALARM = %X'1';
literal NSAS$M_NOAUDIT = %X'2';
literal NSAS$M_NOPROBE = %X'4';
literal NSAS$M_PRIVS_SUPPLIED = %X'8';
literal NSAS$K_MAX_JOURNALS = 1;        !  maximum number of alarm or audit journals
literal NSAS$K_LENGTH = 76;             !  define length of structure
literal NSAS$S_NSASDEF = 76;            !  Old size name - synonym
literal NSAS$S_NSAS = 76;
macro NSAS$L_SIZE = 0,0,32,0 %;         !  size of required packet list
macro NSAS$L_SUPPLIED = 4,0,32,0 %;     !  supplied packet mask
macro NSAS$L_EVENT = 8,0,32,0 %;        !  event type/subtype as longword
macro NSAS$W_EVENT_TYPE = 8,0,16,0 %;   !  event type
macro NSAS$W_EVENT_SUBTYPE = 10,0,16,0 %; !  event subtype
macro NSAS$L_FACILITY = 12,0,32,0 %;    !  event facility
macro NSAS$L_FLAGS = 16,0,32,0 %;       !  flags
macro NSAS$V_NOALARM = 16,0,1,0 %;      !  do not copy alarm packets
macro NSAS$V_NOAUDIT = 16,1,1,0 %;      !  do not copy audit packets
macro NSAS$V_NOPROBE = 16,2,1,0 %;      !  do not probe item list
macro NSAS$V_PRIVS_SUPPLIED = 16,3,1,0 %; !  did the caller supply a priv mask
!  or identifier list? 
macro NSAS$L_ACCESS_DESIRED = 20,0,32,0 %; !  actual access desired
macro NSAS$L_PRIVS_USED = 24,0,32,0 %;  !  actual privs used (as longword)
macro NSAS$Q_PRIVS_USED = 24,0,0,0 %;
literal NSAS$S_PRIVS_USED = 8;          !  actual privs used (as quadword)
macro NSAS$L_ALARM_COUNT = 32,0,32,0 %; !  number of alarm journals present
macro NSAS$L_AUDIT_COUNT = 36,0,32,0 %; !  number of audit journals present
macro NSAS$L_MIN_CLASS_ADDR = 40,0,32,1 %; !  address of min. class mask
macro NSAS$L_MAX_CLASS_ADDR = 44,0,32,1 %; !  address of max. class mask
macro NSAS$Q_OBJECT_CLASS = 48,0,0,0 %;
literal NSAS$S_OBJECT_CLASS = 8;        !  object class name descriptor
macro NSAS$R_CLASS_DESC = 48,0,0,0 %;
literal NSAS$S_CLASS_DESC = 8;
macro NSAS$W_CLASS_LENGTH = 48,0,16,0 %; !  object class name length
macro NSAS$L_CLASS_ADDR = 52,0,32,1 %;  !  object class name buffer address
macro NSAS$Q_ALARM_LIST = 56,0,0,0 %;
literal NSAS$S_ALARM_LIST = 8;          !  array of alarm journals descriptors
macro NSAS$Q_AUDIT_LIST = 64,0,0,0 %;
literal NSAS$S_AUDIT_LIST = 8;          !  array of audit journals descriptors
macro NSAS$L_FINAL_STATUS = 72,0,32,0 %; !  actual final status
 
!*** MODULE $NTEDEF ***
! +
!  NOTIFICATION TABLE ENTRY DEFINITIONS
! 
!  NOTIFICATION TABLE ENTRIES ARE USED BY THE NOTIFICATION MODULE ROUTINES. 
!  EACH ENTRY STORES THE INFORMATION NEEDED FOR A SINGLE NOTIFICATION. THE
!  SYSTEM MAINTAINS TWO TABLES OF SUCH ENTRIES, ONE EACH FOR JOIN NOTIFICATION
!  AND REMOVAL NOTIFICATION.
! 
! -
literal NTE$K_LENGTH = 12;              !  LENGTH OF AN ENTRY 
literal NTE$C_LENGTH = 12;              !  LENGTH OF AN ENTRY
literal NTE$S_NTEDEF = 12;
literal NTE$S_NTE = 12;
macro NTE$L_NOTIFN_LIST_HDR = 0,0,32,0 %;
macro NTE$W_NOTIFNEFL = 0,0,16,0 %;     !  INDEX OF FIRST NOTIFICATION ENTRY ON THE TABLE
macro NTE$W_NOOFENT = 2,0,16,0 %;       !  NUMBER OF ENTRIES IN THE TABLE
macro NTE$L_NOTIFN_ID = 0,0,32,0 %;
macro NTE$W_LINK = 0,0,16,0 %;          !  LINK TO THE NEXT ENTRY ON THE LIST
macro NTE$W_SEQNO = 2,0,16,0 %;         !  SEQUENCE NUMBER OF THIS ENTRY
macro NTE$L_ROUTINE_ADDRESS = 4,0,32,1 %; !  ADDRESS OF ROUTINE TO BE CALLED DURING NOTIFICATION 
macro NTE$L_FREE_LIST_HDR = 4,0,32,0 %;
macro NTE$W_FREEFL = 4,0,16,0 %;        !  INDEX OF FIRST FREE ENTRY ON THE TABLE
macro NTE$L_NOTIFN_PARAM = 8,0,32,0 %;  !  PARAMETER TO BE PASSED TO THE ROUTINE
macro NTE$L_TYPE_DEFN = 8,0,32,0 %;
macro NTE$W_SIZE = 8,0,16,0 %;          !  SIZE OF THE TABLE
macro NTE$B_TYPE = 10,0,8,0 %;          !  TYPE OF THE DATA STRUCTURE
macro NTE$B_SUBTYPE = 11,0,8,0 %;       !  SUBTYPE OF THE DATA STRUCTURE
 
!*** MODULE $OCBDEF ***
! +
!  OCB - Object Class Block
! 
!  This structures contains information about a security Object
!  Class Block.
! 
! -
literal OCB$M_ACC_BITS_ALLOC = %X'1';
literal OCB$M_IMP_GRP_NAMING = %X'2';
literal OCB$M_CREATE = %X'4';
literal OCB$M_DEACCESS = %X'8';
literal OCB$M_DELETE = %X'10';
literal OCB$K_LENGTH = 203;             !  Length of structure
literal OCB$S_OCBDEF = 203;             !  Old size name - synonym    
literal OCB$S_OCB = 203;
macro OCB$L_FLINK = 0,0,32,1 %;         !  Forward link
macro OCB$L_BLINK = 4,0,32,1 %;         !  Backward link
macro OCB$L_SIZE = 8,0,32,0 %;          !  Allocation size
macro OCB$L_TYPE = 12,0,32,0 %;         !  Structure type
macro OCB$L_SUBTYPE = 16,0,32,0 %;      !  Subtype
macro OCB$L_FLAGS = 20,0,32,0 %;        !  Processing flags
macro OCB$V_ACC_BITS_ALLOC = 20,0,1,0 %; !  Bitname XLATE allocated
macro OCB$V_IMP_GRP_NAMING = 20,1,1,0 %; !  Implicit group namespace
macro OCB$V_CREATE = 20,2,1,0 %;        !  Object class supports creation auditing
macro OCB$V_DEACCESS = 20,3,1,0 %;      !  Object class supports deaccess auditing
macro OCB$V_DELETE = 20,4,1,0 %;        !  Object class supports deletion auditing (devices)
macro OCB$L_OBJECT_TYPE = 24,0,32,0 %;  !  Object type value
macro OCB$L_CLASS_ORB = 28,0,32,0 %;    !  Class rights block
macro OCB$L_DEFAULT_ORB = 32,0,32,0 %;  !  Default rights block
macro OCB$L_ACCESS_BITNAMES = 36,0,32,1 %; !  Ptr to access bitnames
macro OCB$L_SUPPORT_RTNS = 40,0,32,1 %; !  Ptr to support rtns dispatch
macro OCB$AR_ACC_AUDITS = 44,0,32,1 %;  !  Ptr to access audits
macro OCB$AR_ACC_ALARMS = 48,0,32,1 %;  !  Ptr to access alarms
macro OCB$L_ACCESS_MODES = 52,0,32,0 %; !  Mask of valid access modes 
macro OCB$L_ACC_BITNAME_SIZE = 60,0,32,0 %; !  Size of pool for bitname table
macro OCB$L_ACC_BITNAME_LENGTH = 64,0,32,0 %; !  Length of access bitname table
! 
macro OCB$T_ACCESS_AUDITS = 68,0,0,0 %;
literal OCB$S_ACCESS_AUDITS = 48;       !  Access audits
macro OCB$T_ACCESS_ALARMS = 116,0,0,0 %;
literal OCB$S_ACCESS_ALARMS = 48;       !  Access alarms
! 
macro OCB$L_NAME_LENGTH = 164,0,32,0 %; !  Length of class name
macro OCB$AR_CLASS_PROT_ALARMS = 172,0,32,1 %; !  Ptr to class alarms
macro OCB$AR_CLASS_PROT_AUDITS = 176,0,32,1 %; !  Ptr to class audits
macro OCB$T_NAME = 180,0,0,0 %;
literal OCB$S_NAME = 23;                !  Class name string
 
!*** MODULE $OLCKDEF ***
! +
!  OLCK - ORB LOCK
! 
!  This structures contains information about an outstanding LOCK
!  on the Object Rights Block of a specific resourse.  It is
!  maintained in a per process database (CTL$GQ_ORB_LOCKDB) used
!  to control ACL modifications through $CHANGE_ACL.
! 
! -
literal OLCK$M_RESV_1 = %X'1';
literal OLCK$K_FIXED_LEN = 30;          !  Fixed length 
literal OLCK$K_MAX_RSN = 33;            !  Maximum resource name
literal OLCK$S_OLCKDEF = 30;            !  Old size name - synonym
literal OLCK$S_OLCK = 30;
macro OLCK$L_FLINK = 0,0,32,1 %;        !  Forward link
macro OLCK$L_BLINK = 4,0,32,1 %;        !  Backward link
macro OLCK$W_SIZE = 8,0,16,0 %;         !  Allocation size
macro OLCK$B_TYPE = 10,0,8,0 %;         !  Structure type
macro OLCK$B_STYPE = 11,0,8,0 %;        !  Subtype
macro OLCK$L_LOCKID = 12,0,32,0 %;      !  Lockid
macro OLCK$B_PRV_LKMODE = 16,0,8,0 %;   !  Previous lock mode
macro OLCK$B_CUR_LKMODE = 17,0,8,0 %;   !  Current lock mode
macro OLCK$W_FLAGS = 18,0,16,0 %;       !  Processing flags
macro OLCK$V_RESV_1 = 18,0,1,0 %;       !  reserved for future
macro OLCK$L_RESV_1 = 20,0,32,0 %;      !  Reserved 
macro OLCK$L_RESV_2 = 24,0,32,0 %;      !     for future use
macro OLCK$W_RSN_SIZE = 28,0,16,0 %;    !  Size of resource name
macro OLCK$T_RSN = 30,0,0,0 %;          !  Resource name string
 
!*** MODULE $ORBDEF ***
! +
! 
!  Object's Rights Block - structure defining the protection information
!  for various objects within the system.
! 
! -
literal ORB$M_PROT_16 = %X'1';
literal ORB$M_ACL_QUEUE = %X'2';
literal ORB$M_MODE_VECTOR = %X'4';
literal ORB$M_NOACL = %X'8';
literal ORB$M_CLASS_PROT = %X'10';
literal ORB$M_NOAUDIT = %X'20';
literal ORB$M_MODE_VALID = %X'80';
literal ORB$M_PROFILE_LOCKED = %X'100';
literal ORB$M_INDIRECT_ACL = %X'200';
literal ORB$M_BOOTTIME = %X'400';
literal ORB$M_UNMODIFIED = %X'800';
literal ORB$M_DAMAGED = %X'1000';
literal ORB$M_TEMPLATE = %X'2000';
literal ORB$M_TRANSITION = %X'4000';
literal ORB$M_EXT_NAMEBLOCK = %X'8000';
literal ORB$K_LENGTH = 124;             !  Structure length
literal ORB$C_LENGTH = 124;             !  Structure length
literal ORB$K_DEVNAM_LENGTH = 64;       !  size of static device name
literal ORB$C_DEVNAM_LENGTH = 64;       !  size of static device name
literal ORB$S_ORBDEF = 125;             !  Old ORB size field for compatability
literal ORB$S_ORB = 125;
macro ORB$L_OWNER = 0,0,32,0 %;         !  Object's owner
macro ORB$W_UICMEMBER = 0,0,16,0 %;     !  Member number
macro ORB$W_UICGROUP = 2,0,16,0 %;      !  Group number
macro ORB$L_ACL_MUTEX = 4,0,32,0 %;     !  Mutex for this ACL
macro ORB$W_SIZE = 8,0,16,0 %;          !  Size of the ORB in bytes
macro ORB$B_TYPE = 10,0,8,0 %;          !  Structure type
macro ORB$B_SUBTYPE = 11,0,8,0 %;       !  Subtype of ORB block:
!  0 - normal ORB
!  1 - block used to contain a name (only)
macro ORB$W_FLAGS = 12,0,16,0 %;        !  System protection field
macro ORB$B_FLAGS_1 = 12,0,8,0 %;       !  first byte of flags
macro ORB$B_FLAGS_2 = 13,0,8,0 %;       !  second byte of flags
macro ORB$B_FLAGS = 12,0,8,0 %;         !  first byte of flags
macro ORB$V_PROT_16 = 12,0,1,0 %;       !  Use word not vector protection
macro ORB$V_ACL_QUEUE = 12,1,1,0 %;     !  (*temp*) remove at later time
macro ORB$V_MODE_VECTOR = 12,2,1,0 %;   !  Use vector not byte mode protection
macro ORB$V_NOACL = 12,3,1,0 %;         !  Object cannot have an ACL
macro ORB$V_CLASS_PROT = 12,4,1,0 %;    !  Security classification is valid
macro ORB$V_NOAUDIT = 12,5,1,0 %;       !  Do not perform $CHKPRO auditing
macro ORB$V_MODE_VALID = 12,7,1,0 %;    !  Access mode protection is valid
macro ORB$V_PROFILE_LOCKED = 12,8,1,0 %; !  Object locked, no modification allowed
!  The PROFILE_LOCKED flag is intended to be set when the profile cannot
!  reasonably be modified.  I.e., the protection of a volume set may only be
!  altered if the root volume of the set is mounted, though mounting a selected
!  volume from a volume set is supported.
macro ORB$V_INDIRECT_ACL = 12,9,1,0 %;  !  Use the ACL from the template
!   ORB (ORB$L_TEMPLATE)
macro ORB$V_BOOTTIME = 12,10,1,0 %;     !  ORB created prior to securty object init.
macro ORB$V_UNMODIFIED = 12,11,1,0 %;   !  ORB has not been explicitly modified
macro ORB$V_DAMAGED = 12,12,1,0 %;      !  Deny access to all but system (BADACL)
macro ORB$V_TEMPLATE = 12,13,1,0 %;     !  This orb is a template
macro ORB$V_TRANSITION = 12,14,1,0 %;   !  Profile content uncertain --
!   eg. cluster instantiation
macro ORB$V_EXT_NAMEBLOCK = 12,15,1,0 %; !  ORB name is store in a separate 'ORB' block
! 
macro ORB$W_REFCOUNT = 14,0,16,0 %;     !  Reference count
macro ORB$Q_MODE_PROT = 16,0,0,0 %;
literal ORB$S_MODE_PROT = 8;            !  Mode protection vector
macro ORB$L_MODE_PROTL = 16,0,32,0 %;   !  Low longword of vector
macro ORB$L_MODE_PROTH = 20,0,32,0 %;   !  High longword of vector
macro ORB$L_MODE = 16,0,32,0 %;         !  Simple access mode
macro ORB$L_SYS_PROT = 24,0,32,0 %;     !  System protection field
macro ORB$W_PROT = 24,0,16,0 %;         !  Standard SOGW protection
macro ORB$L_OWN_PROT = 28,0,32,0 %;     !  Owner protection field
macro ORB$L_GRP_PROT = 32,0,32,0 %;     !  Group protection field
macro ORB$L_WOR_PROT = 36,0,32,0 %;     !  World protection field
macro ORB$L_ACLFL = 40,0,32,1 %;        !  ACL queue forward link
macro ORB$L_ACL_COUNT = 40,0,32,0 %;    !  Count of ACL segments
macro ORB$L_ACLBL = 44,0,32,1 %;        !  ACL queue backward link
macro ORB$L_ACL_DESC = 44,0,32,1 %;     !  Address of ACL segment descriptor list
macro ORB$R_MIN_CLASS = 48,0,0,0 %;
literal ORB$S_MIN_CLASS = 20;
macro ORB$R_MAX_CLASS = 68,0,0,0 %;
literal ORB$S_MAX_CLASS = 20;
macro ORB$W_NAME_LENGTH = 88,0,16,0 %;  !  Length of object name
macro ORB$L_NAME_POINTER = 92,0,32,1 %; !  Pointer to object name
macro ORB$L_OCB = 96,0,32,1 %;          !  Pointer to Object Class Block
macro ORB$L_TEMPLATE_ORB = 100,0,32,1 %; !  Pointer to template ORB 
macro ORB$L_OBJECT_SPECIFIC = 104,0,32,0 %; !  Object class specific usage cell
macro ORB$L_ORIGINAL_ORB = 108,0,32,1 %; !  Pointer to another ORB 
macro ORB$L_UPDSEQ = 112,0,32,0 %;      !  Update sequence number
macro ORB$L_MUTEX_ADDRESS = 116,0,32,1 %; !  Address of mutex for CHKPRO
macro ORB$L_RESERVE2 = 120,0,32,0 %;    !  for future use
macro ORB$T_OBJECT_NAME = 124,0,8,0 %;  !  Start of object name
 
!*** MODULE $OSRDEF ***
! +
!  Object Support Routine flag definitions.
! 
!  This structure contains the flag definitions that are used
!  to control processing between the security object management
!  services and the Object Support Routines.  These are internal 
!  flags used within the services and should not be used in the 
!  system service interfaces.
! -
literal OSR$M_ACCESS_CHECKED = %X'1';
literal OSR$M_MOD_MAC = %X'2';
literal OSR$M_NO_LOCK_RSN = %X'4';
literal OSR$M_RUNDOWN = %X'8';
literal OSR$M_WRITE = %X'10';
literal OSR$M_MOD_ORB = %X'20';
literal OSR$M_MOD_ACL = %X'40';
literal OSR$M_MOD_FOR = %X'80';
literal OSR$M_KERNEL_SETITM = %X'100';
literal OSR$M_KERNEL_CLONE_PROFILE = %X'200';
literal OSR$M_KERNEL_UPDATE_PROFILE = %X'400';
literal OSR$M_KERNEL_RUNDOWN = %X'800';
literal OSR$M_KERNEL_CHECK_ACCESS = %X'1000';
literal OSR$M_KERNEL_TRANQUILITY = %X'2000';
literal OSR$M_KERNEL_FIXUP_BTIME_ORBS = %X'4000';
literal OSR$M_RELCTX = %X'8000';
literal OSR$M_SELECT_NAME = %X'10000';
literal OSR$M_SELECT_HANDLE = %X'20000';
literal OSR$M_EMBED_OBJNAM = %X'40000';
literal OSR$M_CLUSTER_OBJECT = %X'80000';
literal OSR$M_CONTEXT_NAME = %X'100000';
literal OSR$M_CLUSTER_NOTIFY = %X'200000';
literal OSR$M_TEMPORARY = %X'400000';
literal OSR$M_PERMANENT = %X'800000';
literal OSR$M_NEW_OBJECT = %X'1000000';
literal OSR$M_NO_CREATE = %X'2000000';
literal OSR$M_NO_MAC_DAC = %X'4000000';
literal OSR$M_NO_MAC_AUDIT = %X'8000000';
literal OSR$M_MO_MAC_RANGE = %X'10000000';
literal OSR$M_NO_MAC = %X'20000000';
literal OSR$S_OSRDEF = 4;               !  Old size name - synonym
literal OSR$S_OSR = 4;
macro OSR$V_ACCESS_CHECKED = 0,0,1,0 %; !  Bypass chkpro in $xETSOI
macro OSR$V_MOD_MAC = 0,1,1,0 %;        !  Secrecy/integrity hanged
macro OSR$V_NO_LOCK_RSN = 0,2,1,0 %;    !  No need to build lock rsn in preprocess OSR
macro OSR$V_RUNDOWN = 0,3,1,0 %;        !  Rundown OSR call required for $xETSOI 
macro OSR$V_WRITE = 0,4,1,0 %;          !  Write operation $SETSOI
macro OSR$V_MOD_ORB = 0,5,1,0 %;        !  ORB (proper) was modified
macro OSR$V_MOD_ACL = 0,6,1,0 %;        !  ORB ACL was modified
macro OSR$V_MOD_FOR = 0,7,1,0 %;        !  Foreign char was modified
macro OSR$V_KERNEL_SETITM = 0,8,1,0 %;  !  Process set itmlist processing in k_mode
macro OSR$V_KERNEL_CLONE_PROFILE = 0,9,1,0 %; !  Call clone_profile OSR in k_mode
macro OSR$V_KERNEL_UPDATE_PROFILE = 0,10,1,0 %; !  Call update_profile OSR in k_mode
macro OSR$V_KERNEL_RUNDOWN = 0,11,1,0 %; !  Call rundown OSR in k_mode
macro OSR$V_KERNEL_CHECK_ACCESS = 0,12,1,0 %; !  Call check_access OSR in k_mode
macro OSR$V_KERNEL_TRANQUILITY = 0,13,1,0 %; !  Call set/clear trauility in K-mode
macro OSR$V_KERNEL_FIXUP_BTIME_ORBS = 0,14,1,0 %; !  Call fixup_btime_orbs OSR in k_mode
macro OSR$V_RELCTX = 0,15,1,0 %;        !  Release OSR context
macro OSR$V_SELECT_NAME = 0,16,1,0 %;   !  Select object by name
macro OSR$V_SELECT_HANDLE = 0,17,1,0 %; !  Select object by handle
macro OSR$V_EMBED_OBJNAM = 0,18,1,0 %;  !  Embed object name in ORB
macro OSR$V_CLUSTER_OBJECT = 0,19,1,0 %; !  Cluster visible object
macro OSR$V_CONTEXT_NAME = 0,20,1,0 %;  !  Use object name from context
!   for cluster distribution
macro OSR$V_CLUSTER_NOTIFY = 0,21,1,0 %; !  Cluster notification
!   (for volumes)
macro OSR$V_TEMPORARY = 0,22,1,0 %;     !  Temporary object
!  eg. foreign monted disk
macro OSR$V_PERMANENT = 0,23,1,0 %;     !  Not temporary 
macro OSR$V_NEW_OBJECT = 0,24,1,0 %;    !  Any existing profile is stale
macro OSR$V_NO_CREATE = 0,25,1,0 %;     !  Don't create a new profile.
macro OSR$V_NO_MAC_DAC = 0,26,1,0 %;    !  Concurrent MAC/DAC modifications
!   not supported
macro OSR$V_NO_MAC_AUDIT = 0,27,1,0 %;  !  Suppress $SET_SECURITY MAC audits
macro OSR$V_MO_MAC_RANGE = 0,28,1,0 %;  !  MAC range not supported
macro OSR$V_NO_MAC = 0,29,1,0 %;        !  MAC modifications not supported
! +
!   The OSR context area is an overlay of the UNC$S/T_OSR_CONTEXT area
!   in the universal context area structure ($UNCDEF).  If the size of
!   this area is larger then UNC$S_OSR_CONTEXT, you must enlarge the
!   universal context area defintion.  There are ASSUMEs in the ROUTINES
!   that allocate the context structure.
! -
literal OSRCTX$M_CLS_INIT = %X'1';
literal OSRCTX$M_CLS_TMPNAM = %X'2';
literal OSRCTX$M_LNT_INIT = %X'1';
literal OSRCTX$M_LNT_ACCESS_QUAL = %X'2';
literal OSRCTX$M_DEV_CHAN = %X'1';
literal OSRCTX$M_DEV_TEMPLATE = %X'2';
literal OSRCTX$M_DEV_ALL = %X'4';
literal OSRCTX$M_FIL_DEACCESS = %X'1';
literal OSRCTX$M_VOL_DEACCESS = %X'1';
literal OSRCTX$S_OSR_CTXDEF = 16;       !  Old size name - synonym
literal OSRCTX$S_OSR_CTX = 16;
macro OSRCTX$L_CLS_OCB = 0,0,32,1 %;    !  Original OCB
macro OSRCTX$L_CLS_FLAGS = 4,0,32,1 %;  !  Processing flags
macro OSRCTX$V_CLS_INIT = 4,0,1,0 %;    !  Initialized
macro OSRCTX$V_CLS_TMPNAM = 4,1,1,0 %;  !  Template present
macro OSRCTX$L_CLS_TMPNAM_LENGTH = 8,0,32,0 %; !  Template name length
macro OSRCTX$L_CLS_TMPNAM = 12,0,32,0 %; !  Template name
macro OSRCTX$L_LNT_FLAGS = 0,0,32,1 %;  !  Processing flags
macro OSRCTX$V_LNT_INIT = 0,0,1,0 %;    !  Initialized
macro OSRCTX$V_LNT_ACCESS_QUAL = 0,1,1,0 %; !  Access qualifier present
macro OSRCTX$B_LNT_ACCESS_MODE = 4,0,8,0 %; !  Access mode
macro OSRCTX$B_LNT_RESV_1 = 5,0,8,0 %;  !  Reserved for future
macro OSRCTX$W_LNT_OBJNAM_LEN = 6,0,16,0 %; !  LNT name (without access mode)
macro OSRCTX$L_LNT_RESV_2 = 8,0,32,0 %; !  Reserved for future
macro OSRCTX$L_LNT_RESV_3 = 12,0,32,0 %; !  Reserved for future
macro OSRCTX$L_CEF_RESV_1 = 0,0,32,0 %; !  Reserved
macro OSRCTX$L_CEF_RESV_2 = 4,0,32,0 %; ! 
macro OSRCTX$L_CEF_RESV_3 = 8,0,32,0 %; !     for
macro OSRCTX$W_CEF_RESV_4 = 12,0,16,0 %; ! 
macro OSRCTX$W_CEF_RESV_5 = 14,0,16,0 %; !     future use
macro OSRCTX$L_DEV_ORB = 0,0,32,1 %;    !  Active device ORB
macro OSRCTX$L_DEV_RESV_2 = 4,0,32,0 %; ! 
macro OSRCTX$L_DEV_RESV_3 = 8,0,32,0 %; ! 
macro OSRCTX$W_DEV_CHAN = 12,0,16,0 %;  !  channel #
macro OSRCTX$W_DEV_FLAGS = 14,0,16,1 %; !  processing flags
macro OSRCTX$V_DEV_CHAN = 14,0,1,0 %;   !  channel assigned by OSRs
macro OSRCTX$V_DEV_TEMPLATE = 14,1,1,0 %; !  dealing with template device
macro OSRCTX$V_DEV_ALL = 14,2,1,0 %;    !  devcie allocated by OSRs
macro OSRCTX$L_FIL_RESV_1 = 0,0,32,0 %; !  Reserved
macro OSRCTX$L_FIL_RESV_2 = 4,0,32,0 %; !    for
macro OSRCTX$L_FIL_RESV_3 = 8,0,32,0 %; !      future use
macro OSRCTX$W_FIL_CHANNEL = 12,0,16,0 %; ! 
macro OSRCTX$W_FIL_FLAGS = 14,0,16,1 %; !  File context flags
macro OSRCTX$V_FIL_DEACCESS = 14,0,1,0 %; !  Deaccess file at OSR rundown
macro OSRCTX$L_QUE_RESV_1 = 0,0,32,0 %; !  Reserved
macro OSRCTX$L_QUE_RESV_2 = 4,0,32,0 %; ! 
macro OSRCTX$L_QUE_RESV_3 = 8,0,32,0 %; !     for
macro OSRCTX$W_QUE_RESV_4 = 12,0,16,0 %; ! 
macro OSRCTX$W_QUE_RESV_5 = 14,0,16,0 %; !     future use
macro OSRCTX$L_PRC_RESV_1 = 0,0,32,0 %; !  Reserved
macro OSRCTX$L_PRC_RESV_2 = 4,0,32,0 %; ! 
macro OSRCTX$L_PRC_RESV_3 = 8,0,32,0 %; !     for
macro OSRCTX$W_PRC_RESV_4 = 12,0,16,0 %; ! 
macro OSRCTX$W_PRC_RESV_5 = 14,0,16,0 %; !     future use
macro OSRCTX$L_SEC_TRANQ_CNT = 0,0,32,0 %; !  Tranquility count (MAC)
macro OSRCTX$L_SEC_RESV_2 = 4,0,32,0 %; !  Reserved
macro OSRCTX$L_SEC_RESV_3 = 8,0,32,0 %; !     for
macro OSRCTX$W_SEC_RESV_4 = 12,0,16,0 %; ! 
macro OSRCTX$W_SEC_RESV_5 = 14,0,16,0 %; !     future use
macro OSRCTX$L_VOL_RESV_1 = 0,0,32,0 %; !  Reserved
macro OSRCTX$L_VOL_RESV_2 = 4,0,32,0 %; !    for
macro OSRCTX$L_VOL_RESV_3 = 8,0,32,0 %; !      future use
macro OSRCTX$W_VOL_CHANNEL = 12,0,16,0 %; ! 
macro OSRCTX$W_VOL_FLAGS = 14,0,16,1 %; !  Volume context flags
macro OSRCTX$V_VOL_DEACCESS = 14,0,1,0 %; !  Deassign channel at OSR rundown
macro OSRCTX$L_RSDM_DOMAIN = 0,0,32,0 %; !  Domain number
macro OSRCTX$L_RSDM_LOCKID = 4,0,32,0 %; !  Tranquility lock id (MAC)
macro OSRCTX$L_RSDM_RESV_3 = 8,0,32,0 %; !  Reserved
macro OSRCTX$W_RSDM_RESV_4 = 12,0,16,0 %; !   for
macro OSRCTX$W_RSDM_RESV_5 = 14,0,16,0 %; !     future use
 
!*** MODULE $OSRVDEF ***
! +
!  OSRV - Object Support Routine Vectors
! 
!  This structures contains information about the security Object
!  Support Routine dispatch Vectors.  It is through these dispatch
!  vectors that the various security subsystem components callout
!  to the object class specific functions.
! -
literal OSRV$K_LENGTH = 68;             !  Size of the vectors
literal OSRV$S_OSRVDEF = 68;
literal OSRV$S_OSRV = 68;
macro OSRV$L_ACCESS_EXCEPTION = 0,0,32,0 %; !   $CHKPRO access exception
macro OSRV$L_CLONE_PROFILE = 4,0,32,0 %; !   Clone object profile
macro OSRV$L_GET_ITEM = 8,0,32,0 %;     !   Get foreign item processing
macro OSRV$L_PREPROCESS = 12,0,32,0 %;  !   Preprocess (setup)
macro OSRV$L_RUNDOWN = 16,0,32,0 %;     !   Postprocessing (cleanup)
macro OSRV$L_SET_ITEM = 20,0,32,0 %;    !   Get foreign item processing
macro OSRV$L_UPDATE_PROFILE = 24,0,32,0 %; !   Update the object profile
macro OSRV$L_CHECK_ACCESS = 28,0,32,0 %; !   $CHECK_ACCESS routine
macro OSRV$L_FIXUP_BTIME_ORBS = 32,0,32,0 %; !   Fixup any boot time ORBs
macro OSRV$L_RESOLVE_ACL = 36,0,32,0 %; !   Fixup ACL indirection
macro OSRV$L_READ_PROFILE = 40,0,32,0 %; !   re-read profile from
!     backing store (volume support)
macro OSRV$L_SET_TRANQUILITY = 44,0,32,0 %; !   establish tranquility
macro OSRV$L_CLEAR_TRANQUILITY = 48,0,32,0 %; !   relinquish tranquility
macro OSRV$L_RESERVED_1 = 52,0,32,0 %;  !   reserved
macro OSRV$L_RESERVED_2 = 56,0,32,0 %;  !   reserved
macro OSRV$L_RESERVED_3 = 60,0,32,0 %;  !   reserved
macro OSRV$L_RESERVED_4 = 64,0,32,0 %;  !   reserved
 
!*** MODULE $OSSFLGDEF ***
! +
!  Security Object Information context flags definitions.
! 
!  This structure contains the flag definitions that are used
!  in ctl$gl_oss_flags
! 
! -
literal OSSFLG$M_RNDWN_DCLR = %X'1';
literal OSSFLG$S_OSSFLGDEF = 1;
literal OSSFLG$S_OSSFLG = 1;
macro OSSFLG$V_RNDWN_DCLR = 0,0,1,0 %;  !  Rundown handler declared
 
!*** MODULE $PBDEF ***
! +
!  PB - SCS PATH BLOCK
! 
!  THE PB HAS INFORMATION ABOUT THE PHYSICAL PATH TO ANOTHER
!  SYSTEM IN A CLUSTER.  PATH BLOCKS TO THE SAME SYSTEM ARE
!  LINKED TOGETHER TO THE SYSTEM BLOCK (SB).
! -
literal PB$C_CLOSED = 0;                !  NEWLY CREATED PATHBLOCK 
literal PB$C_ST_SENT = 1;               !  START SENT 
literal PB$C_ST_REC = 2;                !  START RECEIVED 
literal PB$C_OPEN = 3;                  !  OPEN PORT-PORT VIRTUAL CIRCUIT 
!  CI port virtual circuit failure states
literal PB$C_STALL_SETCKT = 4;          !   SETCKT stalled by pool problem
literal PB$C_CLOSE_CKT = 5;             !   SETCKT in progress
literal PB$C_NOTIFY_VCFAIL = 6;         !   SYSAP notification for failed VC in progress
literal PB$C_STALL_CACHE = 7;           !   Cache Clear stalled by pool problem
literal PB$C_CACHE_CLEAR = 8;           !   Cache Clear in progress
literal PB$C_NOTIFY_PWFAIL = 9;         !   SYSAP notification for failed port in progress
!  
literal PB$C_VC_FAIL = 32768;           !  VC FAILURE IN PROGRESS STATE  (No longer used for CI)
literal PB$C_PWR_FAIL = 16384;          !  PWR FAIL RECOVERY IN PROGRESS STATE (No longer used for CI)
literal PB$M_DUALPATH = %X'80000000';
literal PB$C_CI780 = 2;                 !  CI780 PORT
literal PB$C_CI750 = 2;                 !  CI750 PORT (=CI780)
literal PB$C_HSC = 4;                   !  HSC PORT
literal PB$C_KL10 = 6;                  !  KLIPA PORT
literal PB$C_CINT = 7;                  !  CI NODE TESTER
literal PB$C_NI = 8;                    !  NI-SCA (LAVC) PORT  
literal PB$C_PS = 9;                    !  PASSTHRU PORT
literal PB$C_BCA = 11;                  !  BI-CI PORT
literal PB$C_BVPSSP = 12;               !  BVP STORAGE PORT
literal PB$C_BVPNI = 13;                !  BVP NI PORT
literal PB$C_CIXCD = 14;                !  XMI-CI PORT CIXCD
literal PB$C_CIXCDAC = 16;              !  XMI-CI N_PORT ALPHA CIXCD
literal PB$C_CITCA = 17;
literal PB$C_CIPCA = 18;
literal PB$C_SII = 32;
literal PB$C_KFQSA = 33;
literal PB$C_SHAC = 34;
literal PB$C_XON = 35;
literal PB$C_SWIFT = 36;
literal PB$C_KFMSA = 37;
literal PB$C_N710 = 38;
literal PB$C_KFMSB = 39;
literal PB$C_RF70 = 48;
literal PB$C_RF71 = 48;
literal PB$C_RF30 = 49;
literal PB$C_RF31 = 50;
literal PB$C_RF72 = 51;
literal PB$C_RF32 = 52;
literal PB$C_RF73 = 53;
literal PB$C_RF31F = 54;
literal PB$C_RF35 = 55;
literal PB$C_RF36 = 58;
literal PB$C_RF37 = 59;
literal PB$C_RF74 = 60;
literal PB$C_RF75 = 61;
literal PB$C_TF70 = 64;
literal PB$C_TF30 = 65;
literal PB$C_TF85 = 65;
literal PB$C_TF86 = 66;
literal PB$C_HSJ = 80;
literal PB$C_HSD = 81;
literal PB$C_HSF = 82;
literal PB$C_EF51 = 96;
literal PB$C_EF52 = 97;
literal PB$C_EF53 = 98;
literal PB$C_EF54 = 99;
literal PB$C_EF58 = 100;
literal PB$M_SRSNTDATWM = %X'80';
literal PB$M_MAINT = %X'1';
literal PB$C_UNINIT = 0;                !  UNINITIALIZED, 
literal PB$C_DISAB = 1;                 !  DISABLED 
literal PB$C_ENAB = 2;                  !  ENABLED 
!  
literal PB$M_CUR_CBL = %X'1';
literal PB$M_CUR_PS = %X'1';
literal PB$M_TIM = %X'1';
literal PB$M_VCCHK_ENB = %X'2';
literal PB$M_SCS_EXP = %X'4';
literal PB$M_NEW_MSG = %X'8';
literal PB$M_UNUSED = %X'10';
literal PB$M_CREDIT = %X'20';
literal PB$M_DISC = %X'40';
literal PB$M_STORAGE = %X'80';
literal PB$K_LENGTH = 100;              ! LENGTH OF A PATH BLOCK 
literal PB$C_LENGTH = 100;              ! LENGTH OF A PATH BLOCK 
literal PB$S_PBDEF = 100;               ! Old size name - synonym    
literal PB$S_PB = 100;
macro PB$L_FLINK = 0,0,32,1 %;          ! FWD LINK TO NEXT PB 
macro PB$L_BLINK = 4,0,32,1 %;          ! BACK LINK TO PREVIOUS PB 
macro PB$W_SIZE = 8,0,16,0 %;           ! STRUCTURE SIZE IN BYTES 
macro PB$B_TYPE = 10,0,8,0 %;           ! SCS STRUCTURE TYPE 
macro PB$B_SUBTYP = 11,0,8,0 %;         ! SCS STRUCT SUBTYPE FOR PB 
macro PB$B_RSTATION = 12,0,0,0 %;
literal PB$S_RSTATION = 6;              ! REMOTE STATION ADDRESS 
macro PB$W_STATE = 18,0,16,0 %;         ! PATH STATE 
! STATE DEFINITIONS:
!  0 ORIGIN, INCREMENTS OF 1 
macro PB$L_RPORT_TYP = 20,0,32,0 %;     ! HARDWARE PORT TYPE CODE 
macro PB$V_PORT_TYP = 20,0,31,0 %;
literal PB$S_PORT_TYP = 31;             !  HARDWARE PORT TYPE, 
macro PB$V_DUALPATH = 20,31,1,0 %;      !  0/1 FOR SINGLE PATH/DUAL PATH PORT 
macro PB$L_RPORT_REV = 24,0,32,0 %;     ! REMOTE PORT HW REV LEVEL 
macro PB$V_RPORT_REV_SPARE = 24,0,30,0 %;
literal PB$S_RPORT_REV_SPARE = 30;      !  Spare
macro PB$V_RPORT_SPC_REV = 24,30,1,0 %; !  0 = -A / 1 = -B
macro PB$V_RPORT_REV_RESV1 = 24,31,1,0 %; !  Reserved
macro PB$L_RPORT_FCN = 28,0,32,0 %;     ! REMOTE PORT FUNCTION MASK
macro PB$V_MBZ = 28,0,7,0 %;
literal PB$S_MBZ = 7;                   !  reserved MBZ
macro PB$V_SRSNTDATWM = 28,7,1,0 %;     ! Send/Rec SNTDATWM (*not* in CI Port Arch)
macro PB$B_RST_PORT = 32,0,8,0 %;       ! OWNING PORT WHICH RESET REMOTE PORT 
macro PB$B_RSTATE = 33,0,8,0 %;         ! REMOTE PORT STATUS: 
macro PB$V_MAINT = 33,0,1,0 %;          !  0/1 FOR MAINTENANCE MODE NO/YES 
macro PB$V_STATE = 33,1,2,0 %;
literal PB$S_STATE = 2;                 !  REMOTE PORT STATE: 
!  DEFINE REMOTE STATES, 0 ORIGIN 
macro PB$W_RETRY = 34,0,16,0 %;         ! START HANDSHAKE RETRY COUNT 
macro PB$T_LPORT_NAME = 36,0,32,0 %;
literal PB$S_LPORT_NAME = 4;            ! LOCAL PORT DEVICE NAME 
macro PB$B_CBL_STS = 40,0,8,0 %;        ! CABLE STATUS TO THE REMOTE 
macro PB$V_CUR_CBL = 40,0,1,0 %;        !  1/0 FOR CURRENT STATUS OK/BAD 
macro PB$B_P0_STS = 41,0,8,0 %;         ! PATH 0 STATUS 
macro PB$B_P1_STS = 42,0,8,0 %;         ! PATH 1 STATUS 
macro PB$V_CUR_PS = 42,0,1,0 %;         !  1/0 FOR CURRENT STATUS OK/BROKEN 
macro PB$L_PDT = 44,0,32,1 %;           ! ADDR OF PORT DESCRIPTOR TABLE FOR 
!  LOCAL PORT
macro PB$L_SBLINK = 48,0,32,1 %;        ! LINK TO SYSTEM BLOCK
macro PB$L_CDTLST = 52,0,32,1 %;        ! LINK TO FIRST CDT OVER THIS PATH 
!  (0 IF NO CDT'S)
macro PB$L_WAITQFL = 56,0,32,1 %;       !  SCS SEND MSG WAIT QUEUE FLINK
macro PB$L_WAITQBL = 60,0,32,1 %;       ! SCS SEND MSG WAIT QUEUE BLINK 
macro PB$L_DUETIME = 60,0,32,0 %;       ! START HANDSHAKE TIMER 
macro PB$L_SCSMSG = 64,0,32,1 %;        ! ADDR OF SCS MESSAGE BUFFER 
macro PB$W_STS = 68,0,16,0 %;           ! PATH BLOCK STATUS 
macro PB$V_TIM = 68,0,1,0 %;            !  HANDSHAKE TIMEOUT IN PROGRESS 
macro PB$V_VCCHK_ENB = 68,1,1,0 %;      !  VC timeout checking enabled
macro PB$V_SCS_EXP = 68,2,1,0 %;        !  SCS message expected during timeout period
macro PB$V_NEW_MSG = 68,3,1,0 %;        !  New message arrived during timeout period
macro PB$V_UNUSED = 68,4,1,0 %;         !  Unused bit
macro PB$V_CREDIT = 68,5,1,0 %;         !  SCS receive credit on free queue
macro PB$V_DISC = 68,6,1,0 %;           !  SCS disconnect request is in progress
macro PB$V_STORAGE = 68,7,1,0 %;        !  Storage only port (A DSSA port)
macro PB$W_VCFAIL_RSN = 70,0,16,0 %;    ! VC FAILURE REASON (VMS
! STATUS CODE
macro PB$B_PROTOCOL = 72,0,8,0 %;       ! PPD PROTOCOL LEVEL
macro PB$L_RPORT_MULT = 76,0,32,0 %;    ! LARGEST PACKET MULTIPLE OF THE REMOTE PORT (CI ONLY)
!  SHIFTED TO BIT POSITION <30:28> 
macro PB$L_TIME_STAMP = 80,0,32,0 %;    !  (TYC 9-Mar-89) PB INSERTION TO CONFIG. DB TIME STAMP
macro PB$L_SHARE_FLINK = 84,0,32,1 %;   !  (TYC 15-Feb-89) FWD LINK TO NEXT PB IN LOAD SHARE QUEUE
macro PB$L_SHARE_BLINK = 88,0,32,1 %;   !  (TYC 15-Feb-89) BACK LINK TO PREVIOUS PB IN LOAD SHARE QUEUE
 
!*** MODULE $PBHDEF ***
! +
!  DEFINE PERFORMANCE BUFFER HEADER
! -
literal PBH$K_START = 13;               ! START OF DATA AREA 
literal PBH$C_START = 13;               ! START OF DATA AREA 
literal PBH$K_LENGTH = 512;             ! LENGTH OF PERFORMANCE DATA BUFFER 
literal PBH$C_LENGTH = 512;             ! LENGTH OF PERFORMANCE DATA BUFFER 
literal PBH$S_PBHDEF = 512;
literal PBH$S_PBH = 512;
macro PBH$L_BUFRFL = 0,0,32,1 %;        ! BUFFER FORWARD LINK 
macro PBH$L_BUFRBL = 4,0,32,1 %;        ! BUFFER BACKWARD LINK 
macro PBH$W_SIZE = 8,0,16,0 %;          ! SIZE OF PERFORMANCE DATA BUFFER 
macro PBH$B_TYPE = 10,0,8,0 %;          ! DATA STRUCTURE TYPE 
macro PBH$W_MSGCNT = 11,0,16,0 %;       ! COUNT OF MESSAGES IN BUFFER 
 
!*** MODULE $PBODEF ***
! +
!  PBO - SCS$CONFIG_PTH CALL OUTPUT ARRAY FORMAT
! 
!  THE OUTPUT ARRAY RETURNED FROM THE SCS$CONFIG_PTH CALL.  DATA IS MOSTLY COPIED
!  FROM THE PATH BLOCK (PB) BEING LOOKED UP.
! -
literal PBO$M_SRSNTDATWM = %X'80';
literal PBO$C_NXT_VC = 32;              ! SPECIFIER OF NEXT VC (PB)
literal PBO$K_NXT_VC = 32;              !  TO THIS SYSTEM (12 BYTE
!  SPECIFIER FOLLOWS:)
literal PBO$C_LENGTH = 52;              ! LENGTH OF PBO
literal PBO$K_LENGTH = 52;              ! LENGTH OF PBO
literal PBO$S_PBODEF = 52;              !  Old size name - synonym
literal PBO$S_PBO = 52;
macro PBO$B_RSTATION = 0,0,0,0 %;
literal PBO$S_RSTATION = 6;             ! REMOTE STATION ADDR
macro PBO$W_STATE = 6,0,16,0 %;         ! PATH STATE
macro PBO$L_RPORT_TYP = 8,0,32,0 %;     ! REMOTE PORT HW PORT TYPE
macro PBO$L_RPORT_REV = 12,0,32,0 %;    ! REMOTE PORT REV LEVEL
macro PBO$L_RPORT_FCN = 16,0,32,0 %;    ! REMOTE PORT FUNCTION MASK
macro PBO$V_MBZ = 16,0,7,0 %;
literal PBO$S_MBZ = 7;                  !  reserved MBZ
macro PBO$V_SRSNTDATWM = 16,7,1,0 %;    ! Send/Rec SNTDATWM (*not* in CI Port Arch)
macro PBO$B_RST_PORT = 20,0,8,0 %;      ! OWNING PORT WHICH LAST
!  RESET THIS REMOTE
macro PBO$B_RSTATE = 21,0,8,0 %;        ! REMOTE PORT STATE
macro PBO$W_RETRY = 22,0,16,0 %;        ! START HANDSHAKE RETRIES LEFT
macro PBO$T_LPORT_NAME = 24,0,32,0 %;
literal PBO$S_LPORT_NAME = 4;           ! LOCAL PORT DEVICE NAME
macro PBO$B_CBL_STS = 28,0,8,0 %;       ! CURRENT CABLE STATUS
macro PBO$B_P0_STS = 29,0,8,0 %;        ! PATH 0 STATUS
macro PBO$B_P1_STS = 30,0,8,0 %;        ! PATH 1 STATUS
macro PBO$B_NXT_RSTAT = 32,0,0,0 %;
literal PBO$S_NXT_RSTAT = 6;            !  REMOTE STATION ADDR
macro PBO$T_NXT_LPORT = 40,0,32,0 %;
literal PBO$S_NXT_LPORT = 4;            !  LOCAL PORT NAME ON NXT PB
macro PBO$B_SYSTEMID = 44,0,0,0 %;
literal PBO$S_SYSTEMID = 6;             ! ID OF SYSTEM ASSOC WITH 
!  THIS PB
 
!*** MODULE $PCBDEF ***
! 
!  Software Process Control Block Definitions
! 
literal PCB$M_RES = %X'1';
literal PCB$M_DELPEN = %X'2';
literal PCB$M_FORCPEN = %X'4';
literal PCB$M_INQUAN = %X'8';
literal PCB$M_PSWAPM = %X'10';
literal PCB$M_RESPEN = %X'20';
literal PCB$M_SSFEXC = %X'40';
literal PCB$M_SSFEXCE = %X'80';
literal PCB$M_SSFEXCS = %X'100';
literal PCB$M_SSFEXCU = %X'200';
literal PCB$M_SSRWAIT = %X'400';
literal PCB$M_SUSPEN = %X'800';
literal PCB$M_WAKEPEN = %X'1000';
literal PCB$M_WALL = %X'2000';
literal PCB$M_BATCH = %X'4000';
literal PCB$M_NOACNT = %X'8000';
literal PCB$M_NOSUSPEND = %X'10000';
literal PCB$M_ASTPEN = %X'20000';
literal PCB$M_PHDRES = %X'40000';
literal PCB$M_HIBER = %X'80000';
literal PCB$M_LOGIN = %X'100000';
literal PCB$M_NETWRK = %X'200000';
literal PCB$M_PWRAST = %X'400000';
literal PCB$M_NODELET = %X'800000';
literal PCB$M_DISAWS = %X'1000000';
literal PCB$M_INTER = %X'2000000';
literal PCB$M_RECOVER = %X'4000000';
literal PCB$M_SECAUDIT = %X'8000000';
literal PCB$M_HARDAFF = %X'10000000';
literal PCB$M_ERDACT = %X'20000000';
literal PCB$M_SOFTSUSP = %X'40000000';
literal PCB$M_PREEMPTED = %X'80000000';
literal PCB$M_QUANTUM_RESCHED = %X'1';
literal PCB$M_PHDLOCK = %X'8';
literal PCB$M_TCB = %X'10';
literal PCB$M_TERM_NOTIFY = %X'10000';
literal PCB$M_BYTLM_LOAN = %X'20000';
literal PCB$M_NOUNSHELVE = %X'80000';
literal PCB$M_SHELVING_RESERVED = %X'100000';
literal PCB$M_CLASS_SCHEDULED = %X'200000';
literal PCB$M_CLASS_SUPPLIED = %X'400000';
literal PCB$M_IN_TBS_STATE = %X'800000';
literal PCB$M_WINDFALL = %X'1000000';
literal PCB$M_EPID_WILD = %X'80000000';
literal PCB$M_FORK = %X'1';
literal PCB$K_SCHED_OTHER = 0;          !  Native VMS policy (MBZ)
literal PCB$K_SCHED_FIFO = 1;           !  POSIX FIFO policy
literal PCB$K_SCHED_RR = 2;             !  POSIX Round-Robbin policy
!  [1..10] for POSIX
literal PCB$K_SCHED_POLICY_CNT = 3;     !  # legal sched policies
literal PCB$S_PCB = 624;
macro PCB$L_SQFL = 0,0,32,1 %;          !  State queue forward link 
macro PCB$L_SQBL = 4,0,32,1 %;          !  State queue backward link 
macro PCB$W_SIZE = 8,0,16,0 %;          !  Size, in bytes
macro PCB$B_TYPE = 10,0,8,0 %;          !  Structure type code for PCB    
macro PCB$L_AST_PENDING = 12,0,32,0 %;  !  AST pending mask
macro PCB$Q_PHYPCB = 16,0,0,0 %;
literal PCB$S_PHYPCB = 8;               !  Physical address of HWPCB
macro PCB$Q_LEFC_SWAPPED = 24,0,0,0 %;
literal PCB$S_LEFC_SWAPPED = 8;         !  Local event flags - swapped
macro PCB$L_LEFC_0_SWAPPED = 24,0,32,0 %; !  Cluster 0
macro PCB$L_LEFC_1_SWAPPED = 28,0,32,0 %; !  Cluster 1
macro PCB$L_ASTQFL_SPK = 32,0,32,1 %;   !  Special kernel AST queue forward link (head) 
macro PCB$L_ASTQBL_SPK = 36,0,32,1 %;   !  Special kernel AST queue back link (tail) 
macro PCB$L_ASTQFL_K = 40,0,32,1 %;     !  Kernel AST queue forward link (head)
macro PCB$L_ASTQBL_K = 44,0,32,1 %;     !  Kernel AST queue back link (tail)
macro PCB$L_ASTQFL_E = 48,0,32,1 %;     !  Executive AST queue forward link (head)
macro PCB$L_ASTQBL_E = 52,0,32,1 %;     !  Executive AST queue back link (tail)
macro PCB$L_ASTQFL_S = 56,0,32,1 %;     !  Supervisor AST queue forward link (head)
macro PCB$L_ASTQBL_S = 60,0,32,1 %;     !  Supervisor AST queue back link (tail)
macro PCB$L_ASTQFL_U = 64,0,32,1 %;     !  User AST queue forward link (head)
macro PCB$L_ASTQBL_U = 68,0,32,1 %;     !  User AST queue back link (tail)
macro PCB$L_PRVCPU = 72,0,32,1 %;       !  Previous CPU (not current CPU)
macro PCB$L_CPU_ID = 76,0,32,1 %;       !  Current CPU (last one to load context)
macro PCB$Q_PRVASN = 80,0,0,0 %;
literal PCB$S_PRVASN = 8;               !  Previous Address Space Number (ASN)
macro PCB$Q_PRVASNSEQ = 88,0,0,0 %;
literal PCB$S_PRVASNSEQ = 8;            !  Previous ASN Sequence Number
macro PCB$Q_ONCPUCNT = 96,0,0,0 %;
literal PCB$S_ONCPUCNT = 8;             !  Count of threads in CUR state
macro PCB$L_ASTACT = 104,0,32,0 %;      !  Access modes with active ASTs 
macro PCB$L_STATE = 108,0,32,0 %;       !  Process state
macro PCB$L_PRI = 112,0,32,0 %;         !  Process current priority 				
macro PCB$L_PRIB = 116,0,32,0 %;        !  Base priority 
macro PCB$L_AFFINITY_SKIP = 120,0,32,0 %; !  Affinity skip count
macro PCB$L_OWNER = 124,0,32,0 %;       !  PID of creator 
macro PCB$L_STS = 128,0,32,0 %;         !  Process status flags 
macro PCB$V_RES = 128,0,1,0 %;          !  Resident, in balance set
macro PCB$V_DELPEN = 128,1,1,0 %;       !  Delete pending                
macro PCB$V_FORCPEN = 128,2,1,0 %;      !  Force exit pending 
macro PCB$V_INQUAN = 128,3,1,0 %;       !  Initial quantum in progress 
macro PCB$V_PSWAPM = 128,4,1,0 %;       !  Process swap mode, 1=NOSWAP 
macro PCB$V_RESPEN = 128,5,1,0 %;       !  Resume pending, skip suspend
macro PCB$V_SSFEXC = 128,6,1,0 %;       !  System service exception enable (K) 
macro PCB$V_SSFEXCE = 128,7,1,0 %;      !  System service exception enable (E) 
macro PCB$V_SSFEXCS = 128,8,1,0 %;      !  System service exception enable (S) 
macro PCB$V_SSFEXCU = 128,9,1,0 %;      !  System service exception enable (U) 
macro PCB$V_SSRWAIT = 128,10,1,0 %;     !  System service resource wait disable 
macro PCB$V_SUSPEN = 128,11,1,0 %;      !  Suspend pending 
macro PCB$V_WAKEPEN = 128,12,1,0 %;     !  Wake pending, skip hibernate 
macro PCB$V_WALL = 128,13,1,0 %;        !  Wait for all events in mask 
macro PCB$V_BATCH = 128,14,1,0 %;       !  Process is a batch job 
macro PCB$V_NOACNT = 128,15,1,0 %;      !  No accounting for process 
macro PCB$V_NOSUSPEND = 128,16,1,0 %;   !  Process cannot be suspended
macro PCB$V_ASTPEN = 128,17,1,0 %;      !  AST pending 
macro PCB$V_PHDRES = 128,18,1,0 %;      !  Process header resident 
macro PCB$V_HIBER = 128,19,1,0 %;       !  Hibernate after initial image activate 
macro PCB$V_LOGIN = 128,20,1,0 %;       !  Login without reading UAF
macro PCB$V_NETWRK = 128,21,1,0 %;      !  Network connect job 
macro PCB$V_PWRAST = 128,22,1,0 %;      !  Power fail AST 
macro PCB$V_NODELET = 128,23,1,0 %;     !  No delete 
macro PCB$V_DISAWS = 128,24,1,0 %;      !  Disable automatic WS adjustment 
macro PCB$V_INTER = 128,25,1,0 %;       !  Process is an interactive job
macro PCB$V_RECOVER = 128,26,1,0 %;     !  Process can recover locks
macro PCB$V_SECAUDIT = 128,27,1,0 %;    !  Mandatory security auditing enabled
macro PCB$V_HARDAFF = 128,28,1,0 %;     !  Process is bound to particular CPU
macro PCB$V_ERDACT = 128,29,1,0 %;      !  Exec mode rundown active
macro PCB$V_SOFTSUSP = 128,30,1,0 %;    !  Process is in "soft" suspend
macro PCB$V_PREEMPTED = 128,31,1,0 %;   !  Hard suspend has preempted soft
macro PCB$L_STS2 = 132,0,32,0 %;        !  Process status flags (2nd LW)
macro PCB$V_QUANTUM_RESCHED = 132,0,1,0 %; !  Quantum-oriented process reschedule
macro PCB$V_PHDLOCK = 132,3,1,0 %;      !  Don't swap PHD -- process has $LCKPAG pages
macro PCB$V_TCB = 132,4,1,0 %;          !  TCB process
macro PCB$V_TERM_NOTIFY = 132,16,1,0 %; !  termination notification
macro PCB$V_BYTLM_LOAN = 132,17,1,0 %;  !  Process has received rundown BYTLIM loan
macro PCB$V_NOUNSHELVE = 132,19,1,0 %;  !  if set, don't auto-unshelve
macro PCB$V_SHELVING_RESERVED = 132,20,1,0 %; !  Reserved for shelving facility
macro PCB$V_CLASS_SCHEDULED = 132,21,1,0 %; !  This process is class scheduled
macro PCB$V_CLASS_SUPPLIED = 132,22,1,0 %; !  This process has been assigned a class,
!  or an explicit "No class" (happens only
!  when CLASS_SCHEDULED is cleared)
macro PCB$V_IN_TBS_STATE = 132,23,1,0 %; !  This process is in TBS state
macro PCB$V_WINDFALL = 132,24,1,0 %;    !  Process eligible for windfall
macro PCB$L_PRISAV = 136,0,32,0 %;      !  Saved current priority 				
macro PCB$L_PRIBSAV = 140,0,32,0 %;     !  Saved base priority 				
macro PCB$L_AUTHPRI = 144,0,32,0 %;     !  Initial process priority 
macro PCB$L_ONQTIME = 148,0,32,0 %;     !  Abs time when placed on COM/COMO queue,
!   adjusted for process wait time
macro PCB$L_WAITIME = 152,0,32,0 %;     !  Abs time of last process event
macro PCB$L_ASTCNT = 156,0,32,0 %;      !  AST count remaining
macro PCB$L_BIOCNT = 160,0,32,0 %;      !  Buffered I/O count remaining 
macro PCB$L_BIOLM = 164,0,32,0 %;       !  Buffered I/O limit 
macro PCB$L_DIOCNT = 168,0,32,0 %;      !  Direct I/O count remaining 
macro PCB$L_DIOLM = 172,0,32,0 %;       !  Direct I/O count limit 
macro PCB$L_PRCCNT = 176,0,32,0 %;      !  Subprocess count 
macro PCB$T_TERMINAL = 180,0,0,0 %;
literal PCB$S_TERMINAL = 8;             !  Terminal device name string 
!   for interactive jobs
macro PCB$L_WEFC = 188,0,32,0 %;        !  Waiting EF cluster number 
macro PCB$L_EFWM = 192,0,32,0 %;        !  Event flag wait mask 
macro PCB$L_EFCS = 196,0,32,0 %;        !  Local event flag cluster, system 
macro PCB$L_EFCU = 200,0,32,0 %;        !  Local event flag cluster, user 
macro PCB$L_EFC2P = 204,0,32,1 %;       !  Pointer to global cluster #2
macro PCB$L_EFC3P = 208,0,32,1 %;       !  Pointer to global cluster #3
macro PCB$W_PGFLCHAR = 204,0,16,0 %;    !  Page file characteristics
macro PCB$B_PGFLINDEX = 206,0,8,0 %;    !  Desired SYSTEM page file index
macro PCB$L_PID = 212,0,32,0 %;         !  Process ID used by exec on local node only
!   
! *** WARNING - THE INTERNAL STRUCTURE OF THE EPID IS SUBJECT TO RADICAL CHANGE BETWEEN
! ***           VERSIONS OF VMS.  NO ASSUMPTIONS SHOULD EVER BE MADE ABOUT ITS FORMAT
! 
macro PCB$L_EPID = 216,0,32,0 %;        !  Cluster-wide process ID seen by the world
macro PCB$V_EPID_PROC = 216,0,21,0 %;
literal PCB$S_EPID_PROC = 21;           !  Process ID field, can convert to PCB$l_pid
macro PCB$V_EPID_NODE_IDX = 216,21,8,0 %;
literal PCB$S_EPID_NODE_IDX = 8;        !  IDX - index to table of node identifications
macro PCB$V_EPID_NODE_SEQ = 216,29,2,0 %;
literal PCB$S_EPID_NODE_SEQ = 2;        !  SEQ - sequence number for node table entry reuse
macro PCB$V_EPID_WILD = 216,31,1,0 %;   !  Flag that EPID is wildcard context for $GETJPI, 
!   and not a valid EPID
macro PCB$L_EOWNER = 220,0,32,0 %;      !  EPID of process owner
macro PCB$L_APTCNT = 224,0,32,0 %;      !  Active page table count on outswap
macro PCB$L_MTXCNT = 228,0,32,0 %;      !  Count of mutex semaphores owned 
macro PCB$L_GPGCNT = 232,0,32,0 %;      !  Global page count in WS 
macro PCB$L_PPGCNT = 236,0,32,0 %;      !  Process page count in WS
macro PCB$L_WSSWP = 240,0,32,1 %;       !  Swap file disk address 
macro PCB$L_SWAPSIZE = 244,0,32,0 %;    !  Swap block allocation 
macro PCB$L_PHD = 248,0,32,1 %;         !  Address of Process Header
macro PCB$L_JIB = 252,0,32,1 %;         !  Address of Job Information Block 
macro PCB$R_PCBARB = 256,0,0,0 %;
literal PCB$S_PCBARB = 124;
macro PCB$Q_PRIV = 256,0,0,0 %;
literal PCB$S_PRIV = 8;                 !  Current privilege mask
macro PCB$L_ARB = 264,0,32,1 %;         !  Address of Access Rights Block
macro PCB$L_UIC = 316,0,32,0 %;         !  Logon UIC of process
macro PCB$W_MEM = 316,0,16,0 %;         !  Member number in UIC
macro PCB$W_GRP = 318,0,16,0 %;         !  Group number in UIC
macro PCB$L_ORB = 380,0,32,1 %;         !  Address of process ORB
macro PCB$L_TMBU = 384,0,32,0 %;        !  Termination mailbox unit number 
macro PCB$L_LOCKQFL = 388,0,32,1 %;     !  Lock queue forward link 
macro PCB$L_LOCKQBL = 392,0,32,1 %;     !  Lock queue backward link 
macro PCB$L_DLCKPRI = 396,0,32,1 %;     !  Deadlock resolution priority 
macro PCB$L_DEFPROT = 400,0,32,0 %;     !  Process default protection
macro PCB$L_PMB = 404,0,32,1 %;         !  PMB address
macro PCB$L_AFFINITY = 408,0,32,1 %;    !  CPU ID for affinity
macro PCB$L_CAPABILITY = 412,0,32,0 %;  !  CPU capability selection bitmask
macro PCB$L_CPUTIM = 416,0,32,0 %;      !  Accumulated CPU time at last outswap
macro PCB$T_LNAME = 420,0,0,0 %;
literal PCB$S_LNAME = 16;               !  Process name
macro PCB$L_PRCPDB = 436,0,32,1 %;      !  Address of process Performance Data Block
! **** For DIGITAL software use only *****
macro PCB$L_PIXHIST = 440,0,32,0 %;     !  PIXSCAN history summary LW (bitmask)
macro PCB$L_AFFINITY_CALLBACK = 444,0,32,1 %; !  Callback for breaking affinity
macro PCB$L_PERMANENT_CAPABILITY = 448,0,32,0 %; !  Permanent capability mask
macro PCB$L_PERMANENT_CPU_AFFINITY = 452,0,32,1 %; !  Permanent CPU affinity
macro PCB$Q_CWPSSRV_QUEUE = 456,0,0,0 %;
literal PCB$S_CWPSSRV_QUEUE = 8;        !  CWPS service block queue
macro PCB$L_CURRENT_AFFINITY = 464,0,32,0 %; !  Current CPU mask
macro PCB$L_CAPABILITY_SEQ = 468,0,32,1 %; !  Copy of last sequence number
macro PCB$Q_BUFOBJ_LIST = 472,0,0,0 %;
literal PCB$S_BUFOBJ_LIST = 8;          !  Defined buffer objects queue head
macro PCB$L_AST_BLOCKED = 480,0,32,0 %; !  AST blocked bits
macro PCB$L_ADB_LINK = 484,0,32,1 %;    !  Address of AST Data Blocks (GEN)
macro PCB$L_TOTAL_EVTAST = 488,0,32,0 %; !  Total AST quota in use for event (GEN)
macro PCB$A_CURRENT_TX = 492,0,32,0 %;  !  Pointer to process default transaction
macro PCB$A_CURRENT_CD = 496,0,32,0 %;  !  Pointer to process default commit domain
macro PCB$A_CURRENT_VERTEX = 500,0,32,0 %; !  Pointer to process default execution vertex
macro PCB$Q_XSCB_QUE = 504,0,0,0 %;
literal PCB$S_XSCB_QUE = 8;             !  Transaction Segment list
macro PCB$A_XSCB_FLINK = 504,0,32,0 %;
macro PCB$A_XSCB_BLINK = 508,0,32,0 %;
macro PCB$Q_RMCB_QUE = 512,0,0,0 %;
literal PCB$S_RMCB_QUE = 8;             !  Declared resource manager list
macro PCB$A_RMCB_FLINK = 512,0,32,0 %;
macro PCB$A_RMCB_BLINK = 516,0,32,0 %;
macro PCB$Q_CD_QUE = 520,0,0,0 %;
literal PCB$S_CD_QUE = 8;               !  Commit domain membership list
macro PCB$A_CD_FLINK = 520,0,32,0 %;
macro PCB$A_CD_BLINK = 524,0,32,0 %;
macro PCB$L_DPC = 528,0,32,0 %;         !  Delete pending count
macro PCB$L_CPUTIME_REF = 532,0,32,0 %; !  CPUTIME at last TICK time
macro PCB$L_ACC_WAITIME = 536,0,32,0 %; !  Accumulated wait time
macro PCB$L_PRCSTR = 540,0,32,1 %;      !  alternate procstrt
macro PCB$L_XPCB = 544,0,32,1 %;        !  address of the POSIX extended PCB
macro PCB$L_PSX_FORK_STATUS = 548,0,32,0 %; !  POSIX fork status cell
macro PCB$L_PSX_FLAGS = 552,0,32,0 %;   !  POSIX flags
macro PCB$V_FORK = 552,0,1,0 %;         !  In fork synchronization
macro PCB$L_PSX_SPARE_L1 = 556,0,32,1 %; !  POSIX spare longword
macro PCB$L_PSX_ACTRTN = 560,0,32,1 %;  !  POSIX fork action routine
macro PCB$L_PSX_ACTPRM = 564,0,32,0 %;  !  POSIX fork action routine parameter
macro PCB$L_KERNEL_COUNTER = 568,0,32,0 %; !  Per-process kernel mode counters
macro PCB$L_EXEC_COUNTER = 572,0,32,0 %; !  Per-process exec mode counters
macro PCB$L_SUPER_COUNTER = 576,0,32,0 %; !  Per-process super mode counters
macro PCB$L_USER_COUNTER = 580,0,32,0 %; !  Per-process user mode counters
macro PCB$L_SCHED_POLICY = 584,0,32,0 %; !  POSIX sched policy
macro PCB$A_FREWSLE_CALLOUT = 588,0,32,0 %; !  Routine to notify of WSLE about to be removed
macro PCB$L_FREWSLE_PARAM = 592,0,32,0 %; !  Parameter to pass to FREWSLE_CALLOUT routine
macro PCB$L_PQB = 592,0,32,1 %;         !  Pointer to Process Quota Block 
!   (process creation only)
macro PCB$L_BUFOBJ_CNT = 596,0,32,0 %;  !  Buffer object page count on outswap
macro PCB$L_NOAUDIT = 600,0,32,0 %;     !  count of reasons not to audit
macro PCB$L_SOURCE_EPID = 604,0,32,0 %; !  Impersonation EPID
macro PCB$Q_RDPB_QUE = 608,0,0,0 %;
literal PCB$S_RDPB_QUE = 8;             !  Resource Domain pointer block
macro PCB$A_RDPB_FLINK = 608,0,32,0 %;
macro PCB$A_RDPB_BLINK = 612,0,32,0 %;
macro PCB$Q_FILES_64 = 616,0,0,0 %;
literal PCB$S_FILES_64 = 8;             !  Files-64 bits and bobs
literal PCB$K_LENGTH = 624;             !  Length of PCB 
literal PCB$C_LENGTH = 624;             !  Length of PCB 
literal PCB$S_PCBDEF = 624;             !  Old PCB size for compatibility
 
!*** MODULE $PCIDEF ***
literal PCI$K_VENDOR_ID = 0;
literal PCI$K_DEVICE_ID = 2;
literal PCI$K_COMMAND = 4;
literal PCI$M_IO_ENABLE = %X'1';
literal PCI$M_MEM_ENABLE = %X'2';
literal PCI$M_BUS_MASTER_ENABLE = %X'4';
literal PCI$M_SPECIAL_CYCLE_ENABLE = %X'8';
literal PCI$M_INVAL_ENABLE = %X'10';
literal PCI$M_PALETTE_SNOOP_ENABLE = %X'20';
literal PCI$M_PARITY_ENABLE = %X'40';
literal PCI$M_WAIT_CYCLE_ENABLE = %X'80';
literal PCI$M_SERR_ENABLE = %X'100';
literal PCI$M_BACK_TO_BACK_ENABLE = %X'200';
literal PCI$K_STATUS = 6;
literal PCI$M_FAST_BB_CAPABLE = %X'80';
literal PCI$M_DATA_PARITY_DETECT = %X'100';
literal PCI$M_DEVSEL_TIMING = %X'600';
literal PCI$M_SIGNAL_TARGET_ABORT = %X'800';
literal PCI$M_RCV_TARGET_ABORT = %X'1000';
literal PCI$M_RCV_MASTER_ABORT = %X'2000';
literal PCI$M_SIGNAL_SERR = %X'4000';
literal PCI$M_DETECT_PE = %X'8000';
literal PCI$K_REVISION_ID = 8;
literal PCI$K_PROGRAMMING_IF = 9;
literal PCI$K_SUB_CLASS = 10;
literal PCI$K_BASE_CLASS = 11;
literal PCI$K_CACHE_LINE_SIZE = 12;
literal PCI$K_LATENCY_TIMER = 13;
literal PCI$K_HEADER_TYPE = 14;
literal PCI$K_BIST = 15;
literal PCI$K_BASE_ADDRESS_0 = 16;
literal PCI$K_BASE_ADDRESS_1 = 20;
literal PCI$K_BASE_ADDRESS_2 = 24;
literal PCI$K_BASE_ADDRESS_3 = 28;
literal PCI$K_BASE_ADDRESS_4 = 32;
literal PCI$K_BASE_ADDRESS_5 = 36;
literal PCI$K_EXP_ROM_BASE = 48;
literal PCI$K_INTR_LINE = 60;
literal PCI$K_INTR_PIN = 61;
literal PCI$K_MIN_GNT = 62;
literal PCI$K_MAX_LAT = 63;
literal PCI$S_PCIDEF = 64;              !  Old PCI size for compatibility
literal PCI$K_DEVSEL_FAST = 0;
literal PCI$K_DEVSEL_MEDIUM = 1;
literal PCI$K_DEVSEL_SLOW = 2;
literal PCI$K_NOT_IMPLEMENTED = 0;
literal PCI$K_MASS_STORAGE_CTRLR = 1;
literal PCI$K_NETWORK_CTRLR = 2;
literal PCI$K_DISPLAY_CTRLR = 3;
literal PCI$K_MULTIMEDIA_DEVICE = 4;
literal PCI$K_MEMORY_CTRLR = 5;
literal PCI$K_BRIDGE_DEVICE = 6;
literal PCI$K_UNDEFINED = 255;
literal PCI$K_SCSI_CTRLR = 0;
literal PCI$K_IDE_CTRLR = 1;
literal PCI$K_FLOPPY_CTRLR = 2;
literal PCI$K_IPI_CTRLR = 3;
literal PCI$K_OTHER_MASS_STORAGE = 80;
literal PCI$K_NI_CTRLR = 0;
literal PCI$K_TOKEN_CTRLR = 1;
literal PCI$K_FDDI_CTRLR = 2;
literal PCI$K_OTHER_NETWORK = 80;
literal PCI$K_VGA_CTRLR = 0;
literal PCI$K_XGA_CTRLR = 1;
literal PCI$K_OTHER_DISPLAY = 80;
literal PCI$K_VIDEO_CTRLR = 0;
literal PCI$K_AUDIO_CTRLR = 1;
literal PCI$K_OTHER_MULTIMEDIA = 80;
literal PCI$K_RAM = 0;
literal PCI$K_FLASH = 1;
literal PCI$K_OTHER_MEMORY = 80;
literal PCI$K_HOST_BRIDGE = 0;
literal PCI$K_ISA_BRIDGE = 1;
literal PCI$K_EISA_BRIDGE = 2;
literal PCI$K_MC_BRIDGE = 3;
literal PCI$K_PCI_PCI_BRIDGE = 4;
literal PCI$K_PCMCIA_BRIDGE = 5;
literal PCI$K_OTHER_BRIDGE = 80;
literal PCI$K_INTR_PIN_NOT_USED = 0;
literal PCI$K_INTR_PIN_INTA = 1;
literal PCI$K_INTR_PIN_INTB = 2;
literal PCI$K_INTR_PIN_INTC = 3;
literal PCI$K_INTR_PIN_INTD = 4;
literal PCI$K_MAX_DEVICES = 32;
literal PCI$K_LENGTH = 64;
literal PCI$S_PCI = 64;
macro PCI$W_VENDOR_ID = 0,0,16,1 %;
macro PCI$W_DEVICE_ID = 2,0,16,1 %;
macro PCI$W_COMMAND = 4,0,16,1 %;
macro PCI$V_IO_ENABLE = 4,0,1,0 %;
macro PCI$V_MEM_ENABLE = 4,1,1,0 %;
macro PCI$V_BUS_MASTER_ENABLE = 4,2,1,0 %;
macro PCI$V_SPECIAL_CYCLE_ENABLE = 4,3,1,0 %;
macro PCI$V_INVAL_ENABLE = 4,4,1,0 %;
macro PCI$V_PALETTE_SNOOP_ENABLE = 4,5,1,0 %;
macro PCI$V_PARITY_ENABLE = 4,6,1,0 %;
macro PCI$V_WAIT_CYCLE_ENABLE = 4,7,1,0 %;
macro PCI$V_SERR_ENABLE = 4,8,1,0 %;
macro PCI$V_BACK_TO_BACK_ENABLE = 4,9,1,0 %;
macro PCI$W_STATUS = 6,0,16,1 %;
macro PCI$V_FAST_BB_CAPABLE = 6,7,1,0 %;
macro PCI$V_DATA_PARITY_DETECT = 6,8,1,0 %;
macro PCI$V_DEVSEL_TIMING = 6,9,2,0 %;
literal PCI$S_DEVSEL_TIMING = 2;
macro PCI$V_SIGNAL_TARGET_ABORT = 6,11,1,0 %;
macro PCI$V_RCV_TARGET_ABORT = 6,12,1,0 %;
macro PCI$V_RCV_MASTER_ABORT = 6,13,1,0 %;
macro PCI$V_SIGNAL_SERR = 6,14,1,0 %;
macro PCI$V_DETECT_PE = 6,15,1,0 %;
macro PCI$B_REVISION_ID = 8,0,8,1 %;
macro PCI$B_PROGRAMMING_IF = 9,0,8,1 %;
macro PCI$B_SUB_CLASS = 10,0,8,1 %;
macro PCI$B_BASE_CLASS = 11,0,8,1 %;
macro PCI$B_CACHE_LINE_SIZE = 12,0,8,1 %;
macro PCI$B_LATENCY_TIMER = 13,0,8,1 %;
macro PCI$B_HEADER_TYPE = 14,0,8,1 %;
macro PCI$B_BIST = 15,0,8,1 %;
macro PCI$L_BASE_ADDRESS_0 = 16,0,32,1 %;
macro PCI$L_BASE_ADDRESS_1 = 20,0,32,1 %;
macro PCI$L_BASE_ADDRESS_2 = 24,0,32,1 %;
macro PCI$L_BASE_ADDRESS_3 = 28,0,32,1 %;
macro PCI$L_BASE_ADDRESS_4 = 32,0,32,1 %;
macro PCI$L_BASE_ADDRESS_5 = 36,0,32,1 %;
macro PCI$L_RESERVED_1 = 40,0,32,1 %;
macro PCI$L_RESERVED_2 = 44,0,32,1 %;
macro PCI$L_EXP_ROM_BASE = 48,0,32,1 %;
macro PCI$L_RESERVED_3 = 52,0,32,1 %;
macro PCI$L_RESERVED_4 = 56,0,32,1 %;
macro PCI$B_INTR_LINE = 60,0,8,1 %;
macro PCI$B_INTR_PIN = 61,0,8,1 %;
macro PCI$B_MIN_GNT = 62,0,8,1 %;
macro PCI$B_MAX_LAT = 63,0,8,1 %;
literal PCI$M_BASE_ADDRESS_MEM_IO = %X'1';
literal PCI$M_BASE_ADDRESS_TYPE = %X'6';
literal PCI$M_BASE_ADDRESS_PREFETCHABLE = %X'8';
literal PCI$M_BASE_ADDRESS_BITS_31_4 = %X'FFFFFFF0';
literal PCI$S_BASE_ADDRESS = 4;
macro PCI$L_BASE_ADDRESS = 0,0,32,1 %;
macro PCI$V_BASE_ADDRESS_MEM_IO = 0,0,1,0 %;
macro PCI$V_BASE_ADDRESS_TYPE = 0,1,2,0 %;
literal PCI$S_BASE_ADDRESS_TYPE = 2;
macro PCI$V_BASE_ADDRESS_PREFETCHABLE = 0,3,1,0 %;
macro PCI$V_BASE_ADDRESS_BITS_31_4 = 0,4,28,0 %;
literal BASE_ADDR_32 = 0;
literal BASE_ADDR_BELOW_1MB = 1;
literal BASE_ADDR_64 = 2;
literal BASE_ADDR_RESERVED = 3;
literal PCI$M_PCI_NODE_NUMBER_FUNCTION = %X'7';
literal PCI$M_PCI_NODE_NUMBER_DEVICE = %X'F8';
literal PCI$M_PCI_NODE_NUMBER_BUS = %X'FF00';
literal PCI$M_PCI_NODE_NUMBER_OFFSET = %X'FFFF0000';
literal PCI$S_PCI_NODE_NUMBER = 4;
macro PCI$L_PCI_NODE_NUMBER = 0,0,32,1 %;
macro PCI$V_PCI_NODE_NUMBER_FUNCTION = 0,0,3,0 %;
literal PCI$S_PCI_NODE_NUMBER_FUNCTION = 3;
macro PCI$V_PCI_NODE_NUMBER_DEVICE = 0,3,5,0 %;
literal PCI$S_PCI_NODE_NUMBER_DEVICE = 5;
macro PCI$V_PCI_NODE_NUMBER_BUS = 0,8,8,0 %;
literal PCI$S_PCI_NODE_NUMBER_BUS = 8;
macro PCI$V_PCI_NODE_NUMBER_OFFSET = 0,16,16,0 %;
literal PCI$S_PCI_NODE_NUMBER_OFFSET = 16;
literal PCI$S_PCI_BUSARRAY_HARDWARE_ID = 8;
macro PCI$Q_PCI_HARDWARE_ID = 0,0,0,1 %;
literal PCI$S_PCI_HARDWARE_ID = 8;
macro PCI$W_PCI_HARDWARE_ID_VENDOR = 0,0,16,1 %;
macro PCI$W_PCI_HARDWARE_ID_DEVICE = 2,0,16,1 %;
literal PCIERR$K_LENGTH = 72;
literal PCIERR$S_PCIERR = 72;
macro PCIERR$V_DEVICE_NUMBER = 0,11,5,0 %;
literal PCIERR$S_DEVICE_NUMBER = 5;
macro PCIERR$B_BUS_NUMBER = 2,0,8,0 %;
macro PCIERR$L_FRAME_SIZE = 4,0,32,0 %;
macro PCIERR$R_PCI = 8,0,0,0 %;
literal PCIERR$S_PCI = 64;
literal PCIFLAGS$M_FILL1 = %X'FFFFFF00';
literal PCIFLAGS$M_DATA_PARITY_DETECT = %X'1';
literal PCIFLAGS$M_SIGNAL_TARGET_ABORT = %X'2';
literal PCIFLAGS$M_RCV_TARGET_ABORT = %X'4';
literal PCIFLAGS$M_RCV_MASTER_ABORT = %X'8';
literal PCIFLAGS$M_SIGNAL_SERR = %X'10';
literal PCIFLAGS$M_DETECT_PE = %X'20';
literal PCIFLAGS$M_FILL2 = %X'C0';
literal PCIFLAGS$M_FILL3 = %X'FFFFFF00';
literal PCIFLAGS$S_PCIFLAGS = 4;
macro PCIFLAGS$B_PCIFLAGS = 0,0,8,0 %;
macro PCIFLAGS$V_DATA_PARITY_DETECT = 0,0,1,0 %; !  From PCI stat<8> 
macro PCIFLAGS$V_SIGNAL_TARGET_ABORT = 0,1,1,0 %; !  Same as stat<11:15>
macro PCIFLAGS$V_RCV_TARGET_ABORT = 0,2,1,0 %;
macro PCIFLAGS$V_RCV_MASTER_ABORT = 0,3,1,0 %;
macro PCIFLAGS$V_SIGNAL_SERR = 0,4,1,0 %;
macro PCIFLAGS$V_DETECT_PE = 0,5,1,0 %;
literal ERRTAG$K_PCIERR = 16;
 
!*** MODULE $PCMCIADEF ***
literal TPLCODE$K_CISTPL_NULL = 0;
literal TPLCODE$K_CISTPL_DEVICE = 1;
literal TPLCODE$K_CISTPL_CHECKSUM = 16;
literal TPLCODE$K_CISTPL_LONGLINK_A = 17;
literal TPLCODE$K_CISTPL_LONGLINK_C = 18;
literal TPLCODE$K_CISTPL_LLINKTARGET = 19;
literal TPLCODE$K_CISTPL_NO_LINK = 20;
literal TPLCODE$K_CISTPL_VERS_1 = 21;
literal TPLCODE$K_CISTPL_ALTSTR = 22;
literal TPLCODE$K_CISTPL_DEVICE_A = 23;
literal TPLCODE$K_CISTPL_JEDEC_C = 24;
literal TPLCODE$K_CISTPL_JEDEC_A = 25;
literal TPLCODE$K_CISTPL_CONFIG = 26;
literal TPLCODE$K_CISTPL_CFTABLE_ENTRY = 27;
literal TPLCODE$K_CISTPL_DEVICE_OC = 28;
literal TPLCODE$K_CISTPL_DEVCIE_OA = 29;
literal TPLCODE$K_CISTPL_DEVICE_GEO = 30;
literal TPLCODE$K_CISTPL_DEVICE_GEO_A = 31;
literal TPLCODE$K_CISTPL_MANFID = 32;
literal TPLCODE$K_CISTPL_FUNCID = 33;
literal TPLCODE$K_CISTPL_FUNCE = 34;
literal TPLCODE$K_CISTPL_SWIL = 35;
literal TPLCODE$K_CISTPL_VERS_2 = 64;
literal TPLCODE$K_CISTPL_FORMAT = 65;
literal TPLCODE$K_CISTPL_GEOMETRY = 66;
literal TPLCODE$K_CISTPL_BYTEORDER = 67;
literal TPLCODE$K_CISTPL_DATE = 68;
literal TPLCODE$K_CISTPL_BATTERY = 69;
literal TPLCODE$K_CISTPL_ORG = 70;
literal TPLCODE$K_CISTPL_END = 255;
literal TPLDID$K_DSPEED_NULL = 0;
literal TPLDID$K_DSPEED_250NS = 1;
literal TPLDID$K_DSPEED_200NS = 2;
literal TPLDID$K_DSPEED_150NS = 3;
literal TPLDID$K_DSPEED_100NS = 4;
literal TPLDID$K_DSPEED_EXT = 7;
literal TPLDID$K_DTYPE_NULL = 0;
literal TPLDID$K_DTYPE_ROM = 1;
literal TPLDID$K_DTYPE_OTPROM = 2;
literal TPLDID$K_DTYPE_EPROM = 3;
literal TPLDID$K_DTYPE_EEPROM = 4;
literal TPLDID$K_DTYPE_FLASH = 5;
literal TPLDID$K_DTYPE_SRAM = 6;
literal TPLDID$K_DTYPE_DRAM = 7;
literal TPLDID$K_DTYPE_FUNCSPEC = 13;
literal TPLDID$K_DTYPE_EXTEND = 14;
literal TPLDID$K_SIZE_512B = 0;
literal TPLDID$K_SIZE_2K = 1;
literal TPLDID$K_SIZE_8K = 2;
literal TPLDID$K_SIZE_32K = 3;
literal TPLDID$K_SIZE_128K = 4;
literal TPLDID$K_SIZE_512K = 5;
literal TPLDID$K_SIZE_2M = 6;
literal TPLFID$K_MULTI_FUNC = 0;
literal TPLFID$K_MEMORY = 1;
literal TPLFID$K_SERIAL_PORT = 2;
literal TPLFID$K_PARALLEL_PORT = 3;
literal TPLFID$K_FIXED_DISK = 4;
literal TPLFID$K_VIDEO_ADAPTER = 5;
literal TPLFID$K_NETWORK_LAN = 6;
literal TPLFID$K_AIMS = 7;
literal TPLFID_SYSINIT$K_POST = 1;
literal TPLFID_SYSINIT$K_ROM = 2;
 
!*** MODULE PCSAMPLEDEF ***
literal PCBUF$C_STRUCTURE_VERSION = 2;
! 
!  Slot constraining values
! 
literal PCBUF$C_MAX_SLOT_CNT = 32768;   !  Maximum number of slots
literal PCBUF$C_MIN_SLOT_CNT = 128;     !  Minimum number of slots
! 
!  Slot structure definition
! 
literal PCSLT$C_LENGTH = 16;
literal PCSLT$S_PCSLTDEF = 16;          !  Old size name - synonym
literal PCSLT$S_PCSLT = 16;
macro PCSLT$L_PC = 0,0,32,1 %;          !  Program counter
macro PCSLT$L_PS = 4,0,32,0 %;          !  Process status
macro PCSLT$L_COUNTER = 8,0,32,0 %;     !  Indicates which counter fired
macro PCSLT$L_PID = 12,0,32,0 %;        !  ID of current process
! 
!  Buffer descriptor structure
! 
literal PCDSC$C_LENGTH = 20;
literal PCDSC$S_PCDSCDEF = 20;          !  Old size name - synonym
literal PCDSC$S_PCDSC = 20;
macro PCDSC$L_BUFFER = 0,0,32,1 %;      !  Pointer to buffer in use
macro PCDSC$R_OVER_1 = 4,0,0,0 %;
literal PCDSC$S_OVER_1 = 8;
macro PCDSC$R_SLOT_INFO = 4,0,0,0 %;
literal PCDSC$S_SLOT_INFO = 8;
macro PCDSC$L_CUR_SLOT = 4,0,32,0 %;    !  Index of next slot
macro PCDSC$L_SLOT_CNT = 8,0,32,0 %;    !  Number of slots in the buffer
macro PCDSC$R_COUNTER_INFO = 4,0,0,0 %;
literal PCDSC$S_COUNTER_INFO = 8;
macro PCDSC$L_COUNTER_0 = 4,0,32,0 %;
macro PCDSC$L_COUNTER_1 = 8,0,32,0 %;
macro PCDSC$L_BUFF_SIZE = 12,0,32,0 %;  !  Size of memory block for descriptor
macro PCDSC$L_RING_PTR = 16,0,32,1 %;   !  Fake buffer pointer to next buffer
! 
!  Buffer structure
! 
literal PCBUF$C_HDR_SIZE = 32;          !  Buffer header size
literal PCBUF$C_MAX_LENGTH = 524320;    !  Maximum buffer size
literal PCBUF$S_PCBUFDEF = 524320;      !  Old size name - synonym
literal PCBUF$S_PCBUF = 524320;
macro PCBUF$L_NEXT_BUFF = 0,0,32,1 %;   !  Pointer to next buffer
macro PCBUF$L_BUFF_SIZE = 4,0,32,0 %;   !  Size of memory block used for buffer
macro PCBUF$L_FULL_FLAG = 8,0,32,0 %;   !  Buffer is full
macro PCBUF$L_CPU_ID = 12,0,32,0 %;     !  CPU index
macro PCBUF$Q_BEGIN_TIME = 16,0,0,0 %;
literal PCBUF$S_BEGIN_TIME = 8;         !  Time buffer was started
macro PCBUF$B_SCRATCH = 24,0,0,1 %;
literal PCBUF$S_SCRATCH = 8;            !  Used to force slot alignment
macro PCBUF$B_DATA_AREA = 32,0,0,1 %;
literal PCBUF$S_DATA_AREA = 524288;     !  Data slots
literal PCBUF$C_MIN_LENGTH = 2080;      !  Minimum buffer size
 
!*** MODULE $PD6729DEF ***
literal PD6729$K_CHIP_REVISION = 0;
literal PD6729$K_INTERFACE_STATUS = 1;
literal PD6729$K_POWER_CONTROL = 2;
literal PD6729$K_INTR_AND_CONTROL = 3;
literal PD6729$K_CARD_STAT_CHANGE = 4;
literal PD6729$K_MGMT_INTR_CNFG = 5;
literal PD6729$K_MAPPING_ENABLE = 6;
literal PD6729$K_IO_WINDOW_CTRL = 7;
literal PD6729$K_MISC_CONTROL_1 = 22;
literal PD6729$K_FIFO_CONTROL = 23;
literal PD6729$K_MISC_CONTROL_2 = 30;
literal PD6729$K_CHIP_INFO = 31;
literal PD6729$K_ATA_CONTROL = 38;
literal PD6729$K_EXT_INDEX = 46;
literal PD6729$K_EXT_DATA = 47;
literal PD6729$K_SETUP_TIME_0 = 58;
literal PD6729$K_CMD_TIME_0 = 59;
literal PD6729$K_RECOVERY_TIME_0 = 60;
literal PD6729$K_SETUP_TIME_1 = 61;
literal PD6729$K_CMD_TIME_1 = 62;
literal PD6729$K_RECOVERY_TIME_1 = 63;
literal PD6729$K_IO_START_LOW_0 = 8;
literal PD6729$K_IO_START_HIGH_0 = 9;
literal PD6729$K_IO_END_LOW_0 = 10;
literal PD6729$K_IO_END_HIGH_0 = 11;
literal PD6729$K_IO_OFFSET_LOW_0 = 54;
literal PD6729$K_IO_OFFSET_HIGH_0 = 55;
literal PD6729$K_IO_START_LOW_1 = 12;
literal PD6729$K_IO_START_HIGH_1 = 13;
literal PD6729$K_IO_END_LOW_1 = 14;
literal PD6729$K_IO_END_HIGH_1 = 15;
literal PD6729$K_IO_OFFSET_LOW_1 = 56;
literal PD6729$K_IO_OFFSET_HIGH_1 = 57;
literal PD6729$K_MEM_START_LOW_0 = 16;
literal PD6729$K_MEM_START_HIGH_0 = 17;
literal PD6729$K_MEM_END_LOW_0 = 18;
literal PD6729$K_MEM_END_HIGH_0 = 19;
literal PD6729$K_MEM_OFFSET_LOW_0 = 20;
literal PD6729$K_MEM_OFFSET_HIGH_0 = 21;
literal PD6729$K_MEM_START_LOW_1 = 24;
literal PD6729$K_MEM_START_HIGH_1 = 25;
literal PD6729$K_MEM_END_LOW_1 = 26;
literal PD6729$K_MEM_END_HIGH_1 = 27;
literal PD6729$K_MEM_OFFSET_LOW_1 = 28;
literal PD6729$K_MEM_OFFSET_HIGH_1 = 29;
literal PD6729$K_MEM_START_LOW_2 = 32;
literal PD6729$K_MEM_START_HIGH_2 = 33;
literal PD6729$K_MEM_END_LOW_2 = 34;
literal PD6729$K_MEM_END_HIGH_2 = 35;
literal PD6729$K_MEM_OFFSET_LOW_2 = 36;
literal PD6729$K_MEM_OFFSET_HIGH_2 = 37;
literal PD6729$K_MEM_START_LOW_4 = 48;
literal PD6729$K_MEM_START_HIGH_4 = 49;
literal PD6729$K_MEM_END_LOW_4 = 50;
literal PD6729$K_MEM_END_HIGH_4 = 51;
literal PD6729$K_MEM_OFFSET_LOW_4 = 52;
literal PD6729$K_MEM_OFFSET_HIGH_4 = 53;
literal PD6729$K_EXT_CONTROL_1 = 3;
literal PD6729$K_MEM_UPPER_0 = 5;
literal PD6729$K_MEM_UPPER_1 = 6;
literal PD6729$K_MEM_UPPER_2 = 7;
literal PD6729$K_MEM_UPPER_3 = 8;
literal PD6729$K_MEM_UPPER_4 = 9;
literal PD6729$K_EXTERNAL_DATA = 10;
literal PD6729$K_EXT_CONTROL_2 = 11;
literal PD6729$K_SOCKET_SHIFT = 6;
literal PD6729$K_SOCKET_OFFSET = 64;
literal PD6729$K_INDEX = 0;
literal PD6729$K_DATA = 1;
literal PD6729$K_LOW_POWER_DYNAMIC = 2;
literal PD6729$K_CARD_ENABLE = 128;
literal PD6729$K_AUTO_POWER = 32;
literal PD6729$K_VCC = 16;
literal PD6729$K_DATA_PATH_16 = 128;
literal PD6729$K_REG_ACTIVE = 64;
literal PD6729$K_NOT_RESET = 64;
literal PD6729$K_IO = 32;
literal PD6729$K_BATTERY_STATUS = 1;
literal PD6729$K_BATTERY_WARN = 2;
literal PD6729$K_READY_ENABLE = 4;
literal PD6729$K_CARD_DETECT_ENABLE = 8;
literal PD6729$K_MEM_MAP_ENABLE_0 = 1;
literal PD6729$K_MEM_MAP_ENABLE_1 = 2;
literal PD6729$K_MEM_MAP_ENABLE_2 = 4;
literal PD6729$K_MEM_MAP_ENABLE_3 = 8;
literal PD6729$K_MEM_MAP_ENABLE_4 = 16;
literal PD6729$K_IO_MAP_ENABLE_0 = 64;
literal PD6729$K_IO_MAP_ENABLE_1 = 128;
literal PD6729$K_CARD_DETECT_MASK = 12;
literal PD6729$K_NO_CARD = 0;
literal PD6729$K_CARD_DETECT = 12;
literal PD6729$K_PD6729_INTA = 3;
literal PD6729$K_PD6729_INTB = 4;
literal PD6729$K_PD6729_INTC = 5;
literal PD6729$K_PD6729_INTD = 7;
 
!*** MODULE $PDBDEF ***
! +
!  DEFINE DEVICE PERFORMANCE DATA BLOCK
! -
literal PDB$K_LENGTH = 52;              ! LENGTH OF DATA CONTROL BLOCK 
literal PDB$C_LENGTH = 52;              ! LENGTH OF DATA CONTROL BLOCK 
literal PDB$S_PDBDEF = 52;
literal PDB$S_PDB = 52;
macro PDB$L_FREEFL = 0,0,32,1 %;        ! FREE BUFFER LISTHEAD FORWARD LINK 
macro PDB$L_FREEBL = 4,0,32,1 %;        ! FREE BUFFER LISTHEAD BACKLINK 
macro PDB$W_SIZE = 8,0,16,0 %;          ! SIZE OF DATA STRUCTURE 
macro PDB$B_TYPE = 10,0,8,0 %;          ! TYPE OF DATA STRUCTURE 
macro PDB$B_OVERRUN = 11,0,8,0 %;       ! OVERRUN INDICATOR 
macro PDB$L_FILLFL = 12,0,32,1 %;       ! FILLED BUFFER LISTHEAD FORWARD LINK 
macro PDB$L_FILLBL = 16,0,32,1 %;       ! FILLED BUFFER LISTHEAD BACKWARD LINK 
macro PDB$L_CURBUF = 20,0,32,1 %;       ! ADDRESS OF CURRENT BUFFER 
macro PDB$L_NXTBUF = 24,0,32,1 %;       ! ADDRESS OF NEXT LOCATION IN BUFFER 
macro PDB$L_ENDBUF = 28,0,32,1 %;       ! ADDRESS OF END OF BUFFER 
macro PDB$L_PID = 32,0,32,0 %;          ! PROCESS ID OF DATA COLLECTION PROCESS 
macro PDB$B_DEVCLASS = 36,0,8,0 %;      ! DEVICE CLASS SELECTION 
macro PDB$B_DEVTYPE = 37,0,8,0 %;       ! DEVICE TYPE SELECTION 
macro PDB$W_ANDM = 38,0,16,0 %;         ! STATUS SELECTION 'AND' MASK 
macro PDB$W_XORM = 40,0,16,0 %;         ! STATUS SELECTION 'XOR' MASK 
macro PDB$W_BUFCNT = 42,0,16,0 %;       ! COUNT OF FILLED BUFFERS 
macro PDB$Q_FUNC = 44,0,0,0 %;
literal PDB$S_FUNC = 8;                 ! SELECTION FUNCTION MASK 
 
!*** MODULE $PDTDEF ***
! +
!  DEFINE PORT-INDEPENDENT OFFSETS IN A PORT DESCRIPTOR TABLE.
! 
!  THERE IS ONE PDT PER PORT ACCESSED VIA SCS.  THESE PORTS INCLUDE
!  CI'S AND UDA'S.  THE PDT CONTAINS A PORT-INDEPENDENT PIECE (DEFINED
!  HERE) FOLLOWED BY AN OPTIONAL PORT-SPECIFIC PIECE DEFINED IN THE
!  PORT DRIVER.  PDT'S ARE CREATED BY THE CONTROLLER INIT ROUTINES
!  OF THE INDIVIDUAL PORT DRIVERS.
! -
literal PDT$M_SNGLHOST = %X'1';
literal PDT$C_PA = 1;                   !  CI PORT 
literal PDT$C_PU = 2;                   !  UDA PORT 
literal PDT$C_PE = 3;                   !  NI PORT
literal PDT$C_PS = 4;                   !  PASSTHRU PORT
literal PDT$C_PB = 5;                   !  BVP storage port
literal PDT$C_PI = 6;                   !  DSSI PORT
literal PDT$C_PL = 7;                   !  Gapless tape port
literal PDT$C_PW = 8;                   !  SWIFT port
literal PDT$C_PN = 9;                   !  NPORT 
literal PDT$M_CNTBSY = %X'1';
literal PDT$M_CNTRLS = %X'2';
literal PDT$M_XCNTRS = %X'4';
literal PDT$M_NON_CI_BHANDLE = %X'8';
literal PDT$C_BASEVER = 0;              ! V4.0 drivers
literal PDT$C_LISTENVER = 1;            ! V5.0 redesigned listener connection state transitions
literal PDT$C_BALANCEVER = 2;           ! Dynamic load balancing version
literal PDT$C_REORGVER = 1;             ! V5.0 reorganized PDT format
literal PDT$C_CREDITVER = 2;            ! Optimistic credit allocation format
literal PDT$C_NI_CLASS = 10;            !  NI/SCA performance level port/interconnect
literal PDT$C_CI_CLASS = 20;            !  CI     performance level port/interconnect
! 
literal PDT$C_YELLOW = 4;               !  Port is in YELLOW zone
literal PDT$C_RED = 6;                  !  Port is in RED zone
literal PDT$C_UNEQUAL_PATH = 7;         !  Unequal path load sharing (i.e. NI->CI)
literal PDT$C_CTRSTART = 592;           !  start of pdt counter area a 
literal PDT$C_STD_CTREND = 624;         !  end of standard pdt counter area a
literal PDT$C_STDNO_CTR = 7;            !  7 standard counters
literal PDT$C_EXT_CTRSTART = 624;       !  start of pdt extended counter area a 
literal PDT$C_EXT_CTREND = 732;         !  end of standard pdt counter area a
literal PDT$C_EXTNO_CTR = 26;           !  26 extended counters
literal SCS$C_EB_MAX_INDEX = 6;
literal PDT$K_LENGTH = 848;             ! SIZE OF PORT-INDEPENDENT PIECE 
literal PDT$C_LENGTH = 848;             ! SIZE OF PORT-INDEPENDENT PIECE 
!  OF PDT.
literal PDT$S_PDTDEF = 848;             !  Old size name - synonym
literal PDT$S_PDT = 848;
macro PDT$L_FLINK = 0,0,32,0 %;         ! LINK TO NEXT SCS PDT
macro PDT$W_PORTCHAR = 4,0,16,0 %;      ! Port Characteristics
macro PDT$V_SNGLHOST = 4,0,1,0 %;       !  Port to single host bus
macro PDT$B_PDT_TYPE = 7,0,8,0 %;       !  TYPE OF PDT 
macro PDT$W_SIZE = 8,0,16,0 %;          ! STRUCTURE SIZE IN BYTES 
macro PDT$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE = SCS 
macro PDT$B_SUBTYP = 11,0,8,0 %;        ! STRUCTURE SUBTYPE
! 
!  SCS accesses routines in the port driver via dispatch vectors in the PDT.
!  There are two sets of vectors, Required entries (must be supplied by every
!  port driver) and Optional entries (allow port drivers that must do so
!  to supplant SCS supplied routines).
! 
!  The required entries are defined below, they must have the prefix
!  PDTVEC and tag L for the INIT_PORT_VECTORS macro to work correctly
macro PDTVEC$L_ALLOCDG = 12,0,32,1 %;   !  ALLOCATE A DG BUFFER 
macro PDTVEC$L_ALLOCMSG = 16,0,32,1 %;  !  ALLOCATE A MESSAGE BUFFER 
macro PDTVEC$L_DEALLOCDG = 20,0,32,1 %; !  DEALLOCATE DG BUFFER 
macro PDTVEC$L_DEALLOMSG = 24,0,32,1 %; !  DEALLOCATE MSG BUFFER
macro PDTVEC$L_INS_PES_MFREEQ = 28,0,32,1 %; !  return MSG buf to port free buffer supply
macro PDTVEC$L_INS_OPT_MFREEQ = 32,0,32,1 %; !  return MSG buf to port free buffer supply (optimistic)
macro PDTVEC$L_REM_OPT_MFREEQ = 36,0,32,1 %; !  take MSG buf from port free buffer supply (optimistic)
macro PDTVEC$L_REM_PES_MFREEQ = 40,0,32,1 %; !  take MSG buf from port free buffer supply (pessimistic)
macro PDTVEC$L_ADD_FREE_DG = 44,0,32,1 %; !  Give Receive DG buffer to port driver
macro PDTVEC$L_REM_FREE_DG = 48,0,32,1 %; !  take receive DG buffer to port driver
macro PDTVEC$L_QUEUE_DG = 52,0,32,1 %;  !  Queue DG buffer to port driver
macro PDTVEC$L_REQDATA = 56,0,32,1 %;   !  REQUEST BLK DATA XFER 
macro PDTVEC$L_SENDDATA = 60,0,32,1 %;  !  SEND BLK DATA XFER 
macro PDTVEC$L_SENDDATAWMSG = 64,0,32,1 %; !  send data w/piggyback message
macro PDTVEC$L_SENDDG = 68,0,32,1 %;    !  SEND A DATAGRAM 
macro PDTVEC$L_SENDMSG = 72,0,32,1 %;   !  SEND A MESSAGE 
macro PDTVEC$L_SENDMSGL = 76,0,32,1 %;  !  SEND A MESSAGE (low priority)
macro PDTVEC$L_TRNMSGH = 80,0,32,1 %;   !  return message to sender (high priority)
macro PDTVEC$L_TRNMSGL = 84,0,32,1 %;   !  return message to sender  (low priority)
macro PDTVEC$L_READCOUNT = 88,0,32,1 %; !  READ COUNTERS (FMT PORT SPECIFIC) 
macro PDTVEC$L_MRESET = 92,0,32,1 %;    !  MAINT RESET OF REMOTE 
macro PDTVEC$L_MSTART = 96,0,32,1 %;    !  MAINT START OF REMOTE 
macro PDTVEC$L_STOP_VCS = 100,0,32,1 %; !  SEND STOP DGS ON ALL VCS
macro PDTVEC$L_SHUT_ALL_VC = 104,0,32,1 %; !  Shutdown all VCs on a port
macro PDTVEC$L_CRASH_VC = 108,0,32,1 %; !  Crash (Shut off) a single VC
macro PDTVEC$L_CRASH_PORT = 112,0,32,1 %; !  Shutdown the port
macro PDTVEC$L_REINIT_PORT = 116,0,32,1 %; !  REINIT A PORT
macro PDTVEC$L_FLUSH_VC = 120,0,32,1 %; !  complete outstanding requests on a VC
macro PDTVEC$L_LOG_ERROR_SCS = 124,0,32,1 %; !  log Packet error for SCS
macro PDTVEC$L_CLEANUP_PKT = 128,0,32,1 %; !  return outstanding pakcets to SCS
macro PDTVEC$L_PB_FROM_MSG = 132,0,32,1 %; !  return PB for message
macro PDTVEC$L_CHK_LOST_ACK = 136,0,32,1 %; !  check if circuit handshake could complete
macro PDTVEC$L_REMOVE_PB = 140,0,32,1 %; !  Remove PB if no connections
!  Optional port driver entry point vectors (and reserved vectors).
!  If these entries are not set by the port driver SCS defaults are used.
macro PDT$L_CONNECT = 144,0,32,1 %;     !  REQUEST CONNECTION TO REMOTE 
macro PDT$L_DCONNECT = 148,0,32,1 %;    !  BREAK CONNECTION 
macro PDT$L_ADD_SCS_HDR = 152,0,32,1 %; !  Add SCS session header to a send message
macro PDT$L_CANCEL_WAIT = 156,0,32,1 %; !  Cancel a stalled CDRP waiting for a SCS resource. This vector is required
!    if port driver stalls for any resource.
macro PDT$L_MAP = 160,0,32,1 %;         !  Port-dependent Mapping of a Buffer for a Block Transfer
macro PDT$L_UNMAP = 164,0,32,1 %;       !  Port-dependent Unmapping of a Buffer for a Block Transfer
macro PDT$L_TEST_CRASH_PORT = 168,0,32,1 %; !  Port-dependent Crash Port routine
macro PDT$L_TEST_INS_COMQH = 172,0,32,1 %; !  Port-dependent Command Queue Insertion
macro PDT$L_TEST_1_PORT = 176,0,32,1 %; !  Port-dependent Test 1 vector
macro PDT$L_TEST_2_PORT = 180,0,32,1 %; !  Port-dependent Test 2 vector
macro PDT$L_WAITQFL = 216,0,32,1 %;     ! LISTHEAD FOR FORK BLOCKS WAITING 
macro PDT$L_WAITQBL = 220,0,32,1 %;     !  FOR NONPAGED POOL
macro PDT$L_DGHDRSZ = 224,0,32,0 %;     ! DATAGRAM HEADER SIZE 
macro PDT$L_MSGHDRSZ = 224,0,32,0 %;    ! MESSAGE HEADER SIZE 
macro PDT$L_DGOVRHD = 228,0,32,0 %;     ! DATAGRAM HEADER SIZE
!  ^^^ Obsolete field
macro PDT$L_MAXBCNT = 232,0,32,0 %;     ! MAXIMUM TRANSFER BCNT
macro PDT$W_FLAGS = 236,0,16,0 %;       ! PORT FLAGS 
macro PDT$V_CNTBSY = 236,0,1,0 %;       !  COUNTERS IN USE 
macro PDT$V_CNTRLS = 236,1,1,0 %;       !  RELEASE COUNTERS
macro PDT$V_XCNTRS = 236,2,1,0 %;       !  port supports block xfer counters
macro PDT$V_NON_CI_BHANDLE = 236,3,1,0 %; !  Port uses non-CI buffer handles
macro PDT$T_CNTOWNER = 240,0,0,0 %;
literal PDT$S_CNTOWNER = 16;            ! NAME OF SYSAP USING COUNTERS 
macro PDT$L_CNTCDRP = 256,0,32,1 %;     ! CDRP OF SYSAP READING COUNTERS 
macro PDT$L_POLLSWEEP = 260,0,32,0 %;   ! # SECONDS TO DO A POLLER SWEEP
macro PDT$L_UCB0 = 264,0,32,1 %;        ! ADDR OF UCB.
macro PDT$L_ADP = 268,0,32,1 %;         ! ADDR OF ADP.
macro PDT$L_MAX_VCTMO = 272,0,32,0 %;   ! Maximum VC timeout
macro PDT$W_SCSVERSION = 276,0,16,0 %;  ! SCSLOA version
macro PDT$W_PPDVERSION = 278,0,16,0 %;  ! PPD driver version
macro PDT$L_LOAD_VECTOR = 280,0,32,1 %; ! Load vector
macro PDT$W_LOAD_CLASS = 284,0,16,0 %;  ! Load class (higher arbitrary numbers for higher interconnect performance)
!  class = 0 for default lowest performance level
!  (TYC 15-Feb-89) Dynamic Load Sharing Specific Counters and Fields                 
! 
macro PDT$Q_PB = 288,0,0,0 %;
literal PDT$S_PB = 8;                   !  Queue header for path blocks
macro PDT$Q_CONN_WAIT = 296,0,0,0 %;
literal PDT$S_CONN_WAIT = 8;            !  Queue header for CDTs in Load Share Wait Queue
macro PDT$Q_YELLOW = 304,0,0,0 %;
literal PDT$S_YELLOW = 8;               !  Queue header for CDTs in Load Share Yellow Queue
macro PDT$Q_RED = 312,0,0,0 %;
literal PDT$S_RED = 8;                  !  Queue header for CDTs in Load Share Red Queue
macro PDT$Q_DISABLED = 320,0,0,0 %;
literal PDT$S_DISABLED = 8;             !  Queue header for CDTs in Load Share Disabled Queue
macro PDT$L_PORT_MAP = 328,0,32,0 %;    !  32-bit load sharing domain bit map
macro PDT$L_AVAIL_THRUPUT = 332,0,32,1 %; !  Port's available throughput
macro PDT$L_LOAD_RATING = 336,0,32,0 %; !  Port load share rating
macro PDT$L_TIME_STAMP = 340,0,32,0 %;  !  Load sharing port time stamp
!  Load share thresholds
macro PDT$L_SATURATION_PT = 344,0,32,0 %; !  Port saturation point
macro PDT$L_MAX_THRUPUT_THRESHOLD = 348,0,32,0 %; !  Port maximum throughput threshold
macro PDT$L_MIN_THRUPUT_THRESHOLD = 352,0,32,0 %; !  Port minimum throughput threshold
macro PDT$L_TOLERANCE_THRESHOLD = 356,0,32,0 %; !  Port load tolerance threshold
!  Load sharing data transfer counters
macro PDT$L_BYTES_DG_XMT = 364,0,32,0 %; !  Total bytes xmitted by port for DG only
macro PDT$L_BYTES_DG_RCV = 368,0,32,0 %; !  Total bytes rcv'd by port for DG only
macro PDT$L_BYTES_MSG_XMT = 372,0,32,0 %; !  Total bytes xmitted by port for MSG only
macro PDT$L_BYTES_MSG_RCV = 376,0,32,0 %; !  Total bytes rcv'd by port for MSG only
macro PDT$L_BYTES_MAPPED = 380,0,32,0 %; !  Total bytes mapped by port for BT only
macro PDT$L_DG_XMT = 384,0,32,0 %;      !  Total DGs xmitted by port
macro PDT$L_DG_RCV = 388,0,32,0 %;      !  Total DGs rcv'd by port
macro PDT$L_MSG_XMT = 392,0,32,0 %;     !  Total MSGs xmitted by port
macro PDT$L_MSG_RCV = 396,0,32,0 %;     !  Total MSGs rcv'd by port
macro PDT$Q_BYTES_XFER = 400,0,0,0 %;
literal PDT$S_BYTES_XFER = 8;           !  Total bytes xferred by port (both XMIT and RCV)
macro PDT$L_NUM_MAP = 408,0,32,0 %;     !  (TYC0001) # of map operations completed
macro PDT$L_PORT_CMD = 412,0,32,0 %;    !  Total # of port commands placed on
!   queue when the queue is not empty
!   (this is a conditional counter)
macro PDT$L_BYTES_DG_XMT_LAST = 420,0,32,0 %; !  Total bytes xmitted by port for DG only
!   up to last load sharing interval
macro PDT$L_BYTES_DG_RCV_LAST = 424,0,32,0 %; !  Total bytes rcv'd by port for DG only
!   up to last load sharing interval
macro PDT$L_BYTES_MSG_XMT_LAST = 428,0,32,0 %; !  Total bytes xmitted by port for MSG only
!   up to last load sharing interval
macro PDT$L_BYTES_MSG_RCV_LAST = 432,0,32,0 %; !  Total bytes rcv'd by port for MSG only
!   up to last load sharing interval
macro PDT$L_BYTES_MAPPED_LAST = 436,0,32,0 %; !  Total bytes mapped by port for BT only
!   up to last load sharing interval
macro PDT$L_DG_XMT_LAST = 440,0,32,0 %; !  Total DGs xmitted by port
!   up to last load sharing interval
macro PDT$L_DG_RCV_LAST = 444,0,32,0 %; !  Total DGs rcv'd by port
!   up to last load sharing interval
macro PDT$L_MSG_XMT_LAST = 448,0,32,0 %; !  Total MSGs xmitted by port
!   up to last load sharing interval
macro PDT$L_MSG_RCV_LAST = 452,0,32,0 %; !  Total MSGs rcv'd by port
!   up to last load sharing interval
macro PDT$Q_BYTES_XFER_LAST = 456,0,0,0 %;
literal PDT$S_BYTES_XFER_LAST = 8;      !  Total bytes xferred by port 
!   up to last load sharing interval
macro PDT$L_NUM_MAP_LAST = 464,0,32,0 %; !  (TYC0001) # of map operations completed
!   by port up to last load sharing interval
macro PDT$L_PORT_CMD_LAST = 468,0,32,0 %; !  Total # of port commands placed on
!   queue when the queue is not empty
!   up to last load sharing interval
!   (this is a conditional counter)
macro PDT$L_BYTES_XFER_INT = 476,0,32,0 %; !  (TYC 31-AUG-89) TOTAL BYTES XFERRED
!  DURING LAST LOAD SHARING INTERVAL
macro PDT$L_EQUAL_PATH_CALL_COUNT = 480,0,32,0 %; !  Number of equal path move requests made
!   to connections on this port
macro PDT$L_UNEQUAL_PATH_CALL_COUNT = 484,0,32,0 %; !  Number of unequal path move requests made
!   to connections on this port
macro PDT$L_CONNECTION_MOVE_COUNT = 488,0,32,0 %; !  Number of connection moves from this port
! 
!  (TYC 27-Feb-89) peak counters used with conditional assembly
macro PDT$L_BYTES_DG_XMT_PEAK = 492,0,32,0 %; !  Peak value of total bytes xmitted 
!   by port for DG only
macro PDT$L_BYTES_DG_RCV_PEAK = 496,0,32,0 %; !  Peak value of total bytes rcv'd 
!   by port for DG only
macro PDT$L_BYTES_MSG_XMT_PEAK = 500,0,32,0 %; !  Peak value of total bytes xmitted 
!   by port for MSG only
macro PDT$L_BYTES_MSG_RCV_PEAK = 504,0,32,0 %; !  Peak value of total bytes rcv'd 
!   by port for MSG only
macro PDT$L_BYTES_MAPPED_PEAK = 508,0,32,0 %; !  Peak value of total bytes mapped 
!   by port for BT only
macro PDT$L_DG_XMT_PEAK = 512,0,32,0 %; !  Peak value of total DGs xmitted by port
macro PDT$L_DG_RCV_PEAK = 516,0,32,0 %; !  Peak value of total DGs rcv'd by port
macro PDT$L_MSG_XMT_PEAK = 520,0,32,0 %; !  Peak value of total MSGs xmitted by port
macro PDT$L_MSG_RCV_PEAK = 524,0,32,0 %; !  Peak value of total MSGs rcv'd by port
macro PDT$Q_BYTES_XFER_PEAK = 528,0,0,0 %;
literal PDT$S_BYTES_XFER_PEAK = 8;      !  Peak value of total bytes xferred 
!   by port (both XMIT and RCV)
macro PDT$L_PORT_CMD_PEAK = 536,0,32,0 %; !  Peak value of total # of port commands placed on
!   queue when the queue is not empty
! 
!  (TYC 27-Feb-89) average counters used with conditional assembly
macro PDT$L_BYTES_DG_XMT_AVG = 540,0,32,0 %; !  Average value of total bytes xmitted 
!   by port for DG only
macro PDT$L_BYTES_DG_RCV_AVG = 544,0,32,0 %; !  Average value of total bytes rcv'd 
!   by port for DG only
macro PDT$L_BYTES_MSG_XMT_AVG = 548,0,32,0 %; !  Average value of total bytes xmitted 
!   by port for MSG only
macro PDT$L_BYTES_MSG_RCV_AVG = 552,0,32,0 %; !  Average value of total bytes rcv'd 
!   by port for MSG only
macro PDT$L_BYTES_MAPPED_AVG = 556,0,32,0 %; !  Average value of total bytes mapped 
!   by port for BT only
macro PDT$L_DG_XMT_AVG = 560,0,32,0 %;  !  Average value of total DGs xmitted by port
macro PDT$L_DG_RCV_AVG = 564,0,32,0 %;  !  Average value of total DGs rcv'd by port
macro PDT$L_MSG_XMT_AVG = 568,0,32,0 %; !  Average value of total MSGs xmitted by port
macro PDT$L_MSG_RCV_AVG = 572,0,32,0 %; !  Average value of total MSGs rcv'd by port
macro PDT$Q_BYTES_XFER_AVG = 576,0,0,0 %;
literal PDT$S_BYTES_XFER_AVG = 8;       !  Average value of total bytes xferred 
!   by port (both XMIT and RCV)
macro PDT$L_PORT_CMD_AVG = 584,0,32,0 %; !  Average value of total # of port commands placed on
!   queue when the queue is not empty
!  (TYC 22-Jun-89) Moved down here to longword-align
macro PDT$B_LS_FLAG = 588,0,8,0 %;      !  Load share flag, if set, load sharing disabled for now
macro PDT$T_FILL_0 = 589,0,24,0 %;
literal PDT$S_FILL_0 = 3;               !  align long.
macro PDT$L_STDNO_CTR = 592,0,32,0 %;   !  Total number of standard of counters
macro PDT$L_PATH0_ACK = 596,0,32,0 %;   !  Total Acks received on path 0.
macro PDT$L_PATH0_NAK = 600,0,32,0 %;   !  Total Naks received on path 0.
macro PDT$L_PATH0_NRSP = 604,0,32,0 %;  !  Total NRSPs received on path 0.
macro PDT$L_PATH1_ACK = 608,0,32,0 %;   !  Total Acks received on path 1.
macro PDT$L_PATH1_NAK = 612,0,32,0 %;   !  Total Naks received on path 1.
macro PDT$L_PATH1_NRSP = 616,0,32,0 %;  !  Total NRSPs received on path 1.
macro PDT$L_DG_DISC = 620,0,32,0 %;     !  Total Datagrams discarded.
macro PDT$L_EXTNO_CTR = 624,0,32,0 %;   !  Total number of port extended
macro PDT$L_SPARE1_CNT = 628,0,32,0 %;  !  Spare counter 1.
macro PDT$L_SPARE2_CNT = 632,0,32,0 %;  !  Spare counter 2.
macro PDT$L_SPARE3_CNT = 636,0,32,0 %;  !  Spare counter 3.
macro PDT$L_SPARE4_CNT = 640,0,32,0 %;  !  Spare counter 4.
macro PDT$L_SNDDAT_OPER_SNT = 644,0,32,0 %; !  Send Data operations completed.
macro PDT$L_SNDDAT_DATA_SNT = 648,0,32,0 %; !  Bytes of SNDDAT sent by Send Data commands.
macro PDT$L_SNDDAT_BODIES_SNT = 652,0,32,0 %; !  SNDDAT Data bodies sent from host.
macro PDT$L_REQDAT_OPER_SNT = 656,0,32,0 %; !  REQDAT operations completed.
macro PDT$L_RETDAT_DATA_RCV = 660,0,32,0 %; !  Bytes of data received by host in RETDAT bodies.
macro PDT$L_RETDAT_BODIES_RCV = 664,0,32,0 %; !  RETDAT Data bodies received by host.
macro PDT$L_SNTDAT_BODIES_REC = 668,0,32,0 %; !  SNTDAT bodies received and delivered to host.
macro PDT$L_SNTDAT_DATA_REC = 672,0,32,0 %; !  Bytes of 'DATA' received in SNTDAT bodies.
macro PDT$L_CNF_SNT = 676,0,32,0 %;     !  Block Data confirmations sent.
macro PDT$L_DATREQ_BODIES_RCV = 680,0,32,0 %; !  DATREQ bodies received.
macro PDT$L_RETDAT_BODIES_SNT = 684,0,32,0 %; !  RETDAT Data bodies sent from host.
macro PDT$L_RETDAT_DATA_SNT = 688,0,32,0 %; !  Bytes of data sent by RETDAT.
macro PDT$L_DGSNT = 692,0,32,0 %;       !  DG bodies sent
macro PDT$L_DG_TXT_SNT = 696,0,32,0 %;  !  Bytes of DG TEXT Sent
macro PDT$L_MSG_SNT = 700,0,32,0 %;     !  MSG bodies sent
macro PDT$L_MSG_TXT_SNT = 704,0,32,0 %; !  Bytes of MSG TEXT Sent
macro PDT$L_MISC_SNT = 708,0,32,0 %;    !  All other opcode bodies sent
macro PDT$L_DG_REC = 712,0,32,0 %;      !  DG bodies received and delivered to host.
macro PDT$L_DG_TXTREC = 716,0,32,0 %;   !  Bytes of dg received and delivered to host.
macro PDT$L_MSG_REC = 720,0,32,0 %;     !  MSG bodies received.
macro PDT$L_MSG_TXT_REC = 724,0,32,0 %; !  Bytes of msg text received and delivered to host.
macro PDT$L_MISC_REC = 728,0,32,0 %;    !  All other bodies received.
macro PDT$L_SNDDAT_DATA_SNT_LAST = 732,0,32,0 %; !  Bytes of SNDDAT sent by Send 
!   Data commands up to last load
!   sharing interval
macro PDT$L_SNDDAT_OPER_SNT_LAST = 736,0,32,0 %; !  # of Send Data operations from host
!  up to last load sharing interval
macro PDT$L_RETDAT_DATA_RCV_LAST = 740,0,32,0 %; !  Bytes of data received by host in
!   RETDAT bodies up to last load
!   sharing interval
macro PDT$L_REQDAT_OPER_SNT_LAST = 744,0,32,0 %; !  # of REQDAT operations completed by 
!   host up to last load share interval
macro PDT$L_CNF_SNT_LAST = 748,0,32,0 %; !  # of Block Data confirmations sent 
!   up to last load share interval
macro PDT$L_SNTDAT_DATA_REC_LAST = 752,0,32,0 %; !  Bytes of 'DATA' received in SNTDAT bodies
!   up to last load sharing interval
macro PDT$L_DATREQ_BODIES_RCV_LAST = 756,0,32,0 %; !  # of DATREQ bodies received
!   up to last load sharing interval
macro PDT$L_RETDAT_DATA_SNT_LAST = 760,0,32,0 %; !  Bytes of data sent by RETDAT up to
!   last load sharing interval
macro PDT$L_AVG_XFER_SIZE = 764,0,32,0 %; !  Average transfer size used in
!   calculating port's effective bandwidth
macro PDT$L_EB_TABLE = 768,0,32,0 %;    !  address of Ports Effec. Bandwidth table
macro PDT$Q_FORMPB = 776,0,0,0 %;
literal PDT$S_FORMPB = 8;               !  Listhead of formative PB's from this port
macro PDT$W_PBCOUNT = 784,0,16,0 %;     !  # PB's (non-formative) associated with this PDT 
macro PDT$B_PORT_NUM = 788,0,8,0 %;     !  Local port number
macro PDT$T_PORT_NUM = 788,0,0,0 %;
literal PDT$S_PORT_NUM = 6;
macro PDT$B_MAX_PORT = 794,0,8,0 %;     !  Maximum port number
macro PDT$T_MAX_PORT = 794,0,0,0 %;
literal PDT$S_MAX_PORT = 6;
macro PDT$L_CURCNT = 800,0,32,0 %;      !  time (secs) till next RDCNT
macro PDT$L_POOLDUE = 804,0,32,0 %;     !  time when message buffer should be  available
macro PDT$L_BDLT = 808,0,32,1 %;        !  addr. or port independent portion of ports BDLT
!   be quadword aligned:
macro PDT$B_SCS_MAINT_BLOCK = 816,0,0,0 %;
literal PDT$S_SCS_MAINT_BLOCK = 16;     ! Add a Maintenance block to the CDT
!  which must be quadword aligned
macro PDT$L_TQEADDR = 840,0,32,0 %;     !  Address store for VC check TQE
macro PDT$L_TIMVCFAIL = 844,0,32,0 %;   !  Value for previous value of G^SGN$TIMVCFAIL 
literal PDT$C_PAMAC_VER = 2;
! 
literal PDT$M_PWF_CLNUP = %X'1';
literal PDT$M_PUP = %X'2';
literal PDT$M_LBDG = %X'4';
literal PDT$M_NEW_RSP = %X'8';
literal PDT$M_REQID_SNT = %X'10';
literal PDT$M_INSTR_SNT = %X'20';
literal PDT$M_CLSCKT = %X'40';
literal PDT$M_LOCAL = %X'80';
literal PDT$M_LOOK_ASIDE = %X'100';
literal PDT$C_PQB = 888;                !  Base of PQB
literal PDT$Q_COMQBASE = 888;           !  Base of queue headers
literal PDT$C_QELOGEND = 1272;
literal PDT$C_PAPQBEND = 1400;
literal PDT$C_RESP_CNT = 100;
literal PDT$C_MFQ_THRESHOLD = -100;
literal PDT$C_MFQ_INCREMENT = 30;
literal PDT$C_HSHUT_SIZ = 28;           !  Shutdown DG itself
literal PDT$C_LASTGASP_DG = 1576;
literal PDT$C_SETCKT_SIZ = 36;          !  SETCKT DG itself
literal PDT$M_M = %X'70000000';
literal PDT$C_DEFCNTR = 60;
literal PDT$C_ERLCNTR = 86400;
literal PDT$C_SPEC_CTRSTART = 1924;
literal PDT$C_SPECNO_CTR = 14;
literal PDT$C_SPEC_CTREND = 1984;
literal PDT$C_SPEC_CTR_LENGTH = 60;
literal PDT$C_SCSLENGTH = 1984;
literal PDT$C_PAREGBASE = 1984;
literal PDT$C_PAREGEND = 2100;
literal PDT$C_PALENGTH = 2112;
literal PDT$S_PAPDTDEF = 2112;          !  Old size name - synonym
literal PDT$S_PAPDT = 2112;
! 
!  Skip the common PDT
! 
! 
!  Define private PA fields
! 
!  All bits in PDT$L_IPORT_STS and PDT$W_LPORT_STS are uniquely defined
!  to test for coding errors!
! 
macro PDT$V_PWF_CLNUP = 848,0,1,0 %;    !   Power fail cleanup in progress
macro PDT$V_PUP = 848,1,1,0 %;          !   Power up has occurred
macro PDT$L_IPORT_STS = 848,0,32,0 %;
macro PDT$V_LBDG = 852,2,1,0 %;         !   0/1 for LB dg's disabled/
!    enabled on this port
macro PDT$V_NEW_RSP = 852,3,1,0 %;      !   New Response timeout check
!    Cleared every polling 
!    interval and set when a
!    response is dequeued from
!    the response queue.
macro PDT$V_REQID_SNT = 852,4,1,0 %;    !   Polling activity check --
!    Set when the poller sends
!    a REQID to enable the port
!    timeout mechanism.
macro PDT$V_INSTR_SNT = 852,5,1,0 %;    !   BVP instruction in progress
macro PDT$V_CLSCKT = 852,6,1,0 %;       !   PB stalled because a close
!    circuit datagram is in use
macro PDT$V_LOCAL = 852,7,1,0 %;        !   This is a local (BVP) port
!    This bit is used for
!    interpretation of the MSTART
!    and MRESET functions.
macro PDT$V_LOOK_ASIDE = 852,8,1,0 %;   !   This port can allocate message
!    packets directly from the
!    lookaside list
macro PDT$W_LPORT_STS = 852,0,16,0 %;
macro PDT$L_CLSCKT_DG = 856,0,32,0 %;   !  Close circuit datagram
!   stored here to guarantee
!   circuit shutdown even though
!   there is no pool.
macro PDT$L_ADAPTER = 860,0,32,0 %;     !  Base of register space --
!   used because the CNF is
!   not at the base for the
!   BCI750.
!   be quadword aligned:
!   be quadword aligned:
macro PDT$Q_DFREEQ = 872,0,0,0 %;
literal PDT$S_DFREEQ = 8;               !  Datagram free queue header
macro PDT$L_DFREEQ_FLINK = 872,0,32,1 %;
macro PDT$L_DFREEQ_BLINK = 876,0,32,1 %;
macro PDT$Q_MFREEQ = 880,0,0,0 %;
literal PDT$S_MFREEQ = 8;               !  Message free queue header
macro PDT$L_MFREEQ_FLINK = 880,0,32,1 %;
macro PDT$L_MFREEQ_BLINK = 884,0,32,1 %;
macro PDT$Q_COMQL = 888,0,0,0 %;
literal PDT$S_COMQL = 8;                !  Listhead for command
!   queue 0, low priority
macro PDT$Q_COMQH = 896,0,0,0 %;
literal PDT$S_COMQH = 8;                !  Listhead for command
!   queue 1, high priority
macro PDT$Q_COMQ2 = 904,0,0,0 %;
literal PDT$S_COMQ2 = 8;                !  Listhead for command
!   queue 2
macro PDT$Q_COMQ3 = 912,0,0,0 %;
literal PDT$S_COMQ3 = 8;                !  Listhead for command
!   queue 3
macro PDT$Q_RSPQ = 920,0,0,0 %;
literal PDT$S_RSPQ = 8;                 !  Listhead for response
!   queue
macro PDT$L_DFQHDR = 928,0,32,1 %;      !  Addr of DG free queue
!   listhead
macro PDT$L_MFQHDR = 932,0,32,1 %;      !  Addr of MSG free queue
!   listhead
macro PDT$W_DQELEN = 936,0,16,0 %;      !  DG free Q entry length
macro PDT$W_MQELEN = 940,0,16,0 %;      !  MSG free Q entry length
macro PDT$L_VPQB = 944,0,32,1 %;        !  VA of PQB base
macro PDT$L_VBDT = 948,0,32,1 %;        !  VA of BDT base
macro PDT$W_BDTLEN = 952,0,16,0 %;      !  # of entries in BDT
macro PDT$L_SPTBASE = 956,0,32,1 %;     !  PA of base of SPT
macro PDT$L_SPTLEN = 960,0,32,0 %;      !  # of entries in SPT
macro PDT$L_GPTBASE = 964,0,32,1 %;     !  VA of base of GPT
macro PDT$L_GPTLEN = 968,0,32,0 %;      !  # of entries in GPT
macro PDT$L_KEEPALIVE = 972,0,32,0 %;   !  Port keepalive interval
macro PDT$L_VC_CHECK = 972,0,32,0 %;    !  Virtual circuit checking
!   interval
macro PDT$L_FUNC_MASK = 976,0,32,0 %;   !  Function mask
macro PDT$L_DQELOGOUT = 1144,0,0,0 %;
literal PDT$S_DQELOGOUT = 64;           !  DGs held by port on
!   powerfailure
macro PDT$L_MQELOGOUT = 1208,0,0,0 %;
literal PDT$S_MQELOGOUT = 64;           !  MSGs held by port on
!   powerfailure
macro PDT$Q_UNINIT_TIMEOUT = 1400,0,0,0 %;
literal PDT$S_UNINIT_TIMEOUT = 8;       !  Timeout value to use during
!  intialization sequeunces
macro PDT$Q_CRRR_CACHE_QUE = 1408,0,0,0 %;
literal PDT$S_CRRR_CACHE_QUE = 8;       !  Carrier queue cache
macro PDT$Q_QBUF_CACHE_QUE = 1416,0,0,0 %;
literal PDT$S_QBUF_CACHE_QUE = 8;       !  QBufqueue cache
macro PDT$Q_TYPE1_CACHE_QUE = 1424,0,0,0 %;
literal PDT$S_TYPE1_CACHE_QUE = 8;      !  Type 1 array queue cache
macro PDT$L_INS_COMQL = 1432,0,32,0 %;  !  Notify port of non-empty CMDQ0
macro PDT$L_INS_COMQH = 1436,0,32,0 %;  !  Notify port of non-empty CMDQ1
macro PDT$L_INS_DFREQ = 1440,0,32,0 %;  !  Notify port of non-empty DFQ
macro PDT$L_INS_MFREQ = 1444,0,32,0 %;  !  Notify port of non-empty MFQ
macro PDT$L_TRC_FLAG = 1448,0,32,0 %;   !  Control bits for tracing
macro PDT$L_TRC_BUF = 1452,0,32,1 %;    !  Pointer to allocated trace
!  buffer
macro PDT$L_TRC_CMDQL = 1456,0,32,1 %;  !  Vector for tracing CMDQL
macro PDT$L_TRC_CMDQM = 1460,0,32,1 %;  !  Vector for tracing CMDQM
macro PDT$L_TRC_CMDQH = 1464,0,32,1 %;  !  Vector for tracing CMDQH
macro PDT$L_TRC_RSP = 1468,0,32,1 %;    !  Vector for tracing PROC_RSP
macro PDT$L_PROC_RSP = 1472,0,32,1 %;   !  Runtime vector for processing
!  responses.
macro PDT$L_DEBUGCHECK = 1476,0,32,0 %; !  Debugging bugcheck flags
macro PDT$L_RESP_CNT = 1480,0,32,0 %;   !  Number of responses to be
!   removed from the response
!   queue before reforking
macro PDT$L_MFQ_DEFICIT = 1484,0,32,0 %; !  Dynamic message free queue
!   deficit.  If negative, one
!   message free queue entry has
!   been allocated for each SCA
!   credit.  If positive, then
!   represents the number of
!   SCA-required credits which
!   have not been allocated to
!   the message free queue.
macro PDT$L_MFQ_THRESHOLD = 1488,0,32,0 %; !  Dynamic message threshold
!   increment.  This value
!   is the change in
!   PDT$L_MFQ_THRESHOLD whenever
!   a message free queue empty
!   interrupt indicates that the
!   optimistic credit allocation
!   has been too optimistic.
macro PDT$L_MFQ_INCREMENT = 1492,0,32,0 %; !  Number to change the threshold
!   by.  Make this large to
!   avoid a cascade of MFQE
!   interrupts and a possible
!   port timeout during the
!   handling of these interrupts
macro PDT$L_MFQE_COUNT = 1496,0,32,0 %; !  Count of MFQE interrupts
macro PDT$L_DGNETHD = 1500,0,32,0 %;    !  Network header size
macro PDT$L_DGALLOCSZ = 1504,0,32,0 %;  !  Datagram allocation size
macro PDT$L_SCS_OFFSET = 1508,0,32,0 %; !  Offset of SCS header
macro PDT$L_SPRT_OFFSET = 1512,0,32,0 %; !  Offset into PPD of source port address
macro PDT$L_DPRT_OFFSET = 1516,0,32,0 %; !  Offset into PPD of destination port address
!  Normally zero except for ports
!  which support subnode addressing
macro PDT$L_PPD_SUB = 1520,0,32,0 %;    !  Extension for subnode addressing
!  Zero for nonsubnode type ports
! 
!  Host shutdown datagram fields -- used by both CI and BVP ports to short-
!  circuit cluster and disk timeouts. As part of shutting down a system
!  all VCs must be closed with a setckt DG before issuing the last gasp DG.
!  This prevents data corruption problems from occurring in a multiple port
!  system. The setckt DG and last gasp DG use the same area of memory to
!  guarantee they are sent out         
! 
macro PDT$Q_TEMP_RSPQ = 1524,0,0,0 %;
literal PDT$S_TEMP_RSPQ = 8;            !  Temporary response queue to
!   hold responses dequeued        
!   during send of host
!   shutdown datagram
macro PDT$B_HSHUT_DG = 1536,0,0,0 %;
literal PDT$S_HSHUT_DG = 28;
macro PDT$B_SETCKT_DG = 1576,0,0,0 %;
literal PDT$S_SETCKT_DG = 36;
! 
!  Maximum packet multiple which may be used by the local port.  This field
!  is minimized with the maximum packet multiple supported by the remote port.
!  For performance reasons, the actual packet multiple is shifted to bits
!  30:28 to correspond with their positions in the message body.
! 
macro PDT$V_M = 1612,28,3,0 %;
literal PDT$S_M = 3;
macro PDT$L_LPORT_MULT = 1612,0,32,0 %;
macro PDT$L_VC_CHKDUE = 1656,0,32,0 %;  !  Next due time for VC checking
macro PDT$L_POLLERDUE = 1660,0,32,0 %;  !  Due time for configuration
!   poller
macro PDT$B_PORTMAP = 1664,0,0,0 %;
literal PDT$S_PORTMAP = 32;             !  Bitmap of ports
!   we've heard from
macro PDT$B_PLOGMAP = 1696,0,0,0 %;
literal PDT$S_PLOGMAP = 32;             !  Bitmap of ports we've logged
!   with improper nodename and/or
!   SYSID, to whom we won't talk
macro PDT$B_DQIMAP = 1728,0,0,0 %;
literal PDT$S_DQIMAP = 32;              !  Datagram inhibit mask
macro PDT$B_FSNMAP = 1760,0,0,0 %;
literal PDT$S_FSNMAP = 32;              !  Full sequence number mask
macro PDT$B_SAMAP = 1792,0,0,0 %;
literal PDT$S_SAMAP = 32;               !  Subnode addressing mask
macro PDT$B_RDPMAP = 1824,0,0,0 %;
literal PDT$S_RDPMAP = 32;              !  RDP mask
macro PDT$L_SETCKTMSK = 1856,0,32,0 %;  !  SETCKT bit mask
macro PDT$B_NXT_PORT = 1860,0,8,0 %;    !  # of next port to poll
macro PDT$B_REQIDPS = 1861,0,8,0 %;     !  Path select value for
!   configuration poller
macro PDT$B_P0_LBSTS = 1862,0,8,0 %;    !  Status of current
macro PDT$B_P1_LBSTS = 1863,0,8,0 %;    !   and previous LB DG
!   tests for paths 0/1
macro PDT$L_LBDG = 1866,0,32,1 %;       !  Addr of template loopback 
!   datagram
macro PDT$W_STDGDYN = 1870,0,16,0 %;    !  # DGs queued for IDREQc
!   used in start handshakes and   
!   finding out about bad paths
macro PDT$W_STDGUSED = 1872,0,16,0 %;   !  # ports that we know of that
!   will be sending IDRECs
macro PDT$L_RDCNTDG = 1880,0,32,1 %;    !  Address of RDCNT Datagram
macro PDT$L_CTRFLAG = 1884,0,32,0 %;    !  Counter flag
macro PDT$L_DEFCNTR = 1888,0,32,0 %;    !  Default Counter update rate in seconds
macro PDT$L_CURCNTR = 1892,0,32,0 %;    !  Current Counter update rate in seconds
macro PDT$L_ERLCNTR = 1896,0,32,0 %;    !  Errorlog Counter update rate in seconds
macro PDT$L_CURERLCNT = 1900,0,32,0 %;  !  Current Error log count (how many sec left till report counters to error log)
macro PDT$L_CNTUSERS = 1904,0,32,0 %;   !  Number of users requesting counters addr
macro PDT$Q_LAST_ERR = 1908,0,0,0 %;
literal PDT$S_LAST_ERR = 8;             !  Time of last port corrected error
macro PDT$Q_TIME_RDCNT = 1916,0,0,0 %;
literal PDT$S_TIME_RDCNT = 8;           !  Time of last RDCNT response returned
! 
!  CIXCD port-specific counters
! 
macro PDT$L_SPECNO_CTR = 1924,0,32,0 %; !  Total number of port specific of counters
macro PDT$L_PCKT_RCRC = 1928,0,32,0 %;  !  Total number of packets received with CRC errors
macro PDT$L_PORT_IDLE = 1932,0,32,0 %;  !  Amount of time time port is idle (seconds)
macro PDT$L_RSPR_WPE = 1936,0,32,0 %;   !  Responder Register write PEs
macro PDT$L_MBPB_WPE = 1940,0,32,0 %;   !  Mover B Packet Buffer PEs
macro PDT$L_CMDR_WPE = 1944,0,32,0 %;   !  Commander Register write PEs
macro PDT$L_INTR_WPE = 1948,0,32,0 %;   !  Interrupt Register write PEs
macro PDT$L_MAR_WPE = 1952,0,32,0 %;    !  Mover A Register write PEs
macro PDT$L_MBR_WPE = 1956,0,32,0 %;    !  Mover B Register write PEs
macro PDT$L_MPB_RPE = 1960,0,32,0 %;    !  MCWI Packet Buffer Read PEs
macro PDT$L_TBUF_PE = 1964,0,32,0 %;    !  Transmit Buffer parity error
macro PDT$L_MIB_PE = 1968,0,32,0 %;     !  MCDP Internal Bus PEs
macro PDT$L_MCWI_PE = 1972,0,32,0 %;    !  MCWI PEs
macro PDT$L_YREG_PE = 1976,0,32,0 %;    !  MCDP YREG PEs
macro PDT$L_XREG_PE = 1980,0,32,0 %;    !  MCDP XREG PEs
macro PDT$L_CNF = 1984,0,32,0 %;        !  Configuration register
macro PDT$L_PMC = 1988,0,32,0 %;        !  Port maintenance/control register
macro PDT$L_MADR = 1992,0,32,0 %;       !  Port maintenance address register
macro PDT$L_MDATR = 1996,0,32,0 %;      !  Port maintenance data register
macro PDT$L_PS = 2000,0,32,0 %;         !  Port status register
macro PDT$L_PQBBR = 2004,0,32,0 %;      !  Port queue block base register
macro PDT$L_CQ0 = 2008,0,32,0 %;        !  Command queue 0 control register
macro PDT$L_CQ1 = 2012,0,32,0 %;        !  Command queue 1 control register
macro PDT$L_PSR = 2016,0,32,0 %;        !  Port status release register
macro PDT$L_PEC = 2020,0,32,0 %;        !  Port enable control register
macro PDT$L_PIC = 2024,0,32,0 %;        !  Port initialize control register
macro PDT$L_DFQ = 2028,0,32,0 %;        !  DG free queue control register
macro PDT$L_MFQ = 2032,0,32,0 %;        !  MSG free queue control register
macro PDT$L_MTC = 2036,0,32,0 %;        !  Maintenance timer control register
macro PDT$L_PFAR = 2040,0,32,0 %;       !  Port failing address register
macro PDT$L_PPR = 2044,0,32,0 %;        !  Port parameter register
macro PDT$L_PSNR = 2048,0,32,0 %;       !  Port serial number register
macro PDT$L_FADRL = 2052,0,32,0 %;      !  Failing address low register
macro PDT$L_FADRH = 2056,0,32,0 %;      !  Failing address high register
macro PDT$L_PESR = 2060,0,32,0 %;       !  Port error status register
macro PDT$L_PIDR = 2064,0,32,0 %;       !  Port interrupt destination register
macro PDT$L_PVR = 2068,0,32,0 %;        !  Port vector register
macro PDT$L_PEVR = 2072,0,32,0 %;       !  Port error vector register
macro PDT$L_PRVR = 2076,0,32,0 %;       !  Port response vector register
macro PDT$L_XCOMM = 2080,0,32,0 %;      !  XMI command register
macro PDT$L_PDCSR = 2084,0,32,0 %;      !  Port diagnostic control register
macro PDT$L_PSCR = 2088,0,32,0 %;       !  Port scan control register
macro PDT$L_PSDR = 2092,0,32,0 %;       !  Port scan data register
macro PDT$L_PSERNUM = 2096,0,32,0 %;    !  Port serial number
macro PDT$L_ALTADP = 2100,0,32,1 %;     !  The other port's ADP
macro PDT$L_ALTPDT = 2104,0,32,1 %;     !  The other port's PDT
macro PDT$B_PORT1 = 2108,0,8,0 %;       !  1 if port 1, 0 if port 2
literal PDT$M_PI_CQ3 = %X'1';
literal PDT$M_PI_CQ2 = %X'2';
literal PDT$M_PI_CQ1 = %X'4';
literal PDT$M_PI_CQ0 = %X'8';
literal PDT$C_PILENGTH = 2248;
literal PDT$S_PIPDTDEF = 2248;          !  Old size name - synonym
literal PDT$S_PIPDT = 2248;
! 
!  Skip the common PDT plus the PA extension
! 
! 
!  Define private PI fields
! 
macro PDT$Q_PI_CMDQ0 = 2112,0,0,0 %;
literal PDT$S_PI_CMDQ0 = 8;
macro PDT$L_PI_CMDQ0_FLINK = 2112,0,32,1 %;
macro PDT$L_PI_CMDQ0_BLINK = 2116,0,32,1 %;
macro PDT$Q_PI_CMDQ1 = 2120,0,0,0 %;
literal PDT$S_PI_CMDQ1 = 8;
macro PDT$L_PI_CMDQ1_FLINK = 2120,0,32,1 %;
macro PDT$L_PI_CMDQ1_BLINK = 2124,0,32,1 %;
macro PDT$Q_PI_CMDQ2 = 2128,0,0,0 %;
literal PDT$S_PI_CMDQ2 = 8;
macro PDT$L_PI_CMDQ2_FLINK = 2128,0,32,1 %;
macro PDT$L_PI_CMDQ2_BLINK = 2132,0,32,1 %;
macro PDT$Q_PI_CMDQ3 = 2136,0,0,0 %;
literal PDT$S_PI_CMDQ3 = 8;
macro PDT$L_PI_CMDQ3_FLINK = 2136,0,32,1 %;
macro PDT$L_PI_CMDQ3_BLINK = 2140,0,32,1 %;
macro PDT$Q_PI_RIPQ = 2144,0,0,0 %;
literal PDT$S_PI_RIPQ = 8;
macro PDT$L_PI_RIPQ_FLINK = 2144,0,32,1 %;
macro PDT$L_PI_RIPQ_BLINK = 2148,0,32,1 %;
macro PDT$L_PI_SVA = 2152,0,32,1 %;
macro PDT$L_PI_PPD = 2156,0,32,0 %;
macro PDT$L_PI_INI = 2160,0,32,0 %;
macro PDT$L_PI_RANDOM = 2164,0,32,0 %;
macro PDT$L_PI_DG_MAX = 2168,0,32,0 %;
macro PDT$L_PI_MSG_MAX = 2172,0,32,0 %;
macro PDT$L_PI_NR = 2176,0,0,0 %;
literal PDT$S_PI_NR = 32;
macro PDT$L_PI_NS = 2208,0,0,0 %;
literal PDT$S_PI_NS = 32;
macro PDT$B_PI_CSTMAP = 2240,0,8,0 %;
macro PDT$B_PI_RIPMAP = 2241,0,8,0 %;
macro PDT$B_PI_PIPMAP = 2242,0,8,0 %;
macro PDT$V_PI_CQ3 = 2243,0,1,0 %;
macro PDT$V_PI_CQ2 = 2243,1,1,0 %;
macro PDT$V_PI_CQ1 = 2243,2,1,0 %;
macro PDT$V_PI_CQ0 = 2243,3,1,0 %;
macro PDT$B_PI_WORK = 2243,0,8,0 %;
literal PDT$M_CUR_LBS = %X'1';
literal PDT$M_PRV_LBS = %X'2';
literal PDT$M_X_LBS = %X'4';
literal PDT$S_LBSTS = 1;
macro PDT$V_CUR_LBS = 0,0,1,0 %;        !  Current LB status
macro PDT$V_PRV_LBS = 0,1,1,0 %;        !  Previous LB status
macro PDT$V_X_LBS = 0,2,1,0 %;          !  Previous LB crossed status
macro PDT$B_LBSTS = 0,0,8,0 %;
literal PDT$C_CUNIN = 0;                !  Channel in UNINITIALIZED state
literal PDT$C_CIC = 1;                  !  Channel Initialization Completed/DISABLED state
literal PDT$C_CEC = 2;                  !  Channel Enable Completed/ENABLED state
literal PDT$M_ONLINE = %X'40000000';
literal PDT$M_CHNL_CLNUP = %X'80000000';
literal PDT$C_TQE_IOTO_TIMEOUT = 100000000; !  10 sec t/o (100ns)
literal PDT$C_TQE_INIT_TIMEOUT = 10000; !  1 msec t/o (100ns)
literal PDT$C_PNLENGTH = 2784;
literal PDT$S_PNPDTDEF = 2784;          !  Old size name - synonym
literal PDT$S_PNPDT = 2784;
! 
!  Skip the common and PA PDT to define NPORT-specific PDT fields         
! 
macro PDT$L_TYP1WAITQFL = 2120,0,32,1 %; !  Listhead for Fork Block waiting for TYP1 Arrays
macro PDT$L_TYP1WAITQBL = 2124,0,32,1 %; ! 
macro PDT$L_FREETYP1 = 2128,0,32,1 %;   !  Free Type 1 array list
macro PDT$L_DLCK = 2132,0,32,0 %;       !  Fork Lock                   
macro PDT$Q_ABLK = 2136,0,0,0 %;
literal PDT$S_ABLK = 8;                 !  Address of adpater block - virtual
macro PDT$Q_ABLKP = 2144,0,0,0 %;
literal PDT$S_ABLKP = 8;                !  Address of adpater block - physical
macro PDT$Q_CRRR = 2152,0,0,0 %;
literal PDT$S_CRRR = 8;                 !  Carriers used with channel queue header
macro PDT$Q_QBUF = 2160,0,0,0 %;
literal PDT$S_QBUF = 8;                 !  Queue buffers used with channel queue header
macro PDT$L_CRRR_CACHEQFL = 2168,0,32,1 %; !  Carriers Cache Queue 	
macro PDT$L_CRRR_CACHEQBL = 2172,0,32,1 %; !  Carriers Cache Queue
macro PDT$L_QBUF_CACHEQFL = 2176,0,32,1 %; !  QBuffers Cache Queue 	
macro PDT$L_QBUF_CACHEQBL = 2180,0,32,1 %; !  QBuffers Cache Queue
macro PDT$Q_SPARE1 = 2184,0,0,0 %;
literal PDT$S_SPARE1 = 8;               !  Spare quadword
macro PDT$Q_SPARE2 = 2192,0,0,0 %;
literal PDT$S_SPARE2 = 8;               !  Spare quadword
macro PDT$Q_SPARE3 = 2200,0,0,0 %;
literal PDT$S_SPARE3 = 8;               !  Spare quadword
macro PDT$Q_SPARE4 = 2208,0,0,0 %;
literal PDT$S_SPARE4 = 8;               !  Spare quadword
macro PDT$L_CNTDIS = 2216,0,32,0 %;     !  RDCNT dispatch
macro PDT$L_HSHUT_QBUF = 2220,0,32,1 %; !  Address of Host Shutdown QBUF
macro PDT$L_SETCKT_QBUF = 2224,0,32,1 %; !  Address of SETCKT QBUF
macro PDT$L_SPARE_QBUF = 2228,0,32,1 %; !  Address of spare QBUF
macro PDT$L_INITIALIZE = 2232,0,32,0 %; !  Initialize adapter 
macro PDT$L_ENABLE = 2236,0,32,0 %;     !  Enable adapter              
macro PDT$L_INIT_ABLK = 2240,0,32,0 %;  !  Init adapter block
macro PDT$L_INS_COMQM = 2244,0,32,0 %;  !  Notify port of non-empty CMDQ1
macro PDT$L_ABBR = 2248,0,32,1 %;       !  adapter block CRAM Address
macro PDT$L_CQ2 = 2252,0,32,1 %;        !  Command que 2 CRAM Address
macro PDT$L_NRE = 2256,0,32,1 %;        !  emulation CRAM Address
macro PDT$L_QIR = 2260,0,32,1 %;        !  QIR CRAM Address
macro PDT$L_XBER = 2264,0,32,1 %;       !  XBER CRAM Address
macro PDT$L_XDEV = 2268,0,32,1 %;       !  XDEV CRAM Address
macro PDT$L_R_AFAR0 = 2272,0,32,1 %;    !  Read CRAM mailbox address - AFAR0 	
macro PDT$L_R_AFAR1 = 2276,0,32,1 %;    !  Read CRAM mailbox address - AFAR1 	
macro PDT$L_R_AMCSR = 2280,0,32,1 %;    !  Read CRAM mailbox address - AMCSR 	
macro PDT$L_R_ASR = 2284,0,32,1 %;      !  Read CRAM mailbox address - ASR 	
macro PDT$L_R_CASR = 2288,0,32,1 %;     !  Read CRAM mailbox address - CASR 	
macro PDT$L_R_PESR = 2292,0,32,1 %;     !  Read CRAM mailbox address - PESR 	
macro PDT$L_R_PFAR = 2296,0,32,1 %;     !  Read CRAM mailbox address - PFAR 	
macro PDT$L_R_SPARE = 2300,0,32,1 %;    !  Read CRAM mailbox address - SPARE 	
macro PDT$L_R_XBE = 2304,0,32,1 %;      !  Read CRAM mailbox address - XBE 	
macro PDT$L_R_XDEV = 2308,0,32,1 %;     !  Read CRAM mailbox address - XDEV 	
macro PDT$L_R_XFADR = 2312,0,32,1 %;    !  Read CRAM mailbox address - XFADR 	
macro PDT$L_R_XFAER = 2316,0,32,1 %;    !  Read CRAM mailbox address - XFAER 	
macro PDT$L_R_XPD1 = 2320,0,32,1 %;     !  Read CRAM mailbox address - XPD1 	
macro PDT$L_W_ABBR = 2324,0,32,1 %;     !  Write CRAM mailbox address -  ABBR
macro PDT$L_W_ACIVR = 2328,0,32,1 %;    !  Write CRAM mailbox address - 	ACIVR    
macro PDT$L_W_AIDR = 2332,0,32,1 %;     !  Write CRAM mailbox address - AIDR 	   
macro PDT$L_W_AMCSR = 2336,0,32,1 %;    !  Write CRAM mailbox address - 	AMCSR    
macro PDT$L_W_AMIVR = 2340,0,32,1 %;    !  Write CRAM mailbox address - 	AMIVR    
macro PDT$L_W_AMTCR = 2344,0,32,1 %;    !  Write CRAM mailbox address - 	AMTCR    
macro PDT$L_W_CASRCR = 2348,0,32,1 %;   !  Write CRAM mailbox address - 	CASRCR   
macro PDT$L_W_COMPIRR = 2352,0,32,1 %;  !  Write CRAM mailbox address - COMPIRR  
macro PDT$L_W_CQ0 = 2356,0,32,1 %;      !  Write CRAM mailbox address - CQ0 	   
macro PDT$L_W_CQ1 = 2360,0,32,1 %;      !  Write CRAM mailbox address - CQ1 	   
macro PDT$L_W_CQ2 = 2364,0,32,1 %;      !  Write CRAM mailbox address - CQ2
macro PDT$L_W_DFQ = 2368,0,32,1 %;      !  Write CRAM mailbox address - DFQ 	   
macro PDT$L_W_INIT = 2372,0,32,1 %;     !  Write CRAM mailbox address - INIT 	   
macro PDT$L_W_CICR = 2376,0,32,1 %;     !  Write CRAM mailbox address - CICR 	   
macro PDT$L_W_CECR = 2380,0,32,1 %;     !  Write CRAM mailbox address - CECR 	   
macro PDT$L_W_MFQ = 2384,0,32,1 %;      !  Write CRAM mailbox address - MFQ 	   
macro PDT$L_W_NRE = 2388,0,32,1 %;      !  Write CRAM mailbox address - NRE 	   
macro PDT$L_W_QIR = 2392,0,32,1 %;      !  Write CRAM mailbox address - QIR 	   
macro PDT$L_W_XBE = 2396,0,32,1 %;      !  Write CRAM mailbox address - XBE 	   
macro PDT$L_W_XPD1 = 2400,0,32,1 %;     !  Write CRAM mailbox address - XPD1 	   
macro PDT$L_W_XPD2 = 2404,0,32,1 %;     !  Write CRAM mailbox address - XPD2 	   
macro PDT$L_R_QCMDF = 2408,0,32,1 %;    !  Fwd link of currently outstanding Cmd qbuffs
macro PDT$L_R_QCMDB = 2412,0,32,1 %;    !  Bkd link of currently outstanding Cmd qbuffs
macro PDT$L_R_RSPF = 2416,0,32,1 %;     !  Fwd link of response qbuffs to be processed
macro PDT$L_R_RSPB = 2420,0,32,1 %;     !  Bkd link of response qbuffs to be processed
macro PDT$L_R_DAFQF = 2424,0,32,1 %;    !  Fwd link of free qbuffs in the Driver-Adapter Free Queue
macro PDT$L_R_DAFQB = 2428,0,32,1 %;    !  Bkd link of free qbuffs in the Driver-Adapter Free Queue
macro PDT$L_R_WCMDFL = 2432,0,32,1 %;   !  DSSI command completion wait queue forward link
macro PDT$L_R_WCMDBL = 2436,0,32,1 %;   !  DSSI command completion wait queue backward link
macro PDT$L_R_PCMDFL = 2440,0,32,1 %;   !  Port command completion wait queue forward link
macro PDT$L_R_PCMDBL = 2444,0,32,1 %;   !  Port command completion wait queue backward link
macro PDT$L_R_AB = 2448,0,32,1 %;       !  Pointer to the shared Adapter Block *already defined, may use this one*
macro PDT$L_R_PDT = 2452,0,32,1 %;      !  PDT address of the other channel
macro PDT$PS_GCQIR = 2456,0,32,1 %;     ! Mailbox address of Channel's "greased" command queue insertion register
macro PDT$L_CHANSTATE = 2460,0,32,0 %;  !  Channel specific state transition code
macro PDT$L_R_DCCQ2T = 2464,0,32,1 %;   !  Driver-Adapter Command queue 2 tail pointer
macro PDT$L_R_DCCQ1T = 2468,0,32,1 %;   !  Driver-Adapter Command queue 1 tail pointer
macro PDT$L_R_DCCQ0T = 2472,0,32,1 %;   !  Driver-Adapter Command queue 0 tail pointer
macro PDT$L_R_CNTRS = 2476,0,32,1 %;    !  Pointer to the port counter block area
!  in the Adapter Block free memory space
macro PDT$IL_INITMR = 2480,0,32,0 %;    !  Port initialization timeout value
macro PDT$IL_ENABTMR = 2484,0,32,0 %;   !  Port re-enable timeout value
macro PDT$L_R_KPB = 2488,0,32,1 %;      !  Adapter-wide Kernel Process Block address
!  Make sure following fork block is quadword aligned
macro PDT$IB_BUSRESET_FKBLK = 2492,0,0,1 %;
literal PDT$S_BUSRESET_FKBLK = 32;      !  Fork block used for getting KPB for BUS RESET
macro PDT$L_R_BUSRESET_KPB = 2524,0,32,1 %; !  KPB used for SCSI BUS RESET operation which
!  is triggered by the port driver
macro PDT$L_R_CHNL_KPB = 2528,0,32,1 %; !   KPB used for cleaning up resources and re-enabling
!   a channel
macro PDT$IB_CHNL_FKBLK = 2536,0,0,1 %;
literal PDT$S_CHNL_FKBLK = 32;          !  Fork block used for getting KPB for re-enabling
macro PDT$IB_CHNL_INT_FKBLK = 2576,0,0,1 %;
literal PDT$S_CHNL_INT_FKBLK = 32;      !  Fork block used for channel specific error
macro PDT$IL_CHNL_INT_FKLCK = 2608,0,32,0 %; !  CHNL_INT fork block lock field
macro PDT$IL_CHANNEL = 2612,0,32,0 %;   !  Channel number (0 or 1) of this port
macro PDT$L_R_PORT_CRAM = 2616,0,32,1 %;
macro PDT$L_STS = 2620,0,32,0 %;        !  port device status
macro PDT$V_ONLINE = 2620,30,1,0 %;     !  ONLINE bit is used when we are cleaning
!  up the adapter buffers after powerfail/crash
macro PDT$V_CHNL_CLNUP = 2620,31,1,0 %; !  This bit is used when we are cleaning up the
!  channel resources after the BUS RESET
macro PDT$B_DIPL = 2624,0,8,1 %;
literal PDT$S_DIPL = 1;
macro PDT$B_TQE_IOTO = 2632,0,0,1 %;
literal PDT$S_TQE_IOTO = 64;            !  TQE for I/O timeout
macro PDT$B_TQE_INIT = 2696,0,0,1 %;
literal PDT$S_TQE_INIT = 64;            !  TQE for init forks
macro PDT$L_KNOWN_NODES = 2768,0,32,0 %; !  Map of known nodes
macro PDT$L_PB_MAP = 2772,0,32,0 %;     !  Map of nodes to track failed VCs
 
!*** MODULE $PDTLISTDEF ***
! +
!  SCS PDT LIST  (TYC 15-Feb-89)
!  
!  THIS DATA STRUCTURE CONTAINS A VECTOR LISTING UP TO 32 PDT ADDRESSES OF
!  DYNAMIC LOAD SHARING PORTS.  THE INDEX IS MAINTAINED IN THE SCS
!  LOAD SHARING PORT BIT MAP.
! -
literal PDTLIST$C_MAX_INDEX = 32;
literal PDTLIST$K_LENGTH = 140;
literal PDTLIST$C_LENGTH = 140;
literal PDTLIST$S_PDTLISTDEF = 16;
literal PDTLIST$S_PDTLIST = 16;
macro PDTLIST$L_FLINK = -12,0,32,1 %;   ! FWD LINK 
macro PDTLIST$L_BLINK = -8,0,32,1 %;    ! BCK LINK 
macro PDTLIST$W_SIZE = -4,0,16,0 %;     ! STRUCTURE SIZE IN BYTES 
macro PDTLIST$B_TYPE = -2,0,8,0 %;      ! SCS STRUCTURE TYPE 
macro PDTLIST$B_SUBTYP = -1,0,8,0 %;    ! SCS STRUCTURE SUBTYPE FOR PDTLIST
macro PDTLIST$L_PDTADDR = 0,0,32,1 %;   ! FIRST PDT ADDRESS
 
!*** MODULE $PEMCLSTDEF ***
literal CLST$S_CLSTDEF = 52;
macro CLST$A_FAILURE_FLINK = 0,0,32,0 %;
macro CLST$A_FAILURE_BLINK = 4,0,32,0 %;
macro CLST$W_SIZE = 8,0,16,0 %;
macro CLST$B_TYPE = 10,0,8,0 %;
macro CLST$B_SUBTYPE = 11,0,8,0 %;
macro CLST$L_COMP_ENTRIES = 12,0,32,0 %;
macro CLST$A_CLST_FLINK = 16,0,32,0 %;
macro CLST$A_CLST_BLINK = 20,0,32,0 %;
macro CLST$A_HW_HASH_LINK = 24,0,32,0 %;
macro CLST$A_DECNET_HASH_LINK = 28,0,32,0 %;
macro CLST$A_LOCAL_ADAPTER = 32,0,32,0 %;
macro CLST$A_REMOTE_ADAPTER = 36,0,32,0 %;
macro CLST$A_PACKET_LOSS_FLINK = 40,0,32,0 %;
macro CLST$A_PACKET_LOSS_BLINK = 44,0,32,0 %;
macro CLST$L_REFERENCE_COUNT = 48,0,32,0 %;
macro CLST$AA_COMP_LIST = 52,0,0,0 %;
 
!*** MODULE $PEMCOMPDEF ***
literal COMP$C_MAX_NAME_LEN = 110;
literal COMP$C_NODE = 1;
literal COMP$C_ADAPTER = 2;
literal COMP$C_COMPONENT = 3;
literal COMP$C_CLOUD = 4;
literal COMP$C_INVALID = 5;
literal COMP$M_HW_ADDR_VALID = %X'1';
literal COMP$M_DECNET_ADDR_VALID = %X'2';
literal COMP$M_PRIMARY_SUSPECT = %X'4';
literal COMP$M_SECONDARY_SUSPECT = %X'8';
literal COMP$M_PRIMARY_LOSS_SUSPECT = %X'10';
literal COMP$M_SECONDARY_LOSS_SUSPECT = %X'20';
literal COMP$M_CLEAR_LOSS_COUNT = %X'40';
literal COMP$S_COMPDEF = 72;
macro COMP$A_SUSPECT_FLINK = 0,0,32,0 %;
macro COMP$A_SUSPECT_BLINK = 4,0,32,0 %;
macro COMP$W_SIZE = 8,0,16,0 %;
macro COMP$B_TYPE = 10,0,8,0 %;
macro COMP$B_SUBTYPE = 11,0,8,0 %;
macro COMP$B_NAME_LEN = 12,0,8,0 %;
macro COMP$B_NODENAME_LEN = 13,0,8,0 %;
macro COMP$B_COMP_TYPE = 14,0,8,0 %;
macro COMP$B_FLAGS = 15,0,8,0 %;
macro COMP$V_HW_ADDR_VALID = 15,0,1,0 %;
macro COMP$V_DECNET_ADDR_VALID = 15,1,1,0 %;
macro COMP$V_PRIMARY_SUSPECT = 15,2,1,0 %;
macro COMP$V_SECONDARY_SUSPECT = 15,3,1,0 %;
macro COMP$V_PRIMARY_LOSS_SUSPECT = 15,4,1,0 %;
macro COMP$V_SECONDARY_LOSS_SUSPECT = 15,5,1,0 %;
macro COMP$V_CLEAR_LOSS_COUNT = 15,6,1,0 %;
macro COMP$A_NAME = 16,0,32,0 %;
macro COMP$AB_HW_ADDR = 20,0,0,0 %;
literal COMP$S_HW_ADDR = 6;
macro COMP$AB_DECNET_ADDR = 26,0,0,0 %;
literal COMP$S_DECNET_ADDR = 6;
macro COMP$A_COMP_FLINK = 32,0,32,0 %;
macro COMP$A_COMP_BLINK = 36,0,32,0 %;
macro COMP$L_REFERENCE_COUNT = 40,0,32,0 %;
macro COMP$L_WORKING_COUNT = 44,0,32,0 %;
macro COMP$L_SUSPECT_COUNT = 48,0,32,0 %;
macro COMP$L_PRIME_SUSPECT = 52,0,32,0 %;
macro COMP$L_SECONDARY_SUSPECT = 56,0,32,0 %;
macro COMP$L_PACKET_LOSS = 60,0,32,0 %;
macro COMP$A_PACKET_LOSS_FLINK = 64,0,32,0 %;
macro COMP$A_PACKET_LOSS_BLINK = 68,0,32,0 %;
 
!*** MODULE $PFBDEF ***
! +
!  PAGE FAULT MONITOR BUFFER
! -
literal PFB$B_USER_BUFFER = 12;
literal PFB$B_BUFFER = 20;              ! Beginning of PC/VA pairs
literal PFB$K_LENGTH = 524;             ! Length of PFB 
literal PFB$C_LENGTH = 524;             ! Length of PFB 
literal PFB$S_PFBDEF = 524;
literal PFB$S_PFB = 524;
macro PFB$L_FLINK = 0,0,32,1 %;         ! Forward link
macro PFB$L_BLINK = 4,0,32,1 %;         ! Back    link
macro PFB$W_SIZE = 8,0,16,0 %;          ! Structure size
macro PFB$B_TYPE = 10,0,8,0 %;          ! Dynamic structure type (PFB)
macro PFB$R_USER_BUFFER = 12,0,0,0 %;
literal PFB$S_USER_BUFFER = 512;        ! Buffer returned to user
macro PFB$L_RECCNT = 12,0,32,0 %;       ! Record count
macro PFB$L_OVERFLOW = 16,0,32,0 %;     ! Overflow count
 
!*** MODULE $PFLDEF ***
! +
!  PAGE FILE CONTROL BLOCK
! -
! 
!  ***** L_VBN, L_WINDOW, and L_PFC must be the same offset values as the
!  ***** equivalently named offsets in $SECDEF
! 
literal PFL$K_LENGTH = 64;              ! SIZE OF PAGE FILE CONTROL BLOCK 
literal PFL$C_LENGTH = 64;              ! SIZE OF PAGE FILE CONTROL BLOCK 
literal PFL$M_INITED = %X'1';
literal PFL$M_PAGFILFUL = %X'2';
literal PFL$M_SWPFILFUL = %X'4';
literal PFL$M_DINSPEN = %X'10';
literal PFL$M_STOPPER = %X'80000000';
literal PFL$S_PFLDEF = 68;              !  Old size name - synonym
literal PFL$S_PFL = 68;
macro PFL$L_BITMAP = 0,0,32,1 %;        ! ADDRESS OF START OF BIT MAP 
! BIT = 1 MEANS AVAILABLE
macro PFL$L_STARTBYTE = 4,0,32,0 %;     ! STARTING BYTE OFFSET TO SCAN 
macro PFL$W_SIZE = 8,0,16,0 %;          ! SIZE OF PAGE FILE CONTROL BLOCK 
macro PFL$B_TYPE = 10,0,8,0 %;          ! PAGE FILE CONTROL BLOCK TYPE CODE 
macro PFL$L_PFC = 12,0,32,0 %;          ! PAGE FAULT CLUSTER FOR PAGE READS 
macro PFL$L_WINDOW = 16,0,32,1 %;       ! WINDOW ADDRESS 
macro PFL$L_VBN = 20,0,32,0 %;          ! BASE VBN 
macro PFL$L_BITMAPSIZ = 24,0,32,0 %;    ! SIZE IN BYTES OF PAGE FILE 
macro PFL$L_FREPAGCNT = 28,0,32,0 %;    ! COUNT - 1 OF PAGES WHICH MAY BE ALLOCATED 
macro PFL$L_MINFREPAGCNT = 32,0,32,0 %; !  Minimum free page count
macro PFL$L_RSRVPAGCNT = 36,0,32,0 %;   !  Count of pages which may be reserved
!  without "overcommiting" the pagefile
macro PFL$L_REFCNT = 40,0,32,0 %;       !  No. of processes using this pagefile
macro PFL$L_SWPREFCNT = 44,0,32,0 %;    !  No. of processes using this file for swapping
macro PFL$L_MAXVBN = 48,0,32,0 %;       ! MASK APPLIED TO PTE WITH PAGING FILE 
!  BACKING STORE ADDRESS
macro PFL$L_PGFLX = 52,0,32,0 %;        !  Page file vector index
macro PFL$L_ALLOCSIZ = 56,0,32,0 %;     ! CURRENT ALLOCATION REQUEST SIZE
!  (cannot exceed MPW PFC parameter)
macro PFL$L_FLAGS = 60,0,32,0 %;        ! FLAGS FOR THIS PAGE FILE 
macro PFL$V_INITED = 60,0,1,0 %;        ! THIS PAGE FILE IS USABLE 
macro PFL$V_PAGFILFUL = 60,1,1,0 %;     ! REQUEST FOR PAGING SPACE HAS FAILED 
macro PFL$V_SWPFILFUL = 60,2,1,0 %;     ! REQUEST FOR SWAPPING SPACE HAS FAILED 
macro PFL$V_DINSPEN = 60,4,1,0 %;       !  File deinstall pending
macro PFL$V_STOPPER = 60,31,1,0 %;      ! RESERVED FOR ALL TIME (MUST NEVER BE SET) 
macro PFL$L_BITMAPLOC = 64,0,32,0 %;    ! BITMAP MUST FOLLOW FLAGS
 
!*** MODULE $PFLMAPDEF ***
! +
!  PAGE FILE MAPPING WINDOW BLOCK
! -
literal PFLMAP$C_MAXPTRS = 61;
literal PFLMAP$K_LENGTH = 508;          ! Size of structure
literal PFLMAP$C_LENGTH = 508;          ! Size of structure
literal PFLMAP$S_PFLMAPDEF = 20;
literal PFLMAP$S_PFLMAP = 20;
macro PFLMAP$L_PAGECNT = 0,0,32,0 %;    ! Total pages in all pointers
macro PFLMAP$W_SIZE = 8,0,16,0 %;       ! Size of structure
macro PFLMAP$B_TYPE = 10,0,8,0 %;       ! Structure type (DYN$C_PFLMAP)
macro PFLMAP$B_ACTPTRS = 11,0,8,0 %;    ! No. of active pointers in window
macro PFLMAP$Q_PTR = 12,0,0,0 %;
literal PFLMAP$S_PTR = 8;               ! Beginning of mapping pointers
!  The structure overhead includes an extra mapping pointer not included
!  in the calculation of "MAXPTRS" below. This mapping pointer is for
!  "overflow" and is included to simplify the logic that does the space
!  allocation and structure maintenance.
!  structure OH + ptrs <= 1 page
 
!*** MODULE $PFNDEF ***
! +
!  PFN Data Base Definitions
! -
! 
!  Define the PFN database record offsets.
! 
!  XDELTA provides embedded command strings for displaying the PFN database records. Any
!  change to the PFN database record here must be implemented in the XDELTA command strings
!  as well to avoid breaking them.
! 
literal PFN$C_ENTRY_SHIFT_SIZE = 5;
literal PFN$C_ENTRY_SIZE = 32;
! 
literal PFN$M_PAGTYP = %X'7';
literal PFN$M_LOC = %X'F0';
literal PFN$M_BUFOBJ = %X'100';
literal PFN$M_COLLISION = %X'200';
literal PFN$M_BADPAG = %X'400';
literal PFN$M_RPTEVT = %X'800';
literal PFN$M_DELCON = %X'1000';
literal PFN$M_MODIFY = %X'2000';
literal PFN$M_UNAVAILABLE = %X'4000';
literal PFN$M_SWPPAG_VALID = %X'8000';
literal PFN$M_TYP0 = %X'10000';
literal PFN$M_PARTIAL_SECTION = %X'80000';
literal PFN$M_GBLBAK = %X'80000000';
literal PFN$M_STX = %X'FFFF00000000';
literal PFN$M_CRF = %X'1000000000000';
literal PFN$M_DZRO = %X'2000000000000';
literal PFN$M_WRT = %X'4000000000000';
literal PFN$M_STX_HIBIT = %X'8000000000000';
literal PFN$M_PGFLPAG = %X'FFFFF00000000';
literal PFN$M_PRCPGFLX = %X'30000000000000';
literal PFN$M_PGFLX = %X'FF00000000000000';
literal PFN$M_BAKX = %X'FFFFFFFF00000000';
literal PFN$M_GPTX = %X'FFFFFFFF00000000';
literal PFN$C_FREPAGLST = 0;            !  On FREE page list
literal PFN$C_MFYPAGLST = 1;            !  On MODIFIED page list
literal PFN$C_BADPAGLST = 2;            !  On BAD page list
literal PFN$C_RELPEND = 3;              !  RELease PENDing
!   (when REFCNT=0 release PFN)
literal PFN$C_RDERR = 4;                !  Read error while paging in
literal PFN$C_WRTINPROG = 5;            !  Write in progress (by MFY PAG WRITER)
literal PFN$C_RDINPROG = 6;             !  Read in progress (page in)
literal PFN$C_ZERO_LIST = 7;            !  On ZEROED page list
literal PFN$C_ACTIVE = 15;              !  Page is ACTIVE and VALID
! 
literal PFN$C_PROCESS = 0;              !  Process page
literal PFN$C_SYSTEM = 1;               !  System page
literal PFN$C_GLOBAL = 2;               !  Global page (read only)
literal PFN$C_GBLWRT = 3;               !  Global Writable page
literal PFN$C_PPGTBL = 4;               !  Process Page Table
literal PFN$C_GPGTBL = 5;               !  Global Page Table
literal PFN$C_RESERVED = 6;             !   reserved
literal PFN$C_UNKNOWN = 7;              !  Uninitialized db for this PFN
literal PFN$S_PFNDEF = 32;
literal PFN$S_PFN = 32;
macro PFN$L_FLINK = 0,0,32,1 %;         !  Forward PFN link pointer
macro PFN$L_SHRCNT = 0,0,32,0 %;        !  Number of process PTEs mapped to global page
macro PFN$L_BLINK = 4,0,32,1 %;         !  Backward PFN link pointer
macro PFN$L_WSLX = 4,0,32,0 %;          !  Working Set List Index for valid page
macro PFN$L_PAGE_STATE = 8,0,32,0 %;    !  Page state information
macro PFN$L_PTE = 12,0,32,1 %;          !  Address of PTE that maps this page
macro PFN$Q_BAK = 16,0,0,0 %;
literal PFN$S_BAK = 8;                  !  Backing store address for this page
macro PFN$L_COLOR_FLINK = 16,0,32,0 %;  !  Forward PFN link for page's color list
macro PFN$L_COLOR_BLINK = 20,0,32,0 %;  !  Backward PFN link for page's color list
macro PFN$L_REFCNT = 24,0,32,0 %;       !  Number of reasons a page should not be released
macro PFN$W_SWPPAG = 28,0,16,0 %;       !  Page number in swap area to receive this page
macro PFN$W_BO_REFC = 28,0,16,0 %;      !  Buffer Object reference count (no swap possible)
!  VIELD definitions in PFN$AL_PAGE_STATE
! 
macro PFN$V_PAGTYP = 0,0,3,0 %;
literal PFN$S_PAGTYP = 3;               !  Page type
macro PFN$V_LOC = 0,4,4,0 %;
literal PFN$S_LOC = 4;                  !  Location of page
macro PFN$V_BUFOBJ = 0,8,1,0 %;         !  Set if any buffer objects reference this PFN
macro PFN$V_COLLISION = 0,9,1,0 %;      !  Empty collision queue when page read complete
macro PFN$V_BADPAG = 0,10,1,0 %;        !  Bad page bit
macro PFN$V_RPTEVT = 0,11,1,0 %;        !  Report event on I/O complete
macro PFN$V_DELCON = 0,12,1,0 %;        !  Delete PFN contents when REF=0
macro PFN$V_MODIFY = 0,13,1,0 %;        !  Modify bit, indicates page is dirty
macro PFN$V_UNAVAILABLE = 0,14,1,0 %;   !  PFN is unavailable to software (such as for console)
macro PFN$V_SWPPAG_VALID = 0,15,1,0 %;  !  Set if SWPPAG contains a swap page number
! 
!  VIELD definitions in PFN$AQ_BAK
! 
macro PFN$V_TYP0 = 0,16,1,0 %;          !  Backing store in section (not pagefile)
macro PFN$V_PARTIAL_SECTION = 0,19,1,0 %; !  Page only partially maps a section
macro PFN$V_GBLBAK = 0,31,1,0 %;        !  Global backing store address (GPTX form)
macro PFN$V_STX = 9,0,16,1 %;
literal PFN$S_STX = 16;                 !  Section Table Index
macro PFN$V_CRF = 9,16,1,0 %;           !  Copy on Reference
macro PFN$V_DZRO = 9,17,1,0 %;          !  Demand Zero
macro PFN$V_WRT = 9,18,1,0 %;           !  Section file accessed for write
macro PFN$V_STX_HIBIT = 9,19,1,0 %;
macro PFN$V_PGFLPAG = 9,0,20,0 %;
literal PFN$S_PGFLPAG = 20;             !  Page file page (not a VBN)
macro PFN$V_PRCPGFLX = 9,20,2,0 %;
literal PFN$S_PRCPGFLX = 2;             !  PROCESS page file index
macro PFN$V_PGFLX = 9,24,8,0 %;
literal PFN$S_PGFLX = 8;                !  SYSTEM page file index 
macro PFN$V_BAKX = 9,0,32,0 %;
literal PFN$S_BAKX = 32;                !  Backup address (uninterpreted)
macro PFN$V_GPTX = 9,0,32,0 %;
literal PFN$S_GPTX = 32;                !  Global Page Table Index
! 
!  Location VIELD values
! 
!  Page Type VIELD definitions
! 
 
!*** MODULE $PFREEDEF ***
! +
!  PFREE - Pool free block
! 
!  This defines the common layout of a pool free block. Some fields are used
!  only by pool checking code. NOTE WELL: Some of these fields must be at the
!  same offsets as in the fork block.
! -
literal PFREE$K_LENGTH = 36;            !  Length of poisoned block header
literal PFREE$S_PFREEDEF = 36;
literal PFREE$S_PFREE = 36;
macro PFREE$L_FLINK = 0,0,32,1 %;       !  Forward link
macro PFREE$L_BLINK = 4,0,32,1 %;       !  Queue backward link
macro PFREE$L_FREE_SIZE = 4,0,32,0 %;   !  Free block size
macro PFREE$W_SIZE = 8,0,16,0 %;        !  Standard size field
macro PFREE$B_TYPE = 10,0,8,0 %;        !  Standard type field
macro PFREE$B_FLCK = 11,0,8,0 %;        !  Fork lock index
macro PFREE$B_RMOD = 11,0,8,0 %;        !  Request mode
macro PFREE$B_SUBTYPE = 11,0,8,0 %;     !  Block subtype
macro PFREE$L_DEAL_PC = 12,0,32,1 %;    !  Deallocater return PC
macro PFREE$L_FPC = 12,0,32,1 %;        !  Fork PC
macro PFREE$L_IPL = 16,0,32,0 %;        !  COM$DRVDEALMEM IPL
macro PFREE$Q_FR3 = 16,0,0,1 %;
literal PFREE$S_FR3 = 8;                !  Fork R3
macro PFREE$L_CDDM_PC = 24,0,32,1 %;    !  COM$DRVDEALMEM return PC
macro PFREE$Q_FR4 = 24,0,0,1 %;
literal PFREE$S_FR4 = 8;                !  Fork R4
macro PFREE$L_CHECKSUM = 32,0,32,0 %;   !  Pool poisoning checksum
 
!*** MODULE $PHDDEF ***
! 
!  Process Header Definitions.  The process header contains the swappable
!  scheduler and memory management data bases for a process in the balance set.
! 
literal PHD$M_ASTEN = %X'F';
literal PHD$M_ASTSR = %X'F0';
literal PHD$M_ASTEN_KEN = %X'1';
literal PHD$M_ASTEN_EEN = %X'2';
literal PHD$M_ASTEN_SEN = %X'4';
literal PHD$M_ASTEN_UEN = %X'8';
literal PHD$M_ASTSR_KPD = %X'10';
literal PHD$M_ASTSR_EPD = %X'20';
literal PHD$M_ASTSR_SPD = %X'40';
literal PHD$M_ASTSR_UPD = %X'80';
literal PHD$M_FEN = %X'1';
literal PHD$M_PME = %X'4000000000000000';
literal PHD$M_DATFX = %X'8000000000000000';
literal PHD$C_HWPCBLEN = 128;           !  Length of HWPCB
literal PHD$K_HWPCBLEN = 128;           !  Length of HWPCB
! 
literal PHD$C_FPR_COUNT = 32;           !  Count of saved FP registers
literal PHD$K_FPR_COUNT = 32;           !  Count of saved FP registers
literal PHD$C_PHDPAGCTX = 8;            !  Size of context for PHD pages 
literal PHD$M_PFMFLG = %X'1';
literal PHD$M_DALCSTX = %X'2';
literal PHD$M_WSPEAKCHK = %X'4';
literal PHD$M_NOACCVIO = %X'8';
literal PHD$M_IWSPEAKCK = %X'10';
literal PHD$M_IMGDMP = %X'20';
literal PHD$M_NO_WS_CHNG = %X'40';
literal PHD$M_PGFLACC = %X'80';
literal PHD$M_LOCK_HEADER = %X'100';
literal PHD$M_SW_FEN = %X'1';
literal PHD$M_AST_PENDING = %X'80000000';
literal PHD$K_LENGTH = 760;             !  Length of fixed part of process header 
literal PHD$C_LENGTH = 760;             !  Length of fixed part of the process header 
literal PHD$S_PHD = 768;
macro PHD$Q_PRIVMSK = 0,0,0,0 %;
literal PHD$S_PRIVMSK = 8;              !  Privilege mask
macro PHD$W_SIZE = 8,0,16,0 %;          !  Structure size
macro PHD$B_TYPE = 10,0,8,0 %;          !  Dynamic structure type (PHD)
! 
!  Working set list pointers - these contain longword offsets from the beginning
!  of the process header.
! 
macro PHD$L_WSLIST = 12,0,32,0 %;       !  1st working set list entry 
macro PHD$L_WSLOCK = 16,0,32,0 %;       !  1st locked working set list entry 
macro PHD$L_WSDYN = 20,0,32,0 %;        !  1st dynamic working set list entry 
macro PHD$L_WSNEXT = 24,0,32,0 %;       !  Last WSL entry replaced 
macro PHD$L_WSLAST = 28,0,32,0 %;       !  Last WSL entry in list 
! 
!  The following three longwords specify the maximum and initial working set
!  sizes for the process.  Rather than containing the count of pages, they
!  contains the longword index to what would be the last working set list entry.
!  
macro PHD$L_WSEXTENT = 32,0,32,0 %;     !  Max working set size against borrowing 
macro PHD$L_WSQUOTA = 36,0,32,0 %;      !  Quota on working set size 
macro PHD$L_DFWSCNT = 40,0,32,0 %;      !  Default working set size 
macro PHD$L_CPULIM = 44,0,32,0 %;       !  Limit on CPU time for process 
! 
!  Process Section Table data base - PSTBASOFF is the byte offset
!  from the beginning of the process header to the first longword beyond
!  the process section table.  PSTLAST and PSTFREE are the section
!  table indices which are the negative longword index from the end of the
!  section table to the section table entry.
! 
macro PHD$L_PSTBASOFF = 48,0,32,0 %;    !  Byte offset to base of PST 
!   First longword not in PST
!   PST grows backwards from here
macro PHD$L_PSTLAST = 52,0,32,0 %;      !  End of process section table 
!   (Address of last PSTE allocated)
macro PHD$L_PSTFREE = 56,0,32,0 %;      !  Head of free PSTE list 
! 
!  Create/Delete Page Context
! 
macro PHD$L_P0LENGTH = 60,0,32,0 %;     !  Byte length of P0 portion of L3 page table
macro PHD$L_P1LENGTH = 64,0,32,0 %;     !  Byte length of P1 portion of L3 page table
macro PHD$L_FREP0VA = 68,0,32,1 %;      !  1st free virtual address at end of P0 space 
macro PHD$L_FREPTECNT = 72,0,32,0 %;    !  Count of free PTEs between the ends 
!   of the P0 and P1 page tables
macro PHD$L_FREP1VA = 76,0,32,1 %;      !  1st free virtual address at end of P1 space 
macro PHD$L_DFPFC = 80,0,32,0 %;        !  Default page fault cluster 
macro PHD$L_PGTBPFC = 84,0,32,0 %;      !  Page table cluster factor 
! 
!  Quotas and Limits
! 
macro PHD$L_QUANT = 88,0,32,0 %;        !  Accumulated CPU time since last quantum overflow
macro PHD$L_ASTLM = 92,0,32,0 %;        !  AST limit 
macro PHD$L_WSLX = 96,0,32,1 %;         !  Pointer to working set list index save area
macro PHD$L_BAK = 100,0,32,1 %;         !  Pointer to backup address vector for 
!  process header pages
macro PHD$L_PSTBASMAX = 100,0,32,1 %;   !  LW offset to top PST address 
macro PHD$L_WSSIZE = 104,0,32,0 %;      !  Current allowed working set size 
macro PHD$L_DIOCNT = 108,0,32,0 %;      !  Direct I/O count 
macro PHD$L_BIOCNT = 112,0,32,0 %;      !  Buffered I/O count
macro PHD$L_PHVINDEX = 116,0,32,0 %;    !  Process header vector index 
macro PHD$Q_PAGFIL = 120,0,0,0 %;
literal PHD$S_PAGFIL = 8;               !  Template to assign page file backing store
macro PHD$B_PAGFIL = 127,0,8,0 %;       !  Current SYSTEM page file index
! 
!  Hardware Privileged Context Block (HWPCB) - This structure must be aligned to
!  a 128 byte boundary. Natural alignment prevents the structure from crossing a
!  page boundary.
! 
!  NOTE WELL: There are bit symbols defined here for accessing the saved ASTEN,
! 	ASTSR, FEN and DATFX values in the HWPCB. These symbols are NOT to be used when
! 	interfacing to the ASTEN, ASTSR, FEN or DATFX internal processor registers directly.
! 	See the specific internal register definitions for bitmasks and constants
! 	to be used when interfacing to the IPRs directly.
! 
macro PHD$Q_HWPCB = 128,0,0,0 %;
literal PHD$S_HWPCB = 8;                !  Base of HWPCB
macro PHD$Q_KSP = 128,0,0,0 %;
literal PHD$S_KSP = 8;                  !  Kernel stack pointer
macro PHD$Q_ESP = 136,0,0,0 %;
literal PHD$S_ESP = 8;                  !  Executive stack pointer
macro PHD$Q_SSP = 144,0,0,0 %;
literal PHD$S_SSP = 8;                  !  Supervisor stack pointer
macro PHD$Q_USP = 152,0,0,0 %;
literal PHD$S_USP = 8;                  !  User stack pointer
macro PHD$Q_PTBR = 160,0,0,0 %;
literal PHD$S_PTBR = 8;                 !  Page Table Base Register
macro PHD$Q_ASN = 168,0,0,0 %;
literal PHD$S_ASN = 8;                  !  Address Space Number
macro PHD$Q_ASTSR_ASTEN = 176,0,0,0 %;
literal PHD$S_ASTSR_ASTEN = 8;          !  ASTSR / ASTEN quadword
macro PHD$V_ASTEN = 176,0,4,0 %;
literal PHD$S_ASTEN = 4;                !  AST Enable Register
macro PHD$V_ASTSR = 176,4,4,0 %;
literal PHD$S_ASTSR = 4;                !  AST Pending Summary Register
macro PHD$V_ASTEN_KEN = 176,0,1,0 %;    !  Kernel AST Enable = 1
macro PHD$V_ASTEN_EEN = 176,1,1,0 %;    !  Executive AST Enable = 1
macro PHD$V_ASTEN_SEN = 176,2,1,0 %;    !  Supervisor AST Enable = 1
macro PHD$V_ASTEN_UEN = 176,3,1,0 %;    !  User AST Enable = 1
macro PHD$V_ASTSR_KPD = 176,4,1,0 %;    !  Kernel AST Pending = 1
macro PHD$V_ASTSR_EPD = 176,5,1,0 %;    !  Executive AST Pending = 1
macro PHD$V_ASTSR_SPD = 176,6,1,0 %;    !  Supervisor AST Pending = 1
macro PHD$V_ASTSR_UPD = 176,7,1,0 %;    !  User AST Pending = 1
macro PHD$Q_FEN_DATFX = 184,0,0,0 %;
literal PHD$S_FEN_DATFX = 8;            !  Floating Point Enable
macro PHD$V_FEN = 184,0,1,0 %;          !  Floating Point Enable = 1
macro PHD$V_PME = 188,30,1,0 %;         !  Performance Monitor Enable
macro PHD$V_DATFX = 188,31,1,0 %;       !  Data Alignment Trap Fixup
macro PHD$Q_CC = 192,0,0,0 %;
literal PHD$S_CC = 8;                   !  Cycle Counter
macro PHD$Q_UNQ = 200,0,0,0 %;
literal PHD$S_UNQ = 8;                  !  Process Unique Value
macro PHD$Q_PAL_RSVD = 208,0,0,1 %;
literal PHD$S_PAL_RSVD = 48;            !  Reserved for PAL Scratch
!  End of Hardware Privileged Context Block (HWPCB).
! 
! 
!  Floating Point Register Save Area. There is space for 32 floating
!  point registers, F0 through F30, and the FPCR. Note that F31 is a 
!  fixed sink register that doesn't need to be saved.
! 
macro PHD$Q_FPR = 256,0,0,1 %;
literal PHD$S_FPR = 256;                !  Space for 32 floating point registers
macro PHD$Q_F0 = 256,0,0,0 %;
literal PHD$S_F0 = 8;                   !  Floating Point Register F0
macro PHD$Q_F1 = 264,0,0,0 %;
literal PHD$S_F1 = 8;                   !  F1
macro PHD$Q_F2 = 272,0,0,0 %;
literal PHD$S_F2 = 8;                   !  F2
macro PHD$Q_F3 = 280,0,0,0 %;
literal PHD$S_F3 = 8;                   !  F3
macro PHD$Q_F4 = 288,0,0,0 %;
literal PHD$S_F4 = 8;                   !  F4
macro PHD$Q_F5 = 296,0,0,0 %;
literal PHD$S_F5 = 8;                   !  F5
macro PHD$Q_F6 = 304,0,0,0 %;
literal PHD$S_F6 = 8;                   !  F6
macro PHD$Q_F7 = 312,0,0,0 %;
literal PHD$S_F7 = 8;                   !  F7
macro PHD$Q_F8 = 320,0,0,0 %;
literal PHD$S_F8 = 8;                   !  F8
macro PHD$Q_F9 = 328,0,0,0 %;
literal PHD$S_F9 = 8;                   !  F9
macro PHD$Q_F10 = 336,0,0,0 %;
literal PHD$S_F10 = 8;                  !  F10
macro PHD$Q_F11 = 344,0,0,0 %;
literal PHD$S_F11 = 8;                  !  F11
macro PHD$Q_F12 = 352,0,0,0 %;
literal PHD$S_F12 = 8;                  !  F12
macro PHD$Q_F13 = 360,0,0,0 %;
literal PHD$S_F13 = 8;                  !  F13
macro PHD$Q_F14 = 368,0,0,0 %;
literal PHD$S_F14 = 8;                  !  F14
macro PHD$Q_F15 = 376,0,0,0 %;
literal PHD$S_F15 = 8;                  !  F15
macro PHD$Q_F16 = 384,0,0,0 %;
literal PHD$S_F16 = 8;                  !  F16
macro PHD$Q_F17 = 392,0,0,0 %;
literal PHD$S_F17 = 8;                  !  F17
macro PHD$Q_F18 = 400,0,0,0 %;
literal PHD$S_F18 = 8;                  !  F18
macro PHD$Q_F19 = 408,0,0,0 %;
literal PHD$S_F19 = 8;                  !  F19
macro PHD$Q_F20 = 416,0,0,0 %;
literal PHD$S_F20 = 8;                  !  F20
macro PHD$Q_F21 = 424,0,0,0 %;
literal PHD$S_F21 = 8;                  !  F21
macro PHD$Q_F22 = 432,0,0,0 %;
literal PHD$S_F22 = 8;                  !  F22
macro PHD$Q_F23 = 440,0,0,0 %;
literal PHD$S_F23 = 8;                  !  F23
macro PHD$Q_F24 = 448,0,0,0 %;
literal PHD$S_F24 = 8;                  !  F24
macro PHD$Q_F25 = 456,0,0,0 %;
literal PHD$S_F25 = 8;                  !  F25
macro PHD$Q_F26 = 464,0,0,0 %;
literal PHD$S_F26 = 8;                  !  F26
macro PHD$Q_F27 = 472,0,0,0 %;
literal PHD$S_F27 = 8;                  !  F27
macro PHD$Q_F28 = 480,0,0,0 %;
literal PHD$S_F28 = 8;                  !  F28
macro PHD$Q_F29 = 488,0,0,0 %;
literal PHD$S_F29 = 8;                  !  F29
macro PHD$Q_F30 = 496,0,0,0 %;
literal PHD$S_F30 = 8;                  !  F30
macro PHD$Q_FPCR = 504,0,0,0 %;
literal PHD$S_FPCR = 8;                 !  FPCR
! 
!  End of Floating Point Register Save Area.
! 
macro PHD$Q_ASNSEQ = 512,0,0,0 %;
literal PHD$S_ASNSEQ = 8;               !  Address Space Number Sequence
macro PHD$Q_LEFC = 520,0,0,0 %;
literal PHD$S_LEFC = 8;                 !  Local event flags
macro PHD$L_LEFC_0 = 520,0,32,0 %;      !  Cluster 0
macro PHD$L_LEFC_1 = 524,0,32,0 %;      !  Cluster 1
macro PHD$L_L2PT_VA = 528,0,32,1 %;     !  Virtual address of Level 2 Page Table
macro PHD$L_L3PT_VA = 532,0,32,1 %;     !  Virtual address of Level 3 Page Tables
macro PHD$L_L3PT_VA_P1 = 536,0,32,1 %;  !  Virtual address of "P1" Level 3 Page Tables
macro PHD$L_PAGEFLTS = 540,0,32,0 %;    !  Count of page faults 
macro PHD$L_FOW_FLTS = 544,0,32,0 %;    !  Count of Fault On Write faults incurred
macro PHD$L_FOR_FLTS = 548,0,32,0 %;    !  Count of Fault On Read faults incurred
macro PHD$L_FOE_FLTS = 552,0,32,0 %;    !  Count of Fault On Execute faults incurred
macro PHD$L_CPUTIM = 556,0,32,0 %;      !  Accumulated CPU time charged 
macro PHD$L_CPUMODE = 560,0,32,0 %;     !  Access mode to notify about cputime 
macro PHD$L_AWSMODE = 564,0,32,0 %;     !  Access mode flag for auto WS AST 
macro PHD$L_PRCPAGFIL = 568,0,32,0 %;   !  Current PROCESS page file index
macro PHD$L_PGFLCNT = 572,0,32,0 %;     !  Number of assigned page files
! 
!  Page Table Statistics
! 
macro PHD$L_PTWSLELCK = 576,0,32,0 %;   !  Byte offset to longword array of counts 
!   of locked WSLE's in this page table
macro PHD$L_PTWSLEVAL = 580,0,32,0 %;   !  Byte offset to longword array of counts 
!   of valid WSLE's in this page table
macro PHD$L_PTCNTLCK = 584,0,32,0 %;    !  Count of page tables containing 
!   1 or more locked WSLE
macro PHD$L_PTCNTVAL = 588,0,32,0 %;    !  Count of page tables containing 
!   1 or more valid WSLE
macro PHD$L_PTCNTACT = 592,0,32,0 %;    !  Count of active page tables 
macro PHD$L_PTCNTMAX = 596,0,32,0 %;    !  Max count of page tables 
!   which have non-zero PTEs
macro PHD$L_WSFLUID = 600,0,32,1 %;     !  Guaranteed number of fluid WS pages 
macro PHD$L_EMPTPG = 604,0,32,0 %;      !  Count of empty working set pages 
macro PHD$L_EXTDYNWS = 608,0,32,0 %;    !  Extra dynamic working set list entries 
!   above required WSFLUID minimum
macro PHD$L_PRCPGFLPAGES = 612,0,32,0 %; !  Remaining number of reserved pages in
!   the current process page file
macro PHD$L_PRCPGFLOPAGES = 616,0,32,0 %; !  Original number of reserved pages in
!   the current process page file
macro PHD$B_PRCPGFL = 620,0,32,0 %;
literal PHD$S_PRCPGFL = 4;              !  Current SYSTEM page file assignments
macro PHD$L_WSAUTH = 624,0,32,0 %;      !  Authorized working set size 
macro PHD$L_WSAUTHEXT = 628,0,32,0 %;   !  Authorized WS extent 
macro PHD$L_RESLSTH = 632,0,32,1 %;     !  Pointer to resource list 
macro PHD$L_AUTHPRI = 636,0,32,0 %;     !  Initial process priority 
macro PHD$Q_AUTHPRIV = 640,0,0,0 %;
literal PHD$S_AUTHPRIV = 8;             !  Authorized privileges mask
macro PHD$Q_IMAGPRIV = 648,0,0,0 %;
literal PHD$S_IMAGPRIV = 8;             !  Installed image privileges mask
macro PHD$L_IMGCNT = 656,0,32,0 %;      !  Image counter bumped by SYSRUNDWN 
macro PHD$L_PFLTRATE = 660,0,32,0 %;    !  Page fault rate 
macro PHD$L_PFLREF = 664,0,32,0 %;      !  Page faults at end of last interval 
macro PHD$L_TIMREF = 668,0,32,0 %;      !  Time at end of last interval 
macro PHD$L_PGFLTIO = 672,0,32,0 %;     !  Count of pagefault I/O 
macro PHD$R_MIN_CLASS = 676,0,0,0 %;
literal PHD$S_MIN_CLASS = 20;           !  Minimum authorized security clearance
macro PHD$R_MAX_CLASS = 696,0,0,0 %;
literal PHD$S_MAX_CLASS = 20;           !  Maximum authorized security clearance
macro PHD$L_PRCPGFLREFS = 716,0,0,0 %;
literal PHD$S_PRCPGFLREFS = 16;         !  # pages currently being used 
!  in each process page file
macro PHD$L_PPGFLVA = 732,0,32,0 %;     !  "Quota" of available pages which may
!  have page file backing store
! 
!  ***** BE CAREFUL ABOUT SYNCHRONIZING ACCESS TO THESE FLAGS !! *****
! 
!  Before adding new flags to this longword, READ and UNDERSTAND the following.
! 
!  Any new flag that requires a change to this synchronization model means that
!  all references to the longword containing these flags must be reviewed.
! 
! 	The current set of flags is synchronized in the following way. All flags are
! 	written only in process context. Therefore, their basic synchronization is
! 	by executing at IPL=IPL$_MMG. Note that this is NOT the same as saying that
! 	the MMG spinlock is needed. (Requiring all writes to occur under MMG would
! 	work, but it's overkill given the current set of flags.)
! 
! 	Some of these flags are written at lower IPLs using Load-Locked/Store-Conditional
! 	sequences. This is OK, because any write at IPL$_MMG will cause the lower IPL
! 	write to be reexecuted. Writes at IPL$_MMG need not be interlocked since the writes
! 	are synchronized by virtue of occurring at the synchronization IPL.
! 
!  EXCEPTION !!
! 
! 	If the flags are for the system PHD, then being at IPL$_MMG is not enough
! 	protection. In this case only, even the writes that occur at this IPL must
! 	be done as interlocked sequences since this is not a case of being limited
! 	to process context only.
! 
macro PHD$L_FLAGS = 736,0,32,0 %;       !  Flags longword
macro PHD$V_PFMFLG = 736,0,1,0 %;       !  Page fault monitoring enabled 
macro PHD$V_DALCSTX = 736,1,1,0 %;      !  Need to deallocate section indices 
macro PHD$V_WSPEAKCHK = 736,2,1,0 %;    !  Check for new working set size (proc) 
macro PHD$V_NOACCVIO = 736,3,1,0 %;     !  Set after inswap of process header 
macro PHD$V_IWSPEAKCK = 736,4,1,0 %;    !  Check for new working set size (image) 
macro PHD$V_IMGDMP = 736,5,1,0 %;       !  Take image dump on error exit
macro PHD$V_NO_WS_CHNG = 736,6,1,0 %;   !  No change to working set or swapping
!   (Transient use by MMG code only)
macro PHD$V_PGFLACC = 736,7,1,0 %;      !  Page file reservation accounting enabled
macro PHD$V_LOCK_HEADER = 736,8,1,0 %;  !  Do not swap process header
!   (Transient use by MMG code only)
! 
!   Note: The Alpha architecture defines that the FEN bit in HWPCB cannot 
!   be read, so a separate software FEN bit must be kept. For performance
!   reasons, we make this bit the low-bit.
! 
macro PHD$L_FLAGS2 = 740,0,32,0 %;      !  Flags2 longword
macro PHD$V_SW_FEN = 740,0,1,0 %;       !  Software FEN bit
macro PHD$V_AST_PENDING = 740,31,1,0 %; !  AST pending optimization
! 
!  Cluster-Wide Process Services
!  
macro PHD$Q_PSCANCTX_QUEUE = 744,0,0,0 %;
literal PHD$S_PSCANCTX_QUEUE = 8;       !  Queue of PSCAN blocks
macro PHD$L_PSCANCTX_SEQNUM = 752,0,32,0 %; !  PSCAN sequence number
macro PHD$L_EXTRACPU = 756,0,32,0 %;    !  Accumulated CPU time limit extension 
! 
!  End of the fixed portion of the process header.
! 
macro PHD$L_WSL = 760,0,32,1 %;         !  First working set list entry 
literal PHD$S_PHDDEF = 768;             !  Old size name - synonym
 
!*** MODULE $PIBDEF ***
! +
!  PERFORMANCE I/O INFORMATION BLOCK
! -
literal PIB$S_PIBDEF = 1;               !  Old size name - synonym
literal PIB$S_PIB = 1;
macro PIB$B_TYPE = 0,0,8,0 %;           ! TYPE OF ENTRY 
! 
!  START OF I/O REQUEST TRANSACTION MESSAGE BLOCK
! 
literal PIB$K_SRQ_SIZE = 32;            ! LENGTH OF START I/O MESSAGE 
literal PIB$C_SRQ_SIZE = 32;            ! LENGTH OF START I/O MESSAGE 
! 
literal PIB$S_PIBDEF1 = 32;             !  Old size name - synonym
literal PIB$S_PIB1 = 32;
macro PIB$B_SRQ_PRI = 1,0,8,0 %;        ! BASE PRIORITY OF PROCESS 
macro PIB$W_SRQ_ACON = 2,0,16,0 %;      ! Access control info from WCB or 0
macro PIB$Q_SRQ_TIME = 4,0,0,0 %;
literal PIB$S_SRQ_TIME = 8;             ! TIME OF I/O TRANSACTION 
macro PIB$L_SRQ_SEQN = 12,0,32,0 %;     ! SEQUENCE NUMBER OF I/O TRANSACTION 
macro PIB$L_SRQ_PID = 16,0,32,0 %;      ! REQUESTER PID 
macro PIB$L_SRQ_UCB = 20,0,32,1 %;      ! ADDRESS OF DEVICE UCB 
macro PIB$W_SRQ_FUNC = 24,0,16,0 %;     ! I/O FUNCTION CODE 
macro PIB$W_SRQ_STS = 26,0,16,0 %;      ! I/O PACKET STATUS 
macro PIB$B_SRQ_ACCESS = 28,0,8,0 %;    ! Access control info from WCB or 0
!  START OF I/O TRANSACTION MESSAGE BLOCK
! 
literal PIB$K_SIO_SIZE = 24;            ! LENGTH OF I/O TRANSACTION MESSAGE 
literal PIB$C_SIO_SIZE = 24;            ! LENGTH OF I/O TRANSACTION MESSAGE 
! 
literal PIB$S_PIBDEF2 = 24;             !  Old size name - synonym
literal PIB$S_PIB2 = 24;
macro PIB$Q_SIO_TIME = 4,0,0,0 %;
literal PIB$S_SIO_TIME = 8;             ! TIME OF TRANSACTION 
macro PIB$L_SIO_SEQN = 12,0,32,0 %;     ! SEQUENCE NUMBER OF TRANSACTION 
macro PIB$L_SIO_MEDIA = 16,0,32,1 %;    ! TRANSFER MEDIA ADDRESS 
macro PIB$L_SIO_BCNT = 20,0,32,0 %;     ! TRANSFER BYTE COUNT 
!  END OF I/O TRANSACTION MESSAGE BLOCK
! 
literal PIB$K_EIO_SIZE = 24;            ! LENGTH OF END OF I/O TRANSACTION 
literal PIB$C_EIO_SIZE = 24;            ! LENGTH OF END OF I/O TRANSACTION 
! 
literal PIB$S_PIBDEF3 = 24;             !  Old size name - synonym
literal PIB$S_PIB3 = 24;
macro PIB$Q_EIO_TIME = 4,0,0,0 %;
literal PIB$S_EIO_TIME = 8;             ! TIME OF TRANSACTION 
macro PIB$L_EIO_SEQN = 12,0,32,0 %;     ! SEQUENCE NUMBER OF TRANSACTION 
macro PIB$Q_EIO_IOSB = 16,0,0,0 %;
literal PIB$S_EIO_IOSB = 8;             ! FINAL I/O STATUS 
!  END OF I/O REQUEST MESSAGE BLOCK
! 
literal PIB$K_ERQ_SIZE = 16;            ! LENGTH OF END OF I/O REQUEST TRANSACTION 
literal PIB$C_ERQ_SIZE = 16;            ! LENGTH OF END OF I/O REQUEST TRANSACTION 
! 
literal PIB$K_SRQ = 0;                  ! START OF I/O REQUEST 
literal PIB$K_SIO = 1;                  ! START OF I/O TRANSACTION 
literal PIB$K_EIO = 2;                  ! END OF I/O TRANSACTION 
literal PIB$K_ERQ = 3;                  ! END OF I/O REQUEST 
literal PIB$K_ARQ = 4;                  ! ABORTED I/O REQUEST 
literal PIB$S_PIBDEF4 = 16;             !  Old size name - synonym
literal PIB$S_PIB4 = 16;
macro PIB$Q_ERQ_TIME = 4,0,0,0 %;
literal PIB$S_ERQ_TIME = 8;             ! TIME OF TRANSACTION 
macro PIB$L_ERQ_SEQN = 12,0,32,0 %;     ! SEQUENCE NUMBER OF TRANSACTION 
!  I/O MESSAGE BLOCK ENTRY TYPE CODES
! 
literal PIB$K_ARQ_SIZE = 16;            ! LENGTH OF ABORTED I/O TRANSACTION
literal PIB$C_ARQ_SIZE = 16;            ! LENGTH OF ABORTED I/O TRANSACTION 
! 
literal PIB$S_PIBDEF5 = 16;             !  Old size name - synonym
literal PIB$S_PIB5 = 16;
macro PIB$Q_ARQ_TIME = 4,0,0,0 %;
literal PIB$S_ARQ_TIME = 8;             ! TIME OF TRANSACTION 
macro PIB$L_ARQ_SEQN = 12,0,32,0 %;     ! SEQUENCE NUMBER OF TRANSACTION 
!  ABORTED I/O REQUEST MESSAGE BLOCK
! 
 
!*** MODULE $PIPPDDEF ***
literal PIPPD$C_OK = 0;
literal PIPPD$C_VCC = 1;
literal PIPPD$C_INVBN = 2;
literal PIPPD$C_BLV = 3;
literal PIPPD$C_ACCV = 4;
literal PIPPD$C_NP = 5;
literal PIPPD$C_PSV = 6;
literal PIPPD$C_URP = 7;
literal PIPPD$C_INVDP = 8;
literal PIPPD$C_OSEQ = 9;
literal PIPPD$C_DG = 1;
literal PIPPD$C_MSG = 2;
literal PIPPD$C_CNF = 3;
literal PIPPD$C_IDREQ = 5;
literal PIPPD$C_RST = 6;
literal PIPPD$C_STRT = 7;
literal PIPPD$C_DATREQ0 = 8;
literal PIPPD$C_DATREQ1 = 9;
literal PIPPD$C_DATREQ2 = 10;
literal PIPPD$C_ID = 11;
literal PIPPD$C_LB = 13;
literal PIPPD$C_SNTDAT = 16;
literal PIPPD$C_RETDAT = 17;
literal PIPPD$C_DGREC = 33;
literal PIPPD$C_MSGREC = 34;
literal PIPPD$C_CNFREC = 35;
literal PIPPD$C_IDREC = 43;
literal PIPPD$C_DATREC = 49;
literal PIPPD$M_OPCODE = %X'1F';
literal PIPPD$M_LP = %X'100';
literal PIPPD$M_NS = %X'E00';
literal PIPPD$M_M = %X'7000';
literal PIPPD$M_DATA = %X'10';
literal PIPPD$M_NR = %X'E00';
literal PIPPD$C_P0 = 1;
literal PIPPD$C_P1 = 2;
literal PIPPD$M_RP = %X'600';
literal PIPPD$M_SP = %X'3000';
literal PIPPD$M_FR = %X'8000';
literal PIPPD$M_DSA = %X'8000';
literal PIPPD$M_RSP = %X'1';
literal PIPPD$M_DISP = %X'2';
literal PIPPD$M_VC = %X'4';
literal PIPPD$M_Q = %X'18';
literal PIPPD$C_TEXT1 = 24;
literal PIPPD$C_LENGTH = 26;
literal PIPPD$C_START = 0;
literal PIPPD$C_STACK = 1;
literal PIPPD$C_ACK = 2;
literal PIPPD$C_SCS_DG = 3;
literal PIPPD$C_SCS_MSG = 4;
literal PIPPD$C_ELOG = 5;
literal PIPPD$C_HOSTSHUT = 6;
literal PIPPD$C_FU_DG = 7;
literal PIPPD$C_CACHECLR = 32768;
literal PIPPD$C_CKTCLSD = 32769;
literal PIPPD$C_CNF_LEN = 8;
literal PIPPD$C_CNFREC_LEN = 8;
literal PIPPD$C_DATREC_LEN = 8;
literal PIPPD$C_IDREQ_LEN = 8;
literal PIPPD$C_RST_LEN = 8;
literal PIPPD$M_MAINT = %X'1';
literal PIPPD$C_UNINIT = 0;
literal PIPPD$C_DISAB = 1;
literal PIPPD$C_ENAB = 2;
literal PIPPD$M_STATE = %X'6';
literal PIPPD$M_AST = %X'700';
literal PIPPD$M_XRPE = %X'800';
literal PIPPD$M_AARB = %X'1000';
literal PIPPD$M_XNR = %X'2000';
literal PIPPD$M_MAX_BODY_LEN = %X'1FFF0000';
literal PIPPD$M_CSZ = %X'E0000000';
literal PIPPD$M_NUM_MEMS = %X'FF';
literal PIPPD$M_SMV = %X'1000';
literal PIPPD$M_RDP_SUP = %X'2000';
literal PIPPD$M_FSN_SUP = %X'4000';
literal PIPPD$M_SA_SUP = %X'8000';
literal PIPPD$C_ID_LEN = 48;
literal PIPPD$C_IDREC_LEN = 48;
literal PIPPD$C_DATREQ_LEN = 28;
literal PIPPD$C_SNTDAT_LEN = 16;
literal PIPPD$C_RETDAT_LEN = 16;
literal PIPPD$C_XXXDAT_LEN = 16;
literal PIPPD$C_STRT_LEN = 12;
literal PIPPD$S_PIPPD = 72;
macro PIPPD$PS_FLINK = 0,0,32,1 %;
macro PIPPD$PS_BLINK = 4,0,32,1 %;
macro PIPPD$W_SIZE = 8,0,16,0 %;
macro PIPPD$B_TYPE = 10,0,8,0 %;
macro PIPPD$B_SUBTYPE = 11,0,8,0 %;
macro PIPPD$PS_C710D = 12,0,32,1 %;
macro PIPPD$B_PORT = 16,0,8,0 %;
macro PIPPD$B_STATUS = 17,0,8,0 %;
macro PIPPD$V_OPCODE = 18,0,5,0 %;
literal PIPPD$S_OPCODE = 5;
macro PIPPD$V_LP = 18,8,1,0 %;
macro PIPPD$V_NS = 18,9,3,0 %;
literal PIPPD$S_NS = 3;
macro PIPPD$V_M = 18,12,3,0 %;
literal PIPPD$S_M = 3;
macro PIPPD$V_DATA = 18,4,1,0 %;
macro PIPPD$V_NR = 18,9,3,0 %;
literal PIPPD$S_NR = 3;
macro PIPPD$V_RP = 18,9,2,0 %;
literal PIPPD$S_RP = 2;
macro PIPPD$V_SP = 18,12,2,0 %;
literal PIPPD$S_SP = 2;
macro PIPPD$V_FR = 18,15,1,0 %;
macro PIPPD$V_DSA = 18,15,1,0 %;
macro PIPPD$W_OPCODE = 18,0,16,0 %;
macro PIPPD$V_RSP = 20,0,1,0 %;
macro PIPPD$V_DISP = 20,1,1,0 %;
macro PIPPD$V_VC = 20,2,1,0 %;
macro PIPPD$V_Q = 20,3,2,0 %;
literal PIPPD$S_Q = 2;
macro PIPPD$W_FLAGS = 20,0,16,0 %;
macro PIPPD$W_LENGTH1 = 22,0,16,0 %;
macro PIPPD$B_TEXT1 = 24,0,8,0 %;
macro PIPPD$W_LENGTH2 = 24,0,16,0 %;
macro PIPPD$B_TEXT2 = 26,0,8,0 %;
macro PIPPD$W_MTYPE = 26,0,16,0 %;
macro PIPPD$Q_XCT_ID = 24,0,0,0 %;
literal PIPPD$S_XCT_ID = 8;
macro PIPPD$L_RPORT_TYP = 32,0,32,0 %;
macro PIPPD$L_RPORT_REV = 36,0,32,0 %;
macro PIPPD$L_RPORT_FCN = 40,0,32,0 %;
macro PIPPD$B_RESET_PORT = 44,0,8,0 %;
macro PIPPD$V_MAINT = 45,0,1,0 %;
macro PIPPD$V_STATE = 45,1,2,0 %;
literal PIPPD$S_STATE = 2;
macro PIPPD$B_RPORT_STATE = 45,0,24,1 %;
literal PIPPD$S_RPORT_STATE = 3;
macro PIPPD$V_AST = 48,8,3,0 %;
literal PIPPD$S_AST = 3;
macro PIPPD$V_XRPE = 48,11,1,0 %;
macro PIPPD$V_AARB = 48,12,1,0 %;
macro PIPPD$V_XNR = 48,13,1,0 %;
macro PIPPD$V_MAX_BODY_LEN = 48,16,13,0 %;
literal PIPPD$S_MAX_BODY_LEN = 13;
macro PIPPD$V_CSZ = 48,29,3,0 %;
literal PIPPD$S_CSZ = 3;
macro PIPPD$L_PORT_FCN_EXT1 = 48,0,32,0 %;
macro PIPPD$V_NUM_MEMS = 52,0,8,0 %;
literal PIPPD$S_NUM_MEMS = 8;
macro PIPPD$V_SMV = 52,12,1,0 %;
macro PIPPD$V_RDP_SUP = 52,13,1,0 %;
macro PIPPD$V_FSN_SUP = 52,14,1,0 %;
macro PIPPD$V_SA_SUP = 52,15,1,0 %;
macro PIPPD$L_PORT_FCN_EXT2 = 52,0,32,0 %;
macro PIPPD$Q_SUB_MAP = 56,0,0,0 %;
literal PIPPD$S_SUB_MAP = 8;
macro PIPPD$B_UNUSEDID = 64,0,0,0 %;
literal PIPPD$S_UNUSEDID = 8;
macro PIPPD$L_XCT_LEN = 32,0,32,0 %;
macro PIPPD$L_SND_NAME = 36,0,32,0 %;
macro PIPPD$L_SND_BOFF = 40,0,32,0 %;
macro PIPPD$Q_SND_BUFF = 36,0,0,0 %;
literal PIPPD$S_SND_BUFF = 8;
macro PIPPD$L_REC_NAME = 44,0,32,0 %;
macro PIPPD$L_REC_BOFF = 48,0,32,0 %;
macro PIPPD$Q_REC_BUFF = 44,0,0,0 %;
literal PIPPD$S_REC_BUFF = 8;
macro PIPPD$Q_BUFF = 32,0,0,0 %;
literal PIPPD$S_BUFF = 8;
macro PIPPD$B_DATA = 40,0,8,0 %;
macro PIPPD$L_ST_ADDR = 32,0,32,1 %;
literal DSSI$C_STS_GOOD = 97;
literal DSSI$C_MAX_PKT = 4114;
literal DSSI$C_NUM_PAGES = 8;
literal DSSI$C_RETRY_IMMED = 8;
literal DSSI$C_RETRY_DELAY = 512;
literal DSSI$C_TIMER = 100000;
literal DSSI$C_CMD_DSSI = 224;
literal DSSI$M_MBZ = %X'F';
literal DSSI$M_REQ_ACK = %X'F0';
literal DSSI$S_DSSI_CMD = 6;
macro DSSI$B_OPCODE = 0,0,8,0 %;
macro DSSI$V_MBZ = 1,0,4,0 %;
literal DSSI$S_MBZ = 4;
macro DSSI$V_REQ_ACK = 1,4,4,0 %;
literal DSSI$S_REQ_ACK = 4;
macro DSSI$B_FLAGS = 1,0,8,0 %;
macro DSSI$B_DST_PORT = 2,0,8,0 %;
macro DSSI$B_SRC_PORT = 3,0,8,0 %;
macro DSSI$W_SIZE = 4,0,16,0 %;
literal DSSI$C_DG = 1;
literal DSSI$C_MSG = 2;
literal DSSI$C_CNF = 3;
literal DSSI$C_IDREQ = 5;
literal DSSI$C_RST = 6;
literal DSSI$C_STRT = 7;
literal DSSI$C_DATREQ0 = 8;
literal DSSI$C_DATREQ1 = 9;
literal DSSI$C_DATREQ2 = 10;
literal DSSI$C_ID = 11;
literal DSSI$C_LB = 13;
literal DSSI$C_SNTDAT = 16;
literal DSSI$C_RETDAT = 17;
literal DSSI$M_OPCODE = %X'1F';
literal DSSI$M_LP = %X'100';
literal DSSI$M_NS = %X'E00';
literal DSSI$M_M = %X'7000';
literal DSSI$M_DATA = %X'10';
literal DSSI$M_NR = %X'E00';
literal DSSI$C_P0 = 1;
literal DSSI$C_P1 = 2;
literal DSSI$M_RP = %X'600';
literal DSSI$M_SP = %X'3000';
literal DSSI$M_FR = %X'8000';
literal DSSI$M_DSA = %X'8000';
literal DSSI$C_START = 0;
literal DSSI$C_STACK = 1;
literal DSSI$C_ACK = 2;
literal DSSI$C_SCS_DG = 3;
literal DSSI$C_SCS_MSG = 4;
literal DSSI$C_ELOG = 5;
literal DSSI$C_HOSTSHUT = 6;
literal DSSI$C_FU_DG = 7;
literal DSSI$C_CNF_LEN = 10;
literal DSSI$C_CNFREC_LEN = 10;
literal DSSI$C_DATREC_LEN = 10;
literal DSSI$C_IDREQ_LEN = 10;
literal DSSI$C_RST_LEN = 10;
literal DSSI$M_MAINT = %X'1';
literal DSSI$C_UNINIT = 0;
literal DSSI$C_DISAB = 1;
literal DSSI$C_ENAB = 2;
literal DSSI$M_STATE = %X'6';
literal DSSI$M_AST = %X'700';
literal DSSI$M_XRPE = %X'800';
literal DSSI$M_AARB = %X'1000';
literal DSSI$M_XNR = %X'2000';
literal DSSI$M_MAX_BODY_LEN = %X'1FFF0000';
literal DSSI$M_CSZ = %X'E0000000';
literal DSSI$M_NUM_MEMS = %X'FF';
literal DSSI$M_SMV = %X'1000';
literal DSSI$M_RDP_SUP = %X'2000';
literal DSSI$M_FSN_SUP = %X'4000';
literal DSSI$M_SA_SUP = %X'8000';
literal DSSI$C_ID_LEN = 50;
literal DSSI$C_IDREC_LEN = 50;
literal DSSI$C_DATREQ_LEN = 30;
literal DSSI$C_SNTDAT_LEN = 18;
literal DSSI$C_RETDAT_LEN = 18;
literal DSSI$C_XXXDAT_LEN = 18;
literal DSSI$C_STRT_LEN = 14;
literal DSSI$S_DSSI_DAT = 50;
macro DSSI$V_OPCODE = 0,0,5,0 %;
literal DSSI$S_OPCODE = 5;
macro DSSI$V_LP = 0,8,1,0 %;
macro DSSI$V_NS = 0,9,3,0 %;
literal DSSI$S_NS = 3;
macro DSSI$V_M = 0,12,3,0 %;
literal DSSI$S_M = 3;
macro DSSI$V_DATA = 0,4,1,0 %;
macro DSSI$V_NR = 0,9,3,0 %;
literal DSSI$S_NR = 3;
macro DSSI$V_RP = 0,9,2,0 %;
literal DSSI$S_RP = 2;
macro DSSI$V_SP = 0,12,2,0 %;
literal DSSI$S_SP = 2;
macro DSSI$V_FR = 0,15,1,0 %;
macro DSSI$V_DSA = 0,15,1,0 %;
macro DSSI$W_OPCODE = 0,0,16,0 %;
macro DSSI$B_TEXT = 2,0,8,0 %;
macro DSSI$W_MTYPE = 2,0,16,0 %;
macro DSSI$Q_XCT_ID = 2,0,0,0 %;
literal DSSI$S_XCT_ID = 8;
macro DSSI$L_RPORT_TYP = 10,0,32,0 %;
macro DSSI$L_RPORT_REV = 14,0,32,0 %;
macro DSSI$L_RPORT_FCN = 18,0,32,0 %;
macro DSSI$B_RESET_PORT = 22,0,8,0 %;
macro DSSI$V_MAINT = 23,0,1,0 %;
macro DSSI$V_STATE = 23,1,2,0 %;
literal DSSI$S_STATE = 2;
macro DSSI$B_RPORT_STATE = 23,0,24,1 %;
literal DSSI$S_RPORT_STATE = 3;
macro DSSI$V_AST = 26,8,3,0 %;
literal DSSI$S_AST = 3;
macro DSSI$V_XRPE = 26,11,1,0 %;
macro DSSI$V_AARB = 26,12,1,0 %;
macro DSSI$V_XNR = 26,13,1,0 %;
macro DSSI$V_MAX_BODY_LEN = 26,16,13,0 %;
literal DSSI$S_MAX_BODY_LEN = 13;
macro DSSI$V_CSZ = 26,29,3,0 %;
literal DSSI$S_CSZ = 3;
macro DSSI$L_PORT_FCN_EXT1 = 26,0,32,0 %;
macro DSSI$V_NUM_MEMS = 30,0,8,0 %;
literal DSSI$S_NUM_MEMS = 8;
macro DSSI$V_SMV = 30,12,1,0 %;
macro DSSI$V_RDP_SUP = 30,13,1,0 %;
macro DSSI$V_FSN_SUP = 30,14,1,0 %;
macro DSSI$V_SA_SUP = 30,15,1,0 %;
macro DSSI$L_PORT_FCN_EXT2 = 30,0,32,0 %;
macro DSSI$Q_SUB_MAP = 34,0,0,0 %;
literal DSSI$S_SUB_MAP = 8;
macro DSSI$B_UNUSEDID = 42,0,0,0 %;
literal DSSI$S_UNUSEDID = 8;
macro DSSI$L_XCT_LEN = 10,0,32,0 %;
macro DSSI$L_SND_NAME = 14,0,32,0 %;
macro DSSI$L_SND_BOFF = 18,0,32,0 %;
macro DSSI$Q_SND_BUFF = 14,0,0,0 %;
literal DSSI$S_SND_BUFF = 8;
macro DSSI$L_REC_NAME = 22,0,32,0 %;
macro DSSI$L_REC_BOFF = 26,0,32,0 %;
macro DSSI$Q_REC_BUFF = 22,0,0,0 %;
literal DSSI$S_REC_BUFF = 8;
macro DSSI$Q_BUFF = 10,0,0,0 %;
literal DSSI$S_BUFF = 8;
macro DSSI$B_DATA = 18,0,8,0 %;
macro DSSI$L_ST_ADDR = 10,0,32,1 %;
 
!*** MODULE $PLVDEF ***
! +
!  PRIVILEGED LIBRARY VECTOR DEFINITION
! -
literal PLV$M_WAIT_CALLERS_MODE = %X'1';
literal PLV$M_WAIT_CALLERS_NO_REEXEC = %X'2';
literal PLV$S_FILL_654 = 8;
macro PLV$Q_PLVFLG = 0,0,0,1 %;
literal PLV$S_PLVFLG = 8;
macro PLV$V_WAIT_CALLERS_MODE = 0,0,1,0 %;
macro PLV$V_WAIT_CALLERS_NO_REEXEC = 0,1,1,0 %;
literal PLV$C_LENGTH = 44;              !  Size of fixed portion
literal PLV$S_PLVDEF = 44;
literal PLV$S_PLV = 44;
macro PLV$L_TYPE = 0,0,32,0 %;          ! TYPE CODE FOR VECTOR FORMAT 
macro PLV$L_VERSION = 4,0,32,0 %;       ! SYSTEM VERSION NUMBER 
macro PLV$L_KERNEL_ROUTINE_COUNT = 8,0,32,0 %; !  # of kernel routines
macro PLV$L_EXEC_ROUTINE_COUNT = 12,0,32,0 %; !  # of exec routines
macro PLV$PS_KERNEL_ROUTINE_LIST = 16,0,32,1 %; !  addr of kernel list
macro PLV$PS_EXEC_ROUTINE_LIST = 20,0,32,1 %; !  addr of exec list
macro PLV$PS_KERNEL_RUNDOWN_HANDLER = 24,0,32,1 %; !  kern rundown routine
macro PLV$PS_EXEC_RUNDOWN_HANDLER = 28,0,32,1 %; !  exec rundown routine
macro PLV$PS_RMS_DISPATCHER = 32,0,32,1 %; !  RMS dispatch routine
macro PLV$PS_KERNEL_ROUTINE_FLAGS = 36,0,32,1 %; !  flags vector
macro PLV$PS_EXEC_ROUTINE_FLAGS = 40,0,32,1 %; !  flags vector
macro PLV$L_MSGDSP = 8,0,32,1 %;        !  self-rel ptr to message dispatcher 
macro PLV$L_MSG_ENTRY = 12,0,32,0 %;    !  message dispatcher code
macro PLV$L_MSG_SECTION = 16,0,32,1 %;  !  self-rel ptr to msg section
macro PLV$L_FLAGS = 8,0,32,0 %;
macro PLV$V_MAIN_IMAGE = 8,0,1,0 %;     !  Closest to system service
macro PLV$L_SSI_ROUTINE_COUNT = 12,0,32,0 %; !  Count of SSI symbol vectors
macro PLV$PS_VECTOR_ADDRESS = 16,0,32,1 %; !  Private symbol vector address
! +
!  TYPE CODES FOR PRIVILEGE VECTORS 
! -
literal PLV$C_TYP_CMOD = 1;             !  CHANGE MODE VECTOR TYPE 
literal PLV$C_TYP_MSG = 2;              !  MESSAGE VECTOR TYPE 
literal PLV$C_TYP_SSI = 3;              !  SYSTEM SERVICE INTERCEPT TYPE
 
!*** MODULE $PLVECDEF ***
! +
!  PLVEC - SCS PORT LOAD VECTOR
! 
!  THIS DATA STRUCTURE CONTAINS A VECTOR LISTING THE ACTIVE CONNECTIONS BY
!  TYPE ON A PORT.  THE INDEX IS CONTAINED IN THE SBNB (SCS LOAD SHARE
!  NAME BLOCK and in the CDT$L_
!  
! -
literal PLVEC$C_MAX_INDEX = 10;
literal PLVEC$K_LENGTH = 60;            !  (TYC 15-Feb-89)
literal PLVEC$C_LENGTH = 60;
literal PLVEC$S_PLVECDEF = 16;
literal PLVEC$S_PLVEC = 16;
macro PLVEC$L_FLINK = -12,0,32,1 %;     ! FWD LINK 
macro PLVEC$L_BLINK = -8,0,32,1 %;      ! BCK LINK 
macro PLVEC$W_SIZE = -4,0,16,0 %;       ! STRUCTURE SIZE IN BYTES 
macro PLVEC$B_TYPE = -2,0,8,0 %;        ! SCS STRUCTURE TYPE 
macro PLVEC$B_SUBTYP = -1,0,8,0 %;      ! SCS STRUCTURE SUBTYPE FOR PLVEC
macro PLVEC$L_TOT_CONNECT = 0,0,32,0 %; ! TOTAL NUMBER OF CONNECTIONS ON
!  THIS PORT
 
!*** MODULE $PMBDEF ***
! +
!  PAGE FAULT MONITOR CONTROL BLOCK
! -
literal PMB$M_MODE = %X'1';
literal PMB$K_SUBPROC = 0;              ! Subprocess mode
literal PMB$K_IMAGE = 1;                ! Image mode
literal PMB$M_ASTIP = %X'2';
literal PMB$M_QAST = %X'4';
literal PMB$K_LENGTH = 76;              ! Length of PMB 
literal PMB$C_LENGTH = 76;              ! Length of PMB 
literal PMB$S_PMBDEF = 76;              !  Old size name - synonym
literal PMB$S_PMB = 76;
macro PMB$L_CURBUF = 0,0,32,1 %;        ! Current buffer pointer 
macro PMB$L_BUFBASE = 4,0,32,1 %;       ! Current buffer base address
macro PMB$W_SIZE = 8,0,16,0 %;          ! Block size field 
macro PMB$B_TYPE = 10,0,8,0 %;          ! Dynamic structure type (PMB)
macro PMB$B_FLAGS = 11,0,8,0 %;         ! Processing flags
macro PMB$V_MODE = 11,0,1,0 %;          ! Mode of operation
macro PMB$V_ASTIP = 11,1,1,0 %;         ! AST in progress flag
macro PMB$V_QAST = 11,2,1,0 %;          ! Imbedded ACB is enqueued on the PCB
macro PMB$L_LASTCPU = 12,0,32,0 %;      ! Last recorded CPU time
macro PMB$L_OVERFLOW = 16,0,32,0 %;     ! Buffer overflow counter (both modes)
macro PMB$Q_HDR = 24,0,0,0 %;
literal PMB$S_HDR = 8;                  ! Free   buffer queue header 
macro PMB$Q_SBPHDR = 32,0,0,0 %;
literal PMB$S_SBPHDR = 8;               ! Filled buffer queue header 
macro PMB$L_ASTQFL = 40,0,32,1 %;       ! ACB flink
macro PMB$L_ASTQBL = 44,0,32,1 %;       ! ACB blink
macro PMB$B_ACMODE = 50,0,8,0 %;        ! Owner access mode
macro PMB$B_RMOD = 51,0,8,0 %;          ! AST delivery mode/flags
macro PMB$L_PID = 52,0,32,0 %;          ! PID for AST delivery
macro PMB$L_AST = 56,0,32,1 %;          ! AST routine address
macro PMB$L_ASTPRM = 60,0,32,0 %;       ! AST parameter
macro PMB$L_KAST = 72,0,32,1 %;         ! Address of piggy-back kernel AST routine
macro PMB$W_MBXCHN = 48,0,16,0 %;       ! Subprocess mailbox channel 
macro PMB$B_OACMODE = 50,0,8,0 %;       ! Owner access mode (Synonym for ACMODE)
macro PMB$L_IPID = 52,0,32,0 %;         ! IPID of subprocess (Synonym for PID)
macro PMB$L_EPID = 56,0,32,0 %;         ! EPID of subprocess
 
!*** MODULE $POOLCHECKDEF ***
! +
!  POOLCHECK - Poolcheck SYSGEN parameter layout
! -
literal PCHECK$M_POISON = %X'1';
literal PCHECK$M_CHECK = %X'2';
literal PCHECK$M_SRP_FREE = %X'4';
literal PCHECK$M_IRP_FREE = %X'8';
literal PCHECK$M_LRP_FREE = %X'10';
literal PCHECK$M_XRP_ALIGN = %X'20';
literal PCHECK$M_P1 = %X'80';
literal PCHECK$S_POOLCHECKDEF = 4;
literal PCHECK$S_POOLCHECK = 4;
macro PCHECK$W_FLAGS = 0,0,16,0 %;      !  Flag bits
macro PCHECK$V_POISON = 0,0,1,0 %;      !  Poison on deallocation
!   Enable other features
macro PCHECK$V_CHECK = 0,1,1,0 %;       !  Check poisoning on allocation
!   and poison with allo pattern
macro PCHECK$V_SRP_FREE = 0,2,1,0 %;    !  Poison SRPs on deallocation (obsolete)
macro PCHECK$V_IRP_FREE = 0,3,1,0 %;    !  Poison IRPs on deallocation (obsolete)
macro PCHECK$V_LRP_FREE = 0,4,1,0 %;    !  Poison LRPs on deallocation (obsolete)
macro PCHECK$V_XRP_ALIGN = 0,5,1,0 %;   !  Check xRP alignment on deallocation (obs)
macro PCHECK$V_SPARE1 = 0,6,1,0 %;      !  Spare
macro PCHECK$V_P1 = 0,7,1,0 %;          !  Do poisoning/checking on P1 space
macro PCHECK$B_FREE = 2,0,8,0 %;        !  Free pattern
macro PCHECK$B_ALLO = 3,0,8,0 %;        !  Allocated pattern
! +
!  PCHK_REASON - Poolcheck bugcheck reason codes
! 
!  This defines the poolcheck bugcheck codes pushed on the stack when a
!  poolcheck bugcheck is declared.
!  
! -
literal PCHK_REASON$_CORRUPT = 0;       !  Corrupted packet
literal PCHK_REASON$_ALIGN = 1;         !  Bad alignment (obsolete)
literal PCHK_REASON$_XRP_ALIGN = 2;     !  Bad alignment of xRP packet (obsolete)
literal PCHK_REASON$_PAGED = 3;         !  Paged block is partially outside
literal PCHK_REASON$_NPAGED = 4;        !  Npaged block is partially outside
literal PCHK_REASON$_IPL = 5;           !  Called P1 routines with IPL too high
literal PCHK_REASON$_AGGLOM = 6;        !  Agglomeration not done
 
!*** MODULE $PQBDEF ***
! +
!  PROCESS QUOTA BLOCK DEFINITION
! -
literal PQB$M_IMGDMP = %X'1';
literal PQB$M_DEBUG = %X'2';
literal PQB$M_DBGTRU = %X'4';
literal PQB$K_LENGTH = 2256;            !  LENGTH OF PROCESS QUOTA BLOCK 
literal PQB$C_LENGTH = 2256;            !  LENGTH OF PROCESS QUOTA BLOCK 
literal PQB$S_PQBDEF = 2256;            !  Old size name - synonym    
literal PQB$S_PQB = 2256;
macro PQB$Q_PRVMSK = 0,0,0,0 %;
literal PQB$S_PRVMSK = 8;               !  PRIVILEGE MASK 
macro PQB$W_SIZE = 8,0,16,0 %;          !  SIZE OF PQB IN BYTES 
macro PQB$B_TYPE = 10,0,8,0 %;          !  STRUCTURE TYPE CODE 
macro PQB$B_STS = 11,0,8,0 %;           !  STATUS FLAGS 
macro PQB$L_ASTLM = 12,0,32,0 %;        !  AST LIMIT 
macro PQB$L_BIOLM = 16,0,32,0 %;        !  BUFFERED I/O LIMIT 
macro PQB$L_BYTLM = 20,0,32,0 %;        !  BUFFERED I/O LIMIT 
macro PQB$L_CPULM = 24,0,32,0 %;        !  CPU TIME LIMIT 
macro PQB$L_DIOLM = 28,0,32,0 %;        !  DIRECT I/O LIMIT 
macro PQB$L_FILLM = 32,0,32,0 %;        !  OPEN FILE LIMIT 
macro PQB$L_PGFLQUOTA = 36,0,32,0 %;    !  PAGING FILE QUOTA 
macro PQB$L_PRCLM = 40,0,32,0 %;        !  SUB-PROCESS LIMIT 
macro PQB$L_TQELM = 44,0,32,0 %;        !  TIMER QUEUE ENTRY LIMIT 
macro PQB$L_WSQUOTA = 48,0,32,0 %;      !  WORKING SET QUOTA 
macro PQB$L_WSDEFAULT = 52,0,32,0 %;    !  WORKING SET DEFAULT 
macro PQB$L_ENQLM = 56,0,32,0 %;        !  ENQUEUE LIMIT 
macro PQB$L_WSEXTENT = 60,0,32,0 %;     !  MAXIMUM WORKING SET SIZE 
macro PQB$L_JTQUOTA = 64,0,32,0 %;      !  JOB-WIDE LOGICAL NAME TABLE CREATION QUOTA
macro PQB$W_FLAGS = 68,0,16,0 %;        !  MISC FLAGS
macro PQB$V_IMGDMP = 68,0,1,0 %;        !  TAKE IMAGE DUMP ON SERIOUS ERROR
macro PQB$V_DEBUG = 68,1,1,0 %;         !  /DEBUG startup desired
macro PQB$V_DBGTRU = 68,2,1,0 %;        !  debugger present
macro PQB$B_MSGMASK = 70,0,8,0 %;       !  MESSAGE FLAGS 
macro PQB$L_UAF_FLAGS = 72,0,32,0 %;    !  FLAGS FROM UAF RECORD
macro PQB$L_CREPRC_FLAGS = 76,0,32,0 %; !  FLAGS FROM $CREPRC ARGUMENT LIST
macro PQB$R_MIN_CLASS = 80,0,0,0 %;
literal PQB$S_MIN_CLASS = 20;           !  MINIMUM AUTHORIZED SECURITY CLEARANCE
macro PQB$R_MAX_CLASS = 100,0,0,0 %;
literal PQB$S_MAX_CLASS = 20;           !  MAXIMUM AUTHORIZED SECURITY CLEARANCE
macro PQB$L_INPUT_ATT = 120,0,32,0 %;   !   SYS$INPUT attributes
macro PQB$L_OUTPUT_ATT = 124,0,32,0 %;  !   SYS$OUTPUT attributes
macro PQB$L_ERROR_ATT = 128,0,32,0 %;   !   SYS$ERROR attributes
macro PQB$L_DISK_ATT = 132,0,32,0 %;    !   SYS$DISK attributes
macro PQB$T_CLI_NAME = 136,0,0,0 %;
literal PQB$S_CLI_NAME = 32;            !  CLI name
macro PQB$T_CLI_TABLE = 168,0,0,0 %;
literal PQB$S_CLI_TABLE = 256;          !  CLI table name
macro PQB$T_SPAWN_CLI = 424,0,0,0 %;
literal PQB$S_SPAWN_CLI = 32;           !  Spawn CLI name
macro PQB$T_SPAWN_TABLE = 456,0,0,0 %;
literal PQB$S_SPAWN_TABLE = 256;        !  Spawn CLI table name
macro PQB$T_INPUT = 712,0,0,0 %;
literal PQB$S_INPUT = 256;              !  LOGICAL NAME FOR INPUT 
macro PQB$T_OUTPUT = 968,0,0,0 %;
literal PQB$S_OUTPUT = 256;             !  LOGICAL NAME FOR OUTPUT 
macro PQB$T_ERROR = 1224,0,0,0 %;
literal PQB$S_ERROR = 256;              !  LOGICAL NAME FOR ERROR OUTPUT 
macro PQB$T_DISK = 1480,0,0,0 %;
literal PQB$S_DISK = 256;               !  LOGICAL NAME FOR SYS$DISK 
macro PQB$T_DDSTRING = 1736,0,0,0 %;
literal PQB$S_DDSTRING = 256;           !  DEFAULT DIRECTORY STRING 
macro PQB$T_IMAGE = 1992,0,0,0 %;
literal PQB$S_IMAGE = 256;              !  IMAGE NAME FOR NEW PROCESS 
macro PQB$T_ACCOUNT = 2248,0,0,0 %;
literal PQB$S_ACCOUNT = 8;              !  ACCOUNT NAME FOR NEW PROCESS 
 
!*** MODULE $PRBDEF ***
! +
! 
!  Protection block definition. The protection block is used to specify
!  protection on objects internal to the system (e.g., devices, logical
!  name tables, etc.) It is used as input to the EXE$CHECKACCESS routine.
! 
! -
literal PRB$M_UIC = %X'1';
literal PRB$M_ACL = %X'2';
literal PRB$M_CLASS = %X'4';
literal PRB$M_CLASSMAX = %X'8';
literal PRB$S_PRBDEF = 8;
! 
literal PRB$S_PRB = 8;
macro PRB$W_FLAGS = 0,0,16,0 %;         !  Presence flag bits
macro PRB$V_UIC = 0,0,1,0 %;            !  Set for simple UIC protection
macro PRB$V_ACL = 0,1,1,0 %;            !  Set for access control list
macro PRB$V_CLASS = 0,2,1,0 %;          !  Set for security classification
macro PRB$V_CLASSMAX = 0,3,1,0 %;       !  Set for security class range
macro PRB$W_PROTECTION = 2,0,16,0 %;    !  SOGW protection mask
macro PRB$L_OWNER = 4,0,32,0 %;         !  Owner UIC
!  The remaining items in the protection block are optional and therefore
!  do not have fixed offsets. The description given below is for a
!  hypothetical fully configured protection block.
! 
!   ACL quadword;			/* ACL listhead
!   CLASS structure;			/* Classification mask
! 	FILL_1 long dimension 5 fill;
! 	end CLASS;
!   CLASSMAX structure;			/* Maximum class mask for range
! 	FILL_2 long dimension 5 fill;
! 	end CLASSMAX;
! 
 
!*** MODULE $PRCEVTDEF ***
! 
!  PRCEVTDEF
! 
!  This module defines the Process Event constants and structure
!  offsets.
! 
literal PRCEVT$K_LENGTH = 16;           !  Length of PRCEVT
literal PRCEVT$C_LENGTH = 16;           !  Length of PRCEVT
literal PRCEVT$S_PRCEVTDEF = 16;        !  Old size name - synonym
literal PRCEVT$S_PRCEVT = 16;
macro PRCEVT$L_FLINK = 0,0,32,1 %;      !  Foward link
macro PRCEVT$L_BLINK = 4,0,32,1 %;      !  Backward link
macro PRCEVT$W_SIZE = 8,0,16,0 %;       !  Size, in bytes
macro PRCEVT$B_TYPE = 10,0,8,0 %;       !  Structure type code 
macro PRCEVT$B_SUBTYPE = 11,0,8,0 %;    !  Structure subtype
macro PRCEVT$L_HANDLER = 12,0,32,1 %;   !  Handler address
literal PRCEVT$C_USRUNDWN_EXEC = 0;     !  Exec mode image rundown 
literal PRCEVT$C_USRUNDWN = 1;          !  Image rundown 
literal PRCEVT$C_DELPRC_RUNDWN = 2;     !  Process rundown 
literal PRCEVT$C_DELPRC_DELTVA = 3;     !  Process address space deletion 
literal PRCEVT$C_CRE_MIN_PROCESS = 4;   !  Minimal process creation
literal PRCEVT$C_FORK_PROCSTRT = 5;     !  Child's fork() procstrt
literal PRCEVT$C_MAX_EVENT = 6;         !  Maximum number of process events
 
!*** MODULE $PRCPOLDEF ***
! +
!  PROCESS POLLER MAILBOX MESSAGE DEFINITIONS
! -
literal PRCPOL$C_SIZ = 56;              ! SIZE OF MESSAGE	
literal PRCPOL$S_PRCPOLDEF = 56;
literal PRCPOL$S_PRCPOL = 56;
macro PRCPOL$L_SYSIDL = 0,0,32,0 %;     ! LOW ORDER SYSTEM ID
macro PRCPOL$W_SYSIDH = 4,0,16,0 %;     ! HIGH ORDER SYSTEM ID
macro PRCPOL$T_NODNAM = 8,0,0,0 %;
literal PRCPOL$S_NODNAM = 16;           ! SCA NODE NAME (COUNTED ASCII)
macro PRCPOL$B_PRCNAM = 24,0,0,0 %;
literal PRCPOL$S_PRCNAM = 16;           ! PROCESS NAME
macro PRCPOL$B_DIRINF = 40,0,0,0 %;
literal PRCPOL$S_DIRINF = 16;           ! DIRECTORY INFORMATION
 
!*** MODULE $PRCSTRDEF ***
! 
!  PRCSTRDEF
! 
!  This module defines the alternate procstrt structure offsets.
! 
literal PRCSTR$K_LENGTH = 52;           !  Length of PRCSTR
literal PRCSTR$C_LENGTH = 52;           !  Length of PRCSTR
literal PRCSTR$S_PRCSTRDEF = 52;
literal PRCSTR$S_PRCSTR = 52;
macro PRCSTR$L_FLINK = 0,0,32,1 %;      !  Foward link
macro PRCSTR$L_BLINK = 4,0,32,1 %;      !  Backward link
macro PRCSTR$W_SIZE = 8,0,16,0 %;       !  Size, in bytes
macro PRCSTR$B_TYPE = 10,0,8,0 %;       !  Structure type code 
macro PRCSTR$B_SUBTYPE = 11,0,8,0 %;    !  Structure subtype
macro PRCSTR$L_PARENT_PCB = 12,0,32,1 %; !  Address of parent/creator's PCB
macro PRCSTR$L_PROCSTRT = 16,0,32,1 %;  !  Address of alternate procstrt routine
macro PRCSTR$L_CTX_BUFFER = 20,0,32,1 %; !  Address of context buffer
macro PRCSTR$L_PHD_BUFFER = 24,0,32,1 %; !  Address of PHD data buffer
macro PRCSTR$L_P1POINTER_SVA = 28,0,32,1 %; !  System VA of P1 Pointer page
macro PRCSTR$L_P1POINTER_SVAPTE = 32,0,32,1 %; !  SVAPTE    of P1 Pointer page
macro PRCSTR$L_P1POINTER_PFN = 36,0,32,1 %; !  PFN       of P1 Pointer page
macro PRCSTR$L_PIO_SVA = 40,0,32,1 %;   !  Syetem VA of PIO page
macro PRCSTR$L_PIO_SVAPTE = 44,0,32,1 %; !  SVAPTE    of PIO page
macro PRCSTR$L_PIO_PFN = 48,0,32,1 %;   !  PFN       of P1 Pointer page
 
!*** MODULE $PRIDEF ***
! +
!  PRIORITY INCREMENT CLASS DEFINITIONS
! -
literal PRI$_NULL = 0;                  !  NO PRIORITY INCREMENT (must be equal to 0)
literal PRI$_IOCOM = 1;                 !  DIRECT I/O COMPLETION 
literal PRI$_RESAVL = 2;                !  RESOURCE AVAIL 
literal PRI$_TOCOM = 3;                 !  TERMINAL OUTPUT COMPLETE 
literal PRI$_TICOM = 4;                 !  TERMINAL INPUT COMPLETE 
literal PRI$_TIMER = 5;                 !  TIMER INTERVAL COMPLETION 
literal PRI$_PINC_CNT = 6;              !  No. of priority increment classes
literal PRI$C_NUM_PRI = 64;
literal PRI$C_NUM_NORMAL = 16;
literal PRI$C_NUM_REALTIME = 48;
!  Realtime threshold
literal PRI$C_RT_THRESHOLD = 16;
!  Priority interval for VMS native sched policy
literal PRI$C_MIN_VMS_PRIO = 0;
literal PRI$C_MAX_VMS_PRIO = 63;
!  Priority interval for POSIX RT policies
literal PRI$C_MIN_PSXRT_PRIO = 16;
literal PRI$C_MAX_PSXRT_PRIO = 63;
 
!*** MODULE $PRMDEF ***
! +
!  DEFINE PARAMETER DESCRIPTOR BLOCK
! -
literal PRM$M_DYNAMIC = %X'1';
literal PRM$M_STATIC = %X'2';
literal PRM$M_SYSGEN = %X'4';
literal PRM$M_ACP = %X'8';
literal PRM$M_JBC = %X'10';
literal PRM$M_RMS = %X'20';
literal PRM$M_SYS = %X'40';
literal PRM$M_SPECIAL = %X'80';
literal PRM$M_DISPLAY = %X'100';
literal PRM$M_CONTROL = %X'200';
literal PRM$M_MAJOR = %X'400';
literal PRM$M_PQL = %X'800';
literal PRM$M_NEG = %X'1000';
literal PRM$M_TTY = %X'2000';
literal PRM$M_SCS = %X'4000';
literal PRM$M_CLUSTER = %X'8000';
literal PRM$M_ASCII = %X'10000';
literal PRM$M_LGI = %X'20000';
literal PRM$M_MULTIPROCESSING = %X'40000';
literal PRM$M_CONVERT_PAGE = %X'80000';
literal PRM$M_MODIFIED = %X'100000';
literal PRM$C_BYTE = 8;                 !  
literal PRM$C_WORD = 16;                !  
literal PRM$C_LONG = 32;                !  
literal PRM$C_QUAD = 64;                ! 
literal PRM$C_OCTA = 128;               ! 
literal PRM$C_MAXNAMLEN = 15;           ! MAXIMUM LENGTH FOR PARAMETER NAME 
literal PRM$C_MAXUNILEN = 11;           ! MAXIMUM LENGTH FOR UNIT NAME 
literal PRM$K_LENGTH = 64;              ! SIZE OF DESCRIPTOR BLOCK 
literal PRM$C_LENGTH = 64;              ! SIZE OF DESCRIPTOR BLOCK 
literal PRM$S_PRM_DEF = 64;             !  Old size name - synonym
literal PRM$S_PRM = 64;
macro PRM$L_ADDR = 0,0,32,1 %;          ! ADDRESS OF PARAMETER
macro PRM$L_INT_ADDR = 4,0,32,1 %;      ! ADDRESS OF INTERAL VAL
macro PRM$L_DEFAULT = 8,0,32,0 %;       ! DEFAULT VALUE 
macro PRM$L_MIN = 12,0,32,0 %;          ! MINIMUM VALUE (-1)=>NONE 
macro PRM$L_MAX = 16,0,32,0 %;          ! MAXIMUM VALUE (-1)=>NONE 
macro PRM$L_INT_MIN = 20,0,32,0 %;      ! POST-CONVERSION MIN
macro PRM$L_FLAGS = 24,0,32,0 %;        ! TYPE FLAGS 
macro PRM$V_DYNAMIC = 24,0,1,0 %;       !  DYNAMIC PARAMETER 
macro PRM$V_STATIC = 24,1,1,0 %;        !  STATIC PARAMETER 
macro PRM$V_SYSGEN = 24,2,1,0 %;        !  SYSGEN PARAMETER 
macro PRM$V_ACP = 24,3,1,0 %;           !  ACP CONTROL PARAMETER 
macro PRM$V_JBC = 24,4,1,0 %;           !  JOB CONTROL PARAMETER 
macro PRM$V_RMS = 24,5,1,0 %;           !  RMS CONTROL PARAMETER 
macro PRM$V_SYS = 24,6,1,0 %;           !  GENERAL SYSTEM PARAMETER 
macro PRM$V_SPECIAL = 24,7,1,0 %;       !  SPECIAL PARAMETER 
macro PRM$V_DISPLAY = 24,8,1,0 %;       !  DISPLAY ONLY (NO CHANGE) 
macro PRM$V_CONTROL = 24,9,1,0 %;       !  CONTROL PARAMETER 
macro PRM$V_MAJOR = 24,10,1,0 %;        !  MAJOR PARAMETER 
macro PRM$V_PQL = 24,11,1,0 %;          !  PROCESS QUOTA LIST 
macro PRM$V_NEG = 24,12,1,0 %;          !  NEGATIVE 
macro PRM$V_TTY = 24,13,1,0 %;          !  TERMINAL CONTROL PARAMETER 
macro PRM$V_SCS = 24,14,1,0 %;          !  SCS CONTROL PARAMETERS 
macro PRM$V_CLUSTER = 24,15,1,0 %;      !  CLUSTER CONTROL PARAMETERS
macro PRM$V_ASCII = 24,16,1,0 %;        !  ASCII PARAMETER
macro PRM$V_LGI = 24,17,1,0 %;          !  LOGIN PARAMETER
macro PRM$V_MULTIPROCESSING = 24,18,1,0 %; !  MULTIPROCESSING control
macro PRM$V_CONVERT_PAGE = 24,19,1,0 %; !  Pagelets externally, pages internally
macro PRM$V_MODIFIED = 24,20,1,0 %;     !  Parameter modified (auditing)
macro PRM$L_SIZE = 28,0,32,0 %;         ! SIZE CODE FOR DATUM 
macro PRM$L_POS = 32,0,32,0 %;          ! BIT POSITION 
macro PRM$T_NAME = 36,0,0,0 %;
literal PRM$S_NAME = 16;                ! ASCIC NAME STRING 
macro PRM$T_UNIT = 52,0,0,0 %;
literal PRM$S_UNIT = 12;                ! ASCIC UNIT STRING 
 
!*** MODULE proc_read_write ***
! 
! 			  Copyright (c) 1991 by
! 	      Digital Equipment Corporation, Maynard, Mass.
! 
!  This software is furnished under a license and may be used and  copied
!  only  in  accordance  with  the  terms  of  such  license and with the
!  inclusion of the above copyright notice.  This software or  any  other
!  copies  thereof may not be provided or otherwise made available to any
!  other person.  No title to and ownership of  the  software  is  hereby
!  transferred.
! 
!  The information in this software is subject to change  without  notice
!  and  should  not  be  construed  as  a commitment by Digital Equipment
!  Corporation.
! 
!  Digital assumes no responsibility for the use or  reliability  of  its
!  software on equipment which is not supplied by Digital.
! 
! ++
!  Facility:
! 
! 	SYS
! 
!  Abstract:
! 
! 	This module defines all the constants and data structures for
!  PROC_READ_WRITE.BLI which are specific to that module.
! 
!  Environment:
! 
! 	Kernel mode at IPL = 0
! 
!  Author: Steve DiPirro	, Creation date: 30-JAN-1991
! 
!  Modified by:
! 
! 	X-2	RS00178		Richard Sayde		28-Oct-1991
! 		Add definitions to be able to read and write registers.
! 
! 	X-1	RS00175		Richard Sayde		22-Oct-1991
! 		Put module into CMS - made some changes based on the
! 		way SDA solved the problem.
! ---
! 
! 
! 
!  ACB extensions to accommodate various additional pieces of information
!  needed to complete process read/write operations.
!  
literal eacb$k_memory = 1;              ! 	virtual memory
literal eacb$k_general_register = 2;    ! 	R0-R29,PC,PS
literal eacb$k_float_register = 3;      ! 	F0-F30
literal eacb$k_gen_register_size = 8;   !  Number of bytes in a general
!  register
literal eacb$k_r0 = 0;
literal eacb$k_r1 = 1;
literal eacb$k_r2 = 2;
literal eacb$k_r3 = 3;
literal eacb$k_r4 = 4;
literal eacb$k_r5 = 5;
literal eacb$k_r6 = 6;
literal eacb$k_r7 = 7;
literal eacb$k_r8 = 8;                  !  R0 - R29, PC, PS (address
literal eacb$k_r9 = 9;
literal eacb$k_r10 = 10;
literal eacb$k_r11 = 11;
literal eacb$k_r12 = 12;
literal eacb$k_r13 = 13;
literal eacb$k_r14 = 14;
literal eacb$k_r15 = 15;                !  map for registers
literal eacb$k_r16 = 16;
literal eacb$k_r17 = 17;
literal eacb$k_r18 = 18;
literal eacb$k_r19 = 19;
literal eacb$k_r20 = 20;
literal eacb$k_r21 = 21;
literal eacb$k_r22 = 22;
literal eacb$k_r23 = 23;
literal eacb$k_r24 = 24;
literal eacb$k_r25 = 25;
literal eacb$k_r26 = 26;
literal eacb$k_r27 = 27;
literal eacb$k_r28 = 28;
literal eacb$k_r29 = 29;
literal eacb$k_pc = 30;
literal eacb$k_ps = 31;
literal eacb$k_gen_regs_length = 32;
literal eacb$k_float_register_size = 8;
literal eacb$k_fp0 = 0;
literal eacb$k_fp1 = 1;
literal eacb$k_fp2 = 2;
literal eacb$k_fp3 = 3;
literal eacb$k_fp4 = 4;
literal eacb$k_fp5 = 5;
literal eacb$k_fp6 = 6;                 !  FP0 - FP29 (address map for
literal eacb$k_fp7 = 7;
literal eacb$k_fp8 = 8;
literal eacb$k_fp9 = 9;
literal eacb$k_fp10 = 10;
literal eacb$k_fp11 = 11;
literal eacb$k_fp12 = 12;               !  registers
literal eacb$k_fp13 = 13;
literal eacb$k_fp14 = 14;
literal eacb$k_fp15 = 15;
literal eacb$k_fp16 = 16;
literal eacb$k_fp17 = 17;
literal eacb$k_fp18 = 18;
literal eacb$k_fp19 = 19;
literal eacb$k_fp20 = 20;
literal eacb$k_fp21 = 21;
literal eacb$k_fp22 = 22;
literal eacb$k_fp23 = 23;
literal eacb$k_fp24 = 24;
literal eacb$k_fp25 = 25;
literal eacb$k_fp26 = 26;
literal eacb$k_fp27 = 27;
literal eacb$k_fp28 = 28;
literal eacb$k_fp29 = 29;
literal eacb$k_float_regs_length = 30;
literal eacb$m_done = %X'1';
literal eacb$m_half_done = %X'2';
literal eacb$m_suspend = %X'4';
literal eacb$k_block_size = 52;         ! Length of data block
literal eacb$S_acb_extend = 52;
macro eacb$q_local_adr = 0,0,0,0 %;
literal eacb$s_local_adr = 8;           ! Local process address
macro eacb$q_target_adr_type = 8,0,0,0 %;
literal eacb$s_target_adr_type = 8;     ! target type, one of:
macro eacb$q_target_adr = 16,0,0,0 %;
literal eacb$s_target_adr = 8;          ! Target process address
macro eacb$q_status_adr = 24,0,0,0 %;
literal eacb$s_status_adr = 8;          ! Address of src process status longword
macro eacb$l_status = 32,0,32,0 %;      ! Operation completion status
macro eacb$l_buffer_size = 36,0,32,0 %; ! Buffer size to transfer
macro eacb$l_local_pid = 40,0,32,0 %;   ! Local process PID
macro eacb$l_image_count = 44,0,32,0 %; ! Process image count
macro eacb$r_flags_field = 48,0,32,0 %;
literal eacb$s_flags_field = 4;         ! 
macro eacb$l_flags = 48,0,32,0 %;       ! For references to whole thing
macro eacb$r_flags_bits = 48,0,8,0 %;
literal eacb$s_flags_bits = 1;          ! For individual bits
macro eacb$v_done = 48,0,1,0 %;         ! Operation complete flag
macro eacb$v_half_done = 48,1,1,0 %;    ! Operation partly complete flag
macro eacb$v_suspend = 48,2,1,0 %;      ! Set if target process should suspend
! 
! 
literal prcstk$k_nofp_save_size = 256;
literal prcstk$S_proc_save_regs = 256;
macro prcstk$q_r0 = 0,0,0,0 %;
literal prcstk$s_r0 = 8;                !  Saved r0
macro prcstk$q_r1 = 8,0,0,0 %;
literal prcstk$s_r1 = 8;                !  Saved r1
macro prcstk$q_r2 = 16,0,0,0 %;
literal prcstk$s_r2 = 8;                !  Saved r2
macro prcstk$q_r3 = 24,0,0,0 %;
literal prcstk$s_r3 = 8;                !  Saved r3
macro prcstk$q_r4 = 32,0,0,0 %;
literal prcstk$s_r4 = 8;                !  Saved r4
macro prcstk$q_r5 = 40,0,0,0 %;
literal prcstk$s_r5 = 8;                !  Saved r5
macro prcstk$q_r6 = 48,0,0,0 %;
literal prcstk$s_r6 = 8;                !  Saved r6
macro prcstk$q_r7 = 56,0,0,0 %;
literal prcstk$s_r7 = 8;                !  Saved r7
macro prcstk$q_r8 = 64,0,0,0 %;
literal prcstk$s_r8 = 8;                !  Saved r8
macro prcstk$q_r9 = 72,0,0,0 %;
literal prcstk$s_r9 = 8;                !  Saved r9
macro prcstk$q_r10 = 80,0,0,0 %;
literal prcstk$s_r10 = 8;               !  Saved r10
macro prcstk$q_r11 = 88,0,0,0 %;
literal prcstk$s_r11 = 8;               !  Saved r11
macro prcstk$q_r12 = 96,0,0,0 %;
literal prcstk$s_r12 = 8;               !  Saved r12
macro prcstk$q_r13 = 104,0,0,0 %;
literal prcstk$s_r13 = 8;               !  Saved r13
macro prcstk$q_r14 = 112,0,0,0 %;
literal prcstk$s_r14 = 8;               !  Saved r14
macro prcstk$q_r15 = 120,0,0,0 %;
literal prcstk$s_r15 = 8;               !  Saved r15
macro prcstk$q_r16 = 128,0,0,0 %;
literal prcstk$s_r16 = 8;               !  Saved r16
macro prcstk$q_r17 = 136,0,0,0 %;
literal prcstk$s_r17 = 8;               !  Saved r17
macro prcstk$q_r18 = 144,0,0,0 %;
literal prcstk$s_r18 = 8;               !  Saved r18
macro prcstk$q_r19 = 152,0,0,0 %;
literal prcstk$s_r19 = 8;               !  Saved r19
macro prcstk$q_r20 = 160,0,0,0 %;
literal prcstk$s_r20 = 8;               !  Saved r20
macro prcstk$q_r21 = 168,0,0,0 %;
literal prcstk$s_r21 = 8;               !  Saved r21
macro prcstk$q_r22 = 176,0,0,0 %;
literal prcstk$s_r22 = 8;               !  Saved r22
macro prcstk$q_r23 = 184,0,0,0 %;
literal prcstk$s_r23 = 8;               !  Saved r23
macro prcstk$q_r24 = 192,0,0,0 %;
literal prcstk$s_r24 = 8;               !  Saved r24
macro prcstk$q_r25 = 200,0,0,0 %;
literal prcstk$s_r25 = 8;               !  Saved r25
macro prcstk$q_r26 = 208,0,0,0 %;
literal prcstk$s_r26 = 8;               !  Saved r26
macro prcstk$q_r27 = 216,0,0,0 %;
literal prcstk$s_r27 = 8;               !  Saved r27
macro prcstk$q_r28 = 224,0,0,0 %;
literal prcstk$s_r28 = 8;               !  Saved r28
macro prcstk$q_r29 = 232,0,0,0 %;
literal prcstk$s_r29 = 8;               !  Saved r29
macro prcstk$q_pc = 240,0,0,0 %;
literal prcstk$s_pc = 8;                !  Saved pc
macro prcstk$q_ps = 248,0,0,0 %;
literal prcstk$s_ps = 8;                !  Saved ps
!  
!  End of module proc_read_write
! 
 
!*** MODULE $PRQDEF ***
! +
!  INTER-PROCESSOR REQUEST BLOCK DEFINITIONS
! 
!  THIS IS THE BASIC FORMAT FOR AN EXECUTIVE OR DRIVER REQUEST FROM
!  ONE PROCESSOR TO ANOTHER PROCESSOR.
! -
literal PRQ$C_EXEC = 0;                 !  EXECUTIVE REQUEST ID 
literal PRQ$C_MAILBOX = 1;              !  MAILBOX REQUEST ID 
literal PRQ$C_REMDISK = 2;              !  REMOTE DISK REQUEST ID 
literal PRQ$C_HSC50 = 3;                !  HSC-50 REQUEST ID 
literal PRQ$C_SETEF = 0;                !  COPY COMMON EVENT FLAG REQUEST ID 
literal PRQ$C_RESAVL = 1;               !  REPORT RESOURCE AVAILABLE 
literal PRQ$C_MINLENGTH = 64;           ! MINIMUM REQUEST BLOCK LENGTH 
literal PRQ$S_PRQDEF = 40;
literal PRQ$S_PRQ = 40;
macro PRQ$L_FLINK = 0,0,32,1 %;         ! FORWARD LINK TO NEXT BLOCK 
macro PRQ$L_BLINK = 4,0,32,1 %;         ! BACKWARD LINK TO PREVIOUS BLOCK 
macro PRQ$W_TO_PORT = 24,0,16,0 %;      ! PORT NUMBER TO SEND REQUEST TO 
macro PRQ$W_FR_PORT = 26,0,16,0 %;      ! PORT NUMBER REQUEST IS FROM 
macro PRQ$W_DISPATCH = 28,0,16,0 %;     ! MESSAGE DISPATCHER ID 
!  MESSAGE DISPATCHER ID'S
! 
macro PRQ$W_REQTYPE = 32,0,16,0 %;      ! REQUEST TYPE 
!  MESSAGE DISPATCHER REQUEST SUB-TYPES
macro PRQ$W_UNIT = 34,0,16,0 %;         ! UNIT NUMBER 
macro PRQ$L_PARAM = 36,0,32,0 %;        ! FIRST PARAMETER 
 
!*** MODULE $PSCANCTXDEF ***
! 
!  The PSCANCTX$ structure is exchanged with remote nodes.  Any updates to this
!  structure must take mixed-version operation into account.
! 
literal pscanctx$m_super = %X'1';
literal pscanctx$m_csid_vec = %X'2';
literal pscanctx$m_locked = %X'4';
literal pscanctx$m_multi_node = %X'8';
literal pscanctx$m_busy = %X'10';
literal pscanctx$m_relock = %X'20';
literal pscanctx$k_length = 64;         !  length of data structure
literal pscanctx$m_node_item = -2147483648; !  item code references a node
literal pscanctx$v_node_item = 31;      !  item code references a node
literal pscanctx$S_$pscanctxdef = 64;   !  Old size name - synonym
literal pscanctx$S_pscanctx = 64;
macro pscanctx$l_flink = 0,0,32,1 %;    !  forward link
macro pscanctx$l_blink = 4,0,32,1 %;    !  back link
macro pscanctx$w_size = 8,0,16,0 %;     !  size of structure
macro pscanctx$b_type = 10,0,8,0 %;     !  structure type code
macro pscanctx$b_subtype = 11,0,8,0 %;  !  structure subtype
macro pscanctx$w_maj_vers = 12,0,16,0 %; !  incompatible level
macro pscanctx$w_min_vers = 14,0,16,0 %; !  upwards-compatible level
macro pscanctx$l_flags = 16,0,32,0 %;
macro pscanctx$v_super = 16,0,1,0 %;    !  allocated from supervisor mode
macro pscanctx$v_csid_vec = 16,1,1,0 %; !  csid vector is present
macro pscanctx$v_locked = 16,2,1,0 %;   !  cell is locked in memory
macro pscanctx$v_multi_node = 16,3,1,0 %; !  scan is for more than one node
macro pscanctx$v_busy = 16,4,1,0 %;     !  scan in progress on this block
macro pscanctx$v_relock = 16,5,1,0 %;   !  ignore BUSY flag, allow a "lock"
macro pscanctx$l_cur_csid = 20,0,32,0 %; !  CSID for scan in progress
macro pscanctx$l_cur_ipid = 24,0,32,0 %; !  initial IPID for scan in progress
macro pscanctx$l_next_ipid = 28,0,32,0 %; !  updated IPID for scan in progress
macro pscanctx$l_cur_epid = 32,0,32,0 %; !  EPID for scan in progress
macro pscanctx$w_itmlstoff = 36,0,16,0 %; !  offset to item list
macro pscanctx$w_bufferoff = 38,0,16,0 %; !  offset to buffer area
macro pscanctx$w_csidoff = 40,0,16,0 %; !  offset to csid vector
macro pscanctx$w_csididx = 42,0,16,0 %; !  index of current csid
macro pscanctx$l_svapte = 44,0,32,0 %;  !  sva of pte for this block
macro pscanctx$l_cwpssrv = 48,0,32,1 %; !  address of CWPSSRV structure
macro pscanctx$l_jpibufadr = 52,0,32,1 %; !  address of $GETJPI buffer
macro pscanctx$w_seqnum = 56,0,16,0 %;  !  sequence number
macro pscanctx$b_acmode = 58,0,8,0 %;   !  access mode of original call
macro pscanctx$b_spare0 = 59,0,8,0 %;   !  just a little extra
macro pscanctx$l_spare1 = 60,0,32,0 %;  !  just a little extra
! 
!  The PSCANBUF$ structure is exchanged with remote nodes.  Any updates to this
!  structure must take mixed-version operation into account.
! 
literal pscanbuf$m_spare0 = %X'1';
literal pscanbuf$k_length = 32;         !  length of data structure
literal pscanbuf$S_$pscanbufdef = 32;   !  Old size name - synonym
literal pscanbuf$S_pscanbuf = 32;
macro pscanbuf$l_buflen = 0,0,32,0 %;   !  length of data area
macro pscanbuf$l_spare0 = 4,0,32,0 %;   !  spare0
macro pscanbuf$w_size = 8,0,16,0 %;     !  size of structure
macro pscanbuf$b_type = 10,0,8,0 %;     !  structure type code
macro pscanbuf$b_subtype = 11,0,8,0 %;  !  structure subtype
macro pscanbuf$w_maj_vers = 12,0,16,0 %; !  incompatible level
macro pscanbuf$w_min_vers = 14,0,16,0 %; !  upwards-compatible level
macro pscanbuf$l_flags = 16,0,32,0 %;
macro pscanbuf$v_spare0 = 16,0,1,0 %;   !  filler
macro pscanbuf$l_itmlstadr = 20,0,32,1 %; !  address of copy of JPI item list
macro pscanbuf$l_buffer_offset = 24,0,32,0 %; !  offset to start of buffer
macro pscanbuf$l_free_offset = 28,0,32,0 %; !  offset to next free byte
! 
!  The PSCANITM$ structure is a local structure.  If modified, you do not need
!  to take mixed-version operation into account, however you must be sure that
!  all modules and images which reference the structure are updated together.
! 
literal pscanitm$k_length = 12;         !  length of data structure
literal pscanitm$S_$pscanitmdef = 13;   !  Old size name - synonym
literal pscanitm$S_pscanitm = 13;
macro pscanitm$l_alloc_length = 0,0,32,0 %; !  allocated length
macro pscanitm$l_itmlen = 4,0,32,0 %;   !  length of item list
macro pscanitm$w_size = 8,0,16,0 %;     !  size of header
macro pscanitm$b_type = 10,0,8,0 %;     !  structure type code
macro pscanitm$b_subtype = 11,0,8,0 %;  !  structure subtype
macro pscanitm$b_itmlst = 12,0,8,0 %;   !  start of the item list
 
!*** MODULE $PSMDEF ***
!  Print symbiont definitions
! +
!  Symbolic definitions for print symbionts.
! 
! 	Public definition of various constants and data structures
! 	used by the standard VMS print symbiont, and by user modified
! 	print symbionts.
! 
! -
! 
! 	Service routine function codes
! 
! 
!  IO functions
! 
literal PSM$K_CANCEL = 1;               !  Cancel pending operations
literal PSM$K_CLOSE = 2;                !  Release resources
literal PSM$K_FORMAT = 3;               !  Format buffer
literal PSM$K_OPEN = 4;                 !  Obtain resources
literal PSM$K_READ = 5;                 !  Read
literal PSM$K_GET_KEY = 6;              !  Read record key
literal PSM$K_POSITION_TO_KEY = 7;      !  Read by record context
literal PSM$K_REWIND = 8;               !  Rewind file
literal PSM$K_WRITE = 9;                !  Write
literal PSM$K_WRITE_NOFORMAT = 10;      !  Write with driver formatting disabled
literal PSM$K_WRITE_SUPPRESSED = 11;    !  Write but suppress output
! 
!  Message notification functions
! 
literal PSM$K_PAUSE_TASK = 12;          !  STOP /QUEUE
literal PSM$K_RESET_STREAM = 13;        !  STOP /QUEUE /RESET
literal PSM$K_RESUME_TASK = 14;         !  START /QUEUE	(when paused)
literal PSM$K_START_STREAM = 15;        !  START /QUEUE (when stopped)
literal PSM$K_START_TASK = 16;          !  (ofiginated by job controller)
literal PSM$K_STOP_TASK = 17;           !  STOP /QUEUE /ABORT or /REQUEUE
literal PSM$K_STOP_STREAM = 18;         !  STOP /QUEUE /NEXT
! 
! 	Replacement routines
! 
! 
!  Task services -- where applicable the ordering of these literals
!  determines the sequence of the corresponding service routines.
! 
! 
!  Page services
! 
literal PSM$K_PAGE_SETUP = 1;           !  Page setup	    - page setup modules
literal PSM$K_PAGE_HEADER = 2;          !  Page separation  - page headers
! 
!  Library module service
! 
literal PSM$K_LIBRARY_INPUT = 3;        !  Module services
! 
!  Filter services
! 
literal PSM$K_INPUT_FILTER = 4;         !  Filter service   - input
literal PSM$K_MAIN_FORMAT = 5;          !  Format service   - carriage control
literal PSM$K_OUTPUT_FILTER = 6;        !  Filter service   - output
! 
!  Output services
! 
literal PSM$K_OUTPUT = 7;               !  Main output routine
! 
!  General input services
! 
literal PSM$K_JOB_SETUP = 8;            !  Job setup	    - job reset modules
literal PSM$K_FORM_SETUP = 9;           !  Form setup	    - form setup modules
literal PSM$K_JOB_FLAG = 10;            !  Job separation   - flag page
literal PSM$K_JOB_BURST = 11;           !  Job separation   - burst page
literal PSM$K_FILE_SETUP = 12;          !  File setup	    - file setup modules
literal PSM$K_FILE_FLAG = 13;           !  File separation  - flag page
literal PSM$K_FILE_BURST = 14;          !  File separation  - burst page
literal PSM$K_FILE_SETUP_2 = 15;        !  File setup	    - top of form
literal PSM$K_MAIN_INPUT = 16;          !  File service	    - main routine
literal PSM$K_FILE_INFORMATION = 17;    !  Additional information print
literal PSM$K_FILE_ERRORS = 18;         !  Errors during task processing
literal PSM$K_FILE_TRAILER = 19;        !  File separation  - trailer page
literal PSM$K_JOB_RESET = 20;           !  Job reset	    - job reset modules
literal PSM$K_JOB_TRAILER = 21;         !  Job separation   - trailer page
literal PSM$K_JOB_COMPLETION = 22;      !  Job completion   - top of form
literal PSM$K_PAGE_FOOTER = 23;         !  Page separation  - page footers
literal PSM$k_max = 24;                 !  MUST BE LAST
! 
! 	Carriage control types
! 
literal PSM$K_CC_INTERNAL = 1;          !   - imbedded
literal PSM$K_CC_IMPLIED = 2;           !   - implied
literal PSM$K_CC_FORTRAN = 3;           !   - fortran
literal PSM$K_CC_PRINT = 4;             !   - print file (PRN)
literal PSM$K_CC_MAX = 5;               !  MUST BE LAST
literal PSM$M_LAT_PROTOCOL = %X'1';
literal PSM$S_P5_FLAGS = 4;             !  PSM$PRINT PaRAMETER 5
macro PSM$L_FLAGS = 0,0,32,0 %;
macro PSM$V_LAT_PROTOCOL = 0,0,1,0 %;   !   
 
!*** MODULE $PROCSTATE ***
literal PSTATE$K_LENGTH = 272;          !  Length of process state
literal PSTATE$S_PROCSTATE = 272;
macro PSTATE$Q_R8 = 0,0,0,0 %;
literal PSTATE$S_R8 = 8;                !  register R8
macro PSTATE$Q_R9 = 8,0,0,0 %;
literal PSTATE$S_R9 = 8;                !  register R9
macro PSTATE$Q_R10 = 16,0,0,0 %;
literal PSTATE$S_R10 = 8;               !  register R10
macro PSTATE$Q_R11 = 24,0,0,0 %;
literal PSTATE$S_R11 = 8;               !  register R11
macro PSTATE$Q_R12 = 32,0,0,0 %;
literal PSTATE$S_R12 = 8;               !  register R12
macro PSTATE$Q_R13 = 40,0,0,0 %;
literal PSTATE$S_R13 = 8;               !  register R13
macro PSTATE$Q_R14 = 48,0,0,0 %;
literal PSTATE$S_R14 = 8;               !  register R14
macro PSTATE$Q_R15 = 56,0,0,0 %;
literal PSTATE$S_R15 = 8;               !  register R15
macro PSTATE$Q_R29 = 64,0,0,0 %;
literal PSTATE$S_R29 = 8;               !  register R29
macro PSTATE$Q_ALIGN_0 = 72,0,0,0 %;
literal PSTATE$S_ALIGN_0 = 8;           !  for alignment
macro PSTATE$Q_R0 = 80,0,0,0 %;
literal PSTATE$S_R0 = 8;                !  register R0
macro PSTATE$Q_R1 = 88,0,0,0 %;
literal PSTATE$S_R1 = 8;                !  register R1
macro PSTATE$Q_R16 = 96,0,0,0 %;
literal PSTATE$S_R16 = 8;               !  register R16
macro PSTATE$Q_R17 = 104,0,0,0 %;
literal PSTATE$S_R17 = 8;               !  register R17
macro PSTATE$Q_R18 = 112,0,0,0 %;
literal PSTATE$S_R18 = 8;               !  register R18
macro PSTATE$Q_R19 = 120,0,0,0 %;
literal PSTATE$S_R19 = 8;               !  register R19
macro PSTATE$Q_R20 = 128,0,0,0 %;
literal PSTATE$S_R20 = 8;               !  register R20
macro PSTATE$Q_R21 = 136,0,0,0 %;
literal PSTATE$S_R21 = 8;               !  register R21
macro PSTATE$Q_R22 = 144,0,0,0 %;
literal PSTATE$S_R22 = 8;               !  register R22
macro PSTATE$Q_R23 = 152,0,0,0 %;
literal PSTATE$S_R23 = 8;               !  register R23
macro PSTATE$Q_R24 = 160,0,0,0 %;
literal PSTATE$S_R24 = 8;               !  register R24
macro PSTATE$Q_R25 = 168,0,0,0 %;
literal PSTATE$S_R25 = 8;               !  register R25
macro PSTATE$Q_R26 = 176,0,0,0 %;
literal PSTATE$S_R26 = 8;               !  register R26
macro PSTATE$Q_R27 = 184,0,0,0 %;
literal PSTATE$S_R27 = 8;               !  register R27
macro PSTATE$Q_R28 = 192,0,0,0 %;
literal PSTATE$S_R28 = 8;               !  register R28
macro PSTATE$Q_ALIGN_1 = 200,0,0,0 %;
literal PSTATE$S_ALIGN_1 = 8;           !  for alignment
macro PSTATE$Q_R2 = 208,0,0,0 %;
literal PSTATE$S_R2 = 8;                !  register R2
macro PSTATE$Q_R3 = 216,0,0,0 %;
literal PSTATE$S_R3 = 8;                !  register R3
macro PSTATE$Q_R4 = 224,0,0,0 %;
literal PSTATE$S_R4 = 8;                !  register R4
macro PSTATE$Q_R5 = 232,0,0,0 %;
literal PSTATE$S_R5 = 8;                !  register R5
macro PSTATE$Q_R6 = 240,0,0,0 %;
literal PSTATE$S_R6 = 8;                !  register R6
macro PSTATE$Q_R7 = 248,0,0,0 %;
literal PSTATE$S_R7 = 8;                !  register R7
macro PSTATE$Q_PC = 256,0,0,0 %;
literal PSTATE$S_PC = 8;                !  register PC
macro PSTATE$Q_PS = 264,0,0,0 %;
literal PSTATE$S_PS = 8;                !  register PS
 
!*** MODULE $PSXFCBDEF ***
!  amount of space reserved to save kernel stack
!  during callbacks
!  and the exec stack
! 
! 	The following structure contains data about the process's use of fork
! 	callbacks. There is at most one of these per process and it is
! 	referenced through the P1 space cell CTL$GL_FORK_CONTROL_BLOCK
! 
literal PSXFCB$M_DISABLED = %X'1';
literal PSXFCB$C_KERN_SAVE_SIZE = 384;
literal PSXFCB$K_KERN_SAVE_SIZE = 384;
literal PSXFCB$C_EXEC_STACK_SAVE = 1280;
literal PSXFCB$K_EXEC_STACK_SAVE = 1280;
literal PSXFCB$S_PSXFCB = 6776;
macro PSXFCB$L_FLINK = 0,0,32,1 %;      !  forward link (unused)
macro PSXFCB$L_BLINK = 4,0,32,1 %;      !  backeard link (unused)
macro PSXFCB$W_SIZE = 8,0,16,0 %;       !  size allocated 
macro PSXFCB$B_TYPE = 10,0,8,0 %;       !  block type
macro PSXFCB$B_SUBTYPE = 11,0,8,0 %;    !  sub type
macro PSXFCB$R_FLAGS = 12,0,32,0 %;
literal PSXFCB$S_FLAGS = 4;             !  flags longword
macro PSXFCB$V_DISABLED = 12,0,1,0 %;   !  callbacks are diabled
macro PSXFCB$V_SPARE = 12,1,31,0 %;
literal PSXFCB$S_SPARE = 31;
macro PSXFCB$L_BLOCK_COUNT = 16,0,0,1 %;
literal PSXFCB$S_BLOCK_COUNT = 16;      !  per-mode block counters
macro PSXFCB$L_HANDLER_COUNT = 32,0,0,1 %;
literal PSXFCB$S_HANDLER_COUNT = 16;    !  count of handlers
macro PSXFCB$L_WAIT = 48,0,0,1 %;
literal PSXFCB$S_WAIT = 16;             !  wait counters (unused
macro PSXFCB$L_WHEN = 64,0,32,1 %;      !  when callbacks are being call
macro PSXFCB$L_FAILED_WHEN = 68,0,32,1 %; !  state of when bits on failure
macro PSXFCB$L_CANCEL_STATE = 72,0,32,1 %; !  mode (+1) of failure
macro PSXFCB$L_CALLBACK_STATE = 76,0,32,1 %; !  mode (+1) of current callbacks
macro PSXFCB$L_PID = 80,0,32,0 %;       !  pid of 'other' process
macro PSXFCB$L_FAILING_DISP = 84,0,32,0 %; !  psxdisp address of failing cb
macro PSXFCB$L_IMAGE_LIST = 88,0,32,1 %; !  pointer to first image fdb
macro PSXFCB$L_PROCESS_LIST = 92,0,32,1 %; !  pointer to first process fdb
macro PSXFCB$L_OUTER_STACK = 96,0,32,0 %; !  saved outer mode stack for cbs
macro PSXFCB$L_SAVE_AP = 100,0,32,0 %;  !  saved AP during callbacks 
macro PSXFCB$L_SAVE_FP = 104,0,32,0 %;  !  saved FP during cbs
macro PSXFCB$L_SAVE_SP = 108,0,32,0 %;  !  saved sp during cbs
macro PSXFCB$L_SAVE_PSL = 112,0,32,0 %; !  saved psl during cbs
macro PSXFCB$L_SAVE_EXEC_SP = 116,0,32,0 %; !  saved exec stack pointer
!  
!  	The area below is used to save the kernel mode stack contents while
! 	callbacks are being made
! 	
macro PSXFCB$L_STACK_SAVE_AREA = 120,0,0,0 %;
literal PSXFCB$S_STACK_SAVE_AREA = 1536;
macro PSXFCB$L_EXEC_STACK_AREA = 1656,0,0,0 %;
literal PSXFCB$S_EXEC_STACK_AREA = 5120;
 
!*** MODULE $PSXFDBDEF ***
! 
!   PSXDISP is the format of a callback dispatch. there  is an array of 
!   callback dispatched in each PSXFDB structure.
! 
literal PSXDISP$M_DISABLED = %X'1';
literal PSXDISP$S_PSXDISP = 20;
macro PSXDISP$R_FLAGS = 0,0,32,0 %;
literal PSXDISP$S_FLAGS = 4;            !  flag word
macro PSXDISP$V_DISABLED = 0,0,1,0 %;   !  this callback is disabled
macro PSXDISP$V_SPARE = 0,1,31,0 %;
literal PSXDISP$S_SPARE = 31;           !  fill out the longword
! 
macro PSXDISP$L_WHEN = 4,0,32,0 %;      !  when the callback are to be made
macro PSXDISP$L_ACMODE = 8,0,32,0 %;    !  access mode of the callback
macro PSXDISP$L_HANDLER = 12,0,32,1 %;  !  address of the callback handler
macro PSXDISP$L_ARG = 16,0,32,0 %;      !  argument to pass to the handler
!  stack
! 
! 	This structure is used to make lists of callbacks routines
! 
! 
literal PSXFDB$C_numcalls = 10;
literal PSXFDB$K_numcalls = 10;
literal PSXFDB$S_PSXFDB = 212;
macro PSXFDB$L_SQFL = 0,0,32,1 %;       !  link to next fdb
macro PSXFDB$L_SQBL = 4,0,32,1 %;       !  link to prev fdb
macro PSXFDB$W_SIZE = 8,0,16,0 %;       !  size
macro PSXFDB$B_TYPE = 10,0,8,0 %;       !  type
macro PSXFDB$B_SUBTYPE = 11,0,8,0 %;
macro PSXFDB$B_CALLS = 12,0,0,1 %;
literal PSXFDB$S_CALLS = 200;           !  array of dispatches
 
!*** MODULE $PXDSRRDEF IDENT X-7 ***
literal psx$_psx$spare_vms_1 = 0;
literal psx$_psx$set_masks = 1;
literal psx$_psx$same_session = 2;
literal psx$_psx$vip_astexit_chmk = 3;
literal psx$_psx$check_cpulim = 4;
literal psx$_psx$get_cpulim = 5;
literal psx$_psx$rdc_cpulim = 6;
literal psx$_psx$alloc_p1_pages = 7;
literal psx$_psx$time_mode = 8;
literal psx$_psx$make_callbacks = 9;
literal psx$_psx$system_callback_list = 10;
literal psx$_psx$fork_check = 11;
literal psx$_psx$callback_service = 12;
literal psx$_psx$sendsegv = 13;
literal psx$_psx$check_new_pid = 14;
literal psx$_psx$spare_vms_16 = 15;
literal psx$_psx$spare_vms_17 = 16;
literal psx$_psx$spare_vms_18 = 17;
literal psx$_psx$spare_vms_19 = 18;
literal psx$_psx$spare_vms_20 = 19;
literal psx$_psx$spare_vms_21 = 20;
literal psx$_psx$spare_vms_22 = 21;
literal psx$_psx$spare_vms_23 = 22;
literal psx$_psx$spare_vms_24 = 23;
literal psx$_psx$spare_vms_25 = 24;
literal psx$_psx$spare_vms_26 = 25;
literal psx$_psx$spare_vms_27 = 26;
literal psx$_psx$spare_vms_28 = 27;
literal psx$_psx$spare_vms_29 = 28;
literal psx$_psx$spare_vms_30 = 29;
literal psx$_psx$spare_vms_31 = 30;
literal psx$_psx$spare_vms_32 = 31;
literal psx$_psx$spare_vms_33 = 32;
literal psx$_psx$spare_vms_34 = 33;
literal psx$_psx$spare_vms_35 = 34;
literal psx$_psx$spare_vms_36 = 35;
literal psx$_psx$spare_vms_37 = 36;
literal psx$_psx$spare_vms_38 = 37;
literal psx$_psx$spare_vms_39 = 38;
literal psx$_psx$spare_vms_40 = 39;
literal psx$_psx$send_signal = 40;
literal psx$_psx$send_signal_to_group = 41;
literal psx$_psx$send_signal_to_session = 42;
literal psx$_psx$rundown = 43;
literal psx$_psx$rundown_exec = 44;
literal psx$_psx$ga_cfs_base = 45;
literal psx$_psx$gl_next_rndwn = 46;
literal psx$_psx$gl_next_rndwn_exec = 47;
literal psx$_psx$ga_spg_table = 48;
literal psx$_psx$gl_spg_size = 49;
literal psx$_psx$gl_spg_hash = 50;
literal psx$_psx$gl_max_fork_in_prg = 51;
literal psx$_psx$gl_max_fork_perproc = 52;
literal psx$_psx$gl_max_sess_perproc = 53;
literal psx$_psx$gl_exec_arg_size = 54;
literal psx$_psx$gl_fs_buff_size = 55;
literal psx$_psx$gl_fork_in_prg = 56;
literal psx$_psx$gl_def_process_flags = 57;
literal psx$_psx$lookup_spg_table = 58;
literal psx$_psx$ga_default_termios = 59;
literal psx$_psx$spare_13 = 60;
literal psx$_psx$spare_14 = 61;
literal psx$_psx$spare_15 = 62;
literal psx$_psx$spare_16 = 63;
literal psx$_psx$spare_17 = 64;
literal psx$_psx$spare_18 = 65;
literal psx$_psx$spare_19 = 66;
literal psx$_psx$spare_20 = 67;
literal psx$_psx$spare_21 = 68;
literal psx$_psx$spare_22 = 69;
literal psx$_psx$spare_23 = 70;
literal psx$_psx$spare_24 = 71;
literal psx$_psx$spare_25 = 72;
literal psx$_psx$spare_26 = 73;
literal psx$_psx$spare_27 = 74;
literal psx$_psx$spare_28 = 75;
literal psx$_psx$spare_29 = 76;
literal psx$_sub_total_number = 77;
literal PXDSRR$K_LENGTH = 308;
literal PXDSRR$C_LENGTH = 308;
literal PXDSRR$S_PXDSRR = 308;
macro PXDSRR$L_GLOBAL_CELLS = 0,0,0,0 %;
literal PXDSRR$S_GLOBAL_CELLS = 308;
literal PSXFRK$K_LENGTH = 248;          ! LENGTH OF FORK CONTEXT BLOCK
literal PSXFRK$C_LENGTH = 248;          ! LENGTH OF FORK CONTEXT BLOCK
literal PSXFRK$S_PSXFRK = 248;
macro PSXFRK$Q_R2 = 0,0,0,1 %;
literal PSXFRK$S_R2 = 8;                ! R2
macro PSXFRK$Q_R3 = 8,0,0,1 %;
literal PSXFRK$S_R3 = 8;                ! R3
macro PSXFRK$Q_R4 = 16,0,0,1 %;
literal PSXFRK$S_R4 = 8;                ! R4
macro PSXFRK$Q_R5 = 24,0,0,1 %;
literal PSXFRK$S_R5 = 8;                ! R5
macro PSXFRK$Q_R6 = 32,0,0,1 %;
literal PSXFRK$S_R6 = 8;                ! R6
macro PSXFRK$Q_R7 = 40,0,0,1 %;
literal PSXFRK$S_R7 = 8;                ! R7
macro PSXFRK$Q_R8 = 48,0,0,1 %;
literal PSXFRK$S_R8 = 8;                ! R8
macro PSXFRK$Q_R9 = 56,0,0,1 %;
literal PSXFRK$S_R9 = 8;                ! R9
macro PSXFRK$Q_R10 = 64,0,0,1 %;
literal PSXFRK$S_R10 = 8;               ! R10
macro PSXFRK$Q_R11 = 72,0,0,1 %;
literal PSXFRK$S_R11 = 8;               ! R11
macro PSXFRK$Q_R12 = 80,0,0,1 %;
literal PSXFRK$S_R12 = 8;               ! R12
macro PSXFRK$Q_R13 = 88,0,0,1 %;
literal PSXFRK$S_R13 = 8;               ! R13
macro PSXFRK$Q_R14 = 96,0,0,1 %;
literal PSXFRK$S_R14 = 8;               ! R14
macro PSXFRK$Q_R15 = 104,0,0,1 %;
literal PSXFRK$S_R15 = 8;               ! R15
macro PSXFRK$Q_FP = 112,0,0,1 %;
literal PSXFRK$S_FP = 8;                ! FP
macro PSXFRK$Q_RA = 120,0,0,1 %;
literal PSXFRK$S_RA = 8;                ! RA
macro PSXFRK$Q_ESP = 128,0,0,1 %;
literal PSXFRK$S_ESP = 8;               ! ESP
macro PSXFRK$Q_SSP = 136,0,0,1 %;
literal PSXFRK$S_SSP = 8;               ! SSP
macro PSXFRK$Q_USP = 144,0,0,1 %;
literal PSXFRK$S_USP = 8;               ! USP
macro PSXFRK$Q_UNQ = 152,0,0,1 %;
literal PSXFRK$S_UNQ = 8;               ! PROCESS UNQ
macro PSXFRK$Q_ASTEN = 160,0,0,1 %;
literal PSXFRK$S_ASTEN = 8;             ! ASTEN
macro PSXFRK$Q_FEN_DATFX = 168,0,0,1 %;
literal PSXFRK$S_FEN_DATFX = 8;         ! FEN & DATFX	    
macro PSXFRK$Q_F2 = 176,0,0,1 %;
literal PSXFRK$S_F2 = 8;                ! F2
macro PSXFRK$Q_F3 = 184,0,0,1 %;
literal PSXFRK$S_F3 = 8;                ! F3
macro PSXFRK$Q_F4 = 192,0,0,1 %;
literal PSXFRK$S_F4 = 8;                ! F4
macro PSXFRK$Q_F5 = 200,0,0,1 %;
literal PSXFRK$S_F5 = 8;                ! F5
macro PSXFRK$Q_F6 = 208,0,0,1 %;
literal PSXFRK$S_F6 = 8;                ! F6
macro PSXFRK$Q_F7 = 216,0,0,1 %;
literal PSXFRK$S_F7 = 8;                ! F7
macro PSXFRK$Q_F8 = 224,0,0,1 %;
literal PSXFRK$S_F8 = 8;                ! F8
macro PSXFRK$Q_F9 = 232,0,0,1 %;
literal PSXFRK$S_F9 = 8;                ! F9
macro PSXFRK$Q_FPCR = 240,0,0,1 %;
literal PSXFRK$S_FPCR = 8;              ! FPCR
 
!*** MODULE $PTEDEF ***
! +
!  Define page table entry vields and values
! -
literal PTE$C_BYTES_PER_PTE = 8;        !  Byte length of Page Table Entry
literal PTE$C_SHIFT_SIZE = 3;           !  PTE size as a power of 2
! 
!  Vield definition for "valid" PTEs
! 
literal PTE$M_VALID = %X'1';
literal PTE$M_FOR = %X'2';
literal PTE$M_FOW = %X'4';
literal PTE$M_FOE = %X'8';
literal PTE$M_ASM = %X'10';
literal PTE$M_GH = %X'60';
literal PTE$C_GROUP_OF_1 = 0;           !  Page in group of 1
literal PTE$C_GROUP_OF_8 = 1;           !  Page in group of 8
literal PTE$C_GROUP_OF_64 = 2;          !  Page in group of 64
literal PTE$C_GROUP_OF_512 = 3;         !  Page in group of 512
literal PTE$M_RSRVD_HW = %X'80';
literal PTE$M_PROT = %X'FF00';
literal PTE$M_SOFTWARE = %X'FFFF0000';
literal PTE$M_PFN = %X'FFFFFFFF00000000';
literal PTE$M_KRE = %X'100';
literal PTE$M_ERE = %X'200';
literal PTE$M_SRE = %X'400';
literal PTE$M_URE = %X'800';
literal PTE$M_KWE = %X'1000';
literal PTE$M_EWE = %X'2000';
literal PTE$M_SWE = %X'4000';
literal PTE$M_UWE = %X'8000';
literal PTE$M_WINDOW = %X'10000';
literal PTE$M_OWN = %X'60000';
literal PTE$M_MODIFY = %X'100000';
literal PTE$M_CPY = %X'30000000';
literal PTE$M_NOX = %X'40000000';
literal PTE$M_S0_MBZ = %X'80000000';
literal PTE$M_TYP0 = %X'10000';
literal PTE$M_PARTIAL_SECTION = %X'80000';
literal PTE$M_TYP1 = %X'100000';
literal PTE$M_STX = %X'FFFF00000000';
literal PTE$M_CRF = %X'1000000000000';
literal PTE$M_DZRO = %X'2000000000000';
literal PTE$M_WRT = %X'4000000000000';
literal PTE$M_PGFLPAG = %X'FFFFF00000000';
literal PTE$M_PRCPGFLX = %X'30000000000000';
literal PTE$M_BAKX = %X'FFFFFFFF00000000';
literal PTE$M_GPTX = %X'FFFFFFFF00000000';
literal PTE$C_NA = 0;                   !  No Access 
literal PTE$C_KR = 256;                 !  Kernel Read only 
literal PTE$C_KW = 4352;                !  Kernel Write
literal PTE$C_ER = 768;                 !  Exec Read only
literal PTE$C_EW = 13056;               !  Exec Write
literal PTE$C_SR = 1792;                !  Super Read only
literal PTE$C_SW = 30464;               !  Super Write
literal PTE$C_UR = 3840;                !  User Read only
literal PTE$C_UW = 65280;               !  User Write
literal PTE$C_ERKW = 4864;              !  Exec Read Kernel Write
literal PTE$C_SRKW = 5888;              !  Super Read Kernel Write
literal PTE$C_SREW = 14080;             !  Super Read Exec Write
literal PTE$C_URKW = 7936;              !  User Read Kernel Write
literal PTE$C_UREW = 16128;             !  User Read Exec Write
literal PTE$C_URSW = 32512;             !  User Read Super Write
! +
literal PTE$C_KOWN = 0;                 !  Kernel Owner Mode
literal PTE$C_EOWN = 131072;            !  Executive Owner Mode
literal PTE$C_SOWN = 262144;            !  Supervisor Owner Mode
literal PTE$C_UOWN = 393216;            !  User Owner Mode
! +
literal PTE$C_COPY = 0;                 !  Copy
literal PTE$C_NOCOPY = 268435456;       !  No copy
literal PTE$C_DZRO = 536870912;         !  Copy as DZRO
literal PTE$S_PTE = 8;
macro PTE$R_PTE_UNION = 0,0,0,0 %;
literal PTE$S_PTE_UNION = 8;
macro PTE$V_VALID = 0,0,1,0 %;          !  VALID bit
macro PTE$V_FOR = 0,1,1,0 %;            !  Fault On Read
macro PTE$V_FOW = 0,2,1,0 %;            !  Fault On Write
macro PTE$V_FOE = 0,3,1,0 %;            !  Fault On Execute
macro PTE$V_ASM = 0,4,1,0 %;            !  Address Space Match
macro PTE$V_GH = 0,5,2,0 %;
literal PTE$S_GH = 2;                   !  Granularity Hint
macro PTE$V_RSRVD_HW = 0,7,1,0 %;       !  Reserved for Hardware
macro PTE$V_PROT = 0,8,8,0 %;
literal PTE$S_PROT = 8;                 !  Page Protection
macro PTE$V_SOFTWARE = 0,16,16,0 %;
literal PTE$S_SOFTWARE = 16;            !  Bits Reserved to Software
macro PTE$V_PFN = 4,0,32,0 %;
literal PTE$S_PFN = 32;                 !  Page Frame Number
macro PTE$V_KRE = 0,8,1,0 %;            !  Kernel Read Enable
macro PTE$V_ERE = 0,9,1,0 %;            !  Executive Read Enable
macro PTE$V_SRE = 0,10,1,0 %;           !  Supervisor Read Enable
macro PTE$V_URE = 0,11,1,0 %;           !  User Read Enable
macro PTE$V_KWE = 0,12,1,0 %;           !  Kernel Write Enable
macro PTE$V_EWE = 0,13,1,0 %;           !  Executive Write Enable
macro PTE$V_SWE = 0,14,1,0 %;           !  Supervisor Write Enable
macro PTE$V_UWE = 0,15,1,0 %;           !  User Write Enable
macro PTE$V_WINDOW = 0,16,1,0 %;        !  Windowed Page Bit
macro PTE$V_OWN = 0,17,2,0 %;
literal PTE$S_OWN = 2;                  !  Page Owner Mode
macro PTE$V_MODIFY = 0,20,1,0 %;        !  Page Modified Bit
macro PTE$V_CPY = 0,28,2,0 %;
literal PTE$S_CPY = 2;                  !  Copy characteristic
macro PTE$V_NOX = 0,30,1,0 %;           !  No Execute Access Allowed
macro PTE$V_S0_MBZ = 0,31,1,0 %;        !  S0 space bit: MBZ in PTE
! 
!  Vield definitions for various invalid forms of PTE
! 
macro PTE$V_TYP0 = 0,16,1,0 %;          !  TYP0 Bit
macro PTE$V_PARTIAL_SECTION = 0,19,1,0 %; !  Only part of page maps to section
macro PTE$V_TYP1 = 0,20,1,0 %;          !  TYP1 Bit
macro PTE$V_STX = 4,0,16,1 %;
literal PTE$S_STX = 16;                 !  Section Table Index
macro PTE$V_CRF = 4,16,1,0 %;           !  Copy on Reference
macro PTE$V_DZRO = 4,17,1,0 %;          !  Demand Zero
macro PTE$V_WRT = 4,18,1,0 %;           !  Section file accessed for write
macro PTE$V_PGFLPAG = 4,0,20,0 %;
literal PTE$S_PGFLPAG = 20;             !  Page File Page Number (not a VBN)
macro PTE$V_PRCPGFLX = 4,20,2,0 %;
literal PTE$S_PRCPGFLX = 2;             !  Process page file index
macro PTE$V_BAKX = 4,0,32,0 %;
literal PTE$S_BAKX = 32;                !  Backup Address (uninterpreted)
macro PTE$V_GPTX = 4,0,32,0 %;
literal PTE$S_GPTX = 32;                !  Global Page Table Index
! +
!  Protection field definitions. These protection encodings provide
!  a way to express page protection using VAX-like protection symbols.
! 
!  These constants are not meant to be shifted into the PROT position.
!  They incorporate protection information as bitmasks relative to the
!  start of a PTE already.
! -
!  OWNer mode field definitions
! 
!  These constants are not meant to be shifted into the owner field. They
!  incorporate ownership information as a bitmask relative to the start of
!  a PTE already.
! _
!  CoPY field definitions
! 
!  These constants are not meant to be shifted into the copy characteristic
!  field. They incorporate copy characteristic information relative to the 
!  start of a PTE already.
! _
! 
!  Vield definitions for system page table entries that reside on the free list.
! 
!  For a single free SPTE, the flag bit will be set and no COUNT offset will exist.
!  For 2 or more free SPTEs, the flag bit will be clear and the COUNT offset will
!  contain the number of SPTEs in this block.
! 
!  In all cases, the first 16 bits of each free SPTE *must be zero*.
! 
! 
literal PTE$M_SINGLE_SPTE = %X'80000000';
literal PTE$S_PTE_FREE = 16;
macro PTE$V_SINGLE_SPTE = 0,31,1,0 %;   !  =1 if a single free SPTE
macro PTE$L_LINK = 4,0,32,0 %;          !  VPN of next free system space
macro PTE$L_COUNT = 12,0,32,0 %;        !  Count of free SPTEs in this block
literal PTE$S_PTEDEF = 16;              !  Old PTE size constant for compatibility
literal PTE$C_FREE_BLOCK = 16;          !  Byte length of SPTE free block
 
!*** MODULE $PTRDEF ***
! +
!  POINTER CONTROL BLOCK
!         THIS IS A STRUCTURE OF POINTERS TO OTHER DYNAMIC STRUCTURES
!         OF LIKE KIND.  TYPICALLY THE STRUCTURES POINTED TO ARE KNOWN
!         BY THEIR LONG WORD INDEX INTO THE TABLE AND TO FACILITATE FETCHING
!         THESE, IT IS CONVENTIONAL TO KEEP A POINTER TO THE BASE OF THE
!         STRUCTURE POINTERS RATHER THAN (OR IN ADDITION TO) THE POINTER
!         TO THE FRONT OF THE POINTER CONTROL BLOCK.  THE NUMBER OF POINTERS
!         IN THE ARRAY PRECEEDS THE FIRST POINTER IN THE ARRAY.
! -
literal PTR$K_LENGTH = 16;              ! LENGTH OF FIXED PORTION 
literal PTR$C_LENGTH = 16;              ! LENGTH OF FIXED PORTION 
literal PTR$S_PTRDEF = 20;
literal PTR$S_PTR = 20;
macro PTR$W_SIZE = 8,0,16,0 %;          ! SIZE OF DYNAMIC CONTROL BLOCK 
macro PTR$B_TYPE = 10,0,8,0 %;          ! TYPE OF DYNAMIC CONTROL BLOCK 
macro PTR$B_PTRTYPE = 11,0,8,0 %;       ! TYPE OF CONTROL BLOCK POINTED TO 
macro PTR$L_PTRCNT = 12,0,32,0 %;       ! COUNT OF ENTRIES 
macro PTR$L_PTR0 = 16,0,32,1 %;         ! PTR NUMBER 0 
 
!*** MODULE $PWDHISDEF ***
!  Password History Record - This structure defines the layout of the system
!  password history file.  This is a variable record length indexed file (keyed
!  by username) where each record contains the last "n" quadword hash values for
!  the user's last "n" passwords.
literal PWDHIS$C_ENTRY_LENGTH = 16;     !  size of one entry
literal PWDHIS$K_ENTRY_LENGTH = 16;     !  size of one entry
literal PWDHIS$S_PWDENTDEF = 16;
literal PWDHIS$S_PWDENT = 16;
macro PWDHIS$Q_ENTRY = 0,0,0,1 %;
literal PWDHIS$S_ENTRY = 8;             !  the quadword hash
macro PWDHIS$Q_CHANGE = 8,0,0,1 %;
literal PWDHIS$S_CHANGE = 8;            !  password change date
literal PWDHIS$C_FIXED = 32;            !  fixed part of record
literal PWDHIS$K_FIXED = 32;            !  fixed part of record
literal PWDHIS$C_DEFAULT_LIFETIME = 365; !  default history lifetime (days)
literal PWDHIS$K_DEFAULT_LIFETIME = 365; !  default history lifetime (days)
literal PWDHIS$C_DEFAULT_LIMIT = 60;    !  default # of history entries per user
literal PWDHIS$K_DEFAULT_LIMIT = 60;    !  default # of history entries per user
literal PWDHIS$C_MAXIMUM_LIMIT = 2000;  !  maximum # of history entries per user
literal PWDHIS$K_MAXIMUM_LIMIT = 2000;  !  maximum # of history entries per user
literal PWDHIS$S_PWDHISDEF = 36;
literal PWDHIS$S_PWDHIS = 36;
macro PWDHIS$T_USERNAME = 0,0,0,0 %;
literal PWDHIS$S_USERNAME = 32;         !  username (KEY0)
macro PWDHIS$R_HISTORY = 32,0,32,0 %;
literal PWDHIS$S_HISTORY = 4;           !  offset to start of list
 
!*** MODULE $RDIDEF ***
! ++
!  Rights Database Identifier Block definitions: This structure contains the
!  RMS Internal File Identifiers (IFI's) and Internal Stream Identifiers
!  (ISI's) for the rights database. This structure is allocated from the
!  process allocation region pool.
! --
literal RDI$K_ISI_MAX = 10;             !  Maximum number of concurrent record streams
literal RDI$M_READ_CHECK = %X'1';
literal RDI$M_READ_ACCESS = %X'2';
literal RDI$S_RDIDEF = 64;
literal RDI$S_RDI = 64;
macro RDI$L_SIZE = 0,0,32,0 %;          !  Size of allocated block
macro RDI$L_IFI_READ = 4,0,32,0 %;      !  Internal File Identifier for read operations
macro RDI$L_IFI_WRITE = 8,0,32,0 %;     !  Internal File Identifier for write operations
macro RDI$L_READ_CHANNEL = 12,0,32,0 %; !  Holds channel used for reading RDB.
macro RDI$L_FLAGS = 16,0,32,0 %;        !   Flags longword
macro RDI$V_READ_CHECK = 16,0,1,0 %;    !   Set if read access checked
macro RDI$V_READ_ACCESS = 16,1,1,0 %;   !   Set if there is read access to RDB
macro RDI$L_ISI_VEC = 20,0,0,0 %;
literal RDI$S_ISI_VEC = 44;             !  Internal Stream Identifier vector
 
!*** MODULE $RDPDEF ***
! 
!  REMOTE DEVICE PROTOCOL DEFINITIONS
! 
literal RDP$K_HEADERLEN = 10;           ! HEADER LENGTH 
literal RDP$C_HEADERLEN = 10;           ! HEADER LENGTH 
literal RDP$S_RDPHDR = 10;
macro RDP$W_OPCODE = 0,0,16,0 %;        ! OPERATION CODE 
macro RDP$W_MOD = 2,0,16,0 %;           ! OPERATION CODE MODIFIERS 
macro RDP$L_REFID = 4,0,32,0 %;         ! REFERENCE ID 
macro RDP$W_UNIT = 8,0,16,0 %;          ! DEVICE UNIT NUMBER 
macro RDP$W_SIZE = 8,0,16,0 %;          ! SIZE OF MESSAGE (ACP/DRIVER USE ONLY) 
literal RDP$C_ATTN = -1;                !  ATTENTION 
literal RDP$C_END = -2;                 !  I/O REQUEST COMPLETE 
literal RDP$C_LOG = -3;                 !  ERROR LOG 
literal RDP$S_RDPDEF = 34;              !  Old size name - synonym
literal RDP$S_RDP = 34;
macro RDP$L_PARAM1 = 10,0,32,0 %;       ! PARAMETER 1 
macro RDP$L_PARAM2 = 14,0,32,0 %;       ! PARAMETER 2 
macro RDP$L_PARAM3 = 18,0,32,0 %;       ! PARAMETER 3 
macro RDP$L_PARAM4 = 22,0,32,0 %;       ! PARAMETER 4 
macro RDP$L_PARAM5 = 26,0,32,0 %;       ! PARAMETER 5 
macro RDP$L_PARAM6 = 30,0,32,0 %;       ! PARAMETER 6 
! 
!  RESPONSE FROM REMOTE PACKET DEFINITIONS
! 
! RESPONSE PACKET OPCODES 
literal RDP$S_RDPDEF1 = 18;             !  Old size name - synonym
literal RDP$S_RDP1 = 18;
macro RDP$Q_STATUS = 10,0,0,0 %;
literal RDP$S_STATUS = 8;               ! END PACKET I/O STATUS 
! 
!  TERMINAL SPECIFIC PARAMETER DEFINITIONS
! 
!   READ/WRITE REQUEST
literal RDP$S_RDPDEF2 = 19;             !  Old size name - synonym
literal RDP$S_RDP2 = 19;
macro RDP$L_TT_BCNT = 10,0,32,0 %;      ! BYTE COUNT 
macro RDP$L_TT_CARCON = 14,0,32,0 %;    ! WRITE CARRIAGE CONTROL 
macro RDP$L_TT_TIMOUT = 14,0,32,0 %;    ! READ TIMEOUT 
macro RDP$T_TT_WDATA = 18,0,8,0 %;      ! WRITE DATA 
macro RDP$T_TT_TERM = 18,0,8,0 %;       ! BYTE OF SIZE + TERMINATOR MASK 
! WORD OF SIZE + PROMPT STRING
!  SET MODE/CHARACTERISTICS REQUEST
literal RDP$S_RDPDEF3 = 34;             !  Old size name - synonym
literal RDP$S_RDP3 = 34;
macro RDP$Q_TT_CHAR = 10,0,0,0 %;
literal RDP$S_TT_CHAR = 8;              ! CHARACTERISTICS 
macro RDP$L_TT_ASTPRM = 10,0,32,0 %;    ! AST PARAMETER 
macro RDP$L_TT_SPEED = 18,0,32,0 %;     ! LINE SPEED 
macro RDP$L_TT_FILL = 22,0,32,0 %;      ! FILL SPECIFIER 
macro RDP$L_TT_PARITY = 26,0,32,0 %;    ! PARITY FLAGS 
macro RDP$L_TT_CHAR2 = 30,0,32,0 %;     !  Remaining longword of characters 
!   READ REQUEST END PACKET
literal RDP$S_RDPDEF4 = 19;             !  Old size name - synonym
literal RDP$S_RDP4 = 19;
macro RDP$T_TT_RDATA = 18,0,8,0 %;      ! WORD OF SIZE + READ DATA 
!   SENSE MODE/CHARACTERISTICS END PACKET
literal RDP$S_RDPDEF5 = 30;             !  Old size name - synonym
literal RDP$S_RDP5 = 30;
macro RDP$Q_TT_SCHAR = 18,0,0,0 %;
literal RDP$S_TT_SCHAR = 8;             ! SENSED CHARACTERISTICS 
macro RDP$L_TT_SCHAR2 = 26,0,32,0 %;    !  Additional longword of characters 
!  Broadcast message attention packet
literal RDP$C_TT_BRDNAME = 16;          !  Size of name field 
literal RDP$S_RDPDEF6 = 34;             !  Old size name - synonym
literal RDP$S_RDP6 = 34;
macro RDP$W_TT_BRDTOTSIZE = 10,0,16,0 %; !  Total size of data 
macro RDP$W_TT_BRDMSG = 12,0,16,0 %;    !  Message code 
macro RDP$W_TT_BRDUNIT = 14,0,16,0 %;   !  Unit number 
macro RDP$T_TT_BRDNAME = 16,0,0,0 %;
literal RDP$S_TT_BRDNAME = 16;          !  Device name as counted string 
macro RDP$W_TT_BRDTXTSIZE = 32,0,16,0 %; !  Count for message text 
macro RDP$T_TT_BRDTEXT = 34,0,0,0 %;    !  Message text start 
!  Out of band attention packet
literal RDP$C_TT_UNSOL = 0;             ! UNSOLICITED DATA 
literal RDP$C_TT_HANGUP = 1;            ! MODEM HANGUP 
literal RDP$C_TT_CTRLC = 2;             ! CONTROL/C 
literal RDP$C_TT_CTRLY = 3;             ! CONTROL/Y 
literal RDP$C_TT_STARTRCV = 4;          !  Start a receive to the net 
literal RDP$C_TT_BRDCST = 5;            !  Broadcast message for mailbox 
literal RDP$C_TT_OUTBAND = 6;           !  Out of band AST 
literal RDP$S_RDPDEF7 = 11;             !  Old size name - synonym    
literal RDP$S_RDP7 = 11;
macro RDP$B_TT_OUTBAND = 10,0,8,0 %;    !  Out of band character 
!  ATTENTION PACKET MODIFIERS
 
!*** MODULE $RBFDEF ***
! 
!         Remote buffer as stored in dynamic memory
! 
!         This structure must be identical to the above structure except
!         for the header, which is the header for a buffered io buffer.
! 
! 
!         Buffered io buffer header
! 
literal RBF$K_HEADERLEN = 24;           ! HEADER LENGTH 
literal RBF$C_HEADERLEN = 24;           ! HEADER LENGTH 
literal RBF$S_RBFHDR = 24;
macro RBF$L_MSGDAT = 0,0,32,1 %;        !  Address of message data 
macro RBF$L_USRBFR = 4,0,32,1 %;        !  User buffer address 
macro RBF$W_SIZE = 8,0,16,0 %;          !  Size of structure 
macro RBF$B_TYPE = 10,0,8,0 %;          !  Type of structure, DYN$C_BUFIO 
macro RBF$B_SPARE = 11,0,8,0 %;         !  Alignment 
macro RBF$W_DATSIZE = 12,0,16,0 %;      !  Data size 
macro RBF$W_OPCODE = 14,0,16,0 %;       ! OPERATION CODE 
macro RBF$W_MOD = 16,0,16,0 %;          ! OPERATION CODE MODIFIERS 
macro RBF$L_REFID = 18,0,32,0 %;        ! REFERENCE ID 
macro RBF$W_UNIT = 22,0,16,0 %;         ! DEVICE UNIT NUMBER 
!         S        SIZE,0,W                /*SIZE OF MESSAGE (ACP/DRIVER USE ONLY)
literal RBF$C_ATTN = -1;                !  ATTENTION 
literal RBF$C_END = -2;                 !  I/O REQUEST COMPLETE 
literal RBF$C_LOG = -3;                 !  ERROR LOG 
literal RBF$S_RBFDEF = 48;              !  Old size name - synonym
literal RBF$S_RBF = 48;
! 
!         End of header
! 
macro RBF$L_PARAM1 = 24,0,32,0 %;       ! PARAMETER 1 
macro RBF$L_PARAM2 = 28,0,32,0 %;       ! PARAMETER 2 
macro RBF$L_PARAM3 = 32,0,32,0 %;       ! PARAMETER 3 
macro RBF$L_PARAM4 = 36,0,32,0 %;       ! PARAMETER 4 
macro RBF$L_PARAM5 = 40,0,32,0 %;       ! PARAMETER 5 
macro RBF$L_PARAM6 = 44,0,32,0 %;       ! PARAMETER 6 
! 
!  RESPONSE FROM REMOTE PACKET DEFINITIONS
! 
! RESPONSE PACKET OPCODES 
literal RBF$S_RBFDEF1 = 32;             !  Old size name - synonym
literal RBF$S_RBF1 = 32;
macro RBF$Q_STATUS = 24,0,0,0 %;
literal RBF$S_STATUS = 8;               ! END PACKET I/O STATUS 
! 
!  TERMINAL SPECIFIC PARAMETER DEFINITIONS
! 
!   READ/WRITE REQUEST
literal RBF$S_RBFDEF2 = 33;             !  Old size name - synonym
literal RBF$S_RBF2 = 33;
macro RBF$L_TT_BCNT = 24,0,32,0 %;      ! BYTE COUNT 
macro RBF$L_TT_CARCON = 28,0,32,0 %;    ! WRITE CARRIAGE CONTROL 
macro RBF$L_TT_TIMOUT = 28,0,32,0 %;    ! READ TIMEOUT 
macro RBF$T_TT_WDATA = 32,0,8,0 %;      ! WRITE DATA 
macro RBF$T_TT_TERM = 32,0,8,0 %;       ! BYTE OF SIZE + TERMINATOR MASK 
! WORD OF SIZE + PROMPT STRING
!  SET MODE/CHARACTERISTICS REQUEST
literal RBF$S_RBFDEF3 = 48;             !  Old size name - synonym
literal RBF$S_RBF3 = 48;
macro RBF$Q_TT_CHAR = 24,0,0,0 %;
literal RBF$S_TT_CHAR = 8;              ! CHARACTERISTICS 
macro RBF$L_TT_ASTPRM = 24,0,32,0 %;    ! AST PARAMETER 
macro RBF$L_TT_SPEED = 32,0,32,0 %;     ! LINE SPEED 
macro RBF$L_TT_FILL = 36,0,32,0 %;      ! FILL SPECIFIER 
macro RBF$L_TT_PARITY = 40,0,32,0 %;    ! PARITY FLAGS 
macro RBF$L_TT_CHAR2 = 44,0,32,0 %;     !  Another longword of characters 
!   READ REQUEST END PACKET
literal RBF$S_RBFDEF4 = 33;             !  Old size name - synonym
literal RBF$S_RBF4 = 33;
macro RBF$T_TT_RDATA = 32,0,8,0 %;      ! WORD OF SIZE + READ DATA 
!   SENSE MODE/CHARACTERISTICS END PACKET
literal RBF$S_RBFDEF5 = 44;             !  Old size name - synonym
literal RBF$S_RBF5 = 44;
macro RBF$Q_TT_SCHAR = 32,0,0,0 %;
literal RBF$S_TT_SCHAR = 8;             ! SENSED CHARACTERISTICS 
macro RBF$L_TT_SCHAR2 = 40,0,32,0 %;    !  Another longword of characters 
!  Broadcast message attention packet
literal RBF$C_TT_BRDNAME = 16;          !  Size of name field 
literal RBF$S_RBFDEF6 = 48;             !  Old size name - synonym
literal RBF$S_RBF6 = 48;
macro RBF$W_TT_BRDTOTSIZE = 24,0,16,0 %; !  Total size of data 
macro RBF$W_TT_BRDMSG = 26,0,16,0 %;    !  Message code 
macro RBF$W_TT_BRDUNIT = 28,0,16,0 %;   !  Unit number 
macro RBF$T_TT_BRDNAME = 30,0,0,0 %;
literal RBF$S_TT_BRDNAME = 16;          !  Device name as counted string 
macro RBF$W_TT_BRDTXTSIZE = 46,0,16,0 %; !  Count for message text 
macro RBF$T_TT_BRDTEXT = 48,0,0,0 %;    !  Message text start 
!  Out of band attention packet
literal RBF$C_TT_UNSOL = 0;             ! UNSOLICITED DATA 
literal RBF$C_TT_HANGUP = 1;            ! MODEM HANGUP 
literal RBF$C_TT_CTRLC = 2;             ! CONTROL/C 
literal RBF$C_TT_CTRLY = 3;             ! CONTROL/Y 
literal RBF$C_TT_STARTRCV = 4;          !  Start a receive to the net 
literal RBF$C_TT_BRDCST = 5;            !  Broadcast message for mailbox 
literal RBF$C_TT_OUTBAND = 6;           !  Out of band AST 
literal RBF$S_RBFDEF7 = 25;             !  Old size name - synonym
literal RBF$S_RBF7 = 25;
macro RBF$B_TT_OUTBAND = 24,0,8,0 %;    !  Out of band character 
!  ATTENTION PACKET MODIFIERS
 
!*** MODULE $RCTDEF ***
! +
!  RCT - Replacement and Caching Table sector !0 layout.
!         The RCT is a structure residing on disks controlled by MSCP
!         speaking disk controllers.  The RCT is maintained by the intelligent
!         controllers and the disk class driver.  The disk class driver mainly
!         gets involved in RCT manipulations during host initiated bad
!         block replacement.
literal RCT$M_WB = %X'1';
literal RCT$M_FE = %X'80';
literal RCT$M_BR = %X'2000';
literal RCT$M_RP2 = %X'4000';
literal RCT$M_RP1 = %X'8000';
literal RCT$M_LBN = %X'FFFFFFF';
literal RCT$M_CODE = %X'F0000000';
literal RCT$M_NONPRIME = %X'10000000';
literal RCT$M_ALLOCATED = %X'20000000';
literal RCT$M_UNUSABLE = %X'40000000';
literal RCT$M_NULL = %X'80000000';
literal RCT$K_EMPTY = 0;                !  Unallocated (empty) replacement block 
literal RCT$K_ALOCPRIME = 2;            !  Allocated replace blk - primary RBN 
literal RCT$K_ALOCNONP = 3;             !  Allocated replace blk - non-primary RBN 
literal RCT$K_UNUSABLE = 4;             !  Unusable replacement block 
literal RCT$K_ALTUNUSE = 5;             !  Alternate unusable replacement block 
literal RCT$K_NULL = 8;                 !  Null entry - no corresponding RBN sector 
literal RCT$S_RCTDEF = 44;              !  Old size name - synonym
literal RCT$S_RCT = 44;
macro RCT$Q_VOLSER = 0,0,0,0 %;
literal RCT$S_VOLSER = 8;               !  Volume serial number 
macro RCT$W_FLAGS = 8,0,16,0 %;         !  Flags word 
macro RCT$V_WB = 8,0,1,0 %;             !  Write back caching in use 
macro RCT$V_FE = 8,7,1,0 %;             !  Forced Error flag for block being replaced 
macro RCT$V_BR = 8,13,1,0 %;            !  Replacement caused by Bad RBN 
macro RCT$V_RP2 = 8,14,1,0 %;           !  Replacement in Progress phase 2 
macro RCT$V_RP1 = 8,15,1,0 %;           !  Replacement in Progress phase 1 
macro RCT$L_LBN = 12,0,32,0 %;          !  LBN curently being replaced. 
macro RCT$L_RBN = 16,0,32,0 %;          !  RBN allocated to replace LBN 
macro RCT$L_BAD_RBN = 20,0,32,0 %;      !  If BR flag, RBN of bad replacement block 
macro RCT$Q_WB_CTRL = 24,0,0,0 %;
literal RCT$S_WB_CTRL = 8;              !  Serial ! of last controller doing Write back 
macro RCT$L_WB_INCAR = 32,0,32,0 %;     !  Write back incarnation ! 
macro RCT$Q_INCARTIME = 36,0,0,0 %;
literal RCT$S_INCARTIME = 8;            !  Date-time of last update of incarnation no. 
! 
!  Structure of a Replacement Block Descriptor
! 
macro RCT$V_LBN = 36,0,28,0 %;
literal RCT$S_LBN = 28;                 !  Space for LBN replaced by this RBN 
macro RCT$V_CODE = 36,28,4,0 %;
literal RCT$S_CODE = 4;                 !  Describes how this descriptor being used 
macro RCT$V_NONPRIME = 36,28,1,0 %;     !  Set implies allocated, but not prime RBN 
macro RCT$V_ALLOCATED = 36,29,1,0 %;    !  This RBN allocated 
macro RCT$V_UNUSABLE = 36,30,1,0 %;     !  This RBN unusable 
macro RCT$V_NULL = 36,31,1,0 %;         !  This marks a NULL entry 
!  Values of CODE 
 
!*** MODULE $RDABDEF ***
literal RDAB$M_DEFAULT = %X'8';
literal RDAB$K_LENGTH = 24;             !  Length of RDAB
literal RDAB$C_LENGTH = 24;             !  Length of RDAB
literal RDAB$S_RDABDEF = 24;
literal RDAB$S_RDAB = 24;
macro RDAB$L_RDDB = 0,0,32,1 %;         !  pointer to the RDDB
macro RDAB$L_MAC = 4,0,32,0 %;          !  spare longword 
macro RDAB$L_SEQ = 8,0,32,0 %;          !  RDAB sequence number
macro RDAB$L_ACCESS = 12,0,32,0 %;      !  access mask
macro RDAB$V_DEFAULT = 12,3,1,0 %;      !  RADB created as default
macro RDAB$L_ACMODE = 16,0,32,0 %;      !  access mode (RSDM_ID)
macro RDAB$L_DOM_ACMODE = 20,0,32,0 %;  !  domain access mode
 
!*** MODULE $RDDBDEF ***
literal RDDB$M_KEEP = %X'1';
literal RDDB$M_NO_PROFILE = %X'2';
literal RDDB$K_LENGTH = 36;             !  Length of RDDB
literal RDDB$C_LENGTH = 36;             !  Length of RDDB
literal RDDB$S_RDDBDEF = 36;
literal RDDB$S_RDDB = 36;
macro RDDB$L_FLINK = 0,0,32,1 %;        !  RDDB queue forward link
macro RDDB$L_BLINK = 4,0,32,1 %;        !  RDDB queue backward link
macro RDDB$L_SIZE = 8,0,32,0 %;         !  Size in bytes
macro RDDB$L_TYPE = 12,0,32,0 %;        !  Structure type code for RDDB
macro RDDB$L_FLAGS = 16,0,32,0 %;
macro RDDB$V_KEEP = 16,0,1,0 %;         !  Domain block is deallocated if
!  refcnt goes to 0 and KEEP not set
!  KEEP is set on successful access.
macro RDDB$V_NO_PROFILE = 16,1,1,0 %;   !  Domain profile being instantiated
macro RDDB$L_GROUP = 20,0,32,0 %;       !  domain number
macro RDDB$L_ORB = 24,0,32,1 %;         !  Pointer to the ORB
macro RDDB$L_LOCKID = 28,0,32,0 %;      !  Lock id value (MAC)
macro RDDB$L_REFCNT = 32,0,32,0 %;      !  Count of RDs + root locks
 
!*** MODULE $RDPBDEF ***
literal RDPB$K_LENGTH = 172;            !  Length of RDPB
literal RDPB$C_LENGTH = 172;            !  Length of RDPB
literal RDPB$C_NUM = 6;                 !  # of RDABs/RDPB
literal RDPB$S_RDPBDEF = 172;
literal RDPB$S_RDPB = 172;
macro RDPB$L_FLINK = 0,0,32,1 %;        !  RDPB queue forward link
macro RDPB$L_BLINK = 4,0,32,1 %;        !  RDPB queue backward link
macro RDPB$W_SIZE = 8,0,16,0 %;         !  Size in bytes
macro RDPB$B_TYPE = 10,0,8,0 %;         !  Structure type code for RDPB
macro RDPB$L_NUM = 12,0,32,0 %;         !  Number of RDABs per RDPB
macro RDPB$L_DEFAULT_RDAB = 16,0,32,1 %; !  address of RDAB for default domain    
macro RDPB$L_DEFAULT_DOMAIN = 20,0,32,0 %; !  domain number for default domain
macro RDPB$L_DEFAULT_ID = 24,0,32,0 %;  !  RDAB index for default domain
! +
!  Next 24*6 bytes are for the 6 RDAB fields contained in the RDPB
! -
macro RDPB$L_RDAB = 28,0,0,1 %;
literal RDPB$S_RDAB = 144;              !  space for 6 RDABs
 
!*** MODULE $RDTDEF ***
! +
!  RDT - SCS RESPONSE DESCRIPTOR TABLE
! 
!  ONE RESPONSE DESCRIPTOR (RD) IS ALLOCATED FOR EACH SCS MESSAGE
!  SENT FOR WHICH THE SENDER EXPECTS A MATCHING RESPONSE.
! -
literal RDT$C_LENGTH = 40;              ! LENGTH OF NEG PORTION OF STRUCTURE 
! 
literal RDT$S_RDTDEF = 41;
literal RDT$S_RDT = 41;
macro RDT$B_SCS_MAINT_BLOCK = -40,0,0,0 %;
literal RDT$S_SCS_MAINT_BLOCK = 16;     ! Add a Maintenance block to the CDT
!  which must be quadword aligned
macro RDT$L_WAITFL = -24,0,32,1 %;      ! RD WAIT QUEUE FWD LINK 
macro RDT$L_WAITBL = -20,0,32,1 %;      ! RD WAIT QUEUE BACK LINK 
macro RDT$W_SIZE = -16,0,16,0 %;        ! STRUCTURE SIZE IN BYTES 
macro RDT$B_TYPE = -14,0,8,0 %;         ! SCS STURCTURE TYPE 
macro RDT$B_SUBTYP = -13,0,8,0 %;       ! SCS STRUCT SUBTYPE FOR RDT 
macro RDT$L_FREERD = -12,0,32,1 %;      ! ADDR OF 1ST FREE RD 
macro RDT$L_MAXRDIDX = -8,0,32,0 %;     ! MAXIMUM ! OF DESCRIPTORS 
macro RDT$L_QRDT_CNT = -4,0,32,0 %;     ! Count of stalls because of no response ID's
 
!*** MODULE $RDDEF ***
! +
!  RD - SCS RESPONSE DESCRIPTOR FORMAT
! -
literal RD$K_LENGTH = 8;                ! LENGTH OF RD 
literal RD$C_LENGTH = 8;                ! LENGTH OF RD 
literal RD$S_RDDEF = 8;
literal RD$S_SCS_RD = 8;
macro RD$L_CDRP = 0,0,32,1 %;           ! ADDR OF ASSOC CDRP OR 
!  OR OTHER CONTEXT BLOCK
macro RD$L_LINK = 0,0,32,1 %;           !  OR LINK TO NEXT FREE RD 
macro RD$W_STATE = 4,0,16,0 %;          ! RD STATE FLAGS 
macro RD$V_BUSY = 4,0,1,0 %;            !  ALLOCATED IF SET 
macro RD$V_PERM = 4,1,1,0 %;            !  PERMANENTLY ALLOCATED RD IF SET 
macro RD$W_SEQNUM = 6,0,16,0 %;         ! SEQUENCE NUMBER OF RD 
 
!*** MODULE $RGBDEF ***
! +
!  RGB - Range Block
! 
!  Range Block is a user defined structure passed by reference to the Lock
!  Manager $enq, $enqw and $deq system system services via the optional [RANGE]
!  argument. 
!  The Range Block specifies a relative start and length of a resource range 
!  to be locked, converted or unlocked.
! -
literal RGB$C_LENGTH = 16;              ! LENGTH OF FIXED PART
literal RGB$K_LENGTH = 16;              ! LENGTH OF FIXED PART
literal RGB$K_MAXRANGE = -1;            ! Maximum range of resource
literal RGB$S_RGBDEF = 16;
literal RGB$S_RGB = 16;
macro RGB$Q_START = 0,0,0,0 %;
literal RGB$S_START = 8;                !  relative start of range to lock
macro RGB$Q_LENGTH = 8,0,0,0 %;
literal RGB$S_LENGTH = 8;               !  length of range to lock
 
!*** MODULE $RSBDEF ***
! +
!  RSB - RESOURCE BLOCK
! 
!  RESOURCE BLOCKS REPRESENT RESOURCES FOR WHICH THERE ARE LOCKS OUTSTANDING.
!  EACH RESOURCE BLOCK MAY HAVE ONE OR MORE LOCK BLOCKS (LKB) QUEUED TO IT.
! -
literal RSB$M_DIRENTRY = %X'1';
literal RSB$M_VALINVLD = %X'2';
literal RSB$M_DIR_RQD = %X'4';
literal RSB$M_RM_PEND = %X'8';
literal RSB$M_RM_IP = %X'10';
literal RSB$M_RM_ACCEPT = %X'20';
literal RSB$M_RM_RBLD = %X'40';
literal RSB$M_RM_WAIT = %X'80';
literal RSB$M_RM_DEFLECT = %X'100';
literal RSB$M_DIR_IP = %X'200';
literal RSB$M_RBLD_IP = %X'400';
literal RSB$M_RBLD_RQD = %X'800';
literal RSB$M_RBLD_ACT = %X'1000';
literal RSB$M_CHK_BTR = %X'2000';
literal RSB$M_WTFULRNG = %X'4000';
literal RSB$M_WTSUBRNG = %X'8000';
literal RSB$M_BRL = %X'10000';
literal RSB$M_ENBSUBRNG = %X'20000';
literal RSB$M_INHSUBRNG = %X'40000';
literal RSB$M_2PC_IP = %X'80000';
literal RSB$M_CVTFULRNG = %X'100000';
literal RSB$M_CVTSUBRNG = %X'200000';
literal RSB$M_VALCUR = %X'400000';
literal RSB$M_INVPEND = %X'800000';
literal RSB$K_MAXLEN = 31;              ! MAXIMUM LENGTH OF RESOURCE NAME 
literal RSB$K_LENGTH = 169;             ! LENGTH OF FIXED PART OF RSB 
literal RSB$C_LENGTH = 169;             ! LENGTH OF FIXED PART OF RSB 
literal RSB$S_RSBDEF = 169;             !  Old size name - synonym
literal RSB$S_RSB = 169;
macro RSB$L_HSHCHN = 0,0,32,1 %;        ! HASH CHAIN 
macro RSB$L_HSHCHNBK = 4,0,32,1 %;      ! HASH CHAIN BACK POINTER 
macro RSB$W_SIZE = 8,0,16,0 %;          ! SIZE OF RSB 
macro RSB$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE 
macro RSB$B_DEPTH = 11,0,8,0 %;         ! DEPTH IN TREE 
macro RSB$B_GGMODE = 12,0,8,0 %;        ! GROUP GRANT MODE 
macro RSB$B_CGMODE = 13,0,8,0 %;        ! CONVERSION GRANT MODE 
macro RSB$L_STATUS = 16,0,32,0 %;       ! STATUS
macro RSB$V_DIRENTRY = 16,0,1,0 %;      !  ENTERED IN DIR. DURING FAILOVER
macro RSB$V_VALINVLD = 16,1,1,0 %;      !  VALUE BLOCK INVALID
macro RSB$V_DIR_RQD = 16,2,1,0 %;       !  DIRECTORY ENTRY REQUIRED
macro RSB$V_RM_PEND = 16,3,1,0 %;       !  RESOURCE REMASTER OP PENDING
macro RSB$V_RM_IP = 16,4,1,0 %;         !  RESOURCE BEING REMASTERED
macro RSB$V_RM_ACCEPT = 16,5,1,0 %;     !  NEW MASTER ACCEPTS
macro RSB$V_RM_RBLD = 16,6,1,0 %;       !  ALWAYS REBUILD TREE
macro RSB$V_RM_WAIT = 16,7,1,0 %;       !  BLOCK LOCAL ACTIVITY
macro RSB$V_RM_DEFLECT = 16,8,1,0 %;    !  DEFLECT REMOTE INTEREST
macro RSB$V_DIR_IP = 16,9,1,0 %;        !  DIRECTORY ENTRY BEING CREATED
macro RSB$V_RBLD_IP = 16,10,1,0 %;      !  REBUILD IN PROGRESS
macro RSB$V_RBLD_RQD = 16,11,1,0 %;     !  REBUILD REQUIRED FOR THIS TREE
macro RSB$V_RBLD_ACT = 16,12,1,0 %;     !  LOCK RBLD ACTIVE FOR TREE
macro RSB$V_CHK_BTR = 16,13,1,0 %;      !  CHECK FOR BETTER MASTER
macro RSB$V_WTFULRNG = 16,14,1,0 %;     !  FULL-RANGE REQs IN WAIT QUE
macro RSB$V_WTSUBRNG = 16,15,1,0 %;     !  SUB-RANGE REQs IN WAIT QUE
macro RSB$V_BRL = 16,16,1,0 %;          !  indicates byte range resource
macro RSB$V_ENBSUBRNG = 16,17,1,0 %;    !  sub-range locking enabled
macro RSB$V_INHSUBRNG = 16,18,1,0 %;    !  sub-range locking inhibited
macro RSB$V_2PC_IP = 16,19,1,0 %;       !  Two Phase CVT In Progress
macro RSB$V_CVTFULRNG = 16,20,1,0 %;    !  FULL-RANGE REQs IN CVT QUE
macro RSB$V_CVTSUBRNG = 16,21,1,0 %;    !  SUB-RANGE REQs IN CVT QUE
macro RSB$V_VALCUR = 16,22,1,0 %;       !  value block is current
macro RSB$V_INVPEND = 16,23,1,0 %;      !  do valblk invalidation chk
macro RSB$L_GRQFL = 20,0,32,1 %;        ! GRANTED QUEUE FORWARD LINK 
macro RSB$L_GRQBL = 24,0,32,1 %;        ! GRANTED QUEUE BACKWARD LINK 
macro RSB$L_CVTQFL = 28,0,32,1 %;       ! CONVERSION QUEUE FORWARD LINK 
macro RSB$L_CVTQBL = 32,0,32,1 %;       ! CONVERSION QUEUE BACKWARD LINK 
macro RSB$L_WTQFL = 36,0,32,1 %;        ! WAIT QUEUE FORWARD LINK 
macro RSB$L_WTQBL = 40,0,32,1 %;        ! WAIT QUEUE BACKWARD LINK 
macro RSB$Q_VALBLK = 48,0,0,0 %;
literal RSB$S_VALBLK = 8;               ! VALUE BLOCK 
macro RSB$L_CSID = 64,0,32,0 %;         ! SYSTEM ID OF MASTER SYS.
macro RSB$L_RRSFL = 68,0,32,1 %;        ! ROOT LIST FORWARD LINK 
macro RSB$L_RRSBL = 72,0,32,1 %;        ! ROOT LIST BACKWARD LINK 
macro RSB$L_SRSFL = 76,0,32,1 %;        ! TREE LIST FORWARD LINK 
macro RSB$L_SRSBL = 80,0,32,1 %;        ! TREE LIST BACKWARD LINK 
macro RSB$L_RM_CSID = 84,0,32,0 %;      ! PENDNG REMASTER CSID
macro RSB$L_RTRSB = 88,0,32,1 %;        ! POINTER TO ROOT RSB
macro RSB$L_CLURCB = 92,0,32,1 %;       ! REMASTER CONTROL BLOCK
macro RSB$W_ACTIVITY = 96,0,16,0 %;     ! RESOURCE ACTIVITY COUNTER
macro RSB$W_LCKCNT = 98,0,16,0 %;       ! COUNT OF LOCKS ON RESOURCE
macro RSB$L_VALSEQNUM = 100,0,32,0 %;   ! VALUE BLOCK SEQ. NUMBER
macro RSB$W_REFCNT = 104,0,16,0 %;      ! SUB RSB REFERENCE COUNT 
macro RSB$W_BLKASTCNT = 106,0,16,0 %;   ! BLOCKING AST COUNT 
macro RSB$W_HASHVAL = 108,0,16,0 %;     ! HASH VALUE
macro RSB$W_RQSEQNM = 110,0,16,0 %;     ! REQUEST SEQUENCE NUMBER
macro RSB$L_PARENT = 112,0,32,1 %;      ! ADDRESS OF PARENT RSB 
macro RSB$W_GROUP = 116,0,16,0 %;       ! GROUP NUMBER 
macro RSB$B_RMOD = 118,0,8,0 %;         ! ACCESS MODE OF RESOURCE 
macro RSB$B_RSNLEN = 119,0,8,0 %;       ! RESOURCE NAME LENGTH 
macro RSB$T_RESNAM = 120,0,0,0 %;
literal RSB$S_RESNAM = 32;              ! START OF RESOURCE NAME 
macro RSB$L_2PCQFL = 152,0,32,0 %;      ! Que of 2PC ops is progress
macro RSB$L_2PCQBL = 156,0,32,0 %;      ! 
macro RSB$W_NACT = 160,0,16,0 %;        ! NEW ACTIVITY
macro RSB$W_OACT = 162,0,16,0 %;        ! OLD (historical) ACTIVITY
macro RSB$W_NMACT = 164,0,16,0 %;       ! NEW MASTER'S ACTIVITY
macro RSB$B_LSTCSID_IDX = 166,0,8,0 %;  ! LAST CSID INDEX
macro RSB$B_SAME_CNT = 167,0,8,0 %;     ! SAME NODE COUNTER
macro RSB$B_FGMODE = 168,0,8,0 %;       ! FULL-RANGE GRANT MODE
 
!*** MODULE $RSNDEF ***
! +
!  RESOURCE NAME DEFINITIONS
! -
! 0 ORIGIN IN INCREMENTS OF 1 
literal RSN$_ASTWAIT = 1;               ! WAIT FOR AST EVENT, CHANNEL INTERLOCK 
literal RSN$_MAILBOX = 2;               ! MAILBOX SPACE 
literal RSN$_NPDYNMEM = 3;              ! NON-PAGED DYNAMIC MEMORY 
literal RSN$_PGFILE = 4;                ! PAGING FILE SPACE 
literal RSN$_PGDYNMEM = 5;              ! PAGED DYNAMIC MEMORY 
literal RSN$_BRKTHRU = 6;               ! TERMINAL BROADCAST 
literal RSN$_IACLOCK = 7;               ! IMAGE ACTIVATION INTERLOCK 
literal RSN$_JQUOTA = 8;                ! JOB POOLED QUOTA 
literal RSN$_LOCKID = 9;                ! LOCKIDS 
literal RSN$_SWPFILE = 10;              ! SWAPPING FILE SPACE 
literal RSN$_MPLEMPTY = 11;             ! MODIFIED PAGE LIST EMPTY 
literal RSN$_MPWBUSY = 12;              ! MODIFIED PAGE WRITER BUSY 
literal RSN$_SCS = 13;                  ! SYSTEM COMMUNICATION
literal RSN$_CLUSTRAN = 14;             ! CLUSTER STATE TRANSITION
literal RSN$_CPUCAP = 15;               ! CPU Capability
literal RSN$_CLUSRV = 16;               ! CLUSTER SERVER
literal RSN$_SNAPSHOT = 17;             ! 
literal RSN$_PSXFRK = 18;               ! POSIX FORK WAIT
literal RSN$_MAX = 19;                  ! MAXIMUM RESOURCE NUMBER 
 
!*** MODULE $RVTDEF ***
! +
!  RVT - RELATIVE VOLUME TABLE
! 
!  A RELATIVE VOLUME MAPPING TABLE IS REQUIRED FOR EVERY MULTIVOLUME
!  STRUCTURE THAT IS MOUNTED IN A SYSTEM.
! -
literal RVT$K_LENGTH = 84;              !  LENGTH OF STANDARD RVT 
literal RVT$C_LENGTH = 84;              !  LENGTH OF STANDARD RVT 
literal RVT$C_UCB_POINTER = 0;          !  ADDRESSES OF THE RESPECTIVE UCB'S 
literal RVT$C_PHYSICAL_VOLUME = 1;      !  Physical volume number
literal RVT$C_VOLUME_LOCK_ID = 2;       !  Volume Lock ID
literal RVT$C_VOLUME_IDENTIFIER = 3;    !  Volume Identifier
!  Number of overlay elements
literal RVT$C_RVTVCB = 4;               !  Number of elements (0 based)
literal RVT$C_MINSIZE = 18;             !  MINIMUM NUMBER OF ENTRIES TO ALLOCATE 
literal RVT$S_RVTDEF = 88;              !  Old size name - synonym    
literal RVT$S_RVT = 88;
macro RVT$L_STRUCLKID = 0,0,32,0 %;     !  LOCK ID OF VOLUME SET LOCK.
macro RVT$L_REFC = 4,0,32,0 %;          !  REFERENCE COUNT
macro RVT$W_SIZE = 8,0,16,0 %;          !  SIZE OF RVT IN BYTES 
macro RVT$B_TYPE = 10,0,8,0 %;          !  STRUCTURE TYPE OF RVT 
macro RVT$B_NVOLS = 11,0,8,0 %;         !  NUMBER OF VOLUMES IN SET 
macro RVT$T_STRUCNAME = 12,0,0,0 %;
literal RVT$S_STRUCNAME = 12;           !  STRUCTURE (VOLUME SET) NAME 
macro RVT$T_VLSLCKNAM = 24,0,0,0 %;
literal RVT$S_VLSLCKNAM = 12;           !  Volume set lock name.
macro RVT$L_BLOCKID = 36,0,32,0 %;      !  Blocking lock id.
macro RVT$B_ACB = 40,0,0,0 %;
literal RVT$S_ACB = 36;                 !  ACB for blocking ast.
macro RVT$L_TRANS = 76,0,32,0 %;        !  Transaction count for volume sets
macro RVT$L_ACTIVITY = 80,0,32,0 %;     !  ACTIVITY COUNT/FLAG
macro RVT$L_UCBLST = 84,0,32,0 %;       !  Addresses of the respective UCB'S 
macro RVT$A_RVTVCB = 84,0,32,0 %;       !  Start of RVT/VCB fields for Files-11 C/D
!  Files-11 C/D RVT/VCB datums
 
!*** MODULE S0PAGINGDEF ***
literal S0PAGING$M_EXEC = %X'1';
literal S0PAGING$M_RMS = %X'2';
literal S0PAGING$S_S0PAGINGDEF = 4;     !  Old size name - synonym
literal S0PAGING$S_S0PAGING = 4;
macro S0PAGING$V_EXEC = 0,0,1,0 %;      !  exec paging (most loadable pieces) 
macro S0PAGING$V_RMS = 0,1,1,0 %;       !  RMS paging
 
!*** MODULE $SBDEF ***
! +
!  SB - SCS SYSTEM BLOCK
! 
!  THE SB HAS INFORMATION ABOUT KNOWN SYSTEMS IN A CPU CLUSTER.
! -
literal SB$M_LOCAL = %X'1';
literal SB$M_LOCAL_DIRECTORY = %X'2';
literal SB$S_SB = 112;
macro SB$L_FLINK = 0,0,32,1 %;          ! FWD LINK TO NEXT SB 
macro SB$L_BLINK = 4,0,32,1 %;          ! BACK LINK TO PREVIOUS SB 
macro SB$W_SIZE = 8,0,16,0 %;           ! STRUCTURE SIZE IN BYTES 
macro SB$B_TYPE = 10,0,8,0 %;           ! SCS STRUCTURE TYPE 
macro SB$B_SUBTYP = 11,0,8,0 %;         ! SCS STRUCT SUBTYPE FOR SB 
macro SB$L_PBFL = 12,0,32,1 %;          ! LINK TO NEXT PATH BLOCK 
macro SB$L_PBBL = 16,0,32,1 %;          ! LINK TO PREVIOUS PATH BLOCK 
macro SB$L_PBCONNX = 20,0,32,1 %;       ! ADDR OF NEXT PB TO USE FOR 
!  A CONNECTION
macro SB$B_SYSTEMID = 28,0,0,0 %;
literal SB$S_SYSTEMID = 6;              ! SYSTEM ID 
macro SB$W_MAXDG = 36,0,16,0 %;         ! MAXIMUM DATAGRAM SIZE 
macro SB$W_MAXMSG = 38,0,16,0 %;        ! MAXIMUM MESSAGE SIZE 
macro SB$T_SWTYPE = 40,0,32,0 %;
literal SB$S_SWTYPE = 4;                ! SOFTWARE TYPE, 1-4 CHAR 
macro SB$T_SWVERS = 44,0,32,0 %;
literal SB$S_SWVERS = 4;                ! SOFTWARE VERSION, 1-4 CHAR 
macro SB$Q_SWINCARN = 48,0,0,0 %;
literal SB$S_SWINCARN = 8;              ! SOFTWARE INCARNATION # 
macro SB$T_HWTYPE = 56,0,32,0 %;
literal SB$S_HWTYPE = 4;                ! HW TYPE; 1-4 CHAR, BLANK FILL
macro SB$B_HWVERS = 60,0,0,0 %;
literal SB$S_HWVERS = 12;               ! HW VERSION #
macro SB$T_NODENAME = 72,0,0,0 %;
literal SB$S_NODENAME = 16;             ! SCS NODENAME, COUNTED ASCII STRING
macro SB$L_DDB = 88,0,32,1 %;           ! DDB LIST HEAD
macro SB$W_TIMEOUT = 92,0,16,1 %;       ! SCA PROCESS POLLER, WAITING TIME REMAINING
macro SB$B_ENBMSK = 94,0,16,0 %;
literal SB$S_ENBMSK = 2;                ! SCA PROCESS POLLER, PROCESS ENABLE MASK
macro SB$L_CSB = 96,0,32,1 %;           ! LINK TO NEWEST CLUSTER SYSTEM BLOCK
macro SB$L_PORT_MAP = 100,0,32,0 %;     !  (TYC 13-Feb-89) LOAD SHARING PORT BIT MAP
macro SB$L_STATUS = 104,0,32,0 %;       !  System block Status
macro SB$V_LOCAL = 104,0,1,0 %;         !  System is a Local port, (A BVP or PU port)
macro SB$V_LOCAL_DIRECTORY = 104,1,1,0 %; !  System is a local port and supports local directory lookups.
macro SB$PS_PROC_NAMES = 108,0,32,1 %;  !  Pointer to list of SYSAP process names supported by a local port.
literal SB$K_LENGTH = 112;              ! LENGTH OF SB 
literal SB$C_LENGTH = 112;              ! LENGTH OF SB 
literal SB$S_SBDEF = 112;               !  Old size name - synonym
 
!*** MODULE $SBNBDEF ***
! +
!  SBNB - SCA LOAD SHARING NAME BLOCK
! 
!  THIS DATA STRUCTURE DESCRIBES A PROCESS NAME KNOWN TO THE SCA
!  DYNAMIC LOAD SHARING CODE. 
! -
literal SBNB$K_LENGTH = 36;
literal SBNB$C_LENGTH = 36;
literal SBNB$S_SBNBDEF = 36;
literal SBNB$S_SBNB = 36;
macro SBNB$L_FLINK = 0,0,32,1 %;        ! FWD LINK 
macro SBNB$L_BLINK = 4,0,32,1 %;        ! BCK LINK 
macro SBNB$W_SIZE = 8,0,16,0 %;         ! STRUCTURE SIZE IN BYTES 
macro SBNB$B_TYPE = 10,0,8,0 %;         ! SCS STRUCTURE TYPE 
macro SBNB$B_SUBTYP = 11,0,8,0 %;       ! SCS STRUCTURE SUBTYPE FOR SBNB
macro SBNB$B_PROCNAM = 12,0,0,0 %;
literal SBNB$S_PROCNAM = 16;            ! ASCII STRING FOR PROCESS NAME 
macro SBNB$W_LOCAL_INDEX = 28,0,16,0 %; ! BIT ASSIGNED TO THIS PROCESS NAME
macro SBNB$L_DISCON_COUNT = 30,0,32,0 %; ! (TYC 13-Feb-89) # OF DISCONNECT 
!  DUE TO LOAD SHARING ACTIVITY
 
!*** MODULE $SBODEF ***
! +
!  SBO - SCS CONFIG_SYS OUTPUT ARRAY FORMAT
! 
!  THE OUTPUT ARRAY RETURNED FROM CALL TO SCS$CONFIG_SYS.  DATA IS MOSTLY COPIED FROM 
!  THE SYSTEM BLOCK (SB) BEING LOOKED UP.
! -
literal SBO$C_VC1 = 60;                 ! START OF 12 BYTE SPECIFIER OF
literal SBO$K_VC1 = 60;                 !  1ST VC (PATH BLK) TO SYSTEM
literal SBO$K_LENGTH = 80;              ! LENGTH OF SBO ARRAY
literal SBO$C_LENGTH = 80;              ! LENGTH OF SBO ARRAY
literal SBO$S_SBODEF = 80;              !  Old size name - synonym
literal SBO$S_SBO = 80;
macro SBO$B_SYSTEMID = 0,0,0,0 %;
literal SBO$S_SYSTEMID = 6;             ! SYSTEM ID
macro SBO$W_MAXDG = 8,0,16,0 %;         ! MAXIMUM DG SIZE
macro SBO$W_MAXMSG = 10,0,16,0 %;       ! MAXIMUM MSG SIZE
macro SBO$T_SWTYPE = 12,0,32,0 %;
literal SBO$S_SWTYPE = 4;               ! SW TYPE, 1-4 CHAR, BLNK FILL
macro SBO$T_SWVERS = 16,0,32,0 %;
literal SBO$S_SWVERS = 4;               ! SW VERSION, 1-4 CHAR, BLNK FILL
macro SBO$Q_SWINCARN = 20,0,0,0 %;
literal SBO$S_SWINCARN = 8;             ! SW INCARNATION #
macro SBO$T_HWTYPE = 28,0,32,0 %;
literal SBO$S_HWTYPE = 4;               ! HW TYPE, 1-4 CHAR BLNK FILL
macro SBO$B_HWVERS = 32,0,0,0 %;
literal SBO$S_HWVERS = 12;              ! HW VERSION, 1-4 CHAR BLNK FILL
macro SBO$T_NODENAME = 44,0,0,0 %;
literal SBO$S_NODENAME = 16;            ! NODE NAME, COUNTED ASCII STRING
macro SBO$B_RSTATION1 = 60,0,0,0 %;
literal SBO$S_RSTATION1 = 6;            ! REMOTE STATION OF 1ST VC
macro SBO$T_LPORT1 = 68,0,32,0 %;
literal SBO$S_LPORT1 = 4;               ! LOCAL PORT NAME OF 1ST VC
macro SBO$B_NXT_SYSID = 72,0,0,0 %;
literal SBO$S_NXT_SYSID = 6;            ! ID OF NEXT SYSTEM IN CONFIGURATION
 
!*** MODULE $SCDRPDEF ***
! +
!  SCDRP - SCSI Class Driver I/O Request Packet
! 
!  This structure contains SCSI class driver request packet, which is used
!  to pass parameters between the SCSI class and port drivers. In addition,
!  the drivers use it to save information temporarily during the execution
!  of a SCSI command.
! 
!  Note: Unlike the class driver request packet (CDRP), this structure does
!  NOT contain an IRP accessed at negative offsets from the base of the packet.
!  Instead, several IRP fields used in the SCDRP are located at positive
!  offsets from the base.
!  
!  ***NOTE1:**** New SCDRP fields must be entered at the end of the data structure.
! 
!  ***NOTE:**** If an INCOMPATIBLE CHANGE is made to this structure bump
! 		the version number of this structure.
! -
literal SCDRP$C_VERSION = 5;            !  Compatible version number.
literal SCDRP$K_SCDRPBASE = 0;
literal SCDRP$C_SCDRPBASE = 0;
literal SCDRP$M_FLAG_S0BUF = %X'1';
literal SCDRP$M_FLAG_BUFFER_MAPPED = %X'2';
literal SCDRP$M_FLAG_DISK_SPUN_UP = %X'4';
literal SCDRP$M_FLAG_LOCK = %X'8';
literal SCDRP$M_FLAG_QUEUED_IO = %X'10';
literal SCDRP$M_FLAG_ACA_IO = %X'20';
literal SCDRP$M_FLAG_CLEAR_ACA_MSG = %X'40';
literal SCDRP$M_FLAG_ASENSE_VALID = %X'80';
literal SCDRP$M_FLAG_ON_PORT_QUEUE = %X'100';
literal SCDRP$M_FLAG_ON_DEV_QUEUE = %X'200';
literal SCDRP$M_FLAG_ABORT_THIS_IO = %X'400';
literal SCDRP$M_FLAG_QUEUE_FULL_INIT = %X'800';
literal SCDRP$M_FLAG_QUEUE_FULL_SEEN = %X'1000';
literal SCDRP$M_FLAG_WAIT_FOR_IO = %X'2000';
literal SCDRP$M_FLAG_INTERNAL_REQUEST = %X'4000';
literal SCDRP$M_FLAG_SEND_MESSAGE_ONLY = %X'8000';
literal SCDRP$M_FLAG_SEND_DEVICE_RESET = %X'10000';
literal SCDRP$M_FLAG_MODE_SENSE = %X'60000';
literal SCDRP$M_FLAG_CL_PRIVATE_BUFF = %X'80000';
literal SCDRP$M_FLAG_TENBYTE = %X'100000';
literal SCDRP$M_FLAG_BUS_RESET = %X'200000';
literal SCDRP$M_FLAG_ON_SYS_QUEUE = %X'400000';
literal SCDRP$M_DSF_NOWAIT = %X'1';
literal SCDRP$M_DSF_RELEASE_SPDT_LOCK = %X'2';
literal SCDRP$M_DSF_DEVICE_WAS_RESET = %X'4';
literal SCDRP$M_DSF_REQUEST_ABORTED = %X'8';
literal SCDRP$M_DSF_REQUEST_FLUSHED = %X'10';
literal SCDRP$M_DSF_STALL_WFIKPCH_DIPL = %X'20';
literal SCDRP$M_MSGO_IDENTIFY = %X'1';
literal SCDRP$M_MSGO_QUEUE_TAG = %X'2';
literal SCDRP$M_MSGO_SYNC_OUT = %X'4';
literal SCDRP$M_MSGO_BUS_DEVICE_RESET = %X'8';
literal SCDRP$M_MSGO_MSG_PARITY_ERROR = %X'10';
literal SCDRP$M_MSGO_ID_ERROR = %X'20';
literal SCDRP$M_MSGO_ABORT = %X'40';
literal SCDRP$M_MSGO_NOP = %X'80';
literal SCDRP$M_MSGO_MESSAGE_REJECT = %X'100';
literal SCDRP$M_MSGO_CLEAR_ACA = %X'200';
literal SCDRP$M_MSGO_LAST_BIT = %X'400';
literal SCDRP$M_MSGI_SYNC_IN = %X'1';
literal SCDRP$K_QCHAR_UNORDERED = 0;    ! O   Device may reorder in queue
literal SCDRP$K_QCHAR_ORDERED = 1;      ! O   Queue barrier for device
literal SCDRP$K_QCHAR_HEAD = 2;         ! O   Next I/O in queue to be processed
literal SCDRP$K_QCHAR_NOT_QUEUED = 3;   ! O   Sent untagged as in SCSI-1
literal SCDRP$K_QCHAR_ACA = 4;          ! O   Automatic Contigent Allegiance - error recovery after CHECK_CONDITION
literal SCDRP$M_EVENT_PARERR = %X'1';
literal SCDRP$M_EVENT_BSYERR = %X'2';
literal SCDRP$M_EVENT_MISPHS = %X'4';
literal SCDRP$M_EVENT_BADPHS = %X'8';
literal SCDRP$M_EVENT_RST = %X'10';
literal SCDRP$M_EVENT_CTLERR = %X'20';
literal SCDRP$M_EVENT_BUSERR = %X'40';
literal SCDRP$M_EVENT_ABORT = %X'80';
literal SCDRP$M_EVENT_MSGERR = %X'100';
literal SCDRP$M_CNX_ABORT_PND = %X'1';
literal SCDRP$M_CNX_ABORT_CMPL = %X'2';
literal SCDRP$M_CNX_ABORT_INPROG = %X'4';
literal SCDRP$M_CNX_ABORT_RESEL = %X'8';
literal SCDRP$M_CNX_PND_RESEL = %X'10';
literal SCDRP$M_CNX_DSCN = %X'20';
literal SCDRP$M_CNX_TMODSCN = %X'40';
literal SCDRP$M_PHASE_DATAOUT = %X'1';
literal SCDRP$M_PHASE_DATAIN = %X'2';
literal SCDRP$M_PHASE_CMD = %X'4';
literal SCDRP$M_PHASE_STS = %X'8';
literal SCDRP$M_PHASE_INV1 = %X'10';
literal SCDRP$M_PHASE_INV2 = %X'20';
literal SCDRP$M_PHASE_MSGOUT = %X'40';
literal SCDRP$M_PHASE_MSGIN = %X'80';
literal SCDRP$M_PHASE_ARB = %X'100';
literal SCDRP$M_PHASE_SEL = %X'200';
literal SCDRP$M_PHASE_RESEL = %X'400';
literal SCDRP$M_PHASE_DISCON = %X'800';
literal SCDRP$M_PHASE_CMD_CMPL = %X'1000';
literal SCDRP$M_PHASE_TMODISCON = %X'2000';
literal SCDRP$M_PHASE_FREE = %X'4000';
literal SCDRP$K_SCSI_LEN = 440;
literal SCDRP$C_SCSI_LEN = 440;
literal SCDRP$K_LENGTH = 488;
literal SCDRP$C_LENGTH = 488;
literal SCDRP$S_SCDRP = 488;
macro SCDRP$L_FQFL = 0,0,32,1 %;        ! O Fork Queue FLINK
macro SCDRP$L_FQBL = 4,0,32,1 %;        ! O Fork Queue Blink
macro SCDRP$W_SCDRPSIZE = 8,0,16,0 %;   ! I Size field for positive section only
macro SCDRP$B_CD_TYPE = 10,0,8,0 %;     ! I Type, always of interest
macro SCDRP$B_FLCK = 11,0,8,0 %;        ! O Fork lock index
macro SCDRP$L_FPC = 12,0,32,1 %;        ! O Fork PC
macro SCDRP$Q_FR3 = 16,0,0,1 %;
literal SCDRP$S_FR3 = 8;                ! O Fork R3
macro SCDRP$Q_FR4 = 24,0,0,1 %;
literal SCDRP$S_FR4 = 8;                ! O Fork R4
!  Thie following field must follow immediately after the fork block for use
!  by MKDRIVER.
macro SCDRP$L_PORT_UCB = 32,0,32,1 %;   ! I Saved UCB address for REQCHAN
!  Fields that came from IRP portion of the old SCDRP.
macro SCDRP$L_UCB = 36,0,32,1 %;        ! I Address of device (class driver) UCB
macro SCDRP$L_FUNC = 40,0,32,0 %;       ! O I/O function code and modifiers
macro SCDRP$L_BOFF = 44,0,32,0 %;       ! O Byte offset in first page
macro SCDRP$IS_STS = 48,0,32,0 %;       ! O Request status
macro SCDRP$L_SVAPTE = 52,0,32,1 %;     ! O System Virtual Address of first PTE
macro SCDRP$L_BCNT = 56,0,32,0 %;       ! O Byte count of transfer
macro SCDRP$L_MEDIA = 60,0,32,1 %;      ! O Media address
macro SCDRP$L_ABCNT = 64,0,32,0 %;      ! O Accumulated bytes transfered
macro SCDRP$L_SAVD_RTN = 68,0,32,1 %;   ! O Saved return address from level 1 JSB
macro SCDRP$L_MSG_BUF = 72,0,32,1 %;    ! O Address of allocated MSCP buffer
macro SCDRP$L_RSPID = 76,0,32,0 %;      ! O Allocated Request ID
macro SCDRP$L_CDT = 80,0,32,1 %;        ! O Address of Connection Descriptor Table
macro SCDRP$L_RWCPTR = 84,0,32,1 %;     ! O RWAITCNT pointer
! 	SCDRP extensions
! 	SCSI port/class driver extension
macro SCDRP$L_IRP = 88,0,32,1 %;        ! I Address of IRP
macro SCDRP$PS_KPB = 92,0,32,1 %;       ! I Address of KPB
macro SCDRP$PS_PREV_SCDRP = 96,0,32,1 %; ! I Address of previous SCDRP
macro SCDRP$PS_SPDT = 100,0,32,1 %;     ! I Address of SPDT
macro SCDRP$L_SVA_USER = 104,0,32,1 %;  ! O S0 address of double mapped user buffer
macro SCDRP$L_CMD_BUF = 108,0,32,1 %;   ! O Address of SCSI command buffer
macro SCDRP$L_CMD_BUF_LEN = 112,0,32,0 %; ! O Length of SCSI command buffer
macro SCDRP$L_CMD_PTR = 116,0,32,0 %;   ! O Address of SCSI command
macro SCDRP$L_STS_PTR = 120,0,32,1 %;   ! O Address of SCSI status byte
macro SCDRP$L_SCSI_FLAGS = 124,0,32,0 %; ! F SCSI flags
macro SCDRP$V_FLAG_S0BUF = 124,0,1,0 %; ! F   Buffer allocated by class driver from S0 space
macro SCDRP$V_FLAG_BUFFER_MAPPED = 124,1,1,0 %; ! F   Buffer (S0 or user) has been mapped
macro SCDRP$V_FLAG_DISK_SPUN_UP = 124,2,1,0 %; ! F   Start unit has been issued
macro SCDRP$V_FLAG_LOCK = 124,3,1,0 %;  ! F   Fork block in use flag
macro SCDRP$V_FLAG_QUEUED_IO = 124,4,1,0 %; ! F   Optimize code for queued I/O.
macro SCDRP$V_FLAG_ACA_IO = 124,5,1,0 %; ! F   ACA command.
macro SCDRP$V_FLAG_CLEAR_ACA_MSG = 124,6,1,0 %; ! F   Send clear ACA message and terminate ACA processing when done.
macro SCDRP$V_FLAG_ASENSE_VALID = 124,7,1,0 %; ! F   Set to indicate valid data is in the sense buffer.
macro SCDRP$V_FLAG_ON_PORT_QUEUE = 124,8,1,0 %; ! F   Set while the SCDRP is queued to the PORT_QUEUE.
macro SCDRP$V_FLAG_ON_DEV_QUEUE = 124,9,1,0 %; ! F   Set while the SCDRP is queued to the IN_DEVICE_QUEUE.
macro SCDRP$V_FLAG_ABORT_THIS_IO = 124,10,1,0 %; ! F   Set to indicate that this I/O is actively being aborted.
macro SCDRP$V_FLAG_QUEUE_FULL_INIT = 124,11,1,0 %; ! F   Queue full processing should be initialized.
macro SCDRP$V_FLAG_QUEUE_FULL_SEEN = 124,12,1,0 %; ! F   Queue full message was seen.
macro SCDRP$V_FLAG_WAIT_FOR_IO = 124,13,1,0 %; ! F   Must wait for I/O completion.
macro SCDRP$V_FLAG_INTERNAL_REQUEST = 124,14,1,0 %; ! F   Internal (port generated) request, skip ACA processing.
macro SCDRP$V_FLAG_SEND_MESSAGE_ONLY = 124,15,1,0 %; ! F   Only send the message byte, there is no CDB to send.
macro SCDRP$V_FLAG_SEND_DEVICE_RESET = 124,16,1,0 %; ! F   Send a device reset message.
macro SCDRP$V_FLAG_MODE_SENSE = 124,17,2,0 %;
literal SCDRP$S_FLAG_MODE_SENSE = 2;    ! F   MODE_SENSE (private flags)
macro SCDRP$V_FLAG_CL_PRIVATE_BUFF = 124,19,1,0 %; ! F   Class Driver Private Buffer
macro SCDRP$V_FLAG_TENBYTE = 124,20,1,0 %; ! F   10-byte mode sense commands supported
macro SCDRP$V_FLAG_BUS_RESET = 124,21,1,0 %; ! F   SCDRP was on device queue during a bus reset
macro SCDRP$V_FLAG_ON_SYS_QUEUE = 124,22,1,0 %; ! F   Set while the SCDRP is on a system queue (fork,timer,...)
macro SCDRP$IS_DIPL_SCSI_FLAGS = 128,0,32,0 %; ! S SCSI flags modified at DIPL.
macro SCDRP$V_DSF_NOWAIT = 128,0,1,0 %; ! S   No wait is necessary in PK$WAIT_FOR_IO_COMPLETION.
macro SCDRP$V_DSF_RELEASE_SPDT_LOCK = 128,1,1,0 %; ! S   Device lock must be released in stall routine.
macro SCDRP$V_DSF_DEVICE_WAS_RESET = 128,2,1,0 %; ! S   Device was reset while request was active.
macro SCDRP$V_DSF_REQUEST_ABORTED = 128,3,1,0 %; ! S   Request aborted while active.
macro SCDRP$V_DSF_REQUEST_FLUSHED = 128,4,1,0 %; ! S   Request was flushed while active.
macro SCDRP$V_DSF_STALL_WFIKPCH_DIPL = 128,5,1,0 %; ! S   Request stalled, use KP_STALL_WFIKPCH_DIPL
macro SCDRP$L_DATACHECK = 132,0,32,1 %; ! O Address of buffer for datacheck operations
macro SCDRP$L_CL_RETRY = 136,0,32,0 %;  ! O Retry count
macro SCDRP$L_DMA_TIMEOUT = 140,0,32,0 %; ! O Time in seconds for a DMA timeout.
macro SCDRP$L_DISCON_TIMEOUT = 144,0,32,0 %; ! O Time in seconds for a disconnect to timeout.
macro SCDRP$L_ADDNL_INFO = 148,0,32,0 %; ! O Additional extended sense info
macro SCDRP$B_SENSE_KEY = 152,0,8,0 %;  ! O Saved extended sense key
! 	SCSI PORT driver extension
macro SCDRP$L_PAD_BCNT = 156,0,32,0 %;  ! O Number of bytes to pad user buffer with
macro SCDRP$L_SVA_DMA = 160,0,32,1 %;   ! O S0 address of chunk of 128KB DMA buffer
macro SCDRP$IS_CMD_SLOT = 164,0,32,1 %; ! O Command slot information
macro SCDRP$L_SVA_SPTE = 168,0,32,1 %;  ! O SVA of SPTE mapping user buffer.
macro SCDRP$PS_PORT_DMA_VA = 172,0,32,1 %; ! O VA of buffer for PORT
macro SCDRP$L_PORT_SVAPTE = 176,0,32,1 %; ! O SVAPTE for *PORT* usage
macro SCDRP$L_PORT_BOFF = 180,0,32,0 %; ! O BOFF for *PORT* usage
macro SCDRP$PS_MODE_ARGS = 184,0,32,1 %; ! O Pointer to SCSI MODE_SENSE.C arguments
macro SCDRP$L_SCSIMSGO_PTR = 188,0,32,1 %; ! O SCSI OUTPUT MSG PTR, required for the SII PORT
macro SCDRP$L_SCSIMSGI_PTR = 192,0,32,1 %; ! O SCSI INPUT MSG PTR, required for the SII PORT
macro SCDRP$B_SCSIMSGO_BUF = 196,0,0,1 %;
literal SCDRP$S_SCSIMSGO_BUF = 8;       ! O SCSI OUTPUT MSG buffer of port.
macro SCDRP$B_SCSIMSGI_BUF = 204,0,0,1 %;
literal SCDRP$S_SCSIMSGI_BUF = 8;       ! O SCSI INPUT MSG buffer of port.
macro SCDRP$L_MSGO_PENDING = 212,0,32,0 %; ! O Bit set if corresponding message is to be sent.
macro SCDRP$V_MSGO_IDENTIFY = 212,0,1,0 %; ! O
macro SCDRP$V_MSGO_QUEUE_TAG = 212,1,1,0 %; ! O
macro SCDRP$V_MSGO_SYNC_OUT = 212,2,1,0 %; ! O
macro SCDRP$V_MSGO_BUS_DEVICE_RESET = 212,3,1,0 %; ! O
macro SCDRP$V_MSGO_MSG_PARITY_ERROR = 212,4,1,0 %; ! O
macro SCDRP$V_MSGO_ID_ERROR = 212,5,1,0 %; ! O
macro SCDRP$V_MSGO_ABORT = 212,6,1,0 %; ! O
macro SCDRP$V_MSGO_NOP = 212,7,1,0 %;   ! O
macro SCDRP$V_MSGO_MESSAGE_REJECT = 212,8,1,0 %; ! O
macro SCDRP$V_MSGO_CLEAR_ACA = 212,9,1,0 %; ! O
macro SCDRP$V_MSGO_LAST_BIT = 212,10,1,0 %; ! O This must be last bit in this structure.
macro SCDRP$L_MSGI_PENDING = 216,0,32,0 %; ! O Bit set if corresponding message is expected.
macro SCDRP$V_MSGI_SYNC_IN = 216,0,1,0 %; ! O
macro SCDRP$B_LAST_MSGO = 220,0,8,0 %;  ! O Last message sent
macro SCDRP$L_DATA_PTR = 224,0,32,1 %;  ! O Current data pointer address.
macro SCDRP$L_TRANS_CNT = 228,0,32,0 %; ! O Count of the # of bytes of users data transfered
macro SCDRP$L_SAVE_DATA_CNT = 232,0,32,0 %; ! O Running 2's complement count of bytes to be transfered
macro SCDRP$L_SAVE_DATA_PTR = 236,0,32,0 %; ! O Running data pointer.
macro SCDRP$L_SDP_DATA_CNT = 240,0,32,0 %; ! O Storage for SDP
macro SCDRP$L_SDP_DATA_PTR = 244,0,32,1 %; ! O Storage for SDP
macro SCDRP$L_DUETIME = 248,0,32,0 %;   ! O Timeout time for disconnected IO.
macro SCDRP$IS_CMD_BCNT = 252,0,32,0 %; ! O temporary storage for cmd bytecnt
macro SCDRP$IS_BUSY_RETRY_CNT = 256,0,32,0 %; ! O Number retries left, for bus busy.
macro SCDRP$IS_ARB_RETRY_CNT = 260,0,32,0 %; ! O Number of retries left, for arbitration failures.
macro SCDRP$IS_SEL_RETRY_CNT = 264,0,32,0 %; ! O Number of retries left, for selection failures.
macro SCDRP$IS_CMD_RETRY_CNT = 268,0,32,0 %; ! O Number of times the port will retry a command.
macro SCDRP$IS_SEL_TQE_RETRY_CNT = 272,0,32,0 %; ! O Number of TQE retries left, for selection failures.
macro SCDRP$IS_DMA_LONG = 276,0,32,0 %; ! O DMA buffer for 1 byte transfers.
macro SCDRP$Q_TIME_STAMP = 280,0,0,1 %;
literal SCDRP$S_TIME_STAMP = 8;         ! O Time stamp for queue full processing.
macro SCDRP$IS_QUEUE_TAG = 288,0,32,0 %; ! O Tag value allocated by port driver.	 Not used by intelligent ports
macro SCDRP$IS_QUEUE_CHAR = 292,0,32,0 %; ! O Queue characteristics for this I/O operation.
macro SCDRP$PS_PQFL = 296,0,32,1 %;     ! O Port and in-device queue linkage, forward link.
macro SCDRP$PS_PQBL = 300,0,32,1 %;     ! O Port and in-device queue linkage, backward link.
macro SCDRP$PS_SENSE_BUFFER = 304,0,32,1 %; ! O Pointer to a buffer to receive the sense data for a CHECK_CONIDTION
macro SCDRP$IS_SENSE_BUFFER_LEN = 308,0,32,0 %; ! O Length of the sense data buffer, length of valid sense data in buffer.
macro SCDRP$IS_EVENTS_SEEN = 312,0,32,0 %; ! O Mask of events seen.
macro SCDRP$V_EVENT_PARERR = 312,0,1,0 %; ! O   Parity error occured.
macro SCDRP$V_EVENT_BSYERR = 312,1,1,0 %; ! O   Lost busy during command.
macro SCDRP$V_EVENT_MISPHS = 312,2,1,0 %; ! O   Missing bus phase detected.
macro SCDRP$V_EVENT_BADPHS = 312,3,1,0 %; ! O   A bad phase transition occured.
macro SCDRP$V_EVENT_RST = 312,4,1,0 %;  ! O   The bus has been reset during this command.
macro SCDRP$V_EVENT_CTLERR = 312,5,1,0 %; ! O   A SCSI controller error has been detected.
macro SCDRP$V_EVENT_BUSERR = 312,6,1,0 %; ! O   A SCSI BUS ERROR HAS BEEN DETECTED
macro SCDRP$V_EVENT_ABORT = 312,7,1,0 %; ! O   This io has been aborted.
macro SCDRP$V_EVENT_MSGERR = 312,8,1,0 %; ! O   An error was detected during ???
macro SCDRP$IS_CNX_STS = 316,0,32,0 %;  ! O Per I/O connection status.
macro SCDRP$V_CNX_ABORT_PND = 316,0,1,0 %; ! O   Abort pending on connection.
macro SCDRP$V_CNX_ABORT_CMPL = 316,1,1,0 %; ! O   Abort completed on connection.
macro SCDRP$V_CNX_ABORT_INPROG = 316,2,1,0 %; ! O   Abort is in progress.
macro SCDRP$V_CNX_ABORT_RESEL = 316,3,1,0 %; ! O   Port has been reselected while abort was in progress.
macro SCDRP$V_CNX_PND_RESEL = 316,4,1,0 %; ! O   Reselection interrupt pending.
macro SCDRP$V_CNX_DSCN = 316,5,1,0 %;   ! O   Connection is disconnected.
macro SCDRP$V_CNX_TMODSCN = 316,6,1,0 %; ! O   Connection timed out.
macro SCDRP$IS_SEQUENCE = 320,0,32,0 %; ! O I/O sequence ID assigned by the port driver for error recovery.
macro SCDRP$PS_CLASS_KPB = 324,0,32,1 %; ! O Field used by the queue manager to save KBP address.
!   Bus phases for phase processing.
macro SCDRP$IS_BUS_PHASE = 328,0,32,0 %; ! O Current SCSI bus phase.
macro SCDRP$V_PHASE_DATAOUT = 328,0,1,0 %; ! O   DATAIN Phase.
macro SCDRP$V_PHASE_DATAIN = 328,1,1,0 %; ! O   DATAIN Phase.
macro SCDRP$V_PHASE_CMD = 328,2,1,0 %;  ! O   Command Phase.
macro SCDRP$V_PHASE_STS = 328,3,1,0 %;  ! O   Status Phase.
macro SCDRP$V_PHASE_INV1 = 328,4,1,0 %; ! O   Invalid Phase 1.
macro SCDRP$V_PHASE_INV2 = 328,5,1,0 %; ! O   Invalid Phase 1.
macro SCDRP$V_PHASE_MSGOUT = 328,6,1,0 %; ! O   MESSAGEOUT Phase.
macro SCDRP$V_PHASE_MSGIN = 328,7,1,0 %; ! O   MESSAGEIN Phase.
macro SCDRP$V_PHASE_ARB = 328,8,1,0 %;  ! O   Arbitration Phase.
macro SCDRP$V_PHASE_SEL = 328,9,1,0 %;  ! O   Selection Phase.
macro SCDRP$V_PHASE_RESEL = 328,10,1,0 %; ! O   Reselection Phase.
macro SCDRP$V_PHASE_DISCON = 328,11,1,0 %; ! O   Disconnect seen.
macro SCDRP$V_PHASE_CMD_CMPL = 328,12,1,0 %; ! O   Command complete received.
macro SCDRP$V_PHASE_TMODISCON = 328,13,1,0 %; ! O   Disconnect operation timed out.
macro SCDRP$V_PHASE_FREE = 328,14,1,0 %; ! O   The bus went free.
macro SCDRP$IS_OLD_PHASES = 332,0,32,0 %; ! O Used to track SCSI bus phases.
macro SCDRP$IS_REQUEST_STATUS = 336,0,32,0 %; ! O Used to record the SCSI request status.
!  Embeded CRCTX (Counted Resource ConTeXt block)
!  Used in allocating/deallocating mapping resources
macro SCDRP$R_CRCTX_BASE = 344,0,0,0 %;
literal SCDRP$S_CRCTX_BASE = 96;
macro SCDRP$IS_ITEM_CNT = 400,0,32,1 %; ! O Number of mapping resource units allocated
macro SCDRP$IS_ITEM_NUM = 404,0,32,1 %; ! O Base mapping resource unit index allocated
!   Reserve some space for future expansion.
macro SCDRP$L_RSVD_LONG = 440,0,0,1 %;
literal SCDRP$S_RSVD_LONG = 44;         ! O Reserved space.
!   Define the structure length.
 
!*** MODULE $SCDTDEF ***
! +
!  SCDT - SCSI Connection Descriptor Table
! 
!  One SCDT is used per SCSI connection.  A connection is a logical link
!  between a class driver UCB and a device on the SCSI bus.  The SCDT
!  contains the entire context of a connection between a class driver
!  (SYSAP) and a device on the SCSI bus.
! 
!  SCDT's are created by port drivers when class drivers call port driver's
!  connect entry point.   The class driver has no access to this data structure.
!  The SCDT is used exclusively by the port driver.
! 
!  ***NOTE1:**** New SCDT fields must be entered at the end of the data structure.
! 
!  ***NOTE2:**** If an INCOMPATIBLE CHANGE is made to this structure bump
! 		 the version number of this structure.
! -
literal SCDT$C_VERSION = 6;             !  Compatible Version Number.
literal SCDT$C_STATE_CLOSED = 0;        ! O Closed
literal SCDT$C_STATE_OPEN = 1;          ! O Open
literal SCDT$C_STATE_FAIL = 2;          ! O Connect Failed
literal SCDT$M_CAP_SCSI_2 = %X'1';
literal SCDT$M_CAP_SCSI_3 = %X'2';
literal SCDT$M_CAP_CMDQ = %X'4';
literal SCDT$M_CAP_FREEZEQ = %X'8';
literal SCDT$M_CAP_FLUSHQ = %X'10';
literal SCDT$M_CAP_CLASS_DRIVER_ACA = %X'20';
literal SCDT$S_FBLOCK = 32;             !   Old FBLOCK size name
! 
literal SCDT$M_CFLG_ENA_DISCON = %X'1';
literal SCDT$M_CFLG_DIS_RETRY = %X'2';
literal SCDT$M_CFLG_TARGET_MODE = %X'4';
literal SCDT$M_ISTS_SDTR_SENT = %X'1';
literal SCDT$M_ISTS_DID_RESET_CALLBACK = %X'2';
literal SCDT$M_QF_QUEUED_ACA = %X'1';
literal SCDT$M_QF_QUEUE_TIMER_RUNNING = %X'2';
literal SCDT$M_QF_NO_DEV_IO_CREDITS = %X'4';
literal SCDT$M_DQF_ACA_ACTIVE = %X'1';
literal SCDT$M_DQF_FLUSHING_QUEUE = %X'2';
literal SCDT$M_DQF_QUEUE_FULL = %X'4';
literal SCDT$M_DQF_QUEUE_FULL_INIT = %X'8';
literal SCDT$M_DQF_QUEUE_WAIT = %X'10';
literal SCDT$M_DQF_CLASS_DRVR_FREEZE_Q = %X'20';
literal SCDT$M_DQF_QUEUE_FLUSH_ACTIVE = %X'40';
literal SCDT$K_MAX_QUEUE_DEPTH = 160;   !   Absolute maximum queue depth allowed.
literal SCDT$K_MAX_TAG = 256;           !   Number of tags in bit map.
literal SCDT$C_LENGTH = 352;            !  Length of SCDT
literal SCDT$S_SCDTDEF = 352;           !  Old size name, synonym for SCDT$S_SCDT
literal SCDT$S_SCDT = 352;
macro SCDT$W_SCDT_TYPE = 0,0,16,0 %;    ! O Type of SCDT
macro SCDT$W_STATE = 2,0,16,0 %;        ! O Connection State
macro SCDT$IS_CAPABILITY = 4,0,32,0 %;  !  Connection Capability Mask
macro SCDT$V_CAP_SCSI_2 = 4,0,1,0 %;    !    Device reports SCSI-2 compliance.
macro SCDT$V_CAP_SCSI_3 = 4,1,1,0 %;    !    Device reports SCSI-3 compliance.
macro SCDT$V_CAP_CMDQ = 4,2,1,0 %;      !    Device supports command queuing.
macro SCDT$V_CAP_FREEZEQ = 4,3,1,0 %;   !    Class driver requests freeze_queue_on_error mode.
macro SCDT$V_CAP_FLUSHQ = 4,4,1,0 %;    !    Class driver requests flush_queue_on_error mode.
macro SCDT$V_CAP_CLASS_DRIVER_ACA = 4,5,1,0 %; !    Class driver requests control of ACA operations.
macro SCDT$W_SIZE = 8,0,16,0 %;         ! I Structure size in bytes
macro SCDT$B_TYPE = 10,0,8,0 %;         ! I SCSI structure type
macro SCDT$B_SUBTYP = 11,0,8,0 %;       ! I SCSI structure subtype for SCDT
! 
! 		Define the fork block.
! 
macro SCDT$R_FKB_OVERLAY = 16,0,0,0 %;
macro SCDT$R_FKB = 16,0,0,0 %;
literal SCDT$S_FKB = 32;                ! O Embedded quadword aligned fork block
macro SCDT$B_FLCK = 16,0,8,1 %;         ! O For backward compatability with old Bliss/Macro code
! 		Define the structure references.
! 
macro SCDT$PS_SPDT = 48,0,32,1 %;       ! I Address of associated PORT descriptor table
macro SCDT$PS_STDT = 52,0,32,1 %;       ! I Pointer to the STDT.
macro SCDT$PS_HASH_FLINK = 56,0,32,1 %; ! F Forward link on SCDT hash list.
macro SCDT$PS_SCDRP_MAP = 60,0,32,1 %;  ! I List of SCDRPs indexed by tag value for reselection.
! 
! 		Define the class driver callbacks.
! 
macro SCDT$L_SEL_CALLBACK = 64,0,32,1 %; ! I Address of Class driver callback.
macro SCDT$L_SEL_CONTEXT = 68,0,32,0 %; ! I Context for Class driver callback.
macro SCDT$PS_PORT_STATE_CALLBACK = 72,0,32,1 %; ! I Class driver call back for PORT_STATE specified with SPI$CONNECT.
macro SCDT$L_PORT_STATE_CONTEXT = 76,0,32,0 %; ! I Context for Port State callback.
! 
! 		ITL specific information.
! 
macro SCDT$L_SCSI_LUN = 80,0,32,0 %;    ! I SCSI device LUN
macro SCDT$IQ_IN_NEX = 84,0,0,1 %;
literal SCDT$S_IN_NEX = 8;              ! I ITL Nexus Descriptor Table Entry contents
macro SCDT$L_DMA_TIMEOUT = 92,0,32,0 %; ! I Time in seconds for a DMA timeout.
macro SCDT$L_DISCON_TIMEOUT = 96,0,32,0 %; ! I Time in seconds for a disconnect to timeout.
macro SCDT$IS_BUSY_RETRY_CNT = 100,0,32,0 %; ! I Number retries left, for bus busy.
macro SCDT$IS_ARB_RETRY_CNT = 104,0,32,0 %; ! I Number of retries left, for arbitration failures.
macro SCDT$IS_SEL_RETRY_CNT = 108,0,32,0 %; ! I Number of retries left, for selection failures.
macro SCDT$IS_CMD_RETRY_CNT = 112,0,32,0 %; ! I Number of times the port will retry a command.
! 
! 		Set Connection Characteristic Information
! 
macro SCDT$IS_CON_FLAGS = 116,0,32,0 %; ! I Connection Specific Flags.
macro SCDT$V_CFLG_ENA_DISCON = 116,0,1,0 %; ! I    Enable disconnect
macro SCDT$V_CFLG_DIS_RETRY = 116,1,1,0 %; ! I    Disable retry on command fail.
macro SCDT$V_CFLG_TARGET_MODE = 116,2,1,0 %; ! I    Target mode supported
macro SCDT$IS_IMPL_STS = 120,0,32,0 %;  ! F Implementation specific connection sts
macro SCDT$V_ISTS_SDTR_SENT = 120,0,1,0 %; ! O If SDTR_SENT bit is set, it means for
!    this target/LUN, we already sent SDTR
!    message to negotiate sync. xfer mode
macro SCDT$V_ISTS_DID_RESET_CALLBACK = 120,1,1,0 %; ! F Used by SCSI2COMMON to remember that we
!   have already told the class driver that a
!   reset is in progress. 
! 
! 		Queuing specific data.
! 
macro SCDT$IS_QUEUE_FLAGS = 124,0,32,0 %; ! F Bitmap of flags used to manage the port queue state.
macro SCDT$V_QF_QUEUED_ACA = 124,0,1,0 %; ! F   ACA I/O on head of queue.
macro SCDT$V_QF_QUEUE_TIMER_RUNNING = 124,1,1,0 %; ! F   Queue full timer is running.
macro SCDT$V_QF_NO_DEV_IO_CREDITS = 124,2,1,0 %; ! F   The port's device I/O queue has no remaining credits
macro SCDT$IS_DIPL_QUEUE_FLAGS = 128,0,32,0 %; ! S Bitmap of flags used to manage the port queue state.
macro SCDT$V_DQF_ACA_ACTIVE = 128,0,1,0 %; ! S   Queued command terminated with a check condition.
macro SCDT$V_DQF_FLUSHING_QUEUE = 128,1,1,0 %; ! F   The device and port queues are being flushed.
macro SCDT$V_DQF_QUEUE_FULL = 128,2,1,0 %; ! S   The device's queue is full.
macro SCDT$V_DQF_QUEUE_FULL_INIT = 128,3,1,0 %; ! S   Initialize queue full processing.
macro SCDT$V_DQF_QUEUE_WAIT = 128,4,1,0 %; ! S   Queue processing is waiting for device I/O completion.
macro SCDT$V_DQF_CLASS_DRVR_FREEZE_Q = 128,5,1,0 %; ! S   Class driver requested that the queue be frozen.
macro SCDT$V_DQF_QUEUE_FLUSH_ACTIVE = 128,6,1,0 %; ! S   Queue flush active is active
macro SCDT$IS_SEQUENCE = 132,0,32,0 %;  ! O Sequence ID assigned to a new I/O.
macro SCDT$IS_NEXT_SEQUENCE = 136,0,32,0 %; ! O Next sequence ID expected to be sent by the port driver.
! 
! 		SCSI-2 Congestion Control information.	Used for queue full message processing.
! 
macro SCDT$IS_QUEUED_IO_COUNT = 140,0,32,0 %; ! F The number of SCSI commands queued following the command that
!     received the queue full condition.
macro SCDT$IS_MAX_QUEUE_DEPTH = 144,0,32,0 %; ! F Maximum queue depth for the port.
macro SCDT$IS_CURRENT_QUEUE_DEPTH = 148,0,32,0 %; ! F Current queue depth for the port.
!     Fast growth if CURRENT_QUEUE_DEPTH < QUEUE_DEPTH_THRESHOLD
!     Slow growth if CURRENT_QUEUE_DEPTH > QUEUE_DEPTH_THRESHOLD
macro SCDT$IS_QUEUE_DEPTH_THRESHOLD = 152,0,32,0 %; ! F Queue depth threshold.
macro SCDT$IS_CMD_SUCCESS_COUNT = 156,0,32,0 %; ! F The number of commands that have successfully completed.
!     if CMD_SUCCESS_COUNT >= CMD_SUCCESS_THRESHOLD
! 	 Increment CURRENT_QUEUE_DEPTH;
! 	 CMD_SUCCESS_COUNT = 0;
macro SCDT$Q_CMD_COMPLETE_TIME = 160,0,0,1 %;
literal SCDT$S_CMD_COMPLETE_TIME = 8;   ! F Average time to complete a command.
macro SCDT$Q_CMD_COMPLETE_DEVIATION = 168,0,0,1 %;
literal SCDT$S_CMD_COMPLETE_DEVIATION = 8; ! F Deviation in the time to complete a command.
macro SCDT$Q_CMD_COMPLETE_DELAY = 176,0,0,1 %;
literal SCDT$S_CMD_COMPLETE_DELAY = 8;  ! F The delay required to ensure that an average command could complete.
macro SCDT$IS_CMD_SUCCESS_THRESHOLD = 184,0,32,0 %; ! F Threshold to be crossed before incrementing CURRENT_QUEUE_DEPTH.
! 
! 		Queue Manager information.
! 
macro SCDT$PS_PORT_QFL = 192,0,32,1 %;  ! F Forward link of queue of I/O sent to the port.
macro SCDT$PS_PORT_QBL = 196,0,32,1 %;  ! F Backward link of queue of I/O sent to the port.
macro SCDT$PS_DEV_QFL = 200,0,32,1 %;   ! F Forward link of queue of requests sent to the device.
macro SCDT$PS_DEV_QBL = 204,0,32,1 %;   ! F Backward link of queue of requests sent to the device.
macro SCDT$IS_TOTAL_IO_COUNT = 208,0,32,0 %; ! F Total outstanding I/O count (port & device).
macro SCDT$IS_PORT_IO_COUNT = 212,0,32,0 %; ! F Count of I/Os outstanding on the port.
macro SCDT$IS_DEV_IO_COUNT = 216,0,32,0 %; ! F Count of I/Os outstanding on the device.
! 
! 		Port connection performance and error counters.
! 
macro SCDT$L_ARB_FAIL_CNT = 220,0,32,0 %; ! S Count of arbitration failures.
macro SCDT$L_SEL_FAIL_CNT = 224,0,32,0 %; ! S Count of selection failures.
macro SCDT$L_PARERR_CNT = 228,0,32,0 %; ! S Count of parity errors.
macro SCDT$L_MISPHS_CNT = 232,0,32,0 %; ! S Count of missing phases errors.
macro SCDT$L_BADPHS_CNT = 236,0,32,0 %; ! S Count of bad phase errors.
macro SCDT$L_RETRY_CNT = 240,0,32,0 %;  ! S Count of retries, this on connection.
macro SCDT$L_CTLERR_CNT = 244,0,32,0 %; ! S Count of controller errors
macro SCDT$L_BUSERR_CNT = 248,0,32,0 %; ! S Count of bus errors
macro SCDT$L_CMDSENT = 252,0,32,0 %;    ! S Number of commands sent
macro SCDT$L_MSGSENT = 256,0,32,0 %;    ! S Number of messages sent
macro SCDT$L_BYTSENT = 260,0,32,0 %;    ! S Number of bytes sent during dataout
! 
! 		Allocation bit map for tag values, and associated values.
! 
macro SCDT$IS_WAIT_TAG = 264,0,32,0 %;  ! F Tag value associated with a non-queued request.
macro SCDT$IS_MAX_TAG_USED = 268,0,32,0 %; ! F Maximum tag value used, performance metric.
!   Maximum tag value allowed: ( 0 - 255 )
!   Maximum longwords for the tag allocation bit map.
macro SCDT$IS_TAG_MAP = 272,0,0,0 %;
literal SCDT$S_TAG_MAP = 32;            ! F Bitmap of allocated tag values.  Bit set => value in use.
macro SCDT$IS_LAST_TAG_INDEX = 304,0,32,0 %; ! F Last tag value allocated
! 
! 		Save some space for future expansion.  Reserved to Digital, ALPHA/VMS development.
! 
macro SCDT$L_RSVD_LONG = 308,0,0,1 %;
literal SCDT$S_RSVD_LONG = 20;          ! F Port specific space that may be used for any purpose.
! 
! 		Save some space for Port specific extensions.
! 
macro SCDT$L_PORT_SPECIFIC = 328,0,0,1 %;
literal SCDT$S_PORT_SPECIFIC = 20;      ! F Port specific space that may be used for any purpose.
! 
! 		Define the length of this structure.
! 
 
!*** MODULE $SCHDEF ***
literal SCH$C_SWPPIX = 1;               !  PIX for swapper process
literal SCH$V_SIP = 0;                  !  SWAP IN PROGRESS FLAG
literal SCH$V_TCD = 1;                  !  MPL threshold checking disabled
literal SCH$V_MPW = 2;                  !  Modify page writer active
literal SCH$V_REORD = 0;                !  OSWPSCHED queue reordering occured
 
!*** MODULE $SCQDEF ***
! +
!  $SCQDEF	- SCSI Connect reQuest desciptor block
! 
!  The SCQ is passed by a SCSI class driver to a SCSI port driver as the
!  sole argument in to the CONNECT service call.  The SCQ contains all
!  CONNECT service parameters, both input and output.
! 				+-------------------+
! 		     Buffer	|    10 or 12	    |	  argument count
! 				+-------------------+
! 		     1	  +04	|   disconnects	    |	  1 = supported, 0 = unsupported
! 				+-------------------+
! 		     2	  +08	|   synchronous	    |	  Port controlled.
! 				+-------------------+
! 		     3	  +0C	|  Transfer_period  |	  m * 4 nanoseconds
! 				+-------------------+
! 		     4	 +10	|  Reqack_offset    |
! 				+-------------------+
! 		     5	 +14	| Busy_retry_count  |	  0 = no retries
! 				+-------------------+
! 		     6	 +18	| Arb_retry_count   |	  0 = no retries
! 				+-------------------+
! 		     7	 +1C	| Sel_retry_count   |	  0 = no retries
! 				+-------------------+
! 		     8	 +20	| Cmd_retry_count   |	  0 = no retries
! 				+-------------------+
! 		     9	 +24	|    Dma_timeout    |	  0 = Phase/Dma Timeout
! 				+-------------------+
! 		    10	 +28	| Disconnect timeout|	  0 = Disconnected IO timeout
! 				+-------------------+
! 		    11	 +2C	|      Flags	    |	  SCSI Flags
! 				+-------------------+
! 		    12	 +30	|  Max Queue Depth  |	  Maximum queue depth
! 				+-------------------+
! 
! 		       The Flags field is defined as follows:
! 
! 			Bit    Description
! 			---    -----------
! 			  0    CMDQ - Device supports command queuing if set
! 			  1    FLUSHQ - Flush queue on error
! 			  2    FREEZEQ - Freeze queue on error
! 			  3    SCSI-2 - Device is SCSI-2 conformant
! 		       31-4    Reserved MBZ
! -
literal SCQ$C_VERSION = 1;              !  Compatible Version Number.
!  Inputs
literal SCQ$K_CLSPOT_SP1 = 1;           !    SP1$ protocol
literal SCQ$K_CLSPOT_SP2 = 2;           !    SP2$ protocol
literal SCQ$K_LENGTH = 60;              !  Structure length
literal SCQ$S_SCQDEF = 60;
literal SCQ$S_SCQ = 60;
macro SCQ$IS_CLSPOT_PROTOCOL = 0,0,32,0 %; !  Class/port protocol
macro SCQ$IS_VERSION_NOS = 4,0,32,0 %;  !  Data struc. version #s
macro SCQ$IB_SCDRP_VNO = 4,0,8,0 %;     !    SCDRP version
macro SCQ$IB_SPDT_VNO = 5,0,8,0 %;      !    SPDT  version
macro SCQ$IB_SCDT_VNO = 6,0,8,0 %;      !    SCDT  version
macro SCQ$IB_STDT_VNO = 7,0,8,0 %;      !    STDT  version
macro SCQ$IS_SCSI_IDS = 8,0,32,0 %;     !  SCSI port/bus IDs
macro SCQ$IW_SCSI_PORT_ID = 8,0,16,0 %; !    SCSI port ID
macro SCQ$IW_SCSI_BUS_ID = 10,0,16,0 %; !    SCSI bus ID
macro SCQ$IS_SCSI_LUN = 12,0,32,0 %;    !  SCSI LUN (longword)
macro SCQ$IW_SCSI_LUN = 14,0,16,0 %;    !    SCSI_LUN (word)
macro SCQ$PS_SEL_CALLBACK = 16,0,32,1 %; !    Target mode callback rout.
macro SCQ$IS_SEL_CONTEXT = 20,0,32,0 %; !    Target mode context data
macro SCQ$PS_AEN_CALLBACK = 24,0,32,1 %; !     AEN callback routine
macro SCQ$IS_AEN_CONTEXT = 28,0,32,0 %; !     AEN context data
macro SCQ$PS_PORT_STATE_CALLBACK = 32,0,32,1 %; !  Port State Callback Routine
macro SCQ$IS_PORT_STATE_CONTEXT = 36,0,32,0 %; !  Port State Callback Context
!  Outputs
macro SCQ$PS_SPDT = 40,0,32,1 %;        !  Port SPDT address
macro SCQ$PS_SCDT = 44,0,32,1 %;        !  SCDT address
macro SCQ$PS_STDT = 48,0,32,1 %;        !  STDT address
macro SCQ$IS_MAX_BCNT = 52,0,32,0 %;    !  Maximum BCNT supported
macro SCQ$IS_PORT_SERV_FLAGS = 56,0,32,0 %; !  Port service flags
 
!*** MODULE $SCSDEF ***
! +
!  SCS MESSAGE DEFINITIONS
! 
!  THIS STRUCTURE DEFINES OFFSETS AND FIELDS WITHIN THE SCS PORTION OF
!  A CLUSTER MESSAGE.  OFFSETS ARE DEFINED RELATIVE TO THE START OF THE
!  APPLICATION DATA OR SCS CONTROL MESSAGE DATA.  THE FULL MESSAGE FORMAT
!  CONSISTS OF A PORT DRIVER LAYER HEADER (SEE STRUCTURE PPD) FOLLOWED
!  BY THE SCS HEADER LAYER FOLLOWED BY THE APPLICATION DATA OR SCS CONTROL
!  MESSAGE DATA.
! -
literal SCS$C_OVHD = 14;                !  SCS LAYER OVERHEAD
literal SCS$C_CON_REQL = 66;            !  CONNECT_REQ LENGTH 
literal SCS$C_CON_RSPL = 22;            !  (TYC 20-apr-89) CONNECT_RSP LENGTH 
literal SCS$C_ACCP_REQL = 66;           !  ACCEPT_REQ LENGTH 
literal SCS$C_ACCP_RSPL = 18;           !  ACCEPT_RSP LENGTH 
literal SCS$C_REJ_REQL = 18;            !  REJECT_REQ LENGTH 
literal SCS$C_REJ_RSPL = 14;            !  REJECT_RSP LENGTH 
literal SCS$C_DISC_REQL = 18;           !  DISCONNECT_REQ LENGTH 
literal SCS$C_DISC_RSPL = 14;           !  DISCONNECT_RSP LENGTH 
literal SCS$C_CR_REQL = 14;             !  CREDIT_REQ LENGTH 
literal SCS$C_CR_RSPL = 14;             !  CREDIT_RSP LENGHT 
literal SCS$C_CON_REQ = 0;              !  CONNECT_REQ 
literal SCS$C_CON_RSP = 1;              !  CONNECT_RSP 
literal SCS$C_ACCP_REQ = 2;             !  ACCEPT_REQ 
literal SCS$C_ACCP_RSP = 3;             !  ACCEPT_RSP 
literal SCS$C_REJ_REQ = 4;              !  REJECT_REQ 
literal SCS$C_REJ_RSP = 5;              !  REJECT_RSP 
literal SCS$C_DISC_REQ = 6;             !  DISCONNECT_REQ 
literal SCS$C_DISC_RSP = 7;             !  DISCONNECT_RSP 
literal SCS$C_CR_REQ = 8;               !  CREDIT_REQ 
literal SCS$C_CR_RSP = 9;               !  CREDIT_RSP 
literal SCS$C_APPL_MSG = 10;            !  APPLICATION MESSAGE 
literal SCS$C_APPL_DG = 11;             !  APPLICATION DATAGRAM 
literal SCS$K_APPL_BASE = 0;            ! BASE OF APPLICTION MESSAGE DATA 
literal SCS$C_APPL_BASE = 0;            ! BASE OF APPLICTION MESSAGE DATA 
literal SCS$M_UAP = %X'1';
literal SCS$K_STNORMAL = 1;             !  NORMAL, SUCCESS
literal SCS$C_STNORMAL = 1;             ! 
literal SCS$K_STNOMAT = 10;             !  NO MATCHING LISTENER
literal SCS$C_STNOMAT = 10;             ! 
literal SCS$K_STNORS = 18;              !  NO RESOURCES
literal SCS$C_STNORS = 18;              ! 
literal SCS$K_STDISC = 25;              !  DISCONNECTED
literal SCS$C_STDISC = 25;              ! 
literal SCS$K_STINSFCR = 33;            !  INSUFF CREDIT
literal SCS$C_STINSFCR = 33;            ! 
literal SCS$K_STBALANCE = 41;           !  LOAD BALANCE
literal SCS$C_STBALANCE = 41;           !   DISCONNECT
literal SCS$K_USE_ALTERNATE_PORT = 42;  !  (TYC 13-Feb-89) Load Share
literal SCS$C_USE_ALTERNATE_PORT = 42;  !   Status code for using alternate port
literal SCS$K_CON_BASE = 4;             ! BASE OF CONNECT/ACCEPT INFO TO 
literal SCS$C_CON_BASE = 4;             ! BASE OF CONNECT/ACCEPT INFO TO 
!  GIVE TO SYSAP'S
literal SCS$S_SCSDEF = 84;              !  Old size name - synonym
literal SCS$S_SCS = 84;
macro SCS$B_PPD = -32,0,0,0 %;
literal SCS$S_PPD = 16;                 ! 16 BYTES OF PPD HEADER 
macro SCS$W_LENGTH = -16,0,16,0 %;      ! MESSAGE LENGTH (INCLUDES ALL 
!  BYTES FROM SCS$W_LENGTH ON,
!  NOT INCLUDING SCS$W_LENGTH)
!  (FIELD SHARED BY PPD)
! DEFINE LENGTHS OF SCS CONTROL MSGS: 
macro SCS$W_MTYPE = -12,0,16,0 %;       ! SCS MESSAGE TYPE 
! SCS MESSAGE TYPE CODES:
!  0 ORIGIN, INCREMENTS OF 1 
macro SCS$W_CREDIT = -10,0,16,0 %;      ! CREDIT BEING EXTENDED 
macro SCS$L_DST_CONID = -8,0,32,0 %;    ! DESTINATION (RECVING) CONNX ID 
macro SCS$L_SRC_CONID = -4,0,32,0 %;    ! SOURCE (SENDING) CONNX ID 
macro SCS$W_MIN_CR = 0,0,16,0 %;        ! MINIMUM SEND CREDIT 
macro SCS$W_STATUS = 2,0,16,0 %;        ! STATUS/REASON  
macro SCS$V_UAP = 2,0,1,0 %;            !  USE ALTERNATE PORT is supported
! DEFINE STATUS/REASON CODES:
! FORMAT OF CONNECT/ACCEPT_REQ MSGS:
macro SCS$T_DST_PROC = 4,0,0,0 %;
literal SCS$S_DST_PROC = 16;            !  DESTINATION PROCESS NAME 
macro SCS$B_SUBNODE = 4,0,8,0 %;        !  MUST BE ZERO FOR NOW
macro SCS$B_PGRP = 5,0,8,0 %;           !  ALTERNATE PORT'S PPD ADDR
macro SCS$W_RSV = 6,0,16,0 %;           !  RESERVED FIELD
macro SCS$T_SRC_PROC = 20,0,0,0 %;
literal SCS$S_SRC_PROC = 16;            !  SOURCE PROCESS NAME 
macro SCS$B_CON_DAT = 36,0,0,0 %;
literal SCS$S_CON_DAT = 16;             !  CONNECT DATA 
! 
!  DEFINITION OF THE REQUEST/SEND DATA OFFSETS 
! 
literal SCS$S_SCSDEF1 = 28;             !  Old size name - synonym
literal SCS$S_SCS1 = 28;
macro SCS$L_LCONID = -16,0,32,0 %;      !  LOCAL CONNECTION ID
macro SCS$L_RSPID = -12,0,32,0 %;       !  LOCAL RESPONSE ID
macro SCS$L_XCT_LEN = -8,0,32,0 %;      !  TRANSACTION LENGTH
macro SCS$L_SND_NAME = -4,0,32,0 %;     !  SEND BUFFER NAME
macro SCS$L_SND_BOFF = 0,0,32,0 %;      !   AND OFFSET
macro SCS$L_REC_NAME = 4,0,32,0 %;      !  RECEIVE BUFFER NAME
macro SCS$L_REC_BOFF = 8,0,32,0 %;      !   AND OFFSET
 
!*** MODULE $SCSCMGDEF ***
! +
!  SCSCMG - SCS CONNECTION MANAGEMENT MESSAGE FORMAT
! 
!  THIS PORTION OF A CONNECT/ACCEPT MESSAGE IS SEEN BY A
!  SYSTEM APPLICATION.
! -
literal SCSCMG$S_SCSCMGDEF = 48;
literal SCSCMG$S_SCSCMG = 48;
macro SCSCMG$T_RECNAM = 0,0,0,0 %;
literal SCSCMG$S_RECNAM = 16;           ! RECEIVE PROCESS NAME 
macro SCSCMG$T_SNDNAM = 16,0,0,0 %;
literal SCSCMG$S_SNDNAM = 16;           ! SENDER PROCESS NAME 
macro SCSCMG$B_SNDDAT = 32,0,0,0 %;
literal SCSCMG$S_SNDDAT = 16;           ! SENDER CONNECT DATA 
 
!*** MODULE $SCSIDEF IDENT X-2 ***
! 
!  Standard INQUIRY data
! 
!  The standard inquiry data contains 36 bytes, followed by a variable number of
!  vendor specific parameters.
! 
literal SCSI$INQ$M_DEVICE_TYPE = %X'1F';
literal SCSI$C_DISK = 0;                !  Direct-access device (e.g., magnetic disk)
literal SCSI$C_TAPE = 1;                !  Sequential-access device (e.g., magnetic tape)
literal SCSI$C_PRINTER = 2;             !  Printer device
literal SCSI$C_CPU = 3;                 !  Processor device
literal SCSI$C_WORM = 4;                !  Write-once device
literal SCSI$C_CDROM = 5;               !  CD-ROM device
literal SCSI$C_SCANNER = 6;             !  Scanner device
literal SCSI$C_OPTICAL = 7;             !  Optical memory device (e.g., some optical disks)
literal SCSI$C_JUKEBOX = 8;             !  Medium Changer device (e.g., jukeboxes)
literal SCSI$C_INTERCONNECT = 9;        !  Communications device
literal SCSI$INQ$M_QUALIFIER = %X'E0';
literal SCSI$C_LUN_CONNECTED = 0;       !  Peripheral device is connected to LUN
literal SCSI$C_LUN_NOCONNECT = 1;       !  Peripheral device is not connected to LUN
literal SCSI$C_LUN_UNAVAILABLE = 3;     !  Peripheral device does not support LUNs
literal SCSI$INQ$M_MODIFIER = %X'7F';
literal SCSI$INQ$M_RMB = %X'80';
literal SCSI$INQ$M_ANSI_VERSION = %X'7';
literal SCSI$C_ANSI_UNKNOWN = 0;        !  The device ANSI version is unknown
literal SCSI$C_ANSI_SCSI_1 = 1;         !  The device complies to SCSI-1 (ANSI X3.131-1986)
literal SCSI$C_ANSI_SCSI_2 = 2;         !  The device complies to SCSI-2 (revision ?)
literal SCSI$INQ$M_ECMA_VERSION = %X'38';
literal SCSI$INQ$M_ISO_VERSION = %X'C0';
literal SCSI$INQ$M_RESP_DATA_FORMAT = %X'F';
literal SCSI$C_SCSI_1 = 0;              !  INQUIRY data in SCSI-1 format
literal SCSI$C_OTHER = 1;               !  INQUIRY data in pre-SCSI-2 format
literal SCSI$C_SCSI_2 = 2;              !  INQUIRY data in SCSI-2 format
literal SCSI$INQ$M_TRMIOP = %X'40';
literal SCSI$INQ$M_AENC = %X'80';
literal SCSI$INQ$M_SFTRE = %X'1';
literal SCSI$INQ$M_CMDQUE = %X'2';
literal SCSI$INQ$M_LINKED = %X'8';
literal SCSI$INQ$M_SYNC = %X'10';
literal SCSI$INQ$M_WBUS16 = %X'20';
literal SCSI$INQ$M_WBUS32 = %X'40';
literal SCSI$INQ$M_RELADR = %X'80';
literal SCSI$INQ$S_INQUIRY_DATA = 36;
macro SCSI$INQ$R_PERIPHERAL = 0,0,8,0 %;
literal SCSI$INQ$S_PERIPHERAL = 1;      !  Peripheral device types & qualifiers
macro SCSI$INQ$V_DEVICE_TYPE = 0,0,5,0 %;
literal SCSI$INQ$S_DEVICE_TYPE = 5;     !  Peripheral device type
macro SCSI$INQ$V_QUALIFIER = 0,5,3,0 %;
literal SCSI$INQ$S_QUALIFIER = 3;       !  Peripheral qualifer
macro SCSI$INQ$R_DEVICE_TYPE_MOD = 1,0,8,0 %;
literal SCSI$INQ$S_DEVICE_TYPE_MOD = 1; !  Device Type Modifiers
macro SCSI$INQ$V_MODIFIER = 1,0,7,0 %;
literal SCSI$INQ$S_MODIFIER = 7;        !  Device Type Modifiers
macro SCSI$INQ$V_RMB = 1,7,1,0 %;       !  Removalable media bit
macro SCSI$INQ$R_VERSION = 2,0,8,0 %;
literal SCSI$INQ$S_VERSION = 1;         !  SCSI Versions
macro SCSI$INQ$V_ANSI_VERSION = 2,0,3,0 %;
literal SCSI$INQ$S_ANSI_VERSION = 3;    !  ANSI Approved Version
macro SCSI$INQ$V_ECMA_VERSION = 2,3,3,0 %;
literal SCSI$INQ$S_ECMA_VERSION = 3;    !  ECMA version number
macro SCSI$INQ$V_ISO_VERSION = 2,6,2,0 %;
literal SCSI$INQ$S_ISO_VERSION = 2;     !  ISO version number
macro SCSI$INQ$R_FLAGS_1 = 3,0,8,0 %;
literal SCSI$INQ$S_FLAGS_1 = 1;         !  SCSI INQUIRY Flags
macro SCSI$INQ$V_RESP_DATA_FORMAT = 3,0,4,0 %;
literal SCSI$INQ$S_RESP_DATA_FORMAT = 4; !  Response data (INQUIRY) format
macro SCSI$INQ$V_TRMIOP = 3,6,1,0 %;    !  Device supports terminate I/O process
macro SCSI$INQ$V_AENC = 3,7,1,0 %;      !  Device supports Asych. Event Notification
macro SCSI$INQ$B_ADD_LENGTH = 4,0,8,0 %; !  Additional length in bytes of parameters
macro SCSI$INQ$R_FLAGS = 7,0,8,0 %;
literal SCSI$INQ$S_FLAGS = 1;           !  SCSI INQUIRY Flags
macro SCSI$INQ$V_SFTRE = 7,0,1,0 %;     !  Device supports soft resets
macro SCSI$INQ$V_CMDQUE = 7,1,1,0 %;    !  Device supports tagged command queueing
macro SCSI$INQ$V_LINKED = 7,3,1,0 %;    !  Device supports linked commands
macro SCSI$INQ$V_SYNC = 7,4,1,0 %;      !  Device supports synchronous data xfer
macro SCSI$INQ$V_WBUS16 = 7,5,1,0 %;    !  Device supports 16-bit data xfers
macro SCSI$INQ$V_WBUS32 = 7,6,1,0 %;    !  Device supports 32-bit data xfers
macro SCSI$INQ$V_RELADR = 7,7,1,0 %;    !  Device supports relative address for linked cmds
macro SCSI$INQ$B_VENDOR_ID = 8,0,0,1 %;
literal SCSI$INQ$S_VENDOR_ID = 8;       !  Vendor Identification field
macro SCSI$INQ$B_PRODUCT_ID = 16,0,0,1 %;
literal SCSI$INQ$S_PRODUCT_ID = 16;     !  Product Identification field
macro SCSI$INQ$B_PRODUCT_REVISION = 32,0,32,1 %;
literal SCSI$INQ$S_PRODUCT_REVISION = 4; !  Vendor Product Revision level
! 
!  Mode Parameter Header (six byte)
! 
literal SCSI$MPH6$S_MODE_PARAM_HDR_6 = 4;
macro SCSI$MPH6$B_DATA_LENGTH = 0,0,8,0 %; !  Mode data Length
macro SCSI$MPH6$B_MEDIUM_TYPE = 1,0,8,0 %; !  Medium type
macro SCSI$MPH6$B_DEVICE_PARAM = 2,0,8,0 %; !  Device-specific parameter
macro SCSI$MPH6$B_BLOCK_LENGTH = 3,0,8,0 %; !  Block descriptor length
! 
!  Mode Parameter Header (ten byte)
! 
literal SCSI$MPH10$S_MODE_PARAM_HDR_10 = 8;
macro SCSI$MPH10$W_DATA_LENGTH = 0,0,16,0 %; !  Mode data Length
macro SCSI$MPH10$B_MEDIUM_TYPE = 2,0,8,0 %; !  Medium type
macro SCSI$MPH10$B_DEVICE_PARAM = 3,0,8,0 %; !  Device-specific parameter
macro SCSI$MPH10$B_RESERVED1 = 4,0,16,0 %;
literal SCSI$MPH10$S_RESERVED1 = 2;     !  Reserved
macro SCSI$MPH10$W_BLOCK_LENGTH = 6,0,16,0 %; !  Block descriptor length
! 
!  Mode Parameters used with direct access devices (DK)
! 
literal SCSI$DK$C_DEFAULT = 0;          !  Default medium type (currently mounted medium type)
literal SCSI$DK$C_SS = 1;               !  Flexible disk, single-sided; unspecified medium
literal SCSI$DK$C_DS = 2;               !  Flexible disk, double-sided; unspecified medium
literal SCSI$DK$C_DD = 3;               !  Flexible disk, double-sided; double-density
! 
!  Direct-Access params
! 
literal SCSI$DK$M_DPOFUA = %X'10';
literal SCSI$DK$M_WP = %X'80';
literal SCSI$DK$S_DISK_SPECIFIC_PARAM = 1;
macro SCSI$DK$V_DPOFUA = 0,4,1,0 %;     !  Disable Page Out/Force Unit Access
macro SCSI$DK$V_WP = 0,7,1,0 %;         !  Write Protect
! 
!  CD-ROM specific parameter
! 
literal SCSI$CD$M_EBC = %X'1';
literal SCSI$CD$M_CACHE = %X'10';
literal SCSI$CD$S_CDROM_SPECIFIC_PARAM = 1;
macro SCSI$CD$V_EBC = 0,0,1,0 %;        !  Enable Blank Check
macro SCSI$CD$V_CACHE = 0,4,1,0 %;      !  Device supports cache memory
! 
!  Mode Parameter Block Descriptor
! 
literal SCSI$MPBD$S_MODE_PARAMETER = 8;
macro SCSI$MPBD$B_DENSITY = 0,0,8,0 %;  !  Device specific density code
macro SCSI$MPBD$B_BLOCK = 1,0,24,0 %;
literal SCSI$MPBD$S_BLOCK = 3;          !  # of logical blocks density applies
macro SCSI$MPBD$B_LENGTH = 5,0,24,0 %;
literal SCSI$MPBD$S_LENGTH = 3;         !  # of bytes in each logical block
! 
!  Identify Message
! 
literal SCSI$IDENT$M_LUNTRN = %X'7';
literal SCSI$IDENT$M_LUNTAR = %X'20';
literal SCSI$IDENT$M_DISC_PRIV = %X'40';
literal SCSI$IDENT$M_IDENTIFY = %X'80';
literal SCSI$IDENT$S_IDENTIFY_MESSAGE = 1;
macro SCSI$IDENT$R_FLAGS = 0,0,8,0 %;
literal SCSI$IDENT$S_FLAGS = 1;
macro SCSI$IDENT$V_LUNTRN = 0,0,3,0 %;
literal SCSI$IDENT$S_LUNTRN = 3;        !  Logical Unit Target Routine #
macro SCSI$IDENT$V_LUNTAR = 0,5,1,0 %;  !  Logical Unit Target direction
macro SCSI$IDENT$V_DISC_PRIV = 0,6,1,0 %; !  Grant target privilege of disconnecting
macro SCSI$IDENT$V_IDENTIFY = 0,7,1,0 %; !  Message is an IDENTIFY message
! 
!  Define SCSI status codes
! 
literal SCSI$C_GOOD = 0;                !  Sucessfull completion of command
literal SCSI$C_CHECK_CONDITION = 2;     !  Contingent allegiance condition
literal SCSI$C_CONDITION_MET = 4;       !  Requested operation satisfied
literal SCSI$C_BUSY = 8;                !  Target busy
literal SCSI$C_INTERMEDIATE = 16;       !  Completed linked command in series
literal SCSI$C_INTERMEDIATE_COND_MET = 20; !  INTERMEDIATE and CONDITION_MET
literal SCSI$C_RESERVATION_CONFLICT = 24; !  Conflicting reservation conflict
literal SCSI$C_COMMAND_TERMINATED = 34; !  Target terminates current I/O
literal SCSI$C_QUEUE_FULL = 40;         !  Command queue is full
literal SCSI$M_STATUS_BYTE_RESERVED = 193; !  Status byte reserved bits
! 
!  Define SCSI Message Codes
! 
literal SCSI$C_COMMAND_COMPLETE = 0;    !  I/O completed
literal SCSI$C_EXTENDED_MESSAGE = 1;    !  Start multi-byte extended message
literal SCSI$C_SAVE_DATA_POINTERS = 2;  !  Save active pointers
literal SCSI$C_RESTORE_POINTERS = 3;    !  Restore saved pointers
literal SCSI$C_DISCONNECT = 4;          !  Connection will disconnect
literal SCSI$C_INITIATOR_DETECT_ERROR = 5; !  Inform target that error have occured
literal SCSI$C_ABORT = 6;               !  Clear active I/O, plus queued I/O
literal SCSI$C_MESSAGE_REJECT = 7;      !  Last message was inappropriate
literal SCSI$C_NO_OPERATION = 8;        !  Reponse when no current command
literal SCSI$C_MESSAGE_PARITY_ERROR = 9; !  Last message byte had parity error
literal SCSI$C_LINKED_COMMAND = 10;     !  Linked command is complete
literal SCSI$C_LINKED_COMMAND_FLAGED = 11; !  Linked command is complete (with flag)
literal SCSI$C_BUS_DEVICE_RESET = 12;   !  Reset device, go to bus free
literal SCSI$C_ABORT_TAG = 13;          !  Clear tagged command
literal SCSI$C_CLEAR_QUEUE = 14;        !  Clear all queued commands
literal SCSI$C_INITIATE_RECOVERY = 15;  !  Start ECA processing
literal SCSI$C_RELEASE_RECOVERY = 16;   !  Finish ECA processing
literal SCSI$C_TERMINATE_IO_PROCESS = 17; !  Terminate I/O process
literal SCSI$C_CLEAR_ACA = 22;
literal SCSI$C_SIMPLE_QUEUE_TAG = 32;   !  Queue I/O to queue
literal SCSI$C_HEAD_OF_QUEUE_TAG = 33;  !  Queue I/O to head of queue
literal SCSI$C_ORDERED_QUEUE_TAG = 34;  !  Queue I/O in order to queue
literal SCSI$C_IGNORE_WIDE_RESIDUE = 35; !  Ignore residual bytes
! 
!  Define SCSI Message Codes
! 
literal SCSI$C_MODIFY_DATA_POINTER = 0; !  Modify data pointers
literal SCSI$C_SYNCH_DATA_TRANSFER = 1; !  Synchronous Data Transfer Request
literal SCSI$C_WIDE_DATA_TRANSFER = 3;  !  Wide Data Transfer Request
! 
!  Sense Data Format
! 
literal SCSI$SNS$M_ERROR_CODE = %X'7F';
literal SCSI$SC1$C_CURRENT = 112;       !  Current error codes
literal SCSI$SC1$C_DEFERRED = 113;      !  Current error codes
literal SCSI$SNS$M_VALID = %X'80';
literal SCSI$SNS$M_SENSE_KEY = %X'F';
literal SCSI$SNS$M_ILI = %X'20';
literal SCSI$SNS$M_EOM = %X'40';
literal SCSI$SNS$M_FILEMARK = %X'80';
literal SCSI$C_RECOVERED_DATA = 23;     !  Recovered data...
!  ^X00 - with no error correction applied
literal SCSI$SNS$M_BIT_POINTER = %X'7';
literal SCSI$SNS$M_BPV = %X'8';
literal SCSI$SNS$M_C_D = %X'40';
literal SCSI$SNS$M_SKSV = %X'80';
literal SCSI$SNS$S_SENSE_DATA = 19;
macro SCSI$SNS$R_ERROR_CODE_FIELD = 0,0,8,0 %;
literal SCSI$SNS$S_ERROR_CODE_FIELD = 1;
macro SCSI$SNS$V_ERROR_CODE = 0,0,7,0 %;
literal SCSI$SNS$S_ERROR_CODE = 7;      !  Sense data error codes
macro SCSI$SNS$V_VALID = 0,7,1,0 %;     !  Information Field Valid
macro SCSI$SNS$B_SEGEMENT = 1,0,8,0 %;  !  # of current segement desc.
macro SCSI$SNS$R_FLAGS = 2,0,8,0 %;
literal SCSI$SNS$S_FLAGS = 1;
macro SCSI$SNS$V_SENSE_KEY = 2,0,4,0 %;
literal SCSI$SNS$S_SENSE_KEY = 4;       !  Information field
macro SCSI$SNS$V_ILI = 2,5,1,0 %;       !  Incorrect Length Indicator
macro SCSI$SNS$V_EOM = 2,6,1,0 %;       !  End of Medium Indicator
macro SCSI$SNS$V_FILEMARK = 2,7,1,0 %;  !  Filemark or Setmark seen
macro SCSI$SNS$R_INFORMATION = 3,0,32,0 %;
literal SCSI$SNS$S_INFORMATION = 4;     !  Device/Command specific info.
macro SCSI$SNS$L_LBA_ADDRESS = 3,0,32,0 %; !  Logical Block Address (Dev. Type 0,4,5,7)
macro SCSI$SNS$L_RESIDUAL_LENGTH = 3,0,32,0 %; !  (requested - actual) length (Dev. Type 1,2,3)
macro SCSI$SNS$L_RESIDUAL_BLOCKS = 3,0,32,0 %; !  (requested - actual) blocks (COPY, VERIFY, COMPARE)
macro SCSI$SNS$L_DATA_BLOCKS = 3,0,32,0 %; !  Count of Data Blocks
macro SCSI$SNS$L_FILE_MARKS = 3,0,32,0 %; !  Count of File Marks
macro SCSI$SNS$L_SET_MARKS = 3,0,32,0 %; !  Count of Set Marks
macro SCSI$SNS$B_ADD_SENSE_LEN = 7,0,8,0 %; !  Additional Sense Length
macro SCSI$SNS$R_ADD_INFORMATION = 8,0,32,0 %;
literal SCSI$SNS$S_ADD_INFORMATION = 4; !  Command specific info.
macro SCSI$SNS$B_SENSE_INFORMATION = 8,0,32,0 %;
literal SCSI$SNS$S_SENSE_INFORMATION = 4; !  Sense information
macro SCSI$SNS$B_ADD_SENSE_CODE = 12,0,8,0 %; !  Additional Sense Code
!  ^X01 - with retries
!  ^X02 - with positive head offset
!  ^X03 - with negative head offset
!  ^X04 - with retries and/or circ applied
!  ^X05 - using previous sector id
!  ^X06 - without ecc - data auto-reallocated
!  ^X07 - without ecc - recommend reassignment
macro SCSI$SNS$B_ADD_SENSE_QUAL = 13,0,8,0 %; !  Additional Sense Qualifier
macro SCSI$SNS$B_FRU_CODE = 14,0,8,0 %; !  Field Replaceable Unit Code
macro SCSI$SNS$R_SENSE_KEY_SPECIFIC = 15,0,24,0 %;
literal SCSI$SNS$S_SENSE_KEY_SPECIFIC = 3;
macro SCSI$SNS$V_BIT_POINTER = 15,0,3,0 %;
literal SCSI$SNS$S_BIT_POINTER = 3;     !  Bitfield pointer to error byte
macro SCSI$SNS$V_BPV = 15,3,1,0 %;      !  Bit Pointer Valid
macro SCSI$SNS$V_C_D = 15,6,1,0 %;      !  Command_Data error indicator
macro SCSI$SNS$V_SKSV = 15,7,1,0 %;     !  Sense Key Specific - Valid
macro SCSI$SNS$W_FIELD_POINTER = 16,0,16,0 %; !  Command or Data byte error pointer
macro SCSI$SNS$R_ADD_SENSE = 18,0,8,0 %;
literal SCSI$SNS$S_ADD_SENSE = 1;       !  Additional Sense data0
macro SCSI$SNS$B_ADD_SENSE_BYTES = 18,0,8,0 %;
literal SCSI$SNS$S_ADD_SENSE_BYTES = 1; !  Additional Sense Bytes
! 
!  Define SCSI sense key codes.
! 
literal SCSI$C_NO_SENSE = 0;            !  No sense key information returned
literal SCSI$C_RECOVERED_ERROR = 1;     !  Command completed with some recovery action
literal SCSI$C_NOT_READY = 2;           !  Logical unit cannot be accessed
literal SCSI$C_MEDIUM_ERROR = 3;        !  Command failed with non-recovered medium error
literal SCSI$C_HARDWARE_ERROR = 4;      !  Command failed with non-recovered hardware error
literal SCSI$C_ILLEGAL_REQUEST = 5;     !  Illegal parameter in the command descriptor block
literal SCSI$C_UNIT_ATTENTION = 6;      !  Removable medium change or target has been reset
literal SCSI$C_DATA_PROTECT = 7;        !  Read/Write of medium failed due to protection
literal SCSI$C_BLANK_CHECK = 8;         !  Read/Write found blank medium, end-of-data, etc.
literal SCSI$C_VENDOR_SPECIFIC = 9;     !  Vendor specific conditions reported
literal SCSI$C_COPY_ABORTED = 10;       !  Copy, compare or Copy/Verify aborted due to error
literal SCSI$C_ABORTED_COMMAND = 11;    !  Targeted aborted current command
literal SCSI$C_EQUAL = 12;              !  Search Data command has equal comparison
literal SCSI$C_VOLUME_OVERFLOW = 13;    !  Buffered device has reach end of parition
literal SCSI$C_MISCOMPARE = 14;         !  Source data command has unequal comparison
literal SCSI$C_RESERVED = 15;           !  Reserved
! 
!  Selected SCSI Mode Page Codes
! 
literal SCSI$C_AUDIO_CONTROL_PAGE = 14; !  CD-ROM Audio Control Page
literal SCSI$C_MEDIA_CHANGE = 40;       !  Medium change
!  ^X00 - Not ready to ready transition (medium change)
literal SCSI$C_MODE_CHANGE = 42;        !  Mode change
!  ^X00 - Parameters changed
!  ^X01 - Mode parameters changed
!  ^X02 - Log parameters changed
literal SCSI$C_INCOMPATIBLE_MEDIA = 48; !  Unformatted media
!  ^X00 - Incompatible medium installed
!  ^X01 - Cannot read medium - unknown format
!  ^X02 - Cannot read medium - incompatible format
!  ^X03 - Cleaning cartridge installed
literal SCSI$C_DRIVE_NOT_READY = 4;     !  Logical unit...
!  ^X00 - not ready, cause not reportable
!  ^X01 - is in process of becoming ready
!  ^X02 - not ready, initializing command required
!  ^X03 - not ready, manual intervention required
!  ^X04 - not ready, format in progress
literal SCSI$C_MEDIUM_NOT_PRESENT = 58; !  Medium not present
!  ^X00 - Medium not present ?
! 
!  Type codes for Optical Memory Medium-Type Codes
! 
literal SCSI$OPT$C_MEDIA_DEFAULT = 0;   !  Default (only one medium type supported)
literal SCSI$OPT$C_MEDIA_RO = 1;        !  Optical Read Only medium
literal SCSI$OPT$C_MEDIA_WORM = 2;      !  Optical Write Once medium
literal SCSI$OPT$C_MEDIA_ERASE = 3;     !  Optical Reversible or Erasable medium
literal SCSI$OPT$C_MEDIA_RO_WORM = 4;   !  Combination of Read only and Write Once medium
literal SCSI$OPT$C_MEDIA_RO_ERASE = 5;  !  Combination of Read only and Reversible or Erasable medium
literal SCSI$OPT$C_MEDIA_WORM_ERASE = 6; !  Combination of Write Once and Reversible or Erasable medium
! 
!  Mode sense page code paramaters
! 
literal SCSI$PGCD$C_VENDOR_SPECIFIC = 0; !  Vendor-Specific (does not require page format)
literal SCSI$PGCD$C_READ_WRITE_ERR = 1; !  Read-Write Error Recovery Page
literal SCSI$PGCD$C_DISCONNECT_REC = 2; !  Disconnect-Reconnect Page
literal SCSI$PGCD$C_FORMAT_DEVICE = 3;  !  Format Device Page
literal SCSI$PGCD$C_RIGID_DISK = 4;     !  Rigid Disk Geometry Page
literal SCSI$PGCD$C_FLEXIBLE_DISK = 5;  !  Flexible Disk Page
literal SCSI$PGCD$C_RESERVED = 6;       !  Reserved
literal SCSI$PGCD$C_VERIFY_ERROR = 7;   !  Verify Error Recovery Page
literal SCSI$PGCD$C_CACHING = 8;        !  Caching Page
literal SCSI$PGCD$C_PERIPHERAL = 9;     !  Peripheral Device Page
literal SCSI$PGCD$C_CONTROL_MODE = 10;  !  Control Mode Page
literal SCSI$PGCD$C_MEDIUM_TYPES = 11;  !  Medium Types Supported Page
literal SCSI$PGCD$C_NOTCH_PARTION = 12; !  Notch and Partition Page
literal SCSI$PGCD$C_ALL_PAGES = 63;     !  Return all pages
literal SCSI$PGCD$C_MAX_PAGE_CODE = 63; !  Maximum Page Code
literal SCSI$PGCD$M_CURRENT = 0;        !  Current Values
literal SCSI$PGCD$M_CHANGEABLE = 64;    !  Changeable Values
literal SCSI$PGCD$M_DEFAULT = 128;      !  Default Values
literal SCSI$PGCD$M_SAVED = 192;        !  Saved Values
literal SCSI$PGCD$C_PAGE_SIZE = 512;    !  Initial Page Size
! 
!  Audio Control Parameters Page
! 
literal SCSI$ACP$M_PAGE_CODE = %X'3F';
literal SCSI$ACP$C_PAGE_CODE = 14;
literal SCSI$ACP$M_PS = %X'80';
literal SCSI$S_HEADER = 2;              !  SCSI Page header size (PAGE_CODE+PAGE_LENGTH)
literal SCSI$ACP$C_PAGE_LENGTH = 14;
literal SCSI$ACP$M_SOTC = %X'2';
literal SCSI$ACP$M_IMMED = %X'4';
literal SCSI$ACP$M_LBA_FORMAT = %X'F000000';
literal SCSI$ACP$M_CHANNEL_0 = %X'1';
literal SCSI$ACP$M_CHANNEL_1 = %X'2';
literal SCSI$ACP$M_CHANNEL_2 = %X'4';
literal SCSI$ACP$M_CHANNEL_3 = %X'8';
literal SCSI$ACP$S_AUDIO_CONTROL = 16;
macro SCSI$ACP$R_PAGE_CODE_FIELD = 0,0,8,0 %;
literal SCSI$ACP$S_PAGE_CODE_FIELD = 1; !  Page code & save bits
macro SCSI$ACP$V_PAGE_CODE = 0,0,6,0 %;
literal SCSI$ACP$S_PAGE_CODE = 6;       !  Page code
macro SCSI$ACP$V_PS = 0,7,1,0 %;        !  PS - Parameters Saveable bit in non-VM
macro SCSI$ACP$B_PAGE_LENGTH = 1,0,8,0 %; !  Page length
macro SCSI$ACP$R_AUDIO_CONTROL_FLAGS = 2,0,32,0 %;
literal SCSI$ACP$S_AUDIO_CONTROL_FLAGS = 4; !  Audio Control Flags
macro SCSI$ACP$V_SOTC = 2,1,1,0 %;      !  Stop On Track Crossing
macro SCSI$ACP$V_IMMED = 2,2,1,0 %;     !  Send completion status immediately
macro SCSI$ACP$V_LBA_FORMAT = 2,24,4,0 %;
literal SCSI$ACP$S_LBA_FORMAT = 4;      !  Format of LBSa / Second
macro SCSI$ACP$W_LBS_PER_SEC = 6,0,16,0 %; !  Logical blocks per sec. of audio playback
macro SCSI$ACP$W_CHANNEL_VOLUME = 8,0,0,0 %;
literal SCSI$ACP$S_CHANNEL_VOLUME = 8;
macro SCSI$ACP$V_CHANNEL_0 = 8,0,1,0 %; !  Connect audio channel 0 to this port
macro SCSI$ACP$V_CHANNEL_1 = 8,1,1,0 %; !  Connect audio channel 1 to this port
macro SCSI$ACP$V_CHANNEL_2 = 8,2,1,0 %; !  Connect audio channel 2 to this port
macro SCSI$ACP$V_CHANNEL_3 = 8,3,1,0 %; !  Connect audio channel 3 to this port
macro SCSI$ACP$B_VOLUME = 9,0,8,0 %;    !  Channel volume from %X00(muted) to %XFF(full)
! 
!  Control Mode Page
! 
literal SCSI$CMP$M_PAGE_CODE = %X'3F';
literal SCSI$CMP$C_PAGE_CODE = 10;
literal SCSI$CMP$M_PS = %X'80';
literal SCSI$CMP$C_PAGE_LENGTH = 6;
literal SCSI$CMP$M_RLEC = %X'1';
literal SCSI$CMP$M_DQUE = %X'100';
literal SCSI$CMP$M_QERR = %X'200';
literal SCSI$CMP$M_QAM = %X'7000';
literal SCSI$QAM$C_RESTRICTED = 0;      !  Restricted Re-ordering
literal SCSI$QAM$C_UNRESTRICTED = 1;    !  Unrestricted Re-ordering
literal SCSI$CMP$M_EAENP = %X'8000';
literal SCSI$CMP$M_UAAENP = %X'10000';
literal SCSI$CMP$M_RAENP = %X'20000';
literal SCSI$CMP$M_EECA = %X'400000';
literal SCSI$CMP$S_CONTROL_MODE = 8;
macro SCSI$CMP$R_PAGE_CODE_FIELD = 0,0,8,0 %;
literal SCSI$CMP$S_PAGE_CODE_FIELD = 1; !  Page code & save bits
macro SCSI$CMP$V_PAGE_CODE = 0,0,6,0 %;
literal SCSI$CMP$S_PAGE_CODE = 6;       !  Page code
macro SCSI$CMP$V_PS = 0,7,1,0 %;        !  PS - Parameters Saveable bit in non-VM
macro SCSI$CMP$B_PAGE_LENGTH = 1,0,8,0 %; !  Page length
macro SCSI$CMP$R_CONTROL_MODE_FLAGS = 2,0,24,0 %;
literal SCSI$CMP$S_CONTROL_MODE_FLAGS = 3; !  Control Mode Flags
macro SCSI$CMP$V_RLEC = 2,0,1,0 %;      !  Targer reports log exception conditions
macro SCSI$CMP$V_DQUE = 2,8,1,0 %;      !  Disable tagged queuing
macro SCSI$CMP$V_QERR = 2,9,1,0 %;      !  Abort queue processing on CA or ACA
macro SCSI$CMP$V_QAM = 2,12,3,0 %;
literal SCSI$CMP$S_QAM = 3;             !  Queue Algorithm Modifier Field
macro SCSI$CMP$V_EAENP = 2,15,1,0 %;    !  Error - AEN
macro SCSI$CMP$V_UAAENP = 2,16,1,0 %;   !  Unit Attention - AEN
macro SCSI$CMP$V_RAENP = 2,17,1,0 %;    !  Ready - AEN
macro SCSI$CMP$V_EECA = 2,22,1,0 %;     !  Enable Extended Contingent Allegiance
macro SCSI$CMP$W_READY_AEN = 6,0,16,0 %; !  Ready AEN holdoff period
! 
!  Read-Write Error Recovery Page
! 
!  Define the error recover parameters that the target shall use during anny command
!  that performs a read-write operation.
! 
literal SCSI$ERP$M_PAGE_CODE = %X'3F';
literal SCSI$ERP$C_PAGE_CODE = 1;
literal SCSI$ERP$M_PS = %X'80';
literal SCSI$ERP$C_PAGE_LENGTH = 10;
literal SCSI$ERP$M_DCR = %X'1';
literal SCSI$ERP$M_DTE = %X'2';
literal SCSI$ERP$M_PER = %X'4';
literal SCSI$ERP$M_EER = %X'8';
literal SCSI$ERP$M_RC = %X'10';
literal SCSI$ERP$M_TB = %X'20';
literal SCSI$ERP$M_ARRE = %X'40';
literal SCSI$ERP$M_AWRE = %X'80';
literal SCSI$ERP$S_ERROR_RECOVERY = 12;
macro SCSI$ERP$R_PAGE_CODE_FIELD = 0,0,8,0 %;
literal SCSI$ERP$S_PAGE_CODE_FIELD = 1; !  Page code & save bits
macro SCSI$ERP$V_PAGE_CODE = 0,0,6,0 %;
literal SCSI$ERP$S_PAGE_CODE = 6;       !  Page code
macro SCSI$ERP$V_PS = 0,7,1,0 %;        !  PS - Parameters Saveable bit in non-VM
macro SCSI$ERP$B_PAGE_LENGTH = 1,0,8,0 %; !  Page length
macro SCSI$ERP$R_RECOVERY_FLAGS = 2,0,8,0 %;
literal SCSI$ERP$S_RECOVERY_FLAGS = 1;  !  Read-Write Error Recovery Page flags
macro SCSI$ERP$V_DCR = 2,0,1,0 %;       !  Disable error correction
macro SCSI$ERP$V_DTE = 2,1,1,0 %;       !  Disable transfer on error
macro SCSI$ERP$V_PER = 2,2,1,0 %;       !  Post error
macro SCSI$ERP$V_EER = 2,3,1,0 %;       !  Enable early correction
macro SCSI$ERP$V_RC = 2,4,1,0 %;        !  Read continuous
macro SCSI$ERP$V_TB = 2,5,1,0 %;        !  Transfer block
macro SCSI$ERP$V_ARRE = 2,6,1,0 %;      !  Automatic read relocation of blocks
macro SCSI$ERP$V_AWRE = 2,7,1,0 %;      !  Automatic write relocation of blocks
macro SCSI$ERP$B_READ_RERTY_COUNT = 3,0,8,0 %; !  Read count of retry attempts
macro SCSI$ERP$B_CORRECTION_SPAN = 4,0,8,0 %; !  Bit size of largest data error attempt
macro SCSI$ERP$B_HEAD_OFFSET_COUNT = 5,0,8,0 %; !  2's complement of head offset from track
macro SCSI$ERP$B_DATA_STROBE_OFFSET = 6,0,8,0 %; !  2's complement of data strobe offset
macro SCSI$ERP$B_WRITE_RETRY_COUNT = 8,0,8,0 %; !  Write count of retry attempts
macro SCSI$ERP$W_RECOVERY_TIME_LIMIT = 10,0,16,0 %; !  ms max. time for error recovery
! 
!  Format Device Page
! 
literal SCSI$FMT$M_PAGE_CODE = %X'3F';
literal SCSI$FMT$C_PAGE_CODE = 3;
literal SCSI$FMT$M_PS = %X'80';
literal SCSI$FMT$C_PAGE_LENGTH = 22;
literal SCSI$FMT$M_SURF = %X'10';
literal SCSI$FMT$M_RMB = %X'20';
literal SCSI$FMT$M_HSEC = %X'40';
literal SCSI$FMT$M_SSEC = %X'80';
literal SCSI$FMT$S_FORMAT_DEVICE = 24;
macro SCSI$FMT$R_PAGE_CODE_FIELD = 0,0,8,0 %;
literal SCSI$FMT$S_PAGE_CODE_FIELD = 1; !  Page code & save bits
macro SCSI$FMT$V_PAGE_CODE = 0,0,6,0 %;
literal SCSI$FMT$S_PAGE_CODE = 6;       !  Page code
macro SCSI$FMT$V_PS = 0,7,1,0 %;        !  PS - Parameters Saveable bit in non-VM
macro SCSI$FMT$B_PAGE_LENGTH = 1,0,8,0 %; !  Page length
macro SCSI$FMT$W_TRACKS = 2,0,16,0 %;   !  Tracks per Zone
macro SCSI$FMT$W_ALT_SECTORS = 4,0,16,0 %; !  Alternate Sectors per Zone
macro SCSI$FMT$W_ALT_TRACKS = 6,0,16,0 %; !  Alternate Tracks per Zone
macro SCSI$FMT$W_ALT_TRACKS_UNIT = 8,0,16,0 %; !  Alternate Tracks per Logical Unit
macro SCSI$FMT$W_SECTORS = 10,0,16,0 %; !  Sectors per Track
macro SCSI$FMT$W_SECTOR_SIZE = 12,0,16,0 %; !  Data Bytes per Physical Sector
macro SCSI$FMT$W_INTERLEAVE = 14,0,16,0 %; !  Interleave
macro SCSI$FMT$W_TRACK_SKEW = 16,0,16,0 %; !  Track Skew Factor
macro SCSI$FMT$W_CYL_SKEW = 18,0,16,0 %; !  Cylinder Skew Factor
macro SCSI$FMT$R_FLAGS = 20,0,8,0 %;
literal SCSI$FMT$S_FLAGS = 1;
macro SCSI$FMT$V_SURF = 20,4,1,0 %;     !  Sector .vs. Cylindar allocation
macro SCSI$FMT$V_RMB = 20,5,1,0 %;      !  Removeable
macro SCSI$FMT$V_HSEC = 20,6,1,0 %;     !  Hard Sector Formatting
macro SCSI$FMT$V_SSEC = 20,7,1,0 %;     !  Soft Sector Formatting
! 
!  Rigid Disk Driver Page
! 
!  The rigid disk drive geometry page specifies parameters for direct-access
!  devices employing a rigid disk drive.
! 
literal SCSI$RGD$M_PAGE_CODE = %X'3F';
literal SCSI$RGD$C_PAGE_CODE = 4;
literal SCSI$RGD$M_PS = %X'80';
literal SCSI$RGD$C_PAGE_LENGTH = 22;
literal SCSI$RGD$M_RPL = %X'3';
literal SCSI$RGD$C_DISABLED = 0;        !  Spindle Synchronization is disabled
literal SCSI$RGD$C_SLAVE = 1;           !  Synchronized-Spindle Slave
literal SCSI$RGD$C_MASTER = 2;          !  Synchronized-Spindle Master.
literal SCSI$RGD$C_CONTROL = 3;         !  Synchronized-Spindle Master Control
literal SCSI$RGD$S_RIGID_DISK = 21;
macro SCSI$RGD$R_PAGE_CODE_FIELD = 0,0,8,0 %;
literal SCSI$RGD$S_PAGE_CODE_FIELD = 1; !  Page code & save bits
macro SCSI$RGD$V_PAGE_CODE = 0,0,6,0 %;
literal SCSI$RGD$S_PAGE_CODE = 6;       !  Page code
macro SCSI$RGD$V_PS = 0,7,1,0 %;        !  PS - Parameters Saveable bit in non-VM
macro SCSI$RGD$B_PAGE_LENGTH = 1,0,8,0 %; !  Page length
macro SCSI$RGD$B_CYLINDERS = 2,0,24,1 %;
literal SCSI$RGD$S_CYLINDERS = 3;       !  Number of cylinders
macro SCSI$RGD$B_HEADS = 5,0,8,0 %;     !  Number of heads
macro SCSI$RGD$W_CYLINDER_WRITE = 6,0,16,0 %; !  Starting Cylinder-Write Precompensation
macro SCSI$RGD$W_CYLINDER_REDUCED = 8,0,16,0 %; !  Starting Cylinder-Reduced Write Current
macro SCSI$RGD$W_STEP_RATE = 10,0,16,0 %; !  Drive Step Rate
macro SCSI$RGD$W_LANDING_ZONE = 12,0,16,0 %; !  Landing Zone Cylinder
macro SCSI$RGD$R_FLAGS = 14,0,8,0 %;
literal SCSI$RGD$S_FLAGS = 1;           !  SCSI FLEXIBLE PAGE Flags
macro SCSI$RGD$V_RPL = 14,0,2,0 %;
literal SCSI$RGD$S_RPL = 2;             !  Rotational Position Locking
macro SCSI$RGD$B_ROTATIONAL_OFFSET = 15,0,8,0 %; !  Rotational Offset
macro SCSI$RGD$W_MEDIUM_ROTATION = 17,0,16,0 %; !  Medium Rotation Rate
macro SCSI$RGD$W_ROTATIONAL_OFFSET = 19,0,16,0 %; !  Rotational Offset
! 
!  Flexible Disk Page
! 
!  The flexible disk page contains parameters for control and reporting of
!  flexible disk drive parameters
! 
literal SCSI$FLX$M_PAGE_CODE = %X'3F';
literal SCSI$FLX$C_PAGE_CODE = 5;
literal SCSI$FLX$M_PS = %X'80';
literal SCSI$FLX$C_PAGE_LENGTH = 30;
literal SCSI$FLX$C_XFR_250KHZ = 64000;  !  250 kbit/second transfer rate
literal SCSI$FLX$C_XFR_300KHZ = 11265;  !  300 kbit/second transfer rate
literal SCSI$FLX$C_XFR_500KHZ = 62465;  !  500 kbit/second transfer rate
literal SCSI$FLX$C_XFR_1MHZ = 59395;    !  1 megabit/second transfer rate
literal SCSI$FLX$C_XFR_2MHZ = 53255;    !  2 megabit/second transfer rate
literal SCSI$FLX$C_XFR_5MHZ = 34835;    !  5 megabit/second transfer rate
literal SCSI$FLX$M_MO = %X'20';
literal SCSI$FLX$M_SSN = %X'40';
literal SCSI$FLX$M_TRDY = %X'80';
literal SCSI$FLX$M_SPC = %X'F00';
literal SCSI$FLX$M_PIN2 = %X'1';
literal SCSI$FLX$M_PIN34 = %X'2';
literal SCSI$FLX$M_PIN1 = %X'4';
literal SCSI$FLX$M_PIN4 = %X'8';
literal SCSI$FLX$S_FLEXIBLE_DISK = 31;
macro SCSI$FLX$R_PAGE_CODE_FIELD = 0,0,8,0 %;
literal SCSI$FLX$S_PAGE_CODE_FIELD = 1; !  Page code & save bits
macro SCSI$FLX$V_PAGE_CODE = 0,0,6,0 %;
literal SCSI$FLX$S_PAGE_CODE = 6;       !  Page code
macro SCSI$FLX$V_PS = 0,7,1,0 %;        !  PS - Parameters Saveable bit in non-VM
macro SCSI$FLX$B_PAGE_LENGTH = 1,0,8,0 %; !  Page length
macro SCSI$FLX$W_TRANSFER_RATE = 2,0,16,0 %; !  Transfer rate KHZ
!  (Note: Definitions are SCSI Endian)
macro SCSI$FLX$B_HEADS = 4,0,8,0 %;     !  Number of heads
macro SCSI$FLX$B_SECTORS_TRACK = 5,0,8,0 %; !  Sectors per track
macro SCSI$FLX$W_SECTOR_SIZE = 6,0,16,0 %; !  Data bytes per sector
macro SCSI$FLX$W_CYLINDERS = 8,0,16,0 %; !  Number of cylinders
macro SCSI$FLX$W_CYLINDER_WRITE = 10,0,16,0 %; !  Starting Cylinder-Write Precompensation
macro SCSI$FLX$W_CYLINDER_REDUCED = 12,0,16,0 %; !  Starting Cylinder-Reduced Write Current
macro SCSI$FLX$W_STEP_RATE = 14,0,16,0 %; !  Drive Step Rate
macro SCSI$FLX$B_STEP_PULSE = 16,0,8,0 %; !  Drive Step Pulse Width
macro SCSI$FLX$W_HEAD_SETTLE = 17,0,16,0 %; !  Head Settle Delay
macro SCSI$FLX$B_MOTOR_ON = 19,0,8,0 %; !  Motor on Delay
macro SCSI$FLX$B_MOTOR_OFF = 20,0,8,0 %; !  Motor off Delay
macro SCSI$FLX$R_FLAGS = 21,0,16,0 %;
literal SCSI$FLX$S_FLAGS = 2;           !  SCSI FLEXIBLE PAGE Flags
macro SCSI$FLX$V_MO = 21,5,1,0 %;       !  Motor on
macro SCSI$FLX$V_SSN = 21,6,1,0 %;      !  Starting Sector Number
macro SCSI$FLX$V_TRDY = 21,7,1,0 %;     !  True-Ready, media is accessable
macro SCSI$FLX$V_SPC = 21,8,4,0 %;
literal SCSI$FLX$S_SPC = 4;             !  Step pulse/cylinder
macro SCSI$FLX$B_WRITE_COMP = 23,0,8,0 %; !  Write Compensation
macro SCSI$FLX$B_HEAD_LOAD = 24,0,8,0 %; !  Head Load Delay
macro SCSI$FLX$B_HEAD_UNLOAD = 25,0,8,0 %; !  Head Unload delay
macro SCSI$FLX$R_PINS = 26,0,8,0 %;
literal SCSI$FLX$S_PINS = 1;
macro SCSI$FLX$V_PIN2 = 26,0,1,0 %;     !  Pin 2 of drive interface
macro SCSI$FLX$V_PIN34 = 26,1,1,0 %;    !  Pin 34 of drive interface
macro SCSI$FLX$V_PIN1 = 26,2,1,0 %;     !  Pin 1 of drive interface
macro SCSI$FLX$V_PIN4 = 26,3,1,0 %;     !  Pin 4 of drive interface
macro SCSI$FLX$W_ROTATION = 27,0,16,0 %; !  Medium Rotation Rate
! 
!  Subchannel Data Format Codes
! 
literal SCSI$SUB$C_SUBQ_CHANNEL_DATA = 0; !  Sub-Q Channel data
literal SCSI$SUB$C_CD_ROM_POSITION = 1; !  CD-ROM Current Position
literal SCSI$SUB$C_MCN = 2;             !  Media Catalog Number (UPC/Bar Code)
literal SCSI$SUB$C_ISRC = 3;            !  Track International-Standard-Recording-Code
! 
!  Sub-Q Channel Data Format
! 
literal SCSI$SUBQ$C_NOT_VALID = 0;      !  Audio status byte not supported or not valid
literal SCSI$SUBQ$C_PLAY = 1;           !  Audio play operation in progress.
literal SCSI$SUBQ$C_PAUSED = 2;         !  Audio play operation paused.
literal SCSI$SUBQ$C_COMPLETE = 3;       !  Audio play operation successfully completed.
literal SCSI$SUBQ$C_ERROR = 4;          !  Audio play operation stopped due to error.
literal SCSI$SUBQ$C_ACTIVE = 5;         !  No current audio status to return
literal SCSI$SUBQ$M_CONTROL = %X'F';
literal SCSI$SUBQ$C_PRE_EMPHASIS = 0;   !  Audio with pre-emphasis
literal SCSI$SUBQ$C_COPY_PERMITTED = 1; !  Digital copy permitted
literal SCSI$SUBQ$C_DATA_TRACK = 2;     !  Data verses audio track
literal SCSI$SUBQ$C_FOUR_CHANNEL = 3;   !  Four verses two channel audio
literal SCSI$SUBQ$M_ADR = %X'F0';
literal SCSI$SUBQ$C_UNKNOWN = 0;        !  mode information not supplied
literal SCSI$SUBQ$C_CURRENT_POS = 1;    !  Current position data (track,index,abs-addr,rel-addr)
literal SCSI$SUBQ$C_MCN = 2;            !  encodes media catalog number
literal SCSI$SUBQ$C_ISRC = 3;           !  encodes ISRC
literal SCSI$SUBQ$M_MC_VAL = %X'80';
literal SCSI$SUBQ$C_MCN_LENGTH = 32;    !  Length of Subq MCN data
literal SCSI$SUBQ$M_TC_VAL = %X'80';
literal SCSI$SUBQ$S_SUBQ_CHANNEL = 48;
macro SCSI$SUBQ$B_AUDIO_STATUS = 1,0,8,0 %; !  Audio Status
macro SCSI$SUBQ$W_DATA_LENGTH = 2,0,16,0 %; !  Sub-channel Data Length
macro SCSI$SUBQ$B_FORMAT_CODE = 4,0,8,0 %; !  Sub-channel data format code
macro SCSI$SUBQ$R_FIELD0 = 5,0,8,0 %;
literal SCSI$SUBQ$S_FIELD0 = 1;
macro SCSI$SUBQ$V_CONTROL = 5,0,4,0 %;
literal SCSI$SUBQ$S_CONTROL = 4;        !  Control
macro SCSI$SUBQ$V_ADR = 5,4,4,0 %;
literal SCSI$SUBQ$S_ADR = 4;            !  Audio Data Recorded Format
macro SCSI$SUBQ$B_TRACK = 6,0,8,0 %;    !  Current Track number
macro SCSI$SUBQ$B_INDEX = 7,0,8,0 %;    !  Current Index number
macro SCSI$SUBQ$L_ABS_ADDRESS = 8,0,32,0 %; !  Absolute CD-ROM Address
macro SCSI$SUBQ$L_REL_ADDRESS = 12,0,32,0 %; !  Track Relative CD-ROM Address
macro SCSI$SUBQ$R_FIELD1 = 16,0,8,0 %;
literal SCSI$SUBQ$S_FIELD1 = 1;
macro SCSI$SUBQ$V_MC_VAL = 16,7,1,0 %;  !  Media Catalog Valid bit
macro SCSI$SUBQ$B_MCN = 17,0,0,0 %;
literal SCSI$SUBQ$S_MCN = 15;           !  Media Catalog Number (UPC/Bar Code)
macro SCSI$SUBQ$R_FIELD2 = 32,0,8,0 %;
literal SCSI$SUBQ$S_FIELD2 = 1;
macro SCSI$SUBQ$V_TC_VAL = 32,7,1,0 %;  !  Track ISRC Valid
macro SCSI$SUBQ$B_IRRC = 33,0,0,0 %;
literal SCSI$SUBQ$S_IRRC = 15;          !  Track International-Standard-Recording-Code
 
!*** MODULE $SCSNETDEF ***
! +
!  SCS CI PPD definitions
! 
!  This structure defines offsets and fields for SCS datagrams used in the 
!  datagram handshake between remote systems.  The full format consists of
!  a port heder (See Structure PPD) followed by these definitions.  The origin
!  of this field is the beginning of user data for a normal SCS datagram
!  so that the PDT$L_DGHDRSZ may be used to determine the true origin of the 
!  packet.
! -
literal SCSNET$C_START_LEN = 62;        !  Start dg length
literal SCSNET$C_STACK_LEN = 62;        !  Stack dg length
literal SCSNET$C_ACK_LEN = 2;           !  Ack dg length
literal SCSNET$C_HSHUT_LEN = 2;         !  Host shutdown dg length
literal SCSNET$C_CACHE_LEN = 2;         !  Cache clear marker length
literal SCSNET$C_START = 0;             !  START DATAGRAM
literal SCSNET$C_STACK = 1;             !  STACK DATAGRAM
literal SCSNET$C_ACK = 2;               !  ACK DATAGRAM
literal SCSNET$C_SCS_DG = 3;            !  SCS DATAGRAM
literal SCSNET$C_SCS_MSG = 4;           !  SCS MESSAGE
literal SCSNET$C_ELOG = 5;              !  ERROR LOG DATAGRAM
literal SCSNET$C_HOSTSHUT = 6;          !  HOST SHUTDOWN DATAGRAM
literal SCSNET$C_CACHECLR = 32768;      !  CACHE CLEAR MARKER MSG
!  (8000 hex)
literal SCSNET$C_PRT_BASE = 0;          !  1st PPD Protocol Rev
literal SCSNET$C_PRT_ELOG = 1;          !  2nd rev, supports error
!  log dgs and host shutdown.
literal SCSNET$C_MIN_DGSIZ = 48;        ! Minimum allowed DG size,
!  not including the SCS header.
literal SCSNET$S_SCSNETDEF = 80;        !  Old size name - synonym
literal SCSNET$S_SCSNET = 80;
macro SCSNET$B_PPD = -32,0,0,0 %;
literal SCSNET$S_PPD = 16;              ! 16 bytes of PPD header 
macro SCSNET$W_LENGTH = -16,0,16,0 %;   ! message length (includes all 
!  bytes from scs$w_length on,
!  not including SCS$W_LENGTH)
!  (field shared by PPD)
macro SCSNET$W_MTYPE = -14,0,16,0 %;
macro SCSNET$B_SYSTEMID = -12,0,0,0 %;
literal SCSNET$S_SYSTEMID = 6;          !  Sending System ID
macro SCSNET$B_PROTOCOL = -6,0,8,0 %;   !  PPD Protocol Level
macro SCSNET$W_MAXDG = -4,0,16,0 %;     !  Max DG size
macro SCSNET$W_MAXMSG = -2,0,16,0 %;    !  Max MSG size
macro SCSNET$T_SWTYPE = 0,0,32,0 %;
literal SCSNET$S_SWTYPE = 4;            !  Software type
macro SCSNET$T_SWVERS = 4,0,32,0 %;
literal SCSNET$S_SWVERS = 4;            !  Software version
macro SCSNET$Q_SWINCARN = 8,0,0,0 %;
literal SCSNET$S_SWINCARN = 8;          !  Software incarnation #
macro SCSNET$T_HWTYPE = 16,0,32,0 %;
literal SCSNET$S_HWTYPE = 4;            !  Hardware type
macro SCSNET$B_HWVERS = 20,0,0,0 %;
literal SCSNET$S_HWVERS = 12;           !  Hardware version
macro SCSNET$Q_NODENAME = 32,0,0,0 %;
literal SCSNET$S_NODENAME = 8;          !  Node Name
macro SCSNET$Q_CURTIME = 40,0,0,0 %;
literal SCSNET$S_CURTIME = 8;           !  Current system time measured
!    in 100 nsec units
 
!*** MODULE $SDIRDEF ***
! +
!  SDIR - SCS DIRECTORY ENTRY
! 
!  THIS DATA STRUCTURE IS ALLOCATED FOR EACH LOCAL PROCESS THAT WANTS
!  TO BE KNOWN TO SCS.
! -
literal SDIR$K_LENGTH = 48;
literal SDIR$C_LENGTH = 48;
literal SDIR$S_SDIRDEF = 48;
literal SDIR$S_SDIR = 48;
macro SDIR$L_FLINK = 0,0,32,1 %;        ! FWD LINK 
macro SDIR$L_BLINK = 4,0,32,1 %;        ! BCK LINK 
macro SDIR$W_SIZE = 8,0,16,0 %;         ! STRUCTURE SIZE IN BYTES 
macro SDIR$B_TYPE = 10,0,8,0 %;         ! SCS STRUCTURE TYPE 
macro SDIR$B_SUBTYP = 11,0,8,0 %;       ! SCS STRUCTURE SUBTYPE FOR SDIR 
macro SDIR$B_PROCNAM = 12,0,0,0 %;
literal SDIR$S_PROCNAM = 16;            ! ASCII STRING FOR PROCESS NAME 
macro SDIR$B_PROCINF = 28,0,0,0 %;
literal SDIR$S_PROCINF = 16;            ! ASCII STRING FOR PROCESS INFO 
macro SDIR$L_CONID = 44,0,32,0 %;       ! CONNECTION ID 
 
!*** MODULE $SGNDEF ***
! +
!  SYSGEN PARAMETER DEFINITIONS
! -
!  
literal SGN$C_BALSETCNT = 24;           !  NUMBER OF PROCESSES IN BALANCE SET 
literal SGN$C_DFWSCNT = 100;            !  DEFAULT WORKING SET COUNT 
literal SGN$C_DFWSQUOTA = 120;          !  DEFAULT WORKING SET QUOTA 
literal SGN$C_GBLSECCNT = 40;           !  GLOBAL SECTION COUNT 
literal SGN$C_MAXGPGCNT = 2048;         !  GLOBAL PAGE COUNT (GPT SIZE) 
literal SGN$C_MAXPAGCNT = 16384;        !  PHYSICAL MEMORY SIZE IN PAGES 
literal SGN$C_MAXPGFL = 4096;           !  DEFAULT MAXIMUM PAGING FILE 
literal SGN$C_MAXPSTCNT = 5;            !  MAX NUMBER OF PST ENTRIES 
literal SGN$C_MAXVPGCNT = 8192;         !  MAX PROCESS VIRTUAL SIZE (PAGES) 
literal SGN$C_MAXWSCNT = 1024;          !  MAX WORKING SET SIZE (PAGES) 
literal SGN$C_MINWSCNT = 10;            !  MIN WORKING SET SIZE (PAGES) 
literal SGN$C_NPAGEDYN = 26624;         !  NON-PAGED DYNAMIC POOL SIZE 
literal SGN$C_NPROCS = 64;              !  MAX NUMBER OF PROCESSES 
literal SGN$C_PAGEDYN = 16384;          !  PAGED DYNAMIC POOL SIZE IN BYTES 
literal SGN$C_PHYPAGCNT = 4096;         !  ACTUAL PHYSICAL PAGE COUNT 
literal SGN$C_SYSDWSCNT = 40;           !  DEFAULT SYSTEM WORKING SET COUNT 
literal SGN$C_SYSVECPGS = 5;            !  NO. OF PAGES OF SYSTEM SERVICE VECTORS 
literal SGN$C_SYSWSCNT = 96;            !  SYSTEM WORKING SET COUNT 
 
!*** MODULE $SHADDEF ***
! ++
!  VOLUME SHADOWING STRUCTURE DEFINITIONS 
! 
! 	These definitions describe the format of a data structure
! 	that is used in the Volume Shadowing Phase II driver to maintain 
! 	status, performance, and locking information for all Phase II 
! 	shadow sets currently mounted in the cluster.
! --
literal SHAD$K_MINDEVS = 1;             !  Minimum number of devices
literal SHAD$C_MINDEVS = 1;             !  Minimum number of devices
literal SHAD$K_MINMBRS = 1;             !  Minimum number of members
literal SHAD$C_MINMBRS = 1;             !  Minimum number of members
literal SHAD$K_MAXMBRS = 3;             !  Maximum number of members
literal SHAD$C_MAXMBRS = 3;             !  Maximum number of members
literal SHAD$K_MBRSIZ = 16;
literal SHAD$C_MBRSIZ = 16;
!  Duplicate the above constants
!  Number of bits in the member status
!   fields used to determine copy type
!  Warning : Please check the shad_irp alignment at the end of this module if
! 	     max_nodes is changed.
!  CLU$C_MAX_NODES
literal LOCK$M_DEQUEUE = %X'1';
literal LOCK$M_WATCHER = %X'2';
literal LOCK$M_VALUE_UPDATE = %X'4';
literal LOCK$M_MBR_CHANGE_HERE = %X'8';
literal LOCK$M_COPY_ACTIVE = %X'10';
literal LOCK$M_STALL = %X'20';
literal LOCK$M_STALL_IP = %X'40';
literal LOCK$K_LENGTH = 80;             ! Length of Structure
literal LOCK$C_LENGTH = 80;             ! Length of Structure
literal LOCK$S_LOCKDEF = 80;            !  Lock substructure
macro LOCK$B_RESNAM_STR = 0,0,0,0 %;
literal LOCK$S_RESNAM_STR = 32;         !  Resource name string
macro LOCK$Q_RESNAM = 32,0,0,0 %;
literal LOCK$S_RESNAM = 8;              !  Resource name descriptor
macro LOCK$L_FLINK = 40,0,32,0 %;       !  CDRP queue Forward link 
macro LOCK$L_BLINK = 44,0,32,0 %;       !  CDRP Queue Backward link
macro LOCK$L_BLKADR = 48,0,32,0 %;      !  Blocking address for function
macro LOCK$L_LKSB = 52,0,32,0 %;        !  Lock status block base
macro LOCK$L_LKID = 56,0,32,0 %;        !  Lock ID
macro LOCK$L_LKVALBLK = 60,0,0,0 %;
literal LOCK$S_LKVALBLK = 16;           !  Lock value block
macro LOCK$B_STATE = 76,0,8,0 %;        !  Lock state semaphore
macro LOCK$V_DEQUEUE = 76,0,1,0 %;      !  DEQUEUE in progress
macro LOCK$V_WATCHER = 76,1,1,0 %;      !  Watcher node
macro LOCK$V_VALUE_UPDATE = 76,2,1,0 %; !  Watcher value update node
macro LOCK$V_MBR_CHANGE_HERE = 76,3,1,0 %; !  Set change in progress
macro LOCK$V_COPY_ACTIVE = 76,4,1,0 %;  !  Copy active here 
macro LOCK$V_STALL = 76,5,1,0 %;        !  Lock does stalls
macro LOCK$V_STALL_IP = 76,6,1,0 %;     !  Stall new requests until NL
literal SHAD$M_NORMAL = %X'1';
literal SHAD$M_NEW = %X'2';
literal SHAD$M_REBLDNG = %X'4';
literal SHAD$M_VERIFY = %X'8';
literal SHAD$M_MVBEGUN = %X'10';
literal SHAD$M_COPYING = %X'20';
literal SHAD$M_MERGING = %X'40';
literal SHAD$M_MINIMRG = %X'80';
literal SHAD$M_CPY_RESET = %X'100';
literal SHAD$M_BOOTING = %X'200';
literal SHAD$M_WLG = %X'400';
literal SHAD$M_INVWLG = %X'800';
literal SHAD$M_FAILED = %X'8000';
literal SHAD$M_COPY_TYPE = %X'3';
literal SHAD$M_MBR_MODIF = %X'FC';
literal SHAD$M_MBR_FCPY = %X'1';
literal SHAD$M_MBR_MERGE = %X'2';
literal SHAD$M_MBR_CIP = %X'4';
literal SHAD$M_MBR_MASTER = %X'8';
literal SHAD$M_MBR_ERROR = %X'10';
literal SHAD$M_MBR_SRC = %X'20';
literal SHAD$M_MBR_DCD = %X'40';
literal SHAD$M_MBR_VALID = %X'80';
literal SHAD$M_CA_COPY_ACTIVATED = %X'1';
literal SHAD$M_CA_LOCAL_COPY = %X'2';
literal SHAD$M_CA_REMOTE_COPY = %X'4';
literal SHAD$M_CA_COPY_PATH_EST = %X'8';
literal SHAD$M_CA_COPY_RETRY = %X'10';
literal SHAD$M_CA_COPY_DISABLE = %X'20';
literal SHAD$M_IN_PROG = %X'1';
literal SHAD$M_INITING = %X'2';
literal SHAD$M_MMB_VALID = %X'4';
literal SHAD$M_MMB_ALLOCATION_FAILED = %X'8';
literal SHAD$M_LOST_CNID = %X'10';
literal SHAD$M_TABLE_GENERATION = %X'20';
literal SHAD$M_SWITCHING = %X'40';
literal SHAD$M_FLUSH_RATE_EXCEEDED = %X'1';
literal SHAD$M_BOOT_DEVICE_GONE = %X'1';
literal SHAD$M_MASTER_EQL_BOOT_DEV = %X'2';
literal SHAD$M_QTIME_STAMP_LOC_BUSY = %X'4';
literal SHAD$M_ORIBOOTDEV_SRC_VALID = %X'8';
literal SHAD$M_MASTER_ON_BAD_ADP_PATH = %X'10';
literal SHAD$M_BOOTED_ON_EMULATED_PATH = %X'20';
literal SHAD$M_MASTER_ON_EMULATED_PATH = %X'40';
literal SHAD$M_DUMP_UNIT_NUMBER_WRITTEN = %X'80';
literal SHAD$M_NODMPDISK = %X'8000';
literal SHAD$M_EXTENDED_INVWLG = %X'1';
literal SHAD$M_EXTENDED_INVWLG_PENDING = %X'2';
literal SHAD$M_EXTENDED_RESTARTED_TRIGR = %X'4';
literal SHAD$M_EXTENDED_WLG_TO_ON = %X'8';
literal SHAD$M_EXTENDED_EP_INPROGRESS = %X'10';
literal SHAD$M_EXTENDED_EP_DONE = %X'20';
literal SHAD$M_EXTENDED_SHDCPY_GTLK_ACT = %X'40';
literal SHAD$K_LENGTH = 1228;           ! Length of Structure
literal SHAD$C_LENGTH = 1228;           ! Length of Structure
literal SHAD$S_SHADDEF = 1232;
macro SHAD$L_FLINK = 0,0,32,0 %;        !  Forward link to next SHAD
macro SHAD$L_BLINK = 4,0,32,0 %;        !  Backward link
macro SHAD$W_SIZE = 8,0,16,0 %;         !  Size of this structure
macro SHAD$B_TYPE = 10,0,8,0 %;         !  Standard fields
macro SHAD$B_SUBTYP = 11,0,8,0 %;       !   ...
macro SHAD$L_VU_UCB = 12,0,32,0 %;      !  Unit Control Block for VU
macro SHAD$L_VU_VCB = 16,0,32,0 %;      !  Volume Control Block for VU
macro SHAD$L_ACTIVE_IRPS = 20,0,32,0 %; !  Active "Master" IRPs
macro SHAD$L_BADBLOCKS = 24,0,32,0 %;   !  Number of badblocks repaired.	
macro SHAD$L_NOTIFICATION_ID = 28,0,32,0 %; !  Notification ID
macro SHAD$B_MEMBERSHIP_PERMISSION = 32,0,0,0 %;
literal SHAD$S_MEMBERSHIP_PERMISSION = 80; !  Shadow set membership change permission lock
macro SHAD$B_MEMBERSHIP_LOCK = 112,0,0,0 %;
literal SHAD$S_MEMBERSHIP_LOCK = 80;    !  Shadow set membership lock
macro SHAD$B_MEMBER_OF_SET = 192,0,0,0 %;
literal SHAD$S_MEMBER_OF_SET = 80;      !  Shadow set guaranteed member lock
macro SHAD$B_WATCHER_MEMBER_OF_SET = 272,0,0,0 %;
literal SHAD$S_WATCHER_MEMBER_OF_SET = 80; !  Shadow set guaranteed member lock for WATCHER thread
macro SHAD$B_WATCHER_LOCK = 352,0,0,0 %;
literal SHAD$S_WATCHER_LOCK = 80;       !  Shadow set membership lock watcher lock
macro SHAD$B_SEQ_CMD_PERMISSION = 432,0,0,0 %;
literal SHAD$S_SEQ_CMD_PERMISSION = 80; !  Shadow set sequential command permission lock
macro SHAD$B_SEQ_CMD_LOCK = 512,0,0,0 %;
literal SHAD$S_SEQ_CMD_LOCK = 80;       !  Shadow set sequential command lock
macro SHAD$B_COPIER_LOCK = 592,0,0,0 %;
literal SHAD$S_COPIER_LOCK = 80;        !  Shadow set copier lock
macro SHAD$B_COPIER_THRESHOLD = 672,0,0,0 %;
literal SHAD$S_COPIER_THRESHOLD = 80;   !  Copier threshold lock
macro SHAD$B_NODE_MAP = 752,0,0,0 %;
literal SHAD$S_NODE_MAP = 32;           !  Mounted node bit map
macro SHAD$L_ACTIVE_FL = 784,0,32,0 %;  !  Active Queue flink
macro SHAD$L_ACTIVE_BL = 788,0,32,0 %;  !  Active Queue bLink
macro SHAD$L_RESTART_FL = 792,0,32,0 %; !  FL for restart wait queue
macro SHAD$L_RESTART_BL = 796,0,32,0 %; !  BL for restart wait queue
! 
!  define the LAST_INDEX so that it can be used as a byte and yet maintain
!  longword alignment.
! 
macro SHAD$L_LAST_INDX = 800,0,32,0 %;  !  Tot num phys IRPs active.
macro SHAD$B_LAST_INDX = 800,0,8,0 %;   !  Tot num phys IRPs assoc.
macro SHAD$L_LAST_RINDX = 804,0,32,0 %; !  Index of last read SSM
macro SHAD$R_VECTOR = 808,0,0,0 %;
literal SHAD$S_VECTOR = 16;
macro SHAD$L_COPY_VECTOR = 808,0,32,0 %; !   Address of COPY routine
macro SHAD$L_MERGE_VECTOR = 812,0,32,0 %; !   Address of MINI-MERGE routine
macro SHAD$L_WRITE_VECTOR = 816,0,32,0 %; !   Address of WRITE Startio routine
macro SHAD$L_READ_VECTOR = 820,0,32,0 %; !   Address of DSE Startio routine
! 
!  The following fields, up to the next comment are placed contiguously in 
!  this data structure so that they can be copied from the SCB in one 
!  instruction.
! 
macro SHAD$Q_GENERNUM = 824,0,0,0 %;
literal SHAD$S_GENERNUM = 8;            !  Shadow Set generation number
macro SHAD$Q_UNIT_ID = 832,0,0,0 %;
literal SHAD$S_UNIT_ID = 8;             !   unique cluster-wide identifier
macro SHAD$W_STATUS = 840,0,16,0 %;     !  Volume status:
macro SHAD$V_NORMAL = 840,0,1,0 %;      !  Shadow set populated and online
macro SHAD$V_NEW = 840,1,1,0 %;         !  Newly created, no members yet
macro SHAD$V_REBLDNG = 840,2,1,0 %;     !  rebuilding shadow set
macro SHAD$V_VERIFY = 840,3,1,0 %;      !  This SS needs verification
macro SHAD$V_MVBEGUN = 840,4,1,0 %;     !  Mount verification initiated
macro SHAD$V_COPYING = 840,5,1,0 %;     !  Full copy in progreess
macro SHAD$V_MERGING = 840,6,1,0 %;     !  Merge copy in progress
macro SHAD$V_MINIMRG = 840,7,1,0 %;     !  Mini-merge in progress
macro SHAD$V_CPY_RESET = 840,8,1,0 %;   !  Copy mode is reset.
macro SHAD$V_BOOTING = 840,9,1,0 %;     !  Shadow set in booting state
macro SHAD$V_WLG = 840,10,1,0 %;        !  Write logging
macro SHAD$V_INVWLG = 840,11,1,0 %;     !  Spare bit for internal use
macro SHAD$V_FAILED = 840,15,1,0 %;     !  Shadow set not populated
macro SHAD$B_MEMBER_STATUS = 842,0,8,0 %; !  Member status bits
macro SHAD$V_COPY_TYPE = 842,0,2,0 %;
literal SHAD$S_COPY_TYPE = 2;           !  Function Code Field
macro SHAD$V_MBR_MODIF = 842,2,6,0 %;
literal SHAD$S_MBR_MODIF = 6;           !  Function Modifiers Field
macro SHAD$V_MBR_FCPY = 842,0,1,0 %;    !  Member involved in copy
macro SHAD$V_MBR_MERGE = 842,1,1,0 %;   !  Member being merged
macro SHAD$V_MBR_CIP = 842,2,1,0 %;     !  Copy (or merge) in progress
macro SHAD$V_MBR_MASTER = 842,3,1,0 %;  !  Member with guaranteed correct
!   SCB. Same member as MEMBERSHIP_LOCK
macro SHAD$V_MBR_ERROR = 842,4,1,0 %;   !  Error processing in progress
macro SHAD$V_MBR_SRC = 842,5,1,0 %;     !  member can be used for source
macro SHAD$V_MBR_DCD = 842,6,1,0 %;     !  Assisted copy source
macro SHAD$V_MBR_VALID = 842,7,1,0 %;   !  Status information is valid
macro SHAD$Q_MEMBER_IDS = 848,0,0,0 %;
literal SHAD$S_MEMBER_IDS = 24;         !  Unit ID for member
macro SHAD$L_SCB_LBN = 872,0,32,0 %;    !  Unit Control Block for VU
macro SHAD$B_DEVICES = 876,0,8,0 %;     !  Number of devices in SS
macro SHAD$B_MEMBERS = 877,0,8,0 %;     !  Number of full members
macro SHAD$B_MAST_INDX = 878,0,8,0 %;   !  Array index to master UCB
macro SHAD$B_MRG_TARGETS = 879,0,8,0 %; !  Merge Copy Targets
macro SHAD$B_FC_TARGETS = 880,0,8,0 %;  !  Full Copy Targets
!  Preserve quadword alignment for IRP.
!  Maintain the following array as the last part of this data structure 
!  in order to maintain the longword alignment of fields preceding it.
!  
macro SHAD$L_MEMBER_UCB = 888,0,0,0 %;
literal SHAD$S_MEMBER_UCB = 12;         !  UCB for member
macro SHAD$L_MEMBER_VCB = 900,0,0,0 %;
literal SHAD$S_MEMBER_VCB = 12;         !  VCB for member
macro SHAD$L_COPY_LBN = 912,0,0,0 %;
literal SHAD$S_COPY_LBN = 12;           !  Last LBN Copied
macro SHAD$L_PERD_LCKID = 924,0,0,0 %;
literal SHAD$S_PERD_LCKID = 12;         !  sublock id for
!  perdisk licensing
!  Command Assist Information is added at the end of the shad to be
!  backwardly compatable.
macro SHAD$L_VP_IRP = 936,0,32,0 %;     !  Volume processing master
macro SHAD$L_WLG = 940,0,0,0 %;
literal SHAD$S_WLG = 12;                !  Array of table indicators.
macro SHAD$B_WLG_INV = 952,0,0,0 %;
literal SHAD$S_WLG_INV = 80;            !  Invalidate WLG lock
macro SHAD$L_CA_COPY_STATUS = 1032,0,32,0 %; !  Command Assisted Copy Status
macro SHAD$V_CA_COPY_ACTIVATED = 1032,0,1,0 %; !   Copy activated.
macro SHAD$V_CA_LOCAL_COPY = 1032,1,1,0 %; !   Local copy.
macro SHAD$V_CA_REMOTE_COPY = 1032,2,1,0 %; !   Remote copy.
macro SHAD$V_CA_COPY_PATH_EST = 1032,3,1,0 %; !   Communication path established.
macro SHAD$V_CA_COPY_RETRY = 1032,4,1,0 %; !   Retrying last I/O on a diff disk
macro SHAD$V_CA_COPY_DISABLE = 1032,5,1,0 %; !   Disable assisted copy.
macro SHAD$L_CA_SOURCE_INDEX = 1036,0,32,0 %; !  Command Assisted Copy Source
macro SHAD$L_CA_TARGET_INDEX = 1040,0,32,0 %; !  Command Assisted Copy Target
macro SHAD$L_TQE = 1044,0,32,0 %;       !  Pointer to shadow TQE
macro SHAD$W_FAILED_CNID = 1048,0,16,0 %;
macro SHAD$L_MMB = 1056,0,32,0 %;       !  Pointer to Merge Mngmnt Block
macro SHAD$L_SRVR_IRP = 1060,0,32,0 %;  !  Shadow server I/O PTR
macro SHAD$L_MM_STS = 1064,0,32,0 %;    !  Longword boundary
macro SHAD$V_IN_PROG = 1064,0,1,0 %;    !   In-progress
macro SHAD$V_INITING = 1064,1,1,0 %;    !   Table generation phase
macro SHAD$V_MMB_VALID = 1064,2,1,0 %;  !   mmb valid
macro SHAD$V_MMB_ALLOCATION_FAILED = 1064,3,1,0 %; !   allocation failed
macro SHAD$V_LOST_CNID = 1064,4,1,0 %;  !   lost one or more cnids
macro SHAD$V_TABLE_GENERATION = 1064,5,1,0 %; !   mmb in use for table
macro SHAD$V_SWITCHING = 1064,6,1,0 %;  !   mini-merge to merge switch
! 
!  Additional count to track how many seqcmd threads are queued.
! 
macro SHAD$L_SEQCMD_THREAD_COUNT = 1068,0,32,0 %; !  Count concurrent seqcmd threads
macro SHAD$B_WLGINV_MAP = 1072,0,0,0 %;
literal SHAD$S_WLGINV_MAP = 32;         !  Node with WLG Lock
macro SHAD$L_FLUSH_COUNT = 1104,0,32,0 %; !  Flush count
macro SHAD$L_FLUSH_TICK_COUNT = 1108,0,32,0 %; !  Heart beat counter.
macro SHAD$L_FLUSH_STS = 1112,0,32,0 %; !  Longword boundary
macro SHAD$V_FLUSH_RATE_EXCEEDED = 1112,0,1,0 %; !   Flush rate exceeded
! 
!  DCD copy fence and some reserved longwords
! 
macro SHAD$L_DCD_COPY_LBN = 1116,0,32,0 %; !  DCD Copy Fence for Assisted Full Copy
macro SHAD$L_RESERVED1 = 1120,0,32,0 %; !  Reserved longword
macro SHAD$L_RESERVED2 = 1124,0,32,0 %; !  Reserved longword
macro SHAD$L_RESERVED3 = 1128,0,32,0 %; !  Reserved longword
macro SHAD$L_RESERVED4 = 1132,0,32,0 %; !  Reserved longword
macro SHAD$L_RESERVED5 = 1136,0,32,0 %; !  Reserved longword
! 
!  Warning : John Andruszkiewicz said this caused problems when SDD fields
!            were not quadword-aligned on VAX. He never determined the
! 	     actual cause of the problem...it may or may not occur on Alpha.
! 				
macro SHAD$W_SDD_STATUS = 1144,0,16,0 %; !  Master switching status:
macro SHAD$V_BOOT_DEVICE_GONE = 1144,0,1,0 %; ! 
macro SHAD$V_MASTER_EQL_BOOT_DEV = 1144,1,1,0 %; ! 
macro SHAD$V_QTIME_STAMP_LOC_BUSY = 1144,2,1,0 %; ! 
macro SHAD$V_ORIBOOTDEV_SRC_VALID = 1144,3,1,0 %; ! 
macro SHAD$V_MASTER_ON_BAD_ADP_PATH = 1144,4,1,0 %; !  
macro SHAD$V_BOOTED_ON_EMULATED_PATH = 1144,5,1,0 %; ! 
macro SHAD$V_MASTER_ON_EMULATED_PATH = 1144,6,1,0 %; ! 
macro SHAD$V_DUMP_UNIT_NUMBER_WRITTEN = 1144,7,1,0 %; ! 
macro SHAD$V_NODMPDISK = 1144,15,1,0 %; !  
macro SHAD$W_FILLER_1 = 1146,0,16,0 %;  !  For alignment
macro SHAD$L_THRESHOLD_UPDATE_TIME = 1148,0,32,0 %; ! 
macro SHAD$Q_SDD_QTIME_MASTER_GONE = 1152,0,0,0 %;
literal SHAD$S_SDD_QTIME_MASTER_GONE = 8; ! 
macro SHAD$L_EXTENDED_STATUS = 1160,0,32,0 %; ! 
macro SHAD$V_EXTENDED_INVWLG = 1160,0,1,0 %; ! 
macro SHAD$V_EXTENDED_INVWLG_PENDING = 1160,1,1,0 %; ! 
macro SHAD$V_EXTENDED_RESTARTED_TRIGR = 1160,2,1,0 %; ! 
macro SHAD$V_EXTENDED_WLG_TO_ON = 1160,3,1,0 %; ! 
macro SHAD$V_EXTENDED_EP_INPROGRESS = 1160,4,1,0 %; ! 
macro SHAD$V_EXTENDED_EP_DONE = 1160,5,1,0 %; ! 
macro SHAD$V_EXTENDED_SHDCPY_GTLK_ACT = 1160,6,1,0 %; ! 
! 
! 
macro SHAD$W_DEVSTS_MSCP_MTVERIP_CNTR = 1164,0,16,0 %; !  # of threads doing mntver
macro SHAD$W_DEVSTS_SEQCMD_THERE_CNTR = 1166,0,16,0 %; !  
macro SHAD$W_DEVSTS_PASSIVE_MV_CNTR = 1168,0,16,0 %; !  # of threads doing passive
macro SHAD$W_DEVSTS_NODE_FAILURE_CNTR = 1170,0,16,0 %; !  # of node failure threads
macro SHAD$W_DEVSTS_WLGSTA_CHA_CNTR = 1172,0,16,0 %; ! 
macro SHAD$W_DEVSTS_WLG_INV_CNTR = 1174,0,16,0 %; ! 
macro SHAD$L_TRIGGER_VALIDATE_FLINK = 1176,0,32,0 %; !  Trigger validate queue header
macro SHAD$L_TRIGGER_VALIDATE_BLINK = 1180,0,32,0 %; ! 
macro SHAD$L_SEQ_CMD_FLINK = 1184,0,32,0 %; !  sequential cmd queue header
macro SHAD$L_SEQ_CMD_BLINK = 1188,0,32,0 %; ! 
macro SHAD$L_NODE_FAILURE_FLINK = 1192,0,32,0 %; !  node failure queue header
macro SHAD$L_NODE_FAILURE_BLINK = 1196,0,32,0 %; ! 
macro SHAD$L_NODE_FAILURE_QUEUE = 1200,0,32,0 %; !  
macro SHAD$W_NODE_FAILURE_STATUS1 = 1204,0,16,0 %; ! 
macro SHAD$W_NODE_FAILURE_STATUS2 = 1206,0,16,0 %; ! 
macro SHAD$L_CONTROLLER_WLG = 1208,0,0,0 %;
literal SHAD$S_CONTROLLER_WLG = 12;     ! 
macro SHAD$Q_CONTROLLER_WLG_IOSB = 1220,0,0,0 %;
literal SHAD$S_CONTROLLER_WLG_IOSB = 8; ! 
macro SHAD$L_IRP = 1228,0,32,0 %;       !  Pointer to shadow IRP
 
!*** MODULE $SHLDEF ***
! +
!  SHL - SHAREABLE IMAGE LIST
! 
!  THIS LIST IS CREATED IN THE IMAGE FIXUP SECTION BY THE LINKER AND
!  USED BY THE IMAGE ACTIVATOR FOR DOING SHAREABLE IMAGE FIXUPS.
! -
literal SHL$M_FIXUP = %X'1';
literal SHL$C_OLD_SHL_SIZE = 56;        !  Size of "old" SHL
literal SHL$C_MAXNAMLNG = 39;           !  Maximum length of image name 
literal SHL$K_LENGTH = 64;              !  Length of shareable image list element 
literal SHL$C_LENGTH = 64;              !  Length of shareable image list element 
literal SHL$S_SHLDEF = 64;
literal SHL$S_SHL = 64;
macro SHL$L_BASEVA = 0,0,32,1 %;        !  Base address of this shareable image 
macro SHL$L_SHLPTR = 4,0,32,1 %;        !  Pointer from SHL in shareable image 
!   to associated SHL in executable image
macro SHL$L_IDENT = 8,0,32,0 %;         !  GSMATCH 
macro SHL$L_PERMCTX = 12,0,32,1 %;      !  Permanent sharable image context 
macro SHL$B_SHL_SIZE = 16,0,8,1 %;      !  Size of SHL elements
macro SHL$B_FLAGS = 19,0,8,0 %;         !  Flags
macro SHL$V_FIXUP = 19,0,1,0 %;         !  Fixups against this shareable have been done
macro SHL$L_ICB = 20,0,32,1 %;          !  Address of the image control block
macro SHL$T_IMGNAM = 24,0,0,0 %;
literal SHL$S_IMGNAM = 40;              !  Shareable image name (ASCIC string) 
macro SHL$B_NAMLNG = 24,0,8,1 %;        !  Synonym for name count 
 
!*** MODULE $SLUSHRDEF ***
!  SLU - Shared Data Structures for the serial line unit.
! 
!  SLUshr is the data structure used to bind the
!  OpenVMS YR Driver and the X.25 ZR Driver.
! 
!  Define some types so we can get the C function prototypes to return
!  the correct types.
! 
! 
!  Vectors for the SCC interrupts generated by the SIR
! 
literal SIRVEC$K_SIZE = 20;
literal SIRVEC$S_SIRvector = 20;
macro SIRVEC$A_RxOverrun = 0,0,32,0 %;
macro SIRVEC$A_RxHalfPage = 4,0,32,0 %;
macro SIRVEC$A_TxReadError = 8,0,32,0 %;
macro SIRVEC$A_TxPageEnd = 12,0,32,0 %;
macro SIRVEC$A_SCC = 16,0,32,0 %;
! 
!  Vectors describing the SCC Specific ISRs
!  
literal SCCVEC$K_SIZE = 12;
literal SCCVEC$S_SCCvector = 12;
macro SCCVEC$A_RxSpecCond = 0,0,32,0 %;
macro SCCVEC$A_Transmit = 4,0,32,0 %;
macro SCCVEC$A_ExtStatus = 8,0,32,0 %;
! 
!  Saved state of the SCC registers
! 
literal SCCSAV$K_SIZE = 64;
literal SCCSAV$S_SCCsaveReg = 64;
macro SCCSAV$L_RR0 = 0,0,32,1 %;        !  RR0 is saved, as WR0 is stateless
macro SCCSAV$L_WR1 = 4,0,32,1 %;
macro SCCSAV$L_WR2 = 8,0,32,1 %;
macro SCCSAV$L_WR3 = 12,0,32,1 %;
macro SCCSAV$L_WR4 = 16,0,32,1 %;
macro SCCSAV$L_WR5 = 20,0,32,1 %;
macro SCCSAV$L_WR6 = 24,0,32,1 %;
macro SCCSAV$L_WR7 = 28,0,32,1 %;
macro SCCSAV$L_WR8 = 32,0,32,1 %;
macro SCCSAV$L_WR9 = 36,0,32,1 %;
macro SCCSAV$L_WR10 = 40,0,32,1 %;
macro SCCSAV$L_WR11 = 44,0,32,1 %;
macro SCCSAV$L_WR12 = 48,0,32,1 %;
macro SCCSAV$L_WR13 = 52,0,32,1 %;
macro SCCSAV$L_WR14 = 56,0,32,1 %;
macro SCCSAV$L_WR15 = 60,0,32,1 %;
! 
!   This structure is shared between the YR- and ZR-Drivers
! 
literal SLUSHR$K_SIZE = 172;
literal SLUSHR$S_SLUshr = 172;
macro SLUSHR$R_SIRvec = 0,0,0,0 %;
literal SLUSHR$S_SIRvec = 20;           !  SIR interrupt vectors
macro SLUSHR$R_SCCvec = 20,0,0,0 %;
literal SLUSHR$S_SCCvec = 24;           !  SCC interupt vectors
macro SLUSHR$R_SCCsav = 44,0,0,0 %;
literal SLUSHR$S_SCCsav = 128;          !  Save SCC registers
macro SLUshrPtr = 0,0,32,0 %;
! 
!  PROTOTYPE
! 
%if not %declared(%quote SDL$$SLUSHRDEF_REQ) %then
! MACRO to emit warning and default to 0 if required argument is missing
!
macro
SDL$$SLUSHRDEF_REQ(ARG1, arg2) =
    %IF not %NULL(ARG1) %THEN ARG1
    %else
	%warn(%string('REQUIRED ARGUMENT ', %NAME(ARG2), ' MISSING')) 0
    %FI %;
%fi
 
%if not %declared(%quote SDL$$SLUSHRDEF_OPT) %then
! Defaults omitted arguments to 0 if followed by additional arguments
!
macro
SDL$$SLUSHRDEF_OPT[ARG] =
    %IF %NULL(ARG)
    %THEN
	%IF NOT %NULL(%REMAINING)
	%THEN
	    0
	%FI
    %ELSE
	ARG
    %FI %;
%fi
 
%if not %declared(%quote SDL$$SLUSHRDEF_LIST_0_REQ) %then
! Handles LIST parameters that are also OPTIONAL
!
macro
SDL$$SLUSHRDEF_LIST_0_REQ(ARG) =
    %IF NOT %NULL(ARG) %THEN %REMOVE(ARG) %FI %;
%fi
 
%if not %declared(%quote SDL$$SLUSHRDEF_LIST_1_REQ) %then
! Handles LIST parameters that are not OPTIONAL
! Emits warning and defaults to 0 if required argument is missing
!
macro
SDL$$SLUSHRDEF_LIST_1_REQ(ARG, ARG2) =
    %IF %NULL(ARG) %THEN
	 %warn(%string('REQUIRED ARGUMENT ', %NAME(ARG2), ' MISSING')) 0
    %ELSE
        SDL$$SLUSHRDEF_LIST_0_REQ(ARG) %FI %;
%fi
 
%if not %declared(%quote SDL$$SLUSHRDEF_CONCAT) %then
! Eliminates trailing null arguments
!
macro
SDL$$SLUSHRDEF_CONCAT[ARG] =
    %IF NOT %NULL(ARG) %THEN ARG %FI %;
%fi
 
!             ***********************************	
 
KEYWORDMACRO $ATTACH_TTA1 (ShrTablePtr) =
   BEGIN
   EXTERNAL ROUTINE ZR$ATTACH_TTA1 : BLISS ADDRESSING_MODE (GENERAL);
	   ZR$ATTACH_TTA1 (SDL$$SLUSHRDEF_CONCAT( SDL$$SLUSHRDEF_REQ(ShrTablePtr, %QUOTE ShrTablePtr) ))
   END %;
 
!  VAX/DEC CMS REPLACEMENT HISTORY, Element SLUSHRDEF.SDL
!  *3     6-JUL-1993 14:27:06 MUGGERIDGE "Cosmetic change."
!  *2     5-JUL-1993 17:39:07 MUGGERIDGE " Added entry point description for zr$attach_tta1()."
!  *1    23-JUN-1993 09:57:58 MUGGERIDGE "Shared data structures for the YR and ZR drivers"
!  VAX/DEC CMS REPLACEMENT HISTORY, Element SLUSHRDEF.SDL
 
!*** MODULE $SLVDEF ***
! 
! 
!  Define symbolic offsets for System Loadable Vectors.  These symbols
!  are used by the various pieces of the loadable EXEC, notably SCSVEC,
!  to create a list of vectors in system space and a corresponding image
!  that will be loaded into pool and connected to the system vectors.
! 
! 
literal SLV$K_LENGTH = 676;             !  SLV$K_LENGTH
literal SLV$S_SLV = 676;
macro SLV$L_CODESIZE = 0,0,32,0 %;      !  Loadable image size (in bytes)
macro SLV$L_INITRTN = 4,0,32,0 %;       !  Offset to init. routine
macro SLV$W_SIZE = 8,0,16,0 %;          !  Same as SLV$L_CODESIZE
macro SLV$B_TYPE = 10,0,8,0 %;          !  Structure type (DYN$C_LOADCODE)
macro SLV$B_SUBTYP = 11,0,8,0 %;        !  Sturcture Subtype
macro SLV$B_PROT_R = 12,0,8,0 %;        !  writeable protection for image
macro SLV$B_PROT_W = 13,0,8,0 %;        !  read-only protection for image
macro SLV$W_SPARE = 14,0,16,0 %;        !  spare field for future use
macro SLV$A_SYSVECS = 16,0,32,0 %;      !  address of vectors in SYS.EXE
macro SLV$T_FACILITY = 20,0,0,0 %;
literal SLV$S_FACILITY = 16;            !  facility name (.ASCIC)
macro SLV$T_LIST = 36,0,0,0 %;
literal SLV$S_LIST = 640;               !  Start of vector list (MAXVEC*5)
! 
! 
!  Define vector type codes.  The codes LODUMMY and HIDUMMY are
!  used as placeholders, to make the definition of the upper and
!  lower bound vector type symbols automatic.  New vector type codes
!  should be added at the end of the list, but before HIDUMMY.
! 
! 
literal SLV$K_LODUMMY = 0;              !  
literal SLV$K_LDATA = 1;                !  Longword pointer to data
literal SLV$K_AJUMP = 2;                !  Aligned jump
literal SLV$K_UJUMP = 3;                !  Unaligned jump
literal SLV$K_SDATA = 4;                !  Specified data
literal SLV$K_SJUMP = 5;                !  Specified jump
literal SLV$K_HIDUMMY = 6;              ! 
literal SLV$K_MINTYPE = 1;              !  Lower bound of vector type codes
literal SLV$K_MAXTYPE = 5;              !  Upper bount of vector type codes
literal SLV$K_MAXVEC = 128;             !  Max. # of vectors in list.
 
!*** MODULE $SMBDEF ***
!  Symbiont interface definitions
! +
!  Symbolic definitions for the symbiont to job controller interface.
! 
! 	Public definitions of message types, item codes, and
! 	other constants utilied by the symbiont to job controller
! 	interface facility.
! 
! -
! 
! 	Structure level
! 
literal SMBMSG$K_STRUCTURE_LEVEL = 1;   !  Current structure level
literal SMBMSG$K_STRUCTURE_LEVEL_1 = 1; !  Structure level 1
literal SMBMSG$K_ARCH_MAX_STREAMS = 32; !  Architected maximum streams per symbiont
! 
! 	Request header
! 
literal SMBMSG$K_PAUSE_TASK = 1;        !   - STOP /QUEUE
literal SMBMSG$K_RESET_STREAM = 2;      !   - STOP /QUEUE /RESET
literal SMBMSG$K_RESUME_TASK = 3;       !   - START /QUEUE (when paused)
literal SMBMSG$K_START_STREAM = 4;      !   - START /QUEUE (when stopped)
literal SMBMSG$K_START_TASK = 5;        !   - task available
literal SMBMSG$K_STOP_STREAM = 6;       !   - STOP /QUEUE /NEXT
literal SMBMSG$K_STOP_TASK = 7;         !   - STOP /QUEUE /ABORT or /REQUEUE
literal SMBMSG$K_TASK_COMPLETE = 8;     !   - stream is idle
literal SMBMSG$K_TASK_STATUS = 9;       !   - asynchronous status update
literal SMBMSG$K_START_SYMBIONT = 10;   !   - symbiont creation confirmation
literal SMBMSG$K_JOB_REQUEST = 11;      !   - request a job to be executed
literal SMBMSG$K_MAX_REQUEST_CODE = 12; !  MUST BE LAST
literal SMBMSG$S_REQUEST_HEADER = 12;
macro SMBMSG$W_REQUEST_CODE = 0,0,16,0 %; !  Request code
!   Define request codes
macro SMBMSG$B_STRUCTURE_LEVEL = 2,0,8,0 %; !  Message structure level
macro SMBMSG$B_STREAM_INDEX = 3,0,8,0 %; !  Stream index
macro SMBMSG$L_SYMBIONT_ID = 4,0,32,0 %; !  Symbiont identification
macro SMBMSG$L_JOB_ID = 8,0,32,0 %;     !  Job number (or 0 if a queue-oriented request)
! 
! 	Item header
! 
literal SMBMSG$K_ACCOUNTING_DATA = 1;   !   - accounting information
literal SMBMSG$K_ACCOUNT_NAME = 2;      !   - account name
literal SMBMSG$K_AFTER_TIME = 3;        !   - /AFTER value
literal SMBMSG$K_ALIGNMENT_PAGES = 4;   !   - /ALIGN count
literal SMBMSG$K_BOTTOM_MARGIN = 5;     !   - trailing blank lines
literal SMBMSG$K_CHARACTERISTICS = 6;   !   - /CHARACTERISTICS value
literal SMBMSG$K_CHECKPOINT_DATA = 7;   !   - checkpoint information
literal SMBMSG$K_CONDITION_VECTOR = 8;  !   - task error messages
literal SMBMSG$K_DEVICE_NAME = 9;       !   - /ON value
literal SMBMSG$K_DEVICE_STATUS = 10;    !   - device status
literal SMBMSG$K_ENTRY_NUMBER = 11;     !   - job entry number
literal SMBMSG$K_EXECUTOR_QUEUE = 12;   !   - this output queue
literal SMBMSG$K_FILE_COPIES = 13;      !   - /COPIES value
literal SMBMSG$K_FILE_COUNT = 14;       !   - current file copy number
literal SMBMSG$K_FILE_SETUP_MODULES = 15; !   - file setup module list
literal SMBMSG$K_FIRST_PAGE = 16;       !   - first page to print
literal SMBMSG$K_FORM_LENGTH = 17;      !   - lines per page
literal SMBMSG$K_FORM_NAME = 18;        !   - name of physical form
literal SMBMSG$K_FORM_SETUP_MODULES = 19; !   - form setup module list
literal SMBMSG$K_FORM_WIDTH = 20;       !   - columns per line
literal SMBMSG$K_FILE_IDENTIFICATION = 21; !   - device, fid, and did
literal SMBMSG$K_FILE_SPECIFICATION = 22; !   - file name
literal SMBMSG$K_JOB_COPIES = 23;       !   - /JOB_COUNT value
literal SMBMSG$K_JOB_COUNT = 24;        !   - current job copy number
literal SMBMSG$K_JOB_NAME = 25;         !   - /NAME value
literal SMBMSG$K_JOB_RESET_MODULES = 26; !   - job reset module list
literal SMBMSG$K_LAST_PAGE = 27;        !   - last page to print
literal SMBMSG$K_LEFT_MARGIN = 28;      !   - leading blank columns
literal SMBMSG$K_LIBRARY_SPECIFICATION = 29; !   - library name
literal SMBMSG$K_MAXIMUM_STREAMS = 30;  !   - maximum supported symbiont
literal SMBMSG$K_MESSAGE_VECTOR = 31;   !   - error messages to print
literal SMBMSG$K_NOTE = 32;             !   - /NOTE value
literal SMBMSG$K_PAGE_SETUP_MODULES = 33; !   - page setup module list
literal SMBMSG$K_PARAMETER_1 = 34;      !   - user parameter 1
literal SMBMSG$K_PARAMETER_2 = 35;      !   - user parameter 2
literal SMBMSG$K_PARAMETER_3 = 36;      !   - user parameter 3
literal SMBMSG$K_PARAMETER_4 = 37;      !   - user parameter 4
literal SMBMSG$K_PARAMETER_5 = 38;      !   - user parameter 5
literal SMBMSG$K_PARAMETER_6 = 39;      !   - user parameter 6
literal SMBMSG$K_PARAMETER_7 = 40;      !   - user parameter 7
literal SMBMSG$K_PARAMETER_8 = 41;      !   - user parameter 8
literal SMBMSG$K_PRINT_CONTROL = 42;    !   - printing control
literal SMBMSG$K_PRIORITY = 43;         !   - queue priority
literal SMBMSG$K_QUEUE = 44;            !   - generic queue name
literal SMBMSG$K_REFUSE_REASON = 45;    !   - reason task refused
literal SMBMSG$K_RELATIVE_PAGE = 46;    !   - /BACKWARD, /FORWARD values
literal SMBMSG$K_REQUEST_CONTROL = 47;  !   - request control
literal SMBMSG$K_REQUEST_RESPONSE = 48; !   - request code being responded to
literal SMBMSG$K_RIGHT_MARGIN = 49;     !   - trailing blank columns
literal SMBMSG$K_SEARCH_STRING = 50;    !   - /SEARCH value
literal SMBMSG$K_SEPARATION_CONTROL = 51; !   - separation control
literal SMBMSG$K_STOP_CONDITION = 52;   !   - reason for print abort
literal SMBMSG$K_TIME_QUEUED = 53;      !   - time queued
literal SMBMSG$K_TOP_MARGIN = 54;       !   - leading blank lines
literal SMBMSG$K_UIC = 55;              !   - UIC of submittor
literal SMBMSG$K_USER_NAME = 56;        !   - username
literal SMBMSG$K_CHECKPOINT_FREQUENCY = 57; !   - pages per checkpoint
literal SMBMSG$K_QUEUING_CONTROL = 58;  !   - queuing control
literal SMBMSG$K_RETRY_TIME = 59;       !   - delta time at which symbiont should retry job
literal SMBMSG$K_DEVICE_CONDITION = 60; !   - device error messages
literal SMBMSG$K_MESSAGE_FILE = 61;     !   - symbiont's message file
literal SMBMSG$K_AGENT_PROFILE = 62;    !   - security info
literal SMBMSG$K_CPU_LIMIT = 63;
literal SMBMSG$K_FILE_SEPARATION = 64;
literal SMBMSG$K_LOG_QUEUE = 65;
literal SMBMSG$K_LOG_SPECIFICATION = 66;
literal SMBMSG$K_LOG_SPOOL = 67;
literal SMBMSG$K_OPERATOR_REQUEST = 68;
literal SMBMSG$K_WSDEFAULT = 69;
literal SMBMSG$K_WSEXTENT = 70;
literal SMBMSG$K_WSQUOTA = 71;
literal SMBMSG$K_FILE_ATTRIBUTES = 72;
literal SMBMSG$K_FILE_ATTRIBUTES_SIZE = 73;
literal SMBMSG$K_JOB_ATTRIBUTES = 74;
literal SMBMSG$K_JOB_ATTRIBUTES_SIZE = 75;
literal SMBMSG$K_QUEUE_ATTRIBUTES = 76;
literal SMBMSG$K_QUEUE_ATTRIBUTES_SIZE = 77;
literal SMBMSG$K_SUBMITTER_EPID = 78;
! 
literal SMBMSG$K_MAX_ITEM_CODE = 79;    !  MUST BE LAST
literal SMBMSG$S_SMBMSG_ITEM_HEADER = 4;
macro SMBMSG$W_ITEM_SIZE = 0,0,16,0 %;  !  Item size
macro SMBMSG$W_ITEM_CODE = 2,0,16,0 %;  !  Item code
!   Define item codes
literal SMBMSG$S_ITEM_HEADER = 4;       !  Size (using prior aggregate name)
! 
! 	ACCOUNTING_DATA item
! 
literal SMBMSG$S_ACCOUNTING_DATA = 16;
macro SMBMSG$L_PAGES_PRINTED = 0,0,32,0 %; !  Pages printed
macro SMBMSG$l_qio_puts = 4,0,32,0 %;   !  Lines printed
macro SMBMSG$l_rms_gets = 8,0,32,0 %;   !  File reads
macro SMBMSG$L_CPU_TIME = 12,0,32,0 %;  !  Processor time
! 
! 	CHECKPOINT_DATA item
! 
literal SMBMSG$S_CHECKPOINT_DATA = 24;
macro SMBMSG$B_FILLER = 0,0,8,0 %;      !  Reserved
macro SMBMSG$B_CHECKPOINT_LEVEL = 1,0,8,0 %; !  Checkpoint structure level
macro SMBMSG$W_OFFSET = 2,0,16,0 %;     !  Offset into record
macro SMBMSG$L_CARCON = 4,0,32,0 %;     !  Carriage control
macro SMBMSG$L_PAGE = 8,0,32,0 %;       !  Page number
macro SMBMSG$L_RECORD_NUMBER = 12,0,32,0 %; !  Record number
macro SMBMSG$Q_USER_KEY = 16,0,0,1 %;
literal SMBMSG$S_USER_KEY = 8;          !  User positioning key
! 
! 	DEVICE_STATUS item
! 
literal SMBMSG$M_LOWERCASE = %X'1';
literal SMBMSG$M_PAUSE_TASK = %X'2';
literal SMBMSG$M_REMOTE = %X'4';
literal SMBMSG$M_SERVER = %X'8';
literal SMBMSG$M_STALLED = %X'10';
literal SMBMSG$M_STOP_STREAM = %X'20';
literal SMBMSG$M_TERMINAL = %X'40';
literal SMBMSG$M_UNAVAILABLE = %X'80';
literal SMBMSG$M_SYM_NOTIFIES = %X'100';
literal SMBMSG$M_SYM_REQUESTS_OPER = %X'200';
literal SMBMSG$M_SYM_COPIES_FILE = %X'400';
literal SMBMSG$M_SYM_COPIES_JOB = %X'800';
literal SMBMSG$M_SYM_ACCEPTS_ALL_FORMS = %X'1000';
literal SMBMSG$M_SYM_NO_JOB_CHECKPOINT = %X'2000';
literal SMBMSG$M_SYM_ALL_CHARACTERISTIC = %X'4000';
literal SMBMSG$M_NOTIFY_ON_INTERRUPT = %X'8000';
literal SMBMSG$S_DEVICE_STATUS = 4;
macro SMBMSG$L_DEVICE_FLAGS = 0,0,32,0 %; !  Device flags
macro SMBMSG$V_LOWERCASE = 0,0,1,0 %;   !   - supports lowercase
macro SMBMSG$V_PAUSE_TASK = 0,1,1,0 %;  !   - symbiont initiated pause
macro SMBMSG$V_REMOTE = 0,2,1,0 %;      !   - device is remote
macro SMBMSG$V_SERVER = 0,3,1,0 %;      !   - server symbiont
macro SMBMSG$V_STALLED = 0,4,1,0 %;     !   - task stalled
macro SMBMSG$V_STOP_STREAM = 0,5,1,0 %; !   - symbiont requesting stop stream
macro SMBMSG$V_TERMINAL = 0,6,1,0 %;    !   - device is a terminal
macro SMBMSG$V_UNAVAILABLE = 0,7,1,0 %; !   - device unavailable
macro SMBMSG$V_SYM_NOTIFIES = 0,8,1,0 %; !   - Symbiont notifies for job completions
macro SMBMSG$V_SYM_REQUESTS_OPER = 0,9,1,0 %; !   - Symbiont generates operator messages
macro SMBMSG$V_SYM_COPIES_FILE = 0,10,1,0 %; !   - Symbiont generates multiple file copies
macro SMBMSG$V_SYM_COPIES_JOB = 0,11,1,0 %; !   - Symbiont generates multiple job copies
macro SMBMSG$V_SYM_ACCEPTS_ALL_FORMS = 0,12,1,0 %; !   - Symbiont processes all form types
macro SMBMSG$V_SYM_NO_JOB_CHECKPOINT = 0,13,1,0 %; !   - Always reprocess full job on a restart
macro SMBMSG$V_SYM_ALL_CHARACTERISTIC = 0,14,1,0 %; !   - Symbiont processes all characteristics
macro SMBMSG$V_NOTIFY_ON_INTERRUPT = 0,15,1,0 %; !   - Symbiont notifies user on job interrupt
! 
! 	PRINT_CONTROL item
! 
literal SMBMSG$M_DOUBLE_SPACE = %X'1';
literal SMBMSG$M_PAGE_HEADER = %X'2';
literal SMBMSG$M_PAGINATE = %X'4';
literal SMBMSG$M_PASSALL = %X'8';
literal SMBMSG$M_SEQUENCED = %X'10';
literal SMBMSG$M_SHEET_FEED = %X'20';
literal SMBMSG$M_TRUNCATE = %X'40';
literal SMBMSG$M_WRAP = %X'80';
literal SMBMSG$M_RECORD_BLOCKING = %X'100';
literal SMBMSG$M_PAGE_FOOTER = %X'200';
literal SMBMSG$M_DELETE_FILE = %X'400';
literal SMBMSG$M_LOWERCASE_EXPLICIT = %X'800';
literal SMBMSG$M_NOTIFY = %X'1000';
literal SMBMSG$M_RESTART = %X'2000';
literal SMBMSG$M_JOB_RETAIN = %X'4000';
literal SMBMSG$M_JOB_ERROR_RETAIN = %X'8000';
literal SMBMSG$S_PRINT_CONTROL = 4;
macro SMBMSG$L_PRINT_FLAGS = 0,0,32,0 %; !  Print flags
macro SMBMSG$V_DOUBLE_SPACE = 0,0,1,0 %; !   - double space
macro SMBMSG$V_PAGE_HEADER = 0,1,1,0 %; !   - print page headers
macro SMBMSG$V_PAGINATE = 0,2,1,0 %;    !   - insert <FF>'s
macro SMBMSG$V_PASSALL = 0,3,1,0 %;     !   - binary print file
macro SMBMSG$V_SEQUENCED = 0,4,1,0 %;   !   - print sequence numbers
macro SMBMSG$V_SHEET_FEED = 0,5,1,0 %;  !   - pause at every TOF
macro SMBMSG$V_TRUNCATE = 0,6,1,0 %;    !   - truncate on overflow
macro SMBMSG$V_WRAP = 0,7,1,0 %;        !   - wrap on overflow
macro SMBMSG$V_RECORD_BLOCKING = 0,8,1,0 %; !   - block records in output buffer
macro SMBMSG$V_PAGE_FOOTER = 0,9,1,0 %; !   - print page footers
macro SMBMSG$V_DELETE_FILE = 0,10,1,0 %; !   - delete file after printing
macro SMBMSG$V_LOWERCASE_EXPLICIT = 0,11,1,0 %; !   - job for printer that supports lowercase
macro SMBMSG$V_NOTIFY = 0,12,1,0 %;     !   - notify user when job completes
macro SMBMSG$V_RESTART = 0,13,1,0 %;    !   - restart job after crash or requeue
macro SMBMSG$V_JOB_RETAIN = 0,14,1,0 %; !   - per job retain
macro SMBMSG$V_JOB_ERROR_RETAIN = 0,15,1,0 %; !   - per job retain on error
! 
! 	REQUEST_CONTROL item
! 
literal SMBMSG$M_ALIGNMENT_MASK = %X'1';
literal SMBMSG$M_PAUSE_COMPLETE = %X'2';
literal SMBMSG$M_RESTARTING = %X'4';
literal SMBMSG$M_TOP_OF_FILE = %X'8';
literal SMBMSG$S_REQUEST = 4;
macro SMBMSG$L_REQUEST_FLAGS = 0,0,32,0 %; !  Print flags
macro SMBMSG$V_ALIGNMENT_MASK = 0,0,1,0 %; !   - print A's and 9's
macro SMBMSG$V_PAUSE_COMPLETE = 0,1,1,0 %; !   - pause when request complete
macro SMBMSG$V_RESTARTING = 0,2,1,0 %;  !   - job is restarting
macro SMBMSG$V_TOP_OF_FILE = 0,3,1,0 %; !   - rewind before resume
! 
! 	SEPARATION_CONTROL item
! 
literal SMBMSG$M_FILE_BURST = %X'1';
literal SMBMSG$M_FILE_FLAG = %X'2';
literal SMBMSG$M_FILE_TRAILER = %X'4';
literal SMBMSG$M_FILE_TRAILER_ABORT = %X'8';
literal SMBMSG$M_JOB_FLAG = %X'10';
literal SMBMSG$M_JOB_BURST = %X'20';
literal SMBMSG$M_JOB_RESET = %X'40';
literal SMBMSG$M_JOB_RESET_ABORT = %X'80';
literal SMBMSG$M_JOB_TRAILER = %X'100';
literal SMBMSG$M_JOB_TRAILER_ABORT = %X'200';
literal SMBMSG$M_FIRST_FILE_OF_JOB = %X'400';
literal SMBMSG$M_LAST_FILE_OF_JOB = %X'800';
literal SMBMSG$S_SEPARATION_CONTROL = 4;
macro SMBMSG$L_SEPARATION_FLAGS = 0,0,32,0 %; !  Print flags
macro SMBMSG$V_FILE_BURST = 0,0,1,0 %;  !   - print file burst page
macro SMBMSG$V_FILE_FLAG = 0,1,1,0 %;   !   - print file flag page
macro SMBMSG$V_FILE_TRAILER = 0,2,1,0 %; !   - print file trailer page
macro SMBMSG$V_FILE_TRAILER_ABORT = 0,3,1,0 %; !   - print file trailer page
macro SMBMSG$V_JOB_FLAG = 0,4,1,0 %;    !   - print job flag page
macro SMBMSG$V_JOB_BURST = 0,5,1,0 %;   !   - print job burst page
macro SMBMSG$V_JOB_RESET = 0,6,1,0 %;   !   - execute job reset sequence
macro SMBMSG$V_JOB_RESET_ABORT = 0,7,1,0 %; !   - execute job reset sequence
macro SMBMSG$V_JOB_TRAILER = 0,8,1,0 %; !   - print job trailer page
macro SMBMSG$V_JOB_TRAILER_ABORT = 0,9,1,0 %; !   - print job trailer page
macro SMBMSG$V_FIRST_FILE_OF_JOB = 0,10,1,0 %; !   - this is the first file of the current job
macro SMBMSG$V_LAST_FILE_OF_JOB = 0,11,1,0 %; !   - this is the last file of the current job
! 
! 	QUEUING_CONTROL item
! 
literal SMBMSG$M_RETAIN_JOB = %X'1';
literal SMBMSG$S_QUEUING_CONTROL = 4;
macro SMBMSG$L_QUEUING_FLAGS = 0,0,32,0 %; !  Queuing flags
macro SMBMSG$V_RETAIN_JOB = 0,0,1,0 %;  !   - symbiont retained job on "fixable" error
 
!*** MODULE SNAPFKVECDEF ***
literal SNAPFKVEC$K_TIMEOUT = 15;       !  MAXIMUM DELAY TIME
literal SNAPFKVEC$K_LENGTH = 32;        ! LENGTH OF OVERHEAD AREA
literal SNAPFKVEC$C_LENGTH = 32;        ! LENGTH OF OVERHEAD AREA
literal SNAPFKVEC$S_SNAPFKVECDEF = 32;
literal SNAPFKVEC$S_SNAPFKVEC = 32;
macro SNAPFKVEC$L_FQFL = 0,0,32,1 %;    ! FORK QUEUE FORWARD LINK 
macro SNAPFKVEC$L_FQBL = 4,0,32,1 %;    ! FORK QUEUE BACKWARD LINK 
macro SNAPFKVEC$W_SIZE = 8,0,16,0 %;    ! SIZE OF BLOCK IN BYTES 
macro SNAPFKVEC$W_TYPE = 10,0,16,0 %;   ! STRUCTURE TYPE
macro SNAPFKVEC$L_REFCNT = 12,0,32,0 %; ! REFERENCE COUNT
macro SNAPFKVEC$L_COUNT = 16,0,32,0 %;  ! MAXIMUM VECTOR INDEX
macro SNAPFKVEC$W_EVENT = 20,0,16,0 %;  ! CURRENT EVENT CODE
macro SNAPFKVEC$W_SEED = 22,0,16,0 %;   ! SEQUENCE SEED
macro SNAPFKVEC$L_STATUS = 24,0,32,0 %; ! ABORT STATUS
macro SNAPFKVEC$L_VECTOR = 28,0,32,1 %; ! BEGINNING OF VECTOR AREA
! THE VECTOR AREA SIZE IS "COUNT" LONGWORDS
 
!*** MODULE SNAPSTATEDEF ***
literal SNAPSTATE$M_ACTIVE = %X'1';
literal SNAPSTATE$M_NORETURN = %X'2';
literal SNAPSTATE$M_ABORT = %X'4';
literal SNAPSTATE$M_RESUME = %X'8';
literal SNAPSTATE$M_POWER = %X'10';
literal SNAPSTATE$M_WATCHDOG = %X'20';
literal SNAPSTATE$M_ENABLEWATCH = %X'40';
literal SNAPSTATE$M_DEBUG = %X'80';
literal SNAPSTATE$M_CLEANUP = %X'100';
literal SNAPSTATE$S_SNAPSTATEDEF = 4;
literal SNAPSTATE$S_SNAPSTATE = 4;
macro SNAPSTATE$V_ACTIVE = 0,0,1,0 %;   !  Snapshot process is active
macro SNAPSTATE$V_NORETURN = 0,1,1,0 %; !  Snapshot is committed and an abort is not possible
macro SNAPSTATE$V_ABORT = 0,2,1,0 %;    !  Snapshot being aborted
macro SNAPSTATE$V_RESUME = 0,3,1,0 %;   !  O.K. to resume other processes.
macro SNAPSTATE$V_POWER = 0,4,1,0 %;    !  Powerfail exception in progress
macro SNAPSTATE$V_WATCHDOG = 0,5,1,0 %; !  Snapshot watchdog is active (set by the watchdog process)
macro SNAPSTATE$V_ENABLEWATCH = 0,6,1,0 %; !  Snapshot watchdog is enabled (set by the snapshot process)
macro SNAPSTATE$V_DEBUG = 0,7,1,0 %;    !  Snapshot watchdog may detect erroneous timeouts caused by the debugger
macro SNAPSTATE$V_CLEANUP = 0,8,1,0 %;  !  Snapshot cleanup process has been started
 
!*** MODULE $SPDTDEF ***
! +
!  SPDT - SCSI Port Descriptor Table
! 
!  There is one SPDT per port. The SPDT contains the SCSI port information
!  for one SCSI port. SPDT's are created by the unit init routines
!  of the individual port drivers. During initialization the port driver's
!  port routine entry points are initialized in the SPDT. The class drivers
!  execute these entry points to interact with the underlying port hardware.
! 
!  This structure is read accessable to the class driver and readable and
!  writeable by the port driver.
! 
!  ***NOTE1:**** New SPDT fields must be entered at the end of the data structure.
! 
!  ***NOTE2:**** If an INCOMPATIBLE CHANGE is made to this structure bump
! 		 the version number of this structure.
! -
literal SPDT$C_VERSION = 9;             !  Compatible version number.
literal SPDT$C_TYPE_PKS = 1;            !  SCSI KZTSA/KZPSA (SimPort)
literal SPDT$C_TYPE_PKC = 2;            !  SCSI NCR 53C94 Port
literal SPDT$C_TYPE_PKZ = 3;            !  SCSI KZXZA NCR 53C710 Port
literal SPDT$C_TYPE_PKT = 4;            !  SCSI NCR 53C710 Port
literal SPDT$C_TYPE_PKJ = 5;            !  SCSI ADAPTEC 1742A Port
literal SPDT$C_TYPE_PKE = 6;            !  SCSI NCR 53C810 Port
literal SPDT$C_TYPE_PKQ = 7;            !  SCSI QLogic ISP1020 Port
literal SPDT$M_PFLG_SYNCH = %X'1';
literal SPDT$M_PFLG_ASYNCH = %X'2';
literal SPDT$M_PFLG_MAPPING_REG = %X'4';
literal SPDT$M_PFLG_BUF_DMA = %X'8';
literal SPDT$M_PFLG_DIR_DMA = %X'10';
literal SPDT$M_PFLG_AEN = %X'20';
literal SPDT$M_PFLG_LUNS = %X'40';
literal SPDT$M_PFLG_CMDQ = %X'80';
literal SPDT$M_PFLG_AUTOSENSE = %X'100';
literal SPDT$M_PFLG_PORT_AUTOSENSE = %X'200';
literal SPDT$M_PFLG_SMART_PORT = %X'400';
literal SPDT$M_PFLG_DIPL = %X'800';
literal SPDT$M_STS_ONLINE = %X'1';
literal SPDT$M_STS_TIMOUT = %X'2';
literal SPDT$M_STS_ERLOGIP = %X'4';
literal SPDT$M_STS_CANCEL = %X'8';
literal SPDT$M_STS_POWER = %X'10';
literal SPDT$M_STS_BSY = %X'20';
literal SPDT$M_STS_FAILED = %X'40';
literal SPDT$M_STS_FIFOLCK = %X'80';
literal SPDT$M_STS_QWORK_TODO = %X'100';
literal SPDT$M_STS_RESET_ISSUED = %X'200';
literal SPDT$m_spare = %X'400';
literal SPDT$M_STS_MULTIHOST = %X'800';
literal SPDT$M_STS_TIMEOUT_SOON = %X'1000';
literal SPDT$M_STS_TIMEOUT_NOW = %X'2000';
literal SPDT$M_DIPL_RESET_IN_PROGRESS = %X'1';
literal SPDT$M_DIPL_RESET_FORK_INUSE = %X'2';
literal SPDT$M_DIPL_RESET_DETECTED_WAIT = %X'4';
literal SPDT$M_DIPL_STDT_SCDT = %X'8';
literal SPDT$M_DIPL_RESET_CU_FORK_INUSE = %X'10';
literal SPDT$C_VEC_START = 80;          ! * Start of SCSI Vector Table; used by SCSIDEBUG
literal SPDT$K_STDT_HASH_SIZE = 8;      !   Size of STDT_HASH_TABLE.
literal SPDT$K_STDT_HASH_BITBASE = 0;   !   Start bit of hash mask.
literal SPDT$K_STDT_HASH_BITCNT = 3;    !   Number of bits in hash mask.
literal SPDT$K_STDT_HASH_BITMASK = 7;   !   Bit mask for the hash value.
! 
literal SPDT$K_CMD_SLOTS = 255;         !   Total number of command slot allocation bits.
literal SPDT$S_CMD_BITS = 32;           !   Total byte count of command slot allocation bit map.
literal SPDT$C_PKSLENGTH = 632;         !   SIZE OF SPDT
literal SPDT$C_PKCLENGTH = 632;         !   SIZE OF SPDT
literal SPDT$C_PKNLENGTH = 632;         !   SIZE OF SPDT
literal SPDT$S_SPDTDEF = 632;           !   Old size name, synonym for SPDT$S_SPDT
literal SPDT$S_SPDT = 632;
macro SPDT$L_FLINK = 0,0,32,1 %;        ! O Link to next SCSI SPDT
macro SPDT$L_VERSION_CHECK = 4,0,32,0 %; ! I Value used to check driver versions
macro SPDT$W_SIZE = 8,0,16,0 %;         ! I Structure size in bytes
macro SPDT$B_TYPE = 10,0,8,0 %;         ! I Structure type
macro SPDT$B_SUBTYP = 11,0,8,0 %;       ! I Structure subtype
! 
! 		SCSI Port Identification.
! 
macro SPDT$W_SPDT_TYPE = 12,0,16,0 %;   ! I Type of SPDT
macro SPDT$L_SCSI_PORT_ID = 16,0,32,0 %; ! I SCSI port ID.  (A..Z)
macro SPDT$L_SCSI_BUS_ID = 20,0,32,0 %; ! I SCSI bus ID.
macro SPDT$IS_SCSI_ID_NUM = 24,0,32,0 %; ! I SCSI bus ID numeric value
! 
! 		Define the port characteristics and status.
! 
macro SPDT$L_PORT_FLAGS = 28,0,32,0 %;  ! F Port specific flags.
macro SPDT$V_PFLG_SYNCH = 28,0,1,0 %;   ! F Supports synchronous mode.
macro SPDT$V_PFLG_ASYNCH = 28,1,1,0 %;  ! F Supports asynchronous mode.
macro SPDT$V_PFLG_MAPPING_REG = 28,2,1,0 %; ! F Supports mapping registers.
macro SPDT$V_PFLG_BUF_DMA = 28,3,1,0 %; ! F Supports buffered DMA.
macro SPDT$V_PFLG_DIR_DMA = 28,4,1,0 %; ! F Supports direct DMA.
macro SPDT$V_PFLG_AEN = 28,5,1,0 %;     ! F Supports Async Event Notification
macro SPDT$V_PFLG_LUNS = 28,6,1,0 %;    ! F Supports LUNS
macro SPDT$V_PFLG_CMDQ = 28,7,1,0 %;    ! F Set if port supports command queueing.
macro SPDT$V_PFLG_AUTOSENSE = 28,8,1,0 %; ! F Set if the port driver supports autosense.	Tested by class drivers.
macro SPDT$V_PFLG_PORT_AUTOSENSE = 28,9,1,0 %; ! F Set if port specific hardware/software supports autosense.
macro SPDT$V_PFLG_SMART_PORT = 28,10,1,0 %; ! F Set if the port hardware is an intelligent SCSI adapter.
macro SPDT$V_PFLG_DIPL = 28,11,1,0 %;   ! F Set if the port stalls at DIPL .vs. FORK
macro SPDT$L_STS = 32,0,32,0 %;         ! F Port device status
macro SPDT$V_STS_ONLINE = 32,0,1,0 %;   ! F Unit online (1=yes)
macro SPDT$V_STS_TIMOUT = 32,1,1,0 %;   ! F Unit timed out (1=yes)
macro SPDT$V_STS_ERLOGIP = 32,2,1,0 %;  ! F Error log in progress on unit (1=yes)
macro SPDT$V_STS_CANCEL = 32,3,1,0 %;   ! F Cancel I/O on unit (1=yes)
macro SPDT$V_STS_POWER = 32,4,1,0 %;    ! F Power failed while unit busy (1=yes)
macro SPDT$V_STS_BSY = 32,5,1,0 %;      ! F Unit is busy (1=yes)
macro SPDT$V_STS_FAILED = 32,6,1,0 %;   ! F Port failed operation or initialization.
macro SPDT$V_STS_FIFOLCK = 32,7,1,0 %;  ! F N53C94 FIFO in use
macro SPDT$V_STS_QWORK_TODO = 32,8,1,0 %; ! F Set when queue manager has more work to do.
macro SPDT$V_STS_RESET_ISSUED = 32,9,1,0 %; ! F Set when PORT issues a reset.
macro SPDT$v_spare = 32,10,1,0 %;       ! F   placeholder for obsolete field
macro SPDT$V_STS_MULTIHOST = 32,11,1,0 %; ! F Multiple hosts (for SCSI clusters)
macro SPDT$V_STS_TIMEOUT_SOON = 32,12,1,0 %; ! F I/O's to SCSI Port adapter will time out soon
macro SPDT$V_STS_TIMEOUT_NOW = 32,13,1,0 %; ! F I/O's to SCSI Port adapter are timing out now
macro SPDT$L_DIPL_STS = 36,0,32,0 %;    ! D Port device status manipulated at DIPL
macro SPDT$V_DIPL_RESET_IN_PROGRESS = 36,0,1,0 %; ! D Bus Reset in progress
macro SPDT$V_DIPL_RESET_FORK_INUSE = 36,1,1,0 %; ! D Bus Reset fork block in use
macro SPDT$V_DIPL_RESET_DETECTED_WAIT = 36,2,1,0 %; ! D External reset wait in progress
macro SPDT$V_DIPL_STDT_SCDT = 36,3,1,0 %; ! D Deallocation of either SCDT or STDT
macro SPDT$V_DIPL_RESET_CU_FORK_INUSE = 36,4,1,0 %; ! D Bus Reset Cleanup fork block in use
macro SPDT$IS_FLCK = 40,0,32,0 %;       ! I Fork lock index
macro SPDT$L_DLCK = 44,0,32,1 %;        ! I Device lock address
macro SPDT$B_DIPL = 48,0,8,0 %;         ! I Device IPL
macro SPDT$IS_SAVIPL = 52,0,32,0 %;     ! I Saved IPL
macro SPDT$IW_ERL_TYPE = 56,0,16,0 %;   ! I ERL$DEVICEATN type/subtype codes
macro SPDT$IS_CRCTX_SHIFT = 60,0,32,0 %; ! F Counted res. size, as a shift factor
macro SPDT$IS_CRCTX_BWP_MASK = 64,0,32,0 %; ! F Counted res. size, as a BWP mask
macro SPDT$IS_SCSI_INT_MSK = 68,0,32,0 %; ! F Port-specific interrupt mask
macro SPDT$L_MAXBYTECNT = 72,0,32,0 %;  ! I Maximum byte count for a transfer.
macro SPDT$L_TIMEOUT_COUNT = 76,0,32,0 %; ! F Counted of I/O's about to time out
! 
! 		The SCSI Port Interface entry points follow. These entry
! 		points are fork entry points that the class driver envokes
! 		to execute port specific functions.
! 
macro SPDT$PS_CD_ABORT_COMMAND = 80,0,32,1 %; ! I Abort outstanding cmd.
macro SPDT$PS_CD_BUFFER_MAP = 84,0,32,1 %; ! I Map a buffer for read or write transfer
macro SPDT$PS_CD_BUFFER_UNMAP = 88,0,32,1 %; ! I Unmap a buffer
macro SPDT$PS_CD_CMD_BUFFER_ALLOC = 92,0,32,1 %; ! I Allocate a message buffer
macro SPDT$PS_CD_CMD_BUFFER_DEALLOC = 96,0,32,1 %; ! I Deallocate buffer
macro SPDT$PS_CD_CONNECT = 100,0,32,1 %; ! I Request connection to target.
macro SPDT$PS_CD_CONNECTION_CHAR_GET = 104,0,32,1 %; ! I Get connect char.
macro SPDT$PS_CD_CONNECTION_CHAR_SET = 108,0,32,1 %; ! I Set connect char.
macro SPDT$PS_CD_DISCONNECT = 112,0,32,1 %; ! I Break connection.
macro SPDT$PS_CD_QUEUE_FLUSH = 116,0,32,1 %; ! I Address of SC$FLUSH_QUEUE in the port driver.
macro SPDT$PS_CD_QUEUE_FREEZE = 120,0,32,1 %; ! I Address of SC$FREEZE_QUEUE in the port driver.
macro SPDT$PS_CD_QUEUE_RELEASE = 124,0,32,1 %; ! I Address of SC$RELEASE_QUEUE in the port driver.
macro SPDT$PS_CD_RESET_DEVICE = 128,0,32,1 %; ! I Perform a device reset.
macro SPDT$PS_CD_RESET_SCSI_BUS = 132,0,32,1 %; ! I Maintenace reset of port
macro SPDT$PS_CD_SEND_COMMAND = 136,0,32,1 %; ! I Start processing a SCSI command on the device.
! 
! 		The SCSI Port Interface entry points follow. These entry
! 		points are the entry points from SCSI2COMMON and SCSI2SUBS into
! 		the port specific routines.
! 
macro SPDT$PS_PK_ABORT_COMMAND = 144,0,32,1 %; ! I Abort the outstanding requests.
macro SPDT$PS_PK_CMD_BUFFER_ALLOC = 148,0,32,1 %; ! I Allocate a command buffer.
macro SPDT$PS_PK_CMD_BUFFER_DEALLOC = 152,0,32,1 %; ! I Deallocate a command buffer.
macro SPDT$PS_PK_CMD_WAIT_COMPLETION = 156,0,32,1 %; ! I Wait for the SCSI request to complete.
macro SPDT$PS_PK_CONNECT = 160,0,32,1 %; ! I Complete connection and SCDT initialization.
macro SPDT$PS_PK_CONNECTION_CHAR_SET = 164,0,32,1 %; ! I Finish setting the connection characteristics.
macro SPDT$PS_PK_INIT_SPDT = 168,0,32,1 %; ! I Complete SPDT initialization.
macro SPDT$PS_PK_INIT_STDT = 172,0,32,1 %; ! I Complete STDT initialization.
macro SPDT$PS_PK_NEGOTIATE_SYNCH = 176,0,32,1 %; ! I Re-negotiate the transfer mode
macro SPDT$PS_PK_QUEUE_FLUSH = 180,0,32,1 %; ! I Flush the device queue.
macro SPDT$PS_PK_QUEUE_FREEZE = 184,0,32,1 %; ! I Freeze the device queue.
macro SPDT$PS_PK_QUEUE_RELEASE = 188,0,32,1 %; ! I Release the device queue.
macro SPDT$PS_PK_RESET_SCSI_BUS = 192,0,32,1 %; ! I Reset the SCSI bus.
macro SPDT$PS_PK_SEND_COMMAND = 196,0,32,1 %; ! I Initiate the SCSI request.
! 
! 		The "runtime library" entry point interface follows.  These entry
! 		points are called by the port specific driver routines to perform
! 		support functions.
! 
macro SPDT$PS_RL_CHECK_CMDQ_STATUS = 204,0,32,1 %; ! I Check CMDQ status processing
macro SPDT$PS_RL_CHECK_ONDECK_BLOCKED = 208,0,32,1 %; ! I Check if ONDECK_KPB is blocked
macro SPDT$PS_RL_CMD_SLOT_ALLOC = 212,0,32,1 %; ! I Allocate a command slot
macro SPDT$PS_RL_CMD_SLOT_DEALLOC = 216,0,32,1 %; ! I Deallocate a command slot
macro SPDT$PS_RL_CREATE_PORT = 220,0,32,1 %; ! I Create a new SPDT for a new SCSI port
macro SPDT$PS_RL_POOL_ALLOC = 224,0,32,1 %; ! I Allocate non-paged pool
macro SPDT$PS_RL_POOL_ALLOC_PHYSICAL = 228,0,32,1 %; ! I Allocate non-paged pool of physically contigous memory
macro SPDT$PS_RL_POOL_DEALLOC = 232,0,32,1 %; ! I Deallocate non-paged pool
macro SPDT$PS_RL_INIT_SCDRP = 236,0,32,1 %; ! I Initialize SCDRP for port usage
macro SPDT$PS_RL_TIMEOUT_SETUP_TQE = 240,0,32,1 %; ! I Initialize port timer
macro SPDT$PS_RL_QUEUE_RESET_DIPL = 244,0,32,1 %; ! I Queue device reset from DIPL
macro SPDT$PS_RL_QUEUE_RESET_FORK = 248,0,32,1 %; ! I Queue device reset from FORK
macro SPDT$PS_RL_RESET_DETECTED_DIPL = 252,0,32,1 %; ! I Bus reset detected from DIPL
macro SPDT$PS_RL_RESET_DETECTED_FORK = 256,0,32,1 %; ! I Bus reset detected from FORK
macro SPDT$PS_RL_RESET_DETECTED_WAIT = 260,0,32,1 %; ! I Bus reset detected wait request
! 
! 		Wait queues
! 
macro SPDT$L_PORT_WQFL = 268,0,32,1 %;  ! F Port wait queue forward link
macro SPDT$L_PORT_WQBL = 272,0,32,1 %;  ! F Port wait queue backward link
macro SPDT$L_WAITQFL = 276,0,32,1 %;    ! F Listhead for fork blocks waiting
macro SPDT$L_WAITQBL = 280,0,32,1 %;    ! F For nonpaged pool
macro SPDT$PS_RESET_WAIT_LIST = 284,0,32,1 %; ! D Single-Linked-List for bus reset waiters
! 
! 		Related Port Data Structures.
! 
macro SPDT$L_ADP = 288,0,32,1 %;        ! I Address of ADP
macro SPDT$PS_CRAB = 292,0,32,1 %;      ! I Address of CRAB
macro SPDT$PS_PORT_CRAM = 296,0,32,1 %; ! I Address of CRAM
macro SPDT$L_PORT_IDB = 300,0,32,1 %;   ! I Address of port IDB.
macro SPDT$L_PORT_UCB = 304,0,32,1 %;   ! I Address of port UCB.
macro SPDT$PS_ERL_SCDT = 308,0,32,1 %;  ! F SCDT address for error logging operation
macro SPDT$L_SCSI_DEBUG = 312,0,32,1 %; ! F SCSIDEBUG data structure pointer
macro SPDT$PS_QMAN_KPB = 316,0,32,1 %;  ! F Queue manager's KPB address.
macro SPDT$PS_CHIP_KPB = 320,0,32,1 %;  ! S KPB address that owns the SCSI chip.
macro SPDT$PS_ONDECK_KPB = 324,0,32,1 %; ! S KPB address that is waiting for the SCSI chip.
! 
! 		This TQE is used by the port driver to timeout pending disconnected IO's
! 		When this TQE expires, the timer thread will timeout expired pending IO's.
! 
macro SPDT$B_TQE = 328,0,0,0 %;
literal SPDT$S_TQE = 64;                ! F Timer queue entry
macro SPDT$L_TQE_DELAY = 392,0,32,0 %;  ! F Delay time for next TQE delay.
! 
! 	Define the reset fork block
! 
macro SPDT$R_RESET_FKB = 400,0,0,0 %;
literal SPDT$S_RESET_FKB = 32;          ! I Embedded quadword aligned reset fork block
! 
! 	Define a SCSI bus-reset-cleanup fork block
! 
macro SPDT$R_RESET_CLEANUP_FKB = 432,0,0,0 %;
literal SPDT$S_RESET_CLEANUP_FKB = 32;  ! I Embedded quadword aligned reset cleanup fork block
! 
! 		Port specific DMA information.
! 
macro SPDT$L_DMA_BASE = 464,0,32,1 %;   ! F Base address of DMA buffer
macro SPDT$L_SPTE_BASE = 468,0,32,1 %;  ! F S0 base address of buffer
macro SPDT$L_SPTE_SVAPTE = 472,0,32,1 %; ! F SVAPTE of 1st SPTE used to double map
macro SPDT$IS_EXTMAPREG = 476,0,32,0 %; ! F Extra (guard etc.) map regs needed
! 
! 		SCSI port event counters
! 
! 		These counters are for events that are characteristic of the
! 		port not a connection and that don't need to be recorded on
! 		a connection by connection basis.
! 
macro SPDT$L_TARRST_CNT = 480,0,32,0 %; ! F Count of target initiated bus resets.
macro SPDT$L_RETRY_CNT = 484,0,32,0 %;  ! F Count of total number of retry attempts.
macro SPDT$L_STRAY_INT_CNT = 488,0,32,0 %; ! F Count of interrupts when no owner of chan.
macro SPDT$L_UNEXP_INT_CNT = 492,0,32,0 %; ! F Count of unexpected interrupts when chan owned.
macro SPDT$L_NODISCON_CNT = 496,0,32,0 %; ! F Count of reselections when not disconnected.
macro SPDT$IS_EVENT_CNT = 500,0,32,0 %; ! F Count number of events this interrupt.
macro SPDT$IS_TOTAL_IO_COUNT = 504,0,32,1 %; ! F Total outstanding I/O count (DEVICE_QUEUE & PORT_QUEUE).
macro SPDT$IS_PORT_IO_COUNT = 508,0,32,1 %; ! F Count of I/Os currently on all PORT_QUEUEs.
macro SPDT$IS_DEV_IO_COUNT = 512,0,32,1 %; ! F Count of I/Os currently on all DEVICE_QUEUEs.
macro SPDT$IS_QUEUE_SPINS = 516,0,32,1 %; ! F Number of loops through the queue manager.
macro SPDT$IS_QUEUE_EXITS = 520,0,32,1 %; ! F Number of times the queue manager has exited.
! 
! 		STDT hash table information.
! 
!   Number of bits in the hash value.
!   Starting position of those bits.
macro SPDT$PS_STDT_HASH_TABLE = 524,0,0,1 %;
literal SPDT$S_STDT_HASH_TABLE = 32;    ! F STDT hash table.
! 		Command buffer slot information.
! 
! 		The following fields are used to manage allocation of command
! 		buffer slots, for port drivers that require that concept.
! 
macro SPDT$PS_CMD_BASE = 556,0,32,1 %;  ! I Base address of CMD buffers
macro SPDT$PS_CMD_SPDT = 560,0,32,1 %;  ! I The SPDT that manages command slots
macro SPDT$PS_CMDWTFL = 564,0,32,1 %;   ! F Wait queue forward pointer
macro SPDT$PS_CMDWTBL = 568,0,32,1 %;   ! F Wait queue backward pointer
!   Total number of command slots.
!   Total longwords for command slot allocation bit map.
macro SPDT$IL_CMD_BITS = 572,0,0,0 %;   ! F Command slot allocation bit map.
! 
! 		Save some space for future expansion.  Reserved to Digital, ALPHA/VMS development.
! 
macro SPDT$L_RSVD_LONG = 604,0,0,1 %;
literal SPDT$S_RSVD_LONG = 12;          ! F Port specific space that may be used for any purpose.
! 
! 		Save some space for Port specific extensions.
! 
macro SPDT$L_PORT_SPECIFIC = 616,0,0,1 %;
literal SPDT$S_PORT_SPECIFIC = 12;      ! F Port specific space that may be used for any purpose.
! 
! 		Define the length of this structure.
! 
 
!*** MODULE $SPIDEF ***
! +
!  $SPIDEF	- SCSI CLASS/PORT DRIVER INTERFACE DEFINITIONS.
! -
literal SPI$K_PBCB_STOP_BUSY = -1;      !  Port is busy
literal SPI$K_PBCB_STOP_CHECK_CONDITION = -2; !  Port has seen a check condition event.
literal SPI$K_PBCB_STOP_QUEUE_FULL_EVNT = -3; !  Port has seen a queue full event.
literal SPI$K_PBCB_STOP_BUS_RESET = -4; !  Port has seen a bus reset
literal SPI$K_PBCB_STOP_NO_SEND_CREDITS = -5; !  Port has run out of send credits.
literal SPI$K_PBCB_STOP_NO_CMD_BITS = -6; !  Port has run out of cmd bits
literal SPI$K_PBCB_GO_READY = 0;        !  Port is no longer busy
literal SPI$K_PBCB_GO_ACA_COMPLETE = 1; !  Port has finished the ACA processing.
literal SPI$K_PBCB_GO_QUEUE_STARTING = 2; !  Port is attempting to restart the queue following the queue full event.
literal SPI$K_PBCB_GO_BUS_FREE = 3;     !  Port has finished bus reset, bus is free
literal SPI$K_PBCB_GO_SEND_CREDITS = 4; !  Port has send credits available
literal SPI$K_PBCB_GO_CMD_BITS = 5;     !  Port has cmd bits available
!  Structure used by SPI$GET_CONNECTION_CHAR and SPI$SET_CONNECTION_CHAR
literal SPI$K_CC_NUM_ARGS = 10;         !   Current required count
literal SPI$K_CC_QNUM_ARGS = 12;        !  TCQ adds 2 longword arguments
literal SPI$M_CC_ENA_DISCON = %X'1';
literal SPI$M_CC_DIS_RETRY = %X'2';
literal SPI$K_CC_DEF_FLAGS = 0;         !   Default connection flags
literal SPI$K_CC_DEF_SYNCH = 0;         !   Default synch xfer support
literal SPI$K_CC_DEF_XFERPERIOD = 64;   !   Default REQ/ACK tick count
literal SPI$K_CC_DEF_REQACKOFF = 3;     !   Default REQs before ACK
literal SPI$K_CC_DEF_BSYRTY = 2000;     !   Default bus free retry cnt
literal SPI$K_CC_DEF_ARBRTY = 5;        !   Default arb retry count
literal SPI$K_CC_DEF_SELRTY = 3;        !   Default sel retry count
literal SPI$K_CC_DEF_CMDRTY = 3;        !   Default cmd retry count
literal SPI$K_CC_DEF_DMATMO = 4;        !   Default DMA/Phase timeout
literal SPI$K_CC_DEF_DISCTMO = 4;       !   Default Disconnect timeout
literal SPI$M_CC_CMDQ = %X'1';
literal SPI$M_CC_FLUSHQ = %X'2';
literal SPI$M_CC_FREEZEQ = %X'4';
literal SPI$M_CC_SCSI_2 = %X'8';
literal SPI$M_CC_SCSI_3 = %X'10';
literal SPI$M_CC_CLS_DRVR_ACA = %X'20';
literal SPI$K_CC_DEF_MAX_QDEPTH = 1;    !   Default maximum queue depth
literal SPI$K_CC_LENGTH = 52;           !  Length of SPI_CC structure
literal SPI$S_SPI_CC_DEF = 52;          !  Old size name, synonym for SPI$S_SPI
literal SPI$S_SPI = 56;
macro SPI$IL_CC_COUNT = 0,0,32,1 %;     !  Count of longword arguments
macro SPI$IL_CC_CON_FLAGS = 4,0,32,0 %; !  Connection flags
macro SPI$V_CC_ENA_DISCON = 4,0,1,0 %;  !   Discon/Resel enabled
macro SPI$V_CC_DIS_RETRY = 4,1,1,0 %;   !   Disable command retry
macro SPI$IL_CC_SYNCHRONOUS = 8,0,32,1 %; !  Sychronous transfer support
macro SPI$IL_CC_TRANSFER_PERIOD = 12,0,32,1 %; !  Ticks between REQ & ACK
macro SPI$IL_CC_REQACK_OFFSET = 16,0,32,1 %; !  REQs before ACK
macro SPI$IL_CC_BUSY_RETRY_CNT = 20,0,32,1 %; !  Retries before bus free
macro SPI$IL_CC_ARB_RETRY_CNT = 24,0,32,1 %; !  Retries before arbitration
macro SPI$IL_CC_SEL_RETRY_CNT = 28,0,32,1 %; !  Retries on selections
macro SPI$IL_CC_CMD_RETRY_CNT = 32,0,32,1 %; !  Retries on command send
macro SPI$IL_CC_DMA_TIMEOUT = 36,0,32,1 %; !  DMA/Phase timeout
macro SPI$IL_CC_DISC_TIMEOUT = 40,0,32,1 %; !  Disconnect timeout
macro SPI$IL_CC_SCSI_FLAGS = 44,0,32,0 %; !  SCSI flags, including TCQ
macro SPI$V_CC_CMDQ = 44,0,1,0 %;       !   Device supports TCQ
macro SPI$V_CC_FLUSHQ = 44,1,1,0 %;     !   Flush queue on error
!    MBZ, reserved for SCSI-3
macro SPI$V_CC_FREEZEQ = 44,2,1,0 %;    !   Freeze queue on error
!    MBZ, reserved for SCSI-3
macro SPI$V_CC_SCSI_2 = 44,3,1,0 %;     !   Device is SCSI-2 conformant
macro SPI$V_CC_SCSI_3 = 44,4,1,0 %;     !   Device is SCSI-3 conformant
macro SPI$V_CC_CLS_DRVR_ACA = 44,5,1,0 %; !   Class Driver needs ACA
macro SPI$IL_CC_MAX_QDEPTH = 48,0,32,1 %; !  Maximum queue depth if TCQ
 
!*** MODULE $SPLCODDEF ***
! +
! 
!  SPINLOCK INDEX DEFINITIONS
! 
! -
! 
!  DEFINE THE HARDWARE LEVEL LOCKS (INDICES 0-F)
! 
literal SPL$C_EMB = 32;                 !  EMB spinlock index
literal SPL$C_MCHECK = 33;              !  Machine Check spinlock index
literal SPL$C_MEGA = 34;                !  Kitchen sink of spinlocks
literal SPL$C_HWCLK = 36;               !  HWCLK spinlock index
literal SPL$C_INVALIDATE = 38;          !  INVALIDATE spinlock index
literal SPL$C_PERFMON = 40;             !  PERFMON spinlock index
literal SPL$C_POOL = 42;                !  POOL spinlock index
literal SPL$C_MAILBOX = 44;             !  MAILBOX spinlock index
literal SPL$C_IOLOCK11 = 46;            !  IPL 11 I/O spinlock index
literal SPL$C_IOLOCK10 = 47;            !  IPL 10 I/O spinlock index
literal SPL$C_IOLOCK9 = 48;             !  IPL 9 I/O spinlock index
literal SPL$C_SCHED = 50;               !  SCHED spinlock index
literal SPL$C_MMG = 52;                 !  Memory management spinlock index
literal SPL$C_IO_MISC = 54;             !  Miscellaneous short time I/O spinlock index
literal SPL$C_TIMER = 56;               !  TIMER spinlock index
literal SPL$C_TX_SYNCH = 57;            !  Transaction processing lock
literal SPL$C_IOLOCK8 = 58;             !  IPL 8 I/O spinlock index
literal SPL$C_LCKMGR = 59;              !  Lock Manager lock
literal SPL$C_FILSYS = 60;              !  File system spinlock index
literal SPL$C_QUEUEAST = 62;            !  QUEUEAST spinlock index
literal SPL$C_SCS = 58;                 !  SCS spinlock index
literal SPL$_MIN_INDEX = 32;            !  Min spinlock index
literal SPL$_MAX_INDEX = 62;            !  Max spinlock index
literal SPL$_NUM_LOCKS = 31;            !  Max number of spinlocks (ever)
! 
!  Define some system-wide multiprocessing control flags
! 
literal SMP$M_ENABLED = %X'1';
literal SMP$M_START_CPU = %X'2';
literal SMP$M_CRASH_CPU = %X'4';
literal SMP$M_TODR = %X'8';
literal SMP$M_UNMOD_DRIVER = %X'10';
literal SMP$M_TODR_ACK = %X'20';
literal SMP$M_SYNCH = %X'40';
literal SMP$M_BENIGN = %X'80';
literal SMP$M_OVERRIDE = %X'1';
literal SMP$M_FOREVER = %X'2';
literal SMP$S_SMPDEF = 2;               !  Old size name, synonym for  SMP$S_SMP
literal SMP$S_SMP = 2;
macro SMP$V_ENABLED = 0,0,1,0 %;        !  SMP operation is enabled
macro SMP$V_START_CPU = 0,1,1,0 %;      !  PRIMARY CPU has finished INIT
macro SMP$V_CRASH_CPU = 0,2,1,0 %;      !  A CPU is initiating BUGCHECK
macro SMP$V_TODR = 0,3,1,0 %;           !  SMP$GL_PROPOSED_TODR in use
macro SMP$V_UNMOD_DRIVER = 0,4,1,0 %;   !  Unmodified driver is loaded
macro SMP$V_TODR_ACK = 0,5,1,0 %;       !  SMP TODR operation complete
macro SMP$V_SYNCH = 0,6,1,0 %;          !  SMP SYNCHRONIZATION IMAGE LOADED
macro SMP$V_BENIGN = 0,7,1,0 %;         !  BENIGN STATE REQUESTED
macro SMP$V_OVERRIDE = 1,0,1,0 %;       !  Skip checks before stopping CPU
macro SMP$V_FOREVER = 1,1,1,0 %;        !  FOREVER means remove from
!  available set after stopping.
 
!*** MODULE $SPLDEF ***
! 
!   SPINLOCK Control Block
! 
literal SPL$C_SPL_SPINLOCK = 1;         !  Static system spinlock
literal SPL$C_SPL_FORKLOCK = 2;         !  Spinlock used for FORKLOCK
literal SPL$C_SPL_DEVICELOCK = 3;       !  Dynamic spinlock (devicelock)
literal SPL$M_INTERLOCK = %X'1';
literal SPL$K_PC_VEC_CNT = 16;          !  Size of PC vector
literal SPL$S_SPL = 128;
macro SPL$L_OWN_CPU = 0,0,32,1 %;       !  Owner CPU's per-cpu database addr
macro SPL$L_OWN_CNT = 4,0,32,1 %;       !  Count of concurrent acquires
macro SPL$W_SIZE = 8,0,16,0 %;          !  Structure size
macro SPL$B_TYPE = 10,0,8,0 %;          !  Structure type
macro SPL$B_SUBTYPE = 11,0,8,0 %;       !  Spinlock subtype
macro SPL$L_SPINLOCK = 12,0,32,0 %;     !  Structure lock semaphore
macro SPL$V_INTERLOCK = 12,0,1,0 %;     !  Spinlock access interlock
macro SPL$L_RANK = 16,0,32,1 %;         !  RANK of spinlock
macro SPL$L_IPL = 20,0,32,0 %;          !  Lock IPL
macro SPL$B_IPL = 20,0,8,0 %;           !  Defined for first byte only
macro SPL$L_RLS_PC = 24,0,32,1 %;       !  PC of nested acquisition releaser
! 
!  After much consultation, we think that BUSY_WAITS should be unsigned.
!  The MACRO-32 source treats it as an unsigned longword integer, and
!  tests for overflow by testing if the value is zero.
! 
macro SPL$L_BUSY_WAITS = 28,0,32,0 %;   !  Count of failed acquisitions
macro SPL$L_WAIT_CPUS = 32,0,32,1 %;    !  Count of waiting CPUs
macro SPL$L_WAIT_PC = 36,0,32,1 %;      !  Last busywait PC
macro SPL$Q_SPINS = 40,0,0,1 %;
literal SPL$S_SPINS = 8;                !  Count number of spins
macro SPL$Q_ACQ_COUNT = 48,0,0,0 %;
literal SPL$S_ACQ_COUNT = 8;            !  Count of actual acquisitions
macro SPL$L_TIMO_INT = 56,0,32,0 %;     !  Busywait timeout interval
macro SPL$L_VEC_INX = 60,0,32,1 %;      !  PC vector index
macro SPL$L_OWN_PC_VEC = 64,0,0,1 %;
literal SPL$S_OWN_PC_VEC = 64;          !  16 PCs of acquires/releases
literal SPL$K_LENGTH = 128;             !  Structure size
literal SPL$C_LENGTH = 128;             !  Structure size
literal SPL$S_SPLDEF = 128;             !  Old size name, synonym for  SPL$S_SPL 
 
!*** MODULE $SPNBDEF ***
! +
!  SPNB - SCA POLLER NAME BLOCK
! 
!  THIS DATA STRUCTURE CONTAINS A LIST OF PROCESS NAMES WHICH WILL
!  BE SEARCHED FOR ON THE GIVEN REMOTE NODE.
! -
literal SPNB$C_HDRSIZ = 24;             ! SIZE OF HEADER
literal SPNB$S_SPNBDEF = 25;
literal SPNB$S_SPNB = 25;
macro SPNB$L_FLINK = 0,0,32,1 %;        ! FWD LINK 
macro SPNB$L_BLINK = 4,0,32,1 %;        ! BCK LINK 
macro SPNB$W_SIZE = 8,0,16,0 %;         ! STRUCTURE SIZE IN BYTES 
macro SPNB$B_TYPE = 10,0,8,0 %;         ! SCS STRUCTURE TYPE 
macro SPNB$B_SUBTYP = 11,0,8,0 %;       ! SCS STRUCTURE SUBTYPE FOR SPNB
macro SPNB$L_SB = 12,0,32,0 %;          ! SYSTEM BLOCK OF REMOTE NOTE
macro SPNB$L_ROUTINE = 16,0,32,1 %;     ! ADDRESS OF ROUTINE TO BE CALLED WHEN PROCESS FOUND
macro SPNB$B_INDEX = 20,0,8,0 %;        ! INDEX INTO PROCESS LIST OF NEXT PROCESS TO SEARCH FOR
macro SPNB$W_REFC = 21,0,16,0 %;        ! NUMBER OF REFERENCES TO SPNB
macro SPNB$B_FREE = 23,0,8,0 %;
literal SPNB$S_FREE = 1;                ! FREE BYTE
macro SPNB$B_NAMLST = 24,0,8,0 %;       ! START OF VARIABLE LENGTH LIST OF ADDRESSES OF PROCESS NAMES
! LIST IS ZERO TERMINATED
 
!*** MODULE $SPPBDEF ***
! +
!  SPPB - SCA POLLER PROCESS BLOCK
! 
!  THIS DATA STRUCTURE DESCRIBES A PROCESS NAME KNOWN
!  TO THE SCA DIRECTORY POLLER.
! -
literal SPPB$K_LENGTH = 40;
literal SPPB$C_LENGTH = 40;
literal SPPB$S_SPPBDEF = 40;
literal SPPB$S_SPPB = 40;
macro SPPB$L_FLINK = 0,0,32,1 %;        ! FWD LINK 
macro SPPB$L_BLINK = 4,0,32,1 %;        ! BCK LINK 
macro SPPB$W_SIZE = 8,0,16,0 %;         ! STRUCTURE SIZE IN BYTES 
macro SPPB$B_TYPE = 10,0,8,0 %;         ! SCS STRUCTURE TYPE 
macro SPPB$B_SUBTYP = 11,0,8,0 %;       ! SCS STRUCTURE SUBTYPE FOR SPPB
macro SPPB$B_PROCNAM = 12,0,0,0 %;
literal SPPB$S_PROCNAM = 16;            ! ASCII STRING FOR PROCESS NAME 
macro SPPB$L_RTN = 28,0,32,1 %;         ! ADDRESS OF NOTIFICATION ROUTINE
macro SPPB$L_CTX = 32,0,32,0 %;         ! CONTEXT FOR NOTIFICATION ROUTINE
macro SPPB$W_BIT = 36,0,16,0 %;         ! BIT ASSIGNED TO THIS PROCESS NAME
 
!*** MODULE $SQEDEF ***
! +
!  Serialisation Queue Element Definitions
! 
!  SQEs are put on the extent/FID cache serialisation queues within
!  the XQP.
! 
! -
literal SQE$K_ACB = 16;                 ! OFFSET INTO ACB AREA
literal SQE$C_ACB = 16;
literal SQE$K_LENGTH = 44;              !  LENGTH OF BLOCK
literal SQE$C_LENGTH = 44;              !  LENGTH OF BLOCK
literal SQE$S_SQEDEF = 44;
literal SQE$S_SQE = 44;
macro SQE$L_SQEQFL = 0,0,32,1 %;        ! SQE QUEUE FORWARD LINK 
macro SQE$L_SQEQBL = 4,0,32,1 %;        ! SQE QUEUE BACKWARD LINK 
macro SQE$W_SQESIZE = 8,0,16,0 %;       ! STRUCTURE SIZE IN BYTES 
macro SQE$B_SQETYPE = 10,0,8,0 %;       ! STRUCTURE TYPE CODE 
macro SQE$B_SQESUBTYPE = 11,0,8,0 %;    ! STRUCTURE SUBTYPE CODE
macro SQE$L_SQEPID = 12,0,32,0 %;       ! PID OWNER OF SQE
! DONT ADD ANYTHING HERE - ACB IS QUAD ALIGNED
macro SQE$L_ASTQFL = 16,0,32,1 %;       ! AST QUEUE FORWARD LINK 
macro SQE$L_ASTQBL = 20,0,32,1 %;       ! AST QUEUE BACKWARD LINK 
macro SQE$W_SIZE = 24,0,16,0 %;         ! STRUCTURE SIZE IN BYTES 
macro SQE$B_TYPE = 26,0,8,0 %;          ! STRUCTURE TYPE CODE 
macro SQE$B_RMOD = 27,0,8,0 %;          ! REQUEST ACCESS MODE 
macro SQE$L_PID = 28,0,32,0 %;          ! PROCESS ID OF REQUEST 
macro SQE$L_AST = 32,0,32,1 %;          ! AST ROUTINE ADDRESS 
macro SQE$L_ASTPRM = 36,0,32,0 %;       ! AST PARAMETER 
macro SQE$L_KAST = 40,0,32,0 %;         ! INTERNAL KERNEL MODE XFER ADDRESS 
 
!*** MODULE $SRVBUFDEF ***
! +
!  SRVBUF Definitions -- MSCP Server local buffer
! 
!  	This module defines the fields used in the data structure
! 	that keeps track of the local buffer pool. This local pool
! 	is used for buffering data between the client host and the
! 	local disk driver. The size field is stored after the type
! 	and subtype fields so that it can be larger and still retain
! 	the type and subtype convention.
! -
literal SRVBUF$S_SRVBUFDEF = 24;        !  Old size name - synonym
literal SRVBUF$S_SRVBUF = 24;
macro SRVBUF$L_FLINK = 0,0,32,1 %;      !  Field maintained for 
macro SRVBUF$L_BLINK = 4,0,32,1 %;      !   compatability
macro SRVBUF$W_DEBITS = 8,0,16,0 %;     !  Number of requestors memory has been lent to
macro SRVBUF$B_TYPE = 10,0,8,0 %;       !  MSCP type structure
macro SRVBUF$B_SUBTYPE = 11,0,8,0 %;    !   with a SRVBUF subtype  (4)
macro SRVBUF$L_SIZE = 12,0,32,0 %;      !  Total buffer area size
macro SRVBUF$L_BUFF_START = 16,0,32,1 %; !  List head for buffer free list
macro SRVBUF$L_FREE_SIZE = 20,0,32,0 %; !  Buffer size for free list
 
!*** MODULE $SSCDEF ***
! ++
! 	SSC definitions
! --
!  The BASE register is at physical address %X2014000.  It is loaded with
!  a value at which to locate all the other registers.  All other registers
!  are at @BASE+offset.
literal SSC$AL_BASE = 538181632;        ! Base address
literal SSC$L_CONFIG = 16;              ! Configuration
literal SSC$L_TODR = 108;               ! Time-of-year
literal SSC$L_TCR0 = 256;               ! Timer 0 control
literal SSC$L_TIR0 = 260;               ! Timer 0 interval
literal SSC$L_TNIR0 = 264;              ! Timer 0 next interval
literal SSC$L_TIVR0 = 268;              ! Timer 0 interrupt vector
literal SSC$L_TCR1 = 272;               ! Timer 1 control
literal SSC$L_TIR1 = 276;               ! Timer 1 interval
literal SSC$L_TNIR1 = 264;              ! Timer 1 next interval
literal SSC$L_TIVR1 = 268;              ! Timer 1 interrupt vector
literal SSC$B_RAM_START = 1024;         ! Start of SSC RAM
literal SSC$B_RAM_END = 2047;           ! End of SSC RAM
literal SSC$M_TCR_RUN = %X'1';
literal SSC$M_TCR_STP = %X'4';
literal SSC$M_TCR_XFR = %X'10';
literal SSC$M_TCR_SGL = %X'20';
literal SSC$M_TCR_IE = %X'40';
literal SSC$M_TCR_INT = %X'80';
literal SSC$M_TCR_ERR = %X'80000000';
literal SSC$S_TCR = 4;
macro SSC$V_TCR_RUN = 0,0,1,0 %;
macro SSC$V_TCR_MBZ_0 = 0,1,1,0 %;
macro SSC$V_TCR_STP = 0,2,1,0 %;
macro SSC$V_TCR_MBZ_1 = 0,3,1,0 %;
macro SSC$V_TCR_XFR = 0,4,1,0 %;
macro SSC$V_TCR_SGL = 0,5,1,0 %;
macro SSC$V_TCR_IE = 0,6,1,0 %;
macro SSC$V_TCR_INT = 0,7,1,0 %;
macro SSC$V_TCR_MBZ_2 = 0,8,23,0 %;
literal SSC$S_TCR_MBZ_2 = 23;
macro SSC$V_TCR_ERR = 0,31,1,0 %;
 
!*** MODULE $SSCTDEF ***
! +
!   This file contains offset definitions for SSC timer registers accessible 
!  through XMI private space on the XMI-based processors.
! -
literal SSCT_TCR0$M_RUN = %X'1';
literal SSCT_TCR0$M_STP = %X'4';
literal SSCT_TCR0$M_XFR = %X'10';
literal SSCT_TCR0$M_SGL = %X'20';
literal SSCT_TCR0$M_IE = %X'40';
literal SSCT_TCR0$M_INT = %X'80';
literal SSCT_TCR0$M_ERR = %X'80000000';
literal SSCT_TIVR0$M_VECTOR = %X'3FC';
literal SSCT_TCR1$M_RUN = %X'1';
literal SSCT_TCR1$M_STP = %X'4';
literal SSCT_TCR1$M_XFR = %X'10';
literal SSCT_TCR1$M_SGL = %X'20';
literal SSCT_TCR1$M_IE = %X'40';
literal SSCT_TCR1$M_INT = %X'80';
literal SSCT_TCR1$M_ERR = %X'80000000';
literal SSCT_TIVR1$M_VECTOR = %X'3FC';
literal SSCT$S_SSCTDEF = 32;
literal SSCT$S_SSCT = 32;
macro SSCT$L_TCR0 = 0,0,32,0 %;
macro SSCT_TCR0$V_RUN = 0,0,1,0 %;      !  Enables timer
macro SSCT_TCR0$V_STP = 0,2,1,0 %;      !  Stop on overflow
macro SSCT_TCR0$V_XFR = 0,4,1,0 %;      !  1=copy TNIRn to TIRn
macro SSCT_TCR0$V_SGL = 0,5,1,0 %;      !  Increment counter by one
macro SSCT_TCR0$V_IE = 0,6,1,0 %;       !  Interrupt Enable
macro SSCT_TCR0$V_INT = 0,7,1,0 %;      !  Set on timer overflow
macro SSCT_TCR0$V_ERR = 0,31,1,0 %;     !  Indicates missed overflow
macro SSCT$L_TIR0 = 4,0,32,0 %;         !  Timer Interval Register 0
macro SSCT$L_TNIR0 = 8,0,32,0 %;        !  Timer Next Interval Reg. 0
macro SSCT$L_TIVR0 = 12,0,32,0 %;
macro SSCT_TIVR0$V_VECTOR = 12,2,8,0 %;
literal SSCT_TIVR0$S_VECTOR = 8;        !  Longword aligned SCB vector
macro SSCT$L_TCR1 = 16,0,32,0 %;
macro SSCT_TCR1$V_RUN = 16,0,1,0 %;     !  Enables timer           
macro SSCT_TCR1$V_STP = 16,2,1,0 %;     !  Stop on overflow
macro SSCT_TCR1$V_XFR = 16,4,1,0 %;     !  1=copy TNIRn to TIRn
macro SSCT_TCR1$V_SGL = 16,5,1,0 %;     !  Increment counter by one
macro SSCT_TCR1$V_IE = 16,6,1,0 %;      !  Interrupt Enable
macro SSCT_TCR1$V_INT = 16,7,1,0 %;     !  Set on timer overflow
macro SSCT_TCR1$V_ERR = 16,31,1,0 %;    !  Indicates missed overflow
macro SSCT$L_TIR1 = 20,0,32,0 %;        !  Timer Interval Register 1
macro SSCT$L_TNIR1 = 24,0,32,0 %;       !  Timer Next Interval Reg. 1
macro SSCT$L_TIVR1 = 28,0,32,0 %;
macro SSCT_TIVR1$V_VECTOR = 28,2,8,0 %;
literal SSCT_TIVR1$S_VECTOR = 8;        !  Longword aligned SCB vector
 
!*** MODULE $SSIDEF ***
! 
!  System Service Intercept Control Block Definitions
! 
literal SSI$M_CLOSEST = %X'1';
literal SSI$C_LENGTH = 28;              !  Length of SSI_BLOCK
literal SSI$S_SSI_BLOCK = 28;
macro SSI$R_FLINK_OVERLAY = 0,0,32,0 %;
macro SSI$PS_FLINK = 0,0,32,1 %;        !  Forward link 
macro SSI$PS_PRE_NEXT = 0,0,32,1 %;     !  Pointer to next pre-processing routine 
macro SSI$R_BLINK_OVERLAY = 4,0,32,0 %;
macro SSI$PS_BLINK = 4,0,32,1 %;        !  Backward link 
macro SSI$PS_POST_NEXT = 4,0,32,1 %;    !  Pointer to next post-processing routine
macro SSI$W_SIZE = 8,0,16,0 %;          !  Size, in bytes
macro SSI$B_TYPE = 10,0,8,0 %;          !  Structure type code for SSI_BLOCK
macro SSI$B_SUBTYPE = 11,0,8,0 %;       !  Structure subtype code
macro SSI$L_VERSION = 12,0,32,0 %;      !  Version number
macro SSI$L_FLAGS = 16,0,32,0 %;        !  Flags longword
macro SSI$V_CLOSEST = 16,0,1,0 %;       !  Closest to system service
macro SSI$PS_PRE_ROUTINE = 20,0,32,1 %; !  Address of pre-processing routine
macro SSI$PS_POST_ROUTINE = 24,0,32,1 %; !  Address of post-processing routine
! 
!  Extensions to bound procedure descriptors for System Service Intercept
! 
literal SSI_PDSC$S_SSI_PDSC = 40;
macro SSI_PDSC$q_fill_1 = 0,0,0,1 %;
literal SSI_PDSC$s_fill_1 = 8;          !  Quadword which contains flags
macro SSI_PDSC$q_fill_2 = 8,0,0,1 %;
literal SSI_PDSC$s_fill_2 = 8;          !  Quadword which contains entry address
macro SSI_PDSC$q_fill_3 = 16,0,0,1 %;
literal SSI_PDSC$s_fill_3 = 8;          !  Quadword which contains bound procedure value
macro SSI_PDSC$Q_SS_SSADR = 24,0,0,1 %;
literal SSI_PDSC$S_SS_SSADR = 8;        !  Address of system service in system space
macro SSI_PDSC$PS_SS_SSADR = 24,0,32,1 %;
macro SSI_PDSC$Q_REPLACEMENT_ROUTINE = 32,0,0,1 %;
literal SSI_PDSC$S_REPLACEMENT_ROUTINE = 8; !  Address of replacement routine        	
macro SSI_PDSC$PS_REPLACEMENT_ROUTINE = 32,0,32,1 %;
! 
!  Function prototypes
! 
KEYWORDMACRO $SSI_GET_INTERCEPT_MAIN =
   BEGIN
   EXTERNAL ROUTINE SSI$GET_INTERCEPT_MAIN : BLISS ADDRESSING_MODE (GENERAL);
	SSI$GET_INTERCEPT_MAIN()
   END %;
KEYWORDMACRO $SSI_DECLARE_INTERCEPT (SSI_BLOCK_PTR) =
   BEGIN
   EXTERNAL ROUTINE SSI$DECLARE_INTERCEPT : BLISS ADDRESSING_MODE (GENERAL);
	   SSI$DECLARE_INTERCEPT (SDL$$SSIDEF_CONCAT( SDL$$SSIDEF_REQ(SSI_BLOCK_PTR, %QUOTE SSI_BLOCK_PTR) ))
   END %;
 
KEYWORDMACRO $SSI_CANCEL_INTERCEPT (SSI_BLOCK_PTR) =
   BEGIN
   EXTERNAL ROUTINE SSI$CANCEL_INTERCEPT : BLISS ADDRESSING_MODE (GENERAL);
	   SSI$CANCEL_INTERCEPT (SDL$$SSIDEF_CONCAT( SDL$$SSIDEF_REQ(SSI_BLOCK_PTR, %QUOTE SSI_BLOCK_PTR) ))
   END %;
 
KEYWORDMACRO $SSI_DECLARE_REPLACEMENT (PS_SSADR,REPLACEMENT_ROUTINE) =
   BEGIN
   EXTERNAL ROUTINE SSI$DECLARE_REPLACEMENT : BLISS ADDRESSING_MODE (GENERAL);
	   SSI$DECLARE_REPLACEMENT (SDL$$SSIDEF_CONCAT( SDL$$SSIDEF_REQ(PS_SSADR, %QUOTE PS_SSADR) , 
	   SDL$$SSIDEF_REQ(REPLACEMENT_ROUTINE, %QUOTE REPLACEMENT_ROUTINE) ))
   END %;
 
KEYWORDMACRO $SSI_CANCEL_REPLACEMENT (PS_SSADR,REPLACEMENT_ROUTINE) =
   BEGIN
   EXTERNAL ROUTINE SSI$CANCEL_REPLACEMENT : BLISS ADDRESSING_MODE (GENERAL);
	   SSI$CANCEL_REPLACEMENT (SDL$$SSIDEF_CONCAT( SDL$$SSIDEF_REQ(PS_SSADR, %QUOTE PS_SSADR) , 
	   SDL$$SSIDEF_REQ(REPLACEMENT_ROUTINE, %QUOTE REPLACEMENT_ROUTINE) ))
   END %;
 
 
!*** MODULE STATDEF ***
literal STAT_M_INPOOL = %X'1';
literal STAT_M_NOIMGHDR = %X'2';
literal STAT_M_OPEN = %X'4';
literal STAT_M_NOLOAD_SA_APP = %X'8';
literal STAT_M_OPTIONAL_LOAD = %X'10';
literal STAT_M_INHIBIT_LOAD = %X'20';
literal STAT_C_SIZE = 16;               !  Size of statistics block
literal STAT_S_STATDEF = 16;
literal STAT_S_STAT = 16;
macro STAT_L_LENGTH = 0,0,32,0 %;       !  Length of ASCII file name
macro STAT_L_NAME = 4,0,32,1 %;         !  Address of ASCII file name
macro STAT_L_FLAGS = 8,0,32,0 %;        !  Loading flags for INIT
macro STAT_V_INPOOL = 8,0,1,0 %;
macro STAT_V_NOIMGHDR = 8,1,1,0 %;
macro STAT_V_OPEN = 8,2,1,0 %;
macro STAT_V_NOLOAD_SA_APP = 8,3,1,0 %; !  Don't load image if SA_APP=1
macro STAT_V_OPTIONAL_LOAD = 8,4,1,0 %; !  Image may not be present
macro STAT_V_INHIBIT_LOAD = 8,5,1,0 %;  !  Don't load image if set
macro STAT_L_LDR_FLAGS = 12,0,32,0 %;   !  Flags passed to exec loader
 
!*** MODULE $STATEDEF ***
! +
!  SCHEDULING STATES
! -
!  DEFINITIONS START AT 1 
literal SCH$C_COLPG = 1;                ! COLLIDED PAGE WAIT 
literal SCH$C_MWAIT = 2;                ! MUTEX AND MISCELLANEOUS RESOURCE WAIT 
literal SCH$C_CEF = 3;                  ! COMMON EVENT FLAG WAIT STATE 
literal SCH$C_PFW = 4;                  ! PAGE FAULT WAIT 
literal SCH$C_LEF = 5;                  ! LOCAL EVENT FLAG WAIT 
literal SCH$C_LEFO = 6;                 ! LOCAL EVENT FLAG WAIT OUT OF BALANCE SET 
literal SCH$C_HIB = 7;                  ! HIBERNATE WAIT 
literal SCH$C_HIBO = 8;                 ! HIBERNATE WAIT OUT OF BALANCE SET 
literal SCH$C_SUSP = 9;                 ! SUSPENDED 
literal SCH$C_SUSPO = 10;               ! SUSPENDED OUT OF THE BALANCE SET 
literal SCH$C_FPG = 11;                 ! FREEPAGE WAIT 
literal SCH$C_COM = 12;                 ! COMPUTE, IN BALANCE SET STATE 
literal SCH$C_COMO = 13;                ! COMPUTE, OUT OF BALANCE SET STATE 
literal SCH$C_CUR = 14;                 ! CURRENT PROCESS STATE 
 
!*** MODULE $STDTDEF ***
! +
!  STDT - SCSI Target Descriptor Table
! 
!  There is one STDT per target. The STDT contains the SCSI information
!  for each SCSI target.  STDT's are created during the configuration of
!  the SCSI bus.
! 
!  This structure is read accessable to the class driver and readable and
!  writeable by the PORT driver.
! 
!  ***NOTE1:**** New STDT fields must be entered at the end of the data structure.
! 
!  ***NOTE2:**** If an INCOMPATIBLE CHANGE is made to this structure bump
! 		 the version number of this structure.
! -
literal STDT$C_VERSION = 1;             ! COMPATIBLE VERSION NUMBER.
literal STDT$M_DFLG_RENEGOTIATE_SYNC = %X'1';
literal STDT$K_SCDT_HASH_SIZE = 8;      !   Size of SCDT_HASH_TABLE.
literal STDT$K_SCDT_HASH_BITBASE = 0;   !   Start bit of hash mask.
literal STDT$K_SCDT_HASH_BITCNT = 3;    !   Number of bits in hash mask.
literal STDT$K_SCDT_HASH_BITMASK = 7;   !   Bit mask for the hash value.
literal STDT$C_LENGTH = 136;            !   Length of STDT
literal STDT$S_STDT = 136;
macro STDT$PS_HASH_FLINK = 0,0,32,1 %;  ! I STDT hash list forward link
macro STDT$PS_HASH_BLINK = 4,0,32,1 %;  ! I STDT hash list backward link
macro STDT$W_SIZE = 8,0,16,0 %;         ! I Standard pool header - data structure size.
macro STDT$B_TYPE = 10,0,8,0 %;         ! I Standard pool header - data structure type.
macro STDT$B_SUBTYPE = 11,0,8,0 %;      ! I Standard pool header - data structure subtype.
! 
! 		Target Specific Information
! 
macro STDT$IS_TARGET_ID = 12,0,32,0 %;  ! I ID (bit#) of this SCSI target.
macro STDT$IS_SCSI_ID_NUM = 16,0,32,0 %; ! I ID (number) of this SCSI target.
macro STDT$IS_REQACK_OFFSET = 20,0,32,0 %; ! S reqack offset for sync IO
macro STDT$IS_TRANSFER_PERIOD = 24,0,32,0 %; ! S m*4 nanoseconds
macro STDT$IS_XFERPD_DATA = 28,0,32,0 %; ! S Port transfer period data
macro STDT$IS_FAST_DATA = 32,0,32,0 %;  ! S Port fast SCSI data (port specific)
macro STDT$IS_WIDE = 36,0,32,0 %;       ! S Flag set enables WIDE data transfer mode.
macro STDT$IS_BUS_WIDTH = 40,0,32,0 %;  ! S Width of WIDE bus (8, 16, 32).
macro STDT$IS_DIPL_FLAGS = 44,0,32,0 %; ! S Flags manipulated at DIPL.
macro STDT$V_DFLG_RENEGOTIATE_SYNC = 44,0,1,0 %; !    Re-negotiate asynchronous/synchronous operation.
! 
! 		Performance and sanity counters
! 
macro STDT$IS_SCDT_COUNT = 48,0,32,0 %; ! F Count of SCDTs associated with this STDT.
macro STDT$IS_DEV_IO_COUNT = 52,0,32,0 %; ! F Outstanding I/O count for the entire target.
macro STDT$IS_RESET_CNT = 56,0,32,0 %;  ! S Count of bus resets.
! 
! 		Hash table for the SCDTs
! 
!   Number of bits in the hash value.
!   Starting position of those bits.
macro STDT$PS_SCDT_HASH_TABLE = 60,0,0,1 %;
literal STDT$S_SCDT_HASH_TABLE = 32;    ! F SCDT hash table.
! 
! 		Save some space for future expansion.  Reserved to Digital, ALPHA/VMS development.
! 
macro STDT$IS_RSVD_LONG = 92,0,0,1 %;
literal STDT$S_RSVD_LONG = 20;          ! F Port specific space that may be used for any purpose.
! 
! 		Save some space for Port specific extensions.
! 
macro STDT$IS_PORT_SPECIFIC = 112,0,0,1 %;
literal STDT$S_PORT_SPECIFIC = 20;      ! F Port specific space that may be used for any purpose.
! 
! 		Define the length of this structure.
! 
 
!*** MODULE $SYSAPDEF ***
! +
!  SYSAP - FLAGS USED IN THE SYSAP-SCS INTERFACE
! -
! OPTIONS FOR DISPOSING OF
!  SENT DATAGRAM:
!  0 ORIGIN, INCR OF 1:
literal SYSAP$C_DISPQ = 0;              !  DISPOSE ON DG FREE QUEUE
literal SYSAP$C_DISPRET = 1;            !  DISPOSE BY RETURN TO SYSAP
literal SYSAP$C_DISPPO = 2;             !  DISPOSE BY RETURN TO POOL
! FLAGS SPECIFYING TYPE OF DG
!  REC'D FROM REMOTE SYSAP:
!  0 ORIGIN, INCR OF 1:
literal SYSAP$C_DGREC = 0;              !  DG REC'D FROM REMOTE
literal SYSAP$C_DGSNT = 1;              !  DG SENT
 
!*** MODULE $SYSGDEF ***
literal SYSG$M_UCB_CONFIG_CONS = %X'1';
literal SYSG$M_UCB_CONFIG_PPORT = %X'2';
literal SYSG$M_UCB_CONFIG_KBIO = %X'4';
literal SYSG$M_WORKSTATION_PRESENT = %X'1';
literal SYSG$M_WIND_SYS_ACTIVE = %X'2';
literal SYSG$M_ALT_CONSOLE = %X'4';
literal SYSG$M_WIND_SYS_CONSOLE = %X'8';
literal SYSG$M_UNIT0_TX = %X'1';
literal SYSG$M_UNIT0_RX = %X'2';
literal SYSG$M_UNIT1_TX = %X'4';
literal SYSG$M_UNIT1_RX = %X'8';
literal SYSG$M_UNIT2_TX = %X'10';
literal SYSG$M_UNIT2_RX = %X'20';
literal SYSG$M_UNIT3_TX = %X'40';
literal SYSG$M_UNIT3_RX = %X'80';
literal SYSG$M_UNIT4_TX = %X'100';
literal SYSG$M_UNIT4_RX = %X'200';
literal SYSG$S_SYSG = 144;
macro SYSG$IQ_KB_UCB = 0,0,0,0 %;
literal SYSG$S_KB_UCB = 8;              !  Address of UCB for the workstation KB
macro SYSG$IL_KB_UCB_L = 0,0,32,1 %;
macro SYSG$IL_KB_UCB_H = 4,0,32,0 %;
macro SYSG$IQ_MOUSE_UCB = 8,0,0,0 %;
literal SYSG$S_MOUSE_UCB = 8;           !  Address of UCB for the workstation mouse
macro SYSG$IL_MOUSE_UCB_L = 8,0,32,1 %;
macro SYSG$IL_MOUSE_UCB_H = 12,0,32,0 %;
macro SYSG$IL_SYSG_SIZE = 16,0,32,0 %;  !  Length of structure.
macro SYSG$IL_SPARE1 = 20,0,32,0 %;     !  Spare use
macro SYSG$PQ_CTB_PTR = 24,0,0,1 %;
literal SYSG$S_CTB_PTR = 8;             !  Console Terminal Block pointer.
macro SYSG$PL_CTB_PTR_L = 24,0,32,1 %;
macro SYSG$IL_CTB_PTR_H = 28,0,32,0 %;
macro SYSG$IL_UCB_CONFIG = 32,0,32,0 %; !  Tells autoconfig which opa lines should be configured
macro SYSG$V_UCB_CONFIG_CONS = 32,0,1,0 %; !  OPA0 (always configured)
macro SYSG$V_UCB_CONFIG_PPORT = 32,1,1,0 %; !  Printer port (unit 1)
macro SYSG$V_UCB_CONFIG_KBIO = 32,2,1,0 %; !  KB I/O for windows (unit 2)
macro SYSG$IL_FLAGS = 36,0,32,0 %;      !  Flags for the window system
macro SYSG$V_WORKSTATION_PRESENT = 36,0,1,0 %; !  System is a workstation
!  
macro SYSG$V_WIND_SYS_ACTIVE = 36,1,1,0 %; !  Windowing system has been activated
!  (Bit set by server)
macro SYSG$V_ALT_CONSOLE = 36,2,1,0 %;  !  alternate console in use.
macro SYSG$V_WIND_SYS_CONSOLE = 36,3,1,0 %; !  Use windowing system console
!  (Bit set by server)
macro SYSG$IQ_OPWIN_UPDOWN_PD = 40,0,0,0 %;
literal SYSG$S_OPWIN_UPDOWN_PD = 8;     !  Console Visibility Toggle
macro SYSG$IQ_OPWIN_UP_PD = 40,0,0,0 %;
literal SYSG$S_OPWIN_UP_PD = 8;
macro SYSG$IL_OPWIN_UP_PD_L = 40,0,32,0 %;
macro SYSG$IL_OPWIN_UP_PD_H = 44,0,32,0 %;
macro SYSG$IQ_OPWIN_RESIZE_PD = 48,0,0,0 %;
literal SYSG$S_OPWIN_RESIZE_PD = 8;     !  Console Window Resize
macro SYSG$IQ_OPWIN_DOWN_PD = 48,0,0,0 %;
literal SYSG$S_OPWIN_DOWN_PD = 8;
macro SYSG$IL_OPWIN_DOWN_PD_L = 48,0,32,0 %;
macro SYSG$IL_OPWIN_DOWN_PD_H = 52,0,32,0 %;
macro SYSG$IQ_UNIT_INT = 56,0,0,0 %;
literal SYSG$S_UNIT_INT = 8;            !  Unit interrupt bits
macro SYSG$V_UNIT0_TX = 56,0,1,0 %;
macro SYSG$V_UNIT0_RX = 56,1,1,0 %;
macro SYSG$V_UNIT1_TX = 56,2,1,0 %;
macro SYSG$V_UNIT1_RX = 56,3,1,0 %;
macro SYSG$V_UNIT2_TX = 56,4,1,0 %;
macro SYSG$V_UNIT2_RX = 56,5,1,0 %;
macro SYSG$V_UNIT3_TX = 56,6,1,0 %;
macro SYSG$V_UNIT3_RX = 56,7,1,0 %;
macro SYSG$V_UNIT4_TX = 56,8,1,0 %;
macro SYSG$V_UNIT4_RX = 56,9,1,0 %;
macro SYSG$IQ_OPWIN_RESET_PD = 64,0,0,0 %;
literal SYSG$S_OPWIN_RESET_PD = 8;      !  Reset console
macro SYSG$IL_OPWIN_RESET_PD_L = 64,0,32,0 %;
macro SYSG$IL_OPWIN_RESET_PD_H = 68,0,32,0 %;
macro SYSG$IQ_OPWIN_PUTS_PD = 72,0,0,0 %;
literal SYSG$S_OPWIN_PUTS_PD = 8;       !  Put string to console
macro SYSG$IL_OPWIN_PUTS_PD_L = 72,0,32,0 %;
macro SYSG$IL_OPWIN_PUTS_PD_H = 76,0,32,0 %;
macro SYSG$IQ_OPWIN_VISIBLE_PD = 80,0,0,0 %;
literal SYSG$S_OPWIN_VISIBLE_PD = 8;    !  Test visibility
macro SYSG$IL_OPWIN_VISIBLE_PD_L = 80,0,32,0 %;
macro SYSG$IL_OPWIN_VISIBLE_PD_H = 84,0,32,0 %;
macro SYSG$IQ_OPWIN_HALT_PD = 88,0,0,0 %;
literal SYSG$S_OPWIN_HALT_PD = 8;       !  Handle HALT
macro SYSG$IL_OPWIN_HALT_PD_L = 88,0,32,0 %;
macro SYSG$IL_OPWIN_HALT_PD_H = 92,0,32,0 %;
macro SYSG$IQ_OPWIN_CONTINUE_PD = 96,0,0,0 %;
literal SYSG$S_OPWIN_CONTINUE_PD = 8;   !  Handle CONTINUE
macro SYSG$IL_OPWIN_COMTINUE_PD_L = 96,0,32,0 %;
macro SYSG$IL_OPWIN_CONTINUE_PD_H = 100,0,32,0 %;
macro SYSG$IQ_CONSOLE_LANGUAGE_PD = 104,0,0,0 %;
literal SYSG$S_CONSOLE_LANGUAGE_PD = 8; !  Get console language
macro SYSG$IL_CONSOLE_LANGUAGE_PD_L = 104,0,32,0 %;
macro SYSG$IL_CONSOLE_LANGUAGE_PD_H = 108,0,32,0 %;
macro SYSG$IQ_SPARE_1_PD = 112,0,0,0 %;
literal SYSG$S_SPARE_1_PD = 8;          !  Reserved
macro SYSG$IQ_SPARE_2_PD = 120,0,0,0 %;
literal SYSG$S_SPARE_2_PD = 8;          !  Reserved
macro SYSG$IQ_SPARE_3_PD = 128,0,0,0 %;
literal SYSG$S_SPARE_3_PD = 8;          !  Reserved
macro SYSG$IQ_SPARE_4_PD = 136,0,0,0 %;
literal SYSG$S_SPARE_4_PD = 8;          !  Reserved
literal SYSG$K_LENGTH = 144;            !  Length
literal SYSG$C_LENGTH = 144;            !  Length (with a C!)
literal S_SYSG$ = 144;                  !  Old size name - synonym
 
!*** MODULE $SYSPARDEF ***
literal ACP$S_DATACHK = 1;              !  Old size name, synonym for  ACP$S_SYS_DATACHK
literal ACP$S_SYS_DATACHK = 1;          !  Definition for ACP$GB_DATACHK
macro ACP$V_READCHK = 0,0,1,0 %;        !  do datachecks on reads
macro ACP$V_WRITECHK = 0,1,1,0 %;       !  do datachecks on writes
literal ACP$S_SWAPFLAGS = 1;            !  Old size name, synonym for  ACP$S_SYS_SWAPFLAGS
literal ACP$S_SYS_SWAPFLAGS = 1;        !  Definition for ACP$GB_SWAPFLGS
macro ACP$V_SWAPSYS = 0,0,1,0 %;        !  /SYSTEM
macro ACP$V_SWAPGRP = 0,1,1,0 %;        !  /GROUP
macro ACP$V_SWAPPRV = 0,2,1,0 %;        !  other (private mount)
macro ACP$V_SWAPMAG = 0,3,1,0 %;        !  magtape
literal CLU$S_SGN_FLAGS = 4;            !  Old size name, synonym for  CLU$S_SYS_SGN_FLAGS
literal CLU$S_SYS_SGN_FLAGS = 4;        !  Definition for CLU$GL_SGN_FLAGS
macro CLU$V_NISCS_LOAD_PEA0 = 0,0,1,0 %; !  Load PEA0 for NISCS
macro CLU$V_NISCS_CONV_BOOT = 0,1,1,0 %; !  Allow remote conversational boot
literal EXE$M_FATAL_BUG = %X'100';
literal EXE$S_FLAGS = 4;                !  Old size name, synonym for EXE$S_SYS_FLAGS
literal EXE$S_SYS_FLAGS = 4;            !  DEFINITION FOR EXE$GL_FLAGS
macro EXE$V_SYSWRTABL = 0,0,1,0 %;      !  LEAVE SYSTEM READ ONLY CODE WRITABLE
macro EXE$V_NOAUTOCNF = 0,1,1,0 %;      !  NO AUTOMATIC CONFIGURATION OF UBA
macro EXE$V_POOLPGING = 0,2,1,0 %;      !  ENABLE DYNAMIC POOL PAGING
macro EXE$V_SIMULATOR = 0,3,1,0 %;      !  RUNNING ON SIMULATOR
macro EXE$V_CRDENABL = 0,4,1,0 %;       !  ENABLE CRD ERROR DETECTION
macro EXE$V_SBIERR = 0,5,1,0 %;         !  ENABLE SBI ERROR INTERRUPT
macro EXE$V_INIT = 0,6,1,0 %;           !  RMS AND FILE SYSTEM INITIALIZED
macro EXE$V_SETTIME = 0,7,1,0 %;        !  FORCE SOLICITATION OF TIME
macro EXE$V_FATAL_BUG = 0,8,1,0 %;      !  FORCE ALL BUG CHECKS FATAL
macro EXE$V_MULTACP = 0,9,1,0 %;        !  USE MULTIPLE FILE ACP'S
macro EXE$V_NOCLUSTER = 0,10,1,0 %;     !  TURN OFF PAGE FAULT CLUSTERING
macro EXE$V_BUGREBOOT = 0,11,1,0 %;     !  AUTO REBOOT ON BUGCHECK
macro EXE$V_SYSUAFALT = 0,12,1,0 %;     !  ALTERNATE LOGICAL NAME FOR SYSUAF
macro EXE$V_SHRF11ACP = 0,13,1,0 %;     !  MAKE F11ACP SHARABLE AT BOOT TIME
macro EXE$V_BUGDUMP = 0,14,1,0 %;       !  TAKE SYSTEM DUMP ON BUGCHECK
macro EXE$V_RESALLOC = 0,15,1,0 %;      !  ENABLE RESOURCE ALLOCATION CHECKS
macro EXE$V_CONCEALED = 0,16,1,0 %;     !  ENABLE USE OF CONCEALED DEVICES
macro EXE$V_SSINHIBIT = 0,17,1,0 %;     !  INHIBIT SYSTEM SERVICES PER-PROCESS
macro EXE$V_EXPLICITP = 0,18,1,0 %;     !  IF SET TODAY IS CONSIDERED PRIMARY
macro EXE$V_EXPLICITS = 0,19,1,0 %;     !  IF SET TODAY IS CONSIDERED SECONDARY
macro EXE$V_PGFLFRAG = 0,20,1,0 %;      !  SET IF PAGE FILE FRAGMENTED MSG ISSUED
macro EXE$V_PGFLCRIT = 0,21,1,0 %;      !  SET IF PAGE FILE FULL MSG ISSUED
macro EXE$V_TBCHK = 0,22,1,0 %;         !  SET IF PROCESSOR REGISTER TBCHK PRESENT
macro EXE$V_PAGFILDMP = 0,23,1,0 %;     !  SET IF DUMP IS IN PAGE FILE
macro EXE$V_SAVEDUMP = 0,24,1,0 %;      !  SET TO SAVE DUMP UNTIL ANALYZED
macro EXE$V_JOBQUEUES = 0,25,1,0 %;     !  Set if JOBCTL to enable queues
macro EXE$V_REINITQUE = 0,26,1,0 %;     !  Set if JOBCTL to reinitialize JBCSYSQUE
macro EXE$V_WLKSYSDSK = 0,27,1,0 %;     !  Set if system disk is write locked
literal EXE$M_NOCLOCK = %X'1';
literal EXE$M_NOSMPSANITY = %X'2';
literal EXE$M_NOSPINWAIT = %X'4';
literal EXE$S_TIME_CONTROL = 4;         !  Old size name, synonym for EXE$S_SYS_TIME_CONTROL
literal EXE$S_SYS_TIME_CONTROL = 4;     !  DEFINITION FOR EXE$GL_TIME_CONTROL
macro EXE$V_NOCLOCK = 0,0,1,0 %;        !  DO NOT TURN ON CLOCK
macro EXE$V_NOSMPSANITY = 0,1,1,0 %;    !  DISABLE SMP SANITY TIMER TIMEOUTS
macro EXE$V_NOSPINWAIT = 0,2,1,0 %;     !  DISABLE SMP SPIN/BUSYWAIT TIMEOUTS
literal EXE$S_DYNAMIC_FLAGS = 4;        !  Old size name, synonym for EXE$S_SYS_DYNAMIC_FLAGS
literal EXE$S_SYS_DYNAMIC_FLAGS = 4;    !  DEFINITION FOR EXE$GL_DYNAMIC_FLAGS
macro EXE$V_CLASS_PROT = 0,0,1,0 %;     !  Do non-discretionary classification check
macro EXE$V_WRITESYSPARAMS = 0,1,1,0 %; !  Write the active parameters to the system .PAR file
macro EXE$V_BRK_TERM = 0,2,1,0 %;       !  Associate on terminal in breakin detection
macro EXE$V_BRK_DISUSER = 0,3,1,0 %;    !  Disable user account on breakin
macro EXE$V_NOPGFLSWP = 0,4,1,0 %;      !  Disallow swapping into page files
macro EXE$V_LOAD_PWD_POLICY = 0,5,1,0 %; !  Load site-specific password change policy
literal EXE$S_STATIC_FLAGS = 4;         !  Old size name, synonym for EXE$S_SYS_STATIC_FLAGS
literal EXE$S_SYS_STATIC_FLAGS = 4;     !  DEFINITION FOR EXE$GL_STATIC_FLAGS
macro EXE$V_XQP_RESIDENT = 0,0,1,0 %;   !  MEMORY RESIDENT XQP
macro EXE$V_REBLDSYSD = 0,1,1,0 %;      !  REBUILD SYSTEM DISK IN SYSMOUNT
macro EXE$V_OBSSHAD = 0,2,1,0 %;        !  Skip obsolete SHADOWING bit
macro EXE$V_SA_APP = 0,3,1,0 %;         !  Booting stand-alone application (SA-BACKUP)
literal EXE$S_MSGFLAGS = 4;             !  Old size name, synonym for EXE$S_SYS_MSGFLAGS
literal EXE$S_SYS_MSGFLAGS = 4;         !  DEFINITION FOR EXE$GL_MSGFLAGS
macro EXE$V_MOUNTMSG = 0,0,1,0 %;       !  ENABLE MOUNT NOTIFICATION
macro EXE$V_DISMOUMSG = 0,1,1,0 %;      !  ENABLE DISMOUNT NOTIFICATION
literal EXE$S_WSFLAGS = 4;              !  Old size name, synonym for EXE$S_SYS_WSFLAGS
literal EXE$S_SYS_WSFLAGS = 4;          !  DEFINITION FOR EXE$GL_WSFLAGS
macro EXE$V_OPA0 = 0,0,1,0 %;           !  Reserve a window for OPA0
literal SGN$S_LOADFLAGS = 4;            !  Old size name, synonym for SGN$S_SYS_LOADFLAGS
literal SGN$S_SYS_LOADFLAGS = 4;        !  DEFINITION FOR SGN$GL_LOADFLAGS
macro SGN$V_LOAD_SYS_IMAGES = 0,0,1,0 %; !  Alternate load system images
macro SGN$V_EXEC_SLICING = 0,1,1,0 %;   !  Slice system images
macro SGN$V_RELEASE_PFNS = 0,2,1,0 %;   !  Release PFNs in the huge page
 
!*** MODULE $SWRPBDEF ***
literal SWRPB_BOOT_FLAGS$M_CONV = %X'1';
literal SWRPB_BOOT_FLAGS$M_DEBUG = %X'2';
literal SWRPB_BOOT_FLAGS$M_INIBPT = %X'4';
literal SWRPB_BOOT_FLAGS$M_DIAG = %X'8';
literal SWRPB_BOOT_FLAGS$M_BOOBPT = %X'10';
literal SWRPB_BOOT_FLAGS$M_NOHEADER = %X'20';
literal SWRPB_BOOT_FLAGS$M_NOTEST = %X'40';
literal SWRPB_BOOT_FLAGS$M_SOLICIT = %X'80';
literal SWRPB_BOOT_FLAGS$M_HALT = %X'100';
literal SWRPB_BOOT_FLAGS$M_SHADOW = %X'200';
literal SWRPB_BOOT_FLAGS$M_ISL = %X'400';
literal SWRPB_BOOT_FLAGS$M_PALCHECK = %X'800';
literal SWRPB_BOOT_FLAGS$M_DEBUG_BOOT = %X'1000';
literal SWRPB_BOOT_FLAGS$M_CRDFAIL = %X'2000';
literal SWRPB_BOOT_FLAGS$M_ALIGN_FAULTS = %X'4000';
literal SWRPB_BOOT_FLAGS$M_REM_DEBUG = %X'8000';
literal SWRPB_BOOT_FLAGS$M_DBG_INIT = %X'10000';
literal SWRPB_BOOT_FLAGS$M_USER_MSGS = %X'20000';
literal SWRPB_BOOT_FLAGS$M_RSM = %X'40000';
literal SWRPB_BOOT_FLAGS$M_FOREIGN = %X'80000';
literal SWRPB$M_LOAD_SCS = %X'1';
literal SWRPB$M_TAKENODMP = %X'2';
literal SWRPB_LAVC_FLAGS$M_CONV_BOOT_OK = %X'1';
literal SWRPB$C_LENGTH = 160;           !  Length of SWRPB
literal SWRPB$K_LENGTH = 160;           !  Length of SWRPB    
literal SWRPB$S_SWRPBDEF = 160;         !  Old size name - synonym
literal SWRPB$S_SWRPB = 160;
macro SWRPB$PQ_IOVEC_FLINK = 0,0,0,1 %;
literal SWRPB$S_IOVEC_FLINK = 8;        !  IOVEC forward link
macro SWRPB$PL_IOVEC_FLINK_L = 0,0,32,1 %;
macro SWRPB$IL_IOVEC_FLINK_H = 4,0,32,0 %;
macro SWRPB$PQ_IOVEC_BLINK = 8,0,0,1 %;
literal SWRPB$S_IOVEC_BLINK = 8;        !  IOVEC backward link
macro SWRPB$PL_IOVEC_BLINK_L = 8,0,32,1 %;
macro SWRPB$IL_IOVEC_BLINK_H = 12,0,32,0 %;
macro SWRPB$IQ_BOOT_FLAGS = 16,0,0,0 %;
literal SWRPB$S_BOOT_FLAGS = 8;         !  System variation
macro SWRPB$IL_BOOT_FLAGS_L = 16,0,32,0 %;
macro SWRPB_BOOT_FLAGS$V_CONV = 16,0,1,0 %; !  Conversational bootstrap
macro SWRPB_BOOT_FLAGS$V_DEBUG = 16,1,1,0 %; !  Map XDELTA to running system
macro SWRPB_BOOT_FLAGS$V_INIBPT = 16,2,1,0 %; !  Stop at initial system BPT
macro SWRPB_BOOT_FLAGS$V_DIAG = 16,3,1,0 %; !  Diagnostic bootstrap
macro SWRPB_BOOT_FLAGS$V_BOOBPT = 16,4,1,0 %; !  Stop at bootstrap breakpoints
macro SWRPB_BOOT_FLAGS$V_NOHEADER = 16,5,1,0 %; !  No header on 2nd bootstrap
macro SWRPB_BOOT_FLAGS$V_NOTEST = 16,6,1,0 %; !  Inhibit memory test
macro SWRPB_BOOT_FLAGS$V_SOLICIT = 16,7,1,0 %; !  Prompt for 2nd bootstrap file
macro SWRPB_BOOT_FLAGS$V_HALT = 16,8,1,0 %; !  Halt before 2nd bootstrap
macro SWRPB_BOOT_FLAGS$V_SHADOW = 16,9,1,0 %; !  Boot from shaddow set
macro SWRPB_BOOT_FLAGS$V_ISL = 16,10,1,0 %; !  LAD/LAST bootstrap
macro SWRPB_BOOT_FLAGS$V_PALCHECK = 16,11,1,0 %; !  Disable PAL rev check halt
macro SWRPB_BOOT_FLAGS$V_DEBUG_BOOT = 16,12,1,0 %; !  Xfer to 2nd primary bootstrap
macro SWRPB_BOOT_FLAGS$V_CRDFAIL = 16,13,1,0 %; !  Mark CRD pages bad
macro SWRPB_BOOT_FLAGS$V_ALIGN_FAULTS = 16,14,1,0 %; !  Report bootstrap unaligned data traps 
macro SWRPB_BOOT_FLAGS$V_REM_DEBUG = 16,15,1,0 %; !  Allow remote high level lang sys debug
macro SWRPB_BOOT_FLAGS$V_DBG_INIT = 16,16,1,0 %; !  Toggle verbose mode in EXEC_INIT
macro SWRPB_BOOT_FLAGS$V_USER_MSGS = 16,17,1,0 %; !  user messages displayed (subset of verbose mode)
macro SWRPB_BOOT_FLAGS$V_RSM = 16,18,1,0 %; !  Boot is controlled by Remote System Manager
macro SWRPB_BOOT_FLAGS$V_FOREIGN = 16,19,1,0 %; !  Boot involves a foreign disk, either as system
!  device or as installation target
macro SWRPB$IL_BOOT_FLAGS_H = 20,0,32,0 %;
macro SWRPB_BOOT_FLAGS$V_ROOT = 20,16,16,0 %;
literal SWRPB_BOOT_FLAGS$S_ROOT = 16;   !  System root
macro SWRPB$PQ_BTADP = 24,0,0,1 %;
literal SWRPB$S_BTADP = 8;              !  BOOT ADAPTER BLOCK
macro SWRPB$PL_BTADP_L = 24,0,32,1 %;
macro SWRPB$IL_BTADP_H = 28,0,32,0 %;
macro SWRPB$PQ_BOOPARAM = 32,0,0,1 %;
literal SWRPB$S_BOOPARAM = 8;           !  EXEC_INIT Param block
macro SWRPB$PL_BOOPARAM_L = 32,0,32,1 %;
macro SWRPB$IL_BOOPARAM_H = 36,0,32,0 %;
macro SWRPB$PQ_IOCHAN = 40,0,0,1 %;
literal SWRPB$S_IOCHAN = 8;             !  IOCHAN of boot driver
macro SWRPB$PL_IOCHAN_L = 40,0,32,1 %;
macro SWRPB$IL_IOCHAN_H = 44,0,32,0 %;
macro SWRPB$IQ_BOOT_TIME = 48,0,0,0 %;
literal SWRPB$S_BOOT_TIME = 8;          !  Time that system was booted
macro SWRPB$IL_BOOT_TIME_L = 48,0,32,0 %;
macro SWRPB$IL_BOOT_TIME_H = 52,0,32,0 %;
macro SWRPB$IQ_FLAGS = 56,0,0,0 %;
literal SWRPB$S_FLAGS = 8;              !  Other bootstrap flags
macro SWRPB$IL_FLAGS_L = 56,0,32,0 %;
macro SWRPB$V_LOAD_SCS = 56,0,1,0 %;    !  Load SCS code
macro SWRPB$V_TAKENODMP = 56,1,1,0 %;   !  Do not take dump, master 
!   changed for shadowed system 
!   disk.  Note:  On VAX, 
!   TAKENODMP was added to RPB
!   to pass to console reboot
!   logic.
macro SWRPB$IL_FLAGS_H = 60,0,32,0 %;
macro SWRPB$PQ_PORT_CHAN = 64,0,0,1 %;
literal SWRPB$S_PORT_CHAN = 8;          !  PORT_CHAN of port boot driver
macro SWRPB$PL_PORT_CHAN_L = 64,0,32,1 %;
macro SWRPB$IL_PORT_CHAN_H = 68,0,32,0 %;
macro SWRPB$IQ_SCB_SIZE = 72,0,0,0 %;
literal SWRPB$S_SCB_SIZE = 8;           !  Size of the runtime SCB
macro SWRPB$IL_SCB_SIZE_L = 72,0,32,0 %;
macro SWRPB$IL_SCB_SIZE_H = 76,0,32,0 %;
!   The following fields are filled in by APB if a NISCA
!   boot is being performed on a LAVc satellite.  These
!   fields are cluster specific fields.
macro SWRPB$T_SCSNODE = 80,0,0,0 %;
literal SWRPB$S_SCSNODE = 8;            !  System's SCS node name.
macro SWRPB$IQ_SCSSYSTEMID = 88,0,0,0 %;
literal SWRPB$S_SCSSYSTEMID = 8;        !  System's SCSSYSTEMID value.
!   The following fields are filled in by APB if a NISCA
!   boot is being performed on a LAVc satellite.
macro SWRPB$IQ_LAVC_AUTH = 96,0,0,0 %;
literal SWRPB$S_LAVC_AUTH = 8;          !  LAVc authorization code.
macro SWRPB$IL_LAVC_GROUP = 104,0,32,0 %; !  LAVc group number.
macro SWRPB$IL_LAVC_PORT_SERVICES = 108,0,32,0 %; !  NISCA port services.
macro SWRPB$IL_LAVC_FLAGS = 112,0,32,0 %; !  LAVc boot control flags.
macro SWRPB_LAVC_FLAGS$V_CONV_BOOT_OK = 112,0,1,0 %; !  Allow converstational boot.
!   End of fields used for LAVc satellite booting.
!   Define the file system data.
macro SWRPB$T_SYSROOT = 120,0,0,0 %;
literal SWRPB$S_SYSROOT = 40;           !  Root directory on the system disk.  Counted string
!   End of the file system data.
 
!*** MODULE $TASTDEF ***
! 
!  TERMINAL AST PACKET. THIS STRUCTURE IS USED BY TERMINAL SERVICES TO
!  DELIVER OUT OF BAND CHARACTER ASTS.
! 
literal TAST$M_MASK_DSBL = %X'1';
literal TAST$M_INCLUDE = %X'2';
literal TAST$M_ONE_SHOT = %X'4';
literal TAST$M_BUSY = %X'8';
literal TAST$M_LOST = %X'10';
literal TAST$M_ABORT = %X'20';
literal TAST$K_LENGTH = 60;
literal TAST$C_LENGTH = 60;
literal TAST$M_ABO = %X'4000';
literal TAST$M_INC = %X'8000';
literal TAST$S_TAST = 64;
macro TAST$L_FLINK = 36,0,32,1 %;       ! FORWARD LINK 
macro TAST$L_AST = 40,0,32,1 %;         ! SAVED AST ADDRESS 
macro TAST$L_ASTPRM = 44,0,32,0 %;      ! SAVED AST PARAMETER 
macro TAST$L_PID = 48,0,32,0 %;         ! SAVED PID 
macro TAST$B_RMOD = 52,0,8,0 %;         ! SAVED RMOD 
macro TAST$B_CTRL = 53,0,8,0 %;         ! CONTROL FIELD 
macro TAST$V_MASK_DSBL = 53,0,1,0 %;    ! DISABLE MASK PROCESSING 
macro TAST$V_INCLUDE = 53,1,1,0 %;      ! INCLUDE CHARACTER 
macro TAST$V_ONE_SHOT = 53,2,1,0 %;     ! ONE SHOT AST 
macro TAST$V_BUSY = 53,3,1,0 %;         ! BLOCK BUSY 
macro TAST$V_LOST = 53,4,1,0 %;         ! AST LOST
macro TAST$V_ABORT = 53,5,1,0 %;        ! ABORT I/O
macro TAST$W_CHAN = 54,0,16,0 %;        ! CHANNEL 
macro TAST$L_MASK = 56,0,32,0 %;        ! OUT OF BAND MASK 
macro TAST$R_STATUS_BITS = 60,0,16,0 %;
macro TAST$V_FILL = 60,0,14,0 %;
literal TAST$S_FILL = 14;               !  First byte and spares
macro TAST$V_ABO = 60,14,1,0 %;         !  ABORT flag
macro TAST$V_INC = 60,15,1,0 %;         !  INCLUDE flag
literal TAST$S_TASTDEF = 64;            !  Old size name, synonym for TAST$S_TAST
 
!*** MODULE $TLVDEF ***
!  Define the layout of a general purpose type-length-value structure which is
!  used to pass a variety of data structures around the cluster.
literal TLV$K_MAX_ORB_LENGTH = 13312;
literal TLV$K_MAX_ARB_LENGTH = 8448;    !  8360 rounded up to %x2100
literal TLV$K_MAX_IDENTIFIERS = 1024;   !  maximum number of rights IDs
literal TLV$S_CHECKSUM = 8;             !  header minus checksum
literal TLV$K_MSG_HDR_LENGTH = 24;      !  message header length
literal TLV$K_VERSION_1 = 1;            !  version number 1
literal TLV$K_VERSION_2 = 2;            !  version number 2 (Blade)
literal TLV$K_CURRENT_VERSION = 2;      !  current protocol
literal TLV$K_GRANULARITY = 7;          !  allocation granularity
literal TLV$S_HEADER = 24;
macro TLV$L_CHECKSUM = 0,0,32,0 %;      !  checksum (includes header)
macro TLV$L_UNUSED_L1 = 4,0,32,0 %;     !  start of checksum
macro TLV$L_MSG_SIZE = 8,0,32,0 %;      !  message size
macro TLV$W_MSG_COUNT = 12,0,16,0 %;    !  # of packets in message
macro TLV$B_VERSION = 14,0,8,0 %;       !  TLV protocol version number
macro TLV$Q_SECURITY_DOMAIN = 16,0,0,0 %;
literal TLV$S_SECURITY_DOMAIN = 8;      !  security domain ($KGBDEF)
literal TLV$K_PKT_HDR_LENGTH = 4;       !  packet header length
literal TLV$S_PACKET = 8;
macro TLV$W_TYPE = 0,0,16,0 %;          !  packet type
macro TLV$W_LENGTH = 2,0,16,0 %;        !  packet length (including packet header)
macro TLV$R_VALUE = 4,0,32,0 %;         !  offset to start of data
 
!*** MODULE $TQEDEF ***
! +
!  TQE - TIME QUEUE ENTRY
! 
!  TIME QUEUE ENTRIES ARE UTILIZED TO SET TIMERS, WAKE UP PROCESSES, AND
!  FOR INTERNAL SYSTEM SUBROUTINES.
! -
literal TQE$M_REPEAT = %X'4';
literal TQE$M_ABSOLUTE = %X'8';
literal TQE$M_CHK_CPUTIM = %X'10';
literal TQE$C_TMSNGL = 0;               ! TIMER ENTRY SINGLE SHOT REQUEST 
literal TQE$C_SSREPT = 5;               ! SYSTEM SUBROUTINE REPEAT REQUEST 
literal TQE$C_SSSNGL = 1;               ! SYSTEM SUBROUTINE SINGLE SHOT REQUEST 
literal TQE$C_WKREPT = 6;               ! WAKE ENTRY REPEAT REQUEST 
literal TQE$C_WKSNGL = 2;               ! WAKE ENTRY SINGLE SHOT REQUEST 
literal TQE$S_TQEDEF = 64;              !  Old size name - synonym    
literal TQE$S_TQE = 64;
macro TQE$L_TQFL = 0,0,32,1 %;          ! TIME QUEUE FORWARD LINK 
macro TQE$L_TQBL = 4,0,32,1 %;          ! TIME QUEUE BACKWARD LINK 
macro TQE$W_SIZE = 8,0,16,0 %;          ! SIZE OF TQE IN BYTES 
macro TQE$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE FOR TQE 
macro TQE$B_RQTYPE = 11,0,8,0 %;        ! TIME QUEUE ENTRY TYPE 
macro TQE$V_REPEAT = 11,2,1,0 %;        !  REPEAT REQUEST (1=YES) 
macro TQE$V_ABSOLUTE = 11,3,1,0 %;      !  Absolute expiration time specified 
macro TQE$V_CHK_CPUTIM = 11,4,1,0 %;    !  Process CPU time constrained request
macro TQE$L_PID = 12,0,32,0 %;          ! TIMER OR WAKE REQUEST PROCESS ID 
macro TQE$L_FPC = 12,0,32,1 %;          ! TIMER SUBROUTINE ADDRESS 
macro TQE$L_AST = 16,0,32,1 %;          ! ADDRESS OF AST ROUTINE 
macro TQE$L_ASTPRM = 20,0,32,0 %;       ! AST PARAMETER 
macro TQE$Q_FR3 = 16,0,0,1 %;
literal TQE$S_FR3 = 8;                  ! TIMER SUBROUTINE SAVED R3 
macro TQE$Q_FR4 = 24,0,0,1 %;
literal TQE$S_FR4 = 8;                  ! TIMER SUBROUTINE SAVED R4 
macro TQE$Q_TIME = 32,0,0,0 %;
literal TQE$S_TIME = 8;                 ! ABSOLUTE EXPIRATION TIME 
macro TQE$Q_DELTA = 40,0,0,0 %;
literal TQE$S_DELTA = 8;                ! DELTA REPEAT TIME 
macro TQE$L_RMOD = 48,0,32,0 %;         ! ACCESS MODE OF REQUEST 
macro TQE$L_EFN = 52,0,32,0 %;          ! EVENT FLAG NUMBER AND EVENT GROUP 
macro TQE$L_RQPID = 56,0,32,0 %;        ! REQUESTER PROCESS ID 
macro TQE$L_CPUTIM = 60,0,32,0 %;       !  Process CPU time at which entry becomes due
! 
!  TIME QUEUE ENTRY REQUEST TYPE DEFINITIONS
! 
literal TQE$K_LENGTH = 64;              ! LENGTH OF STANDARD TQE 
literal TQE$C_LENGTH = 64;              ! LENGTH OF STANDARD TQE 
 
!*** MODULE $TSRVDEF ***
! +
!  TSRV  ( )  Definitions
! 
! 	This module defines the main data structure of the TMSCP
! 	server. This structure contains the values specified in
! 	the start up qualifiers when the server was loaded, the 
! 	UQB vector table, and statistics that are kept for server
! 	performance measurements.
! 	
! 	This structure is being checked in with fields aligned
! 	to the MSCP structure DSRV. This is not a requirement
! 	and may be changed in the future if necessary.
! 
!  <<== !NOTICE! ==>>
! 
! 	DO NOT change offsets of the top part of the data structure.
!  	If new fields have to be added please make them below the 
! 	forward and backward links to the UQB.
! -
literal TSRV$M_LOG_ENABLD = %X'1';
literal TSRV$M_LOG_PRESENT = %X'2';
literal TSRV$M_PKT_LOGGED = %X'4';
literal TSRV$M_PKT_LOST = %X'8';
literal TSRV$M_LBSTEP1 = %X'10';
literal TSRV$M_LBSTEP2 = %X'20';
literal TSRV$M_LBEVENT = %X'40';
literal TSRV$M_HULB_DEL = %X'80';
literal TSRV$M_MON_ACTIVE = %X'100';
literal TSRV$M_LB_REQ = %X'200';
literal TSRV$C_LENGTH = 1900;
literal TSRV$K_LENGTH = 1900;
literal TSRV$K_AR_ADD = 2;              !  Action routine code
literal TSRV$S_TSRV = 1900;
macro TSRV$L_FLINK = 0,0,32,1 %;        !  Field maintained for 
macro TSRV$L_BLINK = 4,0,32,1 %;        !   compatability
macro TSRV$W_SIZE = 8,0,16,0 %;         !  Structure size in bytes
macro TSRV$B_TYPE = 10,0,8,0 %;         !  MSCP type structure
macro TSRV$B_SUBTYPE = 11,0,8,0 %;      !   with a TSRV subtype      (1)
macro TSRV$W_STATE = 12,0,16,0 %;       !  Current state of the server
macro TSRV$V_LOG_ENABLD = 12,0,1,0 %;   !  Logging is enabled
macro TSRV$V_LOG_PRESENT = 12,1,1,0 %;  !  Logging code is present
macro TSRV$V_PKT_LOGGED = 12,2,1,0 %;   !  A packet has been logged
macro TSRV$V_PKT_LOST = 12,3,1,0 %;     !  One or more packets over-
!   written since last read
macro TSRV$V_LBSTEP1 = 12,4,1,0 %;      !  Load balancing step1 active
macro TSRV$V_LBSTEP2 = 12,5,1,0 %;      !  Load balancing step2 active
macro TSRV$V_LBEVENT = 12,6,1,0 %;      !  An event of interest to LB has
!   occured while STEP1 was active
macro TSRV$V_HULB_DEL = 12,7,1,0 %;     !  One or more HULBs to be deleted
macro TSRV$V_MON_ACTIVE = 12,8,1,0 %;   !  The load monitor thread is active
macro TSRV$V_LB_REQ = 12,9,1,0 %;       !  A load balance request has been sent
macro TSRV$W_BUFWAIT = 14,0,16,0 %;     ! I/Os that had to wait
macro TSRV$L_LOG_BUF_START = 16,0,32,1 %; !  Address of start of buffer
macro TSRV$L_LOG_BUF_END = 20,0,32,1 %; !  Address of end of buffer
macro TSRV$L_NEXT_READ = 24,0,32,1 %;   !  Adrs of next packet to read
macro TSRV$L_NEXT_WRITE = 28,0,32,1 %;  !  Adrs of next packet to write
macro TSRV$W_INC_LOLIM = 32,0,16,0 %;   !  Low unit number to log
macro TSRV$W_INC_HILIM = 34,0,16,0 %;   !  High unit number to log
macro TSRV$W_EXC_LOLIM = 36,0,16,0 %;   !  Low unit number not to log
macro TSRV$W_EXC_HILIM = 38,0,16,0 %;   !  High unit number not to log
macro TSRV$W_VERSION = 60,0,16,0 %;     !  Server software version
macro TSRV$W_CFLAGS = 62,0,16,0 %;      !  Controller flags
macro TSRV$W_CTIMO = 64,0,16,0 %;       !  Controller timeout
macro TSRV$Q_CTRL_ID = 68,0,0,0 %;
literal TSRV$S_CTRL_ID = 8;             !  Unique MSCP device identifier
macro TSRV$W_NUM_HOST = 92,0,16,0 %;    !  Count of hosts being served
macro TSRV$W_NUM_UNIT = 94,0,16,0 %;    !  Count of disks being served
macro TSRV$L_HQB_FL = 96,0,32,1 %;      !  Host queue block list head
macro TSRV$L_HQB_BL = 100,0,32,1 %;     ! 
macro TSRV$L_UQB_FL = 104,0,32,1 %;     !  Unit queue block list head
macro TSRV$L_UQB_BL = 108,0,32,1 %;     ! 
macro TSRV$L_UNITS = 196,0,0,1 %;
literal TSRV$S_UNITS = 1024;            !  Table of UQB addresses
! 
!  new fields should be added here, after the UQB linkages
! 
! 
! 	Statistics gathering fields
! 
! 	Two tables are maintained below. The first table is made up of the 
! 	frequency count for each of the opcodes received since the server
! 	was loaded. The opcode is used as an index into the table to its own
! 	frequency count (the zeroeth element contains a total count). The 
! 	second table is made up of the frequency counters for all the
! 	different sized block transfers. For this table, the size of the 
! 	transfer is the index into the table.
! 
macro TSRV$L_OPCOUNT = 1220,0,32,0 %;   !  Total operations count
macro TSRV$L_ABORT_CNT = 1224,0,32,0 %; !    - 1 -
macro TSRV$L_GET_CMD_CNT = 1228,0,32,0 %; !    - 2 -
macro TSRV$L_GET_UNT_CNT = 1232,0,32,0 %; !    - 3 -
macro TSRV$L_SET_CON_CNT = 1236,0,32,0 %; !    - 4 -
macro TSRV$L_AVAIL_CNT = 1252,0,32,0 %; !    - 8 -
macro TSRV$L_ONLIN_CNT = 1256,0,32,0 %; !    - 9 -
macro TSRV$L_SET_UNT_CNT = 1260,0,32,0 %; !    - 10 -
macro TSRV$L_DET_ACC_CNT = 1264,0,32,0 %; !    - 11 -
macro TSRV$L_ACCES_CNT = 1284,0,32,0 %; !    - 16 -
macro TSRV$L_CMP_CON_CNT = 1288,0,32,0 %; !    - 17 -
macro TSRV$L_ERASE_CNT = 1292,0,32,0 %; !    - 18 -
macro TSRV$L_FLUSH_CNT = 1296,0,32,0 %; !    - 19 -
macro TSRV$L_REPLC_CNT = 1300,0,32,0 %; !    - 20 -
macro TSRV$L_CMP_HST_CNT = 1348,0,32,0 %; !    - 32 -
macro TSRV$L_READ_CNT = 1352,0,32,0 %;  !    - 33 -
macro TSRV$L_WRITE_CNT = 1356,0,32,0 %; !    - 34 -
macro TSRV$L_VCFAIL_CNT = 1380,0,32,0 %; !  Count of VC failures
macro TSRV$L_BLKCOUNT = 1384,0,0,0 %;
literal TSRV$S_BLKCOUNT = 516;          !  Counters for block xfer reqs
 
!*** MODULE $UAFDEF ***
! ++
!  User authorization file format
!  Note: With the exception of the username and account name,
!  all strings are blank padded counted strings. Username and
!  account name are uncounted, blank padded.
! --
literal UAF$C_USER_ID = 1;              !  main user ID record
literal UAF$C_VERSION1 = 1;             !  this version
literal UAF$C_KEYED_PART = 52;          !  ISAM keys come this far
literal UAF$C_MAX_PWD_LENGTH = 32;      !  maximum plaintext password length
literal UAF$K_MAX_PWD_LENGTH = 32;      !  maximum plaintext password length
literal UAF$C_AD_II = 0;                !  AUTODIN-II 32 bit crc code
literal UAF$C_PURDY = 1;                !  Purdy polynomial over salted input
literal UAF$C_PURDY_V = 2;              !  Purdy polynomial + variable length username
literal UAF$C_PURDY_S = 3;              !  PURDY_V folded into password length
literal UAF$K_CURRENT_ALGORITHM = 3;    !  current DEC algorithm number
literal UAF$C_CURRENT_ALGORITHM = 3;    !  current DEC algorithm number
literal UAF$C_PREFERED_ALGORITHM = 127;
literal UAF$K_PREFERED_ALGORITHM = 127;
literal UAF$C_PREFERRED_ALGORITHM = 127; !  preferred hash algorithm - use current
literal UAF$K_PREFERRED_ALGORITHM = 127; !  preferred hash algorithm - use current
literal UAF$C_CUST_ALGORITHM = 128;     !  customer algorithm division
literal UAF$K_CUST_ALGORITHM = 128;     !  customer algorithm division
literal UAF$K_FIXED = 644;              !  length of fixed portion
literal UAF$C_FIXED = 644;              !  length of fixed portion
literal UAF$K_LENGTH = 1412;
literal UAF$C_LENGTH = 1412;
literal UAF$S_UAFDEF = 1412;            !  Old size name, synonym for  UAF$S_UAF
literal UAF$S_UAF = 1412;
macro UAF$B_RTYPE = 0,0,8,0 %;          !  UAF record type
macro UAF$B_VERSION = 1,0,8,0 %;        !  UAF format version
macro UAF$W_USRDATOFF = 2,0,16,0 %;     !  offset of counted string of user data
macro UAF$T_USERNAME = 4,0,0,0 %;
literal UAF$S_USERNAME = 32;            !  username
macro UAF$T_USERNAME_TAG = 35,0,8,0 %;  !  tag to differentiate records
macro UAF$L_UIC = 36,0,32,0 %;          !  user ID code
macro UAF$W_MEM = 36,0,16,0 %;          !  member subfield
macro UAF$W_GRP = 38,0,16,0 %;          !  group subfield
macro UAF$L_SUB_ID = 40,0,32,0 %;       !  user sub-identifier
macro UAF$Q_PARENT_ID = 44,0,0,0 %;
literal UAF$S_PARENT_ID = 8;            !  identifier of owner of this account
macro UAF$T_ACCOUNT = 52,0,0,0 %;
literal UAF$S_ACCOUNT = 32;             !  account name
macro UAF$T_OWNER = 84,0,0,0 %;
literal UAF$S_OWNER = 32;               !  owner's name
macro UAF$T_DEFDEV = 116,0,0,0 %;
literal UAF$S_DEFDEV = 32;              !  default device
macro UAF$T_DEFDIR = 148,0,0,0 %;
literal UAF$S_DEFDIR = 64;              !  default directory
macro UAF$T_LGICMD = 212,0,0,0 %;
literal UAF$S_LGICMD = 64;              !  login command file
macro UAF$T_DEFCLI = 276,0,0,0 %;
literal UAF$S_DEFCLI = 32;              !  default command interpreter
macro UAF$T_CLITABLES = 308,0,0,0 %;
literal UAF$S_CLITABLES = 32;           !  user CLI tables
macro UAF$Q_PWD = 340,0,0,0 %;
literal UAF$S_PWD = 8;                  !  hashed password
macro UAF$L_PWD = 340,0,32,0 %;         !  32 bit subfield
macro UAF$Q_PWD2 = 348,0,0,0 %;
literal UAF$S_PWD2 = 8;                 !  second password
macro UAF$W_LOGFAILS = 356,0,16,0 %;    !  count of login failures
macro UAF$W_SALT = 358,0,16,0 %;        !  random password salt
macro UAF$B_ENCRYPT = 360,0,8,0 %;      !  primary password hash algorithm
!  known hash algorithm indices
macro UAF$B_ENCRYPT2 = 361,0,8,0 %;     !  secondary password hash algorithm
macro UAF$B_PWD_LENGTH = 362,0,8,0 %;   !  minimum password length
macro UAF$Q_EXPIRATION = 364,0,0,0 %;
literal UAF$S_EXPIRATION = 8;           !  expiration date for account
macro UAF$Q_PWD_LIFETIME = 372,0,0,0 %;
literal UAF$S_PWD_LIFETIME = 8;         !  password lifetime
macro UAF$Q_PWD_DATE = 380,0,0,0 %;
literal UAF$S_PWD_DATE = 8;             !  date of password change
macro UAF$Q_PWD2_DATE = 388,0,0,0 %;
literal UAF$S_PWD2_DATE = 8;            !  date of 2nd password change
macro UAF$Q_LASTLOGIN_I = 396,0,0,0 %;
literal UAF$S_LASTLOGIN_I = 8;          !  date of last interactive login
macro UAF$Q_LASTLOGIN_N = 404,0,0,0 %;
literal UAF$S_LASTLOGIN_N = 8;          !  date of last non-interactive login
macro UAF$Q_PRIV = 412,0,0,0 %;
literal UAF$S_PRIV = 8;                 !  process privilege vector
macro UAF$Q_DEF_PRIV = 420,0,0,0 %;
literal UAF$S_DEF_PRIV = 8;             !  default process privileges
macro UAF$R_MIN_CLASS = 428,0,0,0 %;
literal UAF$S_MIN_CLASS = 20;           !  minimum security class
macro UAF$R_MAX_CLASS = 448,0,0,0 %;
literal UAF$S_MAX_CLASS = 20;           !  maximum security class
macro UAF$L_FLAGS = 468,0,32,0 %;       !  user flags longword
macro UAF$V_DISCTLY = 468,0,1,0 %;      !  no user control-y
macro UAF$V_DEFCLI = 468,1,1,0 %;       !  only allow user default CLI
macro UAF$V_LOCKPWD = 468,2,1,0 %;      !  disable SET PASSWORD command
macro UAF$V_RESTRICTED = 468,3,1,0 %;   !  restricted account (pre-V5.2 CAPTIVE)
macro UAF$V_DISACNT = 468,4,1,0 %;      !  no interactive login
macro UAF$V_DISWELCOM = 468,5,1,0 %;    !  skip welcome message
macro UAF$V_DISMAIL = 468,6,1,0 %;      !  skip new mail message
macro UAF$V_NOMAIL = 468,7,1,0 %;       !  disable mail delivery
macro UAF$V_GENPWD = 468,8,1,0 %;       !  passwords must be generated
macro UAF$V_PWD_EXPIRED = 468,9,1,0 %;  !  password has expired
macro UAF$V_PWD2_EXPIRED = 468,10,1,0 %; !  2nd password has expired
macro UAF$V_AUDIT = 468,11,1,0 %;       !  audit all actions
macro UAF$V_DISREPORT = 468,12,1,0 %;   !  skip last login messages
macro UAF$V_DISRECONNECT = 468,13,1,0 %; !  inhibit reconnections
macro UAF$V_AUTOLOGIN = 468,14,1,0 %;   !  auto-login only
macro UAF$V_DISFORCE_PWD_CHANGE = 468,15,1,0 %; !  disable forced password change
macro UAF$V_CAPTIVE = 468,16,1,0 %;     !  captive account (no overrides)
macro UAF$V_DISIMAGE = 468,17,1,0 %;    !  disable arbitrary image activation
macro UAF$V_DISPWDDIC = 468,18,1,0 %;   !  disable password dictionary search
macro UAF$V_DISPWDHIS = 468,19,1,0 %;   !  disable password history search
macro UAF$V_DEFCLSVAL = 468,20,1,0 %;   !  default classification is valid
macro UAF$B_NETWORK_ACCESS_P = 472,0,24,0 %;
literal UAF$S_NETWORK_ACCESS_P = 3;     !  hourly network access, primary
macro UAF$B_NETWORK_ACCESS_S = 475,0,24,0 %;
literal UAF$S_NETWORK_ACCESS_S = 3;     !  hourly network access, secondary
macro UAF$B_BATCH_ACCESS_P = 478,0,24,0 %;
literal UAF$S_BATCH_ACCESS_P = 3;       !  hourly batch access, primary
macro UAF$B_BATCH_ACCESS_S = 481,0,24,0 %;
literal UAF$S_BATCH_ACCESS_S = 3;       !  hourly batch access, secondary
macro UAF$B_LOCAL_ACCESS_P = 484,0,24,0 %;
literal UAF$S_LOCAL_ACCESS_P = 3;       !  hourly local access, primary
macro UAF$B_LOCAL_ACCESS_S = 487,0,24,0 %;
literal UAF$S_LOCAL_ACCESS_S = 3;       !  hourly local access, secondary
macro UAF$B_DIALUP_ACCESS_P = 490,0,24,0 %;
literal UAF$S_DIALUP_ACCESS_P = 3;      !  hourly dialup access, primary
macro UAF$B_DIALUP_ACCESS_S = 493,0,24,0 %;
literal UAF$S_DIALUP_ACCESS_S = 3;      !  hourly dialup access, secondary
macro UAF$B_REMOTE_ACCESS_P = 496,0,24,0 %;
literal UAF$S_REMOTE_ACCESS_P = 3;      !  hourly remote access, primary
macro UAF$B_REMOTE_ACCESS_S = 499,0,24,0 %;
literal UAF$S_REMOTE_ACCESS_S = 3;      !  hourly remote access, secondary
macro UAF$B_PRIMEDAYS = 514,0,8,0 %;    !  bits representing primary days
macro UAF$V_MONDAY = 514,0,1,0 %;       !  bit clear means this is a primary day
macro UAF$V_TUESDAY = 514,1,1,0 %;      !  bit set means this is an off day
macro UAF$V_WEDNESDAY = 514,2,1,0 %;
macro UAF$V_THURSDAY = 514,3,1,0 %;
macro UAF$V_FRIDAY = 514,4,1,0 %;
macro UAF$V_SATURDAY = 514,5,1,0 %;
macro UAF$V_SUNDAY = 514,6,1,0 %;
macro UAF$B_PRI = 516,0,8,0 %;          !  base process priority
macro UAF$B_QUEPRI = 517,0,8,0 %;       !  maximum job queuing priority
macro UAF$W_MAXJOBS = 518,0,16,0 %;     !  maximum jobs for UIC allowed
!  0 means no limit
macro UAF$W_MAXACCTJOBS = 520,0,16,0 %; !  maximum jobs for account allowed
!  0 means no limit
macro UAF$W_MAXDETACH = 522,0,16,0 %;   !  maximum detached processes for UIC
!  0 means no limit
macro UAF$W_PRCCNT = 524,0,16,0 %;      !  subprocess creation limit
macro UAF$W_BIOLM = 526,0,16,0 %;       !  buffered I/O limit
macro UAF$W_DIOLM = 528,0,16,0 %;       !  direct I/O limit
macro UAF$W_TQCNT = 530,0,16,0 %;       !  timer queue entry limit
macro UAF$W_ASTLM = 532,0,16,0 %;       !  AST queue limit
macro UAF$W_ENQLM = 534,0,16,0 %;       !  enqueue limit
macro UAF$W_FILLM = 536,0,16,0 %;       !  open file limit
macro UAF$W_SHRFILLM = 538,0,16,0 %;    !  shared file limit
macro UAF$L_WSQUOTA = 540,0,32,0 %;     !  working set size quota
macro UAF$L_DFWSCNT = 544,0,32,0 %;     !  default working set size
macro UAF$L_WSEXTENT = 548,0,32,0 %;    !  working set size limit
macro UAF$L_PGFLQUOTA = 552,0,32,0 %;   !  page file quota
macro UAF$L_CPUTIM = 556,0,32,0 %;      !  CPU time quota
macro UAF$L_BYTLM = 560,0,32,0 %;       !  buffered I/O byte count limit
macro UAF$L_PBYTLM = 564,0,32,0 %;      !  paged buffer I/O byte count limit
macro UAF$L_JTQUOTA = 568,0,32,0 %;     !  job-wide logical name table creation quota
macro UAF$W_PROXY_LIM = 572,0,16,0 %;   !  number of proxies user can grant
macro UAF$W_PROXIES = 574,0,16,0 %;     !  number of proxies granted
macro UAF$W_ACCOUNT_LIM = 576,0,16,0 %; !  number of sub-accounts allowed
macro UAF$W_ACCOUNTS = 578,0,16,0 %;    !  number of sub-accounts in use
macro UAF$R_DEF_CLASS = 580,0,0,0 %;
literal UAF$S_DEF_CLASS = 20;           !  default security class
 
!*** MODULE $UASDEF ***
! +
!  UNIBUS ADDRESS SPACE REGISTER DEFINITIONS FOR DW750
!  	(SECOND UNIBUS ADAPTER ON 11/750)
! -
literal UAS$M_IP_CR1_PIE = %X'1000';
literal UAS$M_IP_CR1_PDN = %X'2000';
literal UAS$S_UASDEF = 5222;
literal UAS$S_UAS = 5222;
macro UAS$R_IP = 5216,0,0,0 %;
literal UAS$S_IP = 6;                   !  INTER-PROCESSOR EXERCISER COMMUNICATOR
macro UAS$W_IP_CR1 = 5220,0,16,0 %;     !  THE THIRD IPEC REGISTER, CR1
macro UAS$V_IP_CR1_PIE = 5220,12,1,0 %; !  POWERFAIL INTERRUPT ENABLE
macro UAS$V_IP_CR1_PDN = 5220,13,1,0 %; !  POWER DOWN STATUS BIT
 
!*** MODULE $UBIDEF ***
! +
!  UNIBUS INTERCONNECT (VAX 11/750 & 11/730) REGISTER OFFSETS AND FIELDS
! -
literal UBI$M_DPR_PUR = %X'1';
literal UBI$M_DPR_UCE = %X'20000000';
literal UBI$M_DPR_NXM = %X'40000000';
literal UBI$M_DPR_ERROR = %X'80000000';
literal UBI$S_UBIDEF = 16;
macro UBI$L_DPR = 0,0,0,0 %;
literal UBI$S_DPR = 16;                 ! DATAPATH REGISTERS 
!  (DPR 0 NOT IMPLEMENTED)
macro UBI$V_DPR_PUR = 0,0,1,0 %;        !  DATAPATH PURGE 
macro UBI$V_DPR_UCE = 0,29,1,0 %;       !  UNCORRECTABLE ERROR 
macro UBI$V_DPR_NXM = 0,30,1,0 %;       !  NON-EXISTENT MEMORY 
macro UBI$V_DPR_ERROR = 0,31,1,0 %;     !  ERROR (UCE!NXM) 
literal UBI$M_DSR_CD = %X'8000000';
literal UBI$S_UBIDEF1 = 32;
macro UBI$L_DSR = 16,0,0,0 %;
literal UBI$S_DSR = 16;                 ! DIAGNOSTIC STATUS REGISTERS 
!  (DSR 0 NOT IMPLEMENTED)
macro UBI$V_DSR_CD = 16,27,1,0 %;       !  ALL 4 BYTES IN BDP FULL 
macro UBI$V_DSR_BF = 16,28,4,0 %;
literal UBI$S_DSR_BF = 4;               !  BYTE 0,1,2,3 IN BDP HAS VALID DATA 
literal UBI$M_SR_UWE = %X'4000';
literal UBI$M_SR_MRPE = %X'8000';
literal UBI$M_SR_NXM = %X'10000';
literal UBI$M_SR_UCE = %X'80000000';
literal UBI$S_UBIDEF2 = 20;
macro UBI$L_SR = 16,0,32,0 %;           ! UB STATUS REGISTER: 
macro UBI$V_SR_UWE = 16,14,1,0 %;       !  UNCORRECTED WRITE ERROR 
macro UBI$V_SR_MRPE = 16,15,1,0 %;      !  MAP REGISTER PARITY ERROR 
macro UBI$V_SR_NXM = 16,16,1,0 %;       !  NONEXISTENT MEMORY REF 
macro UBI$V_SR_UCE = 16,31,1,0 %;       !  UNCORRECTED READ ERROR 
! END OF CPU_SPECIFIC REGISTERS
literal UBI$C_MAXDP = 3;                ! MAXIMUM DATAPATH ! 
literal UBI$C_PURCNT = 10;              ! MAX ! OF TESTS OF PURGE DONE 
literal UBI$S_UBIDEF3 = 4032;
macro UBI$L_MAP = 2048,0,0,0 %;
literal UBI$S_MAP = 1984;               ! MAP REGISTERS, SAME FORMAT AS UBA 
 
!*** MODULE $UBMDDEF ***
! +
!  UBMD - UNIBUS Map Descriptor used to record UNIBUS map registers
!         and datapaths allocated.
! -
literal UBMD$S_UBMDDEF = 4;
literal UBMD$S_UBMD = 4;
macro UBMD$W_MAPREG = 0,0,16,0 %;       !  Starting map register 
macro UBMD$B_NUMREG = 2,0,8,0 %;        !  Number of registers in extent 
macro UBMD$B_DATAPATH = 3,0,8,0 %;      !  Associated Buffered datapath 
 
!*** MODULE $UCBDEF ***
literal UCB$M_TIM = %X'1';
literal UCB$M_INT = %X'2';
literal UCB$M_ERLOGIP = %X'4';
literal UCB$M_CANCEL = %X'8';
literal UCB$M_ONLINE = %X'10';
literal UCB$M_POWER = %X'20';
literal UCB$M_TIMOUT = %X'40';
literal UCB$M_INTTYPE = %X'80';
literal UCB$M_BSY = %X'100';
literal UCB$M_MOUNTING = %X'200';
literal UCB$M_DEADMO = %X'400';
literal UCB$M_VALID = %X'800';
literal UCB$M_UNLOAD = %X'1000';
literal UCB$M_TEMPLATE = %X'2000';
literal UCB$M_MNTVERIP = %X'4000';
literal UCB$M_WRONGVOL = %X'8000';
literal UCB$M_DELETEUCB = %X'10000';
literal UCB$M_LCL_VALID = %X'20000';
literal UCB$M_SUPMVMSG = %X'40000';
literal UCB$M_MNTVERPND = %X'80000';
literal UCB$M_DISMOUNT = %X'100000';
literal UCB$M_CLUTRAN = %X'200000';
literal UCB$M_WRTLOCKMV = %X'400000';
literal UCB$M_SVPN_END = %X'800000';
literal UCB$M_ALTBSY = %X'1000000';
literal UCB$M_SNAPSHOT = %X'2000000';
literal UCB$M_NO_ASSIGN = %X'4000000';
literal UCB$M_EXFUNC_SUPP = %X'8000000';
literal UCB$M_JOB = %X'1';
literal UCB$M_TEMPL_BSY = %X'40';
literal UCB$M_PRMMBX = %X'1';
literal UCB$M_DELMBX = %X'2';
literal UCB$M_TT_TIMO = %X'2';
literal UCB$M_TT_NOTIF = %X'4';
literal UCB$M_TT_HANGUP = %X'8';
literal UCB$M_TT_NOLOGINS = %X'8000';
literal UCB$M_NT_BFROVF = %X'4';
literal UCB$M_NT_NAME = %X'10';
literal UCB$M_NT_BREAK = %X'20';
literal UCB$M_ECC = %X'1';
literal UCB$M_DIAGBUF = %X'2';
literal UCB$M_NOCNVRT = %X'4';
literal UCB$M_DX_WRITE = %X'8';
literal UCB$M_DATACACHE = %X'10';
literal UCB$M_MSCP_MNTVERIP = %X'100';
literal UCB$M_MSCP_INITING = %X'200';
literal UCB$M_MSCP_WAITBMP = %X'400';
literal UCB$M_MSCP_FLOVR = %X'800';
literal UCB$M_MSCP_PKACK = %X'1000';
literal UCB$M_MSCP_WRTP = %X'2000';
literal UCB$M_MSCP_IGNSRV = %X'4000';
literal UCB$M_DU_SHMV_STRTD = %X'8';
literal UCB$M_DU_0MNOTE = %X'20';
literal UCB$M_TU_OVRSQCHK = %X'1';
literal UCB$M_TU_TRACEACT = %X'2';
literal UCB$M_TU_SEQNOP = %X'4';
literal UCB$M_TU_1DENS = %X'8';
literal UCB$M_TU_DENS_DETERMINED = %X'10';
literal UCB$M_TU_MEDIA_LOADED = %X'20';
literal UCB$M_SHD_SEQCMD_HERE = %X'400';
literal UCB$M_SHD_SEQCMD_THERE = %X'800';
literal UCB$M_SHD_PASSIVE_MV = %X'1000';
literal UCB$M_SHD_NODE_FAILURE = %X'2000';
literal UCB$M_SHD_WLGSTA_CHA = %X'4000';
literal UCB$M_SHD_VCB_DEQUEUE = %X'8000';
literal UCB$M_PORT_ONLINE = %X'1';
literal UCB$M_FKLOCK = %X'2';
literal UCB$M_MSGFKLOCK = %X'4';
literal UCB$M_INIFKLOCK = %X'8';
literal UCB$M_BAD_REV = %X'10';
literal UCB$M_PA_ERLOGIP = %X'20';
literal UCB$M_MFQEFKLOCK = %X'40';
literal UCB$M_MFQE_LOST = %X'80';
literal UCB$S_UCB = 224;
macro UCB$L_FQFL = 0,0,32,1 %;          ! FORK QUEUE FORWARD LINK 
macro UCB$W_UNIT_SEED = 0,0,16,0 %;     !  UNIT NUMBER SEED 
macro UCB$W_MB_SEED = 0,0,16,0 %;       !  MB -- UNIT NUMBER SEED 
macro UCB$L_RQFL = 0,0,32,1 %;          !  NET -- RCV QUEUE FORWARD LINK 
macro UCB$L_MB_MSGQFL = 0,0,32,1 %;     !  MAILBOX MESSAGE QUEUE LISTHEAD
macro UCB$L_FQBL = 4,0,32,1 %;          ! FORK QUEUE BACKWARD LINK 
macro UCB$L_RQBL = 4,0,32,1 %;          !  NET -- RCV QUEUE BACKWARD LINK 
macro UCB$L_MB_MSGQBL = 4,0,32,1 %;     !  MAILBOX MESSAGE QUEUE LISTHEAD
macro UCB$W_SIZE = 8,0,16,0 %;          ! SIZE OF UCB IN BYTES 
macro UCB$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE FOR UCB 
macro UCB$B_FLCK = 11,0,8,0 %;          !  Fork lock number index
macro UCB$L_FPC = 12,0,32,1 %;          ! FORK PC 
macro UCB$L_ASTQFL = 12,0,32,1 %;       !  MB -- AST QUEUE LISTHEAD FORWARD LINK 
macro UCB$L_MB_W_AST = 12,0,32,1 %;     !  MAILBOX WRITE ATTN AST LIST
macro UCB$T_PARTNER = 12,0,8,0 %;       !  NET -- PARTNER'S NODENAME 
macro UCB$Q_FR3 = 16,0,0,1 %;
literal UCB$S_FR3 = 8;                  ! FORK R3 
macro UCB$L_ASTQBL = 16,0,32,1 %;       !  MB -- AST QUEUE LISTHEAD BACKWARD LINK 
macro UCB$L_MB_R_AST = 16,0,32,1 %;     !  MAILBOX READ ATTN AST LIST
macro UCB$Q_FR4 = 24,0,0,1 %;
literal UCB$S_FR4 = 8;                  ! FORK R4 
macro UCB$W_MSGMAX = 24,0,16,0 %;       !  MB -- MAXIMUM MESSAGES ALLOWED 
macro UCB$W_MSGCNT = 26,0,16,0 %;       !  MB -- CURRENT NUMBER OF MESSAGES 
macro UCB$L_FIRST = 24,0,32,1 %;        !  NET -- ADDR OF 1ST SEG OF CHAINED MSG 
macro UCB$W_BUFQUO = 32,0,16,0 %;       !  BUFFERED I/O QUOTA CHARGED FOR THIS UCB
macro UCB$W_DSTADDR = 32,0,16,0 %;      !  NET -- REMOTE CONNECT NO. 
macro UCB$W_INIQUO = 34,0,16,0 %;       !  INITIAL BUFFERED I/O QUOTA FOR THIS UCB
macro UCB$W_SRCADDR = 34,0,16,0 %;      !  NET -- LOCAL CONNECT NO. 
macro UCB$L_ORB = 36,0,32,1 %;          !  OBJECT'S RIGHTS BLOCK ADDRESS
macro UCB$L_LOCKID = 40,0,32,0 %;       ! DEVICE LOCK ID
macro UCB$L_CPID = 40,0,32,0 %;         ! PID CHARGED FOR BUFQUO BY UCBCREDEL
macro UCB$PS_CRAM = 44,0,32,1 %;        ! ADDRESS OF FIRST UNIT CRAM
macro UCB$L_CRB = 48,0,32,1 %;          ! ADDRESS OF PRIMARY CHANNEL REQUEST BLOCK 
macro UCB$L_DLCK = 52,0,32,1 %;         ! ADDRESS OF DEVICE IPL SPINLOCK
macro UCB$L_DDB = 56,0,32,1 %;          ! BACKPOINTER TO DEVICE DATA BLOCK 
macro UCB$L_PID = 60,0,32,0 %;          ! PROCESS ID OF OWNER PROCESS 
macro UCB$L_LINK = 64,0,32,1 %;         ! ADDRESS OF NEXT UCB FOR RESPECTIVE DDB 
macro UCB$L_VCB = 68,0,32,1 %;          ! ADDRESS OF VOLUME CONTROL BLOCK 
macro UCB$Q_DEVCHAR = 72,0,0,0 %;
literal UCB$S_DEVCHAR = 8;              !  Device characteristic bits quadword
macro UCB$L_DEVCHAR = 72,0,32,0 %;      !   Original device characteristic bits
macro UCB$L_DEVCHAR2 = 76,0,32,0 %;     !   Extended device characteristic bits
macro UCB$L_AFFINITY = 80,0,32,0 %;     ! DEVICE AFFINITY
macro UCB$L_XTRA = 84,0,32,0 %;         ! EXTRA LONGWORD (FOR SMP)
macro UCB$L_ALTIOWQ = 84,0,32,1 %;      ! ALTERNATE STARTIO WAIT
! QUEUE
macro UCB$B_DEVCLASS = 88,0,8,0 %;      ! DEVICE CLASS 
macro UCB$B_DEVTYPE = 89,0,8,0 %;       ! DEVICE TYPE 
macro UCB$W_DEVBUFSIZ = 90,0,16,0 %;    ! DEVICE DEFAULT BUFFER SIZE 
macro UCB$Q_DEVDEPEND = 92,0,0,0 %;
literal UCB$S_DEVDEPEND = 8;            ! Device dependent quadword
macro UCB$R_DEVDEPEND_Q_BLOCK = 92,0,0,0 %;
literal UCB$S_DEVDEPEND_Q_BLOCK = 8;
macro UCB$L_DEVDEPEND = 92,0,32,0 %;    !   First device dependent longword
macro UCB$R_DISK_DEVDEPEND = 92,0,32,0 %;
literal UCB$S_DISK_DEVDEPEND = 4;       !     Disk fields
macro UCB$B_SECTORS = 92,0,8,0 %;       ! 	Sectors per track
macro UCB$B_TRACKS = 93,0,8,0 %;        ! 	Track per cylinder
macro UCB$W_CYLINDERS = 94,0,16,0 %;    ! 	Cylinders per disk
macro UCB$R_TERM_DEVDEPEND = 92,0,32,0 %;
literal UCB$S_TERM_DEVDEPEND = 4;       !     Terminal fields
macro UCB$B_VERTSZ = 95,0,8,0 %;        ! 	Vertical page size (lines per page)
macro UCB$R_NET_DEVDEPEND = 92,0,32,0 %;
literal UCB$S_NET_DEVDEPEND = 4;        !     Network fields
macro UCB$B_LOCSRV = 92,0,8,0 %;        ! 	Local link services 
macro UCB$B_REMSRV = 93,0,8,0 %;        ! 	Remote link services
macro UCB$W_BYTESTOGO = 94,0,16,0 %;    ! 	No. of bytes left in rcv bfr
macro UCB$L_DEVDEPND2 = 96,0,32,0 %;    !   Second device dependent long word 
macro UCB$L_TT_DEVDP1 = 96,0,32,0 %;    !     Terminal -- Device dependent long word 
macro UCB$W_TU_FORMENU = 96,0,16,0 %;   !     TU/TMSCP -- Supported formats (returned by GETDVI).
macro UCB$Q_DEVDEPEND2 = 100,0,0,0 %;
literal UCB$S_DEVDEPEND2 = 8;           ! Device dependent quadword
macro UCB$R_DEVDEPEND2_Q_BLOCK = 100,0,0,0 %;
literal UCB$S_DEVDEPEND2_Q_BLOCK = 8;
macro UCB$L_DEVDEPND3 = 100,0,32,0 %;   !   3rd device dependent longword
macro UCB$L_DEVDEPND4 = 104,0,32,0 %;   !   4th device dependent long word 
macro UCB$R_TMV_BCNT = 100,0,0,0 %;
literal UCB$S_TMV_BCNT = 8;             !  Tape Mount verification byte counts
macro UCB$W_TMV_BCNT1 = 100,0,16,0 %;   !  Byte count for 1st CRC
macro UCB$W_TMV_BCNT2 = 102,0,16,0 %;   !  ...2nd CRC
macro UCB$W_TMV_BCNT3 = 104,0,16,0 %;   !  ...3rd CRC
macro UCB$W_TMV_BCNT4 = 106,0,16,0 %;   !  ...4th CRC
macro UCB$L_IOQFL = 108,0,32,1 %;       ! I/O QUEUE LISTHEAD FORWARD LINK 
macro UCB$L_IOQBL = 112,0,32,1 %;       ! I/O QUEUE LISTHEAD BACKWARD LINK 
macro UCB$W_UNIT = 116,0,16,0 %;        ! PHYSICAL DEVICE UNIT NUMBER 
macro UCB$W_CHARGE = 118,0,16,0 %;      ! MAILBOX BYTE COUNT QUOTA CHARGE 
macro UCB$W_RWAITCNT = 118,0,16,0 %;    !  CLASS DRIVERS -- THREADS WAITING RESOURCES 
macro UCB$B_CM1 = 118,0,8,0 %;          !  LEVEL 1 CONTROLLER ALLOCATION MASK 
macro UCB$B_CM2 = 119,0,8,0 %;          !  LEVEL 2 CONTROLLER ALLOCATION MASK 
macro UCB$L_IRP = 120,0,32,1 %;         ! CURRENT I/O REQUEST PACKET ADDRESS 
macro UCB$L_REFC = 124,0,32,0 %;        ! REFERENCE COUNT OF PROCESSES 
macro UCB$B_DIPL = 128,0,8,0 %;         ! DEVICE INTERRUPT PRIORITY LEVEL 
macro UCB$B_STATE = 128,0,8,0 %;        !  NET -- LINK STATE FOR NETWORK TRANSITIONS 
macro UCB$B_AMOD = 129,0,8,0 %;         ! ALLOCATION ACCESS MODE 
macro UCB$W_FILL_0 = 130,0,16,1 %;
macro UCB$L_AMB = 132,0,32,1 %;         ! ASSOCIATED UNIT CONTROL BLOCK POINTER 
macro UCB$L_STS = 136,0,32,0 %;         ! DEVICE UNIT STATUS 
macro UCB$V_TIM = 136,0,1,0 %;          !  TIME OUT ENABLED (1=YES) 
macro UCB$V_INT = 136,1,1,0 %;          !  INTERRUPT EXPECTED (1=YES) 
macro UCB$V_ERLOGIP = 136,2,1,0 %;      !  ERROR LOG IN PROGRESS ON UNIT (1=YES) 
macro UCB$V_CANCEL = 136,3,1,0 %;       !  CANCEL I/O ON UNIT (1=YES) 
macro UCB$V_ONLINE = 136,4,1,0 %;       !  UNIT ONLINE (1=YES) 
macro UCB$V_POWER = 136,5,1,0 %;        !  POWER FAILED WHILE UNIT BUSY (1=YES) 
macro UCB$V_TIMOUT = 136,6,1,0 %;       !  UNIT TIMED OUT (1=YES) 
macro UCB$V_INTTYPE = 136,7,1,0 %;      !  RECEIVER INTERRUPT IF SET 
macro UCB$V_BSY = 136,8,1,0 %;          !  UNIT IS BUSY (1=YES) 
macro UCB$V_MOUNTING = 136,9,1,0 %;     !  DEVICE IS BEING MOUNTED 
macro UCB$V_DEADMO = 136,10,1,0 %;      !  DEALLOCATE AT DISMOUNT 
macro UCB$V_VALID = 136,11,1,0 %;       !  VOLUME IS SOFTWARE VALID 
macro UCB$V_UNLOAD = 136,12,1,0 %;      !  UNLOAD VOLUME AT DISMOUNT 
macro UCB$V_TEMPLATE = 136,13,1,0 %;    !  SET IF THIS IS TEMPLATE UCB
macro UCB$V_MNTVERIP = 136,14,1,0 %;    !  MOUNT VERIFICATION IN PROGRESS 
macro UCB$V_WRONGVOL = 136,15,1,0 %;    !  WRONG VOLUME DETECTED DURING MOUNT VERIFICATION 
macro UCB$V_DELETEUCB = 136,16,1,0 %;   !  DELETE THIS UCB WHEN REFC REACHES ZERO
macro UCB$V_LCL_VALID = 136,17,1,0 %;   !  VOLUME IS VALID ON THE LOCAL NODE
macro UCB$V_SUPMVMSG = 136,18,1,0 %;    !  IF SET, SUPPRESS SUCCESS TYPE MOUNT VER. MSGS.
macro UCB$V_MNTVERPND = 136,19,1,0 %;   !  MOUNT VERIFICATION IS PENDING ON BUSY DEVICE.
macro UCB$V_DISMOUNT = 136,20,1,0 %;    !  DISMOUNT IN PROGRESS
macro UCB$V_CLUTRAN = 136,21,1,0 %;     !  VAXcluster STATE TRANSITION IN PROGRESS
macro UCB$V_WRTLOCKMV = 136,22,1,0 %;   !  Write-locked mount verification in progress
macro UCB$V_SVPN_END = 136,23,1,0 %;    !  Last byte used from page mapped by SVPN
macro UCB$V_ALTBSY = 136,24,1,0 %;      !  Unit is busy via alternate startio path
macro UCB$V_SNAPSHOT = 136,25,1,0 %;    !    Restart validation is in progress
macro UCB$V_NO_ASSIGN = 136,26,1,0 %;   !  Unit cannot have channels assigned to it.
macro UCB$V_EXFUNC_SUPP = 136,27,1,0 %; !  Unit supports the EXFUNC bit
macro UCB$L_DEVSTS = 140,0,32,0 %;      ! DEVICE DEPENDENT STATUS 
macro UCB$V_JOB = 140,0,1,0 %;          !    Job Controller notified 
macro UCB$V_TEMPL_BSY = 140,6,1,0 %;    !    Template UCB is busy 
macro UCB$V_PRMMBX = 140,0,1,0 %;       !    Permanent mailbox 
macro UCB$V_DELMBX = 140,1,1,0 %;       !    Mailbox marked for delete 
macro UCB$V_TT_TIMO = 140,1,1,0 %;      !    Terminal read timeout in progress 
macro UCB$V_TT_NOTIF = 140,2,1,0 %;     !    Terminal user notified of unsolicted data 
macro UCB$V_TT_HANGUP = 140,3,1,0 %;    !    Process hang up
macro UCB$V_TT_DEVSTS_FILL = 140,4,11,0 %;
literal UCB$S_TT_DEVSTS_FILL = 11;      !    fill to the end the word
macro UCB$V_TT_NOLOGINS = 140,15,1,0 %; !  NOLOGINS ALLOWED
macro UCB$V_NT_BFROVF = 140,2,1,0 %;    !    Too many bytes rcvd 
macro UCB$V_NT_NAME = 140,4,1,0 %;      !    Link has declared a connect name 
macro UCB$V_NT_BREAK = 140,5,1,0 %;     !    Link is being broken 
macro UCB$V_ECC = 140,0,1,0 %;          !    ECC correction was made
macro UCB$V_DIAGBUF = 140,1,1,0 %;      !    Diagnostic buffer specified
macro UCB$V_NOCNVRT = 140,2,1,0 %;      !    No LBN to media address conversion
macro UCB$V_DX_WRITE = 140,3,1,0 %;     !    Console floppy write operation
macro UCB$V_DATACACHE = 140,4,1,0 %;    !    Data blocks being cached
macro UCB$V_MSCP_MNTVERIP = 140,8,1,0 %; !    Mount verification in progress
macro UCB$V_MSCP_INITING = 140,9,1,0 %; !    UCB is being initialized
macro UCB$V_MSCP_WAITBMP = 140,10,1,0 %; !    RWAITCNT has been bumped
macro UCB$V_MSCP_FLOVR = 140,11,1,0 %;  !    Bit toggled everytime a failover succeeds.
macro UCB$V_MSCP_PKACK = 140,12,1,0 %;  !    Set when a IO$_PACKACK is in progress.
macro UCB$V_MSCP_WRTP = 140,13,1,0 %;   !    Unit MSCP write protected in some way.
macro UCB$V_MSCP_IGNSRV = 140,14,1,0 %; !    Ignore served paths during connection failover.
macro UCB$V_DU_SHMV_STRTD = 140,3,1,0 %; !    Shadowing mount verification started
macro UCB$V_DU_0MNOTE = 140,5,1,0 %;    !    Zero members message sent
macro UCB$V_TU_OVRSQCHK = 140,0,1,0 %;  !    Override sequence checking
macro UCB$V_TU_TRACEACT = 140,1,1,0 %;  !    IRP trace table active
macro UCB$V_TU_SEQNOP = 140,2,1,0 %;    !    Sequential NOP tape operation in progress
macro UCB$V_TU_1DENS = 140,3,1,0 %;     !    Single density device
macro UCB$V_TU_DENS_DETERMINED = 140,4,1,0 %; !    Density already determined. Basically a
!     bit that says that a particular part of
!     PACKACK processing has already been done
!     once for this unit.
macro UCB$V_TU_MEDIA_LOADED = 140,5,1,0 %; !    Media loaded into drive and drive available.
macro UCB$V_SHD_SEQCMD_HERE = 140,10,1,0 %; !    Sequential command in progress on this node
macro UCB$V_SHD_SEQCMD_THERE = 140,11,1,0 %; !    Sequential command in progress on another node
macro UCB$V_SHD_PASSIVE_MV = 140,12,1,0 %; !    Passive MV in progress
macro UCB$V_SHD_NODE_FAILURE = 140,13,1,0 %; !    Node failure in progress
macro UCB$V_SHD_WLGSTA_CHA = 140,14,1,0 %; !    Write log state change
macro UCB$V_SHD_VCB_DEQUEUE = 140,15,1,0 %; !  indicate  DEQUE required on VCB
macro UCB$V_PORT_ONLINE = 140,0,1,0 %;  !   Port is online.
macro UCB$V_FKLOCK = 140,1,1,0 %;       !   Fork block interlock bit
macro UCB$V_MSGFKLOCK = 140,2,1,0 %;    !   Fork block interlock for
!    printing operator msgs
macro UCB$V_INIFKLOCK = 140,3,1,0 %;    !   Fork block interlock for
!    adapter errors
macro UCB$V_BAD_REV = 140,4,1,0 %;      !   Bad Port Revision flag
macro UCB$V_PA_ERLOGIP = 140,5,1,0 %;   !   Error log buffer in the
!    extended UCB is in use
macro UCB$V_MFQEFKLOCK = 140,6,1,0 %;   !   Fork block interlock for
!    emergency pool allocation
macro UCB$V_MFQE_LOST = 140,7,1,0 %;    !   Lost MFQE interrupt because
!    the fork block was in use
macro UCB$L_QLEN = 144,0,32,1 %;        !  Device queue length
macro UCB$L_DUETIM = 148,0,32,0 %;      ! DUE TIME FOR I/O COMPLETION 
macro UCB$L_OPCNT = 152,0,32,0 %;       ! COUNT OF OPERATIONS COMPLETED 
macro UCB$L_SVPN = 156,0,32,0 %;        ! SYSTEM VIRTUAL PAGE/MAP REGISTER NUMBER 
macro UCB$L_SVAPTE = 160,0,32,1 %;      ! SYSTEM VIRTUAL ADDRESS OF PTE 
macro UCB$L_BCNT = 164,0,32,0 %;        ! BYTE COUNT OF TRANSFER 
macro UCB$L_BOFF = 168,0,32,0 %;        ! Byte offset in page
macro UCB$L_SOFTERRCNT = 172,0,32,0 %;  ! SOFT ERROR COUNT
macro UCB$L_ERTCNT = 176,0,32,0 %;      ! ERROR LOG DEVICE CURRENT ERROR RETRY COUNT 
macro UCB$L_ERTMAX = 180,0,32,0 %;      ! ERROR LOG DEVICE MAXIMUM ERROR RETRY COUNT 
macro UCB$L_ERRCNT = 184,0,32,0 %;      ! DEVICE ERROR COUNT 
macro UCB$L_PDT = 188,0,32,1 %;         ! ADDR OF PORT DESCRIPTOR TABLE
macro UCB$L_DDT = 192,0,32,1 %;         ! ADDR OF DDT (OPTIONAL BUT PREFERRED) 
macro UCB$PS_ADP = 196,0,32,1 %;        ! ADDR OF ADP
macro UCB$PS_CRCTX = 200,0,32,1 %;      ! ADDR OF COUNTED RESOURCE CONTEXT BLK
macro UCB$L_MEDIA_ID = 204,0,32,0 %;    ! BIT ENCODED MEDIA IDENTIFICATION 
macro UCB$V_MEDIA_ID_NN = 204,0,7,0 %;
literal UCB$S_MEDIA_ID_NN = 7;          !  MEDIA NAME NUMBER
macro UCB$V_MEDIA_ID_N2 = 204,7,5,0 %;
literal UCB$S_MEDIA_ID_N2 = 5;          !  MEDIA NAME CHAR 2
macro UCB$V_MEDIA_ID_N1 = 204,12,5,0 %;
literal UCB$S_MEDIA_ID_N1 = 5;          !  MEDIA NAME CHAR 1
macro UCB$V_MEDIA_ID_N0 = 204,17,5,0 %;
literal UCB$S_MEDIA_ID_N0 = 5;          !  MEDIA NAME CHAR 0
macro UCB$V_MEDIA_ID_T1 = 204,22,5,0 %;
literal UCB$S_MEDIA_ID_T1 = 5;          !  MEDIA TYPE CHAR 1
macro UCB$V_MEDIA_ID_T0 = 204,27,5,0 %;
literal UCB$S_MEDIA_ID_T0 = 5;          !  MEDIA TYPE CHAR 0
macro UCB$PS_DTN = 208,0,32,1 %;        ! ADDR OF DEVICE TYPE NAME DTN STRUC
macro UCB$PS_DTN_LINK = 212,0,32,1 %;   !  ADDR OF NEXT UCB WITH THIS DEVICE TYPE
macro UCB$PS_TOUTROUT = 216,0,32,1 %;   ! DEVICE TIMEOUT ROUTINE PROCEDURE VALUE
literal UCB$K_LENGTH = 224;             ! LENGTH OF STANDARD UCB 
literal UCB$C_LENGTH = 224;             ! LENGTH OF STANDARD UCB 
literal UCB$S_UCBDEF = 224;             ! OLD UCBDEF SIZE NAME FOR COMPATIBILITY
! 
!  DEVICE DEPENDENT UCB EXTENSIONS
! 
!  MAILBOX
! 
literal UCB$S_MB_UCB = 280;
macro UCB$L_MB_READERREFC = 224,0,32,0 %; ! REFERENCE COUNT OF READ ENABLED CHANNELS TO DEVICE
macro UCB$L_MB_WRITERREFC = 228,0,32,0 %; ! REFERENCE COUNT OF WRITE ENABLED CHANNELS TO DEVICE
macro UCB$L_MB_READQFL = 232,0,32,1 %;  ! MAILBOX READ IRP QUEUE LISTHEAD
macro UCB$L_MB_READQBL = 236,0,32,1 %;
macro UCB$L_MB_WRITERWAITQFL = 240,0,32,1 %; ! MAILBOX WAIT FOR WRITE CHANNEL TO BE ASSIGNED QUEUE
macro UCB$L_MB_WRITERWAITQBL = 244,0,32,1 %;
macro UCB$L_MB_READERWAITQFL = 248,0,32,1 %; ! MAILBOX WAIT FOR READ CHANNEL TO BE ASSIGNED QUEUE
macro UCB$L_MB_READERWAITQBL = 252,0,32,1 %;
macro UCB$L_MB_NOWRITERWAITQFL = 256,0,32,1 %; ! MAILBOX WAIT FOR ALL WRITE CHANNELS TO BE DEASSIGNED QUEUE
macro UCB$L_MB_NOWRITERWAITQBL = 260,0,32,1 %;
macro UCB$L_MB_NOREADERWAITQFL = 264,0,32,1 %; ! MAILBOX WAIT FOR ALL READ CHANNELS TO BE DEASSIGNED QUEUE
macro UCB$L_MB_NOREADERWAITQBL = 268,0,32,1 %;
macro UCB$L_MB_ROOM_NOTIFY = 272,0,32,1 %; ! ROOM NOTIFY AST LIST
macro UCB$L_LOGADR = 276,0,32,1 %;      ! LOGICAL NAME BLOCK ADDRESS 
macro UCB$L_MB_LOGADR = 276,0,32,1 %;   !  and a synonym to let SDA find the field
literal UCB$K_MB_UCBLENGTH = 280;       ! SIZE OF MAILBOX UCB 
literal UCB$C_MB_UCBLENGTH = 280;       ! SIZE OF MAILBOX UCB 
literal UCB$S_MB_EXTENSION = 280;       !  Old step-1 size name for compatibility
! 
!  ERROR LOG DEVICES (ALL)
! 
literal UCB$S_ERL_UCB = 240;
macro UCB$L_EMB = 224,0,32,1 %;         ! ADDRESS OF ERROR MESSAGE BUFFER 
macro UCB$L_FUNC = 228,0,32,0 %;        !  I/O function modifiers
macro UCB$L_DPC = 232,0,32,1 %;         ! SAVED DRIVER SUBROUTINE RETURN ADDRESS
literal UCB$K_ERL_LENGTH = 240;         ! SIZE OF ERROR LOG UCB
literal UCB$C_ERL_LENGTH = 240;         ! SIZE OF ERROR LOG UCB
literal UCB$S_UCBDEF4 = 240;            !  Old step-1 size name for compatibility
! 
!  DUAL PORTED DEVICES (ALL DISKS AND MOST TAPES)
! 
literal UCB$S_DP_UCB = 256;
macro UCB$L_DP_DDB = 240,0,32,1 %;      !  Pointer to alternate DDB
macro UCB$L_DP_LINK = 244,0,32,1 %;     !  Address of next UCB for this DDB 
macro UCB$L_DP_ALTUCB = 248,0,32,1 %;   !  Addr of alternate UCB for this unit
macro UCB$L_2P_DDB = 240,0,32,1 %;      !  Pointer to alternate DDB
macro UCB$L_2P_LINK = 244,0,32,1 %;     !  Address of next UCB for this DDB 
macro UCB$L_2P_ALTUCB = 248,0,32,1 %;   !  Addr of alternate UCB for this unit
literal UCB$K_DP_LENGTH = 256;          ! Size of dual path UCB
literal UCB$C_DP_LENGTH = 256;          !  size of dual path UCB
literal UCB$K_2P_LENGTH = 256;          ! Size of dual path UCB
literal UCB$C_2P_LENGTH = 256;          !  size of dual path UCB
literal UCB$S_DUALPATH_EXTENSION = 256; !  Old step-1 size name for compatibility
! 
!  ALL DISKS AND TAPES
! 
literal UCB$M_AST_ARMED = %X'8000';
literal UCB$K_LCL_DISK_LENGTH = 276;    !  Size of local disk UCB
literal UCB$C_LCL_DISK_LENGTH = 276;    !  Size of local disk UCB
literal UCB$K_LCL_TAPE_LENGTH = 280;    !  Size of local tape UCB
literal UCB$C_LCL_TAPE_LENGTH = 280;    !  Size of local tape UCB
literal UCB$S_DT_UCB = 280;
macro UCB$W_DIRSEQ = 256,0,16,0 %;      !  Directory sequence number
macro UCB$V_AST_ARMED = 256,15,1,0 %;   !   Blocking AST armed flag
macro UCB$B_ONLCNT = 258,0,8,0 %;       !  Online count
macro UCB$L_MAXBLOCK = 260,0,32,0 %;    !  Random access device highest block
macro UCB$L_MAXBCNT = 264,0,32,0 %;     !  Maximum transfer BCNT
macro UCB$L_DCCB = 268,0,32,1 %;        !  Pointer to data cache control block
macro UCB$L_QLENACC = 272,0,32,0 %;     !  Queue length accumulator
macro UCB$B_PREV_RECORD = 259,0,8,0 %;  !  Tape position prior at start of last I/O
macro UCB$L_RECORD = 260,0,32,0 %;      !  Current tape position or frame counter
macro UCB$L_TMV_RECORD = 268,0,32,0 %;  !  Position following last guaranteed successful I/O
macro UCB$W_TMV_CRC1 = 272,0,16,0 %;    !  1st CRC for Mount Ver's media validation
macro UCB$W_TMV_CRC2 = 274,0,16,0 %;    !  2nd CRC ...
macro UCB$W_TMV_CRC3 = 276,0,16,0 %;    !  3rd CRC ...
macro UCB$W_TMV_CRC4 = 278,0,16,0 %;    !  4th CRC ...
literal UCB$S_DISKTAPE_UCB_EXTENSION = 280;
!  Old step-1 size name for compatibility
! 
!  MSCP DISKS AND TAPES UCB EXTENSION
! 
literal UCB$S_MSCP_UCB = 336;
macro UCB$L_CDDB = 280,0,32,1 %;        !  Pointer to active CDDB
macro UCB$L_2P_CDDB = 284,0,32,1 %;     !  Pointer to alternate CDDB
macro UCB$L_CDDB_LINK = 288,0,32,1 %;   !  Pointer to next UCB in CDDB chain
macro UCB$L_CDT = 292,0,32,1 %;         !  Pointer to active CDT
macro UCB$L_WAIT_CDDB = 296,0,32,1 %;   !  Address of CDDB waiting for mnt. ver. to complete on this UCB
macro UCB$L_PREF_CDDB = 300,0,32,1 %;   !  CDDB address for preferred path
macro UCB$Q_UNIT_ID = 304,0,0,0 %;
literal UCB$S_UNIT_ID = 8;              !  Unique MSCP unit identifier
macro UCB$W_MSCPUNIT = 312,0,16,0 %;    !  Primary path MSCP unit number 
macro UCB$W_UNIT_FLAGS = 314,0,16,0 %;  !  MSCP unit flags
macro UCB$W_LCL_MSCPUNIT = 316,0,16,0 %; !  MSCP unit number for local (non-emulated) controllers
macro UCB$W_SRV_MSCPUNIT = 318,0,16,0 %; !  MSCP unit number for served (emulated) controllers
macro UCB$L_MSCPDEVPARAM = 320,0,32,0 %; !  MSCP device-dependent parameters
macro UCB$B_FREECAP = 324,0,8,0 %;      !  Free capacity
macro UCB$B_FAIL_MUTEX = 325,0,8,0 %;   !  MUTEX for device failover
macro UCB$W_MSCP_RESVDW = 326,0,16,0 %; !  Reserved for MSCP enhancements
macro UCB$L_SHAD = 328,0,32,1 %;        !  Virtual Unit Pointer to HBS SHAD
literal UCB$K_MSCP_DISK_LENGTH = 336;   ! Size of MSCP disk UCB
literal UCB$K_MSCP_TAPE_LENGTH = 336;   ! Size of MSCP tape UCB
literal UCB$S_MSCP_UCB_EXTENSION = 336; !  Old step-1 size name for compatibility
! 
!  DISK CLASS DRIVER DEVICE DEPENDENT UNIT CONTROL BLOCK OFFSETS
! 
literal UCB$S_DU_UCB = 368;
macro UCB$L_DU_VOLSER = 336,0,32,0 %;   !  Serial umber as returned
!   in ONLINE end packet.
macro UCB$L_DU_USIZE = 340,0,32,0 %;    !  Size of user visible area of 
!   unit in logical blocks
macro UCB$L_DU_TOTSZ = 344,0,32,0 %;    !  Size of unit including RCT 
!   area in logical blocks
macro UCB$W_DU_RCTSIZE = 348,0,16,0 %;  !  Size of the RCT in blocks
macro UCB$B_DU_RCTCPYS = 350,0,8,0 %;   !  Number of RCT copies on the unit
macro UCB$B_DU_RBNPTRK = 351,0,8,0 %;   !  RBNs per track
macro UCB$W_DU_LBNPTRK = 352,0,16,0 %;  !  LBNs per track
macro UCB$W_DU_TRKPGRP = 354,0,16,0 %;  !  Tracks per group
macro UCB$W_DU_GRPPCYL = 356,0,16,0 %;  !  Groups per cylinder
macro UCB$W_DU_MUNTC = 358,0,16,0 %;    !  Multi-unit code
macro UCB$B_DU_USVR = 360,0,8,0 %;      !  Unit software version
macro UCB$B_DU_UHVR = 361,0,8,0 %;      !  Unit hardware version
literal UCB$K_DU_LENGTH = 368;          !  Size of DISK CLASS DRIVER dependent UCB
!  Old step-1 size name for compatibility
literal UCB$S_DUDRIVER_EXTENSION = 368;
! 
!  TAPE CLASS DRIVER DEVICE DEPENDENT UNIT CONTROL BLOCK OFFSETS
! 
literal UCB$M_TU_RPTREQ = %X'1';
literal UCB$M_TU_RPTPND = %X'2';
literal UCB$M_TU_DENSITY = %X'4';
literal UCB$S_TU_UCB = 368;
macro UCB$L_TU_MAXWRCNT = 336,0,32,0 %; !  Largest size record likely to have reliability statistics.
macro UCB$W_TU_FORMAT = 340,0,16,0 %;   !  Format (density).
macro UCB$W_TU_SPEED = 342,0,16,0 %;    !  Current speed.
macro UCB$W_TU_NOISE = 344,0,16,0 %;    !  Size of noise records ignored by controller.
macro UCB$B_TU_SOFTERR = 346,0,8,0 %;   !  Media quality reporting counter.
macro UCB$B_TU_SOFTFLAGS = 347,0,8,0 %; !  Media quality reporting flags.
macro UCB$V_TU_RPTREQ = 347,0,1,0 %;    !  Report request.
macro UCB$V_TU_RPTPND = 347,1,1,0 %;    !  Report pending.
macro UCB$V_TU_DENSITY = 347,2,1,0 %;   !  Density check done if set.
macro UCB$L_TRACEBEG = 348,0,32,1 %;    !  Pointer to beginning of trace ring.
macro UCB$L_TRACEPTR = 352,0,32,1 %;    !  Pointer to next available slot.
macro UCB$L_TRACEND = 356,0,32,1 %;     !  Pointer to beyond trace ring.
macro UCB$L_TRACE_NEXT_SLOT = 360,0,32,1 %; !  Number of next trace slot to use.
literal UCB$K_TU_LENGTH = 368;          !  Size of TAPE CLASS DRIVER dependent UCB
!  Old step-1 size name for compatibility
literal UCB$S_TUDRIVER_EXTENSION = 368;
! 
!  SCSI Port Driver Extensions
! 
literal UCB$M_PK_IFKB_LOCK = %X'1';
literal UCB$S_SCSI_UCB = 288;
macro UCB$IL_PK_CUR_DATA = 240,0,32,0 %; !  Selection bus data snapshot
macro UCB$IL_PK_RESEL_ID = 244,0,32,0 %; !  [RE]selection saved id
macro UCB$IL_PK_EXFLAGS = 248,0,32,0 %; !  Port extended flags
macro UCB$V_PK_IFKB_LOCK = 248,0,1,0 %; !    Init FKB locked
macro UCB$IB_PK_INIFKBLK = 252,0,0,1 %;
literal UCB$S_PK_INIFKBLK = 32;         !  Initialization fork block
macro UCB$PS_PK_INIKPB = 252,0,32,1 %;  !  Initializtion KPB pointer
literal UCB$K_PK_LENGTH = 288;          !  Size of SCSI port UCB
literal UCB$S_SCSI_PORT_EXTENSION = 288; !  Old step-1 size name for compatibility
! 
!  NETWORK LOGICAL LINK (NETWORK MAILBOX) EXTENSION
! 
literal UCB$M_BACKP = %X'20';
literal UCB$C_LOGLNK = 1;               !  CONNECT IS FOR LOGICAL LINK (NOT SINGLE MSG) 
literal UCB$S_NET_UCB = 240;
macro UCB$L_NT_DATSSB = 224,0,32,1 %;   !  ADDRESS OF DATA SUBCHANNEL STATUS BLOCK 
macro UCB$L_NT_INTSSB = 228,0,32,1 %;   !  ADDRESS OF INT/LS SSB 
macro UCB$W_NT_CHAN = 232,0,16,0 %;     !  DDCMP CHANNEL NO. 
macro UCB$V_LTYPE = 234,0,2,0 %;
literal UCB$S_LTYPE = 2;                !  LINK TYPE BITS 
macro UCB$V_SEGFLO = 234,2,1,0 %;       !  SEGMENT REQUEST COUNTS 
macro UCB$V_MSGFLO = 234,3,1,0 %;       !  MESSAGE REQUEST COUNTS 
macro UCB$V_MSGACK = 234,4,1,0 %;       !  MESSAGE ACK/NAK 
macro UCB$V_BACKP = 234,5,1,0 %;        !  BACKPRESSURE (1=> NO FLOW) 
macro UCB$V_LNKPRI = 234,6,2,0 %;
literal UCB$S_LNKPRI = 2;               !  LINK PRIORITY (IGNORED) 
!  NETWORK CONSTANTS 
literal UCB$S_UCBDEF7 = 240;            !  Old step-1 size name for compatibility
! 
!  NI DEVICE EXTENSION
! 
literal UCB$S_NI_UCB = 232;
macro UCB$L_NI_HWAPTR = 224,0,32,1 %;   ! ADDRESS OF NI DEVICE HARDWARE ADDRESS
macro UCB$L_NI_MLTPTR = 228,0,32,1 %;   ! ADDRESS OF PROTOCOL MULTICAST TABLE
literal UCB$K_NI_LENGTH = 232;          ! SIZE OF NI DEVICE UCB 
literal UCB$C_NI_LENGTH = 232;          ! SIZE OF NI DEVICE UCB 
literal UCB$S_UCBDEF9 = 232;            !  Old step-1 size name for compatibility
! 
!  DAP DEVICE EXTENSION (FOR DEVICES THAT USE THE DAP INTERFACE WITHOUT
!  UNDELYING DECNET, SUCH AS CERTAIN CONSOLE DISKS).
! 
literal UCB$S_DAP_UCB = 256;
macro UCB$T_DAPDEVNAM = 224,0,0,0 %;
literal UCB$S_DAPDEVNAM = 32;           ! EQUIVALENCE NAME STRING
literal UCB$K_DAPDEV_LENGTH = 256;      ! SIZE OF DAP DEVICE UCB
literal UCB$C_DAPDEV_LENGTH = 256;      ! SIZE OF DAP DEVICE UCB
literal UCB$S_UCBDEF10 = 256;           !  Old step-1 size name for compatibility
literal UCB$K_BGN_ADPTAB = 320;
literal UCB$M_LBDG = %X'1';
literal UCB$M_POLL = %X'2';
literal UCB$M_LOCAL = %X'4';
literal UCB$M_SINGLE_PATH = %X'8';
literal UCB$M_STORAGE = %X'10';
literal UCB$K_BGN_ADPSUB = 348;
literal UCB$K_BGN_PDTSUB = 412;
literal UCB$K_END_ADPTAB = 452;
literal UCB$K_TAB_LEN = 132;
literal UCB$K_LMPKTBYTS = 64;
literal UCB$K_ERRDGBYTS = 180;
literal UCB$K_LMBUFSIZ = 104;
literal UCB$K_ERRDGSIZ = 220;
literal UCB$S_PA_UCB = 736;
! 
!  Skip the common UCB
! 
! 
!  Define private PA fields
! 
macro UCB$L_INIFKBLK = 240,0,0,0 %;
literal UCB$S_INIFKBLK = 32;            !  Error fork block for handling
!   severe adapter errors
macro UCB$L_MFQEFKBLK = 272,0,0,0 %;
literal UCB$S_MFQEFKBLK = 32;           !  Pool allocation fork block for
!   handling message free queue
!   interrupts
macro UCB$W_INCARN = 304,0,16,0 %;      !  Last BVP incarnation number
macro UCB$L_ADP = 308,0,32,1 %;         !  Address of the ADP
macro UCB$L_INIRETURN = 312,0,32,0 %;   !  Initialization thread return
!   address
! 
!  Fields used to link a port driver with the generic SCS port code.  The port
!  driver initializes these routines with pointers to hardware-dependent routines
!  at unit initialization time.
! 
macro UCB$L_NDT = 320,0,32,0 %;         !  Adapter hardware code
macro UCB$B_DT = 324,0,8,0 %;           !  Adapter device type
macro UCB$V_LBDG = 325,0,1,0 %;         !   Loopback datagram
macro UCB$V_POLL = 325,1,1,0 %;         !   Configuration polling
macro UCB$V_LOCAL = 325,2,1,0 %;        !   Local MSCP port (BVP ports)
macro UCB$V_SINGLE_PATH = 325,3,1,0 %;  !   Only one path available
macro UCB$V_STORAGE = 325,4,1,0 %;      !   Port is for remote storage only
macro UCB$B_INI_FLAGS = 325,0,8,0 %;
macro UCB$B_MSG_TYP = 328,0,8,0 %;      !  Error log message type
macro UCB$B_PDT_TYPE = 329,0,8,0 %;     !  Type of PDT
macro UCB$W_PDT_SIZE = 330,0,16,0 %;    !  Size of PDT
macro UCB$L_PPD_SIZE = 332,0,32,0 %;    !  Size of the PPD header
macro UCB$L_LSINDX = 336,0,32,1 %;      !  Local store dump start address
macro UCB$L_LSLENGTH = 340,0,32,0 %;    !  Dump size in longwords
macro UCB$L_PMC = 344,0,32,1 %;         !  Address of the PMC register
!   used to disable interrupts
!   on port power-up
macro UCB$L_REV_TABLE = 348,0,32,0 %;   !  Port version table
macro UCB$L_POWER_FAIL = 352,0,32,1 %;  !  Power failure recovery routine
macro UCB$L_INIT_PDT = 356,0,32,1 %;    !  PDT initialization routine
macro UCB$L_START_UCODE = 360,0,32,1 %; !  Microcode load and start routine
macro UCB$L_ENB_INT = 364,0,32,1 %;     !  Interrupt enable routine
macro UCB$L_FORMAT_REV = 368,0,32,1 %;  !  Verify port version routine
macro UCB$L_TIMER = 372,0,32,1 %;       !  Periodic wakeup routine
macro UCB$L_POKE_PORT = 376,0,32,1 %;   !  Poke the port's sanity timer
macro UCB$L_INTERRUPT = 380,0,32,1 %;   !  Adapter interrupt service routine
macro UCB$L_STOP_UCODE = 384,0,32,1 %;  !  Microcode shutdown routine
macro UCB$L_UNMAP_PDT = 388,0,32,1 %;   !  Unmap register pointers routine
macro UCB$L_REG_DUMP = 392,0,32,1 %;    !  Register dump routine
macro UCB$L_REG_DISP = 396,0,32,1 %;    !  Error log register display routine
macro UCB$L_MEM_DUMP = 400,0,32,1 %;    !  Memory dump routine
macro UCB$L_RELEASE_PS = 404,0,32,1 %;  !  Release port status register routine
macro UCB$L_INS_COMQL = 412,0,32,0 %;   !  Notify port of non-empty CMDQ0
macro UCB$L_INS_COMQH = 416,0,32,0 %;   !  Notify port of non-empty CMDQ1
macro UCB$L_INS_DFREQ = 420,0,32,0 %;   !  Notify port of non-empty DFQ
macro UCB$L_INS_MFREQ = 424,0,32,0 %;   !  Notify port of non-empty MFQ
macro UCB$L_INS_COMQM = 428,0,32,0 %;
macro UCB$L_INIT_ABLK = 432,0,32,0 %;
macro UCB$L_CMPL_INT = 436,0,32,0 %;
macro UCB$L_MISC_INT2 = 440,0,32,0 %;
macro UCB$L_MSGFKBLK = 452,0,0,0 %;
literal UCB$S_MSGFKBLK = 32;            !  Fork block for starting
!   error messages to operator
macro UCB$T_OPA0_TEMP = 484,0,0,0 %;
literal UCB$S_OPA0_TEMP = 24;           !  Field used to store optional
!   OPA0: error logging information
!   (access to this field is also
!   protected by UCB$V_MSGFKLOCK)
macro UCB$B_LMEST = 508,0,8,0 %;        !  Error subtype
macro UCB$B_LMET = 509,0,8,0 %;         !  Error type
macro UCB$B_LMERTCNT = 510,0,8,0 %;     !  Error retry count
macro UCB$B_LMERTMAX = 511,0,8,0 %;     !  Maximum error retry count
macro UCB$W_LMERRCNT = 512,0,16,0 %;    !  Accumulated errors
macro UCB$N_LSADDR = 516,0,0,0 %;
literal UCB$S_LSADDR = 6;               !  Local station address
macro UCB$N_LSID = 522,0,0,0 %;
literal UCB$S_LSID = 6;                 !  Local station ID
macro UCB$N_RSADDR = 528,0,0,0 %;
literal UCB$S_RSADDR = 6;               !  Remote station address
macro UCB$N_RSID = 534,0,0,0 %;
literal UCB$S_RSID = 6;                 !  Remote station ID
macro UCB$L_CICMD = 540,0,32,0 %;       !  CI packet command longword
macro UCB$W_MSGBYTCNT = 544,0,16,0 %;   !  CI packet byte count
macro UCB$W_MSGPPDTYP = 546,0,16,0 %;   !  CI packet PPD type
macro UCB$T_MSGDATA = 548,0,0,0 %;
literal UCB$S_MSGDATA = 64;             !  CI packet data
literal UCB$C_PALENGTH = 736;
literal UCB$S_PAUCBDEF = 736;           !  Old PAUCBDEF size name for compatibility 
literal UCB$M_PI_ENABLE = %X'1';
literal UCB$M_PI_FKB_BUSY = %X'2';
literal UCB$M_PI_TQE_BUSY = %X'4';
literal UCB$S_PI_UCB = 928;
! 
!  Skip the common UCB plus the PA extension
! 
! 
!  Define private PI fields
! 
macro UCB$B_PI_FKB = 736,0,0,0 %;
literal UCB$S_PI_FKB = 32;
macro UCB$B_PI_TQE = 768,0,0,0 %;
literal UCB$S_PI_TQE = 64;
macro UCB$Q_PI_TFQ = 832,0,0,0 %;
literal UCB$S_PI_TFQ = 8;
macro UCB$L_PI_TFQ_FLINK = 832,0,32,1 %;
macro UCB$L_PI_TFQ_BLINK = 836,0,32,1 %;
macro UCB$Q_PI_TQ = 840,0,0,0 %;
literal UCB$S_PI_TQ = 8;
macro UCB$L_PI_TQ_FLINK = 840,0,32,1 %;
macro UCB$L_PI_TQ_BLINK = 844,0,32,1 %;
macro UCB$Q_PI_IFQ = 848,0,0,0 %;
literal UCB$S_PI_IFQ = 8;
macro UCB$L_PI_IFQ_FLINK = 848,0,32,1 %;
macro UCB$L_PI_IFQ_BLINK = 852,0,32,1 %;
macro UCB$Q_PI_IQ = 856,0,0,0 %;
literal UCB$S_PI_IQ = 8;
macro UCB$L_PI_IQ_FLINK = 856,0,32,1 %;
macro UCB$L_PI_IQ_BLINK = 860,0,32,1 %;
macro UCB$L_PI_SVA = 864,0,32,0 %;
macro UCB$L_PI_SVPN = 868,0,32,0 %;
macro UCB$L_PI_SCRIPT = 872,0,32,0 %;
macro UCB$L_PI_TGT_SCRIPT = 876,0,32,0 %;
macro UCB$L_PI_DAT_SCRIPT = 880,0,32,0 %;
macro UCB$L_PI_INI_SCRIPT = 884,0,32,0 %;
macro UCB$L_PI_RL_STAT = 888,0,32,0 %;
macro UCB$L_PI_WL_DSP = 892,0,32,0 %;
macro UCB$L_PI_TGT_C710D = 896,0,32,0 %;
macro UCB$L_PI_INI_C710D = 900,0,32,0 %;
macro UCB$L_PI_CURR_SCRIPT = 904,0,32,0 %;
macro UCB$L_PI_DSA = 908,0,32,0 %;
macro UCB$L_PI_DSPS = 912,0,32,0 %;
macro UCB$L_PI_SCRATCH = 916,0,32,0 %;
macro UCB$L_PI_EXP_INT = 920,0,32,0 %;
macro UCB$V_PI_ENABLE = 924,0,1,0 %;
macro UCB$V_PI_FKB_BUSY = 924,1,1,0 %;
macro UCB$V_PI_TQE_BUSY = 924,2,1,0 %;
macro UCB$B_PI_FLAGS = 924,0,8,0 %;
literal UCB$C_PILENGTH = 928;
literal UCB$S_PIUCBDEF = 928;           !  Old PIUCBDEF size name for compatibility 
 
!*** MODULE $UNCDEF ***
! 
!  UNCHDRDEF - Universal Context Segment Header Definition
! 
literal UNC$C_JPI = 1;                  !  JPI context segment (not used)
literal UNC$C_UAI = 2;                  !  UAI context segment
literal UNC$C_AUDIT_EVENT = 3;          !  AUDIT_EVENT context segment
literal UNC$C_OBJECT = 4;               !  Object management context segment
literal UNC$C_ORB_FIXUP = 5;            !  Writeback ORB after boot fixup
literal UNC$C_OBJECT_SERVICE = 6;       !  Object service request context
literal UNC$C_HDR_LENGTH = 16;          !  size of context segment header
literal UNC$K_HDR_LENGTH = 16;          !  size of context segment header
literal UNC$C_LIST = 16;                !  offset to first context block
literal UNC$K_LIST = 16;                !  offset to first context block
literal UNC$S_UNCHDRDEF = 16;           !  Old size name - synonym
literal UNC$S_UNCHDR = 16;
macro UNC$L_FLINK = 0,0,32,1 %;         !  forward link to next context segment
macro UNC$L_BLINK = 4,0,32,1 %;         !  back link to previous context segment
macro UNC$W_SIZE = 8,0,16,0 %;          !  total size of context segment
macro UNC$B_TYPE = 10,0,8,0 %;          !  VMS type of block (DYN$C_UNC)
macro UNC$B_SUBTYPE = 11,0,8,0 %;       !  type of context segment
macro UNC$W_COUNT = 12,0,16,0 %;        !  number of context blocks in segment
macro UNC$W_FREE_COUNT = 14,0,16,0 %;   !  number of entries free for use
macro UNC$R_LIST = 16,0,0,0 %;          !  Start of context blocks
! 
!  Universal Context Block Definition (Go Heels!)
! 
literal UNC$M_ENTRY_INUSE = %X'1';
literal UNC$M_NEW_ENTRY = %X'2';
literal UNC$C_LENGTH = 84;              !  size of largest context block
literal UNC$K_LENGTH = 84;              !  size of largest context block
literal UNC$C_SEGMENTS = 5;             !  natural number of segments/page
literal UNC$K_SEGMENTS = 5;             !  natural number of segments/page
literal UNC$S_UNCDEF = 84;              !  Old size name - synonym
literal UNC$S_UNC = 84;
macro UNC$W_FLAGS = 0,0,16,0 %;         !  context cell flags
macro UNC$V_ENTRY_INUSE = 0,0,1,0 %;    !  context entry inuse
macro UNC$V_NEW_ENTRY = 0,1,1,0 %;      !  Newly created entry
macro UNC$B_ACCESS_MODE = 2,0,8,0 %;    !  access mode of context cell
macro UNC$L_IMAGE_COUNT = 4,0,32,0 %;   !  IMGCNT when context cell assigned
macro UNC$W_UAI_IFI = 8,0,16,0 %;       !  FAB$W_IFI
macro UNC$W_UAI_ISI = 10,0,16,0 %;      !  RAB$W_ISI
macro UNC$W_UAI_CHANNEL = 12,0,16,0 %;  !  UAF channel
macro UNC$L_AE_IOSB = 8,0,32,1 %;       !  IOSB address
macro UNC$L_AE_ASTADR = 12,0,32,1 %;    !  AST address
macro UNC$L_AE_ASTPRM = 16,0,32,0 %;    !  AST parameter
macro UNC$W_AE_EFN = 20,0,16,0 %;       !  EFN number
macro UNC$W_AE_CHANNEL = 22,0,16,0 %;   !  reply mailbox channel
macro UNC$L_AE_FLAGS = 24,0,32,0 %;     !  $AUDIT_EVENT flags
macro UNC$L_AE_REPLY = 28,0,32,0 %;     !  audit server reply status
macro UNC$W_AE_QIO_STATUS = 32,0,16,0 %; !  status from $AUDIT_EVENT's $QIO to reply mailbox
macro UNC$B_AE_PRVMOD = 40,0,8,0 %;     !  mode to deliver completion AST
macro UNC$L_SO_CONTEXT = 8,0,32,0 %;    !  Value of this context block
macro UNC$L_SO_CONTEXT_PTR = 12,0,32,1 %; !  Address of user's context cell
macro UNC$L_SO_ACL_POSITION = 16,0,32,0 %; !  Position in the ACL
macro UNC$L_SO_LOCKID = 20,0,32,0 %;    !  Lock ID for write lock on ORB
macro UNC$L_SO_PARENT_ID = 24,0,32,0 %; !  Parent lock ID for SO_LOCKID
macro UNC$L_SO_OSR_FLAGS = 28,0,32,0 %; !  OSR processing flags (see $OSRDEF)
macro UNC$L_SO_OCB = 32,0,32,1 %;       !  Object Class Block address
macro UNC$L_SO_ORB = 36,0,32,1 %;       !  Address of the ORB
macro UNC$L_SO_OBJECT_HANDLE = 40,0,32,1 %; !  Object handle address
! 
!  OBJNAM_LENGTH and OBJNAM
!    must form an string 
!    descriptor
! 
macro UNC$W_SO_OBJNAM_LENGTH = 44,0,16,0 %; !  Size of object name
macro UNC$W_SO_RESERVED_1 = 46,0,16,0 %; !     Reserved (MBZ)
macro UNC$L_SO_OBJNAM = 48,0,32,1 %;    !  Object name buffer address
! 
macro UNC$W_SO_OBJNAM_BUFSIZ = 52,0,16,0 %; !  Size of objnam buffer alloc
macro UNC$B_SO_ACMODE = 54,0,8,0 %;     !  Access mode
macro UNC$B_SO_RESERVED_2 = 55,0,8,0 %; !  Reserved for digital use
macro UNC$L_SO_ACLCTX_PTR = 56,0,32,1 %; !  Context return address
macro UNC$L_SO_RESERVED_3 = 60,0,32,0 %; !  Reserved for digital use
macro UNC$L_SO_RESERVED_4 = 64,0,32,0 %; !  Reserved for digital use
macro UNC$T_SO_OSR_CONTEXT = 68,0,0,0 %;
literal UNC$S_SO_OSR_CONTEXT = 16;      !  Object Support Routine context area
macro UNC$L_OF_ASTADR = 8,0,32,1 %;     !  AST address
macro UNC$L_OF_ASTPRM = 12,0,32,0 %;    !  AST parameter
macro UNC$L_OF_FLAGS = 16,0,32,0 %;     !  flags (object specific)
macro UNC$W_OF_STATUS = 20,0,16,0 %;    !  completion status 
macro UNC$B_OF_PRVMOD = 28,0,8,0 %;     !  mode to deliver completion AST
macro UNC$L_OF_OBJECT = 32,0,32,0 %;    !  context for locating the 
macro UNC$L_OF_OBJECT1 = 36,0,32,0 %;   !  next object profile
macro UNC$L_OF_OBJECT2 = 40,0,32,0 %;   !   (object specific)
macro UNC$L_OF_OBJECT3 = 44,0,32,0 %;   ! 
macro UNC$L_OS_ASTADR = 8,0,32,1 %;     !  AST address
macro UNC$L_OS_ASTPRM = 12,0,32,0 %;    !  AST parameter
macro UNC$L_OS_FLAGS = 16,0,32,0 %;     !  flags (object specific)
macro UNC$W_OS_REPL_CHAN = 20,0,16,0 %; !  mailbox channel for reply
macro UNC$W_OS_RQST_CHAN = 22,0,16,0 %; !  mailbox channel for request
macro UNC$R_OS_IOSB = 24,0,0,0 %;
literal UNC$S_OS_IOSB = 8;              !  IOSB for $QIO
macro UNC$W_OS_STATUS = 24,0,16,0 %;    !  completion status 
macro UNC$B_OS_PRVMOD = 32,0,8,0 %;     !  mode to deliver completion AST
macro UNC$L_OS_OBJECT = 36,0,32,0 %;    !  context for locating the 
macro UNC$L_OS_OBJECT1 = 40,0,32,0 %;   !  next object profile
macro UNC$L_OS_OBJECT2 = 44,0,32,0 %;   !   (object specific)
macro UNC$L_OS_OBJECT3 = 48,0,32,0 %;   ! 
! 
!  Object management Context cell layout
! 
literal OBJCTX$S_CTXDEF = 8;            !  Old size name - synonym
literal OBJCTX$S_OBJCTX = 8;
macro OBJCTX$L_INDEX = 0,0,32,0 %;      !  Index in table
macro OBJCTX$L_SEQ = 4,0,32,0 %;        !  Sequence number
 
!*** MODULE $UTCDEF ***
! +
! 
!  $UTCDEF defines the storage format for UTC based times.
! 
! -
literal UTC$M_TDF = %X'FFF';
literal UTC$M_VER = %X'F000';
literal UTC$S_UTCDEF = 16;              !  Old size name - synonym
literal UTC$S_UTC = 16;
macro UTC$A_WHOLE_TIME = 0,0,0,1 %;
literal UTC$S_WHOLE_TIME = 16;          !  Double quad to fetch entire time
macro UTC$Q_ABSTIME = 0,0,0,0 %;
literal UTC$S_ABSTIME = 8;              !  64 bit system time
!  In units of 100ns ticks
macro UTC$Q_TDF_ETC = 8,0,0,0 %;
literal UTC$S_TDF_ETC = 8;              !  Inaccuracy, TDF, and version
macro UTC$L_ABS0 = 0,0,32,0 %;          !  Least sig 4 bytes of binary time
macro UTC$L_ABS1 = 4,0,32,0 %;          !  Most sig 4 bytes of binary time
macro UTC$L_INAC = 8,0,32,0 %;          !  4 least sig bytes of inaccuracy
macro UTC$L_TDFV = 12,0,32,0 %;         !  4 bits vers, 12 bits TDF, 2 
!  most sig bytes of inaccuracy
macro UTC$A_INACCUR = 0,0,0,1 %;
literal UTC$S_INACCUR = 6;              !  Six bytes of inaccuracy
!  In units of 100ns ticks
macro UTC$W_TDFWRD = 6,0,16,0 %;        !  Fetch the TDF and the version 
macro UTC$V_TDF = 6,0,12,0 %;
literal UTC$S_TDF = 12;                 !  12 bits of offset from UTC to local
!  In units of minutes
macro UTC$V_VER = 6,12,4,0 %;
literal UTC$S_VER = 4;                  !  Unsigned version number
 
!*** MODULE $TTYVECDEF ***
! 
! 
! 
! 
literal CLASS_LENGTH = 40;              !   must be at end.
literal CLASSS_CLASS_DEF = 40;          !  Old size name, synonym for CLASSS_TT_CLASS
literal CLASSS_TT_CLASS = 40;
macro CLASS_GETNXT = 0,0,32,1 %;        ! 
macro CLASS_PUTNXT = 4,0,32,1 %;        !  
macro CLASS_SETUP_UCB = 8,0,32,1 %;     !  
macro CLASS_DS_TRAN = 12,0,32,1 %;      !  
macro CLASS_DDT = 16,0,32,1 %;          !  
macro CLASS_READERROR = 20,0,32,1 %;    !  
macro CLASS_DISCONNECT = 24,0,32,1 %;   !  
macro CLASS_FORK = 28,0,32,1 %;         !  
macro CLASS_POWERFAIL = 32,0,32,1 %;    !  
macro CLASS_TABLES = 36,0,32,1 %;       !  
literal TABLES_LENGTH = 100;            !   must be at end.
literal TABLESS_TABLES_DEF = 100;       !  Old size name, synonym for TABLESS_TT_TABLES
literal TABLESS_TT_TABLES = 100;
macro TABLES_FILL1 = 0,0,32,0 %;        ! 
macro TABLES_FILL2 = 4,0,32,0 %;        ! 
macro TABLES_FILL3 = 8,0,32,0 %;        ! 
macro TABLES_FILL4 = 12,0,32,0 %;       ! 
macro TABLES_FILL5 = 16,0,32,0 %;       ! 
macro TABLES_FILL6 = 20,0,32,0 %;       ! 
macro TABLES_FILL7 = 24,0,32,0 %;       ! 
macro TABLES_FILL8 = 28,0,32,0 %;       ! 
macro TABLES_FILL9 = 32,0,32,0 %;       ! 
macro TABLES_FILL10 = 36,0,32,0 %;      ! 
macro TABLES_FILL11 = 40,0,32,0 %;      ! 
macro TABLES_FILL12 = 44,0,32,0 %;      ! 
macro TABLES_FILL13 = 48,0,32,0 %;      ! 
macro TABLES_FILL14 = 52,0,32,0 %;      ! 
macro TABLES_FILL15 = 56,0,32,0 %;      ! 
macro TABLES_FILL16 = 60,0,32,0 %;      ! 
macro TABLES_FILL17 = 64,0,32,0 %;      ! 
macro TABLES_INIT_MID = 68,0,32,0 %;    !  
macro TABLES_FILL19 = 72,0,32,0 %;      !  
macro TABLES_POSIX = 76,0,32,0 %;       !  
macro TABLES_ASIAN = 80,0,32,0 %;       !  
macro TABLES_FILL22 = 84,0,32,0 %;      !  
macro TABLES_FILL23 = 88,0,32,0 %;      !  
macro TABLES_FILL24 = 92,0,32,0 %;      !  
macro TABLES_FIDRIVER = 96,0,32,0 %;    !  
literal PORT_LENGTH = 76;               !   must be at end.
literal PORTS_PORT_DEF = 76;            !  Old size name, synonym for PORTS_TT_PORT
literal PORTS_TT_PORT = 76;
macro PORT_STARTIO = 0,0,32,1 %;        !  
macro PORT_DISCONNECT = 4,0,32,1 %;     !  
macro PORT_SET_LINE = 8,0,32,1 %;       !  
macro PORT_DS_SET = 12,0,32,1 %;        !  
macro PORT_XON = 16,0,32,1 %;           !  
macro PORT_XOFF = 20,0,32,1 %;          !  
macro PORT_STOP = 24,0,32,1 %;          !  
macro PORT_STOP2 = 28,0,32,1 %;         !  
macro PORT_ABORT = 32,0,32,1 %;         !  
macro PORT_RESUME = 36,0,32,1 %;        !  
macro PORT_SET_MODEM = 40,0,32,1 %;     !  
macro PORT_GLYPHLOAD = 44,0,32,1 %;     !  Glyph loading (was _DMA)
macro PORT_MAINT = 48,0,32,1 %;         !  
macro PORT_FORKRET = 52,0,32,1 %;       !  
macro PORT_FDT = 56,0,32,1 %;           !  
macro PORT_START_READ = 60,0,32,0 %;    !  Start of PSI specific extensions
macro PORT_MIDDLE_READ = 64,0,32,0 %;   ! 
macro PORT_END_READ = 68,0,32,0 %;      !  End of PSI specific extensions
macro PORT_CANCEL = 72,0,32,1 %;        !  Port driver cancel I/O routine for PORT FDT requests
! 
!  Asian terminal driver vectors
! 
literal ASIAN_LENGTH = 92;              !   must be at end.
literal ASIANS_ASIAN_DEF = 92;          !  Old size name, synonym for ASIANS_TT_ASIAN
literal ASIANS_TT_ASIAN = 92;
macro ASIAN_FDTSENSEM = 0,0,32,1 %;     !  FDT SENSEMODE
macro ASIAN_FDTSENSEC = 4,0,32,1 %;     !  FDT SENSECHAR
macro ASIAN_FDT_SETM = 8,0,32,1 %;      !  FDT SETMODE
macro ASIAN_FDT_SETC = 12,0,32,1 %;     !  FDT SETCHAR
macro ASIAN_UPPER = 16,0,32,1 %;        !  FDT upcasing
macro ASIAN_JISCON = 20,0,32,1 %;       !  JIS conversion
macro ASIAN_START_READ = 24,0,32,1 %;   !  Read QIO init
macro ASIAN_DO_SETM = 28,0,32,1 %;      !  Start I/O SETMODE
macro ASIAN_DO_SETC = 32,0,32,1 %;      !  Start I/O SETCHAR
macro ASIAN_BEGIN_ECHO = 36,0,32,1 %;   !  Start echo if needed
macro ASIAN_CURSOROVERF = 40,0,32,1 %;  !  Cursor overflow
macro ASIAN_SETUP_UCB = 44,0,32,1 %;    !  Set/reset UCB
macro ASIAN_FONTFORK = 48,0,32,1 %;     !  Fork ODL startup
macro ASIAN_CRE_CONTROL = 52,0,32,1 %;  ! 
macro ASIAN_FHPOINTER = 56,0,32,1 %;    !  Pointer to FHDRIVER
macro ASIAN_DELETE_ASC = 60,0,32,1 %;   !  Delete ASC
macro ASIAN_ABORT = 64,0,32,1 %;        !  AS$ABORT
macro ASIAN_FIND_BOL = 68,0,32,1 %;     !  Find begin of line
macro ASIAN_PRELOAD = 72,0,32,1 %;      !  Preload handling
macro ASIAN_PRELOAD_FORK = 76,0,32,1 %; !  Deliver preload req.
macro ASIAN_DEL_CACHE_FORK = 80,0,32,1 %; !  Deliver del cache req.
macro ASIAN_PRELOAD_CLEANUP = 84,0,32,1 %; !  Deliver preload req.
macro ASIAN_CLONE_UCB = 88,0,32,1 %;    !  Clone UCB fixup
! 
!  FI driver vectors
! 
literal FIDRIVER_LENGTH = 12;           !   must be at end.
literal FIDRIVERS_FIDRIVER_DEF = 12;    !  Old size name, synonym for ASIANS_TT_ASIAN
literal FIDRIVERS_TT_FIDRIVER = 12;
macro FIDRIVER_TTREAD = 0,0,32,1 %;     !  FDT READ
macro FIDRIVER_TTCANCELIO = 4,0,32,1 %; !  CANCEL IO
macro FIDRIVER_TTDISCONNECT = 8,0,32,1 %; !  DISCONNECT
! 
!  Tables pointed to by TTY$A_POSIX
! 
literal POSIX_TABLES_LENGTH = 16;       !   must be at end.
literal POSIX_TABLESS_POSIX_TABLES_DEF = 16; !  Old size name, synonym for POSIX_TABLESS_TT_POSIX_TABLES
literal POSIX_TABLESS_TT_POSIX_TABLES = 16;
macro POSIX_TABLES_PT_POINTER = 0,0,32,0 %; !  
macro POSIX_TABLES_PT_PUTNXT = 4,0,32,0 %; !  
macro POSIX_TABLES_PT_GETNXT = 8,0,32,0 %; !  
macro POSIX_TABLES_PT_WRITING = 12,0,32,0 %; !  
 
!*** MODULE $FTVECDEF ***
literal PORT_FT_LENGTH = 100;
literal PORTS_FTVECDEF = 100;
literal PORTS_FT_VEC = 100;
macro PORT_FT_CREATE = 76,0,32,1 %;
macro PORT_FT_READ = 80,0,32,1 %;
macro PORT_FT_WRITE = 84,0,32,1 %;
macro PORT_FT_SET_EVENT = 88,0,32,1 %;
macro PORT_FT_CANCEL = 92,0,32,1 %;
macro PORT_FT_DECTERM_SET = 96,0,32,1 %;
 
!*** MODULE $POSIXVECDEF ***
! ++
! 
!  POSIX driver vectors
!  	These values are used by TTDRIVER to dispatch to Posix
! 	driver routines.  The pointer to the Posix vector table is
! 	contained in TTY$A_POSIX in TTDRIVER.  The Posix driver wil
! 	use the $VECINI and $VEC macros to generate its table based 
! 	on these offsets.
! 
! __
literal POSIX_LENGTH = 88;              !   must be at end.
literal POSIXS_POSIX_DEF = 88;          !  Old size name, synonym for POSIX$S_POSIX_FDT
literal POSIXS_POSIX_FDT = 88;
macro POSIX_PUTNXT = 0,0,32,1 %;        !  POSIX VECTORS
macro POSIX_GETNXT = 4,0,32,1 %;        !  
macro POSIX_WRITING = 8,0,32,1 %;       !  Getnxt entry for POSIXWRITE
macro POSIX_DO_SETM = 12,0,32,1 %;      !  Startio SET MODE
macro POSIX_INTERRUPT = 16,0,32,1 %;    !  Send SIGINT
macro POSIX_BREAK = 20,0,32,1 %;        !  Handle BREAK condition
macro POSIX_PARITY = 24,0,32,1 %;       !  Handle PARITY error
macro POSIX_SIGHUP = 28,0,32,1 %;       !  Send SIGHUP
macro POSIX_FDT_READ = 32,0,32,1 %;     !  
macro POSIX_FDT_WRITE = 36,0,32,1 %;    !  
macro POSIX_FDT_SETM = 40,0,32,1 %;     !  
macro POSIX_FDT_SENSEM = 44,0,32,1 %;   !  
macro POSIX_INIT_PTC = 48,0,32,1 %;     !  
macro POSIX_DELETE_PTC = 52,0,32,1 %;   !  
macro POSIX_DO_SETC = 56,0,32,1 %;      !  not in V1 of Posix
macro POSIX_FDT_SETC = 60,0,32,1 %;     !  not in V1 of Posix
macro POSIX_FDT_SENSEC = 64,0,32,1 %;   !  not in V1 of Posix
macro POSIX_POWER = 68,0,32,1 %;        !  powerfail
macro POSIX_DO_READ = 72,0,32,1 %;      !  Startio POSIXREAD
macro POSIX_DO_WRITE = 76,0,32,1 %;     !  Extra write entry point if n
macro POSIX_READ_DONE = 80,0,32,1 %;    !  Read is being completed
macro POSIX_WRITE_DONE = 84,0,32,1 %;   !  Write is being completed
 
!*** MODULE $TTYSYMDEF ***
! ++
! 
!  Miscellaneous symbols used by the terminal driver.
! 
! --
! 
!  FORK DISPATCHER BIT DEFINITIONS
! 
literal TTY$M_FD_UNSOL = %X'1';
literal TTY$M_FD_GETAHD = %X'2';
literal TTY$M_FD_DISCONNECT = %X'4';
literal TTY$M_FD_PORTFORK = %X'8';
literal TTY$M_FD_UNLINK = %X'10';
literal TTY$M_FD_LINK = %X'20';
literal TTY$M_FD_ASIAN_CTRL = %X'40';
literal TTY$M_FD_FONT = %X'80';
literal TTY$M_FD_PRELOAD = %X'100';
literal TTY$M_FD_DEL_CACHE = %X'200';
literal TTY$M_FD_BUSY = %X'400';
literal TTY$S_FORK = 2;                 !  Old size name, synonym for TTY$S_FORK
literal TTY$S_TT_FORK = 2;
macro TTY$V_FD_UNSOL = 0,0,1,0 %;       !  SEND UNSOLISITED INPUT MESSAGE
macro TTY$V_FD_GETAHD = 0,1,1,0 %;      !  CREATE A TYPEAHEAD BUFFER
macro TTY$V_FD_DISCONNECT = 0,2,1,0 %;  !  DISCONNECT AND DELIVER HANGUPAST
macro TTY$V_FD_PORTFORK = 0,3,1,0 %;    !  FORK DISPATCH FOR THE PORT DRIVER
macro TTY$V_FD_UNLINK = 0,4,1,0 %;      !  UNLINK PUCB & LUCB (DETACH)
macro TTY$V_FD_LINK = 0,5,1,0 %;        !  LINK PUCB & LUCB (CONNECT)
macro TTY$V_FD_ASIAN_CTRL = 0,6,1,0 %;  !  Create Asian control block
macro TTY$V_FD_FONT = 0,7,1,0 %;        !  Font request delivery
macro TTY$V_FD_PRELOAD = 0,8,1,0 %;     !  Deliver preload request
macro TTY$V_FD_DEL_CACHE = 0,9,1,0 %;   !  request delete Soft-ODL  cache
macro TTY$V_FD_BUSY = 0,10,1,0 %;       ! *** MUST REMAIN AT THE END ********
! 
!  POSIX FDT RETURN VALUE DEFINITIONS
! 
literal TTY$M_PF_GETAHD = %X'1';
literal TTY$S_POSIX_FDT_RET = 1;
macro TTY$V_PF_GETAHD = 0,0,1,0 %;      !  CREATE A TYPEAHEAD BUFFER
! 
!  POSIX PUTNXT RETURN VALUE DEFINITIONS
! 
literal TTY$M_PP_XOFF = %X'1';
literal TTY$M_PP_XON = %X'2';
literal TTY$M_PP_CTRLY = %X'4';
literal TTY$M_PP_CTRLYFLUSH = %X'8';
literal TTY$M_PP_GETAHD = %X'10';
literal TTY$M_PP_START = %X'20';
literal TTY$M_PP_STOP = %X'40';
literal TTY$M_PP_ECHO = %X'80';
literal TTY$M_PP_FLUSHONLY = %X'100';
literal TTY$M_PP_MAX = %X'200';
literal TTY$S_POSIX_PUTNXT = 2;
macro TTY$V_PP_XOFF = 0,0,1,0 %;        !  SEND XOFF
macro TTY$V_PP_XON = 0,1,1,0 %;         !  SEND XON
macro TTY$V_PP_CTRLY = 0,2,1,0 %;       !  DELIVER CTRL-Y AST
macro TTY$V_PP_CTRLYFLUSH = 0,3,1,0 %;  !  CTRL-Y AST AND FLUSH QUEUES
macro TTY$V_PP_GETAHD = 0,4,1,0 %;      !  CREATE TYPEAHEAD
macro TTY$V_PP_START = 0,5,1,0 %;       !  CALL TTY$RESUME
macro TTY$V_PP_STOP = 0,6,1,0 %;        !  CALL TTY$STOP
macro TTY$V_PP_ECHO = 0,7,1,0 %;        !  ECHO (TTY$GETNEXTCHAR)
macro TTY$V_PP_FLUSHONLY = 0,8,1,0 %;   !  FLUSH I/O QUEUES
macro TTY$V_PP_MAX = 0,9,1,0 %;         ! ** MUST BE LAST ***
! 
!  POSIX GETNXT RETURN VALUE DEFINITIONS
! 
literal TTY$M_PG_XON = %X'1';
literal TTY$M_PG_LOOP = %X'2';
literal TTY$M_PG_WRITEDONE = %X'4';
literal TTY$S_POSIX_GETNXT = 1;
macro TTY$V_PG_XON = 0,0,1,0 %;         !  SEND XON
macro TTY$V_PG_LOOP = 0,1,1,0 %;        !  GO BACK TO GETNXT
macro TTY$V_PG_WRITEDONE = 0,2,1,0 %;   !  Finish current write
! 
!  POSIX READERROR RETURN VALUE DEFINITIONS
! 
literal TTY$M_PR_PURGEAHEAD = %X'1';
literal TTY$M_PR_FLUSH = %X'2';
literal TTY$S_POSIX_READERROR = 1;
macro TTY$V_PR_PURGEAHEAD = 0,0,1,0 %;  !  PURGE TYPEAHEAD
macro TTY$V_PR_FLUSH = 0,1,1,0 %;       !  FLUSH I/O QUEUES
! 
!  CHARACTER CONSTANTS
! 
literal TTY$C_CTRLA = 1;                !  1
literal TTY$C_CTRLB = 2;                !  2
literal TTY$C_CTRLC = 3;                !  3
literal TTY$C_CTRLD = 4;                !  4
literal TTY$C_CTRLE = 5;                !  5
literal TTY$C_CTRLF = 6;                !  6
literal TTY$C_BELL = 7;                 !  7
literal TTY$C_BS = 8;                   !  8
literal TTY$C_TAB = 9;                  !  9
literal TTY$C_LF = 10;                  !  10
literal TTY$C_VT = 11;                  !  11
literal TTY$C_FF = 12;                  !  12
literal TTY$C_CR = 13;                  !  13
literal TTY$C_CTRLN = 14;               !  14
literal TTY$C_CTRLO = 15;               !  15
literal TTY$C_CTRLP = 16;               !  16
literal TTY$C_CTRLQ = 17;               !  17 (XON)
literal TTY$C_CTRLR = 18;               !  18
literal TTY$C_CTRLS = 19;               !  19 (XOFF)
literal TTY$C_CTRLT = 20;               !  20
literal TTY$C_CTRLU = 21;               !  21
literal TTY$C_CTRLV = 22;               !  22
literal TTY$C_CTRLW = 23;               !  23
literal TTY$C_CTRLX = 24;               !  24
literal TTY$C_CTRLY = 25;               !  25
literal TTY$C_CTRLZ = 26;               !  26
literal TTY$C_ESCAPE = 27;              !  27
literal TTY$C_XON = 17;
literal TTY$C_XOFF = 19;
literal TTY$C_BLANK = 32;
literal TTY$C_DOLLAR = 36;
literal TTY$C_PLUS = 43;
literal TTY$C_ZERO = 48;
literal TTY$C_ONE = 49;
literal TTY$C_SCRIPT = 96;
literal TTY$C_LOWA = 97;
literal TTY$C_LOWZ = 123;
literal TTY$C_LOWESC1 = 125;
literal TTY$C_LOWESC2 = 126;
literal TTY$C_DELETE = 127;
literal TTY$C_NL = 128;
literal TTY$C_CSI = 155;
! 
!  Miscellaneous values
!  	
literal TTY$C_MAXPAGLEN = 255;
literal TTY$C_MAXPAGWID = 511;
literal TTY$C_HIGHIPL = 22;
! 
!  EDIT READ STATES (STORED IN THE MODE FIELD OF THE READ BUFFER)
! 
literal TTY$K_ER_NORMAL = 0;            !  NORMAL CONTROL-R OR CONTROL-U
literal TTY$K_ER_CLRECHO = 1;           !  ECHO WITH TABS EXPANDED TO SPACES
literal TTY$K_ER_ECHLINE = 2;           !  ECHO FROM GIVEN STRING
literal TTY$K_ER_UPDCURSOR = 3;         !  UPDATE THE CURSOR POSITION THEN EXIT
literal TTY$K_ER_EXITING = 4;           !  EXIT NOW
literal TTY$K_ER_MOVECURSOR = 5;        !  MOVE THE CURSOR TO ITS FINAL PLACE
literal TTY$K_ER_CLRREST = 6;           !  CLEAR THE REST OF THE LINE
literal TTY$K_ER_PRMECHO = 7;           !  ECHO OUT A PROMPT
literal TTY$K_ER_PRMECHO1 = 8;          !  RETURN STATE FOR PROMPT ECHOING
literal TTY$K_ER_AESECHO = 9;           !  ECHO AES STRING ALONE
literal TTY$K_ER_RVECHO = 10;           !  ECHO READ VERIFY STRING
literal TTY$K_ER_SIMCEOL = 11;          !  SIMULATE CLEAR TO END OF LINE
! 
!  EDITING TOKENS
! 
literal TTY$K_ET_CTRLU = 1;             !  CONTROL-U
literal TTY$K_ET_CTRLR = 2;             !  CONTROL-R
literal TTY$K_ET_DELEFT = 3;            !  DELETE CHARACTER LEFT
literal TTY$K_ET_ESCAPE = 4;            !  ESCAPE PREFIX CHARACTER
! ***** END OF THE NORMAL EDITING CHARACTERRSn
literal TTY$K_ET_BACK_CHAR = 5;         !  BACKUP 1 CHARACTER
literal TTY$K_ET_FORWARD_CHAR = 6;      !  MOVE FORWARD 1 CHARCTER
literal TTY$K_ET_MOVE_EOL = 7;          !  MOVE TO THE END OF LINE
literal TTY$K_ET_MOVE_BOL = 8;          !  MOVE TO THE BEGINNING OF THE LINE
literal TTY$K_ET_DELETE_WORD = 9;       !  DELETE WORD TO THE LEFT
literal TTY$K_ET_QUOTING = 10;          !  AND THE QUOTE CHARACTER
literal TTY$K_ET_RECALL = 11;           !  RECALL THE LAST Command
literal TTY$K_ET_TOGGEL = 12;           !  TOGGEL BETWEEN INSERT AND OVERSTRIKE MODES
literal TTY$K_ET_UNUSED = 13;           !  *** MUST REMAIN AT THE END ***
literal TTY$K_ET_TERMINATE = 14;        !  INDICATES CHARACTERS NOT ALLOWED IN EDITING INPUT LINE
literal TTY$K_EDITNORMAL = 4;
! 
!  INTERNAL FUNCTION CODES
! 
literal TTY$C_FC_READ = 0;              !  0 READ FUNCTION
literal TTY$C_FC_WRITE = 1;             !  1 WRITE FUNCTION
literal TTY$C_FC_SETM = 2;              !  2 SET MODE
literal TTY$C_FC_SETC = 3;              !  3 SET CHAR
literal TTY$C_FC_HANGUP = 4;            !  4 HANGUP
literal TTY$C_FC_MAINT = 5;             !  5 MAINTENCE FUNCTION
literal TTY$C_FC_CTRL = 6;              !  6 CONTROL ENABLE
literal TTY$C_FC_CONNECT = 7;           !  7 CONNECT TO DETACHED TERMINAL
literal TTY$C_FC_DISCON = 8;            !  8 DISCONNECT FROM ATTACHED TERMINAL
literal TTY$C_FC_POSIXREAD = 9;         !  9 POSIX READ
literal TTY$C_FC_POSIXWRITE = 10;       !  10 POSIX WRITE - MAPS TO VMS WRITE
literal TTY$C_FC_POSIXSETM = 11;        !  11 POSIX SET MODE
literal TTY$C_FC_ASSETM = 12;           !  12 Asian set mode
literal TTY$C_FC_ASSETC = 13;           !  13 Asian set characteristics
! 
!  CHARACTER CHARACTERISTICS
! 
literal TTY$M_CH_LOWER = %X'8';
literal TTY$M_CH_SPEC = %X'10';
literal TTY$M_CH_CTRL = %X'20';
literal TTY$M_CH_CTRL3 = %X'40';
literal TTY$M_CH_CTRL2 = %X'80';
literal TTY$S_CHAR_CHAR = 1;            !  Old size name, synonym for TTY$S_TT_CHAR_CHAR
literal TTY$S_TT_CHAR_CHAR = 1;
macro TTY$V_CH_FILL = 0,0,3,0 %;
literal TTY$S_CH_FILL = 3;
macro TTY$V_CH_LOWER = 0,3,1,0 %;
macro TTY$V_CH_SPEC = 0,4,1,0 %;
macro TTY$V_CH_CTRL = 0,5,1,0 %;
macro TTY$V_CH_CTRL3 = 0,6,1,0 %;
macro TTY$V_CH_CTRL2 = 0,7,1,0 %;
! ++
! 
!  ASDRIVER symbols
! 
! --
 
!*** MODULE ASSYMDEF ***
literal AS$M_MD_ODLPARSE = %X'1';
literal AS$M_MD_EDIT = %X'2';
literal AS$M_MD_NOUPCASE = %X'4';
literal AS$M_MD_INPUT = %X'8';
literal AS$M_MD_1978 = %X'10';
literal AS$M_MD_PRELOAD = %X'20';
literal AS$M_MD_4BYTE = %X'40';
literal AS$S_MODEDEF = 1;               !  Old size name, synonym for  AS$S_AS_MODE
literal AS$S_AS_MODE = 1;
macro AS$V_MD_ODLPARSE = 0,0,1,0 %;     !  Parse ODL request sequence
macro AS$V_MD_EDIT = 0,1,1,0 %;         !  MOC line editing
macro AS$V_MD_NOUPCASE = 0,2,1,0 %;     !  Disable MOC upcasing
macro AS$V_MD_INPUT = 0,3,1,0 %;        !  Input (Kana or Kanji)
macro AS$V_MD_1978 = 0,4,1,0 %;         !  JIS 1978 code conversion
macro AS$V_MD_PRELOAD = 0,5,1,0 %;      !  Dynamic glyph preloading
macro AS$V_MD_4BYTE = 0,6,1,0 %;        !  4-byte capability
literal AS$M_ST_XPORT = %X'1';
literal AS$M_ST_NOTTYGET = %X'2';
literal AS$M_ST_GLOAD = %X'4';
literal AS$M_ST_GLOAD2 = %X'8';
literal AS$M_ST_NOJOBC = %X'10';
literal AS$M_ST_NOECHO = %X'20';
literal AS$M_ST_TIM = %X'40';
literal AS$S_ODLLOADDEF = 1;            !  Old size name; synonym for AS$S_AS_ODLLOAD
literal AS$S_AS_ODLLOAD = 1;
macro AS$V_ST_XPORT = 0,0,1,0 %;        !  Extended Port
macro AS$V_ST_NOTTYGET = 0,1,1,0 %;     !  No TTYGET
macro AS$V_ST_GLOAD = 0,2,1,0 %;        !  Glyph Load
macro AS$V_ST_GLOAD2 = 0,3,1,0 %;       !  Glyph Load 2
macro AS$V_ST_NOJOBC = 0,4,1,0 %;       !  No JOBCONT
macro AS$V_ST_NOECHO = 0,5,1,0 %;       !  No Echo
macro AS$V_ST_TIM = 0,6,1,0 %;          !  Timer Active
literal AS$M_PR_REQUEST = %X'F';
literal AS$M_PR_XAREA = %X'10';
literal AS$M_PR_XSEQ = %X'20';
literal AS$S_ODLPARSEDEF = 1;           !  Old size name; synonym for AS$S_AS_ODLPARSE
literal AS$S_AS_ODLPARSE = 1;
macro AS$V_PR_REQUEST = 0,0,4,0 %;
literal AS$S_PR_REQUEST = 4;            !  Req. seq. stat
macro AS$V_PR_XAREA = 0,4,1,0 %;        !  Extend Area
macro AS$V_PR_XSEQ = 0,5,1,0 %;         !  Extended request sequence
literal AS$M_TR_ESCSEEN = %X'1';
literal AS$M_TR_1STOF2B = %X'2';
literal AS$M_TR_WAS_XA8 = %X'4';
literal AS$M_TR_KANAMODE = %X'8';
literal AS$M_TR_UPCASE = %X'10';
literal AS$M_TR_SS2 = %X'20';
literal AS$M_TR_SS3 = %X'40';
literal AS$S_JISTRANSDEF = 1;           !  Old size name; synonym for AS$S_AS_JISTRANS
literal AS$S_AS_JISTRANS = 1;
macro AS$V_TR_ESCSEEN = 0,0,1,0 %;      !  ESC seen
macro AS$V_TR_1STOF2B = 0,1,1,0 %;      !  1st of 2Byte
macro AS$V_TR_WAS_XA8 = 0,2,1,0 %;      !  it was x'A8'
macro AS$V_TR_KANAMODE = 0,3,1,0 %;     !  Kana mode
macro AS$V_TR_UPCASE = 0,4,1,0 %;       !  Upper-case ASCII code
macro AS$V_TR_SS2 = 0,5,1,0 %;          !  SS2 seen
macro AS$V_TR_SS3 = 0,6,1,0 %;          !  SS3 seen
literal AS$M_ED_EDIT = %X'1';
literal AS$M_ED_NOUPCASE = %X'2';
literal AS$M_ED_RETBYTE = %X'4';
literal AS$M_ED_GOTMOC = %X'8';
literal AS$M_ED_GOTMULTI = %X'10';
literal AS$M_ED_EXPNEXT = %X'20';
literal AS$M_ED_ECHOMOC = %X'40';
literal AS$M_ED_EDITMOC = %X'80';
literal AS$S_ASEDITDEF = 1;             !  Old size name; synonym for AS$S_AS_EDIT
literal AS$S_AS_EDIT = 1;
macro AS$V_ED_EDIT = 0,0,1,0 %;         !  MOC editing required
macro AS$V_ED_NOUPCASE = 0,1,1,0 %;     !  Disable MOC upcasing
macro AS$V_ED_RETBYTE = 0,2,1,0 %;      !  Can return incomplete MOC
macro AS$V_ED_GOTMOC = 0,3,1,0 %;       !  Got a MOC
macro AS$V_ED_GOTMULTI = 0,4,1,0 %;     !  Remove whole MOC from TA buffer
macro AS$V_ED_EXPNEXT = 0,5,1,0 %;      !  Expecting next byte of MOC
macro AS$V_ED_ECHOMOC = 0,6,1,0 %;      !  MOC echo in pregress
macro AS$V_ED_EDITMOC = 0,7,1,0 %;      !  MOC edit (e.g. del)
literal AS$M_XE_EXP2ND = %X'1';
literal AS$M_XE_EXP3RD = %X'2';
literal AS$M_XE_EXP4TH = %X'4';
literal AS$S_ASXEDDEF = 1;              !  Old size name; synonym for AS$S_AS_XED
literal AS$S_AS_XED = 1;
macro AS$V_XE_EXP2ND = 0,0,1,0 %;       !  Expecting MOC 2nd byte
macro AS$V_XE_EXP3RD = 0,1,1,0 %;       !  Expecting MOC 3rd byte
macro AS$V_XE_EXP4TH = 0,2,1,0 %;       !  Expecting MOC 4th byte
! ++
!  VMS/Japanaese Multi Code Set Support bit
! --
literal AS$M_MCE_SS2 = %X'1';
literal AS$M_MCE_SS3 = %X'2';
literal AS$M_MCE_EXP2ND = %X'4';
literal AS$M_MCE_EXP3RD = %X'8';
literal AS$M_MCE_EXPSS2NXT = %X'10';
literal AS$S_MCEDEF = 1;
macro AS$V_MCE_SS2 = 0,0,1,0 %;         !  Handling SS2 bit
macro AS$V_MCE_SS3 = 0,1,1,0 %;         !  Handling SS3 bit
macro AS$V_MCE_EXP2ND = 0,2,1,0 %;      !  Expect 2nd byte of SS3
macro AS$V_MCE_EXP3RD = 0,3,1,0 %;      !  Expect 3rd byte of SS3
macro AS$V_MCE_EXPSS2NXT = 0,4,1,0 %;   !  Expect 2nd byte of SS2
! ++
!   ODL parse State
! --
literal AS$C_PR_DONE = 0;               !  Whole sequence is parsed
literal AS$C_PR_DCS = 1;                !  Parsed DCS, expect 1st P1
literal AS$C_PR_PAR11 = 2;              !  Parsed 1st P1 parameter, expect 2nd
literal AS$C_PR_PARA = 3;               !  Parsed all P1 parameters, expect 'x'
literal AS$C_PR_TERM = 4;               !  Parsed 'x', expect 1st byte of code
literal AS$C_PR_1STB = 5;               !  Parsed 1st byte of code, expect 2nd
literal AS$C_PR_2NDB = 6;               !  Parsed 2nd byte of code, expect ST
! ++
!  VMS/Japanaese Multi Code Set Support SS handling state
! --
literal AS$C_SS2 = 142;
literal AS$C_SS3 = 143;
! ++
!  Dispatch code returned by AS$MOVEREADATA
! --
literal AS$C_GD_DISMISS = 0;            !  0  - DISMISS
literal AS$C_GD_GETNXT = 1;             !  1  - TTY$GETNEXTCHAR
literal AS$C_GD_FORMAT_CHAR = 2;        !  2  - FORMAT_CHAR
literal AS$C_GD_FORMAT_LOCAL = 3;       !  3  - FORMAT_LOCAL
literal AS$C_GD_STRTMULTI = 4;          !  4  - STRTMULTI
literal AS$C_GD_STRTMULTI_1 = 5;        !  5  - STRTMULTI_1
literal AS$C_GD_EOLSEEN = 6;            !  6  - EOLSEEN
literal AS$C_GD_XON = 7;                !  7  - XON
literal AS$C_GD_MOVE_BOL = 8;           !  8  - MOVE_BOL
literal AS$C_GD_MOVE_EOL = 9;           !  9 - MOVE_EOL
literal AS$C_GD_BACKSPACING = 10;       !  10 - BACKSPACING
literal AS$C_GD_EDITREAD = 11;          !  11 - EDITREAD
literal AS$C_GD_UPDATE_CURSOR = 12;     !  12 - UPDATE_CURSOR
literal AS$C_GD_OUTPUTANDWAIT = 13;     !  13 - OUTPUTANDWAIT
! ++
!  Miscellaneous symbols
! --
literal AS$C_MOC_MIN = 161;
 
!*** MODULE $TTYRBDEF ***
! ++
!  Read buffer definitions
! 
! 	This buffer is allocated everytime a read is issued.  The
!  buffer contains all the information necessary to perform this read.
! 
! --
literal TTY$M_RS_WRAP = %X'1';
literal TTY$S_TTYRBDEF = 84;            !  Old size name; synonym for TTY$S_TT_READBUF
literal TTY$S_TT_READBUF = 84;
macro TTY$L_RB_TXT = 0,0,32,1 %;        !  Address of the first character of
!  the read data.
macro TTY$L_RB_UVA = 4,0,32,1 %;        !  READ BUFFER - USER VIRTUAL ADDR
macro TTY$W_RB_SIZE = 8,0,16,0 %;       !  READ BUFFER - BLOCK SIZE
macro TTY$W_RB_TYPE = 10,0,16,0 %;      !  buffer type
macro TTY$W_RB_ECHLEN = 12,0,16,0 %;    !  NUMBER OF CHARACTERS TO ECHO
!  WHEN OUTPUTTING FROM ECHSTR
macro TTY$W_RB_NONFILL = 14,0,16,0 %;   !  POSITION OF 1ST NONFILL CHAR
macro TTY$Q_RB_ECHOAREA = 16,0,0,0 %;
literal TTY$S_RB_ECHOAREA = 8;          !  WORDS TO ECHO CHARACTERS FROM
macro TTY$L_RB_ECHSTR = 24,0,32,1 %;    !  ADDRESS OF THE FIRST CHARACTER
!  TO OUTPUT DURING EDITECHOING.
macro TTY$L_RB_PIC = 28,0,32,1 %;       !  ADDRESS OF THE PICTURE STRING
!  FOR READ VERIFY
macro TTY$L_RB_TERM = 32,0,32,1 %;      !  THE ADDRESS OF THE TERMINATOR BITMASK
macro TTY$L_RB_MOD = 36,0,32,0 %;       !  MODIFIER LONGWORD
macro TTY$L_RB_AES = 40,0,32,1 %;       !  ADDRESS OF THE AES STRING
macro TTY$W_RB_AESLEN = 44,0,16,0 %;    !  THE LENGTH OF THE AESSTRING
macro TTY$W_RB_RDSTATE = 46,0,16,0 %;   !  Read state information word
macro TTY$V_RS_WRAP = 46,0,1,0 %;       !  THE READ HAS WRAPPED EITHER IN THE PROMPT OR INITIAL STRING
macro TTY$L_RB_LIN = 48,0,32,1 %;       !  ADDRESS OF THE FIRST CHARACTER ON
!  THIS LINE.
macro TTY$W_RB_LINOFF = 52,0,16,0 %;    !  OFFSET FROM THE BEGINNING OF THE
!  LINE TO THE CURSOR POSITION.
macro TTY$W_RB_LINREST = 54,0,16,0 %;   !  NUMBER OF CHARACTERS TO THE RIGHT
!  OF THE CURSOR POSITION, USED BY
!  INPUT EDITING
macro TTY$W_RB_PRMLEN = 56,0,16,0 %;    !  LENGTH IN BYTES OF THE PROMPT STRING
macro TTY$W_RB_TIMOS = 58,0,16,0 %;     !  READ BUFFER - TIMEOUT SECONDS
macro TTY$W_RB_CPZCUR = 60,0,16,0 %;    !  CURRENT CURSOR POSITION
macro TTY$W_RB_CPZORG = 62,0,16,0 %;    !  READ BUFFER - ORIGONAL HORIZON
macro TTY$W_RB_TXTOFF = 64,0,16,0 %;    !  OFFSET FROM THE BEGINNING OF THE
!  DATA TO THE LOCATION OF THE NEXT CHARACTER
macro TTY$W_RB_PICLEN = 66,0,16,0 %;    !  the length of the picture string
macro TTY$W_RB_TXTSIZ = 68,0,16,0 %;    !  THE LENGTH OF THE READ.
macro TTY$W_RB_TXTECH = 70,0,16,0 %;    !  AMOUNT OF INITIAL STRING TO ECHO
macro TTY$W_RB_MODE = 72,0,16,0 %;      !  VALUE INDICATING READ EDIT MODE
macro TTY$B_RB_RVFCLR = 74,0,8,0 %;     !  CLEAR CHARACTER FOR READ VERIFY
macro TTY$B_RB_RVFFIL = 75,0,8,0 %;     !  READ VERIFY FILL CHARACTER
macro TTY$W_RB_ESCTKN = 76,0,16,0 %;    !  ESCAPE TOKEN CHARACTER
macro TTY$W_RB_TXTONLYSIZ = 78,0,16,0 %; !  SIZE OF TEXT W/OUT TERMINATOR
macro TTY$A_RB_PRM = 80,0,32,0 %;       !  ADDRESS OF BEGINNING OF THE PROMPT
macro TTY$L_RB_DATA = 80,0,32,1 %;      !  READ BUFFER  - DATA
 
!*** MODULE $TTYISDEF ***
! ++
!  ITEM LIST STACK STRUCTURE
! 
!  WARNING: STRUCTURE MUST ALWAYS BE FORCED TO A LONGWORD BOUNDARY.
! 
!  DESCRIPTION:
! 	THIS STRUCTURE IS ALLOCATED OFF THE STACK WHEN AN ITEM LIST QIO IS
!  DETECTED.
! --
literal TTY$K_IS_LENGTH = 96;           !  LENGTH
literal TTY$S_TTYISDEF = 96;            !  Old size name, synonym for TTY$S_TT_ITEM_STK
literal TTY$S_TT_ITEM_STK = 96;
macro TTY$L_IS_ACMODE = 0,0,32,0 %;     !  ACCESS MODE MAXIMIZED WITH THE MODE OF THE CALLER
macro TTY$L_IS_EDITMODE = 4,0,32,0 %;   !  PLACE TO KEEP THE MODE
macro TTY$L_IS_BUF = 8,0,32,1 %;        !  THE USERS ADDRESS OF HIS BUFFER
macro TTY$L_IS_BUFLEN = 12,0,32,0 %;    !  THE LENGTH OF THE USERS BUFFER
macro TTY$L_IS_INI = 16,0,32,1 %;       !  USERS INITIAL STRING ADDRESS
macro TTY$L_IS_INILEN = 20,0,32,0 %;    !  LENGTH OF THE INITIAL STRING
macro TTY$L_IS_INIBUF = 24,0,32,0 %;    !  length of initial buffer for fallback use
macro TTY$L_IS_ITMLST = 28,0,32,1 %;    !  THE USERS ADDRESS OF THE ITEM LIST
!  USED AS A POINTER TO THE NEXT ENTRY
macro TTY$L_IS_LASTITM = 32,0,32,1 %;   !  USERS ADDRESS OF THE LAST ITEM
!  CALCULATED FROM BEGINNING ADDRESS AND LENGTH
macro TTY$L_IS_MODIFY = 36,0,32,0 %;    !  THE USERS MODIFIER BITS
macro TTY$L_IS_PIC = 40,0,32,1 %;       !  USERS ADDRESS OF THE PICTURE STRING
macro TTY$L_IS_PICLEN = 44,0,32,0 %;    !  THE LENGTH OF THE PICTURE STRING
macro TTY$L_IS_PRM = 48,0,32,1 %;       !  USERS ADDRESS OF THE PROMPT STRING
macro TTY$L_IS_PRMLEN = 52,0,32,0 %;    !  THE LENGTH OF THE PROMPT STRING
macro TTY$L_IS_PRMBUF = 56,0,32,0 %;    !  length of prompt for fallback use
macro TTY$L_IS_SPECIFYED = 60,0,32,0 %; !  BITMASK OF SPECIFYED ITEM LIST ENTRIES
macro TTY$L_IS_TERM = 64,0,32,1 %;      !  THE ADDRESS OF THE USERS TERMINATOR MASK
macro TTY$L_IS_TERMLEN = 68,0,32,1 %;   !  THE LENGTH OF THE USERS TERMINATOR MASK
macro TTY$L_IS_AES = 72,0,32,1 %;       !  THE ADDRESS OF THE ALTERNATE ECHO STRING
macro TTY$L_IS_AESLEN = 76,0,32,0 %;    !  THE LENGTH OF THE ALTERNATE ECHO STRING
macro TTY$L_IS_TIMEOUT = 80,0,32,0 %;   !  TIMEOUT VALUE
macro TTY$W_IS_FILLCHR = 84,0,16,0 %;   !  TWO BYTES SPECIFYING FILL AND CLEAR CHARACTER
macro TTY$W_IS_INIOFF = 86,0,16,0 %;    !  OFFSET INTO INITIAL STRING FOR ECHOING
macro TTY$W_IS_ESCTRMOVR = 88,0,16,0 %; !  ESCAPE TERMINATOR OVERFLOW SIZE
macro TTY$W_IS_SPAREW = 90,0,16,0 %;    !  round to longword
macro TTY$L_IS_SPAREL = 92,0,32,0 %;    !  round to quadword boundary
 
!*** MODULE $TTYILDEF ***
! ++
!  Itemlist Descriptor
! 
!  Description:
! 	This set of definitions defines the locations of all the fields
!  in the terminal QIO item list.
! --
literal TTY$K_IL_LENGTH = 12;           !  LENGTH
literal TTY$S_TTYILDEF = 12;            !  Old size name, synonym for TTY$S_TT_ITEM_LIST
literal TTY$S_TT_ITEM_LIST = 12;
macro TTY$W_IL_LEN = 0,0,16,0 %;        !  THE LENGTH OF THE BUFFER POINTED TO BY ADR
macro TTY$W_IL_TYPE = 2,0,16,0 %;       !  THE TYPE CODE OF THIS ITEM
macro TTY$L_IL_ADR = 4,0,32,0 %;        !  THE USER SPECIFYED ADDRESS
macro TTY$L_IL_RETADR = 8,0,32,0 %;     !  VALUE RETURNED ADDRESS
 
!*** MODULE $TTYTADEF ***
! ++
!  TYPEAHEAD BUFFER
! 
!  DESCRIPTION:
! 	THIS BUFFER IS USED TO STORE CHARACTERS BEFORE PROCESSING AND
!  MOVING THEM INTO THE USERS READ BUFFER.
! 	ALLOCATED ON UNSOLICITED DATA OR THE FIRST READ POSTED ON A TERMINAL
!  LINE.  
! --
literal TTY$K_TA_RCLLEN = 256;          !  LENGTH OF RECALL
literal TTY$S_TTYTADEF = 284;           !  Old size name, synonym for TTY$S_TT_TYPE_AHD
literal TTY$S_TT_TYPE_AHD = 284;
!  THE LENGTH OF THE RECALL BUFFER
macro TTY$L_TA_PUT = 0,0,32,1 %;        !  PUT POINTER
macro TTY$L_TA_GET = 4,0,32,1 %;        !  GET POINTER
macro TTY$W_TA_SIZE = 8,0,16,0 %;       !  BLOCK SIZE
macro TTY$B_TA_TYPE = 10,0,8,0 %;       !  
macro TTY$B_TA_SPARE1 = 11,0,8,0 %;
macro TTY$W_TA_INAHD = 12,0,16,0 %;     !  COUNT OF CHARS IN BUFFER
macro TTY$W_TA_RCLOFF = 14,0,16,0 %;    !  NUMBER OF CHARACTERS IN THE RECALL
!  BUFFER USED.
macro TTY$L_TA_END = 16,0,32,1 %;       !  END ADDRESS
macro TTY$W_TA_RCLSIZ = 20,0,16,0 %;    !  THE SIZE OF THE RECALL STRING
macro TTY$W_TA_SPARE2 = 22,0,16,0 %;
macro TTY$A_TA_RCL = 24,0,0,0 %;
literal TTY$S_TA_RCL = 256;             !  TYPEAHEAD BUFFER - RECALL BUFFER
macro TTY$L_TA_DATA = 280,0,32,1 %;     !  TYPEAHEAD BUFFER - DATA START
 
!*** MODULE $TTYMDMDEF ***
!  aka $TTYMODEM via hack in TTYMACS.MAR
! 
! 	Modem control state table definitions
! 
! 
! 	state entry definitions
! 
literal MODEM$C_ST_LENGTH = 8;          !  LENGTH
literal MODEM$S_MODEM_STATE = 8;        !  Old size name, synonym for MODEM$S_TT_MODEM_STATE
literal MODEM$S_TT_MODEM_STATE = 8;
macro MODEM$B_ST_ONMASK = 0,0,8,0 %;    ! output signals to activate
macro MODEM$B_ST_OFFMASK = 1,0,8,0 %;   ! output signals to disable
macro MODEM$W_ST_TIMER = 2,0,16,0 %;    ! timer amount to init
macro MODEM$L_ST_ROUTINE = 4,0,32,1 %;  ! action routine ADDRESS
! 
! 	transition definitions
! 
literal MODEM$C_TRAN_LENGTH = 8;        !  LENGTH
literal MODEM$S_MODEM_TRANS = 8;        !  Old size name, synonym for MODEM$S_TT_MODEM_TRANS
literal MODEM$S_TT_MODEM_TRANS = 8;
macro MODEM$B_TRAN_TYPE = 0,0,8,0 %;    !  element type
macro MODEM$B_TRAN_TYPE2 = 1,0,8,0 %;   !  unused element type
macro MODEM$B_TRAN_OFFMASK = 2,0,8,0 %; !  input signals test on
macro MODEM$B_TRAN_ONMASK = 3,0,8,0 %;  !  input signals test off
macro MODEM$L_TRAN_NSTATE = 4,0,32,1 %; !  next state ADDRESS
! 
! 	transition type codes
! 
literal MODEM$C_TRAN_DATASET = 0;       !  dataset
literal MODEM$C_TRAN_TIME = 1;          !  timer
literal MODEM$C_TRAN_END = 2;           !  end of transition list
literal MODEM$C_TRAN_DIALTYPE = 3;      !  test for sysgen parameter
literal MODEM$C_TRAN_DZ11 = 4;          !  controller = DZ11
literal MODEM$C_TRAN_NOMODEM = 5;       !  line not enabled for modem
! 
! 	 argument type codes
! 
literal MODEM$C_INIT = 0;               !  init line
literal MODEM$C_SHUTDWN = 1;            !  hangup command
literal MODEM$C_NULL = 2;               !  null, for detecting preset conditions
literal MODEM$C_DATASET = 3;            !  dataset interrupt
literal MODEM$C_TIMER = 4;              !  timer expiration
literal MODEM$C_INIT_NORESET = 5;       !  init modem but not signals
literal MODEM$C_SHUTDWN_NOHANGUP = 6;   !  stop modem but not signals
literal TIMCTRL$M_CANCEL = %X'1';
literal TIMCTRL$M_ACTIVE = %X'2';
literal TIMCTRL$S_MODEM_BITS = 1;       !  Old size name, synonym for TIMCTRL$S_TT_MODEM_BITS
literal TIMCTRL$S_TT_MODEM_BITS = 1;
macro TIMCTRL$V_CANCEL = 0,0,1,0 %;     ! CANCEL TIMER REQUEST
macro TIMCTRL$V_ACTIVE = 0,1,1,0 %;     ! TIMER CURRENTLY ACTIVE
literal MODEM$M_ENABLE = 32768;         ! mask enable
 
!*** MODULE $TTYDEF ***
! ++
! 
!  Terminal driver write packet (TWP)
! 
! --
literal TTY$K_WB_LENGTH = 56;           !  LENGTH
literal TTY$C_WB_LENGTH = 56;           !  LENGTH
literal TTY$S_TTYWBDEF = 60;            !  Old size name, synonym for TWP$S_TWP
literal TTY$S_TWP = 60;
macro TTY$L_WB_FLINK = 0,0,32,1 %;      ! 
macro TTY$L_WB_BLINK = 4,0,32,1 %;      ! 
macro TTY$W_WB_SIZE = 8,0,16,0 %;       !  
macro TTY$B_WB_TYPE = 10,0,8,0 %;       !  
macro TTY$B_WB_FLCK = 11,0,8,0 %;       !  
macro TTY$L_WB_FPC = 12,0,32,1 %;       ! 
macro TTY$Q_WB_FR3 = 16,0,0,1 %;
literal TTY$S_WB_FR3 = 8;               ! 
macro TTY$Q_WB_FR4 = 24,0,0,1 %;
literal TTY$S_WB_FR4 = 8;               ! 
macro TTY$L_WB_MAP = 32,0,32,1 %;       ! 
macro TTY$L_WB_NEXT = 36,0,32,1 %;      ! 
macro TTY$L_WB_END = 40,0,32,1 %;       ! 
macro TTY$L_WB_IRP = 44,0,32,1 %;       ! 
macro TTY$W_WB_STATUS = 48,0,16,0 %;    !  
macro TTY$W_WB_BCNT = 50,0,16,0 %;      !  
macro TTY$L_WB_RETADDR = 52,0,32,1 %;   !  
macro TTY$L_WB_DATA = 56,0,32,1 %;      ! 
 
!*** MODULE $TTYDIALTYP ***
! 
!  Assign meanings to bits in the TTY_DIALTYP SYSGEN parameter.
! 
literal TTY$M_RINGWAIT = %X'1';
literal TTY$M_FAST_SHUTDOWN = %X'2';
literal TTY$M_NO_REFC = %X'4';
literal TTY$M_A_SPEEDS = %X'8';
literal TTY$S_DIALTYP_BITS = 1;         !  Old size name, synonym for TTY$S_TTY_DIALTYP
literal TTY$S_TTY_DIALTYP = 1;
macro TTY$V_RINGWAIT = 0,0,1,0 %;       ! WAIT FOR RING BEFORE SET DTR
macro TTY$V_FAST_SHUTDOWN = 0,1,1,0 %;  ! SHUTDOWN IMMED. IF LOSE CARRIER
macro TTY$V_NO_REFC = 0,2,1,0 %;        ! SKIP CHECK FOR REFC
macro TTY$V_A_SPEEDS = 0,3,1,0 %;       ! IF SET, USE A SPEED TABLE
! last bit reserved for internal
! use
 
!*** MODULE $TTYUCBDEF ***
! 
!   $TTYUCBDEF follows here only because there is no way to get the 
!   UCB$K_LENGTH symbol into another module. TTYUCBDEF was formerly
!   included in TTYDEF.MAR.
! 
!  TERMINAL DRIVER DEFINITIONS
! 
!  These definitions define the device dependent extensions of the UCB.
!  Certain portions of the ucb are assumed to be contiguous and must not
!  be split. These areas are documented in the following definitions.
! 
literal UCB$S_LTRM_UCB = 272;
! 
!  Logical terminal UCB extension
! 
macro UCB$L_TL_CTRLY = 224,0,32,1 %;    !  CONTROL Y AST BLOCK LIST HEAD
macro UCB$L_TL_CTRLC = 228,0,32,1 %;    !  CONTROL C AST BLOCK LIST HEAD
macro UCB$L_TL_OUTBAND = 232,0,32,0 %;  !  OUT OF BAND CHARACTER MASK
macro UCB$L_TL_BANDQUE = 236,0,32,1 %;  !  OUT OF BAND AST QUEUE
macro UCB$L_TL_PHYUCB = 240,0,32,1 %;   !  THE PHYSICAL UCB ADDRESS
macro UCB$L_TL_CTLPID = 244,0,32,0 %;   !  CONTROLING PID (USED WITH SPAWN)
macro UCB$Q_TL_BRKTHRU = 248,0,0,0 %;
literal UCB$S_TL_BRKTHRU = 8;           !  FACILITY BROADCAST BITMASK
macro UCB$L_TL_POSIX_DATA = 256,0,32,1 %; !  POSIX PTC POINTER
macro UCB$L_TL_ASIAN_DATA = 260,0,32,1 %; !  ASIAN DATA POINTER
macro UCB$B_TL_A_MODE = 264,0,8,0 %;    !  CURRENT ASIAN MODES
macro UCB$L_TL_A_CHARSET = 264,0,32,0 %; !  CHARACTER SET BITMASK
macro UCB$L_TL_A_FI_UCB = 268,0,32,1 %; !  POINTER TO ASIAN INPUT SERVER
! 
!  Terminal class driver dependant region
!  Split here between local and remote terminal UCB's, each of 
!  which has it's own type.
! 
literal UCB$C_TL_LENGTH = 272;
literal UCB$K_TL_LENGTH = 272;
literal TTY$M_ST_POWER = %X'1';
literal TTY$M_ST_CTRLS = %X'2';
literal TTY$M_ST_LOSTCTS = %X'4';
literal TTY$M_ST_MODEM_OFF = %X'8';
literal TTY$M_ST_POSIXSTALL = %X'10';
literal TTY$M_ST_FILL = %X'20';
literal TTY$M_ST_CURSOR = %X'40';
literal TTY$M_ST_SENDLF = %X'80';
literal TTY$M_ST_BACKSPACE = %X'100';
literal TTY$M_ST_MULTI = %X'200';
literal TTY$M_ST_WRITE = %X'400';
literal TTY$M_ST_POSIXWRITE = %X'800';
literal TTY$M_ST_EOL = %X'1000';
literal TTY$M_ST_EDITREAD = %X'2000';
literal TTY$M_ST_RDVERIFY = %X'4000';
literal TTY$M_ST_RECALL = %X'8000';
literal TTY$M_ST_READ = %X'10000';
literal TTY$M_ST_POSIXREAD = %X'20000';
literal TTY$M_ST_CTRLO = %X'1';
literal TTY$M_ST_DEL = %X'2';
literal TTY$M_ST_PASALL = %X'4';
literal TTY$M_ST_NOECHO = %X'8';
literal TTY$M_ST_WRTALL = %X'10';
literal TTY$M_ST_PROMPT = %X'20';
literal TTY$M_ST_NOFLTR = %X'40';
literal TTY$M_ST_ESC = %X'80';
literal TTY$M_ST_BADESC = %X'100';
literal TTY$M_ST_NL = %X'200';
literal TTY$M_ST_REFRSH = %X'400';
literal TTY$M_ST_ESCAPE = %X'800';
literal TTY$M_ST_TYPFUL = %X'1000';
literal TTY$M_ST_SKIPLF = %X'2000';
literal TTY$M_ST_ESC_O = %X'4000';
literal TTY$M_ST_WRAP = %X'8000';
literal TTY$M_ST_OVRFLO = %X'10000';
literal TTY$M_ST_AUTOP = %X'20000';
literal TTY$M_ST_CTRLR = %X'40000';
literal TTY$M_ST_SKIPCRLF = %X'80000';
literal TTY$M_ST_EDITING = %X'100000';
literal TTY$M_ST_TABEXPAND = %X'200000';
literal TTY$M_ST_QUOTING = %X'400000';
literal TTY$M_ST_OVERSTRIKE = %X'800000';
literal TTY$M_ST_TERMNORM = %X'1000000';
literal TTY$M_ST_ECHAES = %X'2000000';
literal TTY$M_ST_PRE = %X'4000000';
literal TTY$M_ST_NINTMULTI = %X'8000000';
literal TTY$M_ST_RECONNECT = %X'10000000';
literal TTY$M_ST_CTSLOW = %X'20000000';
literal TTY$M_ST_TABRIGHT = %X'40000000';
literal UCB$M_TT_XXPARITY = %X'1';
literal UCB$M_TT_DISPARERR = %X'2';
literal UCB$M_TT_USERFRAME = %X'4';
literal UCB$M_TT_LEN = %X'18';
literal UCB$M_TT_STOP = %X'20';
literal UCB$M_TT_PARTY = %X'40';
literal UCB$M_TT_ODD = %X'80';
literal TTY$M_TANK_PREMPT = %X'100';
literal TTY$M_TANK_STOP = %X'200';
literal TTY$M_TANK_HOLD = %X'400';
literal TTY$M_TANK_BURST = %X'800';
literal TTY$M_TANK_DMA = %X'1000';
literal TTY$M_PC_NOTIME = %X'1';
literal TTY$M_PC_DMAENA = %X'2';
literal TTY$M_PC_DMAAVL = %X'4';
literal TTY$M_PC_PRMMAP = %X'8';
literal TTY$M_PC_MAPAVL = %X'10';
literal TTY$M_PC_XOFAVL = %X'20';
literal TTY$M_PC_XOFENA = %X'40';
literal TTY$M_PC_NOCRLF = %X'80';
literal TTY$M_PC_BREAK = %X'100';
literal TTY$M_PC_PORTFDT = %X'200';
literal TTY$M_PC_NOMODEM = %X'400';
literal TTY$M_PC_NODISCONNECT = %X'800';
literal TTY$M_PC_SMART_READ = %X'1000';
literal TTY$M_PC_ACCPORNAM = %X'2000';
literal TTY$M_PC_MULTISESSION = %X'8000';
literal UCB$M_TT_DSBL = %X'80';
literal UCB$S_TTY_UCB = 444;
!  READ TIMEOUT CONTROL
macro UCB$L_TT_RDUE = 272,0,32,0 %;     !  ABSTIME WHEN READ TIMEOUT DUE
macro UCB$L_TT_RTIMOU = 276,0,32,1 %;   !  ADDRESS OF READ TIMEOUT ROUTINE
!  TERMINAL DRIVER STATE TABLE
!  (NOTE: Any changes made to this state table must also be made to
!         the SX state table.)
macro UCB$Q_TT_STATE = 280,0,0,0 %;
literal UCB$S_TT_STATE = 8;             !  CURRENT UNIT STATE VECTOR
macro UCB$L_TT_STATE1 = 280,0,32,0 %;
macro TTY$V_ST_POWER = 280,0,1,0 %;     ! 
macro TTY$V_ST_CTRLS = 280,1,1,0 %;     ! 
macro TTY$V_ST_LOSTCTS = 280,2,1,0 %;   !  Reserved for future work
macro TTY$V_ST_MODEM_OFF = 280,3,1,0 %; ! 
macro TTY$V_ST_POSIXSTALL = 280,4,1,0 %; !  POSIX timed output wait
macro TTY$V_ST_FILL = 280,5,1,0 %;      ! 
macro TTY$V_ST_CURSOR = 280,6,1,0 %;    ! 
macro TTY$V_ST_SENDLF = 280,7,1,0 %;    ! 
macro TTY$V_ST_BACKSPACE = 280,8,1,0 %; ! 
macro TTY$V_ST_MULTI = 280,9,1,0 %;     ! 
macro TTY$V_ST_WRITE = 280,10,1,0 %;
macro TTY$V_ST_POSIXWRITE = 280,11,1,0 %; !  POSIX special case write
macro TTY$V_ST_EOL = 280,12,1,0 %;      ! 
macro TTY$V_ST_EDITREAD = 280,13,1,0 %; ! 
macro TTY$V_ST_RDVERIFY = 280,14,1,0 %; ! 
macro TTY$V_ST_RECALL = 280,15,1,0 %;   ! 
macro TTY$V_ST_READ = 280,16,1,0 %;     ! 
macro TTY$V_ST_POSIXREAD = 280,17,1,0 %; ! 
macro UCB$L_TT_STATE2 = 284,0,32,0 %;
macro TTY$V_ST_CTRLO = 284,0,1,0 %;     ! 
macro TTY$V_ST_DEL = 284,1,1,0 %;       ! 
macro TTY$V_ST_PASALL = 284,2,1,0 %;    ! 
macro TTY$V_ST_NOECHO = 284,3,1,0 %;    ! 
macro TTY$V_ST_WRTALL = 284,4,1,0 %;    ! 
macro TTY$V_ST_PROMPT = 284,5,1,0 %;    ! 
macro TTY$V_ST_NOFLTR = 284,6,1,0 %;    ! 
macro TTY$V_ST_ESC = 284,7,1,0 %;       ! 
macro TTY$V_ST_BADESC = 284,8,1,0 %;    ! 
macro TTY$V_ST_NL = 284,9,1,0 %;        ! 
macro TTY$V_ST_REFRSH = 284,10,1,0 %;   ! 
macro TTY$V_ST_ESCAPE = 284,11,1,0 %;   ! 
macro TTY$V_ST_TYPFUL = 284,12,1,0 %;   ! 
macro TTY$V_ST_SKIPLF = 284,13,1,0 %;   ! 
macro TTY$V_ST_ESC_O = 284,14,1,0 %;    ! 
macro TTY$V_ST_WRAP = 284,15,1,0 %;     ! 
macro TTY$V_ST_OVRFLO = 284,16,1,0 %;   ! 
macro TTY$V_ST_AUTOP = 284,17,1,0 %;    ! 
macro TTY$V_ST_CTRLR = 284,18,1,0 %;    ! 
macro TTY$V_ST_SKIPCRLF = 284,19,1,0 %; ! 
macro TTY$V_ST_EDITING = 284,20,1,0 %;  ! 
macro TTY$V_ST_TABEXPAND = 284,21,1,0 %; ! 
macro TTY$V_ST_QUOTING = 284,22,1,0 %;  ! 
macro TTY$V_ST_OVERSTRIKE = 284,23,1,0 %; ! 
macro TTY$V_ST_TERMNORM = 284,24,1,0 %; ! 
macro TTY$V_ST_ECHAES = 284,25,1,0 %;   ! 
macro TTY$V_ST_PRE = 284,26,1,0 %;      ! 
macro TTY$V_ST_NINTMULTI = 284,27,1,0 %; ! 
macro TTY$V_ST_RECONNECT = 284,28,1,0 %; ! 
macro TTY$V_ST_CTSLOW = 284,29,1,0 %;   ! 
macro TTY$V_ST_TABRIGHT = 284,30,1,0 %; ! 
macro UCB$L_TT_LOGUCB = 288,0,32,1 %;   !  ADDRESS OF THE LOGICAL UCB
!  DEFAULT CHARACTERISTICS
macro UCB$L_TT_DECHAR = 292,0,32,0 %;   !  DEFAULT DEVICE CHARACTERISTICS
macro UCB$L_TT_DECHA1 = 296,0,32,0 %;   !  DEFAULT DEVICE CHAR EXTENSIONS
macro UCB$L_TT_DECHA2 = 300,0,32,0 %;   !  MORE DEVICE CHARACTERISTICS
macro UCB$L_TT_DECHA3 = 304,0,32,0 %;   !  ANOTHER DEVICE CHAR EXTENSIONS
!  WRITE QUEUE POINTERS
macro UCB$L_TT_WFLINK = 308,0,32,1 %;   !  Write queue forward link.
macro UCB$L_TT_WBLINK = 312,0,32,1 %;   !  Write queue backward link.
macro UCB$L_TT_WRTBUF = 316,0,32,1 %;   !  Current write buffer block.
!  ADDRESS AND LENGTH OF MULTI-ECHO STRING
macro UCB$L_TT_MULTI = 320,0,32,1 %;    !  CURRENT MULTIECHO BUFFER ADDRESS
macro UCB$W_TT_MULTILEN = 324,0,16,0 %; !  LENGTH OF STRING TO OUTPUT
macro UCB$W_TT_SMLTLEN = 326,0,16,0 %;  !  SAVED MULTI LENGTH
macro UCB$L_TT_SMLT = 328,0,32,1 %;     !  AND THE SAVED ADDRESS
! -- **********************************************************************
!  DEFAULT SPEED, FILL ,PARITY (MUST BE CONTIGUOUS)
! ++ *******************************************************************
macro UCB$W_TT_DESPEE = 332,0,16,0 %;   !  DEFAULT SPEED
macro UCB$B_TT_DECRF = 334,0,8,0 %;     !  DEFAULT CR FILL
macro UCB$B_TT_DELFF = 335,0,8,0 %;     !  DEFAULT LF FILL
macro UCB$B_TT_DEPARI = 336,0,8,0 %;    !  DEFAULT PARITY/CHAR SIZE
macro UCB$B_TT_DEFSPE_SPARE1 = 337,0,8,0 %;
macro UCB$W_TT_DEFSPE_SPARE2 = 338,0,16,0 %;
! -- **********************************************************************
! 
!  DEFAULT TERMINAL TYPE AND SIZE
! 
! ++  ***********************************************************************
macro UCB$W_TT_DESIZE = 340,0,16,0 %;   !  DEFAULT LINE SIZE
macro UCB$B_TT_DETYPE = 342,0,8,0 %;    !  DEFAULT TERMINAL TYPE
macro UCB$B_TT_SPARE1 = 343,0,8,0 %;    !  SPARE BYTE MUST FOLLOW
! -- **********************************************************************
!  SPEED, FILL, PARITY (MUST BE CONTIGUOUS)
! ++ *****************************************************************
macro UCB$W_TT_SPEED = 344,0,16,0 %;    !  SPEED CODES (SPLIT SPEED)
macro UCB$B_TT_TSPEED = 344,0,8,0 %;    !  TRANSMIT SPEED
macro UCB$B_TT_RSPEED = 345,0,8,0 %;    !  RECEIVE SPEED
macro UCB$B_TT_CRFILL = 346,0,8,0 %;    !  NUMBER FILLS TO OUTPUT ON CR
macro UCB$B_TT_LFFILL = 347,0,8,0 %;    !  NUMBER FILLS TO OUTPUT ON LF
macro UCB$B_TT_PARITY = 348,0,8,0 %;    !  PARITY AND CHARACTER SIZE DEFINITIONS
macro UCB$V_TT_XXPARITY = 348,0,1,0 %;  !  UNUSED ??
macro UCB$V_TT_DISPARERR = 348,1,1,0 %; !  SPECIFY DISREGARD PARITY ERRORS
macro UCB$V_TT_USERFRAME = 348,2,1,0 %; !  SPECIFY USER FRAME SETUP
macro UCB$V_TT_LEN = 348,3,2,0 %;
literal UCB$S_TT_LEN = 2;               !  CHARACTER LENGTH
macro UCB$V_TT_STOP = 348,5,1,0 %;      !  STOP BITS
macro UCB$V_TT_PARTY = 348,6,1,0 %;     !  PARITY ENABLED
macro UCB$V_TT_ODD = 348,7,1,0 %;       !  ODD PARITY
macro UCB$B_TT_PAR_SPARE1 = 349,0,8,0 %;
macro UCB$W_TT_PAR_SPARE2 = 350,0,16,0 %;
! -- ******************************************************************
!  Typeahead buffer address
macro UCB$L_TT_TYPAHD = 352,0,32,1 %;   !  TYPEAHEAD BUFFER ADDRESS
!  CURRENT CURSOR AND LINE POSITION FOR FORMATTED OPERATIONS
macro UCB$W_TT_CURSOR = 356,0,16,0 %;   !  CURRENT CURSOR POSITION
macro UCB$B_TT_LINE = 358,0,8,0 %;      !  CURRENT LINE ON PAGE
macro UCB$B_TT_LASTC = 359,0,8,0 %;     !  LAST FORMATTED OUTPUT CHARACTER
!  Number of back spaces to output for non-ansi terminals
macro UCB$W_TT_BSPLEN = 360,0,16,0 %;   !  NUMBER OF BACKSPACES
!  FILL HANDLING
macro UCB$B_TT_FILL = 362,0,8,0 %;      !  CURRENT FILL COUNT
!  ESCAPE SYNTAX RULE STATE.
macro UCB$B_TT_ESC = 363,0,8,0 %;       !  CURRENT  READ ESCAPE SYNTAX STATE
macro UCB$B_TT_ESC_O = 364,0,8,0 %;     !  OUPUT ESCAPE STATE
!  Count of characters in interrupt string
macro UCB$B_TT_INTCNT = 365,0,8,0 %;
!  Bit used for modem control
macro UCB$W_TT_UNITBIT = 366,0,16,0 %;  !  BIT USED TO ENABLE AND DISABLE MODEM CONTROL.
!  PORT SPECIFIC OUTPUT CONTROL
macro UCB$W_TT_HOLD = 368,0,16,0 %;     !  UNIT HOLDING TANK AND PORT DISPATCH
macro TTY$B_TANK_CHAR = 368,0,8,0 %;    !  CHARACTER
macro TTY$V_TANK_PREMPT = 368,8,1,0 %;  !  SEND PREMPT CHARACTER
macro TTY$V_TANK_STOP = 368,9,1,0 %;    !  STOP OUTPUT
macro TTY$V_TANK_HOLD = 368,10,1,0 %;   !  CHAR IN TANK
macro TTY$V_TANK_BURST = 368,11,1,0 %;  !  BURST ACTIVE
macro TTY$V_TANK_DMA = 368,12,1,0 %;    !  DMA ACTIVE **** SHOULD MOVE BEFORE BURST ****
macro UCB$B_TT_PREMPT = 370,0,8,0 %;    !  THE BYTE USED TO PREMPT INPUT
macro UCB$B_TT_OUTYPE = 371,0,8,1 %;    !  TYPE OF OUTPUT THAT THIS CALL
!  CLASS & PORT VECTOR POINTERS
macro UCB$L_TT_GETNXT = 372,0,32,1 %;   !  ADDRESS OF CLASS INPUT ROUTINE
macro UCB$L_TT_PUTNXT = 376,0,32,1 %;   !  ADDRESS OF CLASS OUTPUT ROUTINE
macro UCB$L_TT_CLASS = 380,0,32,1 %;    !  ADDRESS OF CLASS VECTOR
macro UCB$L_TT_PORT = 384,0,32,1 %;     !  ADDRESS OF PORT VECTOR
macro UCB$L_TT_OUTADR = 388,0,32,1 %;   !  ADDRESS OF OUTPUT  CURRENT STREAM
macro UCB$W_TT_OUTLEN = 392,0,16,0 %;   !  LENGTH OF OUTPUT STREAM
macro UCB$W_TT_PRTCTL = 394,0,16,0 %;   !  THE PORT DRIVER CONTROL WORD
macro TTY$V_PC_NOTIME = 394,0,1,0 %;    !  IF SET NO TIMEOUT WILL BE CALCULATED
macro TTY$V_PC_DMAENA = 394,1,1,0 %;    !  DMA CURRENTLY ENABLED 
macro TTY$V_PC_DMAAVL = 394,2,1,0 %;    !  DMA SUPPORTED ON THIS PORT
macro TTY$V_PC_PRMMAP = 394,3,1,0 %;    !  UNIT CAN HAVE PERMANENT MAP REGISTERS
macro TTY$V_PC_MAPAVL = 394,4,1,0 %;    !  MAP REGISTER CURRENTLY ALLOCATED
macro TTY$V_PC_XOFAVL = 394,5,1,0 %;    !  AUTO XOFF SUPPORTED ON THIS PORT
macro TTY$V_PC_XOFENA = 394,6,1,0 %;    !  AUTO XOFF CURRENTLY ENABLED 
macro TTY$V_PC_NOCRLF = 394,7,1,0 %;    !  don't do free linefeed after creturn
macro TTY$V_PC_BREAK = 394,8,1,0 %;     !  TURN ON OR OFF BREAK
macro TTY$V_PC_PORTFDT = 394,9,1,0 %;   !  PORT CONTAINS FDT ROUTINE
macro TTY$V_PC_NOMODEM = 394,10,1,0 %;  !  Port cannot support modem operations
macro TTY$V_PC_NODISCONNECT = 394,11,1,0 %; !  Device cannot support virtual terminal operations
macro TTY$V_PC_SMART_READ = 394,12,1,0 %; !  Port contains additional read capabilities
macro TTY$V_PC_ACCPORNAM = 394,13,1,0 %; !  Port supports access port name
macro TTY$V_PC_MULTISESSION = 394,15,1,0 %; !  part of multi-session terminal
!  MODEM CONTROL DEFINITIONS
macro UCB$L_TT_DS_ST = 396,0,32,0 %;    !  CURRENT MODEM STATE
macro UCB$B_TT_DS_RCV = 400,0,8,0 %;    !  CURRENT RECEIVE MODEM
macro UCB$B_TT_DS_TX = 401,0,8,0 %;     !  CURRENT TRANSMIT MODEM
macro UCB$W_TT_DS_TIM = 402,0,16,0 %;   !  CURRENT MODEM TIMEOUT
macro UCB$B_TT_MAINT = 404,0,8,0 %;     !  MAINTENANCE PARAMETERS
macro UCB$V_TT_MAINT_FILL = 404,0,7,0 %;
literal UCB$S_TT_MAINT_FILL = 7;
macro UCB$V_TT_DSBL = 404,7,1,0 %;      !  LINE DISABLED
macro UCB$B_TT_OLDCPZORG = 405,0,8,0 %; !  spare byte make this longword alligned
macro UCB$W_TT_FILLRUP = 406,0,16,0 %;  !  FILL to align next
macro UCB$L_TT_FBK = 408,0,32,1 %;      !  PTR TO FALLBACK BLOCK
macro UCB$L_TT_RDVERIFY = 412,0,32,1 %; !  PTR TO READ/VERIFY TABLE
macro UCB$L_TT_CLASS1 = 416,0,32,0 %;   !  CLASS DRIVER LONGWORD
macro UCB$L_TT_CLASS2 = 420,0,32,0 %;   !   AND ANOTHER ONE
macro UCB$L_TT_ACCPORNAM = 424,0,32,1 %; !  Address of counted string describing the port 
!  typicall LAT server name / and port name or number
! *****************************************************************************
! 
!  Asian VMS extension
! 
! ++ **************************************************************************
macro UCB$L_TT_A_GCBADR = 428,0,32,1 %; !  Glyph Control Block address
macro UCB$W_TT_A_EDSTS = 432,0,16,0 %;  !  Multi-byte line edit states
macro UCB$B_TT_A_STATE = 434,0,8,0 %;   !  On-demand loading states
macro UCB$B_TT_A_PARSE = 435,0,8,0 %;   !  ODL parse states
macro UCB$B_TT_A_TRANS = 436,0,8,0 %;   !  JIS conversion states
macro UCB$B_TT_A_XEDSTS = 437,0,8,0 %;  !  Extended line edit states
macro UCB$W_TT_A_RESRV1 = 438,0,16,0 %; !  Reserved
macro UCB$B_TT_A_CHAR = 440,0,8,0 %;    !  Default Asian modes
macro UCB$L_TT_A_DECHSET = 440,0,32,0 %; !  Default char set bitmask
literal UCB$C_TT_CLSLEN = 444;
literal UCB$K_TT_CLSLEN = 444;
literal TTY$M_TP_ABORT = %X'1';
literal TTY$M_TP_ALLOC = %X'2';
literal TTY$M_TP_DLLOC = %X'4';
literal UCB$S_TPD_UCB = 452;
! 
! 
!  Terminal Port driver dependant extension region
! 
! 
macro UCB$L_TP_MAP = 444,0,32,1 %;      !  UNIBUS MAP REGISTERS
macro UCB$B_TP_STAT = 448,0,8,0 %;      !  DMA PORT SPECIFIC STATUS
macro TTY$V_TP_ABORT = 448,0,1,0 %;     !  DMA ABORT REQUESTED ON THIS LINE
macro TTY$V_TP_ALLOC = 448,1,1,0 %;     !  ALLOC MAP FORK IN PROGRESS
macro TTY$V_TP_DLLOC = 448,2,1,0 %;     !  DEALLOCATE MAP FORK IN PROGRESS
macro UCB$B_TP_SPARE1 = 449,0,8,0 %;
macro UCB$W_TP_SPARE2 = 450,0,16,0 %;
literal UCB$C_TP_LENGTH = 452;
literal UCB$K_TP_LENGTH = 452;
literal UCB$C_TT_LENGTH = 452;
literal UCB$K_TT_LENGTH = 452;
!  TERMINAL DRIVER SX STATE TABLE
!  (NOTE: Any changes made to this state table must also be made to
!         the ST state table.)
literal TTY$M_SX_LOSTCTS = %X'4';
literal TTY$M_SX_POSIXSTALL = %X'10';
literal TTY$S_SX_STATE = 460;
macro TTY$R_TT_STATE_SX = 452,0,0,0 %;
literal TTY$S_TT_STATE_SX = 8;
macro TTY$V_SX_POWER = 452,0,1,0 %;     ! 	
macro TTY$V_SX_CTRLS = 452,1,1,0 %;     ! 
macro TTY$V_SX_LOSTCTS = 452,2,1,0 %;   !  Reserved for future work
macro TTY$V_SX_MODEM_OFF = 452,3,1,0 %; ! 
macro TTY$V_SX_POSIXSTALL = 452,4,1,0 %; !  POSIX timed output wait
macro TTY$V_SX_FILL = 452,5,1,0 %;      ! 
macro TTY$V_SX_CURSOR = 452,6,1,0 %;    ! 
macro TTY$V_SX_SENDLF = 452,7,1,0 %;    ! 
macro TTY$V_SX_BACKSPACE = 452,8,1,0 %; !  OUTPUT BACKSPACES FOR SEVERAL LOOPS
macro TTY$V_SX_MULTI = 452,9,1,0 %;     ! 
macro TTY$V_SX_WRITE = 452,10,1,0 %;    !  Write state
macro TTY$V_SX_POSIXWRITE = 452,11,1,0 %; !  POSIX Write state
macro TTY$V_SX_EOL = 452,12,1,0 %;      ! 
macro TTY$V_SX_EDITREAD = 452,13,1,0 %; ! 
macro TTY$V_SX_RDVERIFY = 452,14,1,0 %; ! 
macro TTY$V_SX_RECALL = 452,15,1,0 %;   ! 
macro TTY$V_SX_READ = 452,16,1,0 %;     ! 
macro TTY$V_SX_POSIXREAD = 452,17,1,0 %; ! 
macro TTY$V_SX_FILLBITS = 452,18,14,0 %;
literal TTY$S_SX_FILLBITS = 14;         !  END OF FIRST LONGWORD
macro TTY$V_SX_CTRLO = 456,0,1,0 %;     ! 
macro TTY$V_SX_DEL = 456,1,1,0 %;       ! 
macro TTY$V_SX_PASALL = 456,2,1,0 %;    ! 
macro TTY$V_SX_NOECHO = 456,3,1,0 %;    ! 
macro TTY$V_SX_WRTALL = 456,4,1,0 %;    ! 
macro TTY$V_SX_PROMPT = 456,5,1,0 %;    ! 
macro TTY$V_SX_NOFLTR = 456,6,1,0 %;    ! 
macro TTY$V_SX_ESC = 456,7,1,0 %;       ! 
macro TTY$V_SX_BADESC = 456,8,1,0 %;    ! 
macro TTY$V_SX_NL = 456,9,1,0 %;        !  New line must directly precede
macro TTY$V_SX_REFRSH = 456,10,1,0 %;   !  refresh, or all breaks.
macro TTY$V_SX_ESCAPE = 456,11,1,0 %;   ! 
macro TTY$V_SX_TYPFUL = 456,12,1,0 %;   ! 
macro TTY$V_SX_SKIPLF = 456,13,1,0 %;   ! 
macro TTY$V_SX_ESC_O = 456,14,1,0 %;    ! 
macro TTY$V_SX_WRAP = 456,15,1,0 %;     ! 
macro TTY$V_SX_OVRFLO = 456,16,1,0 %;   ! 
macro TTY$V_SX_AUTOP = 456,17,1,0 %;    ! 
macro TTY$V_SX_CTRLR = 456,18,1,0 %;    ! 
macro TTY$V_SX_SKIPCRLF = 456,19,1,0 %; ! 
macro TTY$V_SX_EDITING = 456,20,1,0 %;  ! 
macro TTY$V_SX_TABEXPAND = 456,21,1,0 %; ! 
macro TTY$V_SX_QUOTING = 456,22,1,0 %;  ! 
macro TTY$V_SX_OVERSTRIKE = 456,23,1,0 %; ! 
macro TTY$V_SX_TERMNORM = 456,24,1,0 %; ! 
macro TTY$V_SX_ECHAES = 456,25,1,0 %;   ! 
macro TTY$V_SX_PRE = 456,26,1,0 %;      ! 
macro TTY$V_SX_NINTMULTI = 456,27,1,0 %; ! 
macro TTY$V_SX_RECONNECT = 456,28,1,0 %; ! 
macro TTY$V_SX_CTSLOW = 456,29,1,0 %;   ! 
macro TTY$V_SX_TABRIGHT = 456,30,1,0 %; ! 
literal TTY$S_TTYUCB = 188;             !  Old size name
literal TTY$S_TTYRTTUCB = 188;          !  Old size name
literal TTY$S_TTYUCBDEF = 460;          !  Old size name, synonym for  TTYUCB$S_TTYUCB
literal FLG$M_CTRLO = %X'1';
literal FLG$M_CANCTRLO = %X'2';
literal FLG$M_VAXTOVAX = %X'4';
literal FLG$M_CTRLC = %X'8';
literal FLG$M_INIT = %X'10';
literal FLG$M_RESET_TIMER = %X'20';
literal FLG$M_DECNET_BUSY = %X'40';
literal FLG$M_OUTPUT_BUSY = %X'80';
literal FLG$M_READ_BUSY = %X'100';
literal FLG$M_SENSE_BUSY = %X'200';
literal FLG$M_OOB_CHAR = %X'400';
literal FLG$M_FLUSH_OUTPUT = %X'800';
literal FLG$M_CLR_NOBRDCST = %X'1000';
literal FLG$M_READ_ABORT = %X'2000';
literal FLG$M_READ_ABORTED = %X'4000';
literal FLG$M_ISUPPORT = %X'8000';
literal FLG$M_PARTIAL_READ = %X'10000';
literal UCB$S_RTT_UCB = 408;
! 
!  remote terminal extension
! 
macro UCB$R_RTTUCB = 272,0,0,0 %;
literal UCB$S_RTTUCB = 136;
macro UCB$L_RTT_NETUCB = 272,0,32,1 %;  !  NET DEVICE UCB
macro UCB$L_RTT_NETWIND = 276,0,32,1 %; !  NET DEVICE WCB
macro UCB$L_RTT_IRPFL = 280,0,32,1 %;   !  IRP QUEUE
macro UCB$L_RTT_IRPBL = 284,0,32,1 %;   !  IRP QUEUE
macro UCB$L_RTT_NETIRP = 288,0,32,1 %;  !  READ NET IIRP
macro UCB$L_RTT_BANDINCL = 292,0,32,1 %; !  OUT OF BAND INCLUDES
macro UCB$L_RTT_BANDINMSK = 296,0,32,0 %; !  OUT OF BAND INCLUDE MASK
macro UCB$L_RTT_BANDEXCL = 300,0,32,0 %; !  out of band exclude mask
macro UCB$L_RTT_BANDEXMSK = 304,0,32,0 %; !  out of band exclude
macro UCB$B_RTT_PROVRS = 308,0,8,0 %;   !  PROTOCOL VERSION
macro UCB$B_RTT_PROECO = 309,0,8,0 %;   !  PROTOCOL ECO
macro UCB$W_RTT_LINK = 310,0,16,0 %;    !  LINK NUMBER (for LOGINOUT)
macro UCB$B_RTT_OBJ = 312,0,8,0 %;      !  OBJECT NUMBER CONNECTED
macro UCB$W_RTT_SYSTYPE = 313,0,16,0 %; !  SYSTEM TYPE (VMS=7)
macro UCB$B_RTT_FILLBYTE = 315,0,8,0 %; !  fill - use when convenient
! 	CTERM driver only
macro UCB$L_CT_FLAGS = 316,0,32,0 %;    !  MISC FLAGS
macro FLG$V_CTRLO = 316,0,1,0 %;        !  CTRLO IN PROGRESS
macro FLG$V_CANCTRLO = 316,1,1,0 %;     !  CANCEL CTRLO ON WRITE
macro FLG$V_VAXTOVAX = 316,2,1,0 %;     !  VAX TO VAX
macro FLG$V_CTRLC = 316,3,1,0 %;        !  CTRL/C DELIVERED
macro FLG$V_INIT = 316,4,1,0 %;         !  AWAITING FIRST WRITE
macro FLG$V_RESET_TIMER = 316,5,1,0 %;  !  Restart timer due to write.
macro FLG$V_DECNET_BUSY = 316,6,1,0 %;  !  DECnet Output task busy.
macro FLG$V_OUTPUT_BUSY = 316,7,1,0 %;  !  Output task busy.
macro FLG$V_READ_BUSY = 316,8,1,0 %;    !  Read task busy.
macro FLG$V_SENSE_BUSY = 316,9,1,0 %;   !  Sense task busy.
macro FLG$V_OOB_CHAR = 316,10,1,0 %;    !  Process OOB character later.
macro FLG$V_FLUSH_OUTPUT = 316,11,1,0 %; !  Flush output for out-of-band abort.
macro FLG$V_CLR_NOBRDCST = 316,12,1,0 %; !  Don't broadcast until after first write.
macro FLG$V_READ_ABORT = 316,13,1,0 %;  !  Read abort in progress.
macro FLG$V_READ_ABORTED = 316,14,1,0 %; !  Read has already been aborted.
macro FLG$V_ISUPPORT = 316,15,1,0 %;    !  Support of ISUPPORT msg
macro FLG$V_PARTIAL_READ = 316,16,1,0 %; !  Partial read in progress
macro UCB$L_CT_WIIRP = 320,0,32,1 %;    !  WRITE IIRP
macro UCB$L_CT_TQE = 324,0,32,1 %;      !  TQE ADDRESS
macro UCB$L_CT_NETQFL = 328,0,32,1 %;   !  Queue of DCB's waiting 
macro UCB$L_CT_NETQBL = 332,0,32,1 %;   !    for write IRP
macro UCB$L_CT_SENSEQFL = 336,0,32,1 %; !  Queue for pending 
macro UCB$L_CT_SENSEQBL = 340,0,32,1 %; !    IO$_SENSExxxx IRPs.
macro UCB$L_CT_READQFL = 344,0,32,1 %;  !  Queue for pending
macro UCB$L_CT_READQBL = 348,0,32,1 %;  !    read IRPs.
macro UCB$L_CT_WRTDCB = 352,0,32,1 %;   !  First DCB in current write chain.
macro UCB$L_CT_CURDCB = 356,0,32,1 %;   !  Last DCB added to write chain.
macro UCB$W_CT_REMSIZ = 360,0,16,0 %;   !  Remaining size in message.
macro UCB$W_CT_QDCBCNT = 362,0,16,1 %;  !  Number of queued DCBs.
macro UCB$W_CT_MAXMSG = 364,0,16,0 %;   !  MAX WRITE TO NET SIZE
macro UCB$W_CT_MAXREAD = 366,0,16,0 %;  !  MAX READ IN SERVER
macro UCB$L_CT_LEGALMSG = 368,0,32,0 %; !  LEGAL MESSAGE MASK
macro UCB$B_CT_VERSION = 372,0,8,0 %;   !  CTERM VERSION
macro UCB$B_CT_ECO = 373,0,8,0 %;       !  CTERM ECO
macro UCB$W_CT_SPEED = 374,0,16,0 %;    !  SPEED 
macro UCB$B_CT_CRFILL = 376,0,8,0 %;    !  CR FILL
macro UCB$B_CT_LFFILL = 377,0,8,0 %;    !  LF FILL
macro UCB$W_CT_PARITY = 378,0,16,0 %;   !  CTERM PARITY
macro UCB$L_CT_INCLUDE = 380,0,32,0 %;  !  INCLUDE OUT-OF-BAND CHARACTER MASK
macro UCB$L_CT_EXCLUDE = 384,0,32,0 %;  !  EXCLUDE OUT-OF-BAND CHARACTER MASK
macro UCB$L_CT_ABORT = 388,0,32,0 %;    !  ABORT OUT-OF-BAND CHARACTER MASK
macro UCB$B_CT_OOB_CHAR = 392,0,8,0 %;  !  Received out of band character.
macro UCB$B_CT_FILL_BYTE = 393,0,8,0 %; !  fill
macro UCB$W_CT_PRTCTL = 394,0,16,0 %;   !  Same as UCB$W_TT_PRTCTL
macro UCB$Q_CT_ISUPPORT = 396,0,0,0 %;
literal UCB$S_CT_ISUPPORT = 8;          !  Messages supported
macro UCB$L_CT_FILL_LONGWORD = 404,0,32,0 %; !  fill
literal UCB$C_RTT_LENGTH = 408;         !  Length must be same for both RTTDRIVER
literal UCB$K_RTT_LENGTH = 408;         !  and CTDRIVER.
 
!*** MODULE $FTUCBDEF ***
! 
! 	$FTUCBDEF follows here only because there is no way to get the  the
!  UCB$K_TT_LENGTH into another module.
! 
! 	Pseudo Terminal Driver definitions
! 
! 	These definitions define the device dependent extenstions of the TTYUCB. 
!  Certain portions of the UCB are assumed to be contigious and must not be
!  split.  The AST list heads are order and must remain in order $PTDDEF in
!  STARDEFMP.SDL is in the same order.
! 
literal UCB$M_FT_BSY = %X'1';
literal UCB$M_FT_DELPEND = %X'2';
literal UCB$M_FT_DELETE_ACT = %X'4';
literal UCB$M_FT_INPUT_CRIT = %X'8';
literal UCB$C_FT_LENGTH = 528;          !  Size of FT UCB
literal UCB$K_FT_LENGTH = 528;          !   "   "   "  "
literal UCB$S_FT_UCB = 528;
macro UCB$L_FT_IPID = 444,0,32,0 %;     !  Interal PID of UCB control process
macro UCB$L_FT_1ST_PAGE = 448,0,32,1 %; !  P0/P1 address of first page of I/O buffer
macro UCB$L_FT_LST_PAGE = 452,0,32,1 %; !  P0/P1 address of end of the I/O buffer
macro UCB$L_FT_S0_PAGE = 456,0,32,1 %;  !  S0 address of first page that maps I/O buffer
macro UCB$Q_FT_BUFFER_HANDLE = 460,0,0,0 %;
literal UCB$S_FT_BUFFER_HANDLE = 8;     !  Pointer to buffer handle used by buffer object code
! 
!  Driver private state information
! 
macro UCB$W_FT_STS = 468,0,16,0 %;      !  Driver private status word
macro UCB$V_FT_BSY = 468,0,1,0 %;       !  Read request pending
macro UCB$V_FT_DELPEND = 468,1,1,0 %;   !  It is safe to queue deletion fork
macro UCB$V_FT_DELETE_ACT = 468,2,1,0 %; !  Deletion fork queued
macro UCB$V_FT_INPUT_CRIT = 468,3,1,0 %; !  Type ahead buffer running out or out of space
macro UCB$W_FT_CHAN = 470,0,16,0 %;     !  Control applications channel number
macro UCB$L_FT_READQFL = 472,0,32,1 %;  !  Read requests queue forward link
macro UCB$L_FT_READQBL = 476,0,32,1 %;  !  Read requests queue backward link
macro UCB$L_FT_CURR_READ = 480,0,32,1 %; !  Currend read request packet address
! 
!  AST list head this must remain in order and should not be changed.
! 
!  The AST list head is overlaid and becomes the fork block used to delete the
!  UCB when the control connection deassigns it's channel.  This is safe becuase
!  once the control connection channel is deleted it is impossible to enable one
!  of these ASTs.
! 
macro UCB$R_FT_DELETE_FORK = 484,0,0,0 %;
literal UCB$S_FT_DELETE_FORK = 44;
macro UCB$R_FTUCB = 484,0,0,0 %;
literal UCB$S_FTUCB = 44;
macro UCB$L_FT_HANGUP_AST = 484,0,32,1 %; !  Address of hangup template ACB
macro UCB$L_FT_XON_AST = 488,0,32,1 %;  !  Address of XON template ACB
macro UCB$L_FT_BELL_AST = 492,0,32,1 %; !  Address of BELL template ACB
macro UCB$L_FT_DC3_AST = 496,0,32,1 %;  !  Address of DC3 template ACB
macro UCB$L_FT_STOP_AST = 500,0,32,1 %; !  Address of stop output template ACB
macro UCB$L_FT_RESUME_AST = 504,0,32,1 %; !  Address of resume output template ACB
macro UCB$L_FT_SET_AST = 508,0,32,1 %;  !  Address of changed characteristics template ACB
macro UCB$L_FT_ABORT_AST = 512,0,32,1 %; !  Address of abort output template ACB
macro UCB$L_FT_START_READ_AST = 516,0,32,1 %; !  Address of start read template ACB
macro UCB$L_FT_MIDDLE_READ_AST = 520,0,32,1 %; !  Address of middle read template ACB
macro UCB$L_FT_END_READ_AST = 524,0,32,1 %; !  Address of end read template ACB
macro UCB$R_FT_FORK_OVERLAY = 484,0,0,0 %;
macro UCB$L_FT_FQFL = 484,0,32,1 %;     !  Fork queue forward link
macro UCB$L_FT_FQBL = 488,0,32,1 %;     !  Fork queue backward link
macro UCB$W_FT_FRKSIZE = 492,0,16,0 %;  !  Size of the fork block
macro UCB$B_FT_FRK_TYPE = 494,0,8,0 %;  !  Type of structure
macro UCB$B_FT_FLCK = 495,0,8,0 %;      !  Fork lock index
macro UCB$L_FT_FPC = 496,0,32,1 %;      !  Fork PC this points device deletion routine
macro UCB$Q_FT_FR3 = 500,0,0,1 %;
literal UCB$S_FT_FR3 = 8;               !  R3 will be 0
macro UCB$Q_FT_FR4 = 508,0,0,1 %;
literal UCB$S_FT_FR4 = 8;               !  UCB address
!  End Union
literal UCB$S_FTUCBDEF = 528;           !  Old size name, synonym for  UCB$S_FT_UCB
 
!*** MODULE $UQBDEF ***
! +
!  UQB  (Unit Queue Block)  Definitions -- MSCP Server, TMSCP Server
! 
! 	This data structure has all the information pertaining
! 	to a unit that is currently being served. It is most used
! 	for the list head of all requests for this unit.
! -
literal UQB$M_SEQ = %X'1';
literal UQB$M_WRTPH = %X'2';
literal UQB$M_WRTPS = %X'4';
literal UQB$M_ONLINE = %X'8';
literal UQB$M_FLUSH = %X'10';
literal UQB$M_C = %X'1F';
literal UQB$M_D1 = %X'3E0';
literal UQB$M_D0 = %X'7C00';
literal UQB$K_ST_ONLINE = 2;            !   Unit is online to some host
literal UQB$K_ST_OFFLINE = 3;           !   Unit is offline
literal UQB$K_ST_AVAILABLE = 4;         !   Unit is available
literal UQB$S_UQB = 112;
macro UQB$L_FLINK = 0,0,32,1 %;         !  Used to link together all
macro UQB$L_BLINK = 4,0,32,1 %;         !    UQBs being served 
macro UQB$W_SIZE = 8,0,16,0 %;          !  Structure size in bytes
macro UQB$B_TYPE = 10,0,8,0 %;          !  MSCP type structure
macro UQB$B_SUBTYPE = 11,0,8,0 %;       !   with a UQB subtype       (5)
macro UQB$W_STATE = 12,0,16,0 %;        !  Current state of this unit
macro UQB$W_FLAGS = 14,0,16,0 %;        !  Unit usage
macro UQB$V_SEQ = 14,0,1,0 %;           !  Sequential command executing
macro UQB$V_WRTPH = 14,1,1,0 %;         !  Unit is writelocked
macro UQB$V_WRTPS = 14,2,1,0 %;         !  Unit was mounted /NOWRITE
macro UQB$V_ONLINE = 14,3,1,0 %;        !  Unit is ONLINE.
macro UQB$V_FLUSH = 14,4,1,0 %;         !  Per-unit cache is being flushed
macro UQB$W_OLD_UNIT = 16,0,16,0 %;     !  "Old Style" unit number
macro UQB$W_CURRENT = 18,0,16,0 %;      !  Commands active on this unit
macro UQB$W_MULT_UNIT = 20,0,16,0 %;    !  This information is set up
macro UQB$W_UNIT_FLAGS = 22,0,16,0 %;   !   in ADDUNIT when the device
macro UQB$Q_UNIT_ID = 24,0,0,0 %;
literal UQB$S_UNIT_ID = 8;              !   is set /SERVED.
macro UQB$L_ALLOCLS = 24,0,32,0 %;      !  The unit identifier is made up 
macro UQB$W_UNIT = 28,0,16,0 %;         !   of the allocation class, the 
macro UQB$W_DEVNAME = 30,0,16,0 %;      !   
macro UQB$V_C = 30,0,5,0 %;
literal UQB$S_C = 5;                    !   UCB unit number, the controller 
macro UQB$V_D1 = 30,5,5,0 %;
literal UQB$S_D1 = 5;                   !   letter, and the D1 D0 fields 
macro UQB$V_D0 = 30,10,5,0 %;
literal UQB$S_D0 = 5;                   !   from the media ID field
macro UQB$l_reserved = 32,0,32,0 %;     !   
macro UQB$L_UCB = 36,0,32,1 %;          !  UCB address for this unit
macro UQB$W_NUM_QUE = 40,0,16,0 %;      !  Host requests pending
macro UQB$W_MAX_QUE = 42,0,16,0 %;      !  Most requests ever pending
macro UQB$L_BLOCKED_FL = 44,0,32,1 %;   !  List head for HRBs pending
macro UQB$L_BLOCKED_BL = 48,0,32,1 %;   !   sequential cmd completion
macro UQB$B_ONLINE = 52,0,0,0 %;
literal UQB$S_ONLINE = 32;              !  Array of hosts with unit online 
macro UQB$L_EXTRA_IO = 84,0,32,0 %;     !  Splinter requests
macro UQB$L_IOCNT = 88,0,32,0 %;        !  Server contribution to total
macro UQB$W_QLEN = 92,0,16,0 %;         !  Server queue length for unit
macro UQB$W_SLUN = 94,0,16,0 %;         !  Server local unit number
!  max chars in Cluster unique
!    device name ( dependency in
!    PEDRIVER's PEM_DEF.SDL)
macro UQB$B_UNIQUE_DNAME_CNT = 96,0,8,0 %; !  .ASCIC string with
macro UQB$T_UNIQUE_DNAME = 97,0,0,0 %;
literal UQB$S_UNIQUE_DNAME = 15;        !   Cluster unique name for disk
!   unit (obtained VIA GETDVI
!   ALLDEVNAM item)
!  Unit state definitions
literal UQB$M_ST_BOT = %X'1';
literal UQB$M_ST_DLS = %X'2';
literal UQB$M_ST_EOT = %X'4';
literal UQB$M_ST_LEOT = %X'8';
literal UQB$M_ST_PLS = %X'10';
literal UQB$M_ST_SEREX = %X'20';
literal UQB$M_ST_WRTPH = %X'40';
literal UQB$S_TSRV_EXTENSION = 208;
macro UQB$L_ONLINE_HQB = 112,0,32,1 %;  !  Unit is excl. onl. to this host.
macro UQB$L_MEMW_TOT = 116,0,32,0 %;    !  Number of I/Os that had to wait.
macro UQB$L_MEMW_FL = 120,0,32,1 %;     !  Queue listhead for requests
macro UQB$L_MEMW_BL = 124,0,32,1 %;     !   in memory wait state.
macro UQB$W_MEMW_CNT = 128,0,16,0 %;    !  Current memory stalls.
macro UQB$W_MEMW_MAX = 130,0,16,0 %;    !  Most requests ever in MEMWAIT
macro UQB$L_CACHE_FL = 132,0,32,1 %;    !  Queue listhead for requests
macro UQB$L_CACHE_BL = 136,0,32,1 %;    !   in server cache.
macro UQB$W_NUM_CACHE = 140,0,16,0 %;   !  Number of requests in cache.
macro UQB$W_MAX_CACHE = 142,0,16,0 %;   !  Max ever cached
macro UQB$L_FREELIST_FL = 144,0,32,1 %; !  Queue listhead for available
macro UQB$L_FREELIST_BL = 148,0,32,1 %; !   local buffers
macro UQB$W_BUFF_AVAIL = 152,0,16,0 %;  !  Number of free buffers
macro UQB$W_MAX_BUFF_AVAIL = 154,0,16,0 %; !  Max ever of free buffers
macro UQB$W_BUFF_ALLOC = 156,0,16,0 %;  !  Number of allocated buffers
macro UQB$W_MAX_BUFF_ALLOC = 158,0,16,0 %; !  Max number of buffers alloc.
macro UQB$L_SERV_RSPID = 160,0,32,0 %;  !  Last RSPID checked in GCS
macro UQB$L_CLASS_RSPID = 164,0,32,0 %; !  Last class driver RSPID
macro UQB$L_OLD_CLSSTS = 168,0,32,0 %;  !  Class driver command status.
macro UQB$W_TAPEM_SKIP = 172,0,16,0 %;  !  Storage for REPOS. OBJECT
macro UQB$W_RECORD_SKIP = 174,0,16,0 %; !  Storage for REPOS. OBJECT
macro UQB$L_STARTSTOP = 176,0,32,0 %;   !  Start/stop time for drive
macro UQB$L_IO_TIME = 180,0,32,0 %;     !  Cycle time of IO to local drive
macro UQB$W_NUM_IO = 184,0,16,0 %;      !  Number of IOs issued to drive
macro UQB$W_MAX_IO = 186,0,16,0 %;      !  Max num of IOs outstanding to
!   to drive
macro UQB$L_ARR_TIME = 188,0,32,0 %;    !  Average time it takes the host
!  to respond to a request and
!  send the next request out.
macro UQB$W_NUM_FLUSH = 192,0,16,0 %;   !  Number of flush commands.
macro UQB$W_MAX_NUM_FLUSH = 194,0,16,0 %; !  Max number of flush commands.
macro UQB$L_POSITION = 196,0,32,0 %;    !  Unit's current position
macro UQB$W_ST_FLAGS = 200,0,16,0 %;    !  Unit usage
macro UQB$V_ST_BOT = 200,0,1,0 %;       !  BOT
macro UQB$V_ST_DLS = 200,1,1,0 %;       !  Cached data lost
macro UQB$V_ST_EOT = 200,2,1,0 %;       !  End of tape
macro UQB$V_ST_LEOT = 200,3,1,0 %;      !  Logical end of tape
macro UQB$V_ST_PLS = 200,4,1,0 %;       !  Position lost
macro UQB$V_ST_SEREX = 200,5,1,0 %;     !  Serious exception state
macro UQB$V_ST_WRTPH = 200,6,1,0 %;     !  Write protected
literal UQB$C_LENGTH = 208;
literal UQB$K_LENGTH = 208;
 
!*** MODULE $VADEF ***
! +
!  VIRTUAL ADDRESS VIELDS
! -
literal VA$M_P1 = %X'40000000';
literal VA$M_SYSTEM = %X'80000000';
literal VA$M_BYTES_PER_PAGELET = %X'1FF';
literal VA$S_VADEF = 4;
literal VA$S_VA = 4;
macro VA$V_P1 = 0,30,1,0 %;             ! P1 SPACE 
macro VA$V_SYSTEM = 0,31,1,0 %;         ! SYSTEM SPACE 
macro VA$V_BYTES_PER_PAGELET = 0,0,9,0 %;
literal VA$S_BYTES_PER_PAGELET = 9;     ! BYTES PER PAGELET
 
!*** MODULE $VCADEF ***
! +
! 
!  VCA - Volume Cache Block. This block contains the specialized caches for
!  a disk volume; to wit, the file ID cache, the extent cache, and the quota
!  file cache. The file ID cache and extent cache are together in one block;
!  the quota cache is located separately in another block. Both are pointed to
!  by the VCB.
! 
! -
! ***************************************************************************
!   WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! *
! ***************************************************************************
!  If you add/remove fields *before* SER_QFL then be sure to realign SER_QFL*
!  to be QUADWORD aligned. The danger area is between *#####                *
!                                                                           *
!  Also, *DO NOT* insert any fields between SER_QFL and SER_QBL             *
!                                                                           *
! ***************************************************************************
!   WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! *
! ***************************************************************************
literal VCA$M_FIDC_VALID = %X'1';
literal VCA$M_EXTC_VALID = %X'2';
literal VCA$M_FIDC_FLUSH = %X'4';
literal VCA$M_EXTC_FLUSH = %X'8';
literal VCA$C_QUEUE = 16;               !  Offset of queue header
literal VCA$K_LENGTH = 24;              !  length of block header 
literal VCA$C_LENGTH = 24;              !  length of block header 
literal VCA$S_VCADEF = 24;              !  Old size name - synonym
! 
literal VCA$S_VCA = 24;
! 
!  Be careful between here..........
!  ##################################################
! 
macro VCA$L_FIDCACHE = 0,0,32,1 %;      !  pointer to file ID cache 
macro VCA$L_EXTCACHE = 4,0,32,1 %;      !  pointer to extent cache 
macro VCA$W_SIZE = 8,0,16,0 %;          !  block size
macro VCA$B_TYPE = 10,0,8,0 %;          !  block type code 
macro VCA$B_FLAGS = 11,0,8,1 %;         !  cache flags
macro VCA$V_FIDC_VALID = 11,0,1,0 %;    !  FID cache valid
macro VCA$V_EXTC_VALID = 11,1,1,0 %;    !  Extent cache valid
macro VCA$V_FIDC_FLUSH = 11,2,1,0 %;    !  FID cache to be flushed
macro VCA$V_EXTC_FLUSH = 11,3,1,0 %;    !  Extent cache to be flushed
macro VCA$L_CACHE_SPACE_USED = 12,0,32,1 %; !  Amount of space consumed/released 
macro VCA$L_SER_QFL = 16,0,32,1 %;      !  Extent/FID cache
macro VCA$L_SER_QBL = 20,0,32,1 %;      !  serialization queue header
! 
!  .........and here
!  ##################################################
! 
!  The file ID cache consists of the cache header, followed by a longword
!  vector of file numbers, densely packed.
! 
literal VCA$S_VCADEF1 = 52;             !  Old size name - synonym
literal VCA$S_VCA1 = 52;
macro VCA$L_FIDSIZE = 0,0,32,0 %;       !  number of entries allocated 
macro VCA$L_FIDCOUNT = 4,0,32,0 %;      !  number of entries present 
macro VCA$L_FIDCLKID = 8,0,32,0 %;      !  FID cache lock id.
macro VCA$B_FIDCACB = 12,0,0,0 %;
literal VCA$S_FIDCACB = 36;             !  FID cache blocking ACB
macro VCA$L_FIDLIST = 48,0,32,1 %;      !  first entry in list 
! 
!  The extent cache consists of the cache header, followed by a quadword
!  vector of extents, densely packed. Each quadword contains block count
!  and starting LBN.
! 
literal VCA$S_VCADEF2 = 64;             !  Old size name - synonym
literal VCA$S_VCA2 = 64;
macro VCA$L_EXTSIZE = 0,0,32,0 %;       !  number of entries allocated 
macro VCA$L_EXTCOUNT = 4,0,32,0 %;      !  number of entries present 
macro VCA$L_EXTTOTAL = 8,0,32,0 %;      !  total number of blocks contained in cache 
macro VCA$L_EXTLIMIT = 12,0,32,0 %;     !  limit of volume to be cached, in percent/10 
macro VCA$L_EXTCLKID = 16,0,32,0 %;     !  EXT cache lock id.
macro VCA$B_EXTCACB = 20,0,0,0 %;
literal VCA$S_EXTCACB = 36;             !  Extent cache blocking ACB.
macro VCA$Q_EXTLIST = 56,0,0,0 %;
literal VCA$S_EXTLIST = 8;              !  first entry in list 
literal VCA$S_VCADEF3 = 8;              !  Old size name - synonym
literal VCA$S_VCA3 = 8;
macro VCA$L_EXTBLOCKS = 0,0,32,0 %;     !  number of blocks 
macro VCA$L_EXTLBN = 4,0,32,0 %;        !  starting LBN 
! 
!  The quota cache consists of the cache header, followed by the cache
!  entries. Each cache entry is a block as defined below.
! 
literal VCA$M_CACHEVALID = %X'1';
literal VCA$M_CACHEFLUSH = %X'2';
literal VCA$S_VCADEF4 = 92;             !  Old size name - synonym
literal VCA$S_VCA4 = 92;
macro VCA$L_QUOSIZE = 0,0,32,0 %;       !  number of entries allocated 
macro VCA$L_QUOCLKID = 4,0,32,0 %;      !  whole cache lock ID
macro VCA$B_QUOCFLAGS = 11,0,8,1 %;     !  cache flags
macro VCA$V_CACHEVALID = 11,0,1,0 %;    !  cache is valid
macro VCA$V_CACHEFLUSH = 11,1,1,0 %;    !  cache is to be flushed
macro VCA$L_QUOLRU = 12,0,32,0 %;       !  current LRU counter 
macro VCA$B_QUOACB = 16,0,0,0 %;
literal VCA$S_QUOACB = 36;              !  ACB to deliver blocking AST
macro VCA$B_QUOFLUSHACB = 52,0,0,0 %;
literal VCA$S_QUOFLUSHACB = 36;         !  ACB to deliver cache flush AST
macro VCA$L_QUOLIST = 88,0,32,1 %;      !  start of entries 
literal VCA$M_QUOVALID = %X'1';
literal VCA$M_QUODIRTY = %X'2';
literal VCA$K_QUOLENGTH = 28;           !  length of quota cache entry 
literal VCA$C_QUOLENGTH = 28;           !  length of quota cache entry 
literal VCA$S_VCADEF5 = 28;             !  Old size name - synonym
literal VCA$S_VCA5 = 28;
macro VCA$R_QUOLOCK = 0,0,0,0 %;
literal VCA$S_QUOLOCK = 24;             !  lock status block
macro VCA$W_QUOSTATUS = 0,0,16,0 %;     !  $ENQ status
macro VCA$W_QUOINDEX = 0,0,16,0 %;      !  index in cache of this entry
macro VCA$W_QUOLRUX = 2,0,16,0 %;       !  LRU index for entry 
macro VCA$L_QUOLKID = 4,0,32,0 %;       !  lock ID of cache entry
macro VCA$L_QUORECNUM = 8,0,24,0 %;
literal VCA$S_QUORECNUM = 3;            !  record number 
macro VCA$B_QUOFLAGS = 11,0,8,0 %;      !  flags byte 
macro VCA$V_QUOVALID = 11,0,1,0 %;      !  valid entry is present
macro VCA$V_QUODIRTY = 11,1,1,0 %;      !  dirty flag 
macro VCA$L_USAGE = 12,0,32,0 %;        !  current usage 
macro VCA$L_PERMQUOTA = 16,0,32,0 %;    !  permanent quota 
macro VCA$L_OVERDRAFT = 20,0,32,0 %;    !  overdraft limit 
macro VCA$L_QUOUIC = 24,0,32,0 %;       !  UIC 
 
!*** MODULE $VCBDEF ***
literal VCB$K_MRKLEN = 11;              !  Old size name for Mark length
literal VCB$C_MRKLEN = 11;              !  Old size name for Mark length
literal VCB$M_WRITE_IF = %X'1';
literal VCB$M_WRITE_SM = %X'2';
literal VCB$M_HOMBLKBAD = %X'4';
literal VCB$M_IDXHDRBAD = %X'8';
literal VCB$M_NOALLOC = %X'10';
literal VCB$M_EXTFID = %X'20';
literal VCB$M_GROUP = %X'40';
literal VCB$M_SYSTEM = %X'80';
literal VCB$M_HIGH_SIERRA = %X'1';
literal VCB$M_NOSWITCH = %X'2';
literal VCB$M_DSI = %X'4';
literal VCB$M_XAR = %X'8';
literal VCB$M_UNUSED_1 = %X'10';
literal VCB$M_UNUSED_2 = %X'20';
literal VCB$M_PARTFILE = %X'1';
literal VCB$M_LOGICEOVS = %X'2';
literal VCB$M_WAIMOUVOL = %X'4';
literal VCB$M_WAIREWIND = %X'8';
literal VCB$M_WAIUSRLBL = %X'10';
literal VCB$M_CANCELIO = %X'20';
literal VCB$M_MUSTCLOSE = %X'40';
literal VCB$M_NOWRITE = %X'80';
literal VCB$M_SHADMAST = %X'1';
literal VCB$M_FAILED = %X'2';
literal VCB$M_REBLDNG = %X'8';
literal VCB$M_BLKASTREC = %X'10';
literal VCB$M_MVBEGUN = %X'20';
literal VCB$M_ADDING = %X'40';
literal VCB$M_PACKACKED = %X'80';
literal VCB$K_COMLEN = 40;              !  LENGTH OF COMMON AREA 
literal VCB$C_COMLEN = 40;              !  LENGTH OF COMMON AREA 
literal VCB$S_VCBDEF_COMMON = 40;       !  OLD LENGTH NAME FOR COMPATABILITY	
literal VCB$M_SUBSYSTEM = %X'1';
literal VCB$K_LENGTH = 300;             !  LENGTH OF STANDARD VCB 
literal VCB$C_LENGTH = 300;             !  LENGTH OF STANDARD VCB 
literal VCB$S_VCBDEF_DISKS = 300;       !  Old length name for compatability
literal VCB$M_FILE_ATTRIBUTES = %X'F';
literal VCB$M_FILE_CONTENTS = %X'F0';
literal VCB$C_DEFAULT = 0;              !  use default caching policy
literal VCB$C_WRITETHROUGH = 1;         !  use writethrough caching
literal VCB$C_WRITEBEHIND = 2;          !  use writebehind caching
literal VCB$M_FLUSH_ON_CLOSE = %X'F00';
literal VCB$C_FLUSH = 1;                !  flush file from cache when file closed
literal VCB$C_NOFLUSH = 2;              !  retain file in cache when file closed
literal VCB$M_CACHING_OPTIONS_MBZ = %X'FFFFF000';
literal VCB$K_F64_LEN = 304;            !  length of F64-extended VCB
literal VCB$C_F64_LEN = 304;            !  length of F64-extended VCB
literal VCB$S_VCBDEF_F64 = 304;         !  old length name for compatability
literal VCB$K_SHAD_LEN = 76;            !  Shadow set member VCB length
literal VCB$S_VCBDEF_SHADOW = 76;       !  Old length name for compatability
literal VCB$S_VCBDEF_CDROM = 128;       !  Old size name, synonym for VCB$S_VCB_CDROM
literal VCB$S_VCBDEF2 = 184;            !  Old size name, synonym for VCB$S_VCB_MTAACP
literal VCB$S_VCBDEF3 = 32;             !  OLD LENGTH NAME FOR COMPATABILITY
literal VCB$S_VCB = 304;
macro VCB$L_FCBFL = 0,0,32,1 %;         !  FCB listhead forward link
macro VCB$L_BLOCKFL = 0,0,32,0 %;       !   or - Blocked request listhead forward link
macro VCB$L_MEMQFL = 0,0,32,1 %;        !   or - Shadow set members queue forward link
macro VCB$L_FCBBL = 4,0,32,1 %;         !  FCB listhead backward link
macro VCB$L_BLOCKBL = 4,0,32,0 %;       !   or - Blocked request listhead backward link
macro VCB$L_MEMQBL = 4,0,32,1 %;        !   or - Shadow set members queue backward link
macro VCB$W_SIZE = 8,0,16,0 %;          !  Size of VCB in bytes
macro VCB$B_TYPE = 10,0,8,0 %;          !  structure type of VCB 
macro VCB$R_VCB_UNION = 11,0,0,0 %;
literal VCB$S_VCB_UNION = 293;
macro VCB$B_STATUS = 11,0,8,0 %;        !  Volume status:
macro VCB$V_WRITE_IF = 11,0,1,0 %;      !     Index file is write accessed
macro VCB$V_WRITE_SM = 11,1,1,0 %;      !     Storage map is write accessed
macro VCB$V_HOMBLKBAD = 11,2,1,0 %;     !     Primary home block is bad
macro VCB$V_IDXHDRBAD = 11,3,1,0 %;     !     Primary index file header is bad
macro VCB$V_NOALLOC = 11,4,1,0 %;       !     Allocation/deallocation inhibited (bad bitmaps)
macro VCB$V_EXTFID = 11,5,1,0 %;        !     Volume has 24 bit file numbers
macro VCB$V_GROUP = 11,6,1,0 %;         !     Volume is mounted /group
macro VCB$V_SYSTEM = 11,7,1,0 %;        !     Volume is mounted /system
macro VCB$V_HIGH_SIERRA = 11,0,1,0 %;   !     Volume is High Sierra
macro VCB$V_NOSWITCH = 11,1,1,0 %;      !     Disable Automatic Volume Switching
macro VCB$V_DSI = 11,2,1,0 %;           !     Enable protection based on DSI
macro VCB$V_XAR = 11,3,1,0 %;           !     Enable protection based on XAR
!           GROUP bitfield mask;			/*    Volume is mounted /group
!           SYSTEM bitfield mask;			/*    Volume is mounted /system
macro VCB$V_PARTFILE = 11,0,1,0 %;      !     Partial file exists on tape
macro VCB$V_LOGICEOVS = 11,1,1,0 %;     !     Positioned at logical end of volume set
macro VCB$V_WAIMOUVOL = 11,2,1,0 %;     !     Wait for volume mount
macro VCB$V_WAIREWIND = 11,3,1,0 %;     !     Wait for rewind completion
macro VCB$V_WAIUSRLBL = 11,4,1,0 %;     !     Wait for user label
macro VCB$V_CANCELIO = 11,5,1,0 %;      !     Cancel I/O 
macro VCB$V_MUSTCLOSE = 11,6,1,0 %;     !     Must close file
macro VCB$V_NOWRITE = 11,7,1,0 %;       !     Don't write trailers
macro VCB$V_SHADMAST = 11,0,1,0 %;      !     This VCB is for shadow set master
macro VCB$V_FAILED = 11,1,1,0 %;        !     Member failed out of shadow set
macro VCB$V_REBLDNG = 11,3,1,0 %;       !     Mount verfication rebuilding shadow set
macro VCB$V_BLKASTREC = 11,4,1,0 %;     !     Shadowing lock blocking AST received
macro VCB$V_MVBEGUN = 11,5,1,0 %;       !     Mount verification initiated
macro VCB$V_ADDING = 11,6,1,0 %;        !     Adding member to shadow set
macro VCB$V_PACKACKED = 11,7,1,0 %;     !     Member PACKACKed during rebuild attempt
macro VCB$L_TRANS = 12,0,32,0 %;        !  VOLUME TRANSACTION COUNT 
macro VCB$L_RVN = 16,0,32,0 %;          !  RELATIVE VOLUME NUMBER 
macro VCB$L_AQB = 20,0,32,1 %;          !  ADDRESS OF AQB 
macro VCB$T_VOLNAME = 24,0,0,0 %;
literal VCB$S_VOLNAME = 12;             !  VOLUME LABEL BLANK FILLED 
macro VCB$L_RVT = 36,0,32,1 %;          !  ADDRESS OF UCB OR RELATIVE VOLUME TABLE 
macro VCB$R_VCB_EXTENSIONS = 40,0,0,0 %;
literal VCB$S_VCB_EXTENSIONS = 264;     !  NESTED UNION CONTAINING MAJOR EXTENSIONS
macro VCB$R_VCB_DISKS = 40,0,0,0 %;
literal VCB$S_VCB_DISKS = 264;
! 
!  Files-11 A & B Volume Control Block Fields
! 	(ODS-I & ODS-II )
! 
macro VCB$L_HOMELBN = 40,0,32,0 %;      !  LBN OF VOLUME HOME BLOCK 
macro VCB$L_HOME2LBN = 44,0,32,0 %;     !  LBN OF ALTERNATE VOLUME HOME BLOCK 
macro VCB$L_IXHDR2LBN = 48,0,32,0 %;    !  LBN OF ALTERNATE INDEX FILE HEADER 
macro VCB$L_IBMAPLBN = 52,0,32,0 %;     !  LBN OF INDEX FILE BITMAP 
macro VCB$L_SBMAPLBN = 56,0,32,0 %;     !  LBN OF STORAGE BITMAP 
macro VCB$L_IBMAPSIZE = 60,0,32,0 %;    !  SIZE OF INDEX FILE BITMAP
macro VCB$L_IBMAPVBN = 64,0,32,0 %;     !  CURRENT VBN IN INDEX FILE BIT MAP
macro VCB$L_SBMAPSIZE = 68,0,32,0 %;    !  SIZE OF STORAGE BITMAP 
macro VCB$L_SBMAPVBN = 72,0,32,0 %;     !  CURRENT VBN IN STORAGE MAP 
macro VCB$L_CLUSTER = 76,0,32,0 %;      !  VOLUME CLUSTER SIZE 
macro VCB$L_EXTEND = 80,0,32,0 %;       !  VOLUME DEFAULT FILE EXTENSION LENGTH 
macro VCB$L_FREE = 84,0,32,0 %;         !  NUMBER OF FREE BLOCKS ON VOLUME 
macro VCB$L_MAXFILES = 88,0,32,0 %;     !  MAXIMUM NUMBER OF FILES ALLOWED ON VOLUME 
macro VCB$L_WINDOW = 92,0,32,0 %;       !  VOLUME DEFAULT WINDOW SIZE 
macro VCB$L_LRU_LIM = 96,0,32,0 %;      !  VOLUME DIRECTORY LRU SIZE LIMIT 
macro VCB$L_FILEPROT = 100,0,32,0 %;    !  VOLUME DEFAULT FILE PROTECTION 
macro VCB$L_MCOUNT = 104,0,32,0 %;      !  MOUNT COUNT 
macro VCB$L_EOFDELTA = 108,0,32,0 %;    !  INDEX FILE EOF UPDATE COUNT 
macro VCB$L_RESFILES = 112,0,32,0 %;    !  NUMBER OF RESERVED FILES ON VOLUME 
macro VCB$L_RECORDSZ = 116,0,32,0 %;    !  NUMBER OF BYTES IN A RECORD 
macro VCB$L_BLOCKFACT = 120,0,32,0 %;   !  VOLUME BLOCKING FACTOR 
macro VCB$B_STATUS2 = 124,0,8,0 %;      !  SECOND STATUS BYTE 
macro VCB$V_WRITETHRU = 124,0,1,0 %;    !  VOLUME IS TO BE WRITE-THROUGH CACHED 
macro VCB$V_NOCACHE = 124,1,1,0 %;      !  ALL CACHEING IS DISABLED ON VOLUME 
macro VCB$V_MOUNTVER = 124,2,1,0 %;     !  VOLUME CAN UNDERGO MOUNT VERIFICATION 
macro VCB$V_ERASE = 124,3,1,0 %;        !  ERASE DATA WHEN BLOCKS REMOVED FROM FILE
macro VCB$V_NOHIGHWATER = 124,4,1,0 %;  !  TURN OFF HIGH-WATER MARKING (D = ON)
macro VCB$V_NOSHARE = 124,5,1,0 %;      !  non-shared mount
macro VCB$V_CLUSLOCK = 124,6,1,0 %;     !  CLUSTER WIDE LOCKING NECESSARY
macro VCB$V_SUBSET0 = 124,7,1,0 %;      !  ODS-2 SUBSET 0 VOLUME
macro VCB$L_QUOTAFCB = 128,0,32,1 %;    !  ADDRESS OF FCB OF DISK QUOTA FILE 
macro VCB$L_CACHE = 132,0,32,1 %;       !  ADDRESS OF VOLUME CACHE BLOCK 
macro VCB$L_QUOCACHE = 136,0,32,1 %;    !  ADDRESS OF VOLUME QUOTA CACHE 
macro VCB$L_QUOSIZE = 140,0,32,0 %;     !  LENGTH OF QUOTA CACHE TO ALLOCATE 
macro VCB$L_PENDERR = 144,0,32,0 %;     !  COUNT OF PENDING WRITE ERRORS 
macro VCB$L_SERIALNUM = 148,0,32,0 %;   !  VOLUME SERIAL NUMBER (DISKS ONLY) 
macro VCB$L_STATUS3 = 152,0,32,0 %;     !  THIRD STATUS FIELD
!  NOTE: the above field was formerly called JNLIOCNT
macro VCB$V_SUBSYSTEM = 152,0,1,0 %;    !  PROTECTED SUBSYSTEMS ENABLED
macro VCB$L_VOLLKID = 156,0,32,0 %;     !  VOLUME LOCK ID
macro VCB$T_VOLCKNAM = 160,0,0,0 %;
literal VCB$S_VOLCKNAM = 12;            !  NAME FOR VOLUME LOCKS
macro VCB$L_BLOCKID = 172,0,32,0 %;     !  VOLUME BLOCKING LOCK.
macro VCB$Q_RETAINMIN = 176,0,0,0 %;
literal VCB$S_RETAINMIN = 8;            !  MINIMUM FILE RETENTION PERIOD 
macro VCB$Q_RETAINMAX = 184,0,0,0 %;
literal VCB$S_RETAINMAX = 8;            !  MAXIMUM FILE RETENTION PERIOD 
macro VCB$Q_MOUNTTIME = 192,0,0,0 %;
literal VCB$S_MOUNTTIME = 8;            !  VOLUME MOUNT TIME
macro VCB$L_MEMHDFL = 200,0,32,1 %;     !  SHADOW SET MEMBERS QUEUE HEADER FL
macro VCB$L_MEMHDBL = 204,0,32,1 %;     !  SHADOW SET MEMBERS QUEUE HEADER BL
macro VCB$B_SHAD_STS = 211,0,8,0 %;     !  STATUS BYTE RELATIVE TO MEMHDFL
macro VCB$L_ACTIVITY = 212,0,32,0 %;    !  ACTIVITY COUNT/FLAG
macro VCB$L_SPL_CNT = 216,0,32,0 %;     !  NUMBER OF DEVICES SPOOLED TO VOLUME
macro VCB$L_SHAD_LKID = 220,0,32,0 %;   !  Shadowing lock lock-id
macro VCB$B_ACB = 224,0,0,0 %;
literal VCB$S_ACB = 36;                 !  ACB FOR BLOCKING AST.
macro VCB$R_MIN_CLASS = 260,0,0,0 %;
literal VCB$S_MIN_CLASS = 20;           !  MINIMUM CLASSIFICATION
macro VCB$L_ORB = 260,0,32,0 %;         !  Pointer to the volume's ORB
macro VCB$R_MAX_CLASS = 280,0,0,0 %;
literal VCB$S_MAX_CLASS = 20;           !  MAXIMUM CLASSIFICATION
macro VCB$L_CACHING_OPTIONS = 300,0,32,0 %;
macro VCB$V_FILE_ATTRIBUTES = 300,0,4,0 %;
literal VCB$S_FILE_ATTRIBUTES = 4;      !  file attributes caching field
macro VCB$V_FILE_CONTENTS = 300,4,4,0 %;
literal VCB$S_FILE_CONTENTS = 4;        !  file contents caching field
macro VCB$V_FLUSH_ON_CLOSE = 300,8,4,0 %;
literal VCB$S_FLUSH_ON_CLOSE = 4;       !  flush file on close field
macro VCB$V_CACHING_OPTIONS_MBZ = 300,12,20,0 %;
literal VCB$S_CACHING_OPTIONS_MBZ = 20; !  must be zero
macro VCB$R_VCB_SHADOW = 40,0,0,0 %;
literal VCB$S_VCB_SHADOW = 36;
! 
!  SHADOW SET MEMBER VOLUME CONTROL BLOCK FIELDS
! 
macro VCB$L_MEM_UCB = 40,0,32,1 %;      !  Shadow set member UCB address
macro VCB$L_MAST_UCB = 44,0,32,1 %;     !  Shadow set master UCB address
macro VCB$L_MAST_VCB = 48,0,32,1 %;     !  Shadow set master VCB address
macro VCB$W_COPY_TYPE = 52,0,16,0 %;    !  Member's MSCP copy type
macro VCB$W_CPYSEQNUM = 54,0,16,0 %;    !  IO$_COPYSHAD sequence number
macro VCB$Q_WORK = 60,0,0,0 %;
literal VCB$S_WORK = 8;                 !  Per-member workspace
macro VCB$Q_SHDM_RESV = 68,0,0,0 %;
literal VCB$S_SHDM_RESV = 8;            !  Reserved for future enhancements
macro VCB$R_VCB_CDROM = 40,0,0,0 %;
literal VCB$S_VCB_CDROM = 88;
! 
!  Files-11 C & D Volume Control Block Fields
!  (ISO 9660 and High Sierra)
!  NOTE: fields must parallel VCBDEF_DISK definitions
! 
macro VCB$L_VOLDESC = 40,0,32,0 %;      !  LBN of Volume Descriptor Block 
macro VCB$L_ORPHANED_VCB = 44,0,32,1 %; !  Singlely linked list of Orphaned VCB's
macro VCB$L_PTVECTOR = 48,0,32,1 %;     !  Address Path Table Vector
macro VCB$L_LBNCACHE = 52,0,32,1 %;     !  Address of LBN cache listhead 
macro VCB$L_PTINDEX = 56,0,32,0 %;      !  LBN of Path Table Index 
macro VCB$L_LBSIZE = 60,0,32,0 %;       !  ISO 9660 Logical Block Size
macro VCB$L_MXDIRNM = 64,0,32,0 %;      !  Maximum directory record number
macro VCB$L_LBBLOCKS = 68,0,32,0 %;     !  Number of 512-byte blocks per Logical Block
macro VCB$L_MINREAD = 72,0,32,0 %;      !  Minimum number of LBNs to read at once
macro VCB$L_RDBYTES = 76,0,32,0 %;      !  Number of bytes to read from disk at once
macro VCB$L_LASTGRP = 80,0,32,0 %;      !  Highest volume number of last volume group
macro VCB$L_CD_FREE = 84,0,32,0 %;      !  (VCB$L_FREE - see VCBDEF_DISK)
macro VCB$L_CD_MAXFILES = 88,0,32,0 %;  !  (VCB$L_MAXFILES - see VCBDEF_DISK)
macro VCB$L_CD_WINDOW = 92,0,32,0 %;    !  (VCB$L_WINDOW - see VCBDEF_DISK)
macro VCB$L_CD_LRU_LIM = 96,0,32,0 %;   !  (VCB$L_LRU_LIM - see VCBDEF_DISK)
macro VCB$L_PTRVN = 100,0,32,0 %;       !  RVN of volume containing current Path Table
macro VCB$L_CD_MCOUNT = 104,0,32,0 %;   !  (VCB$L_MCOUNT - see VCBDEF_DISK)
macro VCB$L_FAT_RFM = 108,0,32,0 %;     !  Override FAT Record Format
macro VCB$L_FAT_RAT = 112,0,32,0 %;     !  Override FAT Record Attributes
macro VCB$L_FAT_MRS = 116,0,32,0 %;     !  Override FAT Maximum Record Size
macro VCB$L_SECTORS = 120,0,32,0 %;     !  Number of sectors on volume
macro VCB$B_CD_STATUS2 = 124,0,8,0 %;   !  (VCB$B_STATUS2 - see VCBDEF_DISK)
! 
!  Compare with VCBDEF_DISK above, before overlaying any other CDROM fields
! 
macro VCB$R_VCB_MTAACP = 40,0,0,0 %;
literal VCB$S_VCB_MTAACP = 144;
! 
!  MTAACP VOLUME CONTROL BLOCK FIELDS
! 
macro VCB$L_CUR_FID = 40,0,32,0 %;      !  CURRENT FILE IDENTIFICATION 
macro VCB$W_CUR_NUM = 40,0,16,0 %;      !  CURRENT FILE SECTION NUMBER 
macro VCB$W_CUR_SEQ = 42,0,16,0 %;      !  CURRENT FILE SEQUENCE NUMBER 
macro VCB$L_START_FID = 44,0,32,0 %;    !  FILE IDENTIFICATION AT START OF SEARCH 
macro VCB$W_START_NUM = 44,0,16,0 %;    !  FILE SECTION NUMBER AT START OF SEARCH 
macro VCB$W_START_SEQ = 46,0,16,0 %;    !  FILE SEQUENCE NUMBER AT START OF SEARCH 
macro VCB$W_MODE = 48,0,16,0 %;         !  MODE OF OPERATION 
macro VCB$V_OVREXP = 48,0,1,0 %;        !  OVERRIDE EXPIRATION 
macro VCB$V_OVRACC = 48,1,1,0 %;        !  OVERRIDE ACCESS 
macro VCB$V_OVRLBL = 48,2,1,0 %;        !  OVERRIDE LABELS 
macro VCB$V_OVRSETID = 48,3,1,0 %;      !  OVERRIDE SET IDENTIFIER 
macro VCB$V_INTCHG = 48,4,1,0 %;        !  INTERCHANGE TAPE 
macro VCB$V_EBCDIC = 48,5,1,0 %;        !  EBCDIC CODE SET 
macro VCB$V_NOVOL2 = 48,6,1,0 %;        !  DO NOT WRITE A VOL2 LABEL
macro VCB$V_NOHDR3 = 48,7,1,0 %;        !  DO NOT WRITE HDR3 LABELS 
macro VCB$V_STARFILE = 48,8,1,0 %;      !  CURRENT FILE IS A STARLET PRODUCED FILE 
macro VCB$V_ENUSEREOT = 48,9,1,0 %;     !  SET WHEN USER HANDLING OF EOT IS ENABLED
macro VCB$V_BLANK = 48,10,1,0 %;        !  SET FOR AVL WHEN NO READ SHOULD HAPPEN FIRST
macro VCB$V_INIT = 48,11,1,0 %;         !  SET FOR AVL WHEN NEXT VOL MOUNTED SHOULD BE INITED
macro VCB$V_NOAUTO = 48,12,1,0 %;       !  MTAACP NOT RUNNING IN AVL AND AVR MODE
macro VCB$V_OVRVOLO = 48,13,1,0 %;      !  OVERRIDE THEVOL1 OWNER IDENT FIELD
macro VCB$V_FIL_ACCESS = 48,14,1,0 %;   !  SET IF ACCESS ROUTINE ALLOWS CHECK OF VMS PROTECTION ON FILE
macro VCB$B_TM = 50,0,8,0 %;            !  NUMBER OF TM'S INTO FILE 
macro VCB$B_CUR_RVN = 51,0,8,0 %;       !  CURRENT RELATIVE VOLUME 
macro VCB$L_ST_RECORD = 52,0,32,0 %;    !  NUMBER OF RECORDS UP TO AND INCLUDING LAST TAPE MARK 
macro VCB$L_MVL = 56,0,32,1 %;          !  ADDRESS OF MAGNETIC TAPE VOLUME LIST 
macro VCB$L_WCB = 60,0,32,1 %;          !  ADDRESS OF WINDOW FOR THIS VOLUME 
macro VCB$L_VPFL = 64,0,32,1 %;         !  VIRTUAL PAGE LIST HEAD 
macro VCB$L_VPBL = 68,0,32,1 %;         !  VIRTUAL PAGE LIST TAIL 
macro VCB$L_USRLBLAST = 72,0,32,1 %;    !  ADDRESS OF USER LABEL AST CONTROL BLOCK 
macro VCB$B_LBLCNT = 76,0,8,0 %;        !  Count of HDRn labels read on file open
!  NOTE THAT FCP AND MTAACP SHARE VCB$W/L_MCOUNT(DISPLACEMENT 104)
macro VCB$t_fill_5 = 77,0,0,0 %;
literal VCB$s_fill_5 = 99;              !  Skip over fields up to RETAINMIN=176
macro VCB$Q_EXP_DATE = 176,0,0,0 %;
literal VCB$S_EXP_DATE = 8;             !  DEFAULT FILE EXPIRATION DATE
!  End the Union of extensions
!  End the member (which is a union with VCB_JACP)
macro VCB$R_VCB_JACP = 11,0,0,0 %;
literal VCB$S_VCB_JACP = 21;
! 
!  JOURNAL ACP VOLUME CONTROL BLOCK FIELDS
! 
macro VCB$B_QNAMECNT = 11,0,8,0 %;      !  BYTE COUNT OF QUEUE NAME 
macro VCB$T_QNAME = 12,0,0,0 %;
literal VCB$S_QNAME = 20;               !  ASCII NAME OF QUEUE FOR THIS DEVICE 
 
!*** MODULE $VCIBDEF ***
! +
!  VCIB - VAX Communication Interface Block
! 
!  The VCIB is the data structure used to define an instance of a VCI port
!  between two VCMs.  A single VCIB is used between only two layers.  Those
!  two layers may have many VCIBs between them; each one representing a
!  different VCI port.  Only the common fields within the VCIB are defined
!  here.  All layer-specific fields are defined elsewhere.  Some constants
!  used within the VCIB are defined here also.  And the VCM IDs are also
!  defined here.
! -
!  VCI Registry function codes.
literal VCIB$K_FC_REGISTER = 0;         !  Register a VCM
literal VCIB$K_FC_UNREGISTER = 1;       !  Unregister a VCM
literal VCIB$K_FC_CREATE_PORT = 2;      !  Create a port to a lower VCM
literal VCIB$K_FC_DELETE_PORT = 3;      !  Delete a port to a lower VCM
!  Registered users of the VCI.
literal VCI$K_ID_MODEM = 257;           !  Modem Connect
literal VCI$K_ID_NWM = 2048;            !  Network Management
literal VCI$K_ID_CONF = 2049;           !  Conformance Test Tool
literal VCI$K_ID_SCL = 1280;            !  Session Control
literal VCI$K_ID_SCLSRV = 1281;         !  Session Control Session Services
literal VCI$K_ID_SCLMIN = 1282;         !  Session Control Minimum Services
literal VCI$K_ID_NSPTP = 1024;          !  Transport - NSP
literal VCI$K_ID_OSITP = 1025;          !  Transport - OSI
literal VCI$K_ID_LCLTP = 1026;          !  Transport - Local
literal VCI$K_ID_SCATP = 1027;          !  Transport - SCA
literal VCI$K_ID_LAT = 1028;            !  Transport - LAT
literal VCI$K_ID_LAST = 1029;           !  Transport - LAST
literal VCI$K_ID_LAVC = 1030;           !  Transport - LAVC
literal VCI$K_ID_MOP = 1031;            !  Maintenance Operations
literal VCI$K_ID_TCPIP = 1032;          !  Transport - TCPIP
literal VCI$K_ID_IP = 1032;             !  Transport - IP
literal VCI$K_ID_AMDS = 1033;           !  Transport - AMDS
literal VCI$K_ID_CUSTP = 1177;          !  Transport - Customer
literal VCI$K_ID_NRL = 768;             !  Network Routing
literal VCI$K_ID_ALIAS = 769;           !  Alias (Routing portion)
literal VCI$K_ID_CUSRL = 921;           !  Routing - Customer
literal VCI$K_ID_LAN = 513;             !  Data Link - CSMACD & FDDI
literal VCI$K_ID_DDCMP = 514;           !  Data Link - DDCMP Synchronous
literal VCI$K_ID_HDLC = 515;            !  Data Link - HDLC  Synchronous
literal VCI$K_ID_ASY = 516;             !  Data Link - Asynchronous
literal VCI$K_ID_X25 = 517;             !  Data Link - X.25
literal VCI$K_ID_ADM = 518;             !  Data Link - ALTSTART DDCMP
literal VCI$K_ID_ACM = 519;             !  Data Link - ALTSTART CSMACD
literal VCI$K_ID_LAPB = 520;            !  Data Link - LAPB
literal VCI$K_ID_LLC2 = 521;            !  Data Link - LLC2
literal VCI$K_ID_NETBEUI = 528;         !  Data Link - NETBEUI
literal VCI$K_ID_IPX = 529;             !  Data Link - IPX
literal VCI$K_ID_DSP = 530;             !  Data Link - Digital stream protocol
literal VCI$K_ID_CUSDL = 665;           !  Data Link - Customer
literal VCI$K_ID_TST1 = 2304;           !  Test VCM  - 1st
literal VCI$K_ID_TST2 = 2305;           !  Test VCM  - 2nd
literal VCI$K_ID_TST3 = 2306;           !  Test VCM  - 3rd
literal VCI$K_ID_TST4 = 2307;           !  Test VCM  - 4th
literal VCI$K_ID_TST5 = 2308;           !  Test VCM  - 5th
literal VCI$K_ID_TST6 = 2309;           !  Test VCM  - 6th
literal VCI$K_ID_TST7 = 2310;           !  Test VCM  - 7th
literal VCI$K_ID_TST8 = 2311;           !  Test VCM  - 8th
literal VCI$K_NUM_ID = 41;              !  Number of valid VCMs 
!  VCIB data structure
! 
!  The common fields within the VCIB are defined now.
literal VCIB$K_FIXED_LENGTH = 60;       !  Length of fixed portion of VCIB
literal VCIB$S_VCIBDEF = 60;
macro VCIB$L_FLINK = 0,0,32,0 %;        !  Forward Queue link
macro VCIB$L_BLINK = 4,0,32,0 %;        !  Backward Queue link
macro VCIB$W_SIZE = 8,0,16,0 %;         !  Size of structure
macro VCIB$B_TYPE = 10,0,8,0 %;         !  Type of structure - DYN$C_NET
macro VCIB$B_SUB_TYPE = 11,0,8,0 %;     !  Subtype of structure - DYN$C_VCIB
macro VCIB$L_VCI_ID = 12,0,32,0 %;      !  Field containing the VCI ID of the
!  VCM (used by the lower VCM for
!  validation of user)
macro VCIB$W_VERSION_UPPER = 16,0,16,0 %; !  VCI Version of Upper VCM
macro VCIB$W_VERSION_LOWER = 18,0,16,0 %; !  VCI Version of Lower VCM
macro VCIB$A_PORTMGMT_SYNCH = 20,0,32,0 %; !  Address of Lower VCM's Port
!  Management Synchronous service
macro VCIB$A_PORTMGMT_INITIATE = 24,0,32,0 %; !  Address of Lower VCM's Port
!  Management Initiate service
macro VCIB$A_PORTMGMT_COMPLETE = 28,0,32,0 %; !  Address of Upper VCM's Port
!  Management Complete service
macro VCIB$A_CONTROL_SYNCH = 32,0,32,0 %; !  Address of Lower VCM's Control
!  Synchronous service
macro VCIB$A_CONTROL_INITIATE = 36,0,32,0 %; !  Address of Lower VCM's Control
!  Initiate service
macro VCIB$A_CONTROL_COMPLETE = 40,0,32,0 %; !  Address of Upper VCM's Control
!  Complete service
macro VCIB$A_TRANSMIT_INITIATE = 44,0,32,0 %; !  Address of Lower VCM's Transmit
!  Initiate service
macro VCIB$A_TRANSMIT_COMPLETE = 48,0,32,0 %; !  Address of Upper VCM's Transmit
!  Complete service
macro VCIB$A_RECEIVE_COMPLETE = 52,0,32,0 %; !  Address of Upper VCM's Receive
!  Complete service
macro VCIB$A_REPORT_EVENT = 56,0,32,0 %; !  Address of Upper VCM's Report
!  Event service
 
!*** MODULE $VCRPDEF ***
! +
!  VCRP - VAX Communication Request Packet
! 
!  The VCRP is the data structure used to pass requests between VCMs.  A
!  single VCRP may traverse more than two VCMs.  Only the common fields
!  within the VCRP are defined here.  All layer-specific fields are defined
!  elsewhere.  The common VCRP function codes are also defined here.
! 
!  THE FORMAT OF A VCRP DATA REQUEST PACKET SHOULD NOT CHANGE WITHOUT
!  CORRESPONDING CHANGES BEING MAY TO THE DCBE.
! -
!  Function codes used in the VCRP$L_FUNCTION field.  The function codes
!  are separated numerically by layer as follows:
! 
!    0000-01FF Common function codes from the VCI functional specification
!    0200-02FF DLL Data Link function codes
!    0300-03FF NRL Network Routing function codes
!    0400-04FF TPL Transport function codes
!    0500-05FF SCL Session function codes
!    0600-06FF APP Application function codes
literal VCRP$K_FC_ENABLE_PORT = 0;
literal VCRP$K_FC_DISABLE_PORT = 1;
literal VCRP$K_FC_GET = 2;
literal VCRP$K_FC_SET = 3;
literal VCRP$K_FC_TRANSMIT = 4;
literal VCRP$K_FC_RECEIVE = 5;
!  Define the fields used within the STACK area of the VCRP.
literal STACK$k_STACK_HEADER = 12;
!  Size of Stack Header
literal STACK$K_STACK_SIZE = 80;        !  Size of Stack in bytes
literal STACK$S_VCRPSTACKDEF = 92;
macro STACK$L_LASTUSED = 0,0,32,0 %;    !  Stack Last Used position pointer
macro STACK$L_BTM = 4,0,32,0 %;         !  Stack Bottom
macro STACK$L_TOP = 8,0,32,0 %;         !  Stack Top
macro STACK$T_STACK = 12,0,0,0 %;
literal STACK$S_STACK = 80;
!  Context stack
!  Size of entire stack area
!  VCRP data structure
! 
!  The common fields within the VCRP are defined now.  The VCRP is created
!  such that it can be used as an ACB, a DCBE, or a VCRP.  So the fields at
!  the beginning of the VCRP mimic the fields in the ACB and the DCBE.
literal VCRP$M_PKAST = %X'10';
literal VCRP$M_NODELETE = %X'20';
literal VCRP$M_QUOTA = %X'40';
literal VCRP$M_KAST = %X'80';
literal VCRP$K_ACB_LENGTH = 36;         !  Length of VCRP ACB Block
literal VCRP$M_CMN_LOCKED = %X'1';
literal VCRP$M_CMN_RETBUF = %X'2';
literal VCRP$M_CMN_CACHE = %X'4';
literal VCRP$M_CMN_MGMT = %X'8';
literal VCRP$K_DATA_INFORMATION_OFFSET = 68;
literal VCRP$K_DATA_INFORMATION_LENGTH = 7;
literal VCRP$K_MGMT_INFORMATION_OFFSET = 56;
literal VCRP$K_MGMT_INFORMATION_LENGTH = 19;
literal VCRP$K_CREATOR_DATA_OFFSET = 100;
literal VCRP$K_CREATOR_DATA_LENGTH = 8;
literal VCRP$K_INTERNAL_STACK_OFFSET = 120;
literal VCRP$K_INTERNAL_STACK_LENGTH = 92;
literal VCRP$K_SCRATCH_AREA_OFFSET = 212;
literal VCRP$K_SCRATCH_AREA_LENGTH = 64;
literal VCRP$K_FIXED_LENGTH = 276;      !  Length of fixed part of VCRP
!  If this VCM contains data, it will start here or after here.
literal VCRP$C_DATA = 276;              !  Offset into start of data
literal VCRP$S_VCRPDEF = 276;
macro VCRP$L_FLINK = 0,0,32,0 %;        !  Forward Queue link
macro VCRP$L_BLINK = 4,0,32,0 %;        !  Backward Queue link
macro VCRP$W_SIZE = 8,0,16,0 %;         !  Size of structure
macro VCRP$B_TYPE = 10,0,8,0 %;         !  Type of structure - DYN$C_VCRP
macro VCRP$B_RMOD = 11,0,8,0 %;         !  Request Modifier for ACB
macro VCRP$V_MODE = 11,0,2,0 %;
literal VCRP$S_MODE = 2;                !  Mode for final delivery
macro VCRP$V_PKAST = 11,4,1,0 %;        !  Piggy back special kernel AST
macro VCRP$V_NODELETE = 11,5,1,0 %;     !  Don't delete ACB on delivery
macro VCRP$V_QUOTA = 11,6,1,0 %;        !  Account for quota
macro VCRP$V_KAST = 11,7,1,0 %;         !  Special kernel AST
macro VCRP$L_PID = 12,0,32,0 %;         !  Process Identifier
macro VCRP$A_ASTADR = 16,0,32,0 %;      !  Address of user AST routine
macro VCRP$L_ASTPRM = 20,0,32,0 %;      !  User AST input parameter
macro VCRP$A_KAST = 32,0,32,0 %;        !  Special kernel mode AST routine
macro VCRP$R_COMMON_FLAGS_OVERLAY = 36,0,16,0 %;
macro VCRP$W_COMMON_FLAGS = 36,0,16,0 %; !  Common flags
macro VCRP$V_CMN_LOCKED = 36,0,1,0 %;   !  Buffer is locked down
macro VCRP$V_CMN_RETBUF = 36,1,1,0 %;   !  Return buffer immediately
macro VCRP$V_CMN_CACHE = 36,2,1,0 %;    !  Owner's cache buffer
macro VCRP$V_CMN_MGMT = 36,3,1,0 %;     !  Mgmt VCRP; not data VCRP
macro VCRP$B_FLAGS = 38,0,8,0 %;        !  User controlled VCRP flags
macro VCRP$B_MODE = 39,0,8,0 %;         !  
macro VCRP$A_DEALLOC_RTN = 40,0,32,0 %; !  Address of VCRP deallocation routine
! 
!  This part of the VCRP contains the request specific information.
!  VCRPs can contain either a Management request or a Data request.  The
!  type of VCRP request is determined by the VCRP$W_COMMON_FLAGS field.
!  If VCRP$V_CMN_MGMT is set, then the VCRP is using the Management
!  request format.  IF VCRP$V_CMN_MGMT is NOT set, then the VCRP is
!  using the Data request format.
! 
macro VCRP$R_VCRP_REQUEST = 44,0,0,0 %;
literal VCRP$S_VCRP_REQUEST = 32;
macro VCRP$R_REQUEST_OVERLAY = 44,0,0,0 %;
! 
!  Data Request Format.  The position of these field are to be the same
!  as the DCB fields of the same name.
! 
macro VCRP$R_DATA_REQUEST = 44,0,0,0 %;
literal VCRP$S_DATA_REQUEST = 31;
macro VCRP$A_DCB_LINK = 44,0,32,0 %;    !  Address of next DCB in chain
macro VCRP$L_SVAPTE = 48,0,32,0 %;      !  Address of System Virtual Address PTE
macro VCRP$L_BUFFER_ADDRESS = 52,0,32,0 %; !  VM Address of buffer specified in SVAPTE
macro VCRP$L_BOFF = 56,0,32,0 %;        !  Offset to start of data in buffer
macro VCRP$L_BCNT = 60,0,32,0 %;        !  Byte count of data in buffer
! 
!  All fields preceeding this comment should be similar in layout,name and size 
!  to a DCB.  A programmer should verify that these fields are similar by
!  adding the appropriate ASSUMES to his or her code.
! 
macro VCRP$L_TOTAL_PDU_SIZE = 64,0,32,0 %; !  Total PDU Size
!  This 7 byte portion of the data request area can be used by each
!  layer to allow its client to pass more information in the request.
macro VCRP$T_DATA_INFORMATION = 68,0,0,1 %;
literal VCRP$S_DATA_INFORMATION = 7;
! 
!  Management Request Format.  
! 	    
macro VCRP$R_MGMT_REQUEST = 44,0,0,0 %;
literal VCRP$S_MGMT_REQUEST = 31;
macro VCRP$A_INPUT_LIST = 44,0,32,0 %;  !  Address of Input item list
macro VCRP$A_TEMPLATE_LIST = 48,0,32,0 %; !  Address of Template item list
macro VCRP$A_OUTPUT_LIST = 52,0,32,0 %; !  Address of Output item list
!  This 19 byte portion of the mgmt request area can be used by each
!  layer to allow its client to pass more information in the request.
macro VCRP$T_MGMT_INFORMATION = 56,0,0,1 %;
literal VCRP$S_MGMT_INFORMATION = 19;
macro VCRP$B_LES_FLAGS = 75,0,8,0 %;    !  LES flags
macro VCRP$L_FUNCTION = 76,0,32,0 %;    !  Function for this request
macro VCRP$L_ASSOCIATION_ID = 80,0,32,0 %;
macro VCRP$L_CONNECTION_ID = 84,0,32,0 %;
macro VCRP$R_STATUS_OVERLAY = 88,0,0,0 %; !  Status of request upon completion
macro VCRP$R_QUAD_REQUEST = 88,0,0,0 %;
literal VCRP$S_QUAD_REQUEST = 8;
macro VCRP$Q_REQUEST_STATUS = 88,0,0,0 %;
literal VCRP$S_REQUEST_STATUS = 8;
macro VCRP$R_LONG_REQUEST = 88,0,0,0 %;
literal VCRP$S_LONG_REQUEST = 8;
macro VCRP$L_REQUEST_STATUS = 88,0,32,0 %;
macro VCRP$L_REQUEST_STATUS_QUAL = 92,0,32,0 %;
macro VCRP$A_CREATOR = 96,0,32,0 %;     !  VCIB address of creator of VCRP
!  The creator data section is a section that is used privately by the
!  creator of the VCRP.
macro VCRP$R_CREATOR_DATA_OVERLAY = 100,0,0,0 %;
macro VCRP$R_QUAD_CREATOR_DATA = 100,0,0,0 %;
literal VCRP$S_QUAD_CREATOR_DATA = 8;
macro VCRP$Q_CREATOR_DATA = 100,0,0,0 %;
literal VCRP$S_CREATOR_DATA = 8;
macro VCRP$R_LONG_CREATOR_DATA = 100,0,0,0 %;
literal VCRP$S_LONG_CREATOR_DATA = 8;
macro VCRP$L_CREATOR_DATA1 = 100,0,32,0 %;
macro VCRP$L_CREATOR_DATA2 = 104,0,32,0 %;
macro VCRP$Q_LES = 108,0,0,0 %;
literal VCRP$S_LES = 8;                 !  LES information
!  The following fields describe the VCRP context stack, which is used by
!  by VCM's to preserve request context.  The use of the fields is as 
!  follows:
! 
!  STACK	 - contains an address which will point to a stack block.  The
!              stack block will contain the last used stack pointer
!              (LASTUSED), the address of the end of the stack (BTM), the
!              address of the top of the stack, and the stack itself
!              (STACK).  This is layout is used to insure that if the
!              context stack is removed from the VCRP and allocated in a
!              buffer pointed to by VCRP$A_STACK, that no VCM's will be
!              adversely affected.
! 	LASTUSED - pointer to the last used location in the stack.
! 	BTM	 - pointer to the bottom of the stack
! 	TOP	 - pointer to the top of the stack
! 	STACK    - Start of context stack.
!          
!  Saving on and restoring from the context stack can be done by using the
!  VCRP_PUSH and VCRP_POP macros.
macro VCRP$A_STACK = 116,0,32,0 %;      !  Pointer stack block
macro VCRP$T_INTERNAL_STACK = 120,0,0,0 %;
literal VCRP$S_INTERNAL_STACK = 92;
!  VCRP scratch area.  This area is not guaranteed to be preserved across
!  VCM's.  It is intended to be used as VCM temporary data.
macro VCRP$T_SCRATCH = 212,0,0,0 %;
literal VCRP$S_SCRATCH = 64;
macro VCRP$T_DATA = 276,0,0,0 %;        !  Start of data (if embedded in the VCRP)
 
!*** MODULE $DCBEDEF ***
! +
!  DCBE - Data Chain Block
! 
!  The DCBE is the data structure used to chain data packets together.  A
!  chain may consist of on buffer or may buffers each pointed to by a DCBE.
!  the format of the DCBE is the same as a VCRP data request, so that a 
!  VCRP may be the first DCBE in the chain, and describe the entire 
!  data request.
! 
!  THE FORMAT OF THIS PACKET SHOULD NOT CHANGE WITHOUT CORRESPONDING CHANGES
!  BEING MAY TO A VCRP DATA REQUEST PACKET.
! -
literal DCBE$M_CMN_LOCKED = %X'1';
literal DCBE$M_CMN_RETBUF = %X'2';
literal DCBE$M_CMN_CACHE = %X'4';
literal DCBE$K_DCB_HEADER = 64;         !  Length of DCB header
literal DCBE$S_DCBEDEF = 64;
literal DCBE$S_DCBE = 64;
macro DCBE$L_FLINK = 0,0,32,1 %;        !  Forward Queue link
macro DCBE$L_BLINK = 4,0,32,1 %;        !  Backward Queue link
macro DCBE$W_SIZE = 8,0,16,0 %;         !  Size of structure
macro DCBE$B_TYPE = 10,0,8,0 %;         !  Type of structure - DYN$C_NET
macro DCBE$B_SUB_TYPE = 11,0,8,0 %;     !  Subtype of structure - DYN$C_VCI_DCB
macro DCBE$L_RESERVED = 12,0,0,1 %;
literal DCBE$S_RESERVED = 24;           !  Reserved to ensure that VCRP and
!   DCB look the same up to DCB_HEADER
macro DCBE$R_COMMON_FLAGS_OVERLAY = 36,0,16,0 %;
macro DCBE$W_COMMON_FLAGS = 36,0,16,0 %; !  Common flags used by all users of DCBs
macro DCBE$V_CMN_LOCKED = 36,0,1,0 %;   !  Indicates buffer is locked down for direct I/O
macro DCBE$V_CMN_RETBUF = 36,1,1,0 %;   !  Indicates buffer must be return to owner immediately
macro DCBE$V_CMN_CACHE = 36,2,1,0 %;    !  Indicates buffer came from creator's cache
macro DCBE$B_FLAGS = 38,0,8,0 %;        !  User controlled DCB flags
macro DCBE$B_MODE = 39,0,8,0 %;         !  
macro DCBE$A_DEALLOC_RTN = 40,0,32,0 %; !  Address of routine to deallocate VCRP
macro DCBE$A_DCB_LINK = 44,0,32,0 %;    !  Address of next DCB in chain
macro DCBE$L_SVAPTE = 48,0,32,1 %;      !  Address of System Virtual Address PTE
macro DCBE$L_BUFFER_ADDRESS = 52,0,32,1 %; !  VM Address of buffer specified in SVAPTE
macro DCBE$L_BOFF = 56,0,32,0 %;        !  Offset to start of data in buffer
macro DCBE$L_BCNT = 60,0,32,0 %;        !  Byte count of data in buffer
 
!*** MODULE $VCCDEF ***
! 
!  CFCB - Cache File Control Block
! 
!  There is one CFCB for each cacheable file.  The Cache File Control
!  Block contains the information necessary for consistent data caching
!  in a VAXcluster.  The FCB contains the address of the CFCB.
!  
literal CFCB$M_SEQ = %X'1';
literal CFCB$M_CONFLICT = %X'2';
literal CFCB$M_WRITE = %X'4';
literal CFCB$M_NOLOCK = %X'8';
literal CFCB$M_BUSY = %X'10';
literal CFCB$M_DELAYBLKAST = %X'20';
literal CFCB$M_DELAYCMPLAST = %X'40';
literal CFCB$M_DISBLKFRK = %X'80';
literal CFCB$M_DISCMPLFRK = %X'100';
literal CFCB$M_LIMBO = %X'200';
literal CFCB$M_BYPASS = %X'400';
literal CFCB$M_TRUNCATE = %X'800';
literal CFCB$M_DELETE = %X'1000';
literal CFCB$M_NOPRESERVE = %X'2000';
literal CFCB$K_LENGTH = 152;
literal CFCB$S_CFCBDEF = 152;           !  Old size name - synonym
literal CFCB$S_CFCB = 152;
!  head of CFCB is an ACB which we use as a FKB
macro CFCB$L_ASTQFL = 0,0,32,1 %;       !  AST queue FLINK
macro CFCB$L_ASTQBL = 4,0,32,1 %;       !  AST queue BLINK
macro CFCB$W_SIZE = 8,0,16,0 %;         !  size of CFCB in bytes
macro CFCB$B_TYPE = 10,0,8,0 %;         !  type is VCC, a subtypable structure
macro CFCB$B_SUBTYPE = 11,0,8,0 %;      !  subtype for CFCB and RMODE for ACB
macro CFCB$L_AST_PID = 12,0,32,0 %;     !  either accesser/deacceser or server
macro CFCB$L_AST_ADDR = 16,0,32,1 %;    !  address to resume process
macro CFCB$L_AST_PRM = 20,0,32,0 %;     !  the parameter
!  no KAST field needed
!  end of ACB
!  cells to control access to and type of cache mode lock
macro CFCB$Q_LKSB = 32,0,0,0 %;
literal CFCB$S_LKSB = 8;                !  whole LKSB
macro CFCB$W_LKSB_STATUS = 32,0,16,0 %; !  completion status
macro CFCB$W_RESERVED = 34,0,16,0 %;
macro CFCB$L_LOCKID = 36,0,32,0 %;      !  lockid of cache mode lock
macro CFCB$L_WAIT_PID = 40,0,32,0 %;    !  PID waiting for cache mode lock access
macro CFCB$L_WAIT_ADDR = 44,0,32,1 %;   !  address at which to resume process
macro CFCB$L_WAIT_PRM = 48,0,32,0 %;    !  AST parameter for waiting process
macro CFCB$L_WRITERS = 52,0,32,0 %;     !  number of reasons to keep write lock
macro CFCB$L_HASHTABLE = 56,0,32,1 %;   !  address of hash table data structure
macro CFCB$L_STATUS = 60,0,32,0 %;      !  
macro CFCB$V_SEQ = 60,0,1,0 %;          !  file is being accessed sequentially
!  these next 3 bits must be together
!  they indicate the current cache mode
macro CFCB$V_CONFLICT = 60,1,1,0 %;     !  this node's access conflicts with another node
macro CFCB$V_WRITE = 60,2,1,0 %;        !  set for read/write, clear read only
macro CFCB$V_NOLOCK = 60,3,1,0 %;       !  no cache mode lock held
!  status bits for accessing the cache mode lock
macro CFCB$V_BUSY = 60,4,1,0 %;         !  cache mode lock is being modified
macro CFCB$V_DELAYBLKAST = 60,5,1,0 %;  !  BLKAST arrived while CFCB busy
macro CFCB$V_DELAYCMPLAST = 60,6,1,0 %; !  CMPLAST arrived while CFCB busy
macro CFCB$V_DISBLKFRK = 60,7,1,0 %;    !  disable future blocking forks
macro CFCB$V_DISCMPLFRK = 60,8,1,0 %;   !  disable future completion forks
!  OTHER STATUS BITS
macro CFCB$V_LIMBO = 60,9,1,0 %;        !  set if CFCB in LIMBO
macro CFCB$V_BYPASS = 60,10,1,0 %;      !  If set don't cache IO requests
macro CFCB$V_TRUNCATE = 60,11,1,0 %;    !  If set, need to truncate cache
macro CFCB$V_DELETE = 60,12,1,0 %;
macro CFCB$V_NOPRESERVE = 60,13,1,0 %;  !  If set delete cache at $DEACCESS
!  counts of interesting things
macro CFCB$L_VREAD = 64,0,32,0 %;       !  virtual reads to this file
macro CFCB$L_READHIT = 68,0,32,0 %;     !  read hits to this file
macro CFCB$L_VWRITE = 72,0,32,0 %;      !  virtual writes to this file
macro CFCB$L_WRITEHIT = 76,0,32,0 %;    !  write hits to this file
macro CFCB$L_AROUND = 80,0,32,0 %;      !  read or writes "around" this cache
macro CFCB$L_BLOCKCNT = 84,0,32,0 %;    !  data blocks allocated to this file
macro CFCB$L_CLCNT = 88,0,32,0 %;       !  cache lines allocated to this file
macro CFCB$L_IOERRORS = 92,0,32,0 %;    !  number of I/O errors for this file
macro CFCB$L_LASTVBN = 96,0,32,0 %;     !  last VBN read/written
macro CFCB$L_HIVBN = 100,0,32,0 %;      !  largest VBN ever cached for this file
macro CFCB$L_FCB = 104,0,32,1 %;        !  FCB associated with this CFCB
macro CFCB$L_OCNT = 108,0,32,0 %;       !  Count of Reasons not to delete CFCB
macro CFCB$L_DISABLE = 112,0,32,0 %;    !  number of reasons to disable caching
!  of this file even if cache mode lock
!  will allow caching
!  zero means caching is enabled
macro CFCB$L_LKQ_STATUS = 116,0,32,0 %; !  status of ENQ/DEQ request (not final)
macro CFCB$L_TIME = 120,0,32,0 %;       !  Time put CFCB put in LIMBO 
macro CFCB$Q_LIMBO = 124,0,0,0 %;
literal CFCB$S_LIMBO = 8;               !  Queue of CFCB that are in LIMBO
macro CFCB$L_CID = 132,0,32,0 %;        !  Cache ID 
macro CFCB$L_CVCB = 136,0,32,1 %;       !  VCB address for this file
macro CFCB$T_LOCKNAME = 140,0,0,0 %;
literal CFCB$S_LOCKNAME = 12;           !  XQP lockname
! 
!  HT - Hash Table
! 
!  There is one hash table for each cacheable file.  The Cache File Control
!  Block contains the address of the hash table.  Access requires owning the
!  cache spin lock.
literal HT$Q_HASHTABLE = 24;            !  start of hash table
literal HT$S_HTDEF = 24;                !  Old size name - synonym
literal HT$S_HT = 24;
!  The cache line and hash table sizes are not constants.  They may vary for
!  different files. The size of each must be a power of two. The VBN is
!  subdivided into bitfields based on the cache line size and the size of
!  the hash table.  The lowest bits, <0,CLSIZE-1> represent the offset in
!  the cache line. Bits <CLSIZE-1, HASHSIZE> are the hash index. These
!  fields are accessed via bitfield instructions and the values of CLSIZE
!  and HASHSIZE are encoded to define bitfields NOT the actual size of the
!  entity. 
macro HT$L_CLSIZE = 0,0,32,0 %;         !  encoded cache line size (see above)
macro HT$L_HASHSIZE = 4,0,32,0 %;       !  encoded hash table size (see above)
macro HT$W_SIZE = 8,0,16,0 %;           !  size of hash table strcuture in bytes
macro HT$B_TYPE = 10,0,8,0 %;           !  type is VCC, a subtypable structure
macro HT$B_SUBTYPE = 11,0,8,0 %;        !  subtype for HT
macro HT$L_ENTRIES = 12,0,32,0 %;       !  Entries in HT (if expansion ne 0
!    then actual number is ENTRIES*2)
macro HT$L_EXPANSION = 16,0,32,0 %;     !  Highest Hash currently being
!  expanded
!                             
!  CL - Cache Line
! 
!  A Cache Line is used by the VAXcluster Cache to track per VBN information.
!  The hash table in the CFCB points to cache lines.
!  
literal CL$M_WRITE = %X'10000';
literal CL$M_DELAYTRUNC = %X'20000';
literal CL$K_LENGTH = 64;
literal CL$S_CLDEF = 64;                !  Old size name - synonym    
literal CL$S_CL = 64;
macro CL$L_FLINK = 0,0,32,1 %;          !  Equivalence class forward link
macro CL$L_BLINK = 4,0,32,1 %;          !  Equivalence class back link
macro CL$W_SIZE = 8,0,16,0 %;           !  size of CL in bytes
macro CL$B_TYPE = 10,0,8,0 %;           !  type is VCC, a subtypable structure
macro CL$B_SUBTYPE = 11,0,8,0 %;        !  subtype for CL
macro CL$L_ENTRIES = 12,0,32,0 %;       !  Number of Entries in Use
macro CL$L_EXPANSION = 16,0,32,0 %;     !  Buckets being split
macro CL$L_TIME = 20,0,32,0 %;          !  Time CL last referenced
macro CL$L_FIRSTVBN = 24,0,32,0 %;      !  first VBN in this cache line
macro CL$L_CFCB = 28,0,32,1 %;          !  address of corresponding CFCB 
macro CL$Q_LRUENTRY = 32,0,0,0 %;
literal CL$S_LRUENTRY = 8;              !  absolute queue entry in VCC$Q_LRULINE
macro CL$Q_VALID = 40,0,0,0 %;
literal CL$S_VALID = 8;                 !  set if corresponding VBN data valid
macro CL$Q_DIRTY = 48,0,0,0 %;
literal CL$S_DIRTY = 8;                 !  set if corresponding VBN data
!  needs to be written before block
!  is reused
macro CL$L_LOCK = 56,0,32,0 %;          !   looks just like mutex
macro CL$W_COUNT = 56,0,16,0 %;         !  Count of current accessers
macro CL$V_WRITE = 56,16,1,0 %;         !  write in progress or pending
macro CL$V_DELAYTRUNC = 56,17,1,0 %;    !  delete this line during unlock
macro CL$L_VA = 60,0,32,1 %;            !  virtual addresses for data blocks
! 
!  CPT - Cache I/O Page Table
! 
!  A range of sequential VBNs is not guarenteed to be virtually contiguous
!  in the cache.  Physical I/O requires the SVAPTE which maps the buffer.
!  The cache builds a "fake" page table in this data structure and passes
!  its virtual address as the SVAPTE.  In addition some per I/O cache
!  information is stored here rather than enlarge the IRP.
! 
literal CPT$L_PTE = 32;                 !  start of PTEs(Must be QUAD Aligned)
literal CPT$K_LENGTH = 32;              !  not counting size of VA array
!  which is run time dependent
literal CPT$S_CPTDEF = 32;              !  Old size name - synonym
literal CPT$S_IOCPT = 32;
macro CPT$L_RHBCNT = 0,0,32,0 %;        !  read hit byte count
macro CPT$L_IOVA = 4,0,32,1 %;          !  cache I/O VA
macro CPT$W_SIZE = 8,0,16,0 %;          !  size of CPT in bytes
macro CPT$B_TYPE = 10,0,8,0 %;          !  type is VCC, a subtypable structure
macro CPT$B_SUBTYPE = 11,0,8,0 %;       !  subtype for CPT
macro CPT$L_IOEXTRA = 12,0,32,0 %;      !  read ahead byte count
macro CPT$L_IOVBN = 16,0,32,0 %;        !  cache I/O VBN
macro CPT$L_IOBCNT = 20,0,32,0 %;       !  cache I/O byte count
macro CPT$L_CFCB = 24,0,32,1 %;         !  CFCB address for this I/O
macro CPT$L_FILL1 = 28,0,32,0 %;        !  Force PTEs to QUADWORD
!  real length equals IRP length
! 
!  CVCB - Cache Volume Control Block
! 
!  There is one of these structures for each ODS2 volume currently
!  mounted by this node.  It is used to permit detection of users
!  that perform writes to volumes around the cache, so that the
!  file caches concerned may be flushed.
! 
literal CVCB$M_ON = %X'1';
literal CVCB$M_MISMTCH = %X'2';
literal CVCB$M_DELETE = %X'4';
literal CVCB$M_BSY = %X'8';
literal CVCB$M_CONFLICT = %X'10';
literal CVCB$M_QIRP = %X'20';
literal CVCB$K_LENGTH = 120;
literal CVCB$S_CVCBDEF = 120;           !  Old size name - synonym
literal CVCB$S_CVCB = 120;
macro CVCB$L_FLINK = 0,0,32,1 %;
macro CVCB$L_BLINK = 4,0,32,1 %;
macro CVCB$W_SIZE = 8,0,16,0 %;
macro CVCB$B_TYPE = 10,0,8,0 %;
macro CVCB$B_SUBTYPE = 11,0,8,0 %;
macro CVCB$L_FRK1 = 12,0,32,1 %;        !  Fork Block 
macro CVCB$L_FRK2 = 16,0,32,1 %;        !  Fork Block 
macro CVCB$L_FRK3 = 20,0,32,1 %;        !  Fork Block 
macro CVCB$L_FRK4 = 24,0,32,1 %;        !  Fork Block 
macro CVCB$L_FRK5 = 28,0,32,1 %;        !  Fork Block 
macro CVCB$L_FRK6 = 32,0,32,1 %;        !  Fork Block 
macro CVCB$L_FRK7 = 36,0,32,1 %;        !  Fork Block 
macro CVCB$L_FRK8 = 40,0,32,1 %;        !  Fork Block 
macro CVCB$L_VCB = 44,0,32,1 %;         !  VCB address 
macro CVCB$L_CID = 48,0,32,0 %;         !  Cache ID (monatonicaly increasing)
macro CVCB$L_CLUID = 52,0,32,0 %;       !  Cluster ID (similar to CID)
macro CVCB$L_STATE = 56,0,32,0 %;
macro CVCB$V_ON = 56,0,1,0 %;           !  Set if cache enabled this Volume
macro CVCB$V_MISMTCH = 56,1,1,0 %;      !  Set if not CACHE SAFE Driver 
macro CVCB$V_DELETE = 56,2,1,0 %;       !  Set if Deleteing this CVCB
macro CVCB$V_BSY = 56,3,1,0 %;          !  Set if State change in progress
macro CVCB$V_CONFLICT = 56,4,1,0 %;     !  Set if MISMTCH Set somewhere in
! 	Cluster
macro CVCB$V_QIRP = 56,5,1,0 %;         !  Set if IRP's Q'd waiting for 
!   Cluster Invalidate
macro CVCB$L_OCNT = 60,0,32,0 %;        !  Count of Reasons not to Delete CVCB
macro CVCB$L_MNTCT = 64,0,32,0 %;       !  VCB$W_MNTCT at last State Change
macro CVCB$Q_IRP = 68,0,0,0 %;
literal CVCB$S_IRP = 8;                 !  Q for IRP's
macro CVCB$Q_LKSB = 76,0,0,0 %;
literal CVCB$S_LKSB = 8;                !  whole LKSB
macro CVCB$W_LKSB_STATUS = 76,0,16,0 %; !  completion status
macro CVCB$W_RESERVED = 78,0,16,0 %;
macro CVCB$L_LOCKID = 80,0,32,0 %;      !  lockid of Cache volume lock
macro CVCB$L_SEQ = 84,0,32,0 %;         !  Cluster MEMSEQ for Node Bits
macro CVCB$L_BITS = 88,0,32,0 %;        !  Node bits 
macro CVCB$L_BITS1 = 92,0,32,0 %;
macro CVCB$L_BITS2 = 96,0,32,0 %;
macro CVCB$L_BITS3 = 100,0,32,0 %;
macro CVCB$L_BITS4 = 104,0,32,0 %;
macro CVCB$L_BITS5 = 108,0,32,0 %;
macro CVCB$L_BITS6 = 112,0,32,0 %;
macro CVCB$L_BITS7 = 116,0,32,0 %;
!  
!  Bits in SYSGEN parameter CACHE$GL_FLAGS
!  This is actually 4 one byte sysgen parameters.
! 	CACHE$GB_FLAGS0 - user "visible" dynamic
! 	CACHE$GB_FLAGS1 - user "visible" static
! 	CACHE$GB_FLAGS2 - user "invisible" dynamic
! 	CACHE$GB_FLAGS3 - user "invisible" static
!  
literal CACHE$M_ON = %X'1';
literal CACHE$M_PROTOCOL_ONLY = %X'2';
literal CACHE$M_READ_AHEAD = %X'4';
literal CACHE$M_UPDATE_ON_WRTE = %X'8';
literal CACHE$S_CACHEDEF = 1;           !  Old size name - synonym
literal CACHE$S_CACHEFLAGS = 1;
macro CACHE$V_ON = 0,0,1,0 %;           !  Turn on caching
macro CACHE$V_PROTOCOL_ONLY = 0,1,1,0 %; !  Run the cache protocal, but
!   don't cache anything.
macro CACHE$V_READ_AHEAD = 0,2,1,0 %;   !  Allow Read Ahead
macro CACHE$V_UPDATE_ON_WRTE = 0,3,1,0 %; !  Update on Write Alogrithm
!  Define bits in CACHE$GL_STATE
! 
literal CACHE_STATE$M_LBSY = %X'1';
literal CACHE_STATE$M_MBSY = %X'2';
literal CACHE_STATE$M_LOCK = %X'4';
literal CACHE_STATE$M_PAK = %X'8';
literal CACHE_STATE$M_ON = %X'10';
literal CACHE_STATE$M_IMG = %X'20';
literal CACHE_STATE$M_HETERO = %X'40';
literal CACHE_STATE$M_FLUSH = %X'80';
literal CACHE_STATE$M_UPDWRT = %X'100';
literal CACHE_STATE$M_RDAHD = %X'200';
literal CACHE_STATE$M_SAFE = %X'400';
literal CACHE_STATE$M_DATA = %X'800';
literal CACHE_STATE$M_USERSIZE = %X'1000';
literal CACHE_STATE$M_ENABLED = %X'2000';
literal CACHE_STATE$S_CACHESTATEDEF = 2; !  Old size name - synonym
literal CACHE_STATE$S_CACHESTATE = 2;
macro CACHE_STATE$V_LBSY = 0,0,1,0 %;   !  Cache master lock busy
macro CACHE_STATE$V_MBSY = 0,1,1,0 %;   ! 
macro CACHE_STATE$V_LOCK = 0,2,1,0 %;   !  Cache master lock acquired
macro CACHE_STATE$V_PAK = 0,3,1,0 %;    !  VCC PAK enabled
macro CACHE_STATE$V_ON = 0,4,1,0 %;     !  Cache enabled
macro CACHE_STATE$V_IMG = 0,5,1,0 %;    !  Image cache enabled
macro CACHE_STATE$V_HETERO = 0,6,1,0 %; !  Heterogenous cluster
macro CACHE_STATE$V_FLUSH = 0,7,1,0 %;  !  Flush cache contents
macro CACHE_STATE$V_UPDWRT = 0,8,1,0 %; !  Populate on update write only
macro CACHE_STATE$V_RDAHD = 0,9,1,0 %;  !  Read ahead enabled
macro CACHE_STATE$V_SAFE = 0,10,1,0 %;  !  Cache safe derivers present
macro CACHE_STATE$V_DATA = 0,11,1,0 %;  !  Data cache enabled
macro CACHE_STATE$V_USERSIZE = 0,12,1,0 %; !  User has sized cache
macro CACHE_STATE$V_ENABLED = 0,13,1,0 %; !  Caching enabled
!  Define item codes for GET_STAT
! 
literal CACHE_ITEM$_LISTEND = 0;        !  List terminator
literal CACHE_ITEM$_STATE = 1;          !  State flags
literal CACHE_ITEM$_CACHE_MEMORY = 2;   !  Pages of cache memory
literal CACHE_ITEM$_FREE_CACHE = 3;     !  Free page of cache memory
literal CACHE_ITEM$_READ_HITS = 4;      !  Read hits
literal CACHE_ITEM$_VIRT_READS = 5;     !  Virtual reads to cacheable files
literal CACHE_ITEM$_VIRT_WRITES = 6;    !  Virtual writes to cacheable files
literal CACHE_ITEM$_R_ARND_MOD = 7;     !  Read arounds du to modifier bits
literal CACHE_ITEM$_R_ARND_SIZ = 8;     !  Read arounds due to size too large
literal CACHE_ITEM$_W_ARND_MOD = 9;     !  Write arounds due to modifier bits
literal CACHE_ITEM$_W_ARND_SIZ = 10;    !  Write arounds due to size too large
literal CACHE_ITEM$_LIMBO_LEN = 11;     !  Length of limbo queue
literal CACHE_ITEM$_MAX_ITEM = 12;      !  One more than max item code
 
!*** MODULE SSVECDEF ***
literal SSVEC_K_LENGTH = 16;            !  Size of list element
literal SSVEC_S_SSVECDEF = 16;          !  Old size name - synonym
literal SSVEC_S_SSVEC = 16;
macro SSVEC_L_TOUCH_STACK = 0,0,32,1 %; !  Touch user's stack 
macro SSVEC_L_SAVESP = 4,0,32,1 %;      !  Save Caller's SP
macro SSVEC_L_LDA_CODE = 8,0,32,0 %;    !  Load CHM code into R0
macro SSVEC_L_CHMX = 12,0,32,0 %;       !  CHMx instruction
 
!*** MODULE DISPDEF ***
literal DISP_K_LENGTH = 16;             !  Size of list element
literal DISP_S_DISPDEF = 16;            !  Old size name - synonym
literal DISP_S_DISP = 16;
macro DISP_A_SERVICE_ROUTINE = 0,0,32,0 %; !  Address of first instruction of
!   service-specific procedure
macro DISP_A_ENTRY_POINT = 4,0,32,0 %;  !  Actual code address
macro DISP_B_FLAGS = 8,0,8,0 %;         !  Flags
 
!*** MODULE SSDESCRDEF ***
literal EXIT_K_NORMAL_EXIT = 0;         !  Default exit code
literal EXIT_K_RMS_STALL = 1;           !  RMS wait for I/O completion
literal EXIT_K_RMS_WAIT = 2;            !  RMS $WAIT eit code
literal EXIT_K_ASSIGN_EXIT = 3;         !  Special exit code for $ASSIGN to perform
!  assign to network object in caller's mode.
literal SSFLAG_K_WCM = 1;               !  May return WCM	
literal SSFLAG_K_WCM_NO_REEXEC = 2;     !  Don't reexecute 
literal SSFLAG_K_CLRREG = 4;            !  Clear scratch regs
literal SSFLAG_K_RETURN_ANY = 8;        !  May return any val
literal SSFLAG_K_WCM_NO_SAVE = 16;      !  Don't save regs
literal SSFLAG_K_STACK_ARGS = 32;       ! pointer->stack args
literal SSDESCR_M_CLASS_0 = %X'1';
literal SSDESCR_M_CLASS_1 = %X'2';
literal SSDESCR_M_CLASS_2 = %X'4';
literal SSDESCR_M_CLASS_3 = %X'8';
literal SSDESCR_M_CLASS_4 = %X'10';
literal SSDESCR_M_CLASS_5 = %X'20';
literal SSDESCR_M_CLASS_6 = %X'40';
literal SSDESCR_M_CLASS_7 = %X'80';
literal MODE_K_KERNEL = 0;              !  Service executes in KERNEL mode
literal MODE_K_EXEC = 1;                !  Service executes in EXECUTIVE mode
literal MODE_K_SUPER = 2;               !  Service executes in SUPERVISOR mode
literal MODE_K_USER = 3;                !  Service executes in USER mode
literal MODE_K_CALLERS_MODE = 4;        !  Service executes in the mode of the caller
literal TYPE_K_NORMAL = 0;              !  No composite type, default value
literal TYPE_K_QIOW = 1;                !  Composite type QIOW
literal TYPE_K_ENQW = 2;                !  Composite type ENQW
literal TYPE_K_GETDVIW = 3;             !  Composite type GETDVIW
literal TYPE_K_GETJPIW = 4;             !  Composite type GETJPIW
literal TYPE_K_GETSYIW = 5;             !  Composite type GETSYIW
literal TYPE_K_SNDJBCW = 6;             !  Composite type SNDJBCW
literal TYPE_K_GETLKIW = 7;             !  Composite type GETLKIW
literal TYPE_K_BRKTHRUW = 8;            !  Composite type BRKTHRUW
literal TYPE_K_GETQUIW = 9;             !  Composite type GETQUIW
literal TYPE_K_END_RU = 10;             !  Composite type END_RU
literal TYPE_K_START_TRANSW = 11;       !  Composite type START_TRANS
literal TYPE_K_END_TRANSW = 12;         !  Composite type END_TRANS
literal TYPE_K_ABORT_TRANSW = 13;       !  Composite type ABORT_TRANS
literal TYPE_K_DECLARE_RMW = 14;        !  Composite type DECLARE_RM
literal TYPE_K_FORGET_RMW = 15;         !  Composite type FORGET_RM
literal TYPE_K_JOIN_RMW = 16;           !  Composite type JOIN_RM
literal TYPE_K_FINISH_RMOPW = 17;       !  Composite type FINISH_RMOP
literal TYPE_K_ADD_BRANCHW = 18;        !  Composite type ADD_BRANCH
literal TYPE_K_START_BRANCHW = 19;      !  Composite type START_BRANCH
literal TYPE_K_IPCW = 20;               !  Composite type IPCW
literal TYPE_K_END_BRANCHW = 21;        !  Composite type END_BRANCHW
literal TYPE_K_AUDIT_EVENTW = 22;       !  Composite type AUDIT_EVENTW
literal TYPE_K_CHECK_PRIVILEGEW = 23;   !  Composite type CHECK_PRIVILEGE
literal TYPE_K_MAXIMUM = 24;            !  Maximum number of types
literal SSDESCR_S_SSDESCR = 16;
macro SSDESCR_A_VECTOR_ADDRESS = 0,0,32,0 %; !  Address of vector in S0 space
macro SSDESCR_A_ENTRY_ADDRESS = 4,0,32,0 %; !  Self-relative pointer to .ENTRY mask
macro SSDESCR_B_SYNCH_TYPE = 8,0,8,0 %; !  Composite service type
macro SSDESCR_B_FLAGS = 9,0,8,0 %;      !  Flags
macro SSDESCR_B_INHIBIT_MASK = 10,0,8,0 %; !  System service inhibit mask
macro SSDESCR_V_CLASS_0 = 10,0,1,0 %;
macro SSDESCR_V_CLASS_1 = 10,1,1,0 %;
macro SSDESCR_V_CLASS_2 = 10,2,1,0 %;
macro SSDESCR_V_CLASS_3 = 10,3,1,0 %;
macro SSDESCR_V_CLASS_4 = 10,4,1,0 %;
macro SSDESCR_V_CLASS_5 = 10,5,1,0 %;
macro SSDESCR_V_CLASS_6 = 10,6,1,0 %;
macro SSDESCR_V_CLASS_7 = 10,7,1,0 %;
macro SSDESCR_B_MODE = 11,0,8,0 %;      !  Access mode in which service executes
macro SSDESCR_L_UNUSED = 12,0,32,0 %;   !  Longword of padding, currently unused
literal SSDESCR_K_LENGTH = 16;          !  Size of list element
literal SSDESCR_S_SSDESCRDEF = 16;      !  Old size name - synonym
 
!*** MODULE $VL1DEF ***
! +
!  VOL1 ANSI MAGNETIC TAPE LABEL
!  THIS IS THE FIRST BLOCK ON EVERY ANSI LABELED MAGNETIC TAPE.
!  IT IDENTIFIES THE VOLUME AND ITS PROTECTION.
! -
literal VL1$S_VL1DEF = 80;
literal VL1$S_VL1 = 80;
macro VL1$L_VL1LID = 0,0,32,0 %;        ! LABEL IDENTIFIER AND NUMBER 'VOL1' 
macro VL1$T_VOLLBL = 4,0,0,0 %;
literal VL1$S_VOLLBL = 6;               ! VOLUME LABEL 
macro VL1$B_VOLACCESS = 10,0,8,0 %;     ! VOLUME ACCESS 
macro VL1$T_SYSCODE = 24,0,0,0 %;
literal VL1$S_SYSCODE = 13;             !  SYSTEM CODE
macro VL1$T_OWNER_IDENT = 37,0,0,0 %;
literal VL1$S_OWNER_IDENT = 14;         !  VOL1 OWNER ID FIELD
macro VL1$T_VOLOWNER = 37,0,0,0 %;
literal VL1$S_VOLOWNER = 13;            ! VOLUME OWNER IDENTIFICATION 
macro VL1$B_DECSTDVER = 50,0,8,0 %;     ! DEC STANDARD VERSION 
macro VL1$B_LBLSTDVER = 79,0,8,0 %;     ! LABEL STANDARD VERSION '3' 
 
!*** MODULE $VL2DEF ***
! +
!  VOL2 ANSI MAGNETIC TAPE LABEL
!  THIS IS BLOCK IS WRITTEN TO TAPES WHEN A VMS PROTECTION IS SPECIFIED
! -
literal VL2$S_VL2DEF = 19;
literal VL2$S_VL2 = 19;
macro VL2$L_VL2LID = 0,0,32,0 %;        ! LABEL IDENTIFIER AND NUMBER 'VOL2' 
macro VL2$T_VOLOWNER = 4,0,0,0 %;
literal VL2$S_VOLOWNER = 15;            ! VOLUME OWNER IDENTIFICATION 
 
!*** MODULE $VLEDEF ***
! 
!  VLE (Vector List Extension)
!  This structure is used to hold the list of interrupt vectors used by a
!  particular controller when the controller requires more than one vector.
!  If the VLE flag in an IDB is set, the field IDB$L_VECTOR points to this
!  structure.
! 
literal VLE$K_LENGTH = 12;
literal VLE$C_LENGTH = 12;
literal VLE$S_VLEDEF = 12;              !  Old size name - synonym    
literal VLE$S_VLE = 16;
macro VLE$PS_IDB = 0,0,32,1 %;          !  pointer to parent IDB
macro VLE$L_NUMVEC = 4,0,32,0 %;        !  number of vector entries in the VLE
macro VLE$W_SIZE = 8,0,16,0 %;          !  size of this structure
macro VLE$B_TYPE = 10,0,8,0 %;          !  structure type
macro VLE$B_SUBTYPE = 11,0,8,0 %;       !  structure subtype
!  VECTOR_LIST is an array of unsigned longwords containing the appropriate
!  byte offset into either the SCB or the ADP vector table.
!  put the constant's in front of the definition of vector list so that the
!  header size constants stay the same.
macro VLE$L_VECTOR_LIST = 12,0,32,1 %;
literal VLE$S_VECTOR_LIST = 4;          !  beginning of interrupt vector list
 
!*** MODULE $WCBDEF ***
! +
!  WCB - WINDOW CONTROL BLOCK
! 
!  THERE IS A WINDOW CONTROL BLOCK FOR EACH FILE ACCESSED BY A PROCESS.
!  IT CONTAINS MAPPING INFORMATION SUCH THAT A LARGE PERCENTAGE OF VIRTUAL
!  FILE I/O CAN BE MAPPED FROM VIRTUAL TO LOGICAL BLOCK NUMBERS WITHOUT
!  HAVING TO READ THE RESPECTIVE FILE HEADER.
! -
literal WCB$M_READ = %X'1';
literal WCB$M_WRITE = %X'2';
literal WCB$M_NOTFCP = %X'4';
literal WCB$M_SHRWCB = %X'8';
literal WCB$M_OVERDRAWN = %X'10';
literal WCB$M_COMPLETE = %X'20';
literal WCB$M_CATHEDRAL = %X'40';
literal WCB$M_EXPIRE = %X'80';
literal WCB$M_CONTROL = %X'1000';
literal WCB$M_NO_READ_DATA = %X'2000';
literal WCB$K_MAP = 56;                 !  MAP POINTERS START HERE 
literal WCB$C_MAP = 56;                 !  MAP POINTERS START HERE 
literal WCB$K_LENGTH = 56;              !  LENGTH OF STANDARD WCB SANS POINTERS 
literal WCB$C_LENGTH = 56;              !  LENGTH OF STANDARD WCB SANS POINTERS 
!  NOTE THAT VIRTUAL MAPPING
literal WCB$S_WCBDEF = 80;              !  Old size name - synonym
literal WCB$S_WCB = 80;
macro WCB$L_WLFL = 0,0,32,1 %;          !  WINDOW LIST FORWARD LINK 
macro WCB$L_WLBL = 4,0,32,1 %;          !  WINDOW LIST BACKWARD LINK 
macro WCB$W_SIZE = 8,0,16,0 %;          !  SIZE OF WINDOW BLOCK IN BYTES 
macro WCB$B_TYPE = 10,0,8,0 %;          !  STRUCTURE TYPE OF WCB 
macro WCB$B_ACCESS = 11,0,8,0 %;        !  ACCESS CONTROL BYTE 
macro WCB$V_READ = 11,0,1,0 %;          !  READ ACCESS ALLOWED (1=YES) 
macro WCB$V_WRITE = 11,1,1,0 %;         !  WRITE ACCESS ALLOWED (1=YES) 
macro WCB$V_NOTFCP = 11,2,1,0 %;        !  FILE NOT ACCESSED BY FCP IF SET 
macro WCB$V_SHRWCB = 11,3,1,0 %;        !  SHARED WINDOW 
macro WCB$V_OVERDRAWN = 11,4,1,0 %;     !  FILE ACCESSOR HAS OVERDRAWN HIS QUOTA 
macro WCB$V_COMPLETE = 11,5,1,0 %;      !  SET WINDOW MAPS ENTIRE FILE 
macro WCB$V_CATHEDRAL = 11,6,1,0 %;     !  LARGE, COMPLEX WINDOW (SIC) TO MAP 
!  FILE COMPLETELY
macro WCB$V_EXPIRE = 11,7,1,0 %;        !  FILE EXPIRATION DATE MAY NEED TO BE SET 
macro WCB$L_PID = 12,0,32,0 %;          !  PROCESS ID OF ACCESSOR PROCESS 
macro WCB$L_REFCNT = 16,0,32,0 %;       !  REFERENCE COUNT FOR SHARED WINDOW 
macro WCB$L_ORGUCB = 20,0,32,1 %;       !  ADDRESS OF ORIGINAL UCB FROM CCB 
macro WCB$L_ACON = 24,0,32,0 %;         !  ACCESS CONTROL INFORMATION 
!  NOTE - THESE BITS TRACK THE BITS
!  IN FIB$L_ACCTL
macro WCB$V_NOWRITE = 24,0,1,0 %;       !  NO OTHER WRITERS 
macro WCB$V_DLOCK = 24,1,1,0 %;         !  ENABLE DEACCESS LOCK 
macro WCB$V_SPOOL = 24,4,1,0 %;         !  SPOOL FILE ON CLOSE 
macro WCB$V_WRITECK = 24,5,1,0 %;       !  ENABLE WRITE CHECK 
macro WCB$V_SEQONLY = 24,6,1,0 %;       !  SEQUENTIAL ONLY ACCESS 
macro WCB$V_SNAPSHOT = 24,7,1,0 %;      !  SNAPSHOT REVALIDATION PENDING
macro WCB$V_WRITEAC = 24,8,1,0 %;       !  WRITE ACCESS 
macro WCB$V_READCK = 24,9,1,0 %;        !  ENABLE READ CHECK 
macro WCB$V_NOREAD = 24,10,1,0 %;       !  NO OTHER READERS 
macro WCB$V_NOTRUNC = 24,11,1,0 %;      !  NO TRUNCATES 
macro WCB$V_CONTROL = 24,12,1,0 %;      !  CONTROL ACCESS TO FILE
macro WCB$V_NO_READ_DATA = 24,13,1,0 %; !  NO READ ACCESS TO FILE DATA
!  THE FOLLOWING FIELD OVERLAYS THE FIRST
!  UNUSED FLAG IN WCB$W_ACON ABOVE.
macro WCB$V_NOACCLOCK = 24,2,1,0 %;     !  NO ACCESS LOCK CHECKING
macro WCB$V_READINIT = 24,14,1,0 %;     !  A READINIT WAS DONE OVER THIS CHANNEL 
macro WCB$V_WRITE_TURN = 24,15,1,0 %;   !  FORCE WINDOW TURN ON WRITES
!  SIZE DEVICE INDEPENDENT PART OF WCB
macro WCB$L_NMAP = 28,0,32,0 %;         !  NUMBER OF MAPPING POINTERS 
macro WCB$L_FCB = 32,0,32,1 %;          !  ADDRESS OF FCB 
macro WCB$L_RVT = 36,0,32,1 %;          !  ADDRESS OF RELATIVE VOLUME TABLE 
macro WCB$L_LINK = 40,0,32,1 %;         !  LINK TO NEXT WINDOW SEGMENT 
macro WCB$L_READS = 44,0,32,0 %;        !  COUNT OF READS PERFORMED 
macro WCB$L_WRITES = 48,0,32,0 %;       !  COUNT OF WRITES PERFORMED 
macro WCB$L_STVBN = 52,0,32,0 %;        !  STARTING VBN MAPPED BY WINDOW 
!  NEEDS P1_COUNT IMMEDIATELY
!  FOLLOWING STVBN
macro WCB$W_P1_COUNT = 56,0,16,0 %;     !  TMP
macro WCB$L_P1_COUNT = 56,0,32,0 %;     !  COUNT FIELD OF FIRST POINTER 
macro WCB$L_P1_LBN = 60,0,32,0 %;       !  LBN FIELD OF SECOND POINTER 
macro WCB$L_P1_RVN = 64,0,32,0 %;       !  RVN OF FIRST POINTER
macro WCB$Q_DELIQ = 56,0,0,0 %;
literal WCB$S_DELIQ = 8;                !  DELETE PENDIONG QUEUE
macro WCB$L_P2_COUNT = 68,0,32,0 %;     !  COUNT FIELD OF SECOND POINTER 
macro WCB$L_P2_LBN = 72,0,32,0 %;       !  LBN FIELD OF FIRST POINTER 
macro WCB$L_P2_RVN = 76,0,32,0 %;       !  RVN OF SECOND POINTER
!  FORMAT OF RETRIEVAL POINTER
literal WCB$S_WCBDEF1 = 12;             !  Old size name - synonym
literal WCB$S_WCB1 = 12;
macro WCB$L_COUNT = 0,0,32,0 %;         !  COUNT FIELD 
macro WCB$L_LBN = 4,0,32,0 %;           !  LBN FIELD 
macro WCB$L_RVN = 8,0,32,0 %;           !  RVN FIELD
literal WCB$S_WCBDEF2 = 13;             !  Old size name - synonym
literal WCB$S_WCB2 = 13;
macro WCB$L_PREVCOUNT = -12,0,32,0 %;   !  PREVIOUS RETRIEVAL POINTER 
macro WCB$L_PREVLBN = -8,0,32,0 %;
macro WCB$L_PREVRVN = -4,0,32,0 %;
!  RETRIEVAL POINTER FORMAT
 
!*** MODULE $WSLDEF ***
! +
!  WORKING SET LIST DEFINITIONS
! -
literal WSL$M_VALID = %X'1';
literal WSL$M_PAGTYP = %X'E';
literal WSL$M_PFNLOCK = %X'10';
literal WSL$M_WSLOCK = %X'20';
literal WSL$M_GOODPAGE = %X'40';
literal WSL$M_MODIFY = %X'100';
literal WSL$C_LENGTH = 4;               !  Size of WS list entry
! 
literal WSL$C_PROCESS = 0;              !  Process page
literal WSL$C_SYSTEM = 2;               !  System page
literal WSL$C_GLOBAL = 4;               !  Global page (read only)
literal WSL$C_GBLWRT = 6;               !  Global Writable page
literal WSL$C_PPGTBL = 8;               !  Process Page Table
literal WSL$C_GPGTBL = 10;              !  Global Page Table
literal WSL$C_RESERVED = 12;            !   reserved
literal WSL$C_UNKNOWN = 14;             !  Uninitialized db for this PFN (should never appear in WS)
literal WSL$S_WSLDEF = 2;
literal WSL$S_WSL = 2;
!  THE FOLLOWING 5 BITS MUST BE IN ORDER
macro WSL$V_VALID = 0,0,1,0 %;          !  WSL entry Valid
macro WSL$V_PAGTYP = 0,1,3,0 %;
literal WSL$S_PAGTYP = 3;               !  Page type (see $PFNDEF for values)
macro WSL$V_PFNLOCK = 0,4,1,0 %;        !  Page frame lock
!  THE PRECEDING 5 BITS MUST BE IN ORDER
macro WSL$V_WSLOCK = 0,5,1,0 %;         !  Working set lock
macro WSL$V_GOODPAGE = 0,6,1,0 %;       !  This page should remain in WS one more pass
macro WSL$V_MODIFY = 0,8,1,0 %;         !  Saved modify bit
!  PAGE TYPE VIELD DEFINITIONS
! 
! 	These constants have been adjusted by left-shifting the constant by the offset to the field WSL$V_PAGTYP.
! 	To use these when explicitly extracting the field, the adjustment must be removed.  For example:
! 
! 		   IF .wsle [wsl$v_pagtyp] EQL (wsl$c_system ^-wsl$v_pagtyp)
! 
 
!*** MODULE $WQHDEF ***
! +
!  WAIT QUEUE HEADER DEFINITIONS
! -
literal WQH$K_LENGTH = 16;              ! LENGTH OF WAIT QUEUE HEADER 
literal WQH$C_LENGTH = 16;              ! LENGTH OF WAIT QUEUE HEADER 
literal WQH$S_WQHDEF = 16;
literal WQH$S_WQH = 16;
macro WQH$L_WQFL = 0,0,32,1 %;          ! HEAD OR FORWARD LINK 
macro WQH$L_WQBL = 4,0,32,1 %;          ! TAIL OR BACKWARD LINK 
macro WQH$L_WQCNT = 8,0,32,0 %;         ! WAIT QUEUE COUNT 
macro WQH$L_WQSTATE = 12,0,32,0 %;      ! STATE NUMBER FOR WAIT 
 
!*** MODULE $XMIDEF ***
! +
!  XMI Required Registers
! -
literal XMI$C_IO_CLASS = 32;
literal XMI$C_MEMORY_CLASS = 64;
literal XMI$C_CPU_CLASS = 128;
! 
literal XMI$C_READ = 1;
literal XMI$C_IREAD = 2;
literal XMI$C_UWMASK = 6;
literal XMI$C_WMASK = 7;
literal XMI$C_INTR = 8;
literal XMI$C_IDENT = 9;
literal XMI$C_IVINTR = 15;
!  XMI-2 additional commands
literal XMI$C_OREAD = 3;
literal XMI$C_DWMASK = 4;
literal XMI$C_TBDATA = 11;
literal XMI$M_EMP = %X'2';
literal XMI$M_DXTO = %X'4';
literal XMI$M_EHWW = %X'8';
literal XMI$M_FCMD = %X'F';
literal XMI$M_FCID = %X'3F0';
literal XMI$M_STF = %X'400';
literal XMI$M_ETF = %X'800';
literal XMI$M_NSES = %X'1000';
literal XMI$M_TTO = %X'2000';
literal XMI$M_TE = %X'4000';
literal XMI$M_CNAK = %X'8000';
literal XMI$M_RER = %X'10000';
literal XMI$M_RSE = %X'20000';
literal XMI$M_NRR = %X'40000';
literal XMI$M_CRD = %X'80000';
literal XMI$M_WDNAK = %X'100000';
literal XMI$M_RIDNAK = %X'200000';
literal XMI$M_WSE = %X'400000';
literal XMI$M_PE = %X'800000';
literal XMI$M_IPE = %X'1000000';
literal XMI$M_WEI = %X'2000000';
literal XMI$M_XFAULT = %X'4000000';
literal XMI$M_CC = %X'8000000';
literal XMI$M_XBAD = %X'10000000';
literal XMI$M_NHALT = %X'20000000';
literal XMI$M_NRESET = %X'40000000';
literal XMI$M_ES = %X'80000000';
literal XMI$M_SLEEP_MODE = %X'40000000';
literal XMI$M_FAEM_ENABLE = %X'80000000';
literal XMI$M_LOCMOD = %X'3';
literal XMI$M_XBADD = %X'4';
literal XMI$M_CRDID = %X'10000';
literal XMI$M_CCID = %X'20000';
literal XMI$M_SEO = %X'1';
literal XMI$M_OLR = %X'2';
literal XMI$M_URR = %X'4';
literal XMI$S_XMIDEF = 1592;            !  Old size name - synonym
literal XMI$S_XMI = 1592;
macro XMI$L_XDEV = 0,0,32,0 %;          !  XMI Device register
macro XMI$W_DTYPE = 0,0,16,0 %;         !  Device type
macro XMI$B_DEV_ID = 0,0,8,0 %;         !  Device ID
macro XMI$B_CLASS = 1,0,8,0 %;          !  Device class
macro XMI$W_DREV = 2,0,16,0 %;          !  Device Revision
!  XMI commands
! 
macro XMI$L_XBE = 4,0,32,0 %;           !  XMI Bus Error register
macro XMI$$_FILL_1 = 4,0,1,0 %;         !  Reserved bit
macro XMI$V_EMP = 4,1,1,0 %;            !  Enable More Protocol
macro XMI$V_DXTO = 4,2,1,0 %;           !  Disable XMI Timeout
macro XMI$V_EHWW = 4,3,1,0 %;           !  Enable HexaWord Write
macro XMI$V_FCMD = 4,0,4,0 %;
literal XMI$S_FCMD = 4;                 !  Failing Command (Pre V1.4)
macro XMI$V_FCID = 4,4,6,0 %;
literal XMI$S_FCID = 6;                 !  Failing Commander ID
macro XMI$V_STF = 4,10,1,0 %;           !  Self-test fail
macro XMI$V_ETF = 4,11,1,0 %;           !  Extended Test fail
macro XMI$V_NSES = 4,12,1,0 %;          !  Node-specific Err. Summary
macro XMI$V_TTO = 4,13,1,0 %;           !  Transaction timeout
macro XMI$V_TE = 4,14,1,0 %;            !  Transmit error
macro XMI$V_CNAK = 4,15,1,0 %;          !  Command NoAck
macro XMI$V_RER = 4,16,1,0 %;           !  Read Error Response
macro XMI$V_RSE = 4,17,1,0 %;           !  Read Sequence Error
macro XMI$V_NRR = 4,18,1,0 %;           !  No Read Response
macro XMI$V_CRD = 4,19,1,0 %;           !  Corrected Read Data
macro XMI$V_WDNAK = 4,20,1,0 %;         !  Write Data NoACk
macro XMI$V_RIDNAK = 4,21,1,0 %;        !  Read/IDENT Data NoAck
macro XMI$V_WSE = 4,22,1,0 %;           !  Write Sequence Error
macro XMI$V_PE = 4,23,1,0 %;            !  Parity Error
macro XMI$V_IPE = 4,24,1,0 %;           !  Inconsistent Parity Error
macro XMI$V_WEI = 4,25,1,0 %;           !  Write Error Interrupt
macro XMI$V_XFAULT = 4,26,1,0 %;        !  XMI Fault
macro XMI$V_CC = 4,27,1,0 %;            !  Corrected Confirmation
macro XMI$V_XBAD = 4,28,1,0 %;          !  XMI Bad
macro XMI$V_NHALT = 4,29,1,0 %;         !  Node Halt
macro XMI$V_NRESET = 4,30,1,0 %;        !  Node Reset
macro XMI$V_ES = 4,31,1,0 %;            !  Error Summary
macro XMI$L_XFAD = 8,0,32,0 %;          !  XMI Failing Address (physical) register
macro XMI$L_XFADR0 = 8,0,32,0 %;        !  XMI Failing Address (physical) register
macro XMI$V_FADR = 8,0,30,0 %;
literal XMI$S_FADR = 30;                !  Failing Address
macro XMI$V_FLN = 8,30,2,0 %;
literal XMI$S_FLN = 2;                  !  Failing length
!   register. This is identical
!   to other node's XFAER except
!   that for the XJA it is here
!   at bb+C rather than at bb+2C.
macro XMI$L_XJA_XFADRB = 12,0,32,0 %;   !  XJA Failing Address register (physical) Ext.
!  For the field definitions, use
!   those defined below for XFAER.
macro XMI$L_XGPR = 12,0,32,0 %;         !  XMI General Purpose register
macro XMI$L_XJA_XGPR = 16,0,32,0 %;     !  XJA's General Purpose Register.
macro XMI$L_XCOMM = 16,0,32,0 %;        !  XMI Communication register
macro XMI$L_XJA_XFAEMCTL = 20,0,32,0 %; !  XJA's FAEM Control Register
macro XMI$V_XBI_WINDOW_MASK = 20,0,16,0 %;
literal XMI$S_XBI_WINDOW_MASK = 16;     !  XBI Window Space Mask
macro XMI$V_SLEEP_MODE = 20,30,1,0 %;   !  Set Sleep Mode
macro XMI$V_FAEM_ENABLE = 20,31,1,0 %;  !  Enable FAEM
macro XMI$L_XJA_AOSTS = 24,0,32,0 %;    !  XJA's Add On Self Test Status Register
macro XMI$L_XJA_SERNUM = 28,0,32,0 %;   !  XJA's Serial Number Register
macro XMI$V_SERIAL_NUMBER = 28,0,17,0 %;
literal XMI$S_SERIAL_NUMBER = 17;       !  Serial Number
macro XMI$V_PLANT = 28,17,4,0 %;
literal XMI$S_PLANT = 4;                !  Manufacturing Plant.
macro XMI$V_REV = 28,21,4,0 %;
literal XMI$S_REV = 4;                  !  Revision Level.
macro XMI$V_VARI = 28,25,4,0 %;
literal XMI$S_VARI = 4;                 !  Variation.
macro XMI$L_NSCSR = 28,0,32,0 %;        !  XMI-1 Node specific CSR
macro XMI$L_NSCSR0 = 28,0,32,0 %;       !  XMI-2 Node specific CSR
macro XMI$L_XBCR = 36,0,32,0 %;         !  XMI-1 Bus control register
macro XMI$L_XBCR0 = 36,0,32,0 %;        !  XMI-2 Bus control register
macro XMI$V_LOCMOD = 36,0,2,0 %;
literal XMI$S_LOCMOD = 2;               !  Lockout mode bits
macro XMI$V_XBADD = 36,2,1,0 %;         !  XMI Bad Drive
macro XMI$V_CRDID = 36,16,1,0 %;        !  Corrected Read Int. disable
macro XMI$V_CCID = 36,17,1,0 %;         !  Corrected Conf. Int. disable
macro XMI$L_XFAER = 44,0,32,0 %;        !  XMI-1 Failing Address (physical) Ext register
macro XMI$L_XFAER0 = 44,0,32,0 %;       !  XMI-2 Failing Address (physical) Ext register
macro XMI$V_MASK = 44,0,16,0 %;
literal XMI$S_MASK = 16;                !  Failing Mask
macro XMI$V_ADDREXT = 44,16,10,0 %;
literal XMI$S_ADDREXT = 10;             !  Failing Address Extension bits [38:29]
macro XMI$$_FILL_3 = 44,26,2,0 %;
literal XMIS_FILL_3 = 2;                !  Reserved bits
macro XMI$V_FCMDX = 44,28,4,0 %;
literal XMI$S_FCMDX = 4;                !  Failing Command
!  End of XMI-1 Register.  The addition register only apply to XMI-2.
macro XMI$L_XBEER = 52,0,32,0 %;        !  XMI-1 Bus Error extension
macro XMI$L_XBEER0 = 52,0,32,0 %;       !  XMI-2 Bus Error extension
macro XMI$V_SEO = 52,0,1,0 %;           !  Second Error Occured
macro XMI$V_OLR = 52,1,1,0 %;           !  Only LOC Response
macro XMI$V_URR = 52,2,1,0 %;           !  Unexpected Read Response
macro XMI$L_XBE1 = 516,0,32,0 %;        !  XMI-2 Bus Error register
macro XMI$L_XFAD1 = 520,0,32,0 %;       !  XMI-2 Failing Addr (physical) register
macro XMI$L_NSCSR1 = 540,0,32,0 %;      !  XMI-2 Node specific CSR
macro XMI$L_XBCR1 = 548,0,32,0 %;       !  XMI-2 Bus control register
macro XMI$L_XFAER1 = 556,0,32,0 %;      !  XMI-2 Failing addr. (physical) extension
macro XMI$L_XBEER1 = 564,0,32,0 %;      !  XMI-2 Bus Error extension
!  
macro XMI$L_XBE2 = 1028,0,32,0 %;       !  XMI-2 Bus Error register
macro XMI$L_XFAD2 = 1032,0,32,0 %;      !  XMI-2 Failing Addr (physical) register
macro XMI$L_NSCSR2 = 1052,0,32,0 %;     !  XMI-2 Node specific CSR
macro XMI$L_XBCR2 = 1060,0,32,0 %;      !  XMI-2 Bus control register
macro XMI$L_XFAER2 = 1068,0,32,0 %;     !  XMI-2 Failing addr. (physical) extension
macro XMI$L_XBEER2 = 1076,0,32,0 %;     !  XMI-2 Bus Error extension
!  
macro XMI$L_XBE3 = 1540,0,32,0 %;       !  XMI-2 Bus Error register
macro XMI$L_XFAD3 = 1544,0,32,0 %;      !  XMI-2 Failing Addr (phsycial) register
macro XMI$L_NSCSR3 = 1564,0,32,0 %;     !  XMI-2 Node specific CSR
macro XMI$L_XBCR3 = 1572,0,32,0 %;      !  XMI-2 Bus control register
macro XMI$L_XFAER3 = 1580,0,32,0 %;     !  XMI-2 Failing addr. (physical) extension
macro XMI$L_XBEER3 = 1588,0,32,0 %;     !  XMI-2 Bus Error extension
! 
! ****************************************************************************
! *                                                                          *
! *  Copyright (c) 1995                                                      *
! *  by DIGITAL Equipment Corporation, Maynard, Mass.                        *
! *                                                                          *
! *  This software is furnished under a license and may be used and  copied  *
! *  only  in  accordance  with  the  terms  of  such  license and with the  *
! *  inclusion of the above copyright notice.  This software or  any  other  *
! *  copies  thereof may not be provided or otherwise made available to any  *
! *  other person.  No title to and ownership of  the  software  is  hereby  *
! *  transferred.                                                            *
! *                                                                          *
! *  The information in this software is subject to change  without  notice  *
! *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment  *
! *  Corporation.                                                            *
! *                                                                          *
! *  DIGITAL assumes no responsibility for the use or  reliability  of  its  *
! *  software on equipment which is not supplied by DIGITAL.                 *
! *                                                                          *
! ****************************************************************************
! ********************************************************************************************************************************
!  Created:  4-MAY-1995 17:55:06 by OpenVMS SDL EV1-36     
!  Source:  28-NOV-1994 14:18:51 $64$DUA3210:[LIB.SRC]F11DEF.SDL;1 
! ********************************************************************************************************************************
 
!*** MODULE $FH1DEF ***
literal FH1$C_LEVEL1 = 257;             !  401 octal = structure level 1 
literal FH1$K_LENGTH = 46;              !  length of header area 
literal FH1$C_LENGTH = 46;              !  length of header area 
literal FH1$S_FH1DEF = 512;             !  Old size name - synonym
literal FH1$S_FH1 = 512;
macro FH1$B_IDOFFSET = 0,0,8,0 %;       !  ident area offset in words 
macro FH1$B_MPOFFSET = 1,0,8,0 %;       !  map area offset in words 
macro FH1$W_FID = 2,0,32,0 %;
literal FH1$S_FID = 4;                  !  file ID 
macro FH1$W_FID_NUM = 2,0,16,0 %;       !  file number 
macro FH1$W_FID_SEQ = 4,0,16,0 %;       !  file sequence number 
macro FH1$W_STRUCLEV = 6,0,16,0 %;      !  file structure level 
macro FH1$W_FILEOWNER = 8,0,16,0 %;     !  file owner UIC 
macro FH1$B_UICMEMBER = 8,0,8,0 %;      !  UIC member number 
macro FH1$B_UICGROUP = 9,0,8,0 %;       !  UIC group number 
macro FH1$W_FILEPROT = 10,0,16,0 %;     !  file protection 
macro FH1$V_SYSPRO = 10,0,4,0 %;
literal FH1$S_SYSPRO = 4;               !  system protection 
macro FH1$V_OWNPRO = 10,4,4,0 %;
literal FH1$S_OWNPRO = 4;               !  owner protection 
macro FH1$V_GROUPPRO = 10,8,4,0 %;
literal FH1$S_GROUPPRO = 4;             !  group protection 
macro FH1$V_WORLDPRO = 10,12,4,0 %;
literal FH1$S_WORLDPRO = 4;             !  world protection 
macro FH1$W_FILECHAR = 12,0,16,0 %;     !  file characteristics 
macro FH1$B_USERCHAR = 12,0,8,0 %;      !  user controlled characteristics 
macro FH1$V_WASCONTIG = 12,0,1,0 %;     !  file was (and should be) contiguous
macro FH1$V_NOBACKUP = 12,1,1,0 %;      !  file is not to be backed up 
macro FH1$V_READCHECK = 12,3,1,0 %;     !  verify all read operations 
macro FH1$V_WRITCHECK = 12,4,1,0 %;     !  verify all write operations 
macro FH1$V_CONTIGB = 12,5,1,0 %;       !  keep file as contiguous as possible 
macro FH1$V_LOCKED = 12,6,1,0 %;        !  file is deaccess locked 
macro FH1$V_CONTIG = 12,7,1,0 %;        !  file is contiguous 
macro FH1$B_SYSCHAR = 13,0,8,0 %;       !  system controlled characteristics 
macro FH1$V_SPOOL = 13,4,1,0 %;         !  intermediate spool file 
macro FH1$V_BADBLOCK = 13,6,1,0 %;      !  file contains bad blocks 
macro FH1$V_MARKDEL = 13,7,1,0 %;       !  file is marked for delete 
macro FH1$W_RECATTR = 14,0,0,0 %;
literal FH1$S_RECATTR = 32;             !  file record attributes 
macro FH1$W_CHECKSUM = 510,0,16,0 %;    !  file header checksum 
 
!*** MODULE $FI1DEF ***
literal FI1$K_LENGTH = 46;              !  length of ident area 
literal FI1$C_LENGTH = 46;              !  length of ident area 
literal FI1$S_FI1DEF = 286;             !  Old size name - synonym
literal FI1$S_FI1 = 286;
macro FI1$W_FILENAME = 0,0,0,0 %;
literal FI1$S_FILENAME = 6;             !  file name (RAD-50) 
macro FI1$W_FILETYPE = 6,0,16,0 %;      !  file type (RAD-50) 
macro FI1$W_VERSION = 8,0,16,0 %;       !  version number (binary) 
macro FI1$W_REVISION = 10,0,16,0 %;     !  revision number (binary) 
macro FI1$T_REVDATE = 12,0,0,0 %;
literal FI1$S_REVDATE = 7;              !  revision date (ASCII DDMMMYY) 
macro FI1$T_REVTIME = 19,0,0,0 %;
literal FI1$S_REVTIME = 6;              !  revision time (ASCII HHMMSS) 
macro FI1$T_CREDATE = 25,0,0,0 %;
literal FI1$S_CREDATE = 7;              !  creation date (ASCII DDMMMYY) 
macro FI1$T_CRETIME = 32,0,0,0 %;
literal FI1$S_CRETIME = 6;              !  creation time (ASCII HHMMSS) 
macro FI1$T_EXPDATE = 38,0,0,0 %;
literal FI1$S_EXPDATE = 7;              !  expiration date (ASCII DDMMMYY) 
macro FI1$T_MTHDR1 = 46,0,0,0 %;
literal FI1$S_MTHDR1 = 80;              !  HDR1 of ANSI magnetic tape file 
macro FI1$T_MTHDR2 = 126,0,0,0 %;
literal FI1$S_MTHDR2 = 80;              !  HDR2 of ANSI magnetic tape file 
macro FI1$T_MTHDR3 = 206,0,0,0 %;
literal FI1$S_MTHDR3 = 80;              !  HDR3 of ANSI magnetic tape file 
 
!*** MODULE $FM1DEF ***
literal FM1$K_POINTERS = 10;            !  start of retrieval pointers 
literal FM1$C_POINTERS = 10;            !  start of retrieval pointers 
literal FM1$K_LENGTH = 10;              !  length of map area 
literal FM1$C_LENGTH = 10;              !  length of map area 
!  retrieval pointer format
literal FM1$S_FM1DEF = 10;              !  Old size name - synonym
literal FM1$S_FM1 = 10;
macro FM1$B_EX_SEGNUM = 0,0,8,0 %;      !  extension segment number of this header 
macro FM1$B_EX_RVN = 1,0,8,0 %;         !  extension relative volume number 
macro FM1$W_EX_FILNUM = 2,0,16,0 %;     !  extension file number 
macro FM1$W_EX_FILSEQ = 4,0,16,0 %;     !  extension file sequence number 
macro FM1$B_COUNTSIZE = 6,0,8,0 %;      !  retrieval pointer count field size 
macro FM1$B_LBNSIZE = 7,0,8,0 %;        !  retrieval pointer LBN field size 
macro FM1$B_INUSE = 8,0,8,0 %;          !  number of retrieval words in use 
macro FM1$B_AVAIL = 9,0,8,0 %;          !  number of retrieval words available 
literal FM1$S_FM1DEF1 = 4;              !  Old size name - synonym
literal FM1$S_FM1_1 = 4;
macro FM1$B_HIGHLBN = 0,0,8,0 %;        !  high order LBN 
macro FM1$B_COUNT = 1,0,8,0 %;          !  block count 
macro FM1$W_LOWLBN = 2,0,16,0 %;        !  low order LBN 
literal FM1$S_FM1DEF2 = 5;              !  Old size name - synonym
literal FM1$S_FM1_2 = 5;
macro FM1$B_PREVHLBN = -4,0,8,0 %;
macro FM1$B_PREVCOUNT = -3,0,8,0 %;
macro FM1$W_PREVLLBN = -2,0,16,0 %;     !  previous retrieval pointer 
 
!*** MODULE $FH2DEF ***
! +
! 
!  File header definitions for Files-11 Structure Level 2
! 
! -
literal FH2$C_LEVEL1 = 257;             !  401 octal = structure level 1 
literal FH2$C_LEVEL2 = 512;             !  1000 octal = structure level 2 
literal FH2$M_VCC_STATE = %X'700';
literal FH2$M_ALM_STATE = %X'C0000';
literal FH2$M_WASCONTIG = %X'1';
literal FH2$M_NOBACKUP = %X'2';
literal FH2$M_WRITEBACK = %X'4';
literal FH2$M_READCHECK = %X'8';
literal FH2$M_WRITCHECK = %X'10';
literal FH2$M_CONTIGB = %X'20';
literal FH2$M_LOCKED = %X'40';
literal FH2$M_CONTIG = %X'80';
literal FH2$M_BADACL = %X'800';
literal FH2$M_SPOOL = %X'1000';
literal FH2$M_DIRECTORY = %X'2000';
literal FH2$M_BADBLOCK = %X'4000';
literal FH2$M_MARKDEL = %X'8000';
literal FH2$M_NOCHARGE = %X'10000';
literal FH2$M_ERASE = %X'20000';
literal FH2$M_ALM_AIP = %X'40000';
literal FH2$M_SHELVED = %X'80000';
literal FH2$M_SCRATCH = %X'100000';
literal FH2$M_NOMOVE = %X'200000';
literal FH2$M_NOSHELVABLE = %X'400000';
literal FH2$M_SHELVING_RESERVED = %X'800000';
literal FH2$M_ALM_ARCHIVED = %X'80000';
literal FH2$M_ONLY_RU = %X'1';
literal FH2$M_RUJNL = %X'2';
literal FH2$M_BIJNL = %X'4';
literal FH2$M_AIJNL = %X'8';
literal FH2$M_ATJNL = %X'10';
literal FH2$M_NEVER_RU = %X'20';
literal FH2$M_JOURNAL_FILE = %X'40';
literal FH2$C_RU_FACILITY_RMS = 1;      !  RMS
literal FH2$C_RU_FACILITY_DBMS = 2;     !  DBMS
literal FH2$C_RU_FACILITY_RDB = 3;      !  Rdb/VMS
literal FH2$C_RU_FACILITY_CHKPNT = 4;   !  Checkpoint/Restart
literal FH2$K_LENGTH = 80;              !  length of header area 
literal FH2$C_LENGTH = 80;              !  length of header area 
literal FH2$K_SUBSET0_LENGTH = 88;      !  length of header area 
literal FH2$C_SUBSET0_LENGTH = 88;      !  length of header area 
literal FH2$K_FULL_LENGTH = 108;        !  length of full header
literal FH2$C_FULL_LENGTH = 108;        !  length of full header
literal FH2$S_FH2DEF = 512;             !  Old size name - synonym
literal FH2$S_FH2 = 512;
macro FH2$B_IDOFFSET = 0,0,8,0 %;       !  ident area offset in words 
macro FH2$B_MPOFFSET = 1,0,8,0 %;       !  map area offset in words 
macro FH2$B_ACOFFSET = 2,0,8,0 %;       !  access control list offset in words 
macro FH2$B_RSOFFSET = 3,0,8,0 %;       !  reserved area offset in words 
macro FH2$W_SEG_NUM = 4,0,16,0 %;       !  file segment number 
macro FH2$W_STRUCLEV = 6,0,16,0 %;      !  file structure level 
macro FH2$B_STRUCVER = 6,0,8,0 %;       !  file structure version 
macro FH2$B_STRUCLEV = 7,0,8,0 %;       !  principal file structure level 
macro FH2$W_FID = 8,0,0,0 %;
literal FH2$S_FID = 6;                  !  file ID 
macro FH2$W_FID_NUM = 8,0,16,0 %;       !  file number 
macro FH2$W_FID_SEQ = 10,0,16,0 %;      !  file sequence number 
macro FH2$W_FID_RVN = 12,0,16,0 %;      !  relative volume number 
macro FH2$B_FID_RVN = 12,0,8,0 %;       !  alternate format RVN 
macro FH2$B_FID_NMX = 13,0,8,0 %;       !  alternate format file number extension 
macro FH2$W_EXT_FID = 14,0,0,0 %;
literal FH2$S_EXT_FID = 6;              !  extension file ID 
macro FH2$W_EX_FIDNUM = 14,0,16,0 %;    !  extension file number 
macro FH2$W_EX_FIDSEQ = 16,0,16,0 %;    !  extension file sequence number 
macro FH2$W_EX_FIDRVN = 18,0,16,0 %;    !  extension relative volume number 
macro FH2$B_EX_FIDRVN = 18,0,8,0 %;     !  alternate format extension RVN 
macro FH2$B_EX_FIDNMX = 19,0,8,0 %;     !  alternate format extension file number extension 
macro FH2$W_RECATTR = 20,0,0,0 %;
literal FH2$S_RECATTR = 32;             !  file record attributes 
macro FH2$L_FILECHAR = 52,0,32,0 %;     !  file characteristics 
macro FH2$V_VCC_STATE = 52,8,3,0 %;
literal FH2$S_VCC_STATE = 3;            !  VCC state bits
! **********The following line is different from FH2 
macro FH2$V_ALM_STATE = 52,18,2,0 %;
literal FH2$S_ALM_STATE = 2;            !  ALM state bits
macro FH2$V_WASCONTIG = 52,0,1,0 %;     !  file was (and should be) contiguous
macro FH2$V_NOBACKUP = 52,1,1,0 %;      !  file is not to be backed up 
macro FH2$V_WRITEBACK = 52,2,1,0 %;     !  file may be write-back cached 
macro FH2$V_READCHECK = 52,3,1,0 %;     !  verify all read operations 
macro FH2$V_WRITCHECK = 52,4,1,0 %;     !  verify all write operations 
macro FH2$V_CONTIGB = 52,5,1,0 %;       !  keep file as contiguous as possible 
macro FH2$V_LOCKED = 52,6,1,0 %;        !  file is deaccess locked 
macro FH2$V_CONTIG = 52,7,1,0 %;        !  file is contiguous 
macro FH2$V_BADACL = 52,11,1,0 %;       !  ACL is invalid 
macro FH2$V_SPOOL = 52,12,1,0 %;        !  intermediate spool file 
macro FH2$V_DIRECTORY = 52,13,1,0 %;    !  file is a directory 
macro FH2$V_BADBLOCK = 52,14,1,0 %;     !  file contains bad blocks 
macro FH2$V_MARKDEL = 52,15,1,0 %;      !  file is marked for delete 
macro FH2$V_NOCHARGE = 52,16,1,0 %;     !  file space is not to be charged 
macro FH2$V_ERASE = 52,17,1,0 %;        !  erase file contents before deletion 
! **********The following two lines are different from FCH
macro FH2$V_ALM_AIP = 52,18,1,0 %;      !  Archive in progress - ALM proj cancelled
macro FH2$V_SHELVED = 52,19,1,0 %;      !  File is shelved
macro FH2$V_SCRATCH = 52,20,1,0 %;      !  Scratch Header used by movefile
macro FH2$V_NOMOVE = 52,21,1,0 %;       !  Disable movefile on this file
macro FH2$V_NOSHELVABLE = 52,22,1,0 %;  !  File is not allowed to be shelved
macro FH2$V_SHELVING_RESERVED = 52,23,1,0 %; !  Reserved for shelving facility
!  Note: The high 8 bits of this longword
!  are reserved for user and CSS use.
macro FH2$V_ALM_ARCHIVED = 52,19,1,0 %; !  File archived - ALM proj cancelled
macro FH2$W_RECPROT = 56,0,16,0 %;      !  record protection 
macro FH2$B_MAP_INUSE = 58,0,8,0 %;     !  number of map area words in use 
macro FH2$B_ACC_MODE = 59,0,8,0 %;      !  least privileged access mode 
macro FH2$L_FILEOWNER = 60,0,32,0 %;    !  file owner UIC 
macro FH2$W_UICMEMBER = 60,0,16,0 %;    !  UIC member number 
macro FH2$W_UICGROUP = 62,0,16,0 %;     !  UIC group number 
macro FH2$W_FILEPROT = 64,0,16,0 %;     !  file protection 
macro FH2$W_BACKLINK = 66,0,0,0 %;
literal FH2$S_BACKLINK = 6;             !  back link pointer 
macro FH2$W_BK_FIDNUM = 66,0,16,0 %;    !  back link file number 
macro FH2$W_BK_FIDSEQ = 68,0,16,0 %;    !  back link file sequence number 
macro FH2$W_BK_FIDRVN = 70,0,16,0 %;    !  back link relative volume number 
macro FH2$B_BK_FIDRVN = 70,0,8,0 %;     !  alternate format back link RVN 
macro FH2$B_BK_FIDNMX = 71,0,8,0 %;     !  alternate format back link file number extension 
macro FH2$B_JOURNAL = 72,0,8,0 %;       !  journal control flags 
macro FH2$V_ONLY_RU = 72,0,1,0 %;       !  file is accessible only in recovery unit 
macro FH2$V_RUJNL = 72,1,1,0 %;         !  enable recovery unit journal 
macro FH2$V_BIJNL = 72,2,1,0 %;         !  enable before image journal 
macro FH2$V_AIJNL = 72,3,1,0 %;         !  enable after image journal 
macro FH2$V_ATJNL = 72,4,1,0 %;         !  enable audit trail journal 
macro FH2$V_NEVER_RU = 72,5,1,0 %;      !  file is never accessible in recovery unit
macro FH2$V_JOURNAL_FILE = 72,6,1,0 %;  !  this is a journal file
macro FH2$B_RU_ACTIVE = 73,0,8,0 %;     !  If non-zero, file has active recovery units
!  (value is recoverable facility id number)
!  1-99 reserved to DEC, 100-127 reserved for
!  CSS, 128-255 reserved for customers.
macro FH2$L_HIGHWATER = 76,0,32,0 %;    !  high-water mark in file
macro FH2$R_CLASS_PROT = 88,0,0,0 %;
literal FH2$S_CLASS_PROT = 20;          !  security classification mask
macro FH2$W_CHECKSUM = 510,0,16,0 %;    !  file header checksum 
 
!*** MODULE $FI2DEF ***
literal FI2$K_LENGTH = 120;             !  length of ident area 
literal FI2$C_LENGTH = 120;             !  length of ident area 
literal FI2$S_FI2DEF = 200;             !  Old size name - synonym
literal FI2$S_FI2 = 200;
macro FI2$T_FILENAME = 0,0,0,0 %;
literal FI2$S_FILENAME = 20;            !  file name, type, and version (ASCII) 
macro FI2$W_REVISION = 20,0,16,0 %;     !  revision number (binary) 
macro FI2$Q_CREDATE = 22,0,0,0 %;
literal FI2$S_CREDATE = 8;              !  creation date and time 
macro FI2$Q_REVDATE = 30,0,0,0 %;
literal FI2$S_REVDATE = 8;              !  revision date and time 
macro FI2$Q_EXPDATE = 38,0,0,0 %;
literal FI2$S_EXPDATE = 8;              !  expiration date and time 
macro FI2$Q_BAKDATE = 46,0,0,0 %;
literal FI2$S_BAKDATE = 8;              !  backup date and time 
macro FI2$T_FILENAMEXT = 54,0,0,0 %;
literal FI2$S_FILENAMEXT = 66;          !  extension file name area
macro FI2$T_USERLABEL = 120,0,0,0 %;
literal FI2$S_USERLABEL = 80;           !  optional user file label 
 
!*** MODULE $FM2DEF ***
!  retrieval pointer type codes 
literal FM2$C_PLACEMENT = 0;            !  00 = placement control data 
literal FM2$C_FORMAT1 = 1;              !  01 = format 1 
literal FM2$C_FORMAT2 = 2;              !  10 = format 2 
literal FM2$C_FORMAT3 = 3;              !  11 = format 3 
!  format of retrieval pointer
literal FM2$K_LENGTH0 = 2;              !  length of format 0 (placement) 
literal FM2$C_LENGTH0 = 2;              !  length of format 0 (placement) 
literal FM2$K_LENGTH1 = 4;              !  length of format 1 
literal FM2$C_LENGTH1 = 4;              !  length of format 1 
literal FM2$S_FM2DEF = 4;               !  Old size name - synonym
literal FM2$S_FM2 = 4;
macro FM2$W_WORD0 = 0,0,16,0 %;         !  first word, of many uses 
macro FM2$V_FORMAT = 0,14,2,0 %;
literal FM2$S_FORMAT = 2;               !  format type code 
macro FM2$V_EXACT = 0,0,1,0 %;          !  exact placement specified 
macro FM2$V_ONCYL = 0,1,1,0 %;          !  on cylinder allocation desired 
macro FM2$V_LBN = 0,12,1,0 %;           !  use LBN of next map pointer 
macro FM2$V_RVN = 0,13,1,0 %;           !  place on specified RVN 
macro FM2$V_HIGHLBN = 0,8,6,0 %;
literal FM2$S_HIGHLBN = 6;              !  high order LBN 
macro FM2$V_COUNT2 = 0,0,14,0 %;
literal FM2$S_COUNT2 = 14;              !  format 2 & 3 count field 
macro FM2$B_COUNT1 = 0,0,8,0 %;         !  format 1 count field 
macro FM2$W_LOWLBN = 2,0,16,0 %;        !  format 1 low order LBN 
literal FM2$K_LENGTH2 = 6;              !  length of format 2 
literal FM2$C_LENGTH2 = 6;              !  length of format 2 
literal FM2$S_FM2DEF1 = 6;              !  Old size name - synonym
literal FM2$S_FM2_1 = 6;
macro FM2$L_LBN2 = 2,0,32,0 %;          !  format 2 LBN (longword) 
literal FM2$K_LENGTH3 = 8;              !  length of format 3 
literal FM2$C_LENGTH3 = 8;              !  length of format 3 
literal FM2$S_FM2DEF2 = 8;              !  Old size name - synonym
literal FM2$S_FM2_2 = 8;
macro FM2$W_LOWCOUNT = 2,0,16,0 %;      !  format 3 low order count 
macro FM2$L_LBN3 = 4,0,32,0 %;          !  format 3 LBN (longword) 
 
!*** MODULE $FCHDEF ***
! +
! 
!  File characteristics bit definitions. These are identical to, and must
!  track, the bits in FILECHAR above, but are defined relative to the file
!  characteristics longword instead of relative to the file header.
! 
! -
literal FCH$M_VCC_STATE = %X'700';
literal FCH$M_ASSOCIATED = %X'100000';
literal FCH$M_EXISTENCE = %X'200000';
literal FCH$M_WASCONTIG = %X'1';
literal FCH$M_NOBACKUP = %X'2';
literal FCH$M_WRITEBACK = %X'4';
literal FCH$M_READCHECK = %X'8';
literal FCH$M_WRITCHECK = %X'10';
literal FCH$M_CONTIGB = %X'20';
literal FCH$M_LOCKED = %X'40';
literal FCH$M_CONTIG = %X'80';
literal FCH$M_BADACL = %X'800';
literal FCH$M_SPOOL = %X'1000';
literal FCH$M_DIRECTORY = %X'2000';
literal FCH$M_BADBLOCK = %X'4000';
literal FCH$M_MARKDEL = %X'8000';
literal FCH$M_NOCHARGE = %X'10000';
literal FCH$M_ERASE = %X'20000';
literal FCH$M_SHELVED = %X'80000';
literal FCH$M_SCRATCH = %X'100000';
literal FCH$M_NOMOVE = %X'200000';
literal FCH$M_NOSHELVABLE = %X'400000';
literal FCH$S_FCHDEF = 4;               !  Old size name - synonym
literal FCH$S_FCH = 4;
macro FCH$V_VCC_STATE = 0,8,3,0 %;
literal FCH$S_VCC_STATE = 3;            !  VCC state bits
! **********The following line is different from FH2 
macro FCH$V_ASSOCIATED = 0,20,1,0 %;    !  ISO 9660 Associated file
macro FCH$V_EXISTENCE = 0,21,1,0 %;     !  ISO 9660 Existence file
macro FCH$V_WASCONTIG = 0,0,1,0 %;      !  file was (and should be) contiguous
macro FCH$V_NOBACKUP = 0,1,1,0 %;       !  file is not to be backed up 
macro FCH$V_WRITEBACK = 0,2,1,0 %;      !  file may be write-back cached 
macro FCH$V_READCHECK = 0,3,1,0 %;      !  verify all read operations 
macro FCH$V_WRITCHECK = 0,4,1,0 %;      !  verify all write operations 
macro FCH$V_CONTIGB = 0,5,1,0 %;        !  keep file as contiguous as possible 
macro FCH$V_LOCKED = 0,6,1,0 %;         !  file is deaccess locked 
macro FCH$V_CONTIG = 0,7,1,0 %;         !  file is contiguous 
macro FCH$V_BADACL = 0,11,1,0 %;        !  ACL is invalid 
macro FCH$V_SPOOL = 0,12,1,0 %;         !  intermediate spool file 
macro FCH$V_DIRECTORY = 0,13,1,0 %;     !  file is a directory 
macro FCH$V_BADBLOCK = 0,14,1,0 %;      !  file contains bad blocks 
macro FCH$V_MARKDEL = 0,15,1,0 %;       !  file is marked for delete 
macro FCH$V_NOCHARGE = 0,16,1,0 %;      !  file space is not to be charged 
macro FCH$V_ERASE = 0,17,1,0 %;         !  erase file contents before deletion 
! **********The following line is different from FH2 
macro FCH$V_SHELVED = 0,19,1,0 %;       !  File shelved
macro FCH$V_SCRATCH = 0,20,1,0 %;       !  Scratch Header used by movefile
macro FCH$V_NOMOVE = 0,21,1,0 %;        !  Disable movefile on this file
macro FCH$V_NOSHELVABLE = 0,22,1,0 %;   !  File is not allowed to be shelved
! **********The following line is different from FH2
!  Note: The high 8 bits of this longword
!  are reserved for user and CSS use.
 
!*** MODULE $FJNDEF ***
! +
! 
!  File journal control bit definitions. These are identical to, and must
!  track, the bits in JOURNAL above, but are defined relative to the journal
!  control byte instead of relative to the file header.
! 
! -
literal FJN$M_ONLY_RU = %X'1';
literal FJN$M_RUJNL = %X'2';
literal FJN$M_BIJNL = %X'4';
literal FJN$M_AIJNL = %X'8';
literal FJN$M_ATJNL = %X'10';
literal FJN$M_NEVER_RU = %X'20';
literal FJN$M_JOURNAL_FILE = %X'40';
literal FJN$S_FJNDEF = 1;               !  Old size name - synonym
literal FJN$S_FJN = 1;
macro FJN$V_ONLY_RU = 0,0,1,0 %;        !  file is accessible only in recovery unit 
macro FJN$V_RUJNL = 0,1,1,0 %;          !  enable recovery unit journal 
macro FJN$V_BIJNL = 0,2,1,0 %;          !  enable before image journal 
macro FJN$V_AIJNL = 0,3,1,0 %;          !  enable after image journal 
macro FJN$V_ATJNL = 0,4,1,0 %;          !  enable audit trail journal 
macro FJN$V_NEVER_RU = 0,5,1,0 %;       !  file is never accessible in recovery unit
macro FJN$V_JOURNAL_FILE = 0,6,1,0 %;   !  this is a journal file
 
!*** MODULE $FATDEF ***
! +
! 
!  Record attributes area as used by FCS and RMS.
! 
! -
literal FAT$C_UNDEFINED = 0;            !  undefined record type 
literal FAT$C_FIXED = 1;                !  fixed record type 
literal FAT$C_VARIABLE = 2;             !  variable length 
literal FAT$C_VFC = 3;                  !  variable + fixed control 
literal FAT$C_STREAM = 4;               !  RMS-11 (DEC traditional) stream format 
literal FAT$C_STREAMLF = 5;             !  LF-terminated stream format 
literal FAT$C_STREAMCR = 6;             !  CR-terminated stream format 
literal FAT$C_SEQUENTIAL = 0;           !  sequential organization 
literal FAT$C_RELATIVE = 1;             !  relative organization 
literal FAT$C_INDEXED = 2;              !  indexed organization 
literal FAT$C_DIRECT = 3;               !  direct organization 
literal FAT$M_FORTRANCC = %X'1';
literal FAT$M_IMPLIEDCC = %X'2';
literal FAT$M_PRINTCC = %X'4';
literal FAT$M_NOSPAN = %X'8';
literal FAT$M_MSBRCW = %X'10';
literal FAT$K_LENGTH = 32;
literal FAT$C_LENGTH = 32;
literal FAT$S_FATDEF = 32;              !  Old size name - synonym
literal FAT$S_FAT = 32;
macro FAT$B_RTYPE = 0,0,8,0 %;          !  record type 
macro FAT$V_RTYPE = 0,0,4,0 %;
literal FAT$S_RTYPE = 4;                !  record type subfield 
macro FAT$V_FILEORG = 0,4,4,0 %;
literal FAT$S_FILEORG = 4;              !  file organization 
macro FAT$B_RATTRIB = 1,0,8,0 %;        !  record attributes 
macro FAT$V_FORTRANCC = 1,0,1,0 %;      !  Fortran carriage control 
macro FAT$V_IMPLIEDCC = 1,1,1,0 %;      !  implied carriage control 
macro FAT$V_PRINTCC = 1,2,1,0 %;        !  print file carriage control 
macro FAT$V_NOSPAN = 1,3,1,0 %;         !  no spanned records 
macro FAT$V_MSBRCW = 1,4,1,0 %;         !  Format of RCW (0=LSB, 1=MSB)
macro FAT$W_RSIZE = 2,0,16,0 %;         !  record size in bytes 
macro FAT$L_HIBLK = 4,0,32,0 %;         !  highest allocated VBN 
macro FAT$W_HIBLKH = 4,0,16,0 %;        !  high order word 
macro FAT$W_HIBLKL = 6,0,16,0 %;        !  low order word 
macro FAT$L_EFBLK = 8,0,32,0 %;         !  end of file VBN 
macro FAT$W_EFBLKH = 8,0,16,0 %;        !  high order word 
macro FAT$W_EFBLKL = 10,0,16,0 %;       !  low order word 
macro FAT$W_FFBYTE = 12,0,16,0 %;       !  first free byte in EFBLK 
macro FAT$B_BKTSIZE = 14,0,8,0 %;       !  bucket size in blocks 
macro FAT$B_VFCSIZE = 15,0,8,0 %;       !  size in bytes of fixed length control for VFC records 
macro FAT$W_MAXREC = 16,0,16,0 %;       !  maximum record size in bytes 
macro FAT$W_DEFEXT = 18,0,16,0 %;       !  default extend quantity 
macro FAT$W_GBC = 20,0,16,0 %;          !  global buffer count 
macro FAT$W_VERSIONS = 30,0,16,0 %;     !  default version limit for directory file 
 
!*** MODULE $HM1DEF ***
! +
! 
!  Home block definitions for Files-11 Structure Level 1
! 
! -
literal HM1$C_LEVEL1 = 257;             !  401 octal = structure level 1 
literal HM1$C_LEVEL2 = 258;             !  402 octal = structure level 1, version 2 
literal HM1$S_HM1DEF = 512;             !  Old size name - synonym
literal HM1$S_HM1 = 512;
macro HM1$W_IBMAPSIZE = 0,0,16,0 %;     !  index file bitmap size, blocks 
macro HM1$L_IBMAPLBN = 2,0,32,0 %;      !  index file bitmap starting LBN 
macro HM1$W_MAXFILES = 6,0,16,0 %;      !  maximum ! files on volume 
macro HM1$W_CLUSTER = 8,0,16,0 %;       !  storage bitmap cluster factor 
macro HM1$W_DEVTYPE = 10,0,16,0 %;      !  disk device type 
macro HM1$W_STRUCLEV = 12,0,16,0 %;     !  volume structure level 
macro HM1$T_VOLNAME = 14,0,0,0 %;
literal HM1$S_VOLNAME = 12;             !  volume name (ASCII) 
macro HM1$W_VOLOWNER = 30,0,16,0 %;     !  volume owner UIC 
macro HM1$W_PROTECT = 32,0,16,0 %;      !  volume protection 
macro HM1$V_SYSPRO = 32,0,4,0 %;
literal HM1$S_SYSPRO = 4;               !  system protection 
macro HM1$V_OWNPRO = 32,4,4,0 %;
literal HM1$S_OWNPRO = 4;               !  owner protection 
macro HM1$V_GROUPPRO = 32,8,4,0 %;
literal HM1$S_GROUPPRO = 4;             !  group protection 
macro HM1$V_WORLDPRO = 32,12,4,0 %;
literal HM1$S_WORLDPRO = 4;             !  world protection 
macro HM1$W_VOLCHAR = 34,0,16,0 %;      !  volume characteristics 
macro HM1$W_FILEPROT = 36,0,16,0 %;     !  default file protection 
macro HM1$B_WINDOW = 44,0,8,0 %;        !  default window size 
macro HM1$B_EXTEND = 45,0,8,0 %;        !  default file extend 
macro HM1$B_LRU_LIM = 46,0,8,0 %;       !  default LRU limit 
macro HM1$W_CHECKSUM1 = 58,0,16,0 %;    !  first checksum 
macro HM1$T_CREDATE = 60,0,0,0 %;
literal HM1$S_CREDATE = 14;             !  volume creation date 
macro HM1$L_SERIALNUM = 456,0,32,0 %;   !  pack serial number 
macro HM1$T_VOLNAME2 = 472,0,0,0 %;
literal HM1$S_VOLNAME2 = 12;            !  2nd copy of volume name 
macro HM1$T_OWNERNAME = 484,0,0,0 %;
literal HM1$S_OWNERNAME = 12;           !  volume owner name 
macro HM1$T_FORMAT = 496,0,0,0 %;
literal HM1$S_FORMAT = 12;              !  volume format type 
macro HM1$W_CHECKSUM2 = 510,0,16,0 %;   !  second checksum 
 
!*** MODULE $HM2DEF ***
! +
! 
!  Home block definitions for Files-11 Structure Level 2
! 
! -
literal HM2$C_LEVEL1 = 257;             !  401 octal = structure level 1 
literal HM2$C_LEVEL2 = 512;             !  1000 octal = structure level 2 
literal HM2$M_READCHECK = %X'1';
literal HM2$M_WRITCHECK = %X'2';
literal HM2$M_ERASE = %X'4';
literal HM2$M_NOHIGHWATER = %X'8';
literal HM2$M_CLASS_PROT = %X'10';
literal HM2$S_HM2DEF = 512;             !  Old size name - synonym
literal HM2$S_HM2 = 512;
macro HM2$L_HOMELBN = 0,0,32,0 %;       !  LBN of home (i.e., this) block 
macro HM2$L_ALHOMELBN = 4,0,32,0 %;     !  LBN of alternate home block 
macro HM2$L_ALTIDXLBN = 8,0,32,0 %;     !  LBN of alternate index file header 
macro HM2$W_STRUCLEV = 12,0,16,0 %;     !  volume structure level 
macro HM2$B_STRUCVER = 12,0,8,0 %;      !  structure version number 
macro HM2$B_STRUCLEV = 13,0,8,0 %;      !  main structure level 
macro HM2$W_CLUSTER = 14,0,16,0 %;      !  storage bitmap cluster factor 
macro HM2$W_HOMEVBN = 16,0,16,0 %;      !  VBN of home (i.e., this) block 
macro HM2$W_ALHOMEVBN = 18,0,16,0 %;    !  VBN of alternate home block 
macro HM2$W_ALTIDXVBN = 20,0,16,0 %;    !  VBN of alternate index file header 
macro HM2$W_IBMAPVBN = 22,0,16,0 %;     !  VBN of index file bitmap 
macro HM2$L_IBMAPLBN = 24,0,32,0 %;     !  LBN of index file bitmap 
macro HM2$L_MAXFILES = 28,0,32,0 %;     !  maximum ! files on volume 
macro HM2$W_IBMAPSIZE = 32,0,16,0 %;    !  index file bitmap size, blocks 
macro HM2$W_RESFILES = 34,0,16,0 %;     !  ! reserved files on volume 
macro HM2$W_DEVTYPE = 36,0,16,0 %;      !  disk device type 
macro HM2$W_RVN = 38,0,16,0 %;          !  relative volume number of this volume 
macro HM2$W_SETCOUNT = 40,0,16,0 %;     !  count of volumes in set 
macro HM2$W_VOLCHAR = 42,0,16,0 %;      !  volume characteristics 
macro HM2$V_READCHECK = 42,0,1,0 %;     !  verify all read operations 
macro HM2$V_WRITCHECK = 42,1,1,0 %;     !  verify all write operations 
macro HM2$V_ERASE = 42,2,1,0 %;         !  erase all files on delete 
macro HM2$V_NOHIGHWATER = 42,3,1,0 %;   !  turn off high-water marking
macro HM2$V_CLASS_PROT = 42,4,1,0 %;    !  enable classification checks on the volume
macro HM2$L_VOLOWNER = 44,0,32,0 %;     !  volume owner UIC 
macro HM2$L_SEC_MASK = 48,0,32,0 %;     !  volume security mask 
macro HM2$W_PROTECT = 52,0,16,0 %;      !  volume protection 
macro HM2$W_FILEPROT = 54,0,16,0 %;     !  default file protection 
macro HM2$W_RECPROT = 56,0,16,0 %;      !  default file record protection 
macro HM2$W_CHECKSUM1 = 58,0,16,0 %;    !  first checksum 
macro HM2$Q_CREDATE = 60,0,0,0 %;
literal HM2$S_CREDATE = 8;              !  volume creation date 
macro HM2$B_WINDOW = 68,0,8,0 %;        !  default window size 
macro HM2$B_LRU_LIM = 69,0,8,0 %;       !  default LRU limit 
macro HM2$W_EXTEND = 70,0,16,0 %;       !  default file extend 
macro HM2$Q_RETAINMIN = 72,0,0,0 %;
literal HM2$S_RETAINMIN = 8;            !  minimum file retention period 
macro HM2$Q_RETAINMAX = 80,0,0,0 %;
literal HM2$S_RETAINMAX = 8;            !  maximum file retention period 
macro HM2$Q_REVDATE = 88,0,0,0 %;
literal HM2$S_REVDATE = 8;              !  volume revision date
macro HM2$R_MIN_CLASS = 96,0,0,0 %;
literal HM2$S_MIN_CLASS = 20;           !  volume minimum security class
macro HM2$R_MAX_CLASS = 116,0,0,0 %;
literal HM2$S_MAX_CLASS = 20;           !  volume maximum security class
macro HM2$W_FILETAB_FID = 136,0,0,0 %;
literal HM2$S_FILETAB_FID = 6;          !  file lookup table FID
macro HM2$W_LOWSTRUCLEV = 142,0,16,0 %; !  lowest struclev on volume
macro HM2$B_LOWSTRUCVER = 142,0,8,0 %;  !  structure version number 
macro HM2$B_LOWSTRUCLEV = 143,0,8,0 %;  !  main structure level 
macro HM2$W_HIGHSTRUCLEV = 144,0,16,0 %; !  highest struclev on volume
macro HM2$B_HIGHSTRUCVER = 144,0,8,0 %; !  structure version number 
macro HM2$B_HIGHSTRUCLEV = 145,0,8,0 %; !  main structure level 
macro HM2$Q_COPYDATE = 146,0,0,0 %;
literal HM2$S_COPYDATE = 8;             !  volume copy date
macro HM2$L_SERIALNUM = 456,0,32,0 %;   !  pack serial number 
macro HM2$T_STRUCNAME = 460,0,0,0 %;
literal HM2$S_STRUCNAME = 12;           !  structure (volume set name) 
macro HM2$T_VOLNAME = 472,0,0,0 %;
literal HM2$S_VOLNAME = 12;             !  volume name 
macro HM2$T_OWNERNAME = 484,0,0,0 %;
literal HM2$S_OWNERNAME = 12;           !  volume owner name 
macro HM2$T_FORMAT = 496,0,0,0 %;
literal HM2$S_FORMAT = 12;              !  volume format type 
macro HM2$W_CHECKSUM2 = 510,0,16,0 %;   !  second checksum 
!  Type of homeblock placement deltas.
!  Code assumes these are zero-based and increase monotonically
! 
literal HM2$C_REQ_DELTA_GEOM_DEPEND = 0; !  dependent on disk geometry
literal HM2$C_REQ_DELTA_GEOM_INDEPEND = 1; !  independent of disk geometry
literal HM2$C_REQ_DELTA_FIXED_CONTIG = 2; !  fixed so index file will be contig (for Dollar)
literal HM2$C_GEOM_INDEPEND_DELTA = 1033; !  actual geometry independent delta
!  this is a prime > 1000
literal HM2$C_FIXED_CONTIG_DELTA = 1;   !  fixed delta for contiguous index file
literal HM2$C_LIMITED_SEARCH_LENGTH = 10; !  number of blocks to check in a limited search
 
!*** MODULE $DIRDEF ***
! +
! 
!  Directory entry structure for Files-11 Structure Level 2
! 
! -
literal DIR$C_FID = 0;                  !  normal file ID 
literal DIR$C_LINKNAME = 1;             !  symbolic name 
literal DIR$K_LENGTH = 6;               !  length of directory entry overhead 
literal DIR$C_LENGTH = 6;               !  length of directory entry overhead 
literal DIR$S_NAME = 80;                !  maximum length of name string 
literal DIR$S_DIRDEF = 6;               !  Old size name - synonym
literal DIR$S_DIR = 6;
macro DIR$W_SIZE = 0,0,16,0 %;          !  size of directory record in bytes 
macro DIR$W_VERLIMIT = 2,0,16,0 %;      !  maximum number of versions 
macro DIR$B_FLAGS = 4,0,8,0 %;          !  status flags 
macro DIR$V_TYPE = 4,0,3,0 %;
literal DIR$S_TYPE = 3;                 !  directory entry type 
macro DIR$V_NEXTREC = 4,6,1,0 %;        !  another record of same name & type follows 
macro DIR$V_PREVREC = 4,7,1,0 %;        !  another record of same name & type precedes 
!  directory entry type codes 
macro DIR$B_NAMECOUNT = 5,0,8,0 %;      !  byte count of name string 
macro DIR$T_NAME = 6,0,0,0 %;           !  name string 
!  the version numbers and file ID's follow the
!  variable length name area in the form of a
!  blockvector. Each entry is as follows:
literal DIR$K_VERSION = 8;              !  size of each version entry 
literal DIR$C_VERSION = 8;              !  size of each version entry 
literal DIR$S_DIRDEF1 = 8;              !  Old size name - synonym
literal DIR$S_DIR1 = 8;
macro DIR$W_VERSION = 0,0,16,1 %;       !  version number 
macro DIR$W_FID = 2,0,0,0 %;
literal DIR$S_FID = 6;                  !  file ID 
macro DIR$W_FID_NUM = 2,0,16,0 %;       !  file number 
macro DIR$W_FID_SEQ = 4,0,16,0 %;       !  file sequence number 
macro DIR$W_FID_RVN = 6,0,16,0 %;       !  relative volume number 
macro DIR$B_FID_RVN = 6,0,8,0 %;        !  alternate format RVN 
macro DIR$B_FID_NMX = 7,0,8,0 %;        !  alternate format file number extension 
literal DIR$S_DIRDEF2 = 1;              !  Old size name - synonym
literal DIR$S_DIR2 = 1;
macro DIR$T_LINKNAME = 0,0,8,0 %;       !  symbolic link name (counted string) 
 
!*** MODULE $SCBDEF ***
! +
! 
!  Format of storage control block, Files-11 Structure Level 2
! 
! -
literal SCB$C_LEVEL2 = 512;             !  1000 octal = structure level 2 
literal SCB$M_MAPDIRTY = %X'1';
literal SCB$M_MAPALLOC = %X'2';
literal SCB$M_FILALLOC = %X'4';
literal SCB$M_QUODIRTY = %X'8';
literal SCB$M_HDRWRITE = %X'10';
literal SCB$M_CORRUPT = %X'20';
literal SCB$M_MAPDIRTY2 = %X'1';
literal SCB$M_MAPALLOC2 = %X'2';
literal SCB$M_FILALLOC2 = %X'4';
literal SCB$M_QUODIRTY2 = %X'8';
literal SCB$M_HDRWRITE2 = %X'10';
literal SCB$M_CORRUPT2 = %X'20';
literal SCB$M_NORMAL = %X'1';
literal SCB$M_NEW = %X'2';
literal SCB$M_REBLDNG = %X'4';
literal SCB$M_VERIFY = %X'8';
literal SCB$M_MVBEGUN = %X'10';
literal SCB$M_COPYING = %X'20';
literal SCB$M_MERGING = %X'40';
literal SCB$M_MINIMRG = %X'80';
literal SCB$M_CPY_RESET = %X'100';
literal SCB$M_BOOTING = %X'200';
literal SCB$M_WLG = %X'400';
literal SCB$M_INVWLG = %X'800';
literal SCB$M_FAILED = %X'8000';
literal SCB$M_MBR_FCPY = %X'1';
literal SCB$M_MBR_MERGE = %X'2';
literal SCB$M_MBR_CIP = %X'4';
literal SCB$M_MBR_MASTER = %X'8';
literal SCB$M_MBR_ERROR = %X'10';
literal SCB$M_MBR_SRC = %X'20';
literal SCB$M_MBR_DCD = %X'40';
literal SCB$M_MBR_VALID = %X'80';
literal SCB$K_LENGTH = 512;             ! Length of Structure
literal SCB$C_LENGTH = 512;             ! Length of Structure
literal SCB$S_SCBDEF = 512;
macro SCB$W_STRUCLEV = 0,0,16,0 %;      !  file structure level 
macro SCB$B_STRUCVER = 0,0,8,0 %;       !  file structure version 
macro SCB$B_STRUCLEV = 1,0,8,0 %;       !  principal file structure level 
macro SCB$W_CLUSTER = 2,0,16,0 %;       !  storage map cluster factor 
macro SCB$L_VOLSIZE = 4,0,32,0 %;       !  volume size in logical blocks 
macro SCB$L_BLKSIZE = 8,0,32,0 %;       !  number of physical blocks per logical block 
macro SCB$L_SECTORS = 12,0,32,0 %;      !  number of sectors per track 
macro SCB$L_TRACKS = 16,0,32,0 %;       !  number of tracks per cylinder 
macro SCB$L_CYLINDER = 20,0,32,0 %;     !  number of cylinders 
macro SCB$L_STATUS = 24,0,32,0 %;       !  volume status flags 
macro SCB$V_MAPDIRTY = 24,0,1,0 %;      !  storage map is dirty (partially updated) 
macro SCB$V_MAPALLOC = 24,1,1,0 %;      !  storage map is preallocated (lost blocks) 
macro SCB$V_FILALLOC = 24,2,1,0 %;      !  file numbers are preallocated (lost header slots) 
macro SCB$V_QUODIRTY = 24,3,1,0 %;      !  quota file is dirty (partially updated) 
macro SCB$V_HDRWRITE = 24,4,1,0 %;      !  file headers are write back cached 
macro SCB$V_CORRUPT = 24,5,1,0 %;       !  file structure is corrupt
macro SCB$L_STATUS2 = 28,0,32,0 %;      !  backup status - bits must match those above 
macro SCB$V_MAPDIRTY2 = 28,0,1,0 %;     !  storage map is dirty (partially updated) 
macro SCB$V_MAPALLOC2 = 28,1,1,0 %;     !  storage map is preallocated (lost blocks) 
macro SCB$V_FILALLOC2 = 28,2,1,0 %;     !  file numbers are preallocated (lost header slots) 
macro SCB$V_QUODIRTY2 = 28,3,1,0 %;     !  quota file is dirty (partially updated) 
macro SCB$V_HDRWRITE2 = 28,4,1,0 %;     !  file headers are write back cached 
macro SCB$V_CORRUPT2 = 28,5,1,0 %;      !  file structure is corrupt
macro SCB$W_WRITECNT = 32,0,16,0 %;     !  count of write access mounters.
macro SCB$T_VOLOCKNAME = 34,0,0,0 %;
literal SCB$S_VOLOCKNAME = 12;          !  name used for file system serialization on volume.
macro SCB$Q_MOUNTTIME = 46,0,0,0 %;
literal SCB$S_MOUNTTIME = 8;            !  time of last initial mount.
macro SCB$W_BACKREV = 54,0,16,0 %;      !  BACKUP revision number.
macro SCB$Q_GENERNUM = 56,0,0,0 %;
literal SCB$S_GENERNUM = 8;             !  shadow set revision number.
macro SCB$Q_UNIT_ID = 64,0,0,0 %;
literal SCB$S_UNIT_ID = 8;              !  Virtual Unit specifier
macro SCB$W_SHADOW_STATUS = 72,0,16,0 %; !  Volume status:
macro SCB$W_STATUS = 72,0,16,0 %;       !  Duplicate pointer to status
macro SCB$V_NORMAL = 72,0,1,0 %;        !  Shadow set populated and online
macro SCB$V_NEW = 72,1,1,0 %;           !  Newly created, no members yet
macro SCB$V_REBLDNG = 72,2,1,0 %;       !  rebuilding shadow set
macro SCB$V_VERIFY = 72,3,1,0 %;        !  This SS needs verification
macro SCB$V_MVBEGUN = 72,4,1,0 %;       !  Mount verification initiated
macro SCB$V_COPYING = 72,5,1,0 %;       !  Full copy in progreess
macro SCB$V_MERGING = 72,6,1,0 %;       !  Merge copy in progress
macro SCB$V_MINIMRG = 72,7,1,0 %;       !  Mini-merge in progress
macro SCB$V_CPY_RESET = 72,8,1,0 %;     !  Copy mode is reset.
macro SCB$V_BOOTING = 72,9,1,0 %;       !  Shadow set in booting state
macro SCB$V_WLG = 72,10,1,0 %;          !  Write Logging
macro SCB$V_INVWLG = 72,11,1,0 %;       !  Invalid write logging
macro SCB$V_FAILED = 72,15,1,0 %;       !  Shadow set not populated
macro SCB$B_MEMBER_STATUS = 74,0,8,0 %; !  Member status bytes
macro SCB$V_MBR_FCPY = 74,0,1,0 %;      !  Member involved in copy
macro SCB$V_MBR_MERGE = 74,1,1,0 %;     !  Member being merged
macro SCB$V_MBR_CIP = 74,2,1,0 %;       !  Copy (or merge) in progress
macro SCB$V_MBR_MASTER = 74,3,1,0 %;    !  Member with guaranteed correct
!   SCB. Same member as MEMBERSHIP_LOCK
macro SCB$V_MBR_ERROR = 74,4,1,0 %;     !  Error processing in progress
macro SCB$V_MBR_SRC = 74,5,1,0 %;       !  member can be used for source
macro SCB$V_MBR_DCD = 74,6,1,0 %;       !  Assisted copy source
macro SCB$V_MBR_VALID = 74,7,1,0 %;     !  Status information is valid
macro SCB$Q_MEMBER_IDS = 80,0,0,0 %;
literal SCB$S_MEMBER_IDS = 24;          !  Unit ID for member
macro SCB$L_SCB_LBN = 104,0,32,0 %;     !  Unit Control Block for VU
macro SCB$B_DEVICES = 108,0,8,0 %;      !  Number of devices in SS
macro SCB$B_MEMBERS = 109,0,8,0 %;      !  Number of full members
macro SCB$B_MAST_INDX = 110,0,8,0 %;    !  Array index to master UCB
macro SCB$B_MRG_TARGETS = 111,0,8,0 %;  !  Merge Copy Targets
macro SCB$B_FC_TARGETS = 112,0,8,0 %;   !  Full Copy Targets
macro SCB$W_CHECKSUM = 510,0,16,0 %;    !  block checksum 
 
!*** MODULE $BBMDEF ***
! +
! 
!  Bad block map (generated by bad block scan program)
! 
! -
literal BBM$K_POINTERS = 4;             !  start of retrieval pointers 
literal BBM$C_POINTERS = 4;             !  start of retrieval pointers 
literal BBM$S_BBMDEF = 512;             !  Old size name - synonym                                    			/* retrieval pointer format
literal BBM$S_BBM = 512;
macro BBM$B_COUNTSIZE = 0,0,8,0 %;      !  retrieval pointer count field size 
macro BBM$B_LBNSIZE = 1,0,8,0 %;        !  retrieval pointer LBN field size 
macro BBM$B_INUSE = 2,0,8,0 %;          !  number of retrieval words in use 
macro BBM$B_AVAIL = 3,0,8,0 %;          !  number of retrieval words available 
macro BBM$W_CHECKSUM = 510,0,16,0 %;    !  block checksum 
literal BBM$S_BBMDEF1 = 4;              !  Old size name - synonym
literal BBM$S_BBM1 = 4;
macro BBM$B_HIGHLBN = 0,0,8,0 %;        !  high order LBN 
macro BBM$B_COUNT = 1,0,8,0 %;          !  block count 
macro BBM$W_LOWLBN = 2,0,16,0 %;        !  low order LBN 
literal BBM$S_BBMDEF2 = 5;              !  Old size name - synonym
literal BBM$S_BBM2 = 5;
macro BBM$B_PREVHLBN = -4,0,8,0 %;
macro BBM$B_PREVCOUNT = -3,0,8,0 %;
macro BBM$W_PREVLLBN = -2,0,16,0 %;     !  previous retrieval pointer 
 
!*** MODULE $BBDDEF ***
! +
! 
!  Bad block descriptor (generated by formatters for RK06, RM03, et al)
! 
! -
literal BBD$K_DESCRIPT = 8;             !  start of bad block descriptors 
literal BBD$C_DESCRIPT = 8;             !  start of bad block descriptors 
literal BBD$S_BBDDEF = 512;             !  Old size name - synonym        
literal BBD$S_BBD = 512;
macro BBD$L_SERIAL = 0,0,32,0 %;        !  pack serial number 
macro BBD$W_RESERVED = 4,0,16,0 %;      !  reserved area (MBZ) 
macro BBD$W_FLAGS = 6,0,16,0 %;         !  pack status flags (zero for normal use) 
macro BBD$L_LASTWORD = 508,0,32,0 %;    !  last longword of block 
literal BBD$K_ENTRY = 4;
literal BBD$C_ENTRY = 4;
literal BBD$S_BBDDEF1 = 4;              !  Old size name - synonym
literal BBD$S_BBD1 = 4;
macro BBD$L_BADBLOCK = 0,0,32,0 %;      !  individual bad block entry 
macro BBD$V_CYLINDER = 0,0,15,0 %;
literal BBD$S_CYLINDER = 15;            !  cylinder number of bad block 
macro BBD$V_SECTOR = 0,16,8,0 %;
literal BBD$S_SECTOR = 8;               !  sector number of bad block 
macro BBD$V_TRACK = 0,24,7,0 %;
literal BBD$S_TRACK = 7;                !  track number of bad block 
 
!*** MODULE $VSLDEF ***
! +
! 
!  Structure of a volume set list file entry. Record 1 contains the volume
!  set name. Record n+1 contains the volume label of RVN n in the volume set.
! 
! -
literal VSL$K_LENGTH = 64;
literal VSL$C_LENGTH = 64;
literal VSL$S_VSLDEF = 64;              !  Old size name - synonym    
literal VSL$S_VSL = 64;
macro VSL$T_NAME = 0,0,0,0 %;
literal VSL$S_NAME = 12;                !  volume name 
 
!*** MODULE $PBBDEF ***
! +
! 
!  Pending bad block file record format. Each record describes a disk block
!  on which an error has occurred which has not been turned over to the bad
!  block file.
! 
! -
literal PBB$M_READERR = %X'1';
literal PBB$M_WRITERR = %X'2';
literal PBB$K_LENGTH = 16;              !  length of entry 
literal PBB$C_LENGTH = 16;              !  length of entry 
literal PBB$S_PBBDEF = 16;              !  Old size name - synonym    
literal PBB$S_PBB = 16;
macro PBB$W_FID = 0,0,0,0 %;
literal PBB$S_FID = 6;                  !  File ID of containing file 
macro PBB$B_FLAGS = 6,0,8,0 %;          !  status flags 
macro PBB$V_READERR = 6,0,1,0 %;        !  read error occurred 
macro PBB$V_WRITERR = 6,1,1,0 %;        !  write error occurred 
macro PBB$B_COUNT = 7,0,8,0 %;          !  error count 
macro PBB$L_VBN = 8,0,32,0 %;           !  virtual block in file 
macro PBB$L_LBN = 12,0,32,0 %;          !  logical block number 
 
!*** MODULE $DQFDEF ***
! +
! 
!  Structure of disk quota file record. Each record contains the authorization
!  and usage of a particular UIC for this volume set.
! 
! -
literal DQF$M_ACTIVE = %X'1';
literal DQF$K_LENGTH = 32;
literal DQF$C_LENGTH = 32;
literal DQF$S_DQFDEF = 32;              !  Old size name - synonym
literal DQF$S_DQF = 32;
macro DQF$L_FLAGS = 0,0,32,0 %;         !  flags longword, containing... 
macro DQF$V_ACTIVE = 0,0,1,0 %;         !  record contains an active entry 
macro DQF$L_UIC = 4,0,32,0 %;           !  UIC of this record 
macro DQF$L_USAGE = 8,0,32,0 %;         !  number of blocks in use 
macro DQF$L_PERMQUOTA = 12,0,32,0 %;    !  permanent disk quota 
macro DQF$L_OVERDRAFT = 16,0,32,0 %;    !  overdraft limit 
! 
! ****************************************************************************
! *                                                                          *
! *  Copyright (c) 1995                                                      *
! *  by DIGITAL Equipment Corporation, Maynard, Mass.                        *
! *                                                                          *
! *  This software is furnished under a license and may be used and  copied  *
! *  only  in  accordance  with  the  terms  of  such  license and with the  *
! *  inclusion of the above copyright notice.  This software or  any  other  *
! *  copies  thereof may not be provided or otherwise made available to any  *
! *  other person.  No title to and ownership of  the  software  is  hereby  *
! *  transferred.                                                            *
! *                                                                          *
! *  The information in this software is subject to change  without  notice  *
! *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment  *
! *  Corporation.                                                            *
! *                                                                          *
! *  DIGITAL assumes no responsibility for the use or  reliability  of  its  *
! *  software on equipment which is not supplied by DIGITAL.                 *
! *                                                                          *
! ****************************************************************************
! ********************************************************************************************************************************
!  Created:  4-MAY-1995 17:55:52 by OpenVMS SDL EV1-36     
!  Source:  13-MAY-1993 14:02:07 $64$DUA3210:[LIB.SRC]F11CDEF.SDL;1 
! ********************************************************************************************************************************
 
!*** MODULE $F11CDEF IDENT X-3 ***
! 
!  File sections shall be recorded in the Data Area. The following types of
!  descriptors shall be record in the data area of a volume. 
! 
! 	o Volume Descriptors
! 	    o Boot Record (BOOT)
! 	    o Volume Descriptor Set Terminator (VDST)
! 	    o Primary Volume Descriptor (PVD)
! 	    o Supplementary Volume Descriptor (SVD)
! 	    o Volume Partition Descriptor (VPD)
! 	o File Descriptors
! 	o Directory Descriptors
! 	o Path Tables
! 
! 
!  ISO 9660 standard constants
! 
literal ISO$K_LOGICAL_BLOCK_SIZE = 2048; !  Current Volume Descriptor Block Size
literal ISO$K_SYSTEM_AREA = 0;          !  Logical Block number of System Area
literal ISO$K_DATA_AREA = 16;           !  Logical Block number of Data Area
literal ISO$K_ISO_9660_VERSION_1988 = 1; !  Volume Descriptor Version # for ISO 9660 (1988)
! 
!  Character set coding
! 
literal ISO$K_SPACE = 32;               !  ' ' fill character
literal ISO$K_SEPARATOR_1 = 46;         !  '.'-filename.extension break
literal ISO$K_SEPARATOR_2 = 59;         !  ';'-extension;version break
literal ISO$K_FILE_ID = 95;             !  '_' file identifier character
literal ISO$K_ROOT_DIRECTORY_ID = 0;    !  Root Directory Identifier
literal ISO$K_PARENT_DIRECTORY_ID = 1;  !  Parent Directory Identifier
! +
!  FILE_ID
! 
!   A File Identifier consist of the following sequence:
! 	- File name : A sequence of 0 -> 30 'D' or 'D1' characters
! 	- SEPARATOR_1
! 	- Extension : A sequence of 0 -> 30 'D' or 'D1' characters
! 	- SEPARATOR_2
! 	- Version # : A sequence of 1 to 5 digits; up to "32767"
!   If 'File Name' length equals 0, then Extension must be 1 or greater
!   If 'Extension' length equals 0, then File Name must be 1 or greater
!   The length of 'File Name' + 'Extension' must not exceed 30.
! -
literal ISO$FNAME$S_FILE_ID = 37;       !  Old size name- synonym
literal ISO$FNAME$S_F11C_FILE_ID = 37;
macro ISO$FNAME$T_FILE_NAME_EXT = 0,0,0,0 %;
literal ISO$FNAME$S_FILE_NAME_EXT = 37; !  filename.ext;version
! +
!  Identifier
! 
!   This descriptor shall specify an identifier. If the first byte is equal
!   to a %X05F, the remaining bytes of this field shall specific an
!   identifier for a file containing the identification text. This file
!   shall be described in the Root Directory. The File Name shall not
!   contain more than 8 D_CHARACTERS and the File Extension shall not
!   contain more than 3 D_CHARACTERS. If all bytes in this field are set to
!   %X20, it shall mean that no such identifier is defined.
! -
literal ISO$ID$S_IDENTIFIER = 128;      !  Old size name - synonym
literal ISO$ID$S_F11C_IDENTIFIER = 128;
macro ISO$ID$R_ENCODED_ID = 0,0,0,0 %;
literal ISO$ID$S_ENCODED_ID = 38;
macro ISO$ID$B_FLAG = 0,0,8,0 %;        !  File specific flag
macro ISO$ID$T_FILE_NAME_EXT = 1,0,0,0 %;
literal ISO$ID$S_FILE_NAME_EXT = 37;    !  File Identifier (filename.ext;version)
macro ISO$ID$B_DATA = 0,0,0,1 %;
literal ISO$ID$S_DATA = 128;            !  Text Identifier
! +
!  ASCII_DATE_TIME
! 
!   The date and time shall be represented by a 17-byte field.
!   If Byte positions 1-16 are the digit '0', and BP 17 equals 0, then
!   it shall mean that date and time are not specified.
! -
literal ISO$AUTC$S_ASCII_DATE_TIME = 17; !  Old size name - synonym
literal ISO$AUTC$S_F11C_ASCII_DATE = 17;
macro ISO$AUTC$T_YEAR = 0,0,32,0 %;
literal ISO$AUTC$S_YEAR = 4;            !  year (1-9999)
macro ISO$AUTC$T_MONTH = 4,0,16,0 %;
literal ISO$AUTC$S_MONTH = 2;           !  month (1-12)
macro ISO$AUTC$T_DAY = 6,0,16,0 %;
literal ISO$AUTC$S_DAY = 2;             !  day (1-31)
macro ISO$AUTC$T_HOUR = 8,0,16,0 %;
literal ISO$AUTC$S_HOUR = 2;            !  hour (0-23)
macro ISO$AUTC$T_MINUTE = 10,0,16,0 %;
literal ISO$AUTC$S_MINUTE = 2;          !  minute (0-59)
macro ISO$AUTC$T_SECOND = 12,0,16,0 %;
literal ISO$AUTC$S_SECOND = 2;          !  second (0-59)
macro ISO$AUTC$T_HUNDREDTH = 14,0,16,0 %;
literal ISO$AUTC$S_HUNDREDTH = 2;       !  hundredth (0-99)
macro ISO$AUTC$B_OFFSET_GMT = 16,0,8,1 %; !   hr. intervals (-48:+52))
! +
!  BINARY_DATE_TIME
! 
!   The data and time shall be represented by seven 8-bit numbers
! -
literal ISO$BUTC$S_BINARY_DATE_TIME = 7; !  Old size name - synonym
literal ISO$BUTC$S_F11C_BINARY_DATE = 7;
macro ISO$BUTC$B_YEAR = 0,0,8,0 %;      !  year since 1900 (1-99)
macro ISO$BUTC$B_MONTH = 1,0,8,0 %;     !  month (1-12)
macro ISO$BUTC$B_DAY = 2,0,8,0 %;       !  day (1-31)
macro ISO$BUTC$B_HOUR = 3,0,8,0 %;      !  hour (0-23)
macro ISO$BUTC$B_MINUTE = 4,0,8,0 %;    !  minute (0-59)
macro ISO$BUTC$B_SECOND = 5,0,8,0 %;    !  second (0-59)
macro ISO$BUTC$B_OFFSET_GMT = 6,0,8,1 %; !   hr. intervals from -48(west) to +52(east)
! +
!   PATH_TABLE_RECORD
! 
!   A Path Table contain a set of records describing a directory hierarchy
!   for those volume of a Volume Set the sequence numbers of which are less
!   than, or equal to, the assigned Volume Set size of the volume.
! 
!   For each directory in the directory hierarchy other then the Root
!   Directory, the Path Table shall contain a record which identifies
!   the directory, its Parent Directory and its location. The records
!   in a Path Table shall be number starting at 1. The first record in
!   the Path Table shall identify the Root Directory and it location.
! 
! -
literal ISO$PTBL$S_PATH_TABLE_RECORD = 45; !  Old size name - synonym
literal ISO$PTBL$S_F11C_PATH_TABLE_REC = 45;
macro ISO$PTBL$B_DIRECTORY_ID_LENGTH = 0,0,8,0 %; !  Length of directory Identifier
macro ISO$PTBL$B_XAR_LENGTH = 1,0,8,0 %; !  Extended Attribute Record length
macro ISO$PTBL$L_EXTENT_LOCATION = 2,0,32,0 %; !  Location of Extent
macro ISO$PTBL$W_PARENT_DIRECTORY = 6,0,16,0 %; !  Parent Directory Number
macro ISO$PTBL$T_DIRECTORY_ID = 8,0,0,0 %;
literal ISO$PTBL$S_DIRECTORY_ID = 37;   !  Directory Identifier (dirname)
! +
!  DIRECTORY
!   This descriptor shall define a directory record. A directory record
!   contains information to locate a File Section; an Extended Attribute
!   Record associated with a File Section; the identification of a file;
!   attributes of a file and file section.
! -
literal ISO$DREC$M_EXISTENCE = %X'1';
literal ISO$DREC$M_DIRECTORY = %X'2';
literal ISO$DREC$M_ASSOCIATED = %X'4';
literal ISO$DREC$M_RECORD = %X'8';
literal ISO$DREC$M_PROTECTION = %X'10';
literal ISO$DREC$M_RESERVED = %X'60';
literal ISO$DREC$M_MULTI_EXTENT = %X'80';
literal ISO$DREC$A_PADDING = 34;        !  Pad byte
literal ISO$DREC$A_SYSTEM_USE = 34;     !  System use
literal ISO$DREC$S_DIRECTORY = 512;     !  Old size name - synonym
literal ISO$DREC$S_F11C_DIRECTORY = 512;
macro ISO$DREC$B_DIRECTORY_LENGTH = 0,0,8,0 %; !  Length of directory record
macro ISO$DREC$B_XAR_LENGTH = 1,0,8,0 %; !  Extended Attribute Length
macro ISO$DREC$L_EXTENT_LOCATION = 2,0,32,0 %; !  Location of Extent (LBN)
macro ISO$DREC$L_EXTENT_LOCATION_M = 6,0,32,0 %; !  Location of Extent (LBN)
macro ISO$DREC$L_DATA_LENGTH = 10,0,32,0 %; !  Data Length of File Section
macro ISO$DREC$L_DATA_LENGTH_M = 14,0,32,0 %; !  Data Length of File Section
macro ISO$DREC$B_FILE_RECORDING = 18,0,0,1 %;
literal ISO$DREC$S_FILE_RECORDING = 7;  !  Recording Date/Time of extent
macro ISO$DREC$B_FILE_FLAGS = 25,0,8,0 %; !  File characteristics
macro ISO$DREC$V_EXISTENCE = 25,0,1,0 %; !  If set; nonexistent
macro ISO$DREC$V_DIRECTORY = 25,1,1,0 %; !  If set; directory record
macro ISO$DREC$V_ASSOCIATED = 25,2,1,0 %; !  If set; associated file
macro ISO$DREC$V_RECORD = 25,3,1,0 %;   !  If set; record format via XAR.RFM
macro ISO$DREC$V_PROTECTION = 25,4,1,0 %; !  If set; enforce protection
macro ISO$DREC$V_MULTI_EXTENT = 25,7,1,0 %; !  If set; extend record
macro ISO$DREC$B_FILE_UNIT_SIZE = 26,0,8,0 %; !  Interleave File Unit size
macro ISO$DREC$B_INTERLEAVE_GAP = 27,0,8,0 %; !  Interleave Gap size
macro ISO$DREC$W_VOLUME_NUMBER = 28,0,16,0 %; !  Volume Sequence # of extent
macro ISO$DREC$W_VOLUME_NUMBER_M = 30,0,16,0 %; !  Volume Sequence # of extent
macro ISO$DREC$B_FILE_ID_LENGTH = 32,0,8,0 %; !  File Identifier Field Length
macro ISO$DREC$B_FILE_ID = 33,0,8,1 %;  !  File Identifier
! +
!  XAR_RECORD
!   This descriptor shall define an Extended Attribute Record. An
!   extended attribute record contains addition information which
!   is associated to a File Section.
! 
! -
literal ISO$XAR$M_SYS_NO_READ = %X'1';
literal ISO$XAR$M_FILL_1 = %X'2';
literal ISO$XAR$M_SYS_NO_EXECUTE = %X'4';
literal ISO$XAR$M_FILL_2 = %X'8';
literal ISO$XAR$M_OWN_NO_READ = %X'10';
literal ISO$XAR$M_FILL_3 = %X'20';
literal ISO$XAR$M_OWN_NO_EXECUTE = %X'40';
literal ISO$XAR$M_FILL_4 = %X'80';
literal ISO$XAR$M_GRP_NO_READ = %X'100';
literal ISO$XAR$M_FILL_5 = %X'200';
literal ISO$XAR$M_GRP_NO_EXECUTE = %X'400';
literal ISO$XAR$M_FILL_6 = %X'800';
literal ISO$XAR$M_WLD_NO_READ = %X'1000';
literal ISO$XAR$M_FILL_7 = %X'2000';
literal ISO$XAR$M_WLD_NO_EXECUTE = %X'4000';
literal ISO$XAR$M_FILL_8 = %X'8000';
literal ISO$XAR$RFM$K_UNDEFINED = 0;
literal ISO$XAR$RFM$K_FIXED = 1;
literal ISO$XAR$RFM$K_LSB_VARIABLE = 2;
literal ISO$XAR$RFM$K_MSB_VARIABLE = 3;
literal ISO$XAR$RFM$SYS$K_UNDEFINED = 128;
literal ISO$XAR$RFM$SYS$K_FIXED = 129;
literal ISO$XAR$RFM$SYS$K_VARIABLE = 130;
literal ISO$XAR$RFM$SYS$K_VFC = 131;
literal ISO$XAR$RFM$SYS$K_STREAM = 132;
literal ISO$XAR$RFM$SYS$K_STREAMLF = 133;
literal ISO$XAR$RFM$SYS$K_STREAMCR = 134;
literal ISO$XAR$ATR$K_CRLF = 0;
literal ISO$XAR$ATR$K_FTN = 1;
literal ISO$XAR$ATR$K_STM = 2;
literal ISO$XAR$A_ESCAPE_SEQUENCE = 250; !  Escape Sequences
literal ISO$XAR$S_XAR_RECORD = 512;     !  Old size name - synonym
literal ISO$XAR$S_F11C_XAR_RECORD = 512;
macro ISO$XAR$W_OWNER_ID = 0,0,16,0 %;  !  Owner Identification
macro ISO$XAR$W_OWNER_ID_M = 2,0,16,0 %; !  Owner Identification
macro ISO$XAR$W_GROUP_ID = 4,0,16,0 %;  !  Group Identification
macro ISO$XAR$W_GROUP_ID_M = 6,0,16,0 %; !  Group Identification
macro ISO$XAR$W_PERMISSIONS = 8,0,16,0 %; !  Access permission for classes of users
macro ISO$XAR$V_SYS_NO_READ = 8,0,1,0 %; !  If set; ~(S:R)
macro ISO$XAR$V_SYS_NO_EXECUTE = 8,2,1,0 %; !  If set; ~(S:E)
macro ISO$XAR$V_OWN_NO_READ = 8,4,1,0 %; !  If set; ~(O:R)
macro ISO$XAR$V_OWN_NO_EXECUTE = 8,6,1,0 %; !  If set; ~(O:E)
macro ISO$XAR$V_GRP_NO_READ = 8,8,1,0 %; !  If set; ~(G:R)
macro ISO$XAR$V_GRP_NO_EXECUTE = 8,10,1,0 %; !  If set; ~(G:E)
macro ISO$XAR$V_WLD_NO_READ = 8,12,1,0 %; !  If set; ~(W:R)
macro ISO$XAR$V_WLD_NO_EXECUTE = 8,14,1,0 %; !  If set; ~(W:E)
macro ISO$XAR$B_FILE_CREATION = 10,0,0,1 %;
literal ISO$XAR$S_FILE_CREATION = 17;   !  File Creation Date/Time
macro ISO$XAR$B_FILE_MODIFICATION = 27,0,0,1 %;
literal ISO$XAR$S_FILE_MODIFICATION = 17; !  File Modification Date/Time
macro ISO$XAR$B_FILE_EXPIRATION = 44,0,0,1 %;
literal ISO$XAR$S_FILE_EXPIRATION = 17; !  File Expiration Date/Time
macro ISO$XAR$B_FILE_EFFECTIVE = 61,0,0,1 %;
literal ISO$XAR$S_FILE_EFFECTIVE = 17;  !  File Effective Date/Time
macro ISO$XAR$B_RECORD_FORMAT = 78,0,8,0 %; !  Record Format
macro ISO$XAR$B_RECORD_ATTRIBUTES = 79,0,8,0 %; !  Record Attributes
macro ISO$XAR$W_RECORD_LENGTH = 80,0,16,0 %; !  Record Length
macro ISO$XAR$W_RECORD_LENGTH_M = 82,0,16,0 %; !  Record Length
macro ISO$XAR$T_SYSTEM_ID = 84,0,0,0 %;
literal ISO$XAR$S_SYSTEM_ID = 32;       !  System Identifier 
macro ISO$XAR$B_SYSTEM_USE = 116,0,0,1 %;
literal ISO$XAR$S_SYSTEM_USE = 64;      !  System Used
macro ISO$XAR$B_XAR_VERSION = 180,0,8,0 %; !  Extended Attribute Version
macro ISO$XAR$B_ESCAPE_SEQ_LENGTH = 181,0,8,0 %; !  Escape Sequence record length
macro ISO$XAR$W_APPLICATION_USE = 246,0,16,0 %; !  Application Use Length
macro ISO$XAR$W_APPLICATION_USE_M = 248,0,16,0 %; !  Application Use Length
macro ISO$XAR$B_APPLICATION_USE = 250,0,0,1 %;
literal ISO$XAR$S_APPLICATION_USE = 262; !  Application Use
! +
!  Volume Descriptor
! 
!   The Volume Descriptor shall Identify the volume, the partitions recorded
!   on the volume, the volume creator(s),  certain attributes of the volume,
!   the location of other recorded descriptors and the version of the
!   standard which applies to the volume descriptor.
! 
! -
literal ISO$VD$K_BOOT = 0;              ! 	Boot Record Descriptor
literal ISO$VD$K_PVD = 1;               ! 	Primary Volume Descriptor
literal ISO$VD$K_SVD = 2;               ! 	Supplementary Volume Descriptor
literal ISO$VD$K_VPD = 3;               ! 	Volume Partition Descriptor
! 						(Values 4 to 254 are reserved)
literal ISO$VD$K_VDST = 255;            ! 	Volume Descriptor Set Terminator
literal ISO$VD$S_VD = 2048;             !  Old size name - synonym
literal ISO$VD$S_F11C_VD = 2048;
macro ISO$VD$B_VOLUME_DESCRIPTOR_TYPE = 0,0,8,0 %; !  Volume Descriptor Type
macro ISO$VD$T_STANDARD_IDENTIFIER = 1,0,0,0 %;
literal ISO$VD$S_STANDARD_IDENTIFIER = 5; !  International Standard Id. (CD001)
macro ISO$VD$B_VOLUME_DESCRIPTOR_VERS = 6,0,8,0 %; !  Volume Descriptor Version
macro ISO$VD$B_VOLUME_DATA = 7,0,0,1 %;
literal ISO$VD$S_VOLUME_DATA = 2041;    !  Volume Descriptor Data
! +
!  Boot Record (BOOT)
!  
!   The Boot Record shall Identify a system which can recognize and act upon
!   the content of the field reserved for boot system use in the Boot
!   Record, and shall contain information which is used to achieve a
!   specific state for a system or for an application.
!  
! -
literal ISO$BOOT$S_BOOT = 2048;         !  Old size name - synonym
literal ISO$BOOT$S_F11C_BOOT = 2048;
macro ISO$BOOT$B_BOOT_VOLUME = 0,0,0,1 %;
literal ISO$BOOT$S_BOOT_VOLUME = 7;     !  Boot Volume Descriptor
macro ISO$BOOT$T_SYSTEM_IDENTIFIER = 7,0,0,0 %;
literal ISO$BOOT$S_SYSTEM_IDENTIFIER = 32; !  Boot System Identifier
macro ISO$BOOT$T_IDENTIFIER = 39,0,0,0 %;
literal ISO$BOOT$S_IDENTIFIER = 32;     !  Boot Identifier
macro ISO$BOOT$B_SYSTEM_USE = 71,0,0,1 %;
literal ISO$BOOT$S_SYSTEM_USE = 1977;   !  Boot System Use
! +
!  Volume Descriptor Set Terminator
! 
!   The recorded set of Volume Descriptors shall be terminated by a sequence
!   of one or more Volume Descriptor Set Terminators
! 
! -
literal ISO$VDST$S_VDST = 2048;         !  Old size name - synonym
literal ISO$VDST$S_F11C_VDST = 2048;
macro ISO$VDST$B_TERMINATOR_VOLUME = 0,0,0,1 %;
literal ISO$VDST$S_TERMINATOR_VOLUME = 7; !  Volume Descriptor Set
! +
!  Primary Volume Descriptor
! 
!   The Primary Volume Descriptor shall Identify the volume, a system which
!   can recognize and act upon the content of the Logical Sectors with
!   Logical Sector Number 0 to 15, the size of the Volume Space, the version
!   of the  standard which applies to the Volume Descriptor, the version of
!   the specification which applies to the Directory Records and the Path
!   Table Records and certain attributes of the volume.
! 
! -
literal ISO$PVD$S_PVD = 2048;           !  Old size name - synonym
literal ISO$PVD$S_F11C_PVD = 2048;
macro ISO$PVD$B_PRIMARY_VOLUME = 0,0,0,1 %;
literal ISO$PVD$S_PRIMARY_VOLUME = 7;   !  Primary Volume Descriptor
macro ISO$PVD$T_SYSTEM_IDENTIFIER = 8,0,0,0 %;
literal ISO$PVD$S_SYSTEM_IDENTIFIER = 32; !  System Identifier
macro ISO$PVD$T_VOLUME_IDENTIFIER = 40,0,0,0 %;
literal ISO$PVD$S_VOLUME_IDENTIFIER = 32; !  Volume Identifier
macro ISO$PVD$L_VOLUME_SPACE_SIZE = 80,0,32,0 %; !  Volume Space Size
macro ISO$PVD$L_VOLUME_SPACE_SIZE_M = 84,0,32,0 %; !  Volume Space Size
macro ISO$PVD$W_VOLUME_SET_SIZE = 120,0,16,0 %; !  Volume Set Size
macro ISO$PVD$W_VOLUME_SET_SIZE_M = 122,0,16,0 %; !  Volume Set Size
macro ISO$PVD$W_VOLUME_NUMBER = 124,0,16,0 %; !  Volume Sequence Number
macro ISO$PVD$W_VOLUME_NUMBER_M = 126,0,16,0 %; !  Volume Sequence Number
macro ISO$PVD$W_LOGICAL_BLOCK_SIZE = 128,0,16,0 %; !  Logical Block Size
macro ISO$PVD$W_LOGICAL_BLOCK_SIZE_M = 130,0,16,0 %; !  Logical Block Size
macro ISO$PVD$L_PATH_TABLE_SIZE = 132,0,32,0 %; !  Path Table Size
macro ISO$PVD$L_PATH_TABLE_SIZE_M = 136,0,32,0 %; !  Path Table Size
macro ISO$PVD$L_PATH_TABLE = 140,0,32,0 %; !  Path Table Logical Block #
macro ISO$PVD$L_OPT_PATH_TABLE = 144,0,32,0 %; !  Optional Path Table Logical Block #
macro ISO$PVD$L_PATH_TABLE_M = 148,0,32,0 %; !  Path Table Logical Block #
macro ISO$PVD$L_OPT_PATH_TABLE_M = 152,0,32,0 %; !  Optional Path Table Logical Block #
macro ISO$PVD$B_ROOT_DIRECTORY = 156,0,0,1 %;
literal ISO$PVD$S_ROOT_DIRECTORY = 34;  !  Root Directory Record
macro ISO$PVD$T_VOLUME_SET_IDENTIFIER = 190,0,0,0 %;
literal ISO$PVD$S_VOLUME_SET_IDENTIFIER = 128; !  Volume Set Identifier
macro ISO$PVD$B_PUBLISHER_ID = 318,0,0,1 %;
literal ISO$PVD$S_PUBLISHER_ID = 128;   !  Publisher Identifier
macro ISO$PVD$B_DATA_PREPARER_ID = 446,0,0,1 %;
literal ISO$PVD$S_DATA_PREPARER_ID = 128; !  Data Preparer Identifier
macro ISO$PVD$B_APPLICATION_ID = 574,0,0,1 %;
literal ISO$PVD$S_APPLICATION_ID = 128; !  Application Identifier
macro ISO$PVD$B_COPYRIGHT_FILE_ID = 702,0,0,1 %;
literal ISO$PVD$S_COPYRIGHT_FILE_ID = 37; !  Copyright File Identifier
macro ISO$PVD$B_ABSTRACT_FILE_ID = 739,0,0,1 %;
literal ISO$PVD$S_ABSTRACT_FILE_ID = 37; !  Abstract File Identifier
macro ISO$PVD$B_BIBLIOGRAPHIC_ID = 776,0,0,1 %;
literal ISO$PVD$S_BIBLIOGRAPHIC_ID = 37; !  Bibliographic File Identifier
macro ISO$PVD$B_VOLUME_CREATION = 813,0,0,1 %;
literal ISO$PVD$S_VOLUME_CREATION = 17; !  Volume Creation Date/Time
macro ISO$PVD$B_VOLUME_MODIFIY = 830,0,0,1 %;
literal ISO$PVD$S_VOLUME_MODIFIY = 17;  !  Volume Modification Date/Time
macro ISO$PVD$B_VOLUME_EXPIRATION = 847,0,0,1 %;
literal ISO$PVD$S_VOLUME_EXPIRATION = 17; !  Volume Expiration Date/Time
macro ISO$PVD$B_VOLUME_EFFECTIVE = 864,0,0,1 %;
literal ISO$PVD$S_VOLUME_EFFECTIVE = 17; !  Volume Effective Date/Time
macro ISO$PVD$B_FILE_STRUCTURE_VERS = 881,0,8,0 %; !  File Structure Version
macro ISO$PVD$B_APPLICATION_USE = 883,0,0,1 %;
literal ISO$PVD$S_APPLICATION_USE = 512; !  Application Use field
! +
!  Supplementary Volume Descriptor
! 
!   The Supplementary Volume Descriptor shall Identify the volume, a system
!   which can recognize and act upon the content of the Logical Sectors with
!   Logical Sector Number 0 to 15, the size of the Volume Space, the version
!   of the  standard which applies to the Volume Descriptor, the version of
!   the specification which applies to the Directory Records and the Path
!   Table Records, certain attributes of the volume and the coded graphic
!   character sets used to interpret descriptor fields that contain
!   characters.
! 
! -
literal ISO$SVD$M_NON_ISO_2375 = %X'1';
literal ISO$SVD$S_SVD = 2048;           !  Old size name - synonym
literal ISO$SVD$S_F11C_SVD = 2048;
macro ISO$SVD$B_SUPPLEMENTARY_VOLUME = 0,0,0,1 %;
literal ISO$SVD$S_SUPPLEMENTARY_VOLUME = 7; !  Supplementary Volume Descriptor
macro ISO$SVD$B_VOLUME_FLAGS = 7,0,8,0 %; !  Volume characteristics
macro ISO$SVD$V_NON_ISO_2375 = 7,0,1,0 %; !  If set; Escape Sequence is non ISO-2375 compliant
macro ISO$SVD$T_SYSTEM_IDENTIFIER = 8,0,0,0 %;
literal ISO$SVD$S_SYSTEM_IDENTIFIER = 32; !  System Identifier
macro ISO$SVD$T_VOLUME_IDENTIFIER = 40,0,0,0 %;
literal ISO$SVD$S_VOLUME_IDENTIFIER = 32; !  Volume Identifier
macro ISO$SVD$L_VOLUME_SPACE_SIZE = 80,0,32,0 %; !  Volume Space Size
macro ISO$SVD$L_VOLUME_SPACE_SIZE_M = 84,0,32,0 %; !  Volume Space Size
macro ISO$SVD$B_ESCAPE_SEQUENCES = 88,0,0,1 %;
literal ISO$SVD$S_ESCAPE_SEQUENCES = 32; !  Escape Sequences ISO 2022 for G0, G1
macro ISO$SVD$W_VOLUME_SET_SIZE = 120,0,16,0 %; !  Volume Set Size
macro ISO$SVD$W_VOLUME_SET_SIZE_M = 122,0,16,0 %; !  Volume Set Size
macro ISO$SVD$W_VOLUME_NUMBER = 124,0,16,0 %; !  Volume Sequence Number
macro ISO$SVD$W_VOLUME_NUMBER_M = 126,0,16,0 %; !  Volume Sequence Number
macro ISO$SVD$W_LOGICAL_BLOCK_SIZE = 128,0,16,0 %; !  Logical Block Size
macro ISO$SVD$W_LOGICAL_BLOCK_SIZE_M = 130,0,16,0 %; !  Logical Block Size
macro ISO$SVD$L_PATH_TABLE_SIZE = 132,0,32,0 %; !  Path Table Size
macro ISO$SVD$L_PATH_TABLE_SIZE_M = 136,0,32,0 %; !  Path Table Size
macro ISO$SVD$L_PATH_TABLE = 140,0,32,0 %; !  Path Table Logical Block #
macro ISO$SVD$L_OPT_PATH_TABLE = 144,0,32,0 %; !  Optional Path Table Logical Block #
macro ISO$SVD$L_PATH_TABLE_M = 148,0,32,0 %; !  Path Table Logical Block #
macro ISO$SVD$L_OPT_PATH_TABLE_M = 152,0,32,0 %; !  Optional Path Table Logical Block #
macro ISO$SVD$B_ROOT_DIRECTORY = 156,0,0,1 %;
literal ISO$SVD$S_ROOT_DIRECTORY = 34;  !  Root Directory Record
macro ISO$SVD$T_VOLUME_SET_IDENTIFIER = 190,0,0,0 %;
literal ISO$SVD$S_VOLUME_SET_IDENTIFIER = 128; !  Volume Set Identifier
macro ISO$SVD$B_PUBLISHER_ID = 318,0,0,1 %;
literal ISO$SVD$S_PUBLISHER_ID = 128;   !  Publisher Identifier
macro ISO$SVD$B_DATA_PREPARER_ID = 446,0,0,1 %;
literal ISO$SVD$S_DATA_PREPARER_ID = 128; !  Data Preparer Identifier
macro ISO$SVD$B_APPLICATION_ID = 574,0,0,1 %;
literal ISO$SVD$S_APPLICATION_ID = 128; !  Application Identifier
macro ISO$SVD$B_COPYRIGHT_FILE_ID = 702,0,0,1 %;
literal ISO$SVD$S_COPYRIGHT_FILE_ID = 37; !  Copyright File Identifier
macro ISO$SVD$B_ABSTRACT_FILE_ID = 739,0,0,1 %;
literal ISO$SVD$S_ABSTRACT_FILE_ID = 37; !  Abstract File Identifier
macro ISO$SVD$B_BIBLIOGRAPHIC_ID = 776,0,0,1 %;
literal ISO$SVD$S_BIBLIOGRAPHIC_ID = 37; !  Bibliographic File Identifier
macro ISO$SVD$B_VOLUME_CREATION = 813,0,0,1 %;
literal ISO$SVD$S_VOLUME_CREATION = 17; !  Volume Creation Date/Time
macro ISO$SVD$B_VOLUME_MODIFIY = 830,0,0,1 %;
literal ISO$SVD$S_VOLUME_MODIFIY = 17;  !  Volume Modification Date/Time
macro ISO$SVD$B_VOLUME_EXPIRATION = 847,0,0,1 %;
literal ISO$SVD$S_VOLUME_EXPIRATION = 17; !  Volume Expiration Date/Time
macro ISO$SVD$B_VOLUME_EFFECTIVE = 864,0,0,1 %;
literal ISO$SVD$S_VOLUME_EFFECTIVE = 17; !  Volume Effective Date/Time
macro ISO$SVD$B_FILE_STRUCTURE_VERS = 881,0,8,0 %; !  File Structure Version
macro ISO$SVD$B_APPLICATION_USE = 883,0,0,1 %;
literal ISO$SVD$S_APPLICATION_USE = 512; !  Application Use field
! +
!  Volume Partition Descriptor
! 
!   The Volume Partition Descriptor shall identify a volume partition with
!   the Volume Space, a system which can recognize and act upon the content
!   of fields reserved for system use in the Volume Descriptor, the position
!   and size of the volume partition, the version of the standard which
!   applies to the Volume Descriptor.
! 
! -
literal ISO$VPD$S_VPD = 2048;           !  Old size name - synonym
literal ISO$VPD$S_F11C_VPD = 2048;
macro ISO$VPD$B_VOLUME_PARTITION = 0,0,0,1 %;
literal ISO$VPD$S_VOLUME_PARTITION = 7; !  Volume Partition Descriptor
macro ISO$VPD$T_SYSTEM_IDENTIFIER = 8,0,0,0 %;
literal ISO$VPD$S_SYSTEM_IDENTIFIER = 32; !  System Identifier
macro ISO$VPD$T_PARTITION_IDENTIFIER = 40,0,0,0 %;
literal ISO$VPD$S_PARTITION_IDENTIFIER = 32; !  Volume Partition Identifier
macro ISO$VPD$L_PARTITION_LOCATION = 72,0,32,0 %; !  Location of Partition (LBN)
macro ISO$VPD$L_PARTITION_LOCATION_M = 76,0,32,0 %; !  Location of Partition (LBN)
macro ISO$VPD$L_PARTITION_SIZE = 80,0,32,0 %; !  Volume Partition Size
macro ISO$VPD$L_PARTITION_SIZE_M = 84,0,32,0 %; !  Volume Partition Size
macro ISO$VPD$B_SYSTEM_USE = 88,0,0,1 %;
literal ISO$VPD$S_SYSTEM_USE = 1960;    !  System Used
! 
! ****************************************************************************
! *                                                                          *
! *  Copyright (c) 1995                                                      *
! *  by DIGITAL Equipment Corporation, Maynard, Mass.                        *
! *                                                                          *
! *  This software is furnished under a license and may be used and  copied  *
! *  only  in  accordance  with  the  terms  of  such  license and with the  *
! *  inclusion of the above copyright notice.  This software or  any  other  *
! *  copies  thereof may not be provided or otherwise made available to any  *
! *  other person.  No title to and ownership of  the  software  is  hereby  *
! *  transferred.                                                            *
! *                                                                          *
! *  The information in this software is subject to change  without  notice  *
! *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment  *
! *  Corporation.                                                            *
! *                                                                          *
! *  DIGITAL assumes no responsibility for the use or  reliability  of  its  *
! *  software on equipment which is not supplied by DIGITAL.                 *
! *                                                                          *
! ****************************************************************************
! ********************************************************************************************************************************
!  Created:  4-MAY-1995 17:56:37 by OpenVMS SDL EV1-36     
!  Source:  13-MAY-1993 10:46:37 $64$DUA3210:[LIB.SRC]F11DDEF.SDL;1 
! ********************************************************************************************************************************
 
!*** MODULE $F11DDEF IDENT X-3 ***
! 
!  File sections shall be recorded in the Data Area. The following types of
!  descriptors shall be record in the data area of a volume. 
! 
! 	o Volume Descriptors
! 	    o Boot Record (BOOT)
! 	    o Volume Descriptor Set Terminator (VDST)
! 	    o Primary Volume Descriptor (PVD)
! 	    o Supplementary Volume Descriptor (SVD)
! 	    o Volume Partition Descriptor (VPD)
! 	o File Descriptors
! 	o Directory Descriptors
! 	o Path Tables
! 
! 
!  ISO 9660 standard constants
! 
literal HS$K_LOGICAL_BLOCK_SIZE = 2048; !  Current Volume Descriptor Block Size
literal HS$K_SYSTEM_AREA = 0;           !  Logical Block number of System Area
literal HS$K_DATA_AREA = 16;            !  Logical Block number of Data Area
literal HS$K_ISO_9660_VERSION_1988 = 1; !  Volume Descriptor Version # for ISO 9660 (1988)
! 
!  Character set coding
! 
literal HS$K_SPACE = 32;                !  ' ' fill character
literal HS$K_FULL_STOP = 46;            !  '.'-filename.extension break
literal HS$K_SEMICOLON = 59;            !  ';'-extension;version break
literal HS$K_ROOT_DIRECTORY_ID = 0;     !  Root Directory Identifier
literal HS$K_PARENT_DIRECTORY_ID = 1;   !  Parent Directory Identifier
! +
!  FILE_ID
! 
!   A File Identifier consist of the following sequence:
! 	- File name : A sequence of 0 -> 30 'D' or 'D1' characters
! 	- FULL_STOP
! 	- Extension : A sequence of 0 -> 30 'D' or 'D1' characters
! 	- SEMICOLON
! 	- Version # : A sequence of 1 to 5 digits; up to "32767"
!   If 'File Name' length equals 0, then Extension must be 1 or greater
!   If 'Extension' length equals 0, then File Name must be 1 or greater
!   if 'Version' length equals 0, then Version is assumed to be 1
!   The length of 'File Name' + 'Extension' must not exceed 30.
! -
literal HS$FNAME$S_FILE_ID = 32;        !  Old size name - synonym
literal HS$FNAME$S_F11D_FILE_ID = 32;
! +
!  Identifier
! 
!   This descriptor shall specify an identifier. If all bytes in this
!   field are set to %X20, it shall mean that no such identifier is defined.
! -
literal HS$ID$S_IDENTIFIER = 128;       !  Old size name - synonym
literal HS$ID$S_F11D_IDENTIFIER = 128;
macro HS$ID$B_DATA = 0,0,0,1 %;
literal HS$ID$S_DATA = 128;             !  Text Identifier
! +
!  ASCII_DATE_TIME
! 
!   The date and time shall be represented by a 16-byte field.
!   If Byte positions 1-16 are the digit '0' then
!   it shall mean that date and time are not specified.
! -
literal HS$AUTC$S_ASCII_DATE_TIME = 16; !  Old size name - synonym
literal HS$AUTC$S_F11D_ASCII_DATE = 16;
macro HS$AUTC$T_YEAR = 0,0,32,0 %;
literal HS$AUTC$S_YEAR = 4;             !  year (1-9999)
macro HS$AUTC$T_MONTH = 4,0,16,0 %;
literal HS$AUTC$S_MONTH = 2;            !  month (1-12)
macro HS$AUTC$T_DAY = 6,0,16,0 %;
literal HS$AUTC$S_DAY = 2;              !  day (1-31)
macro HS$AUTC$T_HOUR = 8,0,16,0 %;
literal HS$AUTC$S_HOUR = 2;             !  hour (0-23)
macro HS$AUTC$T_MINUTE = 10,0,16,0 %;
literal HS$AUTC$S_MINUTE = 2;           !  minute (0-59)
macro HS$AUTC$T_SECOND = 12,0,16,0 %;
literal HS$AUTC$S_SECOND = 2;           !  second (0-59)
macro HS$AUTC$T_HUNDREDTH = 14,0,16,0 %;
literal HS$AUTC$S_HUNDREDTH = 2;        !  hundredth (0-99)
! +
!  BINARY_DATE_TIME
! 
!   The data and time shall be represented by six 8-bit numbers
! -
literal HS$BUTC$S_BINARY_DATE_TIME = 6; !  Old size name - synonym
literal HS$BUTC$S_F11D_BINARY_DATE = 6;
macro HS$BUTC$B_YEAR = 0,0,8,0 %;       !  year since 1900 (1-99)
macro HS$BUTC$B_MONTH = 1,0,8,0 %;      !  month (1-12)
macro HS$BUTC$B_DAY = 2,0,8,0 %;        !  day (1-31)
macro HS$BUTC$B_HOUR = 3,0,8,0 %;       !  hour (0-23)
macro HS$BUTC$B_MINUTE = 4,0,8,0 %;     !  minute (0-59)
macro HS$BUTC$B_SECOND = 5,0,8,0 %;     !  second (0-59)
! +
!   PATH_TABLE_RECORD
! 
!   A Path Table contain a set of records describing a directory hierarchy
!   for those volume of a Volume Set the sequence numbers of which are less
!   than, or equal to, the assigned Volume Set size of the volume.
! 
!   For each directory in the directory hierarchy other then the Root
!   Directory, the Path Table shall contain a record which identifies
!   the directory, its Parent Directory and its location. The records
!   in a Path Table shall be number starting at 1. The first record in
!   the Path Table shall identify the Root Directory and it location.
! 
! -
literal HS$PTBL$S_PATH_TABLE_RECORD = 40; !  Old size name - synonym
literal HS$PTBL$S_F11D_PATH_TABLE_REC = 40;
macro HS$PTBL$L_EXTENT_LOCATION = 0,0,32,0 %; !  Location of Extent
macro HS$PTBL$B_XAR_LENGTH = 4,0,8,0 %; !  Extended Attribute Record length
macro HS$PTBL$B_DIRECTORY_ID_LENGTH = 5,0,8,0 %; !  Length of directory Identifier
macro HS$PTBL$W_PARENT_DIRECTORY = 6,0,16,0 %; !  Parent Directory Number
macro HS$PTBL$T_DIRECTORY_ID = 8,0,0,0 %;
literal HS$PTBL$S_DIRECTORY_ID = 32;    !  Directory Identifier (dirname)
! +
!  DIRECTORY
!   This descriptor shall define a directory record. A directory record
!   contains information to locate a File Section; an Extended Attribute
!   Record associated with a File Section; the identification of a file;
!   attributes of a file and file section.
! -
literal HS$DREC$M_EXISTENCE = %X'1';
literal HS$DREC$M_DIRECTORY = %X'2';
literal HS$DREC$M_ASSOCIATED = %X'4';
literal HS$DREC$M_RECORD = %X'8';
literal HS$DREC$M_PROTECTION = %X'10';
literal HS$DREC$M_RESERVED = %X'60';
literal HS$DREC$M_MULTI_EXTENT = %X'80';
literal HS$DREC$A_PADDING = 34;         !  Pad byte
literal HS$DREC$A_SYSTEM_USE = 34;      !  System use
literal HS$DREC$S_DIRECTORY = 512;      !  Old size name - synonym
literal HS$DREC$S_F11D_DIRECTORY = 512;
macro HS$DREC$B_DIRECTORY_LENGTH = 0,0,8,0 %; !  Length of directory record
macro HS$DREC$B_XAR_LENGTH = 1,0,8,0 %; !  Extended Attribute Length
macro HS$DREC$L_EXTENT_LOCATION = 2,0,32,0 %; !  Location of Extent (LBN)
macro HS$DREC$L_EXTENT_LOCATION_M = 6,0,32,0 %; !  Location of Extent (LBN)
macro HS$DREC$L_DATA_LENGTH = 10,0,32,0 %; !  Data Length of File Section
macro HS$DREC$L_DATA_LENGTH_M = 14,0,32,0 %; !  Data Length of File Section
macro HS$DREC$B_FILE_RECORDING = 18,0,0,1 %;
literal HS$DREC$S_FILE_RECORDING = 6;   !  Recording Date/Time of extent
macro HS$DREC$B_FILE_FLAGS = 24,0,8,0 %; !  File characteristics
macro HS$DREC$V_EXISTENCE = 24,0,1,0 %; !  If set; nonexistent
macro HS$DREC$V_DIRECTORY = 24,1,1,0 %; !  If set; directory record
macro HS$DREC$V_ASSOCIATED = 24,2,1,0 %; !  If set; associated file
macro HS$DREC$V_RECORD = 24,3,1,0 %;    !  If set; record format via XAR.RFM
macro HS$DREC$V_PROTECTION = 24,4,1,0 %; !  If set; enforce protection
macro HS$DREC$V_MULTI_EXTENT = 24,7,1,0 %; !  If set; extend record
macro HS$DREC$B_FILE_UNIT_SIZE = 26,0,8,0 %; !  Interleave File Unit Size
macro HS$DREC$B_INTERLEAVE_GAP = 27,0,8,0 %; !  Interleave gap size
macro HS$DREC$W_VOLUME_NUMBER = 28,0,16,0 %; !  Volume Sequence # of extent
macro HS$DREC$W_VOLUME_NUMBER_M = 30,0,16,0 %; !  Volume Sequence # of extent
macro HS$DREC$B_FILE_ID_LENGTH = 32,0,8,0 %; !  File Identifier Field Length
macro HS$DREC$B_FILE_ID = 33,0,8,1 %;   !  File Identifier
! +
!   XAR_RECORD
!   This descriptor shall define an Extended Attribute Record. An
!   extended attribute record contains addition information which
!   is associated to a File Section.
! 
! -
literal HS$XAR$M_SYS_NO_READ = %X'1';
literal HS$XAR$M_FILL_1 = %X'2';
literal HS$XAR$M_SYS_NO_EXECUTE = %X'4';
literal HS$XAR$M_FILL_2 = %X'8';
literal HS$XAR$M_OWN_NO_READ = %X'10';
literal HS$XAR$M_FILL_3 = %X'20';
literal HS$XAR$M_OWN_NO_EXECUTE = %X'40';
literal HS$XAR$M_FILL_4 = %X'80';
literal HS$XAR$M_GRP_NO_READ = %X'100';
literal HS$XAR$M_FILL_5 = %X'200';
literal HS$XAR$M_GRP_NO_EXECUTE = %X'400';
literal HS$XAR$M_FILL_6 = %X'800';
literal HS$XAR$M_WLD_NO_READ = %X'1000';
literal HS$XAR$M_FILL_7 = %X'2000';
literal HS$XAR$M_WLD_NO_EXECUTE = %X'4000';
literal HS$XAR$M_FILL_8 = %X'8000';
literal HS$XAR$RFM$K_UNDEFINED = 0;
literal HS$XAR$RFM$K_FIXED = 1;
literal HS$XAR$RFM$K_LSB_VARIABLE = 2;
literal HS$XAR$RFM$K_MSB_VARIABLE = 3;
literal HS$XAR$RFM$SYS$K_UNDEFINED = 128;
literal HS$XAR$RFM$SYS$K_FIXED = 129;
literal HS$XAR$RFM$SYS$K_VARIABLE = 130;
literal HS$XAR$RFM$SYS$K_VFC = 131;
literal HS$XAR$RFM$SYS$K_STREAM = 132;
literal HS$XAR$RFM$SYS$K_STREAMLF = 133;
literal HS$XAR$RFM$SYS$K_STREAMCR = 134;
literal HS$XAR$ATR$K_CRLF = 0;
literal HS$XAR$ATR$K_FTN = 1;
literal HS$XAR$ATR$K_STM = 2;
literal HS$XAR$S_XAR_RECORD = 512;      !  Old size name - synonym
literal HS$XAR$S_F11D_XAR_RECORD = 512;
macro HS$XAR$W_OWNER_ID = 0,0,16,0 %;   !  Owner Identification
macro HS$XAR$W_OWNER_ID_M = 2,0,16,0 %; !  Owner Identification
macro HS$XAR$W_GROUP_ID = 4,0,16,0 %;   !  Group Identification
macro HS$XAR$W_GROUP_ID_M = 6,0,16,0 %; !  Group Identification
macro HS$XAR$W_PERMISSIONS = 8,0,16,0 %; !  Access permission for classes of users
macro HS$XAR$V_SYS_NO_READ = 8,0,1,0 %; !  If set; ~(S:R)
macro HS$XAR$V_SYS_NO_EXECUTE = 8,2,1,0 %; !  If set; ~(S:E)
macro HS$XAR$V_OWN_NO_READ = 8,4,1,0 %; !  If set; ~(O:R)
macro HS$XAR$V_OWN_NO_EXECUTE = 8,6,1,0 %; !  If set; ~(O:E)
macro HS$XAR$V_GRP_NO_READ = 8,8,1,0 %; !  If set; ~(G:R)
macro HS$XAR$V_GRP_NO_EXECUTE = 8,10,1,0 %; !  If set; ~(G:E)
macro HS$XAR$V_WLD_NO_READ = 8,12,1,0 %; !  If set; ~(W:R)
macro HS$XAR$V_WLD_NO_EXECUTE = 8,14,1,0 %; !  If set; ~(W:E)
macro HS$XAR$B_FILE_CREATION = 10,0,0,1 %;
literal HS$XAR$S_FILE_CREATION = 16;    !  File Creation Date/Time
macro HS$XAR$B_FILE_MODIFICATION = 26,0,0,1 %;
literal HS$XAR$S_FILE_MODIFICATION = 16; !  File Modification Date/Time
macro HS$XAR$B_FILE_EXPIRATION = 42,0,0,1 %;
literal HS$XAR$S_FILE_EXPIRATION = 16;  !  File Expiration Date/Time
macro HS$XAR$B_FILE_EFFECTIVE = 58,0,0,1 %;
literal HS$XAR$S_FILE_EFFECTIVE = 16;   !  File Effective Date/Time
macro HS$XAR$B_RECORD_FORMAT = 74,0,8,0 %; !  Record Format
macro HS$XAR$B_RECORD_ATTRIBUTES = 75,0,8,0 %; !  Record Attributes
macro HS$XAR$W_RECORD_LENGTH = 76,0,16,0 %; !  Record Length
macro HS$XAR$W_RECORD_LENGTH_M = 78,0,16,0 %; !  Record Length
macro HS$XAR$T_SYSTEM_ID = 80,0,0,0 %;
literal HS$XAR$S_SYSTEM_ID = 32;        !  System Identifier 
macro HS$XAR$B_SYSTEM_USE = 112,0,0,1 %;
literal HS$XAR$S_SYSTEM_USE = 64;       !  System Used
macro HS$XAR$B_XAR_VERSION = 176,0,8,0 %; !  Extended Attribute Version
macro HS$XAR$W_PARENT_DIRECTORY = 241,0,16,0 %; !  Parent Directory Number
macro HS$XAR$W_PARENT_DIRECTORY_M = 243,0,16,0 %; !  Parent Directory Number
macro HS$XAR$W_APPLICATION_LENGTH = 245,0,16,0 %; !  Application Use Length
macro HS$XAR$W_APPLICATION_LENGTH_M = 247,0,16,0 %; !  Application Use Length
macro HS$XAR$B_ROOT_DIRECTORY = 249,0,0,1 %;
literal HS$XAR$S_ROOT_DIRECTORY = 34;   !  Root Directory Record
macro HS$XAR$B_APPLICATION_USE = 283,0,0,1 %;
literal HS$XAR$S_APPLICATION_USE = 229; !  Application Use
! +
!  Volume Descriptor
! 
!   The Volume Descriptor shall Identify the volume, the partitions recorded
!   on the volume, the volume creator(s),  certain attributes of the volume,
!   the location of other recorded descriptors and the version of the
!   standard which applies to the volume descriptor.
! 
! -
literal HS$VD$K_BOOT = 0;               ! 	Boot Record Descriptor
literal HS$VD$K_PVD = 1;                ! 	Primary Volume Descriptor
literal HS$VD$K_SVD = 2;                ! 	Supplementary Volume Descriptor
literal HS$VD$K_VPD = 3;                ! 	Volume Partition Descriptor
! 						(Values 4 to 254 are reserved)
literal HS$VD$K_VDST = 255;             ! 	Volume Descriptor Set Terminator
literal HS$VD$S_VD = 2048;              !  Old size name - synonym
literal HS$VD$S_F11D_VD = 2048;
macro HS$VD$L_DESCRIPTOR_LBN = 0,0,32,0 %; !  LBN of first logical block
macro HS$VD$L_DESCRIPTOR_LBN_M = 4,0,32,0 %; !  LBN of first logical block
macro HS$VD$B_VOLUME_DESCRIPTOR_TYPE = 8,0,8,0 %; !  Volume Descriptor Type
macro HS$VD$T_STANDARD_IDENTIFIER = 9,0,0,0 %;
literal HS$VD$S_STANDARD_IDENTIFIER = 5; !  International Standard Id. (CDROM)
macro HS$VD$B_VOLUME_DESCRIPTOR_VERS = 14,0,8,0 %; !  Volume Descriptor Version
macro HS$VD$B_VOLUME_DATA = 15,0,0,1 %;
literal HS$VD$S_VOLUME_DATA = 2033;     !  Volume Descriptor Data
! +
!  Boot Record
!  
!   The Boot Record shall Identify a system which can recognize and act upon
!   the content of the field reserved for boot system use in the Boot
!   Record, and shall contain information which is used to achieve a
!   specific state for a system or for an application.
!  
! -
literal HS$BOOT$S_BOOT = 2048;          !  Old size name - synonym
literal HS$BOOT$S_F11D_BOOT = 2048;
macro HS$BOOT$B_BOOT_VOLUME = 0,0,0,1 %;
literal HS$BOOT$S_BOOT_VOLUME = 15;     !  Boot Volume Descriptor
macro HS$BOOT$T_SYSTEM_IDENTIFIER = 15,0,0,0 %;
literal HS$BOOT$S_SYSTEM_IDENTIFIER = 32; !  Boot System Identifier
macro HS$BOOT$T_IDENTIFIER = 47,0,0,0 %;
literal HS$BOOT$S_IDENTIFIER = 32;      !  Boot Identifier
macro HS$BOOT$B_SYSTEM_USE = 79,0,0,1 %;
literal HS$BOOT$S_SYSTEM_USE = 1969;    !  Boot System Use
! +
!  Volume Descriptor Sequence Terminator
! 
!   The recorded set of Volume Descriptors shall be terminated by a sequence
!   of one or more Volume Descriptor Set Terminators
! 
! -
literal HS$VDST$S_VDST = 2048;          !  Old size name - synonym
literal HS$VDST$S_F11D_VDST = 2048;
macro HS$VDST$B_TERMINATOR_VOLUME = 0,0,0,1 %;
literal HS$VDST$S_TERMINATOR_VOLUME = 15; !  Volume Descriptor Set
! +
!  Standard File Structure Volume Descriptor
! 
!   The Standard File Structure Volume Descriptor shall Identify the volume, a system which
!   can recognize and act upon the content of the Logical Sectors with
!   Logical Sector Number 0 to 15, the size of the Volume Space, the version
!   of the  standard which applies to the Volume Descriptor, the version of
!   the specification which applies to the Directory Records and the Path
!   Table Records and certain attributes of the volume.
! 
! -
literal HS$PVD$S_PVD = 2048;            !  Old size name - synonym
literal HS$PVD$S_F11D_PVD = 2048;
macro HS$PVD$B_PRIMARY_VOLUME = 0,0,0,1 %;
literal HS$PVD$S_PRIMARY_VOLUME = 15;   !  Standard File Structure Volume Descriptor
macro HS$PVD$T_SYSTEM_IDENTIFIER = 16,0,0,0 %;
literal HS$PVD$S_SYSTEM_IDENTIFIER = 32; !  System Identifier
macro HS$PVD$T_VOLUME_IDENTIFIER = 48,0,0,0 %;
literal HS$PVD$S_VOLUME_IDENTIFIER = 32; !  Volume Identifier
macro HS$PVD$L_VOLUME_SPACE_SIZE = 88,0,32,0 %; !  Volume Space Size
macro HS$PVD$L_VOLUME_SPACE_SIZE_M = 92,0,32,0 %; !  Volume Space Size
macro HS$PVD$W_VOLUME_SET_SIZE = 128,0,16,0 %; !  Volume Set Size
macro HS$PVD$W_VOLUME_SET_SIZE_M = 130,0,16,0 %; !  Volume Set Size
macro HS$PVD$W_VOLUME_NUMBER = 132,0,16,0 %; !  Volume Sequence Number
macro HS$PVD$W_VOLUME_NUMBER_M = 134,0,16,0 %; !  Volume Sequence Number
macro HS$PVD$W_LOGICAL_BLOCK_SIZE = 136,0,16,0 %; !  Logical Block Size
macro HS$PVD$W_LOGICAL_BLOCK_SIZE_M = 138,0,16,0 %; !  Logical Block Size
macro HS$PVD$L_PATH_TABLE_SIZE = 140,0,32,0 %; !  Path Table Size
macro HS$PVD$L_PATH_TABLE_SIZE_M = 144,0,32,0 %; !  Path Table Size
macro HS$PVD$L_PATH_TABLE = 148,0,32,0 %; !  Path Table Logical Block #
macro HS$PVD$L_OPT_PATH_TABLE = 152,0,32,0 %; !  Optional Path Table Logical Block #
macro HS$PVD$L_OPT_PATH_TABLE_1 = 156,0,32,0 %; !  Optional Path Table Logical Block #
macro HS$PVD$L_OPT_PATH_TABLE_2 = 160,0,32,0 %; !  Optional Path Table Logical Block #
macro HS$PVD$L_PATH_TABLE_M = 164,0,32,0 %; !  Path Table Logical Block #
macro HS$PVD$L_OPT_PATH_TABLE_M = 168,0,32,0 %; !  Optional Path Table Logical Block #
macro HS$PVD$L_OPT_PATH_TABLE_M1 = 172,0,32,0 %; !  Optional Path Table Logical Block #
macro HS$PVD$L_OPT_PATH_TABLE_M2 = 176,0,32,0 %; !  Optional Path Table Logical Block #
macro HS$PVD$B_ROOT_DIRECTORY = 180,0,0,1 %;
literal HS$PVD$S_ROOT_DIRECTORY = 34;   !  Root Directory Record
macro HS$PVD$T_VOLUME_SET_IDENTIFIER = 214,0,0,0 %;
literal HS$PVD$S_VOLUME_SET_IDENTIFIER = 128; !  Volume Set Identifier
macro HS$PVD$B_PUBLISHER_ID = 342,0,0,1 %;
literal HS$PVD$S_PUBLISHER_ID = 128;    !  Publisher Identifier
macro HS$PVD$B_DATA_PREPARER_ID = 470,0,0,1 %;
literal HS$PVD$S_DATA_PREPARER_ID = 128; !  Data Preparer Identifier
macro HS$PVD$B_APPLICATION_ID = 598,0,0,1 %;
literal HS$PVD$S_APPLICATION_ID = 128;  !  Application Identifier
macro HS$PVD$B_COPYRIGHT_FILE_ID = 726,0,0,1 %;
literal HS$PVD$S_COPYRIGHT_FILE_ID = 32; !  Copyright File Identifier
macro HS$PVD$B_ABSTRACT_FILE_ID = 758,0,0,1 %;
literal HS$PVD$S_ABSTRACT_FILE_ID = 32; !  Abstract File Identifier
macro HS$PVD$B_VOLUME_CREATION = 790,0,0,1 %;
literal HS$PVD$S_VOLUME_CREATION = 16;  !  Volume Creation Date/Time
macro HS$PVD$B_VOLUME_MODIFIY = 806,0,0,1 %;
literal HS$PVD$S_VOLUME_MODIFIY = 16;   !  Volume Modification Date/Time
macro HS$PVD$B_VOLUME_EXPIRATION = 822,0,0,1 %;
literal HS$PVD$S_VOLUME_EXPIRATION = 16; !  Volume Expiration Date/Time
macro HS$PVD$B_VOLUME_EFFECTIVE = 838,0,0,1 %;
literal HS$PVD$S_VOLUME_EFFECTIVE = 16; !  Volume Effective Date/Time
macro HS$PVD$B_FILE_STRUCTURE_VERS = 854,0,8,0 %; !  File Structure Version
macro HS$PVD$B_APPLICATION_USE = 856,0,0,1 %;
literal HS$PVD$S_APPLICATION_USE = 512; !  Application Use field
! +
!  Coded Character Set File Structure Volume Descriptor
! 
!  The Coded Character Set File Structure Volume Descriptor Supplementary shall
!  Identify the volume, a system which can recognize and act upon the content of
!  the Logical Sectors with Logical Sector Number 0 to 15, the size of the
!  Volume Space, the version of the  standard which applies to the Volume
!  Descriptor, the version of the specification which applies to the Directory
!  Records and the Path Table Records, certain attributes of the volume and the
!  coded graphic character sets used to interpret descriptor fields that contain
!  characters.
! 
! -
literal HS$SVD$M_NON_ISO_2375 = %X'1';
literal HS$SVD$S_SVD = 2048;            !  Old size name - synonym
literal HS$SVD$S_F11D_SVD = 2048;
macro HS$SVD$B_SUPPLEMENTARY_VOLUME = 0,0,0,1 %;
literal HS$SVD$S_SUPPLEMENTARY_VOLUME = 15; !  Coded Character Set File Structure Volume Descriptor
macro HS$SVD$B_VOLUME_FLAGS = 15,0,8,0 %; !  Volume characteristics
macro HS$SVD$V_NON_ISO_2375 = 15,0,1,0 %; !  If set; Escape Sequence is non ISO-2375 compliant
macro HS$SVD$T_SYSTEM_IDENTIFIER = 16,0,0,0 %;
literal HS$SVD$S_SYSTEM_IDENTIFIER = 32; !  System Identifier
macro HS$SVD$T_VOLUME_IDENTIFIER = 48,0,0,0 %;
literal HS$SVD$S_VOLUME_IDENTIFIER = 32; !  Volume Identifier
macro HS$SVD$L_VOLUME_SPACE_SIZE = 88,0,32,0 %; !  Volume Space Size
macro HS$SVD$L_VOLUME_SPACE_SIZE_M = 92,0,32,0 %; !  Volume Space Size
macro HS$SVD$B_ESCAPE_SEQUENCES = 96,0,0,1 %;
literal HS$SVD$S_ESCAPE_SEQUENCES = 32; !  Coded Character Set for Descriptor Id
macro HS$SVD$W_VOLUME_SET_SIZE = 128,0,16,0 %; !  Volume Set Size
macro HS$SVD$W_VOLUME_SET_SIZE_M = 130,0,16,0 %; !  Volume Set Size
macro HS$SVD$W_VOLUME_NUMBER = 132,0,16,0 %; !  Volume Sequence Number
macro HS$SVD$W_VOLUME_NUMBER_M = 134,0,16,0 %; !  Volume Sequence Number
macro HS$SVD$W_LOGICAL_BLOCK_SIZE = 136,0,16,0 %; !  Logical Block Size
macro HS$SVD$W_LOGICAL_BLOCK_SIZE_M = 138,0,16,0 %; !  Logical Block Size
macro HS$SVD$L_PATH_TABLE_SIZE = 140,0,32,0 %; !  Path Table Size
macro HS$SVD$L_PATH_TABLE_SIZE_M = 144,0,32,0 %; !  Path Table Size
macro HS$SVD$L_PATH_TABLE = 148,0,32,0 %; !  Path Table Logical Block #
macro HS$SVD$L_OPT_PATH_TABLE = 152,0,32,0 %; !  Optional Path Table Logical Block #
macro HS$SVD$L_OPT_PATH_TABLE_1 = 156,0,32,0 %; !  Optional Path Table Logical Block #
macro HS$SVD$L_OPT_PATH_TABLE_2 = 160,0,32,0 %; !  Optional Path Table Logical Block #
macro HS$SVD$L_PATH_TABLE_M = 164,0,32,0 %; !  Path Table Logical Block #
macro HS$SVD$L_OPT_PATH_TABLE_M = 168,0,32,0 %; !  Optional Path Table Logical Block #
macro HS$SVD$L_OPT_PATH_TABLE_M1 = 172,0,32,0 %; !  Optional Path Table Logical Block #
macro HS$SVD$L_OPT_PATH_TABLE_M2 = 176,0,32,0 %; !  Optional Path Table Logical Block #
macro HS$SVD$B_ROOT_DIRECTORY = 180,0,0,1 %;
literal HS$SVD$S_ROOT_DIRECTORY = 34;   !  Root Directory Record
macro HS$SVD$T_VOLUME_SET_IDENTIFIER = 214,0,0,0 %;
literal HS$SVD$S_VOLUME_SET_IDENTIFIER = 128; !  Volume Set Identifier
macro HS$SVD$B_PUBLISHER_ID = 342,0,0,1 %;
literal HS$SVD$S_PUBLISHER_ID = 128;    !  Publisher Identifier
macro HS$SVD$B_DATA_PREPARER_ID = 470,0,0,1 %;
literal HS$SVD$S_DATA_PREPARER_ID = 128; !  Data Preparer Identifier
macro HS$SVD$B_APPLICATION_ID = 598,0,0,1 %;
literal HS$SVD$S_APPLICATION_ID = 128;  !  Application Identifier
macro HS$SVD$B_COPYRIGHT_FILE_ID = 726,0,0,1 %;
literal HS$SVD$S_COPYRIGHT_FILE_ID = 32; !  Copyright File Identifier
macro HS$SVD$B_ABSTRACT_FILE_ID = 758,0,0,1 %;
literal HS$SVD$S_ABSTRACT_FILE_ID = 32; !  Abstract File Identifier
macro HS$SVD$B_VOLUME_CREATION = 790,0,0,1 %;
literal HS$SVD$S_VOLUME_CREATION = 16;  !  Volume Creation Date/Time
macro HS$SVD$B_VOLUME_MODIFIY = 806,0,0,1 %;
literal HS$SVD$S_VOLUME_MODIFIY = 16;   !  Volume Modification Date/Time
macro HS$SVD$B_VOLUME_EXPIRATION = 822,0,0,1 %;
literal HS$SVD$S_VOLUME_EXPIRATION = 16; !  Volume Expiration Date/Time
macro HS$SVD$B_VOLUME_EFFECTIVE = 838,0,0,1 %;
literal HS$SVD$S_VOLUME_EFFECTIVE = 16; !  Volume Effective Date/Time
macro HS$SVD$B_FILE_STRUCTURE_VERS = 854,0,8,0 %; !  File Structure Version
macro HS$SVD$B_APPLICATION_USE = 856,0,0,1 %;
literal HS$SVD$S_APPLICATION_USE = 512; !  Application Use field
! +
!  Unspecified Partition Descriptor
! 
!   The Unspecified Volume Partition Descriptor shall identify a volume partition with
!   the Volume Space, a system which can recognize and act upon the content
!   of fields reserved for system use in the Volume Descriptor, the position
!   and size of the volume partition, the version of the standard which
!   applies to the Volume Descriptor.
! 
! -
literal HS$VPD$S_VPD = 2048;            !  Old size name - synonym
literal HS$VPD$S_F11D_VPD = 2048;
macro HS$VPD$B_VOLUME_PARTITION = 0,0,0,1 %;
literal HS$VPD$S_VOLUME_PARTITION = 15; !  Unspecified Volume Partition Descriptor
macro HS$VPD$T_SYSTEM_IDENTIFIER = 16,0,0,0 %;
literal HS$VPD$S_SYSTEM_IDENTIFIER = 32; !  System Identifier
macro HS$VPD$T_PARTITION_IDENTIFIER = 48,0,0,0 %;
literal HS$VPD$S_PARTITION_IDENTIFIER = 32; !  Volume Partition Identifier
macro HS$VPD$L_PARTITION_LOCATION = 80,0,32,0 %; !  Location of Partition (LBN)
macro HS$VPD$L_PARTITION_LOCATION_M = 84,0,32,0 %; !  Location of Partition (LBN)
macro HS$VPD$L_PARTITION_SIZE = 88,0,32,0 %; !  Volume Partition Size
macro HS$VPD$L_PARTITION_SIZE_M = 92,0,32,0 %; !  Volume Partition Size
macro HS$VPD$B_SYSTEM_USE = 96,0,0,1 %;
literal HS$VPD$S_SYSTEM_USE = 1952;     !  System Use
! ********************************************************************************************************************************
!  Created:  4-MAY-1995 17:57:13 by OpenVMS SDL EV1-36     
!  Source:  16-JAN-1995 18:10:15 $64$DUA3210:[LIB.SRC]NMADEF.SDL;1 
! ********************************************************************************************************************************
 
!*** MODULE $NMADEF ***
! 
!  Object type
! 
literal NMA$C_OBJ_NIC = 19;             !  Nice listener 
! 
!  Function codes
! 
literal NMA$C_FNC_LOA = 15;             !  Request down-line load 
literal NMA$C_FNC_DUM = 16;             !  Request up-line dump 
literal NMA$C_FNC_TRI = 17;             !  Trigger bootstrap 
literal NMA$C_FNC_TES = 18;             !  Test 
literal NMA$C_FNC_CHA = 19;             !  Change parameter 
literal NMA$C_FNC_REA = 20;             !  Read information 
literal NMA$C_FNC_ZER = 21;             !  Zero counters 
literal NMA$C_FNC_SYS = 22;             !  System-specific function 
! 
!  Option byte
! 
!     common to change parameter, read information and zero counters
! 
literal NMA$M_OPT_ENT = %X'7';
literal NMA$M_OPT_CLE = %X'40';
literal NMA$M_OPT_PER = %X'80';
literal NMA$M_OPT_INF = %X'70';
literal NMA$C_OPINF_SUM = 0;            !  Summary 
literal NMA$C_OPINF_STA = 1;            !  Status 
literal NMA$C_OPINF_CHA = 2;            !  Characteristics 
literal NMA$C_OPINF_COU = 3;            !  Counters 
literal NMA$C_OPINF_EVE = 4;            !  Events 
! 
literal NMA$M_OPT_ACC = %X'80';
literal NMA$M_OPT_REA = %X'80';
literal NMA$C_SYS_RST = 1;              !  Rsts 
literal NMA$C_SYS_RSX = 2;              !  Rsx family 
literal NMA$C_SYS_TOP = 3;              !  Tops-20 
literal NMA$C_SYS_VMS = 4;              !  Vms 
literal NMA$C_SYS_RT = 5;               !  RT-11 
! 
literal NMA$C_ENT_NOD = 0;              !  Node 
literal NMA$C_ENT_LIN = 1;              !  Line 
literal NMA$C_ENT_LOG = 2;              !  Logging 
literal NMA$C_ENT_CIR = 3;              !  Circuit 
literal NMA$C_ENT_MOD = 4;              !  Module 
literal NMA$C_ENT_ARE = 5;              !  Area 
! 
literal NMA$C_SENT_PROXY = 2;           !  Proxies
literal NMA$C_SENT_ALI = 3;             !  Alias 
literal NMA$C_SENT_OBJ = 4;             !  Object 
literal NMA$C_SENT_PRO = 5;             !  Process 
literal NMA$C_SENT_SYS = 6;             !  System 
literal NMA$C_SENT_LNK = 7;             !  Links 
literal NMA$C_SENT_WLD = -30;           !  Wildcarded entity
literal NMA$M_ENT_EXE = %X'80';
literal NMA$C_ENT_WAR = -7;             !  Wildcarded area
literal NMA$C_ENT_WAD = -6;             !  Wildcarded address
literal NMA$C_ENT_ADJ = -4;             !  Adjacent 
literal NMA$C_ENT_ACT = -2;             !  Active 
literal NMA$C_ENT_KNO = -1;             !  Known 
literal NMA$C_ENT_ADD = 0;              !  Node address 
literal NMA$C_ENT_ALL = -3;             !  All 
literal NMA$C_ENT_LOO = -3;             !  Loop 
! 
literal NMA$C_SNK_CON = 1;              !  Console 
literal NMA$C_SNK_FIL = 2;              !  File 
literal NMA$C_SNK_MON = 3;              !  Monitor 
! 
literal NMA$M_CNT_TYP = %X'FFF';
literal NMA$M_CNT_MAP = %X'1000';
literal NMA$M_CNT_WID = %X'6000';
literal NMA$M_CNT_COU = %X'8000';
literal NMA$M_CNT_WIL = %X'2000';
literal NMA$M_CNT_WIH = %X'4000';
literal NMA$S_NMADEF = 2;               !  Old size name - synonym
literal NMA$S_NMA = 2;
macro NMA$V_OPT_ENT = 0,0,3,0 %;
literal NMA$S_OPT_ENT = 3;              !  Entity type 
! 
!     change parameter
! 
macro NMA$V_OPT_CLE = 0,6,1,0 %;        !  Clear parameter 
! 
!     common to change parameter or read information
! 
macro NMA$V_OPT_PER = 0,7,1,0 %;        !  Permanent parameters 
! 
!     read information
! 
macro NMA$V_OPT_INF = 0,4,3,0 %;
literal NMA$S_OPT_INF = 3;              !  Information type mask 
!     test
! 
macro NMA$V_OPT_ACC = 0,7,1,0 %;        !  Access control included 
! 
!     zero
! 
macro NMA$V_OPT_REA = 0,7,1,0 %;        !  Read and zero 
! 
!  System types
! 
!  Entity types.  This numbering scheme must be used in non-system-specific
!  NICE messages.  (See below for conflicting system-specific entities).
! 
!  System-specific (function 22) entity types.  This numbering scheme
!  for objects must be used in any entity type in system-specific NICE
!  messages.
! 
macro NMA$V_ENT_EXE = 0,7,1,0 %;        !  Executor indicator flag for response messages 
! 
!  Entity identification format types
! 
!  Logging sink types
! 
!  Counter data type values
! 
macro NMA$V_CNT_TYP = 0,0,12,0 %;
literal NMA$S_CNT_TYP = 12;             !  Type mask 
macro NMA$V_CNT_MAP = 0,12,1,0 %;       !  Bitmapped indicator 
macro NMA$V_CNT_WID = 0,13,2,0 %;
literal NMA$S_CNT_WID = 2;              !  Width field mask 
macro NMA$V_CNT_COU = 0,15,1,0 %;       !  Counter indicator 
macro NMA$V_CNT_WIL = 0,13,1,0 %;       !  Width field low bit 
macro NMA$V_CNT_WIH = 0,14,1,0 %;       !  Width field high bit 
! 
!  Node area and address extraction
! 
literal NMA$M_PTY_TYP = %X'7FFF';
literal NMA$C_PTY_MAX = 15;             !  Maximum fields within coded multiple 
literal NMA$M_PTY_CLE = %X'3F';
literal NMA$M_PTY_MUL = %X'40';
literal NMA$M_PTY_COD = %X'80';
literal NMA$M_PTY_CMU = %X'C0';
literal NMA$M_PTY_NLE = %X'F';
literal NMA$M_PTY_NTY = %X'30';
literal NMA$M_PTY_ASC = %X'40';
literal NMA$C_NTY_DU = 0;               !  Unsigned decimal 
literal NMA$C_NTY_DS = 1;               !  Signed decimal 
literal NMA$C_NTY_H = 2;                !  Hexidecimal 
literal NMA$C_NTY_O = 3;                !  Octal 
!  NLE values (length of number): 
literal NMA$C_NLE_IMAGE = 0;            !  Image field (byte-counted) 
literal NMA$C_NLE_BYTE = 1;             !  Byte 
literal NMA$C_NLE_WORD = 2;             !  Word 
literal NMA$C_NLE_LONG = 4;             !  Longword 
literal NMA$C_NLE_QUAD = 8;             !  Quadword 
! 
literal NMA$C_PTY_AI = 64;              !  ASCII image (ASC=1) 
literal NMA$C_PTY_HI = 32;              !  Hex image (NTY=H, NLE=IMAGE) 
literal NMA$C_PTY_H1 = 33;              !  Hex byte (NTY=H, NLE=BYTE) 
literal NMA$C_PTY_H2 = 34;              !  Hex word (NTY=H, NLE=WORD) 
literal NMA$C_PTY_H4 = 36;              !  Hex byte (NTY=H, NLE=LONG)
literal NMA$C_PTY_DU1 = 1;              !  Decimal unsigned byte (NTY=DU,NLE=BYTE) 
literal NMA$C_PTY_DU2 = 2;              !  Decimal unsigned word (NTY=DU,NLE=WORD) 
literal NMA$C_PTY_CD1 = 129;            !  Coded decimal byte (COD=1, 1 byte) 
literal NMA$C_PTY_CM2 = 194;            !  Coded multiple, 2 fields 
literal NMA$C_PTY_CM3 = 195;            !  Coded multiple, 3 fields 
literal NMA$C_PTY_CM4 = 196;            !  Coded multiple, 4 fields 
literal NMA$C_PTY_CM5 = 197;            !  Coded multiple, 5 fields 
! 
literal NMA$C_CTLVL_UI = 3;             !  User interface
literal NMA$C_CTLVL_XID = 175;          ! 
literal NMA$C_CTLVL_XID_P = 191;        ! 
literal NMA$C_CTLVL_TEST = 227;         ! 
literal NMA$C_CTLVL_TEST_P = 243;       ! 
! 
literal NMA$C_PCCI_STA = 0;             !  State (coded byte of NMA$C_STATE_) 
literal NMA$C_PCCI_SUB = 1;             !  Substate (coded byte of NMA$C_LINSS_) 
literal NMA$C_PCCI_SER = 100;           !  Service (coded byte of NMA$C_LINSV_) 
literal NMA$C_PCCI_LCT = 110;           !  Counter timer (word) 
literal NMA$C_PCCI_SPY = 120;           !  Service physical address (NI address) 
literal NMA$C_PCCI_SSB = 121;           !  Service substate (coded byte of NMA$C_LINSS_) 
literal NMA$C_PCCI_CNO = 200;           !  Connected node 
literal NMA$C_PCCI_COB = 201;           !  Connected object 
literal NMA$C_PCCI_LOO = 400;           !  Loopback name (ascic) 
literal NMA$C_PCCI_ADJ = 800;           !  Adjacent node 
literal NMA$C_PCCI_DRT = 801;           !  Designated router on NI 
literal NMA$C_PCCI_BLO = 810;           !  Block size (word) 
literal NMA$C_PCCI_COS = 900;           !  Cost (byte) 
literal NMA$C_PCCI_MRT = 901;           !  Maximum routers on NI (byte) 
literal NMA$C_PCCI_RPR = 902;           !  Router priority on NI (byte) 
literal NMA$C_PCCI_HET = 906;           !  Hello timer (word) 
literal NMA$C_PCCI_LIT = 907;           !  Listen timer (word) 
literal NMA$C_PCCI_BLK = 910;           !  Blocking (coded byte of NMA$C_CIRBLK_) 
literal NMA$C_PCCI_MRC = 920;           !  Maximum recalls (byte) 
literal NMA$C_PCCI_RCT = 921;           !  Recall timer (word) 
literal NMA$C_PCCI_NUM = 930;           !  Number (ascic) 
literal NMA$C_PCCI_USR = 1000;          !  User entity identification 
literal NMA$C_PCCI_POL = 1010;          !  Polling state (coded byte of NMA$C_CIRPST_) 
literal NMA$C_PCCI_PLS = 1011;          !  Polling substate (coded byte) 
literal NMA$C_PCCI_OWN = 1100;          !  Owner entity identification 
literal NMA$C_PCCI_LIN = 1110;          !  Line (ascic) 
literal NMA$C_PCCI_USE = 1111;          !  Usage (coded byte of NMA$C_CIRUS_) 
literal NMA$C_PCCI_TYP = 1112;          !  Type (coded byte of NMA$C_CIRTY_) 
literal nma$c_pcci_net = 1119;          !  Network (ascic)
literal NMA$C_PCCI_DTE = 1120;          !  DTE (ascic) 
literal NMA$C_PCCI_CHN = 1121;          !  Channel (word) 
literal NMA$C_PCCI_MBL = 1122;          !  Maximum data (word) 
literal NMA$C_PCCI_MWI = 1123;          !  Maximum window (byte) 
literal NMA$C_PCCI_TRI = 1140;          !  Tributary (byte) 
literal NMA$C_PCCI_BBT = 1141;          !  Babble timer (word) 
literal NMA$C_PCCI_TRT = 1142;          !  Transmit timer (word) 
literal NMA$C_PCCI_RTT = 1143;          !  Retransmit timer (word) 
literal NMA$C_PCCI_MRB = 1145;          !  Maximum receive buffers (coded byte) 
!  0-254 is value, 255 = UNLIMITED
literal NMA$C_PCCI_MTR = 1146;          !  Maximum transmits (byte) 
literal NMA$C_PCCI_ACB = 1150;          !  Active base (byte) 
literal NMA$C_PCCI_ACI = 1151;          !  Active increment (byte) 
literal NMA$C_PCCI_IAB = 1152;          !  Inactive base (byte) 
literal NMA$C_PCCI_IAI = 1153;          !  Inactive increment (byte) 
literal NMA$C_PCCI_IAT = 1154;          !  Inactive threshold (byte) 
literal NMA$C_PCCI_DYB = 1155;          !  Dying base (byte) 
literal NMA$C_PCCI_DYI = 1156;          !  Dying increment (byte) 
literal NMA$C_PCCI_DYT = 1157;          !  Dying threshold (byte) 
literal NMA$C_PCCI_DTH = 1158;          !  Dead threshold (byte) 
! 
literal NMA$C_PCCI_RSX_MAC = 2320;      !  Multipoint active ratio 
literal NMA$C_PCCI_RSX_LOG = 2380;      !  Logical name 
literal NMA$C_PCCI_RSX_DLG = 2385;      !  Designated name 
literal NMA$C_PCCI_RSX_ACT = 2390;      !  Actual name 
! 
literal NMA$C_PCCI_VER = 2700;          !  Verification (coded byte of NMA$C_CIRVE_) 
literal NMA$C_PCCI_XPT = 2720;          !  Transport type (coded byte of NMA$C_CIRXPT_) 
!   VMS Specific codes that are used for the X21 project
literal NMA$C_PCCI_IRC = 2750;          ! Incoming Reverse
literal NMA$C_PCCI_ORC = 2751;          ! Outgoing Reverse
literal NMA$C_PCCI_GRP = 2752;          ! Cug
literal NMA$C_PCCI_NOP = 2753;          ! National Facility Data
literal NMA$C_PCCI_CAL = 2754;          ! Call request "Now/Clear"
literal NMA$C_PCCI_INA = 2755;          ! Inactive
literal NMA$C_PCCI_RED = 2756;          ! Redirected status
literal NMA$C_PCCI_MOD = 2757;          ! Time-cut Mode status "Auto/Noauto"
literal NMA$C_PCCI_REQ = 2758;          ! Request timer T1
literal NMA$C_PCCI_DTW = 2759;          ! Dte waiting timer t2
literal NMA$C_PCCI_PRO = 2760;          ! Progress timer t3a
literal NMA$C_PCCI_INF = 2761;          ! Information timer t4a
literal NMA$C_PCCI_ACC = 2762;          ! Accepted timer t4b
literal NMA$C_PCCI_CLR = 2763;          ! Request timer t5
literal NMA$C_PCCI_DTC = 2764;          ! Dte clear timer t6
literal NMA$C_PCCI_CCG = 2765;          ! Charging timer t7
literal NMA$C_PCCI_ESA = 2766;          ! Enhanced Subaddress
literal NMA$C_PCCI_DTI = 2767;          ! DTE provided info
literal NMA$C_PCCI_SWC = 2768;          ! Switched - set line leased
literal NMA$C_PCCI_TIC = 2769;          ! Timecutting on/off
literal NMA$C_PCCI_CSG = 2770;          ! Send signal-data enable/disable
literal NMA$C_PCCI_AAS = 2771;          ! Abbreviated address.
literal NMA$C_PCCI_DTS = 2772;          ! DTE Status
literal NMA$C_PCCI_CAS = 2773;          ! Call Status
literal NMA$C_PCCI_CPS = 2774;          ! Call-Progress Status
literal NMA$C_PCCI_CNT = 2775;          ! Counter .
literal NMA$C_PCCI_RAT = 2776;          ! Rate item read only for show
literal NMA$C_PCCI_PRD = 2777;          ! Period hh:mm-hh:mm
literal NMA$C_PCCI_DAY = 2778;          ! day of week
literal NMA$C_PCCI_BFN = 2779;          ! number of buffers for driver to issue
literal NMA$C_PCCI_BSZ = 2780;          ! size of buffer to allocate.
literal NMA$C_PCCI_MDM = 2781;          ! Modem signals on/off
literal NMA$C_PCCI_DTL = 2782;          ! DTE-List element.
literal NMA$C_PCCI_IDL = 2783;          ! Idle time
literal NMA$C_PCCI_IMT = 2784;          ! Initial Minimum timer
literal NMA$C_PCCI_CAC = 2785;          ! Call accept control
literal NMA$C_PCCI_ORD = 2786;          ! Outgoing request Delay
literal NMA$C_PCCI_CID = 2787;          ! Calling DTE id
! 
literal NMA$C_PCCI_MST = 2810;          !  Maintenance state 
! 
literal NMA$C_PCCI_SRV_LOG = 3380;      !  Logical name 
literal NMA$C_PCCI_SRV_DLG = 3385;      !  Designated name 
literal NMA$C_PCCI_SRV_ACT = 3390;      !  Actual name 
! 
literal NMA$C_PCLI_STA = 0;             !  State (coded byte of NMA$C_STATE_) 
literal NMA$C_PCLI_SUB = 1;             !  Substate (coded byte of NMA$C_LINSS_) 
literal NMA$C_PCLI_SER = 100;           !  Service (coded byte of NMA$C_LINSV_) 
literal NMA$C_PCLI_LCT = 110;           !  Counter timer (word) 
literal NMA$C_PCLI_LOO = 400;           !  Loopback name (ascic) [V2 only] 
literal NMA$C_PCLI_ADJ = 800;           !  Adjacent node [V2 only] 
literal NMA$C_PCLI_BLO = 810;           !  Block size (word) [V2 only] 
literal NMA$C_PCLI_COS = 900;           !  Cost (byte) [V2 only] 
literal NMA$C_PCLI_DEV = 1100;          !  Device (ascic) 
literal NMA$C_PCLI_BFN = 1105;          !  Receive buffers 
literal NMA$C_PCLI_CON = 1110;          !  Controller (coded byte of NMA$C_LINCN_) 
literal NMA$C_PCLI_DUP = 1111;          !  Duplex (coded byte of NMA$C_DPX_) 
literal NMA$C_PCLI_PRO = 1112;          !  Protocol (coded byte of NMA$C_LINPR_) 
literal NMA$C_PCLI_LTY = 1112;          !  Type (coded byte of NMA$C_LINTY_) [V2 only] 
literal NMA$C_PCLI_CLO = 1113;          !  Clock (coded byte of NMA$C_LINCL_) 
literal NMA$C_PCLI_STI = 1120;          !  Service timer (word) 
literal NMA$C_PCLI_NTI = 1121;          !  Normal timer (word) [V2 only] 
literal NMA$C_PCLI_RTT = 1121;          !  Retransmit timer (word) 
literal NMA$C_PCLI_HTI = 1122;          !  Holdback timer (word) 
literal NMA$C_PCLI_MBL = 1130;          !  Maximum block (word) 
literal NMA$C_PCLI_MRT = 1131;          !  Maximum retransmits (byte) 
literal NMA$C_PCLI_MWI = 1132;          !  Maximum window (byte) 
literal NMA$C_PCLI_TRI = 1140;          !  Tributary (byte) [V2 only] 
literal NMA$C_PCLI_SLT = 1150;          !  Scheduling timer (word) 
literal NMA$C_PCLI_DDT = 1151;          !  Dead timer (word) 
literal NMA$C_PCLI_DLT = 1152;          !  Delay timer (word) 
literal NMA$C_PCLI_SRT = 1153;          !  Stream timer (word) 
literal NMA$C_PCLI_HWA = 1160;          !  Hardware address (NI address) 
! 
literal NMA$C_PCLI_TREQ = 1161;         !  Requested TRT
literal NMA$C_PCLI_TVX = 1162;          !  Valid transmission time
literal NMA$C_PCLI_REST_TTO = 1163;     !  Restricted token timeout
literal NMA$C_PCLI_RPE = 1164;          !  Ring purger enable
literal NMA$C_PCLI_NIF_TARG = 1165;     !  NIF target
literal NMA$C_PCLI_SIF_CONF_TARG = 1166; !  SIF configuration target
literal NMA$C_PCLI_SIF_OP_TARG = 1167;  !  SIF operation target
literal NMA$C_PCLI_ECHO_TARG = 1168;    !  Echo target
literal NMA$C_PCLI_ECHO_DAT = 1169;     !  Echo data
! 
literal NMA$C_PCLI_STN_ADR = 1170;      !  Station address
literal NMA$C_PCLI_FNC_ADR = 1171;      !  Functional address
literal NMA$C_PCLI_GRP_ADR = 1172;      !  Group address
literal NMA$C_PCLI_UNA = 1173;          !  Upstream neighbor (in common with FDDI)
literal NMA$C_PCLI_RNG_NUM = 1174;      !  Ring number
literal NMA$C_PCLI_AUTH_PR = 1175;      !  Authorized access priority
literal NMA$C_PCLI_RNG_SPD = 1176;      !  Ring speed
literal NMA$C_PCLI_ETR = 1177;          !  Early token release
literal NMA$C_PCLI_SRC_ROU = 1178;      !  Source routing
literal NMA$C_PCLI_ADR_TYP = 1179;      !  Address type
literal NMA$C_PCLI_A_TIM = 1400;        !  Aging timer
! 
literal NMA$C_PCLI_ECHO_LEN = 1180;     !  Echo length
literal NMA$C_PCLI_LAST_NIF = 1181;     !  Last NIF
literal NMA$C_PCLI_LAST_SIF = 1182;     !  Last SIF
literal NMA$C_PCLI_LAST_ECHO = 1183;    !  Last echo
literal NMA$C_PCLI_T_NEG = 1184;        !  Negotiated TRT
literal NMA$C_PCLI_DAT = 1185;          !  Duplicate address flag
literal NMA$C_PCLI_OLD_UNA = 1187;      !  Old upstream neighbor
literal NMA$C_PCLI_UN_DAT = 1188;       !  Upstream neighbor DA flag
literal NMA$C_PCLI_DNA = 1189;          !  Downstream neighbor
literal NMA$C_PCLI_OLD_DNA = 1192;      !  Old downstream neighbor
literal NMA$C_PCLI_RPS = 1193;          !  Ring purger state
literal NMA$C_PCLI_RER = 1194;          !  Ring error reason
literal NMA$C_PCLI_FDE = 1198;          !  Full duplex enable
literal NMA$C_PCLI_NBR_PHY = 1300;      !  Neighbor PHY type
literal NMA$C_PCLI_LEE = 1301;          !  Link error estimate
literal NMA$C_PCLI_RJR = 1302;          !  Reject reason
literal nma$c_pcli_net = 1190;          !  Network name (ascic)
literal NMA$C_PCLI_XMD = 1191;          !  X.25 line mode (coded byte of NMA$C_X25MD_) 
! 
literal NMA$C_PCLI_RSX_OWN = 2300;      !  Owner 
literal NMA$C_PCLI_RSX_CCS = 2310;      !  Controller CSR 
literal NMA$C_PCLI_RSX_UCS = 2311;      !  Unit CSR 
literal NMA$C_PCLI_RSX_VEC = 2312;      !  Vector 
literal NMA$C_PCLI_RSX_PRI = 2313;      !  Priority 
literal NMA$C_PCLI_RSX_MDE = 2321;      !  Dead polling ratio 
literal NMA$C_PCLI_RSX_LLO = 2330;      !  Location 
!   0, Firstfit
literal NMA$C_PCLI_RSX_LOG = 2380;      !  Logical name 
literal NMA$C_PCLI_RSX_DLG = 2385;      !  Designated name 
literal NMA$C_PCLI_RSX_ACT = 2390;      !  Actual name 
! 
literal NMA$C_PCLI_MCD = 2701;          !  Micro-code dump filespec (ascic) 
literal NMA$C_PCLI_EPT = 2720;          !  Ethernet Protocol Type (hex word) 
literal NMA$C_PCLI_LNS = 2730;          !  Line speed (word)
literal NMA$C_PCLI_SWI = 2740;          !  SWITCH (coded byte of nma$c_linswi_)
literal NMA$C_PCLI_HNG = 2750;          !  HANGUP (coded byte of NMA$C_LINHNG_)
literal NMA$C_PCLI_TPI = 2760;          !  Transmit pipeline 
literal nma$c_pcli_nrzi = 2761;         !  NRZI bit encoding
literal nma$c_pcli_code = 2762;         !  Character code (encoded as CODE_)
!    This section are parameters for 802 support.
literal NMA$C_PCLI_FMT = 2770;          !  Packet format(coded of linfm_)
literal NMA$C_PCLI_SRV = 2771;          !  Driver service coded of linsr
literal NMA$C_PCLI_SAP = 2772;          !  SAP
literal NMA$C_PCLI_GSP = 2773;          !  GSP
literal NMA$C_PCLI_PID = 2774;          !  PID
literal NMA$C_PCLI_CNM = 2775;          !  Client name
literal NMA$C_PCLI_CCA = 2776;          !  Can change address
literal NMA$C_PCLI_APC = 2777;          !  Allow promiscuous client
literal NMA$C_PCLI_MED = 2778;          !  Communication medium
literal NMA$C_PCLI_PNM = 2779;          !  Port name
literal NMA$C_PCLI_SNM = 2780;          !  Station name
!     This section for Token Ring-specific line parameters  
literal NMA$C_PCLI_MONCONTEND = 2781;   !  Monitor Contendor
literal NMA$C_PCLI_CACHE_ENT = 2782;    !  SR Cache Entr
literal NMA$C_PCLI_ROUTEDIS = 2783;     !  SR Discover Tmr
!     This includes generic parameters for LAN devices
literal NMA$C_PCLI_LINEMEDIA = 2784;    !  UTP, STP, AUI, TP, AUTO, UNSPECIFIED
literal NMA$C_PCLI_LINESPEED = 2785;    !  UTP, STP, AUI, TP
! 
literal NMA$C_PCLI_BUS = 2801;          !  Buffer size (word) 
literal NMA$C_PCLI_NMS = 2810;          !  Number of DMP/DMF synch chars (word) 
literal NMA$C_PCLI_PHA = 2820;          !  Physical NI address of UNA (hex string) 
literal NMA$C_PCLI_DPA = 2821;          !  (same as HWA) ; Default UNA physical address (hex string) 
literal NMA$C_PCLI_PTY = 2830;          !  Ethernet Protocol type (word) 
literal NMA$C_PCLI_MCA = 2831;          !  UNA Multicast address list (special) 
!         (See NMA$C_LINMC_)
literal NMA$C_PCLI_ILP = 2839;          !  DELUA Internal Loopback mode 
!  (coded byte of NMA$C_STATE_)
literal NMA$C_PCLI_PRM = 2840;          !  UNA Promiscuous mode (coded byte of NMA$C_STATE_) 
literal NMA$C_PCLI_MLT = 2841;          !  UNA Multicast address mode (coded byte of NMA$C_STATE_) 
literal NMA$C_PCLI_PAD = 2842;          !  UNA Padding mode (coded byte of NMA$C_STATE_) 
literal NMA$C_PCLI_DCH = 2843;          !  UNA Data chaining mode (coded byte of NMA$C_STATE_) 
literal NMA$C_PCLI_CRC = 2844;          !  UNA CRC mode (coded byte of NMA$C_STATE_) 
literal NMA$C_PCLI_HBQ = 2845;          !  UNA Hardware Buffer Quota (word) 
literal NMA$C_PCLI_ACC = 2846;          !  UNA protocol access mode (coded byte of NMA$C_ACC_) 
literal NMA$C_PCLI_EKO = 2847;          !  UNA Echo mode (coded byte of NMA$C_STATE_) 
literal NMA$C_PCLI_BSZ = 2848;          !  UNA Device Buffer size 
literal NMA$C_PCLI_DES = 2849;          !  UNA destination Ethernet address 
literal NMA$C_PCLI_RET = 2850;          !  PCL number of retries (word) 
literal NMA$C_PCLI_MOD = 2851;          !  PCL address mode (coded byte of NMA$C_LINMO_) 
literal NMA$C_PCLI_RIB = 2852;          !  PCL retry-if-busy state (coded byte of NMA$C_STATE_) 
literal NMA$C_PCLI_MNTL = 2860;         !  Maintenance loopback mode for devices 
!   which support several different loop back modes
literal NMA$C_PCLI_INTL0 = 2861;        !  Internal loopback level 0 
literal NMA$C_PCLI_INTL1 = 2862;        !  Internal loopback level 1 
literal NMA$C_PCLI_INTL2 = 2863;        !  Internal loopback level 2 
literal NMA$C_PCLI_INTL3 = 2864;        !  Internal loopback level 3 
literal NMA$C_PCLI_FRA = 2865;          !  Framing address for Bisync 
literal NMA$C_PCLI_STI1 = 2866;         !  State info 1st longword 
literal NMA$C_PCLI_STI2 = 2867;         !  State info 2st longword 
literal NMA$C_PCLI_TMO = 2868;          !  Wait for CTS time out value for DMF sync half duplex 
literal NMA$C_PCLI_MCL = 2869;          !  Clear modem on deassign of channel 
literal NMA$C_PCLI_SYC = 2870;          !  BISYNC protocol sync char 
literal NMA$C_PCLI_BPC = 2871;          !  Number of bits per character 
literal NMA$C_PCLI_MBS = 2872;          !  Maximum buffer size
literal NMA$C_PCLI_RES = 2873;          !  Restart value (coded byte of LINRES_)
literal NMA$C_PCLI_XFC = 2874;          !  Transmit FC (coded byte of NMA$C_STATE_)
literal NMA$C_PCLI_RFC = 2875;          !  Receive  FC (coded byte of NMA$C_STATE_)
!  IO$M_UPDATE_MAP I/O Subfunction parameters (Token Ring)
literal NMA$C_PCLI_MAP = 2876;          !  FCA Map Functions
literal NMA$C_MAP_ADD = 0;              !  Add Entry
literal NMA$C_MAP_CHANGE = 1;           !  Change Entry
literal NMA$C_MAP_DELETE = 2;           !  Delete Entry
literal NMA$C_PCLI_MRB = 2877;          !  Maximum Receive Buffers (for user)
literal NMA$C_PCLI_MINRCV = 2878;       !  Minimum Receive Buffers (for netman) 
literal NMA$C_PCLI_MAXRCV = 2879;       !  Maximum Receive Buffers (for netman)
!  IO$M_ROUTE I/O Subfunction parameters (Token Ring)
literal NMA$C_PCLI_ROUTE = 2880;        !  SR Functions
literal NMA$C_SR_ADD = 0;               !  Add route
literal NMA$C_SR_DEL = 1;               !  Delete route
literal NMA$C_PCLI_SRC = 2881;          !  Source address list
!  Regular IO$M_SENSEMODE/IO$M_STARTUP parameters (Token Ring)
literal NMA$C_PCLI_FCA = 2883;          !  FCA list (RO)
literal NMA$C_PCLI_XAC = 2884;          !  Xmit AC 
literal NMA$C_PCLI_RAC = 2885;          !  Recv AC 
literal NMA$C_PCLI_FAMODE = 2886;       !  Func. Addr. Mode
literal NMA$C_PCLI_SRMODE = 2887;       !  SR mode
literal NMA$C_SR_TRANSPARENT = 0;       !  Xparent SR mode
literal NMA$C_SR_SELF = 1;              !  SR done by self
! 
literal NMA$C_PCLI_SRV_OWN = 3300;      !  Owner 
literal NMA$C_PCLI_SRV_UCS = 3311;      !  Unit CSR 
literal NMA$C_PCLI_SRV_VEC = 3312;      !  Vector 
literal NMA$C_PCLI_SRV_PRI = 3313;      !  Priority 
literal NMA$C_PCLI_SRV_LOG = 3380;      !  Logical name 
literal NMA$C_PCLI_SRV_DLG = 3385;      !  Designated name 
literal NMA$C_PCLI_SRV_ACT = 3390;      !  Actual name 
! 
literal NMA$C_LINMD_CSMACD = 10;        ! 
literal NMA$C_LINMD_FDDI = 11;          ! 
literal NMA$C_LINMD_CI = 12;            ! 
literal NMA$C_LINMD_TR = 13;            ! 
literal NMA$C_LINMD_ATM = 14;           ! 
! 
literal NMA$C_PCCO_RTR = 110;           !  Reservation timer (word) 
! 
literal NMA$C_PCLD_ASS = 10;            !  Assistance flag (coded byte of NMA$C_ASS_) 
! 
literal NMA$C_PCLP_ASS = 10;            !  Assistance flag (coded byte of NMA$C_ASS_) 
! 
literal NMA$C_PCCN_CIR = 100;           !  NI circuit name (ascic) 
literal NMA$C_PCCN_SUR = 110;           !  Surveillance flag (coded byte of NMA$C_SUR_) 
literal NMA$C_PCCN_ELT = 111;           !  Elapsed time 
literal NMA$C_PCCN_PHA = 120;           !  Physical address (NI address) 
literal NMA$C_PCCN_LRP = 130;           !  Time of last report 
literal NMA$C_PCCN_MVR = 20001;         !  Maintenance version 
literal NMA$C_PCCN_FCT = 20002;         !  Function list 
literal NMA$C_PCCN_CUS = 20003;         !  Current console user (NI address) 
literal NMA$C_PCCN_RTR = 20004;         !  Reservation timer (word) 
literal NMA$C_PCCN_CSZ = 20005;         !  Command buffer size (word) 
literal NMA$C_PCCN_RSZ = 20006;         !  Response buffer size (word) 
literal NMA$C_PCCN_HWA = 20007;         !  Hardware address (NI address) 
literal NMA$C_PCCN_DTY = 20100;         !  Device type (coded byte of NMA$C_SOFD_) 
literal NMA$C_PCCN_SFI = 20200;         !  Software ID 
literal NMA$C_PCCN_SPR = 20300;         !  System processor (coded word) 
literal NMA$C_PCCN_DLK = 20400;         !  Data link type (coded word) 
! 
literal NMA$C_PCLO_STA = 0;             !  State (coded byte of NMA$C_STATE_) 
literal NMA$C_PCLO_LNA = 100;           !  System/name (ascic) 
literal NMA$C_PCLO_SIN = 200;           !  Sink node 
literal NMA$C_PCLO_EVE = 201;           !  Events 
! 
literal NMA$C_PCXA_NOD = 320;           !  Node 
literal NMA$C_PCXA_USR = 330;           !  User (ascic) 
literal NMA$C_PCXA_SPW = 331;           !  Password to set (ascic) 
literal NMA$C_PCXA_RPW = 331;           !  Password to read (coded byte of NMA$C_NODPW_) 
literal NMA$C_PCXA_ACC = 332;           !  Account (ascic) 
literal NMA$C_PCXA_NET = 1110;          !  Network (ascic) 
! 
literal NMA$C_PCXA_RSX_ADS = 2310;      !  Destination 
literal NMA$C_PCXA_RSX_ANB = 2320;      !  Number 
literal NMA$C_PCXA_RSX_ASC = 2330;      !  Scope 
! 
literal NMA$C_PCXA_SRV_ADS = 3310;      !  Destination 
literal NMA$C_PCXA_SRV_ANB = 3320;      !  Number 
literal NMA$C_PCXA_SRV_ASC = 3330;      !  Scope 
! 
literal NMA$C_PCXP_STA = 0;             !  State (coded byte of NMA$C_STATE_) 
literal NMA$C_PCXP_SBS = 1;             !  Substate, qualified by DTE (coded byte of NMA$C_XPRSB_) 
literal NMA$C_PCXP_CTM = 100;           !  Counter timer (word) 
literal NMA$C_PCXP_ACH = 1000;          !  Active channels (word) 
literal NMA$C_PCXP_ASW = 1010;          !  Active switched (word) 
literal NMA$C_PCXP_DTE = 1100;          !  DTE (ascic) 
literal NMA$C_PCXP_GRP = 1101;          !  Group (ascic) 
literal NMA$C_pcxp_netent = 1110;       !  Network entity (ascic) 
literal NMA$C_pcxp_dnt = 1111;          !  DTE Network (ascic) 
literal NMA$C_PCXP_LIN = 1120;          !  Line (ascic) 
literal NMA$C_PCXP_CHN = 1130;          !  Channels 
literal NMA$C_PCXP_MCH = 1131;          !  Maximum channels (word) 
literal NMA$C_PCXP_DBL = 1140;          !  Default data (word) 
literal NMA$C_PCXP_DWI = 1141;          !  Default window (byte) 
literal NMA$C_PCXP_MBL = 1150;          !  Maximum data (word) 
literal NMA$C_PCXP_MWI = 1151;          !  Maximum window (byte) 
literal NMA$C_PCXP_MCL = 1152;          !  Maximum clears (byte) 
literal NMA$C_PCXP_MRS = 1153;          !  Maximum resets (byte) 
literal NMA$C_PCXP_MST = 1154;          !  Maximum restarts (byte) 
literal NMA$C_PCXP_CAT = 1160;          !  Call timer (byte) 
literal NMA$C_PCXP_CLT = 1161;          !  Clear timer (byte) 
literal NMA$C_PCXP_RST = 1162;          !  Reset timer (byte) 
literal NMA$C_PCXP_STT = 1163;          !  Restart timer (byte)
literal NMA$C_pcxp_itt = 1164;          !  Interrupt timer (byte)
literal NMA$C_PCXP_GDT = 1170;          !  Group DTE (ascic) 
literal NMA$C_PCXP_GNM = 1171;          !  Group number (word) 
literal NMA$C_PCXP_GTY = 1172;          !  Group type (coded byte of NMA$C_XPRTY_) 
literal NMA$C_pcxp_gnt = 1173;          !  Group Network name (ascic)
literal nma$c_pcxp_mode = 1180;         !  DTE mode (coded byte of NMA$C_X25MD_)
literal nma$c_pcxp_prof = 1190;         !  Profile (ascic)
! 
literal NMA$C_PCXP_RSX_PMC = 2300;      !  Maximum circuits 
! 
literal NMA$C_PCXP_MCI = 2710;          !  Maximum circuits, qualified by DTE 
! 
literal NMA$C_PCXP_SRV_PMC = 3300;      !  Maximum circuits 
! 
literal nma$c_pcxs_sta = 1;             !  State (coded byte of NMA$C_STATE_)
literal NMA$C_PCXS_CTM = 100;           !  Counter timer (word) 
literal NMA$C_PCXS_ACI = 200;           !  Active circuits (word) 
literal NMA$C_PCXS_DST = 300;           !  Destination (ascic) 
literal NMA$C_PCXS_MCI = 310;           !  Maximum circuits (word) 
literal NMA$C_PCXS_NOD = 320;           !  Node 
literal NMA$C_PCXS_USR = 330;           !  Username 
literal NMA$C_PCXS_SPW = 331;           !  Password to set (ascic) 
literal NMA$C_PCXS_RPW = 331;           !  Password to read (coded byte of NMA$C_NODPW_) 
literal NMA$C_PCXS_ACC = 332;           !  Account (ascic) 
literal NMA$C_PCXS_OBJ = 340;           !  Object 
literal NMA$C_PCXS_PRI = 350;           !  Priority (byte) 
literal NMA$C_PCXS_CMK = 351;           !  Call mask (byte-counted hex) 
literal NMA$C_PCXS_CVL = 352;           !  Call value (byte-counted hex) 
literal NMA$C_PCXS_GRP = 353;           !  Group (ascic) 
literal NMA$C_PCXS_SDTE = 354;          !  Sending DTE, formally "Number" (ascic) 
literal NMA$C_PCXS_SAD = 355;           !  Subaddresses 
literal nma$c_pcxs_red = 390;           !  Redirect reason (coded byte nma$c_x25red_)
literal nma$c_pcxs_cdte = 391;          !  Called DTE (ascic)
literal nma$c_pcxs_rdte = 392;          !  Receiving DTE (ascic)
literal nma$c_pcxs_net = 393;           !  Network (ascic)
literal nma$C_pcxs_emk = 394;           !  Extension mask (ascic) 
literal nma$C_pcxs_evl = 395;           !  Extension value (ascic) 
literal nma$C_pcxs_idte = 396;          !  Incoming address (ascii)
! 
literal NMA$C_PCXS_RSX_5ST = 2310;      !  State 
!   0, On
literal NMA$C_PCXS_FIL = 2710;          !  Object filespec (ascic) 
! 
literal NMA$C_PCXS_SRV_5ST = 3310;      !  State 
!   0, On
literal NMA$C_PCXT_STA = 0;             !  State (coded byte of NMA$C_STATE_) 
literal NMA$C_PCXT_BSZ = 100;           !  Buffer size (word) 
literal NMA$C_PCXT_MBK = 101;           !  Maximum blocks/file (word) 
literal NMA$C_PCXT_FNM = 102;           !  Filename (ascic) 
literal NMA$C_PCXT_MBF = 103;           !  Maximum number of buffers (word) 
literal NMA$C_PCXT_CPL = 104;           !  Global data capture limit (word) 
literal NMA$C_PCXT_MVR = 105;           !  Maximum trace file version (word) 
literal NMA$C_PCXT_TPT = 106;           !  Trace point name (ascic) 
literal NMA$C_PCXT_CPS = 110;           !  Per-trace capture size (word) 
literal NMA$C_PCXT_TST = 111;           !  Per-trace state (coded byte of NMA$C_STATE_) 
! 
literal NMA$C_PCNO_STA = 0;             !  State (coded byte of NMA$C_STATE_) 
literal NMA$C_PCNO_PHA = 10;            !  Physical address (NI address) 
literal NMA$C_PCNO_IDE = 100;           !  Identification (ascic) 
literal NMA$C_PCNO_MVE = 101;           !  Management version (3 bytes) 
literal NMA$C_PCNO_SLI = 110;           !  Service circuit (ascic) 
literal NMA$C_PCNO_SPA = 111;           !  Service password (8 bytes) 
literal NMA$C_PCNO_SDV = 112;           !  Service device (coded byte of NMA$C_SOFD_) 
literal NMA$C_PCNO_CPU = 113;           !  CPU type (coded byte of NMA$C_CPU_) 
literal NMA$C_PCNO_HWA = 114;           !  Hardware address (NI address) 
literal NMA$C_PCNO_SNV = 115;           !  Service node version (coded byte of NMA$C_SVN_) 
literal NMA$C_PCNO_LOA = 120;           !  Load file (ascic) 
literal NMA$C_PCNO_SLO = 121;           !  Secondary loader (ascic) 
literal NMA$C_PCNO_TLO = 122;           !  Tertiary loader (ascic) 
literal NMA$C_PCNO_DFL = 123;           !  Diagnostic file (ascic) 
literal NMA$C_PCNO_STY = 125;           !  Software type (coded byte of NMA$C_SOFT_) 
literal NMA$C_PCNO_SID = 126;           !  Software ID (ascic) 
literal NMA$C_PCNO_MFL = 127;           !  Management File (ascic)
literal NMA$C_PCNO_DUM = 130;           !  Dump file (ascic) 
literal NMA$C_PCNO_SDU = 131;           !  Secondary dumper (ascic) 
literal NMA$C_PCNO_DAD = 135;           !  Dump address (longword) 
literal NMA$C_PCNO_DCT = 136;           !  Dump count (longword) 
literal NMA$C_PCNO_OHO = 140;           !  Host (read only parameter) 
literal NMA$C_PCNO_IHO = 141;           !  Host (write only parameter) 
literal NMA$C_PCNO_LPC = 150;           !  Loop count (word) 
literal NMA$C_PCNO_LPL = 151;           !  Loop length (word) 
literal NMA$C_PCNO_LPD = 152;           !  Loop Data type (coded byte of NMA$C_LOOP_) 
literal NMA$C_PCNO_LPA = 153;           !  Loop assistant physical address (NI address) 
literal NMA$C_PCNO_LPH = 154;           !  Loop help type (coded byte) 
literal NMA$C_PCNO_LPN = 155;           !  Loop circuit node 
literal NMA$C_PCNO_LAN = 156;           !  Loop circuit assistant node 
literal NMA$C_PCNO_CTI = 160;           !  Counter timer (word) 
literal NMA$C_PCNO_NNA = 500;           !  Name 
literal NMA$C_PCNO_NLI = 501;           !  Circuit (ascic) 
literal NMA$C_PCNO_ADD = 502;           !  Address 
literal NMA$C_PCNO_ITI = 510;           !  Incoming timer (word) 
literal NMA$C_PCNO_OTI = 511;           !  Outgoing timer (word) 
literal NMA$C_PCNO_IPR = 522;           !  Incoming Proxy
literal NMA$C_PCNO_OPR = 523;           !  Outgoing Proxy
literal NMA$C_PCNO_ACL = 600;           !  Active links (word) 
literal NMA$C_PCNO_DEL = 601;           !  Delay (word) 
literal NMA$C_PCNO_NVE = 700;           !  Nsp version (3 bytes) 
literal NMA$C_PCNO_MLK = 710;           !  Maximum links (word) 
literal NMA$C_PCNO_DFA = 720;           !  Delay factor (byte) 
literal NMA$C_PCNO_DWE = 721;           !  Delay weight (byte) 
literal NMA$C_PCNO_IAT = 722;           !  Inactivity timer (word) 
literal NMA$C_PCNO_RFA = 723;           !  Retransmit factor (word) 
literal NMA$C_PCNO_DTY = 810;           !  Destination Type (coded byte of NMA$C_XPRTY_) 
literal NMA$C_PCNO_DCO = 820;           !  Destination Cost (word) 
literal NMA$C_PCNO_DHO = 821;           !  Destination Hops (byte) 
literal NMA$C_PCNO_DLI = 822;           !  Destination circuit (ascic) 
literal NMA$C_PCNO_NND = 830;           !  Next node to destination 
literal NMA$C_PCNO_RVE = 900;           !  Routing version (3 bytes) 
literal NMA$C_PCNO_ETY = 901;           !  Executor Type (coded byte of NMA$C_NODTY_) 
literal NMA$C_PCNO_RTI = 910;           !  Routing timer (word) 
literal NMA$C_PCNO_SAD = 911;           !  Subaddress (2 words) 
literal NMA$C_PCNO_BRT = 912;           !  Broadcast routing timer (word) 
literal NMA$C_PCNO_MAD = 920;           !  Maximum address (word) 
literal NMA$C_PCNO_MLN = 921;           !  Maximum circuits (word) 
literal NMA$C_PCNO_MCO = 922;           !  Maximum cost (word) 
literal NMA$C_PCNO_MHO = 923;           !  Maximum hops (byte) 
literal NMA$C_PCNO_MVI = 924;           !  Maximum visits (byte) 
literal NMA$C_PCNO_MAR = 925;           !  Maximum areas (byte) 
literal NMA$C_PCNO_MBE = 926;           !  Maximum broadcast nonrouters (word) 
literal NMA$C_PCNO_MBR = 927;           !  Maximum broadcast routers (word) 
literal NMA$C_PCNO_AMC = 928;           !  Area maximum cost (word) 
literal NMA$C_PCNO_AMH = 929;           !  Area maximum hops (byte) 
literal NMA$C_PCNO_MBU = 930;           !  Maximum buffers (word) 
literal NMA$C_PCNO_BUS = 931;           !  Executor buffer size (word) 
literal NMA$C_PCNO_SBS = 932;           !  Segment buffer size (word) 
literal NMA$C_PCNO_MPS = 933;           !  Maximum path splits
literal NMA$C_PCNO_FBS = 933;           !  Forwarding buffer size (word) 
! 
literal NMA$C_PCNO_RSX_RPA = 2300;      !  Receive password 
!   0, Password set
literal NMA$C_PCNO_RSX_TPA = 2301;      !  Transmit password 
!   0, Password set
literal NMA$C_PCNO_RSX_VER = 2310;      !  Verification state 
!   0, On
literal NMA$C_PCNO_PUS = 2704;          !  Privileged user id 
literal NMA$C_PCNO_PAC = 2705;          !  Privileged account 
literal NMA$C_PCNO_PPW = 2706;          !  Privileged password 
literal NMA$C_PCNO_NUS = 2712;          !  Non-privileged user id 
literal NMA$C_PCNO_NAC = 2713;          !  Non-privileged account 
literal NMA$C_PCNO_NPW = 2714;          !  Non-privileged password 
literal NMA$C_PCNO_RPA = 2720;          !  Receive password 
literal NMA$C_PCNO_TPA = 2721;          !  Transmit password 
literal NMA$C_PCNO_ACC = 2730;          !  Access (coded byte of NMA$C_ACES_) 
literal NMA$C_PCNO_DAC = 2731;          !  Default access (coded byte of NMA$C_ACES_) 
literal NMA$C_PCNO_PIQ = 2740;          !  Pipeline quota (word) 
literal NMA$C_PCNO_ALI = 2742;          !  Alias incoming (coded byte of ALIINC))
literal NMA$C_PCNO_ALM = 2743;          !  Alias Maximum links
literal NMA$C_PCNO_ALN = 2744;          !  Alias node
literal NMA$C_PCNO_PRX = 2750;          !  Proxy access (coded byte of NMA$C_ACES_) !! Obsolete: Only for LIST/PURGE 
literal NMA$C_PCNO_DPX = 2751;          !  Default proxy access (coded byte of NMA$C_ACES_) 
literal NMA$C_PCNO_COP = 2760;          !  Remote nodefor COPY command
literal NMA$C_PCNO_INB = 2765;          !  Inbound for async DECnet.
literal NMA$C_PCNO_LAA = 2770;          !  Load Assist Agent
literal NMA$C_PCNO_LAP = 2771;          !  Load Assist Parameter
literal NMA$C_PCNO_PSP = 2780;          !  Path Splits Policy
!  (Coded byte f PSPCY)
literal NMA$C_PCNO_MDO = 2785;          !  Maximum Declared Objects
literal NMA$C_PCNO_DNS = 2790;          !  DNS interface
literal NMA$C_PCNO_IDP = 2791;          !  IDP of ISO address
literal NMA$C_PCNO_DNM = 2792;          !  DNS namespace
! 
literal NMA$C_PCNO_SRV_RPA = 3300;      !  Receive password 
!   0, Password set
literal NMA$C_PCNO_SRV_TPA = 3301;      !  Transmit password 
!   0, Password set
literal NMA$C_PCNO_SRV_VER = 3310;      !  Verification state 
!   0, On
literal NMA$C_PCNO_SRV_ACB = 3402;      !  Active control buffers 
literal NMA$C_PCNO_SRV_ASB = 3404;      !  Active small buffers 
literal NMA$C_PCNO_SRV_ALB = 3406;      !  Active large buffers 
literal NMA$C_PCNO_SRV_MCB = 3410;      !  Maximum control buffers 
literal NMA$C_PCNO_SRV_MSB = 3420;      !  Maximum small buffers 
literal NMA$C_PCNO_SRV_MLB = 3430;      !  Maximum large buffers 
literal NMA$C_PCNO_SRV_LBS = 3431;      !  Large buffer size 
literal NMA$C_PCNO_SRV_NRB = 3440;      !  Minimum receive buffers 
literal NMA$C_PCNO_SRV_CPT = 3450;      !  CEX pool: total bytes 
literal NMA$C_PCNO_SRV_CPF = 3452;      !  CEX pool: number of segments 
literal NMA$C_PCNO_SRV_CPL = 3454;      !  CEX pool: largest segment 
literal NMA$C_PCNO_SRV_XPT = 3460;      !  Extended pool: total bytes 
literal NMA$C_PCNO_SRV_XPF = 3462;      !  Extended pool: number of segments 
literal NMA$C_PCNO_SRV_XPL = 3464;      !  Extended pool: largest segment 
! 
literal NMA$C_PCAR_STA = 0;             !  State (coded byte of NMA$C_STATE_) 
literal NMA$C_PCAR_COS = 820;           !  Cost (word) 
literal NMA$C_PCAR_HOP = 821;           !  Hops (byte) 
literal NMA$C_PCAR_CIR = 822;           !  Circuit (ascic) 
literal NMA$C_PCAR_NND = 830;           !  Next node to area 
! 
literal NMA$C_PCOB_OAN = 400;           !  Active name 
literal NMA$C_PCOB_OAC = 410;           !  Active links 
literal NMA$C_PCOB_ONA = 500;           !  Name 
literal NMA$C_PCOB_OCO = 510;           !  Copies 
literal NMA$C_PCOB_OUS = 511;           !  User 
literal NMA$C_PCOB_OVE = 520;           !  Verification 
literal NMA$C_PCOB_NAM = 500;           !  Name 
literal NMA$C_PCOB_NUM = 513;           !  Number 
literal NMA$C_PCOB_FID = 530;           !  File id 
literal NMA$C_PCOB_PID = 535;           !  Process id 
literal NMA$C_PCOB_PRV = 540;           !  Privilege list 
literal NMA$C_PCOB_OCPRV = 542;         !  Outgoing connect privilege list 
literal NMA$C_PCOB_USR = 550;           !  User id 
literal NMA$C_PCOB_ACC = 551;           !  Account 
literal NMA$C_PCOB_PSW = 552;           !  Password 
literal NMA$C_PCOB_PRX = 560;           !  Proxy access (coded byte of NMA$C_ACES_) 
literal NMA$C_PCOB_ALO = 565;           !  Alias outgoing- coded byte of nma$c_alout
literal NMA$C_PCOB_ALI = 566;           !  Alias incoming- coded byte of nma$c_alinc
! 
literal NMA$C_PCLK_STA = 0;             !  State 
literal NMA$C_PCLK_PID = 101;           !  Process id 
literal NMA$C_PCLK_NID = 102;           !  Partner Node 
literal NMA$C_PCLK_LAD = 105;           !  Link address [V2 only] 
!  entity is node rather than link !
literal NMA$C_PCLK_DLY = 110;           !  Round trip delay time (word) 
literal NMA$C_PCLK_RLN = 120;           !  Remote link number (word) 
literal NMA$C_PCLK_RID = 121;           !  Remote identification, PID or username (ascic) 
literal NMA$C_PCLK_USR = 130;           !  Username of link owner (ascic) 
literal NMA$C_PCLK_PRC = 131;           !  Process name of link owner (ascic) 
! 
literal NMA$C_CTCIR_ZER = 0;            !  Seconds since last zeroed 
literal NMA$C_CTCIR_APR = 800;          !  Terminating packets received 
literal NMA$C_CTCIR_DPS = 801;          !  Originating packets sent 
literal NMA$C_CTCIR_ACL = 802;          !  Terminating congestion loss 
literal NMA$C_CTCIR_CRL = 805;          !  Corruption loss 
literal NMA$C_CTCIR_TPR = 810;          !  Transit packets received 
literal NMA$C_CTCIR_TPS = 811;          !  Transit packets sent 
literal NMA$C_CTCIR_TCL = 812;          !  Transit congestion loss 
literal NMA$C_CTCIR_LDN = 820;          !  Circuit down 
literal NMA$C_CTCIR_IFL = 821;          !  Initialization failure 
literal NMA$C_CTCIR_AJD = 822;          !  Adjacency down events
literal NMA$C_CTCIR_PAJ = 900;          !  Peak adjacencies 
literal NMA$C_CTCIR_BRC = 1000;         !  Bytes received 
literal NMA$C_CTCIR_BSN = 1001;         !  Bytes sent 
literal NMA$C_CTCIR_MBY = 1002;         !  Multicast bytes received 
literal NMA$C_CTCIR_DBR = 1010;         !  Data blocks received 
literal NMA$C_CTCIR_DBS = 1011;         !  Data blocks sent 
literal NMA$C_CTCIR_DEI = 1020;         !  Data errors inbound 
literal NMA$C_CTCIR_DEO = 1021;         !  Data errors outbound 
literal NMA$C_CTCIR_RRT = 1030;         !  Remote reply timeouts 
literal NMA$C_CTCIR_LRT = 1031;         !  Local reply timeouts 
literal NMA$C_CTCIR_RBE = 1040;         !  Remote buffer errors 
literal NMA$C_CTCIR_LBE = 1041;         !  Local buffer errors 
literal NMA$C_CTCIR_SIE = 1050;         !  Selection intervals elapsed 
literal NMA$C_CTCIR_SLT = 1051;         !  Selection timeouts 
literal NMA$C_CTCIR_UBU = 1065;         !  NI user buffer unavailable 
literal NMA$C_CTCIR_RPE = 1100;         !  Remote process errors [V2 only] 
literal NMA$C_CTCIR_LPE = 1101;         !  Local process errors [V2 only] 
literal NMA$C_CTCIR_LIR = 1240;         !  Locally initiated resets 
literal NMA$C_CTCIR_RIR = 1241;         !  Remotely initiated resets 
literal NMA$C_CTCIR_NIR = 1242;         !  Network initiated resets 
! 
literal NMA$C_CTCIR_MNE = 2701;         !  Multicast received for protocol 
!  type, but not enabled
literal NMA$C_CTCIR_ERI = 2750;         !  PCL Errors inbound, bit-mapped 
!         0  CRC error on receive
literal NMA$C_CTCIR_ERO = 2751;         !  PCL Errors outbound, bit-mapped 
!         1  CRC on transmit
literal NMA$C_CTCIR_RTO = 2752;         !  PCL Remote timeouts, bit-mapped 
!         0  Receiver busy
literal NMA$C_CTCIR_LTO = 2753;         !  PCL Local timeouts 
literal NMA$C_CTCIR_BER = 2754;         !  PCL Remote buffer errors 
literal NMA$C_CTCIR_BEL = 2755;         !  PCL Local buffer errors 
! 
literal NMA$C_CTLIN_ZER = 0;            !  Seconds since last zeroed 
literal NMA$C_CTLIN_APR = 800;          !  Arriving packets received [V2 only] 
literal NMA$C_CTLIN_DPS = 801;          !  Departing packets sent [V2 only] 
literal NMA$C_CTLIN_ACL = 802;          !  Arriving congestion loss [V2 only] 
literal NMA$C_CTLIN_TPR = 810;          !  Transit packets received [V2 only] 
literal NMA$C_CTLIN_TPS = 811;          !  Transit packets sent [V2 only] 
literal NMA$C_CTLIN_TCL = 812;          !  Transit congestion loss [V2 only] 
literal NMA$C_CTLIN_LDN = 820;          !  Line down [V2 only] 
literal NMA$C_CTLIN_IFL = 821;          !  Initialization failure [V2 only] 
literal NMA$C_CTLIN_BRC = 1000;         !  Bytes received 
literal NMA$C_CTLIN_BSN = 1001;         !  Bytes sent 
literal NMA$C_CTLIN_MBY = 1002;         !  Multicast bytes received 
literal NMA$C_CTLIN_DBR = 1010;         !  Data blocks received 
literal NMA$C_CTLIN_DBS = 1011;         !  Data blocks sent 
literal NMA$C_CTLIN_MBL = 1012;         !  Multicast blocks received 
literal NMA$C_CTLIN_BID = 1013;         !  Blocks sent, initially deferred 
literal NMA$C_CTLIN_BS1 = 1014;         !  Blocks sent, single collision 
literal NMA$C_CTLIN_BSM = 1015;         !  Blocks sent, multiple collisions 
literal NMA$C_CTLIN_MFC = 1016;         !  MAC frame count
literal NMA$C_CTLIN_MEC = 1017;         !  MAC error count
literal NMA$C_CTLIN_MLC = 1018;         !  MAC lost count
literal NMA$C_CTLIN_DEI = 1020;         !  Data errors inbound 
literal NMA$C_CTLIN_DEO = 1021;         !  Data errors outbound 
literal NMA$C_CTLIN_RRT = 1030;         !  Remote reply timeouts 
literal NMA$C_CTLIN_LRT = 1031;         !  Local reply timeouts 
literal NMA$C_CTLIN_RII = 1032;         !  Ring initializations initiated
literal NMA$C_CTLIN_RIR = 1033;         !  Ring initializations received
literal NMA$C_CTLIN_RBI = 1034;         !  Ring beacons initiated
literal NMA$C_CTLIN_DAT = 1035;         !  Duplicate address test failures
literal NMA$C_CTLIN_DTD = 1036;         !  Duplicate tokens detected
literal NMA$C_CTLIN_RPR = 1037;         !  Ring purge errors
literal NMA$C_CTLIN_FSE = 1038;         !  FCI strip errors
literal NMA$C_CTLIN_TRI = 1039;         !  Traces initiated
literal NMA$C_CTLIN_RBE = 1040;         !  Remote buffer errors 
literal NMA$C_CTLIN_LBE = 1041;         !  Local buffer errors 
literal NMA$C_CTLIN_TRR = 1042;         !  Traces initiated
literal NMA$C_CTLIN_DBC = 1043;         !  Directed beacons received
literal NMA$C_CTLIN_SIE = 1050;         !  Selection intervals elapsed [V2 only] 
literal NMA$C_CTLIN_SLT = 1051;         !  Selection timeouts [V2 only] 
literal NMA$C_CTLIN_SFL = 1060;         !  Send failure 
literal NMA$C_CTLIN_CDC = 1061;         !  Collision detect check failure 
literal NMA$C_CTLIN_RFL = 1062;         !  Receive failure 
literal NMA$C_CTLIN_UFD = 1063;         !  Unrecognized frame destination 
literal NMA$C_CTLIN_OVR = 1064;         !  Data overrun 
literal NMA$C_CTLIN_SBU = 1065;         !  System buffer unavailable 
literal NMA$C_CTLIN_UBU = 1066;         !  User buffer unavailable 
literal NMA$C_CTLIN_SFR = 1070;         !  Send failures (Token Ring)
literal NMA$C_CTLIN_RFR = 1071;         !  Receive failures (Token Ring)
literal NMA$C_CTLIN_IFR = 1072;         !  Insertion failures 
literal NMA$C_CTLIN_RGF = 1073;         !  Ring failures
literal NMA$C_CTLIN_RPG = 1074;         !  Ring purges
literal NMA$C_CTLIN_MNC = 1075;         !  Monitor contention
literal NMA$C_CTLIN_BCN = 1076;         !  Beaconing conditions
literal NMA$C_CTLIN_LER = 1080;         !  Line errors
literal NMA$C_CTLIN_IER = 1081;         !  Internal errors
literal NMA$C_CTLIN_BER = 1082;         !  Burst errors
literal NMA$C_CTLIN_RAE = 1083;         !  Ring poll AC errors
literal NMA$C_CTLIN_ADS = 1084;         !  Abort delimiters sent
literal NMA$C_CTLIN_PIE = 1085;         !  Private isolating errors                                                                 
literal NMA$C_CTLIN_TLF = 1086;         !  Transmit lost frames
literal NMA$C_CTLIN_RCE = 1087;         !  Receiver congestion errors
literal NMA$C_CTLIN_FCE = 1088;         !  Frame copied errors
literal NMA$C_CTLIN_FER = 1089;         !  Frequency errors (802.5 defined but not implemented)
literal NMA$C_CTLIN_TER = 1090;         !  Token errors
literal NMA$C_CTLIN_PNE = 1091;         !  Private non-isolating errors
literal NMA$C_CTLIN_RPE = 1100;         !  Remote process errors 
literal NMA$C_CTLIN_LPE = 1101;         !  Local process errors 
literal NMA$C_CTLIN_EBE = 1200;         !  Elasticity buffer errors	
literal NMA$C_CTLIN_LCT = 1201;         !  LCT rejects
literal NMA$C_CTLIN_LEM = 1202;         !  LEM rejects
literal NMA$C_CTLIN_LNK = 1203;         !  Link errors
literal NMA$C_CTLIN_CNC = 1204;         !  Connections completed
! 
literal NMA$S_NMADEF1 = 2;              !  Old size name - synonym
literal NMA$S_NMA1 = 2;
macro NMA$W_NODE = 0,0,16,0 %;
macro NMA$V_ADDR = 0,0,10,0 %;
literal NMA$S_ADDR = 10;
macro NMA$V_AREA = 0,10,6,0 %;
literal NMA$S_AREA = 6;
! 
!  Parameter ID word (DATA ID)
! 
macro NMA$V_PTY_TYP = 0,0,15,0 %;
literal NMA$S_PTY_TYP = 15;             !  Type mask 
! 
!  Parameter data type byte (DATA TYPE)
! 
macro NMA$V_PTY_CLE = 0,0,6,0 %;
literal NMA$S_PTY_CLE = 6;              !  Coded length mask 
macro NMA$V_PTY_MUL = 0,6,1,0 %;        !  Coded multiple indicator 
macro NMA$V_PTY_COD = 0,7,1,0 %;        !  Coded indicator 
macro NMA$V_PTY_CMU = 0,6,2,0 %;
literal NMA$S_PTY_CMU = 2;              !  Coded multiple 
macro NMA$V_PTY_NLE = 0,0,4,0 %;
literal NMA$S_PTY_NLE = 4;              !  Number length mask 
macro NMA$V_PTY_NTY = 0,4,2,0 %;
literal NMA$S_PTY_NTY = 2;              !  Number type mask 
macro NMA$V_PTY_ASC = 0,6,1,0 %;        !  Ascii image indicator 
!  NTY values (how to display number): 
!  Define standard values for the DATA TYPE byte
! 
!  Parameters for 802 control support
! 
!     Circuit parameters
! 
!  RSX-specific circuit parameters
! 
!  VMS-specific circuit NICE parameters [2700 - 2799]
! 
! 
!  VMS-specific datalink only circuit parameters   [2800 - 2899]
! 
!  (these will never be used in NICE messages).
! 
!  Server Base specific Circuit parameters
! 
!     Line parameters
! 
!  FDDI-specific line parameters
! 
!  Token Ring specific line parameters  
!       (Upstream Neighbor Address used by both FDDI and Token Ring)
! 
!  FDDI-specific line parameters continued
! 
!  RSX-specific line parameters
! 
!   1, Topdown
!  VMS-specific line NICE parameters [2700 - 2799]
! 
!  VMS-specific datalink only line parameters   [2800 - 2899]
! 
!  (these will never be used in NICE messages).
! 
!     Server Base specific line parameters
! 
!     Communication Medium parameters
! 
!     Console module parameters
! 
!     Loader module parameters
! 
!     Looper module parameters
! 
!     Configurator module parameters
! 
!     Logging parameters
! 
!     X.25 Access module parameters
! 
!  RSX-specific X.25-Access module parameters
! 
!  Server Base specific X.25-Access module parameters
! 
!     X.25 Protocol module parameters
! 
!       RSX-specific X.25-Protocol Module parameters
! 
!  VMS-specific X25-PROTOCOL NICE parameters [2700 - 2799]
! 
!  Server Base specific X.25-Protocol Module parameters
! 
!     X.25 server module parameters
! 
!  RSX-specific X.25-Server Module parameters
! 
!   1, Off
! 
!  VMS-specific X25-SERVER NICE parameters [2700 - 2799]
! 
!  Server Base specific X.25-Server Module parameters
! 
!   1, Off
! 
!  X.25 trace module parameters (VMS-specific)
! 
!     Node parameters
! 
!  RSX-Specific Node (Executor) parameters
! 
!   1, Off
! 
!  VMS-specific node parameters
! 
!  Server Base specific Node (Executor) parameters
! 
!   1, Off
!     Area parameters
! 
!     VMS-specific object parameters
! 
!     VMS-specific link parameters
! 
!  CM-1/2, DU-2 (link !), HI-4 (pid)
!     Circuit counters
! 
!  VMS-specific circuit counters
! 
!         2  Timeout on word
!         1  Transmitter offline
!         2  Receiver offline
!     Line counters
! 
!  Line counter flags (byte offset will be 0)
! 
literal NMA$M_CTLIN_BTL = %X'8';
literal NMA$M_CTLIN_FCS = %X'10';
literal NMA$M_CTLIN_TRJ = %X'20';
literal NMA$S_NMADEF2 = 1;              !  Old size name - synonym
literal NMA$S_NMA2 = 1;
macro NMA$V_CTLIN_BTL = 0,3,1,0 %;      !  block too long 
macro NMA$V_CTLIN_FCS = 0,4,1,0 %;      !  frame check 
macro NMA$V_CTLIN_TRJ = 0,5,1,0 %;      !  REJ sent 
literal NMA$M_CTLIN_RRJ = %X'8';
literal NMA$S_NMADEF3 = 1;              !  Old size name - synonym
literal NMA$S_NMA3 = 1;
macro NMA$V_CTLIN_RRJ = 0,3,1,0 %;      !  REJ received 
literal NMA$M_CTLIN_RRN = %X'4';
literal NMA$S_NMADEF4 = 1;              !  Old size name - synonym
literal NMA$S_NMA4 = 1;
macro NMA$V_CTLIN_RRN = 0,2,1,0 %;      !  RNR received 
literal NMA$M_CTLIN_TRN = %X'4';
literal NMA$S_NMADEF5 = 1;              !  Old size name - synonym
literal NMA$S_NMA5 = 1;
macro NMA$V_CTLIN_TRN = 0,2,1,0 %;      !  RNR sent 
literal NMA$M_CTLIN_INR = %X'10';
literal NMA$M_CTLIN_FMS = %X'20';
literal NMA$S_NMADEF6 = 1;              !  Old size name - synonym
literal NMA$S_NMA6 = 1;
macro NMA$V_CTLIN_INR = 0,4,1,0 %;      !  invalid N(R) received 
macro NMA$V_CTLIN_FMS = 0,5,1,0 %;      !  FRMR sent 
literal NMA$M_CTLIN_TUN = %X'4';
literal NMA$M_CTLIN_RUN = %X'10';
literal NMA$M_CTLIN_FMR = %X'20';
literal NMA$C_CTLIN_MBS = 2701;         !  Multicast packets transmitted 
literal NMA$C_CTLIN_MSN = 2702;         !  Multicast bytes transmitted 
literal NMA$C_CTLIN_RME = 2750;         !  PCL Remote errors, bit-mapped 
!         0  TDM bus busy
literal NMA$C_CTLIN_LCE = 2751;         !  PCL Local errors, bit-mapped 
!         0  Transmitter overrun
literal NMA$C_CTLIN_MSE = 2752;         !  PCL master/secondary errors, bit-mapped 
!         1  Master down
literal NMA$C_CTNOD_ZER = 0;            !  Seconds since last zeroed 
literal NMA$C_CTNOD_BRC = 600;          !  Bytes received 
literal NMA$C_CTNOD_BSN = 601;          !  Bytes sent 
literal NMA$C_CTNOD_MRC = 610;          !  Messages received 
literal NMA$C_CTNOD_MSN = 611;          !  Messages sent 
literal NMA$C_CTNOD_CRC = 620;          !  Connects received 
literal NMA$C_CTNOD_CSN = 621;          !  Connects sent 
literal NMA$C_CTNOD_RTO = 630;          !  Response timeouts 
literal NMA$C_CTNOD_RSE = 640;          !  Received connect resource errors 
literal NMA$C_CTNOD_BUN = 650;          !  Buffer unavailable 
literal NMA$C_CTNOD_MLL = 700;          !  Maximum logical links active 
literal NMA$C_CTNOD_APL = 900;          !  Aged packet loss 
literal NMA$C_CTNOD_NUL = 901;          !  Node unreachable packet loss 
literal NMA$C_CTNOD_NOL = 902;          !  Node out-of-range packet loss 
literal NMA$C_CTNOD_OPL = 903;          !  Oversized packet loss 
literal NMA$C_CTNOD_PFE = 910;          !  Packet format error 
literal NMA$C_CTNOD_RUL = 920;          !  Partial routing update loss 
literal NMA$C_CTNOD_VER = 930;          !  Verification reject 
! 
literal NMA$C_CTNOD_SRV_SYC = 3310;     !  Control buffer failures 
literal NMA$C_CTNOD_SRV_SYS = 3320;     !  Small buffer failures 
literal NMA$C_CTNOD_SRV_SYL = 3330;     !  Large buffer failures 
literal NMA$C_CTNOD_SRV_SYR = 3340;     !  Receive buffer failures 
! 
literal NMA$C_CTXP_ZER = 0;             !  Seconds since last zeroed 
literal NMA$C_CTXP_BRC = 1000;          !  Bytes received 
literal NMA$C_CTXP_BSN = 1001;          !  Bytes sent 
literal NMA$C_CTXP_BLR = 1010;          !  Data blocks received 
literal NMA$C_CTXP_BLS = 1011;          !  Data blocks sent 
literal NMA$C_CTXP_CRC = 1200;          !  Calls received 
literal NMA$C_CTXP_CSN = 1201;          !  Calls sent 
literal NMA$C_CTXP_FSR = 1210;          !  Fast selects received 
literal NMA$C_CTXP_FSS = 1211;          !  Fast selects sent 
literal NMA$C_CTXP_MSA = 1220;          !  Maximum switched circuits active 
literal NMA$C_CTXP_MCA = 1221;          !  Maximum channels active 
literal NMA$C_CTXP_RSE = 1230;          !  Received call resource errors 
literal NMA$C_CTXP_LIR = 1240;          !  Locally initiated resets 
literal NMA$C_CTXP_RIR = 1241;          !  Remotely initiated resets 
literal NMA$C_CTXP_NIR = 1242;          !  Network initiated resets 
literal NMA$C_CTXP_RST = 1250;          !  Restarts 
! 
literal NMA$C_CTXS_ZER = 0;             !  Seconds since last zeroed 
literal NMA$C_CTXS_MCA = 200;           !  Maximum circuits active 
literal NMA$C_CTXS_ICR = 210;           !  Incoming calls rejected, no resources 
literal NMA$C_CTXS_LLR = 211;           !  Logical links rejected, no resources 
! 
literal NMA$C_LOOP_MIX = 2;             !  Mixed 
literal NMA$C_LOOP_ONE = 1;             !  Ones 
literal NMA$C_LOOP_ZER = 0;             !  Zeroes 
! 
literal NMA$C_LOOP_DCNT = 1;            !  Default count 
literal NMA$C_LOOP_DSIZ = 40;           !  Default message size 
! 
literal NMA$C_LOOP_XMIT = 0;            !  Transmit 
literal NMA$C_LOOP_RECV = 1;            !  Receive 
literal NMA$C_LOOP_FULL = 2;            !  Full (both transmit and receive) 
! 
literal NMA$C_STATE_ON = 0;             !  On 
literal NMA$C_STATE_OFF = 1;            !  Off 
! 
literal NMA$C_DNS_ENA = 0;              !  Enabled
literal NMA$C_DNS_DIS = 1;              !  Disabled
! 
literal NMA$C_STATE_SER = 2;            !  Service (circuit/line only) 
literal NMA$C_STATE_CLE = 3;            !  Cleared 
! 
literal NMA$C_STATE_HOL = 2;            !  Hold 
! 
literal NMA$C_STATE_SHU = 2;            !  Shut 
literal NMA$C_STATE_RES = 3;            !  Restricted 
literal NMA$C_STATE_REA = 4;            !  Reachable 
literal NMA$C_STATE_UNR = 5;            !  Unreachable 
! 	PVM0001+
literal NMA$C_PCNO_DMAD = 1023;         ! 
! 	PVM0001-	
literal NMA$C_ASS_ENA = 0;              !  Enabled 
literal NMA$C_ASS_DIS = 1;              !  Disabled 
! 
literal NMA$C_SUR_ENA = 0;              !  Enabled 
literal NMA$C_SUR_DIS = 1;              !  Disabled 
! 
literal NMA$C_LINSS_STA = 0;            !  Starting 
literal NMA$C_LINSS_REF = 1;            !  Reflecting 
literal NMA$C_LINSS_LOO = 2;            !  Looping 
literal NMA$C_LINSS_LOA = 3;            !  Loading 
literal NMA$C_LINSS_DUM = 4;            !  Dumping 
literal NMA$C_LINSS_TRI = 5;            !  Triggering 
literal NMA$C_LINSS_ASE = 6;            !  Autoservice 
literal NMA$C_LINSS_ALO = 7;            !  Autoloading 
literal NMA$C_LINSS_ADU = 8;            !  Autodumping 
literal NMA$C_LINSS_ATR = 9;            !  Autotriggering 
literal NMA$C_LINSS_SYN = 10;           !  Synchronizing 
literal NMA$C_LINSS_FAI = 11;           !  Failed 
literal NMA$C_LINSS_RUN = 12;           !  Running 
literal NMA$C_LINSS_UNS = 13;           !  Unsyncronised 
literal NMA$C_LINSS_IDL = 14;           !  Idle (PSI-only) 
! 
literal NMA$C_CIRTY_POI = 0;            !  DDCMP Point 
literal NMA$C_CIRTY_CON = 1;            !  DDCMP Controller 
literal NMA$C_CIRTY_TRI = 2;            !  DDCMP Tributary 
literal NMA$C_CIRTY_X25 = 3;            !  X25 
literal NMA$C_CIRTY_DMC = 4;            !  DDCMP DMC compatibility mode (DMP) 
! /*        CIRTY_LAPB, 5                /* LAPB  *** remove once all references have been changed to LAPB ***
literal NMA$C_CIRTY_NI = 6;             !  NI 
literal NMA$C_CIRTY_TRNG = 11;          !  Token Ring
literal NMA$C_CIRTY_FDDI = 12;          !  FDDI
! 
literal NMA$C_LINSV_ENA = 0;            !  Enabled 
literal NMA$C_LINSV_DIS = 1;            !  Disabled 
! 
literal NMA$C_CIRPST_AUT = 1;           !  Automatic 
literal NMA$C_CIRPST_ACT = 2;           !  Active 
literal NMA$C_CIRPST_INA = 3;           !  Inactive 
literal NMA$C_CIRPST_DIE = 4;           !  Dying 
literal NMA$C_CIRPST_DED = 5;           !  Dead 
! 
literal NMA$C_CIRBLK_ENA = 0;           !  Enabled 
literal NMA$C_CIRBLK_DIS = 1;           !  Disabled 
! 
literal NMA$C_CIRUS_PER = 0;            !  Permanent 
literal NMA$C_CIRUS_INC = 1;            !  Incoming 
literal NMA$C_CIRUS_OUT = 2;            !  Outgoing 
! 
literal NMA$C_CIRHS_ENA = 0;            !  Enabled
literal NMA$C_CIRHS_DIS = 1;            !  Disabled
! 
literal NMA$C_CIRBF_UNL = 255;          !  Unlimited 
! 
literal NMA$C_CIRVE_ENA = 0;            !  Enabled 
literal NMA$C_CIRVE_DIS = 1;            !  Disabled 
literal NMA$C_CIRVE_INB = 2;            !  Inbound
! 
literal NMA$C_CIRXPT_ZND = 1;           !  Z-node 
literal NMA$C_CIRXPT_PH2 = 2;           !  Force Phase II on this circuit 
literal NMA$C_CIRXPT_PH3 = 3;           !  Routing III 
literal NMA$C_CIRXPT_RO3 = 3;           !  Routing III 
literal NMA$C_CIRXPT_NR4 = 4;           !  Nonrouting Phase IV 
! 
literal NMA$C_DPX_FUL = 0;              !  Full 
literal NMA$C_DPX_HAL = 1;              !  Half 
literal NMA$C_DPX_MPT = 4;              !  Multipoint
! 
literal NMA$C_LINCN_NOR = 0;            !  Normal 
literal NMA$C_LINCN_LOO = 1;            !  Loop 
! 
literal NMA$C_LINPR_POI = 0;            !  DDCMP Point 
literal NMA$C_LINPR_CON = 1;            !  DDCMP Controller 
literal NMA$C_LINPR_TRI = 2;            !  DDCMP Tributary 
literal NMA$C_LINPR_DMC = 4;            !  DDCMP DMC compatibility mode (DMP) 
literal NMA$C_LINPR_LAPB = 5;           !  LAPB 
literal NMA$C_LINPR_NI = 6;             !  NI 
literal NMA$C_LINPR_BSY = 9;            !  BISYNC (not really - just Genbyte)
literal NMA$C_LINPR_GENBYTE = 9;        !  Genbyte (real name)
literal nma$c_linpr_lapbe = 10;         !  LAPBE
literal nma$c_LINPR_TRNG = 11;          !  Token Ring
literal nma$c_LINPR_FDDI = 12;          !  FDDI
literal nma$c_linpr_ea_hdlc = 20;       !  Extended addressing HDLC
literal nma$c_linpr_sdlc = 21;          !  SDLC
literal nma$c_linpr_bisync = 22;        !  IBM Bisync protocol (not BSY framing)
literal nma$c_linpr_swift = 23;         !  SWIFT Bisync variant
literal nma$c_linpr_chips = 24;         !  CHIPS Bisync variant
literal nma$m_linpr_mop = 128;          !  MOP support
! 
literal nma$c_code_ascii = 1;           !  ASCII character code
literal nma$c_code_ebcdic = 2;          !  EBCDIC character code
! 
literal NMA$C_LINPR_MAS = 1;            !  Master (controls clock signals) 
literal NMA$C_LINPR_NEU = 2;            !  Neutral (uses master's clock signals) 
literal NMA$C_LINPR_SEC = 0;            !  Secondary (backup for master failure) 
! 
literal NMA$C_LINCL_EXT = 0;            !  External 
literal NMA$C_LINCL_INT = 1;            !  Internal 
! 
literal NMA$C_LINFM_802E = 0;           !  802 Extended
literal NMA$C_LINFM_ETH = 1;            !  Ethernet
literal NMA$C_LINFM_802 = 2;            !  802
literal NMA$C_LINFM_SMT = 4;            !  SMT (FDDI)
! 
literal NMA$C_LINCN_LEN = 0;            !  Local Entity Name
literal NMA$C_LINCN_NAM = 1;            !  Ascii Name
! 
literal NMA$C_LINSR_USR = 1;            !  User supplied
literal NMA$C_LINSR_CLI = 2;            !  Class I
! 
literal NMA$C_LINSWI_DIS = 1;           !  Switch disabled
literal NMA$C_LINSWI_ENA = 0;           !  Switch enabled
! 
literal NMA$C_LINRPE_ON = 1;            !  Ring purge on
literal NMA$C_LINRPE_OFF = 0;           !  Ring purge off
!  
literal NMA$C_LINATY_HIORD = 0;         !  DECnet address
literal NMA$C_LINATY_HW = 1;            !  Hardware address
literal NMA$C_LINATY_USER = 2;          !  User supplied address
! 
literal NMA$C_LINRNG_FOUR = 0;          !  4 Mbps
literal NMA$C_LINRNG_SIXTN = 1;         !  16 Mbps
! 
literal NMA$C_LINETR_ENA = 0;           !  Enabled
literal NMA$C_LINETR_DIS = 1;           !  Disabled
! 
literal NMA$C_LINSRC_ENA = 0;           !  Enabled
literal NMA$C_LINSRC_DIS = 1;           !  Disabled
! 
literal NMA$C_MEDIA_STP = 0;            !  STP
literal NMA$C_MEDIA_UTP = 1;            !  UTP
literal NMA$C_MEDIA_AUI = 2;            !  AUI
literal NMA$C_MEDIA_TP = 3;             !  TP
literal NMA$C_MEDIA_AUTO = 4;           !  Auto-sense
literal NMA$C_MEDIA_UNSPECIFIED = 5;    !  Unspecified
literal NMA$C_MEDIA_ANY = 65535;        !  Any
! 	
literal NMA$C_LINHNG_DIS = 1;           !  Hangup disabled
literal NMA$C_LINHNG_ENA = 0;           !  Hangup enabled
! 	
literal NMA$C_LINRES_DIS = 1;           !  Restart disabled
literal NMA$C_LINRES_ENA = 0;           !  Restart enabled
! 
literal NMA$C_LINTY_POI = 0;            !  DDCMP Point 
literal NMA$C_LINTY_CON = 1;            !  DDCMP Controller 
literal NMA$C_LINTY_TRI = 2;            !  DDCMP Tributary 
literal NMA$C_LINTY_DMC = 3;            !  DDCMP DMC compatibility mode (DMP) 
! 
literal NMA$C_LINMC_SET = 1;            !  Set address(es) 
literal NMA$C_LINMC_CLR = 2;            !  Clear address(es) 
literal NMA$C_LINMC_CAL = 3;            !  Clear entire list of multicast addresses 
literal NMA$C_LINMC_SDF = 4;            !  Set physical address to DECnet default 
! 
literal NMA$C_LINDAT_UNK = 0;           !  Unknown
literal NMA$C_LINDAT_SUC = 1;           !  Success
literal NMA$C_LINDAT_DUP = 2;           !  Duplicate
! 
literal NMA$C_LINUN_DAT_UNK = 0;        !  Unknown
literal NMA$C_LINUN_DAT_SUC = 1;        !  Success
literal NMA$C_LINUN_DAT_DUP = 2;        !  Duplicate
! 
literal NMA$C_LINRPS_OFF = 0;           !  Off
literal NMA$C_LINRPS_CAN = 1;           !  Candidate
literal NMA$C_LINRPS_NON = 2;           !  Non-purger
literal NMA$C_LINRPS_PUR = 3;           !  Purger
! 
literal NMA$C_LINRER_NOE = 0;           !  No error
literal NMA$C_LINRER_RII = 5;           !  Ring init initiated
literal NMA$C_LINRER_RIR = 6;           !  Ring init received
literal NMA$C_LINRER_RBI = 7;           !  Ring beaconing initiated
literal NMA$C_LINRER_DAD = 8;           !  Duplicate address detected
literal NMA$C_LINRER_DTD = 9;           !  Duplicate token detected
literal NMA$C_LINRER_RPE = 10;          !  Ring purge error
literal NMA$C_LINRER_FSE = 11;          !  FCI strip error
literal NMA$C_LINRER_ROC = 12;          !  Ring OP oscillation
literal NMA$C_LINRER_DBR = 13;          !  Directed beacon received
literal NMA$C_LINRER_PCTI = 14;         !  PC trace initiated
literal NMA$C_LINRER_PCTR = 15;         !  PC trace received
! 
literal NMA$C_LINNBR_PHY_A = 0;         !  A
literal NMA$C_LINNBR_PHY_B = 1;         !  B
literal NMA$C_LINNBR_PHY_S = 2;         !  S
literal NMA$C_LINNBR_PHY_M = 3;         !  M
literal NMA$C_LINNBR_PHY_U = 4;         !  Unknown
! 
literal NMA$C_LINRJR_NON = 0;           !  None
literal NMA$C_LINRJR_LLCT = 1;          !  Local LCT
literal NMA$C_LINRJR_RLCT = 2;          !  Remote LCT
literal NMA$C_LINRJR_LCTB = 3;          !  LCT both sides
literal NMA$C_LINRJR_LEM = 4;           !  LEM reject
literal NMA$C_LINRJR_TOP = 5;           !  Topology error
literal NMA$C_LINRJR_NRJ = 6;           !  Noise reject 
literal NMA$C_LINRJR_RRJ = 7;           !  Remote reject
literal NMA$C_LINRJR_TIP = 8;           !  Trace in progress
literal NMA$C_LINRJR_TRD = 9;           !  Trace received-disabled
literal NMA$C_LINRJR_STA = 10;          !  Standby
literal NMA$C_LINRJR_LCTE = 11;         !  LCT protocol error
! 
literal NMA$C_ACC_SHR = 1;              !  Shared access (default protocol user)
literal NMA$C_ACC_LIM = 2;              !  Limited access (point-to-point conn.)
literal NMA$C_ACC_EXC = 3;              !  Exclusive access (allow no others)
literal NMA$C_ACC_SEL = 4;              !  Selective access (source address filtering)
! 
literal NMA$C_LINMO_AUT = 1;            !  Auto address mode 
literal NMA$C_LINMO_SIL = 2;            !  Silo address mode 
! 
literal NMA$C_X25MD_DTE = 1;            !  line operates as DTE 
literal NMA$C_X25MD_DCE = 2;            !  line operates as DCE 
literal NMA$C_X25MD_DTL = 3;            !  line is a DTE in loopback 
literal NMA$C_X25MD_DCL = 4;            !  line is a DCE in loopback 
literal nma$c_x25md_neg = 5;            !  line negotiates mode of operation
! 
literal nma$c_x25red_busy = 0;          !  redirected beacuse DTE was Busy
literal nma$c_x25red_out_of_order = 1;  !  redirected beacuse DTE was out of order
literal nma$c_x25red_systematic = 2;    !  redirected systematically
! 
literal NMA$C_NODTY_ROU = 0;            !  Routing Phase III 
literal NMA$C_NODTY_NON = 1;            !  Nonrouting Phase III 
literal NMA$C_NODTY_PHA = 2;            !  Phase II 
literal NMA$C_NODTY_AREA = 3;           !  Area 
literal NMA$C_NODTY_RT4 = 4;            !  Routing Phase IV 
literal NMA$C_NODTY_NR4 = 5;            !  Nonrouting Phase IV 
literal NMA$C_NODTY_AREAP = 6;          !  Area Phase IV'
literal NMA$C_NODTY_RT4P = 7;           !  Routing Phase IV' 
literal NMA$C_NODTY_NR4P = 8;           !  Nonrouting Phase IV' 
! 
literal NMA$C_NODINB_ROUT = 1;          !  Router
literal NMA$C_NODINB_ENDN = 2;          !  Endnode
! 
literal NMA$C_NODPW_SET = 0;            !  Password set 
! 
literal NMA$C_CPU_8 = 0;                !  PDP-8 processor 
literal NMA$C_CPU_11 = 1;               !  PDP-11 processor 
literal NMA$C_CPU_1020 = 2;             !  Decsystem 10/20 processor 
literal NMA$C_CPU_VAX = 3;              !  Vax processor 
! 
literal NMA$C_NODSNV_PH3 = 0;           !  Phase III 
literal NMA$C_NODSNV_PH4 = 1;           !  Phase IV 
! 
literal NMA$C_SOFT_SECL = 0;            !  Secondary loader 
literal NMA$C_SOFT_TERL = 1;            !  Tertiary loader 
literal NMA$C_SOFT_OSYS = 2;            !  Operating system 
literal NMA$C_SOFT_DIAG = 3;            !  Diagnostics 
! 
literal NMA$C_ACES_NONE = 0;            !  None 
literal NMA$C_ACES_INCO = 1;            !  Incoming 
literal NMA$C_ACES_OUTG = 2;            !  Outgoing 
literal NMA$C_ACES_BOTH = 3;            !  Both 
literal NMA$C_ACES_REQU = 4;            !  Required 
! 
literal NMA$C_ALIINC_ENA = 0;           !  Enabled
literal NMA$C_ALIINC_DIS = 1;           !  Disabled
! 
literal NMA$C_ALOUT_ENA = 0;            !  Enabled
literal NMA$C_ALOUT_DIS = 1;            !  Disabled
! 
literal NMA$C_ALINC_ENA = 0;            !  Enabled
literal NMA$C_ALINC_DIS = 1;            !  Disabled
! 
literal NMA$C_PRXY_ENA = 0;             !  Enabled
literal NMA$C_PRXY_DIS = 1;             !  Disabled
! 
literal NMA$C_PSPCY_NOR = 0;            !  Normal
literal NMA$C_PSPCY_INT = 1;            !  Interim
! 
literal NMA$C_XPRTY_BIL = 1;            !  Bilateral 
! 
literal NMA$C_XPRST_ON = 0;             !  On 
literal NMA$C_XPRST_OFF = 1;            !  Off 
literal NMA$C_XPRST_SHU = 2;            !  Shut 
! 
literal NMA$C_XPRMN_ENA = 0;            !  Enabled 
literal NMA$C_XPRMN_DIS = 1;            !  Disabled 
! 
literal NMA$C_XPRSB_RUN = 12;           !  Running 
literal NMA$C_XPRSB_UNS = 13;           !  Unsynchronized 
literal NMA$C_XPRSB_SYN = 10;           !  Synchronizing 
! 
literal NMA$C_Clear_String = 0;         ! Clear string value
literal NMA$C_Clear_Longword = -1;      ! Clear longword value
literal NMA$C_CAL_CLR = 0;              ! Call clear
literal NMA$C_CAL_NOW = 1;              ! Call now
literal NMA$C_DAY_ALL = 0;
literal NMA$C_DAY_MON = 1;
literal NMA$C_DAY_TUE = 2;
literal NMA$C_DAY_WED = 3;
literal NMA$C_DAY_THU = 4;
literal NMA$C_DAY_FRI = 5;
literal NMA$C_DAY_SAT = 6;
literal NMA$C_DAY_SUN = 7;
literal NMA$C_TIC_No_Cut = 0;           ! Inhibit timecutting
literal NMA$C_TIC_Cut = 1;              ! Perform Timecutting
literal NMA$C_CSG_No_Signal = 0;        ! Inhibit call-signal data
literal NMA$c_CSG_Signal = 1;           ! Send call-signal data
literal NMA$c_IRC_DIS = 0;              ! Incoming Reverse Disable
literal NMA$c_IRC_ENA = 1;              ! Incoming Reverse Enable
literal NMA$c_ORC_DIS = 0;              ! Outgoing Reverse Enable
literal NMA$c_ORC_ENA = 1;              ! Outgoing Reverse Disable
literal NMA$c_RED_DIS = 0;              ! Redirect Enable
literal NMA$c_RED_ENA = 1;              ! Redirect Disable
literal NMA$c_MOD_NOAUTO = 0;           ! Mode AUTO time-cutting
literal NMA$c_MOD_AUTO = 1;             ! Mode non-auto time-cutting
literal NMA$c_SWC_DIS = 0;              ! Enable switched mode
literal NMA$c_SWC_ENA = 1;              ! Set line for Leased operation
literal NMA$c_MDM_OFF = 0;              ! Enable modem signals
literal NMA$c_MDM_ON = 1;               ! Disable modem signals
literal NMA$c_DTS_NO_CABLE = 1;         ! DTE does not have X21 cable
literal NMA$c_DTS_NO_X21_CABLE = 2;     ! DTE has none-X21 cable.
literal NMA$c_DTS_READY = 3;            ! DCE is not ready
literal NMA$c_DTS_NOT_READY = 4;        ! DTE is signalling Not-Ready to network.
literal NMA$c_DTS_ACTIVE = 5;           ! DTE in normal working mode.
literal NMA$c_DTS_NO_OUTGOING = 6;      ! Outgoing calls prohibitedin normal working mode.
literal NMA$c_CAS_NONE = 1;             ! Call-Status - No call active
literal NMA$c_CAS_OUT = 2;              ! Outgoing call active
literal NMA$c_CAS_IN = 3;               ! Incoming call active
literal NMA$c_CAS_OUT_R = 4;            ! Outgoing reverse active
literal NMA$c_CAS_IN_R = 5;             ! Incoming reverse active
literal NMA$c_DTL_ACCEPT = 1;           ! Accept call from
literal NMA$c_DTL_REJECT = 2;           ! Reject call from
literal NMA$C_CAC_MAN = 1;              ! X21 controls connect/accept
literal NMA$C_CAC_AUTO_CONNECT = 2;     ! Driver connects automatically
literal NMA$C_CAC_AUTO_ACCEPT = 3;      ! Enhanced subaddressing
! 
literal NMA$C_JAN = 1;
literal NMA$C_FEB = 2;
literal NMA$C_MAR = 3;
literal NMA$C_APR = 4;
literal NMA$C_MAY = 5;
literal NMA$C_JUN = 6;
literal NMA$C_JUL = 7;
literal NMA$C_AUG = 8;
literal NMA$C_SEP = 9;
literal NMA$C_OCT = 10;
literal NMA$C_NOV = 11;
literal NMA$C_DEC = 12;
! 
literal NMA$C_SOFD_DP = 0;              !  DP11-DA (OBSOLETE)
literal NMA$C_SOFD_UNA = 1;             !  DEUNA UNIBUS CSMA/CD communication link
literal NMA$C_SOFD_DU = 2;              !  DU11-DA synchronous line interface
literal NMA$C_SOFD_CNA = 3;             !  DECNA CSMA/CD communication link
literal NMA$C_SOFD_DL = 4;              !  DL11-C, -E, or -WA synchronous line interface
literal NMA$C_SOFD_QNA = 5;             !  DEQNA CSMA/CD communication link
literal NMA$C_SOFD_DQ = 6;              !  DQ11-DA (OBSOLETE)
literal NMA$C_SOFD_CI = 7;              !  Computer Interconnect Interface
literal NMA$C_SOFD_DA = 8;              !  DA11-B or -AL UNIBUS link
literal NMA$C_SOFD_PCL = 9;             !  PCL11-B multiple CPU link
literal NMA$C_SOFD_DUP = 10;            !  DUP11-DA synchronous line interface
literal NMA$C_SOFD_LUA = 11;            !  DELUA CSMA/CD communication link
literal NMA$C_SOFD_DMC = 12;            !  DMC11-DA/AR, -FA/AR, -MA/AL or -MD/AL interprocessor link
literal NMA$C_SOFD_LNA = 13;            !  MicroServer Lance CSMA/CD communication link
literal NMA$C_SOFD_DN = 14;             !  DN11-BA or -AA automatic calling unit
literal NMA$C_SOFD_DLV = 16;            !  DLV11-E, -F, -J, MXV11-A or -B asynchronous line
literal NMA$C_SOFD_LCS = 17;            !  Lance/Decserver 100 CSMA/CD communication link
literal NMA$C_SOFD_DMP = 18;            !  DMP11 multipoint interprocessor link
literal NMA$C_SOFD_AMB = 19;            !  AMBER (OBSOLETE)
literal NMA$C_SOFD_DTE = 20;            !  DTE20 PDP-11 to KL10 interface
literal NMA$C_SOFD_DBT = 21;            !  DEBET CSMA/CD communication link
literal NMA$C_SOFD_DV = 22;             !  DV11-AA/BA synchronous line multiplexer
literal NMA$C_SOFD_BNA = 23;            !  DEBNA BI CSMA/CD communication link
literal NMA$C_SOFD_BNT = 23;            !  DEBNT **obsolete**
literal NMA$C_SOFD_DZ = 24;             !  DZ11-A, -B, -C, -D asynchronous line multiplexer
literal NMA$C_SOFD_LPC = 25;            !  LANCE/PCXX CSMA/CD communication link
literal NMA$C_SOFD_DSV = 26;            !  DSV11 Q-bus synchronous link
literal NMA$C_SOFD_CEC = 27;            !  3-COM/IBM-PC CSMA/CD communication link
literal NMA$C_SOFD_KDP = 28;            !  KMC11/DUP11-DA synchronous line multiplexer
literal NMA$C_SOFD_IEC = 29;            !  Interlan/IBM-PC CSMA/CD communication link
literal NMA$C_SOFD_KDZ = 30;            !  KMC11/DZ11-A, -B, -C, or -D asynchronous line multiplexer
literal NMA$C_SOFD_UEC = 31;            !  Univation/RAINBOW-100 CSMA/CD communication link
literal NMA$C_SOFD_KL8 = 32;            !  KL8-J (OBSOLETE)
literal NMA$C_SOFD_DS2 = 33;            !  LANCE/DECserver 200 CSMA/CD communication link
literal NMA$C_SOFD_DMV = 34;            !  DMV11 interprocessor link 
literal NMA$C_SOFD_DS5 = 35;            !  DECserver 500 CSMA/CD communication link
literal NMA$C_SOFD_DPV = 36;            !  DPV11 synchronous line interface
literal NMA$C_SOFD_LQA = 37;            !  DELQA CSMA/CD communication link
literal NMA$C_SOFD_DMF = 38;            !  DMF32 synchronous line unit
literal NMA$C_SOFD_SVA = 39;            !  DESVA CSMA/CD communication link
literal NMA$C_SOFD_DMR = 40;            !  DMR11-AA, -AB, -AC, or -AE interprocessor link
literal NMA$C_SOFD_MUX = 41;            !  MUXserver 100 CSMA/CD communication link
literal NMA$C_SOFD_KMY = 42;            !  KMS11-PX synchronous line interface with X.25 Level 2 microcode
literal NMA$C_SOFD_DEP = 43;            !  DEPCA PCSG/IBM-PC CSMA/CD communication link
literal NMA$C_SOFD_KMX = 44;            !  KMS11-BD/BE synchronous line interface with X.25 Level 2 microcode
literal NMA$C_SOFD_LTM = 45;            !  LTM (911) Ethernet monitor
literal NMA$C_SOFD_DMB = 46;            !  DMB-32 BI synchronous line multiplexer
literal NMA$C_SOFD_DES = 47;            !  DESNC Ethernet Encryption Module
literal NMA$C_SOFD_KCP = 48;            !  KCP synchronous/asynchronous line
literal NMA$C_SOFD_MX3 = 49;            !  MUXServer 300 CSMA/CD communication link 
literal NMA$C_SOFD_SYN = 50;            !  MicroServer synchronous line interface
literal NMA$C_SOFD_MEB = 51;            !  DEMEB multiport bridge CSMA/CD communication link 
literal NMA$C_SOFD_DSB = 52;            !  DSB32 BI synchronous line interface
literal NMA$C_SOFD_BAM = 53;            !  DEBAM LANBridge-200 Data Link 
literal NMA$C_SOFD_DST = 54;            !  DST-32 TEAMmate synchronous line interface (DEC423)
literal NMA$C_SOFD_FAT = 55;            !  DEFAT DataKit Server CSMA/CD communication link 
literal NMA$C_SOFD_RSM = 56;            !  DERSM - Remote Segment Monitor 
literal NMA$C_SOFD_RES = 57;            !  DERES - Remote Environmental Sensor 
literal NMA$C_SOFD_3C2 = 58;            !  3COM Etherlink II (part number 3C503) 
literal NMA$C_SOFD_3CM = 59;            !  3COM Etherlink/MC (part number 3C523) 
literal NMA$C_SOFD_DS3 = 60;            !  DECServer 300 CSMA/CD communication link 
literal NMA$C_SOFD_MF2 = 61;            !  Mayfair-2 CSMA/CD communication link 
literal NMA$C_SOFD_MMR = 62;            !  DEMMR Ethernet Multiport Manageable Repeater 
literal NMA$C_SOFD_VIT = 63;            !  Vitalink TransLAN III/IV (NP3A) Bridge 
literal NMA$C_SOFD_VT5 = 64;            !  Vitalink TransLAN 350 (NPC25) Bridge 
literal NMA$C_SOFD_BNI = 65;            !  DEBNI BI CSMA/CD communication link 
literal NMA$C_SOFD_MNA = 66;            !  DEMNA XMI CSMA/CD communication link 
literal NMA$C_SOFD_PMX = 67;            !  PMAX (KN01) CSMA/CD communication link 
literal NMA$C_SOFD_NI5 = 68;            !  Interlan NI5210-8 CSMA/CD comm link for IBM PC XT/AT 
literal NMA$C_SOFD_NI9 = 69;            !  Interlan NI9210 CSMA/CD comm link for IBM PS/2 
literal NMA$C_SOFD_KMK = 70;            !  KMS11-K DataKit UNIBUS adapter 
literal NMA$C_SOFD_3CP = 71;            !  Etherlink Plus (part number 3C505) 
literal NMA$C_SOFD_DP2 = 72;            !  DPNserver-200 CSMA/CD communication link 
literal NMA$C_SOFD_ISA = 73;            !  SGEC CSMA/CD communication link 
literal NMA$C_SOFD_DIV = 74;            !  DIV-32 DEC WAN controller-100
literal NMA$C_SOFD_QTA = 75;            !  DEQTA CSMA/CD communication link
literal NMA$C_SOFD_B15 = 76;            !  LANbridge-150 CSMA/CD communication link
literal NMA$C_SOFD_WD8 = 77;            !  WD8003 Family CSMA/CD communication link
literal NMA$C_SOFD_ILA = 78;            !  BICC ISOLAN 4110-2 PC/AT CSMA/CD communication link
literal NMA$C_SOFD_ILM = 79;            !  BICC ISOLAN 4110-3 PC MicroChannel CSMA/CD comm link
literal NMA$C_SOFD_APR = 80;            !  Apricot Xen-S and Qi CSMA/CD adapter
literal NMA$C_SOFD_ASN = 81;            !  AST EtherNode CSMA/CD communication link
literal NMA$C_SOFD_ASE = 82;            !  AST Ethernet CSMA/CD communication link
literal NMA$C_SOFD_TRW = 83;            !  TRW HC-2001 CSMA/CD communication link
literal NMA$C_SOFD_EDX = 84;            !  Ethernet-XT/AT CSMA/CD communication link
literal NMA$C_SOFD_EDA = 85;            !  Ethernet-AT CSMA/CD communication link
literal NMA$C_SOFD_DR2 = 86;            !  DECrouter-250 CSMA/CD communication link
literal NMA$C_SOFD_SCC = 87;            !  DECrouter-250 DUSCC serial comm link (DDCMP or HDLC)
literal NMA$C_SOFD_DCA = 88;            !  DCA Series 300 Net Processor CSMA/CD communication link
literal NMA$C_SOFD_TIA = 89;            !  LANcard/E CSMA/CD controllers
literal NMA$C_SOFD_FBN = 90;            !  DEFEB DECbridge-500 CSMA/CD communication link
literal NMA$C_SOFD_FEB = 91;            !  DEFEB DECbridge-500 FDDI communication link
literal NMA$C_SOFD_FCN = 92;            !  DEFCN DECconcentrator-500 wiring concentrator FDDI comm link
literal NMA$C_SOFD_MFA = 93;            !  DEMFA FDDI communication link
literal NMA$C_SOFD_MXE = 94;            !  MIPS workstation family CSMA/CD communication links
literal NMA$C_SOFD_CED = 95;            !  Cabletron Ethernet Desktop Network Interface CSMA/CD comm link
literal NMA$C_SOFD_C20 = 96;            !  3Com CS/200 terminal server CSMA/CD comm link
literal NMA$C_SOFD_CS1 = 97;            !  3Com CS/1 terminal server CSMA/CD comm link
literal NMA$C_SOFD_C2M = 98;            !  3Com CS/210, CS/2000, CS/2100 terminal server CSMA/CD comm link
literal NMA$C_SOFD_ACA = 99;            !  ACA/32000 system CSMA/CD comm link
literal NMA$C_SOFD_GSM = 100;           !  Gandalf StarMaster CSMA/CD comm link
literal NMA$C_SOFD_DSF = 101;           !  DSF32 2 line sync comm link for Cirrus
literal NMA$C_SOFD_CS5 = 102;           !  3Com CS/50 terminal server CSMA/CD comm link
literal NMA$C_SOFD_XIR = 103;           !  XIRCOM PE10B2 CSMA/CD comm link
literal NMA$C_SOFD_KFE = 104;           !  KFE52 CSMA/CD comm link for Cirrus
literal NMA$C_SOFD_RT3 = 105;           !  rtVAX-300 SGEC-based CSMA/CD comm link
literal NMA$C_SOFD_SPI = 106;           !  Spiderport M250 terminal server CSMA/CD comm link
literal NMA$C_SOFD_FOR = 107;           !  LAT gateway CSMA/CD comm link
literal NMA$C_SOFD_MER = 108;           !  Meridian CSMA/CD comm link drivers
literal NMA$C_SOFD_PER = 109;           !  Persoft CSMA/CD comm link drivers
literal NMA$C_SOFD_STR = 110;           !  AT&T StarLan-10 twisted pair comm link
literal NMA$C_SOFD_MPS = 111;           !  MIPSfair SGEC CSMA/CD comm link
literal NMA$C_SOFD_L20 = 112;           !  LPS20 print server CSMA/CD comm link
literal NMA$C_SOFD_VT2 = 113;           !  Vitalink TransLAN 320 Bridge
literal NMA$C_SOFD_DWT = 114;           !  VT-1000 DECwindows terminal
literal NMA$C_SOFD_WGB = 115;           !  DEWGB Work Group Bridge CSMA/CD comm link
literal NMA$C_SOFD_ZEN = 116;           !  Zenith Z-LAN4000 XT, AT and MicroChannel Z-LAN comm link
literal NMA$C_SOFD_TSS = 117;           !  Thursby Software Systems CSMA/CD comm link drivers
literal NMA$C_SOFD_MNE = 118;           !  3MIN (KN02-BA) integral CSMA/CD comm link
literal NMA$C_SOFD_FZA = 119;           !  DEFZA TurboChannel FDDI comm link
literal NMA$C_SOFD_90L = 120;           !  DS90L terminal server CSMA/CD comm link
literal NMA$C_SOFD_CIS = 121;           !  Cisco Systems terminal servers CSMA/CD comm link
literal NMA$C_SOFD_STC = 122;           !  STRTC terminal servers
literal NMA$C_SOFD_UBE = 123;           !  Ungermann-Bass PC2030, PC3030 CSMA/CD comm link
literal NMA$C_SOFD_DW2 = 124;           !  DECwindows terminal II CSMA/CD comm link
literal NMA$C_SOFD_FUE = 125;           !  Fujitsu Etherstar MB86950 CSMA/CD comm link
literal NMA$C_SOFD_M38 = 126;           !  MUXServer 380 CSMA/CD comm link
literal NMA$C_SOFD_NTI = 127;           !  NTI Group PC Ethernet Card CSMA/CD comm link
literal NMA$C_SOFD_RAD = 130;           !  RADLINX LAN Gateway CSMA/CD comm link
literal NMA$C_SOFD_INF = 131;           !  Infotron Commix series terminal server CSMA/CD comm link
literal NMA$C_SOFD_XMX = 132;           !  Xyplex MAXserver series terminal server CSMA/CD comm link
literal NMA$C_SOFD_NDI = 133;           !  NDIS data link driver for MS/DOS systems CSMA/CD comm link
literal NMA$C_SOFD_ND2 = 134;           !  NDIS data link driver for OS/2 systems CSMA/CD comm link
literal NMA$C_SOFD_TRN = 135;           !  DEC LANcontroller 520 Token Ring comm link 
literal NMA$C_SOFD_DEV = 136;           !  Develcon Electronics Ltd. LAT gateway CSMA/CD comm link
literal NMA$C_SOFD_ACE = 137;           !  Acer 5220, 5270 adapter CSMA/CD comm link
literal NMA$C_SOFD_PNT = 138;           !  ProNet-4/18 #1390 802.5 comm link
literal NMA$C_SOFD_ISE = 139;           !  Network Integration Server 600 CSMA/CD line card
literal NMA$C_SOFD_IST = 140;           !  Network Integration Server 600 T1 sync line card
literal NMA$C_SOFD_ISH = 141;           !  Network Integration Server 64 kb HDLC line card
literal NMA$C_SOFD_ISF = 142;           !  Network Integration Server 600 FDDI line card
literal NMA$C_SOFD_DSW = 149;           !  DSW-21 single line serial comm link
literal NMA$C_SOFD_DW4 = 150;           !  DSW-41/42 single/dual line serial comm link
literal NMA$C_SOFD_FAA = 161;           !  Futurebus FDDI
literal NMA$C_SOFD_FEA = 162;           !  EISAbus FDDI
literal NMA$C_SOFD_TRA = 175;           !  DETRA-AA Turbochannel 802.5 token ring comm link
literal NMA$C_SOFD_ERA = 182;           !  DE422 EISA-bus PC CSMA/CD comm link
literal NMA$C_SOFD_TRE = 189;           !  DW300 EISA Token Ring
literal NMA$C_SOFD_ETA = 202;           !  TULIP EISA bus CSMA/CD adapter
literal NMA$C_SOFD_EWA = 203;           !  TULIP PCI bus FDDI adapter
literal NMA$C_SOFD_FWA = 204;           !  FOCUS PCI bus FDDI adapter
literal NMA$C_SOFD_AZA = 213;           !  OTTO Turbochannel ATM adapter
literal NMA$C_SOFD_FPA = 216;           !  DEFPA PCI bus FDDI adapter
literal NMA$C_SOFD_ANA = 253;           !  Futurebus CSMA/CD
! 
literal NMA$_SUCCESS = 1;               !  Unqualified success 
literal NMA$_SUCCFLDRPL = 9;            !  Success with field replaced 
literal NMA$_BADFID = 0;                !  Invalid field id code 
literal NMA$_BADDAT = 8;                !  Invalid data format 
literal NMA$_BADOPR = 16;               !  Invalid operation 
literal NMA$_BUFTOOSMALL = 24;          !  Buffer too small 
literal NMA$_FLDNOTFND = 32;            !  Field not found 
! 
literal NMA$C_OPN_MIN = 0;              !  Minimum ! 
literal NMA$C_OPN_NODE = 0;             !  Nodes 
literal NMA$C_OPN_LINE = 1;             !  Lines 
literal NMA$C_OPN_LOG = 2;              !  Logging 
literal NMA$C_OPN_OBJ = 3;              !  Object 
literal NMA$C_OPN_CIR = 4;              !  Circuit 
literal NMA$C_OPN_X25 = 5;              !  Module X25 
literal NMA$C_OPN_X29 = 6;              !  Module X29 
literal NMA$C_OPN_CNF = 7;              !  Module Configurator 
literal NMA$C_OPN_MAX = 7;              !  Maximum ! permanent database files 
literal NMA$C_OPN_ALL = 127;            !  All opened files 
! 
literal NMA$C_OPN_AC_RO = 0;            !  Read Only 
literal NMA$C_OPN_AC_RW = 1;            !  Read write 
! 
literal NMA$C_FN2_DLL = 2;              !  Down line load 
literal NMA$C_FN2_ULD = 3;              !  Upline Dump 
literal NMA$C_FN2_TRI = 4;              !  Trigger remote bootstrap 
literal NMA$C_FN2_LOO = 5;              !  Loop back test 
literal NMA$C_FN2_TES = 6;              !  Send test message to be looped 
literal NMA$C_FN2_SET = 7;              !  Set parameter 
literal NMA$C_FN2_REA = 8;              !  Read Parameter 
literal NMA$C_FN2_ZER = 9;              !  Zero counters 
literal NMA$C_FN2_LNS = 14;             !  Line service 
! 
literal NMA$C_OP2_CHNST = 5;            !  Node operational status 
literal NMA$C_OP2_CHLST = 8;            !  Line operational status 
! 
literal NMA$C_OP2_RENCT = 0;            !  Local node counters 
literal NMA$C_OP2_RENST = 1;            !  local node status 
literal NMA$C_OP2_RELCT = 4;            !  Line counters 
literal NMA$C_OP2_RELST = 5;            !  Line status 
! 
literal NMA$C_OP2_ZENCT = 0;            !  Local Node counters 
literal NMA$C_OP2_ZELCT = 2;            !  Line counters 
! 
literal NMA$C_EN2_KNO = 0;              !  Known lines 
literal NMA$C_EN2_LID = 1;              !  Line id 
literal NMA$C_EN2_LCN = 2;              !  Line convenience name 
! 
literal NMA$C_STS_SUC = 1;              !  Success 
literal NMA$C_STS_MOR = 2;              !  Request accepted, more to come 
literal NMA$C_STS_PAR = 3;              !  Partial reply 
! 
literal NMA$C_STS_DON = -128;           !  Done 
! 
literal NMA$C_STS_FUN = -1;             !  Unrecognized function or option 
literal NMA$C_STS_INV = -2;             !  Invalid message format 
literal NMA$C_STS_PRI = -3;             !  Privilege violation 
literal NMA$C_STS_SIZ = -4;             !  Oversized management command message 
literal NMA$C_STS_MPR = -5;             !  Network management program error 
literal NMA$C_STS_PTY = -6;             !  Unrecognized parameter type 
literal NMA$C_STS_MVE = -7;             !  Incompatible management version 
literal NMA$C_STS_CMP = -8;             !  Unrecognised component 
literal NMA$C_STS_IDE = -9;             !  Invalid identification format 
literal NMA$C_STS_LCO = -10;            !  Line communication error 
literal NMA$C_STS_STA = -11;            !  Component in wrong state 
literal NMA$C_STS_FOP = -13;            !  File open error 
literal NMA$C_STS_FCO = -14;            !  Invalid file contents 
literal NMA$C_STS_RES = -15;            !  Resource error 
literal NMA$C_STS_PVA = -16;            !  Invalid parameter value 
literal NMA$C_STS_LPR = -17;            !  Line protocol error 
literal NMA$C_STS_FIO = -18;            !  File i/o error 
literal NMA$C_STS_MLD = -19;            !  Mirror link disconnected 
literal NMA$C_STS_ROO = -20;            !  No room for new entry 
literal NMA$C_STS_MCF = -21;            !  Mirror connect failed 
literal NMA$C_STS_PNA = -22;            !  Parameter not applicable 
literal NMA$C_STS_PLO = -23;            !  Parameter value too long 
literal NMA$C_STS_HAR = -24;            !  Hardware failure 
literal NMA$C_STS_OPE = -25;            !  Operation failure 
literal NMA$C_STS_SYS = -26;            !  System-specific management 
!  function not supported
literal NMA$C_STS_PGP = -27;            !  Invalid parameter grouping 
literal NMA$C_STS_BLR = -28;            !  Bad loopback response 
literal NMA$C_STS_PMS = -29;            !  Parameter missing 
! 
literal NMA$C_STS_ALI = -127;           !  Invalid alias identification 
literal NMA$C_STS_OBJ = -126;           !  Invalid object identification 
literal NMA$C_STS_PRO = -125;           !  Invalid process identification 
literal NMA$C_STS_LNK = -124;           !  Invalid link identification 
! 
literal NMA$C_FOPDTL_PDB = 0;           !  Permanent database 
literal NMA$C_FOPDTL_LFL = 1;           !  Load file 
literal NMA$C_FOPDTL_DFL = 2;           !  Dump file 
literal NMA$C_FOPDTL_SLF = 3;           !  Secondary loader 
literal NMA$C_FOPDTL_TLF = 4;           !  Tertiary loader 
literal NMA$C_FOPDTL_SDF = 5;           !  Secondary dumper 
literal NMA$C_FOPDTL_PDR = 6;           !  Permanent Database,on remote node
literal NMA$C_FOPDTL_MFL = 7;           !  Management file
! 
literal NMA$C_NCEDTL_NNA = 0;           !  No node name set 
literal NMA$C_NCEDTL_INN = 1;           !  Invalid node name format 
literal NMA$C_NCEDTL_UNA = 2;           !  Unrecognised node name 
literal NMA$C_NCEDTL_UNR = 3;           !  Node unreachable 
literal NMA$C_NCEDTL_RSC = 4;           !  Network resources 
literal NMA$C_NCEDTL_RJC = 5;           !  Rejected by object 
literal NMA$C_NCEDTL_ONA = 6;           !  Invalid object name format 
literal NMA$C_NCEDTL_OBJ = 7;           !  Unrecognised object 
literal NMA$C_NCEDTL_ACC = 8;           !  Access control rejected 
literal NMA$C_NCEDTL_BSY = 9;           !  Object too busy 
literal NMA$C_NCEDTL_NRS = 10;          !  No response from object 
literal NMA$C_NCEDTL_NSD = 11;          !  Node shut down 
literal NMA$C_NCEDTL_DIE = 12;          !  Node or object failed 
literal NMA$C_NCEDTL_DIS = 13;          !  Disconnect by object 
literal NMA$C_NCEDTL_ABO = 14;          !  Abort by object 
literal NMA$C_NCEDTL_ABM = 15;          !  Abort by management 
! 
literal NMA$C_OPEDTL_DCH = 0;           ! 	Data check
literal NMA$C_OPEDTL_TIM = 1;           ! 	Timeout
literal NMA$C_OPEDTL_ORN = 2;           ! 	Data overrun
literal NMA$C_OPEDTL_ACT = 3;           ! 	Unit is active
literal NMA$C_OPEDTL_BAF = 4;           ! 	Buffer allocation failure
literal NMA$C_OPEDTL_RUN = 5;           ! 	Protocol running
literal NMA$C_OPEDTL_DSC = 6;           ! 	Line disconnected
literal NMA$C_OPEDTL_FTL = 8;           ! 	Fatal hardware error
literal NMA$C_OPEDTL_MNT = 11;          ! 	DDCMP maintainance message received
literal NMA$C_OPEDTL_LST = 12;          ! 	Data lost due to buffer size mismatch
literal NMA$C_OPEDTL_THR = 13;          ! 	Threshold error
literal NMA$C_OPEDTL_TRB = 14;          ! 	Tributary malfunction
literal NMA$C_OPEDTL_STA = 15;          ! 	DDCMP start message received
literal NMA$S_NMADEF7 = 1;              !  Old size name - synonym	
literal NMA$S_NMA7 = 1;
macro NMA$V_CTLIN_TUN = 0,2,1,0 %;      !  transmit underrun 
macro NMA$V_CTLIN_RUN = 0,4,1,0 %;      !  receive underrun 
macro NMA$V_CTLIN_FMR = 0,5,1,0 %;      !  FRMR received 
! 
!  VMS-specific line counters
! 
!         1  Message rejected
!         2  Message truncated
!         3  Receiver offline
!         4  Receiver busy
!         5  Transmitter offline
!         1  CRC error on transmit
!         2  CRC error on receive
!         3  Timeouts
!         4  Non-existant memory transmit
!         5  Non-existant memory receive
!         6  Buffer to small
!         7  Failed to open channel
!         8  Memory overflow
!         2  Now master
! 
!     Node counters
! 
!  Server Base Specific Executor Node Counters
! 
!         X.25 Protocol module counters
! 
!         X.25 Server module counters
! 
!         Coded parameter values
! 
! 
!  Loop test block type coded values
! 
!  Default values for loop functions
! 
!  Values for LOOP HELP
! 
!  State coded values
! 
!     DNS interface
! 
!     circuit/line/process specific state values
! 
!     logging specific state values
! 
!     node specific state values
! 
! 	
! 	Default value for EXECUTOR MAXIMUM ADDRESS.
! 	Note: DNA Network Management does not specify a default.
! 	      This is defined for VMS only, for compatibility with
! 	      previous releases that used a hard coded value in
! 	      [NETACP.SRC]NETCONFIG.MAR.
! 
! 
! 
!  Looper/loader assistance coded values
! 
!  Configurator surveillance coded values
! 
!  Circuit/Line substate coded values
! 
!  Circuit type coded values   [In V2, line type coded values]
! 
!         Circuit/Line Service
! 
!  Circuit polling state
! 
!  Circuit blocking values
! 
!  Circuit usage values
! 
!  Circuit parameter, Handshake Required
! 
!  Circuit maximum receive buffers
! 
!  Circuit verification    [VMS only]
! 
!  Circuit (desired) transport type    [VMS only]
! 
!  Line duplex coded values
! 
!  Line controller mode
! 
!  Line protocol values (same as CIRTY_)
! 
! 	Character encoding
! 
!  Line protocol values for the PCL-11B
! 
!  Line clock values
! 
!  Line packet format types.  Note that only the Ethernet format is
!  allowed to be odd.  All other format values must be even.
! 
!  Line client name types.
! 
!  Line services
! 
!  Line Switch states
! 
!  Ring purger enable states (FDDI)
! 
!  Address type (Token Ring)
! 
!  Ring speed (Token Ring)
! 
!  Early token release (Token Ring)
! 
!  Source routing (Token Ring)
! 
!  Line Media (LAN)
! 
!  Line Hangup state
! 
!  Line Restart state
! 
!  Line type coded values  [V2 only]
! 
!  Line multicast address function code [VMS datalink only].
!  Destination and physical address function codes too [VMS datalink only].
!                                       
!  Duplicate address flag states (FDDI)
! 
!  Upstream neighbor DA flag states (FDDI)
! 
!  Ring purger states (FDDI)
! 
!  Ring error reason states (FDDI)
! 
!  Neighbor PHY type states (FDDI)
! 
!  Reject reason states (FDDI)
! 
!  NI line protocol access mode  [VMS datalink only]
! 
!  PCL-11B address mode
! 
!  X.25 line mode
! 
!  X.25 server redirect reason
! 
!  Node type values
! 
!  Node inbound states
! 
!  Node password values
! 
!  Node CPU type codes
! 
!  Service node version coded values
! 
!  Node software type code
! 
!  Node access (and default access) codes
! 
!  Executor Alias incoming values
! 
!  Object alias outgoing
! 
!  Object alias incoming
! 
!  Executor Proxy 
! 
!  Path Split Policy
! 
!  X.25 Protocol type values
! 
!  X.25 protocol state values
! 
!  X.25 protocol multi-network support flag
! 
!  X.25 protocol DTE substate values
! 
!  X21 literals
! 	
!   Months of the Year Codes
! 
!  Service device codes (MOP)
! 
!         Status codes for field support routines
! 
!         Permanent database file ID codes
! 
!         Open access codes
! 
!         Define Phase II NICE function codes
! 
!         Change parameters (volatile only)
! 
!         Read Information (Status and Counters only)
! 
!         Zero counters
! 
!         Line entity codes
! 
!  NML Return codes
! 
!         Error details
! 
! 
!         STS_FOP and STS_FIO
! 
!         STS_MLD, STS_MCF
! 
!         STS_OPE
! 
! ********************************************************************************************************************************
!  Created:  4-MAY-1995 18:00:24 by OpenVMS SDL EV1-36     
!  Source:   9-JUN-1993 15:39:23 $64$DUA3210:[LIB.SRC]NETUSR.SDL;1 
! ********************************************************************************************************************************
 
!*** MODULE $NFBDEF ***
! 
! 	The following generic field identifiers are defined for all databases.
! 
literal NFB$C_ENDOFLIST = 0;            !  Used to terminate the field i.d. 
literal NFB$C_WILDCARD = 1;             !  Field i.d. used for "match all" database searches 
literal NFB$C_CTX_SIZE = 64;            !  Length of context area in P2 buffer 
! 
! 	The following codes are passed in the second IOSB longword to qualify
! 	as SS$_ILLCNTRFUNC error.
! 
!  The high order word of these error codes must be 0 
!  so that they won't be confused with field i.d.s
literal NFB$_ERR_FCT = 1;               !  Unrecognized NFB$B_FCT value. 
literal NFB$_ERR_DB = 2;                !  Unrecognized NFB$B_DATABASE value. 
literal NFB$_ERR_P1 = 3;                !  The P1 buffer is invalid. 
literal NFB$_ERR_P2 = 4;                !  The P2 buffer is invalid. 
literal NFB$_ERR_P3 = 5;                !  The P3 buffer is invalid. 
literal NFB$_ERR_P4 = 6;                !  The P4 buffer is invalid. 
literal NFB$_ERR_P5 = 7;                !  The P5 buffer should not have been specified. 
literal NFB$_ERR_P6 = 8;                !  The P6 buffer should not have been specified. 
literal NFB$_ERR_CELL = 9;              !  Unrecognized NFB$B_CELL value. 
literal NFB$_ERR_OPER = 10;             !  Unrecognized NFB$B_OPER value. 
literal NFB$_ERR_SRCH = 11;             !  Unrecognized NFB$L_SRCH_KEY field ID 
literal NFB$_ERR_SRCH2 = 12;            !  Unrecognized NFB$L_SRCH2_KEY field ID 
literal NFB$_ERR_OPER2 = 13;            !  Unrecognized NFB$B_OPER2 value. 
literal NFB$_ERR_FLAGS = 14;            !  Undefined bits in NFB$B_FLAGS were not zero. 
literal NFB$_ERR_LOCK = 15;             !  Lock was not granted
! 
! 	Define the P1 buffer format
! 
literal NFB$C_DECLNAME = 21;            !  Declare name 
literal NFB$C_DECLOBJ = 22;             !  Declare object 
literal NFB$C_DECLSERV = 23;            !  Declare server process available 
!  Resume defining function codes 
literal NFB$C_LOGEVENT = 28;            !  Log a network event 
literal NFB$C_READEVENT = 29;           !  Read current raw event queue (used by EVL only) 
!  Resume defining function codes 
literal NFB$C_FC_DELETE = 33;           !  Remove an entry from the data base. 
literal NFB$C_FC_SHOW = 34;             !  Return specified field values. 
literal NFB$C_FC_SET = 35;              !  Set/modify the field values. 
literal NFB$C_FC_CLEAR = 36;            !  Clear specified field values. 
literal NFB$C_FC_ZERCOU = 37;           !  Zero (and optionally read) counters 
literal NFB$C_FC_LOOP = 38;             !  Loop (used only to PSI to loop an X.25 line) 
literal NFB$C_REBUILD_PROXY = 39;       !  Rebuild the proxy data base
literal NFB$C_ADD_PROXY = 40;           !  Add/Modify proxy DB entry
literal NFB$C_DELETE_PROXY = 41;        !  Remove/Delete proxy access
!  Maximum FCT value 
literal NFB$C_FC_MAX = 41;              !  Maximum FCT value 
literal NFB$M_ERRUPD = %X'1';
literal NFB$M_MULT = %X'2';
literal NFB$M_NOCTX = %X'4';
literal NFB$M_LOCAL = %X'8';
literal NFB$C_DB_LNI = 1;               !  Local node 
literal NFB$C_DB_NDI = 2;               !  Common nodes 
literal NFB$C_DB_OBI = 3;               !  Network objects 
literal NFB$C_DB_CRI = 4;               !  Circuits 
literal NFB$C_DB_PLI = 5;               !  Lines 
literal NFB$C_DB_EFI = 6;               !  Event logging filters 
literal NFB$C_DB_ESI = 7;               !  Event logging sinks 
literal NFB$C_DB_LLI = 8;               !  Logical-links 
literal NFB$C_DB_XNI = 9;               !  X.25 networks 
literal NFB$C_DB_XGI = 10;              !  X.25 groups 
literal NFB$C_DB_XDI = 11;              !  X.25 DTEs 
literal NFB$C_DB_XS5 = 12;              !  X.25 server 
literal NFB$C_DB_XD5 = 13;              !  X.25 destinations 
literal NFB$C_DB_XS9 = 14;              !  X.29 server 
literal NFB$C_DB_XD9 = 15;              !  X.29 destinations 
literal NFB$C_DB_XTI = 16;              !  X.25 trace facility 
literal NFB$C_DB_XTT = 17;              !  X.25 tracepoints 
literal NFB$C_DB_SPI = 18;              !  Server Process 
literal NFB$C_DB_AJI = 19;              !  Adjacency information 
literal NFB$C_DB_ARI = 20;              !  Area information 
!  (The following codes are reserved for future PSIACP
!   databases.  These codes should only be used in the
!   event PSIACP needs a database code before a new
!   new NETACP can be supplied to support it).
literal NFB$C_DB_XDTE = 21;             !  PSI reserved database 
literal NFB$C_DB_PSI2 = 22;             !  PSI reserved database 
literal NFB$C_DB_PSI3 = 23;             !  PSI reserved database 
literal NFB$C_DB_PSI4 = 24;             !  PSI reserved database 
literal NFB$C_DB_PSI5 = 25;             !  PSI reserved database 
literal NFB$C_DB_SDI = 26;              !  Service (DLE) information 
literal NFB$C_DB_XAI = 27;              !  X.25 access database 
literal NFB$C_DB_PROXY = 28;            !  Proxy data base
literal NFB$C_DB_XXX = 29;              !  Last database definition for NFB$C_DB_MAX calc. 
!  Maximum DATABASE value 
literal NFB$C_DB_MAX = 28;              !  Maximum DATABASE value 
literal NFB$C_OP_EQL = 0;               !  Match if SEARCH_KEY value EQL database entry field 
literal NFB$C_OP_GTRU = 1;              !  Match if SEARCH_KEY value GTRU database entry field 
literal NFB$C_OP_LSSU = 2;              !  Match if SEARCH_KEY value LSSU database entry field 
literal NFB$C_OP_NEQ = 3;               !  Match if SEARCH_KEY value NEQ database entry field 
!  The following may only be used internally by NETACP
literal NFB$C_OP_FNDMIN = 4;            !  Find entry with minimum key value 
literal NFB$C_OP_FNDMAX = 5;            !  Find entry with maximum key value 
literal NFB$C_OP_FNDPOS = 6;            !  Find entry position in database 
!  Maximum operator function 
literal NFB$C_OP_MAXFCT = 3;            !  Maximum operator function 
literal NFB$C_OP_MAXINT = 6;            !  Maximum internal function 
literal NFB$K_LENGTH = 16;              !  Minimum structure size. 
literal NFB$C_LENGTH = 16;              !  Minimum structure size. 
!  counted strings.  If the "cell size" is non-zero, it
literal NFB$S_NFBDEF = 20;              !  Old size name - synonym
literal NFB$S_NFB = 20;
macro NFB$B_FCT = 0,0,8,0 %;            !  A function code as follows: 
!  Function codes for the NFB 
!   (leaving room for 20 obsolete function codes)
!   (leave room for 4 obsolete function codes)
!   (leave room for 3 obsolete function codes)
macro NFB$B_FLAGS = 1,0,8,0 %;          !  Miscellaneous control flags 
macro NFB$V_ERRUPD = 1,0,1,0 %;         !  Update position context, even on error 
macro NFB$V_MULT = 1,1,1,0 %;           !  Process as many entries as can be fit into P4 
macro NFB$V_NOCTX = 1,2,1,0 %;          !  Don't update position context, even if successful 
!   (used to stay on an entry for a while).  This
!   flag Overrides the ERRUPD flag.
macro NFB$V_LOCAL = 1,3,1,0 %;          !  Signal that REBUILD_PROXY should only be
!  performed locally
macro NFB$B_DATABASE = 2,0,8,0 %;       !  A code identifying the database as follows: 
!  ZERO is an illegal value for this field 
macro NFB$B_OPER = 3,0,8,0 %;           !  Specifies the sense of the search (e.g. EQL, GEQU) 
!  when comparing against the SRCH_KEY field.
macro NFB$L_SRCH_KEY = 4,0,32,0 %;      !  Search key field identifier specifying the key used 
!  to locate the entry in the database.  This search is
!  controlled by the sense of the NFB$B_OPER field.
! 
!  If this field has the value "NFB$C_WILDCARD", then
!  the very next entry in the list is assumed to be the
!  target of the search.
! 
!  If this field is not specified (zero), then it
!  is assumed to be NFB$C_WILDCARD (no search key).
! 
macro NFB$L_SRCH2_KEY = 8,0,32,0 %;     !  Secondary search key field ID specifying the key used 
!  to locate the entry in the database.  This search is
!  controlled by the sense of the NFB$B_OPER2 field.
! 
!  If both SRCH_KEY and SRCH2_KEY are specified, then
!  only those database entries matching both search keys
!  will be processed.
! 
!  If this field is not specified (zero), then it
!  is assumed to be NFB$C_WILDCARD (no search key).
! 
macro NFB$B_OPER2 = 12,0,8,0 %;         !  Specifies the sense of the search (e.g. EQL, GEQU) 
!  when comparing against the SRCH2_KEY field.
macro NFB$B_MBZ1 = 13,0,8,0 %;          !  Reserved. MBZ. 
macro NFB$W_CELL_SIZE = 14,0,16,0 %;    !  Some of the field values found in the P4 buffer are 
!  indicates the number of bytes which each string in
!  the P4 buffer occupies.  If it is zero then strings
!  fields are stored as variable lengthed strings.
macro NFB$L_FLDID = 16,0,32,0 %;        !  Cell containing the first field ID -- the list 
!  of field IDs begins here and continues to the
!  end of the structure.
! 
!  The list may be terminated before the end of the
!  structure by placing the value NFB$C_ENDOFLIST
!  in the longword following the last field ID.
! 
! 
! 	Define the "field i.d." format.
! 
literal NFB$M_INX = %X'FFFF';
literal NFB$M_TYP = %X'30000';
literal NFB$M_SPARE = %X'FC0000';
literal NFB$M_DB = %X'FF000000';
literal NFB$C_TYP_BIT = 0;              !  Field type for bits 
literal NFB$C_TYP_V = 0;                !  Field type for bits 
literal NFB$C_TYP_LNG = 1;              !  Field type for longwords 
literal NFB$C_TYP_L = 1;                !  Field type for longwords 
literal NFB$C_TYP_STR = 2;              !  Field type for strings 
literal NFB$C_TYP_S = 2;                !  Field type for strings 
! 
literal NFB$S_NFBDEF1 = 4;              !  Old size name - synonym	
literal NFB$S_NFB1 = 4;
macro NFB$L_PARAM_ID = 0,0,32,0 %;      !  Define parameter ID longword 
macro NFB$V_INX = 0,0,16,0 %;
literal NFB$S_INX = 16;                 !  Index into semantic table 
macro NFB$V_TYP = 0,16,2,0 %;
literal NFB$S_TYP = 2;                  !  Field type (string, bit, etc.) 
macro NFB$V_SPARE = 0,18,6,0 %;
literal NFB$S_SPARE = 6;                !  Reserved, MBZ 
macro NFB$V_DB = 0,24,8,0 %;
literal NFB$S_DB = 8;                   !  Data-base i.d. 
!    Define useful symbols for storing and retreiving binary and string
!    values from the P2 and P4 buffers
! 
literal NFB$S_NFBDEF2 = 4;              !  old size name - synonym
literal NFB$S_NFB2 = 4;
macro NFB$L_LNG_VALUE = 0,0,32,0 %;     !  Longword value 
literal NFB$S_NFBDEF3 = 4;              !  old size name - synonym
literal NFB$S_NFB3 = 4;
macro NFB$L_BIT_VALUE = 0,0,32,0 %;     !  Boolean value 
literal NFB$C_NDI_LCK = 33554433;       !  Set if conditionally writable fields are not writable 
literal NFB$C_NDI_LOO = 33554434;       !  Set if CNF is for a "loopback" node 
literal NFB$C_NDI_REA = 33554435;       !  Set if node is reachable 
! 
literal NFB$C_NDI_TAD = 33619984;       !  "transformed address" - uses local node address 
!  for the local NDI (instead of zero as does ADD)
literal NFB$C_NDI_CTA = 33619985;       !  Absolute due time for logging counters 
literal NFB$C_NDI_ADD = 33619986;       !  Address 
literal NFB$C_NDI_CTI = 33619987;       !  Counter timer 
literal NFB$C_NDI_ACL = 33619988;       !  Active links 
literal NFB$C_NDI_DEL = 33619989;       !  Delay 
literal NFB$C_NDI_DTY = 33619990;       !  Destination Type 
literal NFB$C_NDI_DCO = 33619991;       !  Destination Cost 
literal NFB$C_NDI_DHO = 33619992;       !  Destination Hops 
literal NFB$C_NDI_SDV = 33619993;       !  Service Device 
literal NFB$C_NDI_CPU = 33619994;       !  CPU type 
literal NFB$C_NDI_STY = 33619995;       !  Software type 
literal NFB$C_NDI_DAD = 33619996;       !  Dump address 
literal NFB$C_NDI_DCT = 33619997;       !  Dump count 
literal NFB$C_NDI_OHO = 33619998;       !  Host 
literal NFB$C_NDI_IHO = 33619999;       !  Host 
literal NFB$C_NDI_ACC = 33620000;       !  Access switch (inbound, outbound, etc) 
literal NFB$C_NDI_PRX = 33620001;       !  ** obsolete ** (Node proxy parameter) 
literal NFB$C_NDI_NND = 33620002;       !  Next node address 
literal NFB$C_NDI_SNV = 33620003;       !  Service Node Version
literal NFB$C_NDI_INB = 33620004;       !  Async Line - Inbound node type
! 
literal NFB$C_NDI_COL = 33685568;       !  Collating field 
literal NFB$C_NDI_HAC = 33685569;       !  Node address/loop linename combination 
literal NFB$C_NDI_CNT = 33685570;       !  Counters 
literal NFB$C_NDI_NNA = 33685571;       !  Name 
literal NFB$C_NDI_SLI = 33685572;       !  Service line 
literal NFB$C_NDI_SPA = 33685573;       !  Service password 
literal NFB$C_NDI_LOA = 33685574;       !  Load file 
literal NFB$C_NDI_SLO = 33685575;       !  Secondary loader 
literal NFB$C_NDI_TLO = 33685576;       !  Tertiary loader 
literal NFB$C_NDI_SID = 33685577;       !  Software ID 
literal NFB$C_NDI_DUM = 33685578;       !  Dump file 
literal NFB$C_NDI_SDU = 33685579;       !  Secondary dumper 
literal NFB$C_NDI_NLI = 33685580;       !  Loopback Line 
literal NFB$C_NDI_DLI = 33685581;       !  Destination Line 
literal NFB$C_NDI_PUS = 33685582;       !  Privileged user id 
literal NFB$C_NDI_PAC = 33685583;       !  Privileged account 
literal NFB$C_NDI_PPW = 33685584;       !  Privileged password 
literal NFB$C_NDI_NUS = 33685585;       !  Non-privileged user id 
literal NFB$C_NDI_NAC = 33685586;       !  Non-privileged account 
literal NFB$C_NDI_NPW = 33685587;       !  Non-privileged password 
literal NFB$C_NDI_RPA = 33685588;       !  Receive password 
literal NFB$C_NDI_TPA = 33685589;       !  Transmit password 
literal NFB$C_NDI_DFL = 33685590;       !  Diagnostic load file 
literal NFB$C_NDI_HWA = 33685591;       !  Hardware NI address (ROM address) 
literal NFB$C_NDI_LPA = 33685592;       !  Loop assistant NI address 
literal NFB$C_NDI_NNN = 33685593;       !  Next node name to destination (goes with NND) 
literal NFB$C_NDI_LAA = 33685594;       !  Load Assist Agent
literal NFB$C_NDI_LAP = 33685595;       !  Load Assist Parameter
literal NFB$C_NDI_MFL = 33685596;       !  Management File
! 
literal NFB$C_LNI_LCK = 16777217;       !  Set if conditionally writable fields are not writable 
literal NFB$C_LNI_ALI = 16777218;       !  Set if ALIAS INBOUND has been enabled
literal NFB$C_LNI_IPR = 16777219;       !  Incoming proxy enabled/disabled
literal NFB$C_LNI_OPR = 16777220;       !  Outgoing proxy enabled/disabled
! 
literal NFB$C_LNI_ADD = 16842768;       !  Address 
literal NFB$C_LNI_ACL = 16842769;       !  Total number of active links 
literal NFB$C_LNI_ITI = 16842770;       !  Incoming timer 
literal NFB$C_LNI_OTI = 16842771;       !  Outgoing timer 
literal NFB$C_LNI_STA = 16842772;       !  State 
literal NFB$C_LNI_MLK = 16842773;       !  Maximum links 
literal NFB$C_LNI_DFA = 16842774;       !  Delay factor 
literal NFB$C_LNI_DWE = 16842775;       !  Delay weight 
literal NFB$C_LNI_IAT = 16842776;       !  Inactivity timer 
literal NFB$C_LNI_RFA = 16842777;       !  Retransmit factor 
literal NFB$C_LNI_ETY = 16842778;       !  Executor Type 
literal NFB$C_LNI_RTI = 16842779;       !  Routing timer 
literal NFB$C_LNI_RSI = 16842780;       !  Routing suppression timer 
literal NFB$C_LNI_SAD = 16842781;       !  Subaddress 
!  (lower word = lower limit, upper word = upper limit)
literal NFB$C_LNI_MAD = 16842782;       !  Maximum address 
literal NFB$C_LNI_MLN = 16842783;       !  Maximum lines 
literal NFB$C_LNI_MCO = 16842784;       !  Maximum cost 
literal NFB$C_LNI_MHO = 16842785;       !  Maximum hops 
literal NFB$C_LNI_MVI = 16842786;       !  Maximum visits 
literal NFB$C_LNI_MBU = 16842787;       !  Maximum buffers 
literal NFB$C_LNI_BUS = 16842788;       !  Forwarding buffer size 
literal NFB$C_LNI_LPC = 16842789;       !  Loop count 
literal NFB$C_LNI_LPL = 16842790;       !  Loop length 
literal NFB$C_LNI_LPD = 16842791;       !  Loop Data type 
literal NFB$C_LNI_DAC = 16842792;       !  Default access switch (inbound, outbound, etc) 
literal NFB$C_LNI_fill1 = 16842793;     !  Place holder, used to be Default proxy access (inbound, outbound, etc) 
literal NFB$C_LNI_PIQ = 16842794;       !  Pipeline quota 
literal NFB$C_LNI_LPH = 16842795;       !  Loop help type of assistance given to loop requestors 
literal NFB$C_LNI_BRT = 16842796;       !  Broadcast routing timer 
literal NFB$C_LNI_MAR = 16842797;       !  Maximum areas 
literal NFB$C_LNI_MBE = 16842798;       !  Maximum nonrouters on NI 
literal NFB$C_LNI_MBR = 16842799;       !  Maximum routers on NI 
literal NFB$C_LNI_AMC = 16842800;       !  Area maximum cost 
literal NFB$C_LNI_AMH = 16842801;       !  Area maximum hops 
literal NFB$C_LNI_SBS = 16842802;       !  Segment buffer size 
literal NFB$C_LNI_ALA = 16842803;       !  Alias local node address (cluster address) 
literal NFB$C_LNI_ALM = 16842804;       !  Alias maximum links
literal NFB$C_LNI_PSP = 16842805;       !  Path split policy normal/interim
literal NFB$C_LNI_MPS = 16842806;       !  Maximum path split
literal NFB$C_LNI_MDO = 16842807;       !  Maximum Declared Object
! 
literal NFB$C_LNI_COL = 16908352;       !  Collating field 
literal NFB$C_LNI_NAM = 16908353;       !  Local node name 
literal NFB$C_LNI_CNT = 16908354;       !  Counters 
literal NFB$C_LNI_IDE = 16908355;       !  Identification 
literal NFB$C_LNI_MVE = 16908356;       !  Management version 
literal NFB$C_LNI_NVE = 16908357;       !  Nsp version 
literal NFB$C_LNI_RVE = 16908358;       !  Routing version 
literal NFB$C_LNI_PHA = 16908359;       !  Physical NI address (current address) 
! 
literal NFB$C_OBI_LCK = 50331649;       !  Set if conditionally writable fields are not writable 
literal NFB$C_OBI_SET = 50331650;       !  Set if a "set" QIO has ever modified the CNF. If 
!  not then the CNF was due to a "declare name/obect"
!  only and may be deleted when the declaring process
!  breaks the channel over which the object was declared
literal NFB$C_OBI_ALO = 50331651;       !  Alias Outgoing enabled/disabled
literal NFB$C_OBI_ALI = 50331652;       !  Alias Incoming enabled/disabled
! 
literal NFB$C_OBI_LPR = 50397200;       !  Low order privileges 
literal NFB$C_OBI_HPR = 50397201;       !  High order privileges 
literal NFB$C_OBI_DOV = 50397202;       !  Point to Owners UCB
literal NFB$C_OBI_CHN = 50397203;       !  Owner's channel 
literal NFB$C_OBI_NUM = 50397204;       !  Number 
literal NFB$C_OBI_PID = 50397205;       !  Process id 
literal NFB$C_OBI_PRX = 50397206;       !  Proxy login switch (inbound, outbound, etc) 
! 
literal NFB$C_OBI_COL = 50462784;       !  Collating field 
literal NFB$C_OBI_ZNA = 50462785;       !  Zero obj+name identifier 
literal NFB$C_OBI_SFI = 50462786;       !  Parsed file i.d. 
literal NFB$C_OBI_IAC = 50462787;       !  Default inbound combined access control string 
literal NFB$C_OBI_NAM = 50462788;       !  Name 
literal NFB$C_OBI_FID = 50462789;       !  File id 
literal NFB$C_OBI_USR = 50462790;       !  User id 
literal NFB$C_OBI_ACC = 50462791;       !  Account 
literal NFB$C_OBI_PSW = 50462792;       !  Password 
literal NFB$C_OBI_OCPRV = 50462793;     !  Outgoing Connect Privileges
! 
literal NFB$C_CRI_LCK = 67108865;       !  D Set if conditionally writable fields are 
! 	not writable
literal NFB$C_CRI_SER = 67108866;       !  D Set if Service functions not allowed 
literal NFB$C_CRI_BLK_FILL = 67108867;  !    Filler (BLK retired)
literal NFB$C_CRI_VER_FILL = 67108868;  !    Filler (VER retired)
literal NFB$C_CRI_DLM = 67108869;       !  E Circuit to be used as X.25 datalink, if set 
! 	If clear, circuit is for X.25 native use
literal NFB$C_CRI_OWPID = 67174416;     !  D PID of temp owner of line in service state 
literal NFB$C_CRI_CTA = 67174417;       !  D Absolute due time for counter logging 
literal NFB$C_CRI_SRV = 67174418;       !  D Service substate qualifier 
literal NFB$C_CRI_STA = 67174419;       !  C State 
literal NFB$C_CRI_SUB = 67174420;       !  C Substate 
literal NFB$C_CRI_LCT = 67174421;       !  C Counter timer 
literal NFB$C_CRI_PNA = 67174422;       !  E Adjacent node address 
literal NFB$C_CRI_BLO = 67174423;       !  E Partner's receive block size 
literal NFB$C_CRI_COS = 67174424;       !  E Cost 
literal NFB$C_CRI_HET = 67174425;       !  E Hello timer 
literal NFB$C_CRI_LIT = 67174426;       !  E Listen timer 
literal NFB$C_CRI_MRC = 67174427;       !  E Maximum recalls 
literal NFB$C_CRI_RCT = 67174428;       !  E Recall timer 
literal NFB$C_CRI_POL = 67174429;       !  D Polling state 
literal NFB$C_CRI_PLS = 67174430;       !  D Polling substate 
literal NFB$C_CRI_USE = 67174431;       !  X Usage 
literal NFB$C_CRI_TYP = 67174432;       !  C Type 
literal NFB$C_CRI_CHN = 67174433;       !  X X.25 Channel 
literal NFB$C_CRI_MBL = 67174434;       !  X Maximum block 
literal NFB$C_CRI_MWI = 67174435;       !  X Maximum window 
literal NFB$C_CRI_TRI = 67174436;       !  D Tributary 
literal NFB$C_CRI_BBT = 67174437;       !  D Babble timer 
literal NFB$C_CRI_TRT = 67174438;       !  D Transmit timer 
literal NFB$C_CRI_MRB = 67174439;       !  D Maximum receive buffers 
literal NFB$C_CRI_MTR = 67174440;       !  D Maximum transmits 
literal NFB$C_CRI_ACB = 67174441;       !  D Active base 
literal NFB$C_CRI_ACI = 67174442;       !  D Active increment 
literal NFB$C_CRI_IAB = 67174443;       !  D Inactive base 
literal NFB$C_CRI_IAI = 67174444;       !  D Inactive increment 
literal NFB$C_CRI_IAT = 67174445;       !  D Inactive threshold 
literal NFB$C_CRI_DYB = 67174446;       !  D Dying base 
literal NFB$C_CRI_DYI = 67174447;       !  D Dying increment 
literal NFB$C_CRI_DYT = 67174448;       !  D Dying threshold 
literal NFB$C_CRI_DTH = 67174449;       !  D Dead threshold 
literal NFB$C_CRI_MST = 67174450;       !  D Maintenance mode state (0 => On, 1 => Off> 
literal NFB$C_CRI_XPT = 67174451;       !  E Transport protocol to use 
literal NFB$C_CRI_MRT = 67174452;       !  E Maximum routers on this NI 
literal NFB$C_CRI_RPR = 67174453;       !  E Router priority 
literal NFB$C_CRI_DRT = 67174454;       !  E Designated router on NI (node address) 
literal NFB$C_CRI_VER = 67174455;       !  D Verification Enabled/Disabled/Inbound on circuit
! 
literal NFB$C_CRI_COL = 67240000;       !  D Collating field 
literal NFB$C_CRI_NAM = 67240001;       !  C Circuit name 
literal NFB$C_CRI_VMSNAM = 67240002;    !  D Device name in VMS format 
literal NFB$C_CRI_CHR = 67240003;       !  D Characteristics buffer for startup control QIO 
literal NFB$C_CRI_CNT = 67240004;       !  C Counters 
literal NFB$C_CRI_P2P = 67240005;       !  D Line's PhaseII partner name (for loopback) 
literal NFB$C_CRI_LOO = 67240006;       !  E Loopback name 
literal NFB$C_CRI_PNN = 67240007;       !  E Adjacent node name 
literal NFB$C_CRI_NUM = 67240008;       !  X Call Number 
literal NFB$C_CRI_DTE = 67240009;       !  X DTE 
literal NFB$C_CRI_DEVNAM = 67240010;    !  D Device name in VMS format, with unit included 
literal NFB$C_CRI_net = 67240011;       !  XD Network name
! 
literal NFB$C_PLI_LCK = 83886081;       !  D Set if conditionally writable fields are 
! 	not writable
literal NFB$C_PLI_SER = 83886082;       !  D Service 
literal NFB$C_PLI_DUP = 83886083;       !  C Duplex (set if half) 
literal NFB$C_PLI_CON = 83886084;       !  C Controller (set if loopback) 
literal NFB$C_PLI_CLO = 83886085;       !  C Clock mode (set if internal) 
literal NFB$C_PLI_SWI = 83886086;       !  D Async Line - Switch
literal NFB$C_PLI_HNG = 83886087;       !  D Async Line - Hangup
! 
literal NFB$C_PLI_CTA = 83951632;       !  D Absolute time for counter read and clear 
literal NFB$C_PLI_STA = 83951633;       !  C State 
literal NFB$C_PLI_SUB = 83951634;       !  C Substate 
literal NFB$C_PLI_LCT = 83951635;       !  D Counter timer 
literal NFB$C_PLI_PRO = 83951636;       !  C Protocol 
literal NFB$C_PLI_STI = 83951637;       !  D Service timer 
literal NFB$C_PLI_HTI = 83951638;       !  L Holdback timer 
literal NFB$C_PLI_MBL = 83951639;       !  L Maximum block 
literal NFB$C_PLI_MRT = 83951640;       !  L Maximum retransmits 
literal NFB$C_PLI_MWI = 83951641;       !  L Maximum window 
literal NFB$C_PLI_SLT = 83951642;       !  D Scheduling timer 
literal NFB$C_PLI_DDT = 83951643;       !  D Dead timer 
literal NFB$C_PLI_DLT = 83951644;       !  D Delay timer 
literal NFB$C_PLI_SRT = 83951645;       !  D Stream timer 
literal NFB$C_PLI_BFN = 83951646;       !  D Receive buffers 
literal NFB$C_PLI_BUS = 83951647;       !  D Action routine returns bufsiz used for line 
literal NFB$C_PLI_PLVEC = 83951648;     !  D PLVEC i.d. 
literal NFB$C_PLI_RTT = 83951649;       !  D Retransmit timer 
literal NFB$C_PLI_MOD = 83951650;       !  L X.25 mode (DCE, DTE, etc). 
literal NFB$C_PLI_LPC = 83951651;       !  L Loop count 
literal NFB$C_PLI_LPL = 83951652;       !  L Loop length 
literal NFB$C_PLI_LPD = 83951653;       !  L Loop Data type 
literal NFB$C_PLI_EPT = 83951654;       !  E Ethernet protocol type for datalink 
literal NFB$C_PLI_LNS = 83951655;       !  D Async Line - Line speed
literal NFB$C_PLI_BFS = 83951656;       !  C Line buffer size (overrides executor bufsiz) 
literal NFB$C_PLI_TPI = 83951657;       !  D Transmit Pipeline
! 
literal NFB$C_PLI_COL = 84017216;       !  D Collating field 
literal NFB$C_PLI_NAM = 84017217;       !  C Line name 
literal NFB$C_PLI_VMSNAM = 84017218;    !  D Device name in VMS format 
literal NFB$C_PLI_CHR = 84017219;       !  D Set-mode $QIO line Characteristics buffer 
literal NFB$C_PLI_CNT = 84017220;       !  C Counters 
literal NFB$C_PLI_MCD = 84017221;       !  L Filespec for microcode dump (initiates dump) 
literal NFB$C_PLI_HWA = 84017222;       !  D NI hardware address (ROM address) 
literal NFB$C_PLI_DEVNAM = 84017223;    !  D Device name in VMS format, with unit included 
literal NFB$C_PLI_NET = 84017224;       !  L Network name
! 
literal NFB$C_EFI_LCK = 100663297;      !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_EFI_SIN = 100728848;
literal NFB$C_EFI_SP1 = 100728849;
literal NFB$C_EFI_B1 = 100728850;
literal NFB$C_EFI_B2 = 100728851;
! 
literal NFB$C_EFI_COL = 100794432;      !  Collating field 
literal NFB$C_EFI_EVE = 100794433;
literal NFB$C_EFI_SB1 = 100794434;
literal NFB$C_EFI_SB2 = 100794435;
literal NFB$C_EFI_SB3 = 100794436;
! 
literal NFB$C_ESI_LCK = 117440513;      !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_ESI_SNK = 117506064;
literal NFB$C_ESI_STA = 117506065;
literal NFB$C_ESI_SP1 = 117506066;
literal NFB$C_ESI_B1 = 117506067;
literal NFB$C_ESI_B2 = 117506068;
! 
literal NFB$C_ESI_COL = 117571648;      !  Collating field 
literal NFB$C_ESI_LNA = 117571649;
literal NFB$C_ESI_SB1 = 117571650;
literal NFB$C_ESI_SB2 = 117571651;
literal NFB$C_ESI_SB3 = 117571652;
! 
literal NFB$C_LLI_LCK = 134217729;      !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_LLI_DLY = 134283280;      !  Round trip delay time 
literal NFB$C_LLI_STA = 134283281;      !  State 
literal NFB$C_LLI_LLN = 134283282;      !  Local link number 
literal NFB$C_LLI_RLN = 134283283;      !  Remote link number 
literal NFB$C_LLI_PNA = 134283284;      !  Partner's node address 
literal NFB$C_LLI_PID = 134283285;      !  External Process I.D.
literal NFB$C_LLI_IPID = 134283286;     !  Internal Process I.D.
literal NFB$C_LLI_XWB = 134283287;      !  Pointer to XWB
literal NFB$C_LLI_CNT = 134283288;      !  Counters
! 
literal NFB$C_LLI_COL = 134348864;      !  Collating field 
literal NFB$C_LLI_USR = 134348865;      !  User name 
literal NFB$C_LLI_PRC = 134348866;      !  Process name 
literal NFB$C_LLI_PNN = 134348867;      !  Partner's node name 
literal NFB$C_LLI_RID = 134348868;      !  Partner's process i.d. 
! 
literal NFB$C_XNI_LCK = 150994945;      !  Set if conditionally writable fields are not writable 
literal NFB$C_XNI_MNS_FILL = 150994946; !  X.25 multi-network support (set if enabled) [No longer used]
! 
literal NFB$C_XNI_CAT = 151060496;      !  Call timer 
literal NFB$C_XNI_CLT = 151060497;      !  Clear timer 
literal NFB$C_XNI_DBL = 151060498;      !  Default data 
literal NFB$C_XNI_DWI = 151060499;      !  Default window 
literal NFB$C_XNI_MBL = 151060500;      !  Maximum data 
literal NFB$C_XNI_MCL = 151060501;      !  Maximum clears 
literal NFB$C_XNI_MRS = 151060502;      !  Maximum resets 
literal NFB$C_XNI_MST = 151060503;      !  Maximum restarts 
literal NFB$C_XNI_MWI = 151060504;      !  Maximum window 
literal NFB$C_XNI_RST = 151060505;      !  Reset timer 
literal NFB$C_XNI_STT = 151060506;      !  Restart timer 
! 
literal NFB$C_XNI_COL = 151126080;      !  Collating field 
literal NFB$C_XNI_netent = 151126081;   !  Network 
literal NFB$C_XNI_PROF = 151126082;     !  Profile name
! 
literal NFB$C_XDI_LCK = 184549377;      !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_XDI_ACH = 184614928;      !  Active channels 
literal NFB$C_XDI_ASW = 184614929;      !  Active switched 
literal NFB$C_XDI_CTM = 184614930;      !  Counter timer 
literal NFB$C_XDI_MCH = 184614931;      !  Maximum channels 
literal NFB$C_XDI_STA = 184614932;      !  State 
literal NFB$C_XDI_SUB = 184614933;      !  Substate 
literal NFB$C_XDI_MCI = 184614934;      !  Maximum circuits [VMS only] 
literal NFB$C_XDI_CAT = 184614935;      !  Call timer 
literal NFB$C_XDI_CLT = 184614936;      !  Clear timer 
literal NFB$C_XDI_DBL = 184614937;      !  Default data 
literal NFB$C_XDI_DWI = 184614938;      !  Default window 
literal NFB$C_XDI_MBL = 184614939;      !  Maximum data 
literal NFB$C_XDI_MCL = 184614940;      !  Maximum clears 
literal NFB$C_XDI_MRS = 184614941;      !  Maximum resets 
literal NFB$C_XDI_MST = 184614942;      !  Maximum restarts 
literal NFB$C_XDI_MWI = 184614943;      !  Maximum window 
literal NFB$C_XDI_RST = 184614944;      !  Reset timer 
literal NFB$C_XDI_STT = 184614945;      !  Restart timer 
literal NFB$C_XDI_mode = 184614946;     !  DTE Mode
literal NFB$C_XDI_itt = 184614947;      !  Interrupt timer
! 
literal NFB$C_XDI_COL = 184680512;      !  Collating field 
literal NFB$C_XDI_DTE = 184680513;      !  DTE address 
literal NFB$C_XDI_CHN = 184680514;      !  Channels 
literal NFB$C_XDI_LIN = 184680515;      !  Line 
literal NFB$C_XDI_dnt = 184680516;      !  Network 
literal NFB$C_XDI_CNT = 184680517;      !  Counters 
! 
literal NFB$C_XGI_LCK = 167772161;      !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_XGI_GNM = 167837712;      !  Group number 
literal NFB$C_XGI_GTY = 167837713;      !  Group type 
! 
literal NFB$C_XGI_COL = 167903296;      !  Collating field. This field must be unique across 
!  all entries in this database.  It consists of the
!  group-name string followed by the DTE address.
literal NFB$C_XGI_GRP = 167903297;      !  Group name 
literal NFB$C_XGI_GDT = 167903298;      !  Group DTE address 
literal NFB$C_XGI_gnt = 167903299;      !  Group Network
! 
literal NFB$C_XS5_LCK = 201326593;      !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_XS5_MCI = 201392144;      !  Maximum circuits allowed 
literal NFB$C_XS5_STA = 201392145;      !  State 
literal NFB$C_XS5_ACI = 201392146;      !  Active circuits 
literal NFB$C_XS5_CTM = 201392147;      !  Counter timer 
! 
literal NFB$C_XS5_COL = 201457728;      !  Collating field. This field must be unique across 
!  all entries in this database.
literal NFB$C_XS5_CNT = 201457729;      !  Counters 
! 
literal NFB$C_XD5_LCK = 218103809;      !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_XD5_PRI = 218169360;      !  Priority 
literal NFB$C_XD5_SAD = 218169361;      !  Subaddress range 
!  (lower word = lower limit, upper word = upper limit)
literal NFB$C_XD5_NOD = 218169362;      !  Remote node address containing server (gateways only) 
literal NFB$C_XD5_red = 218169363;      !  Redirect reason
! 
literal NFB$C_XD5_COL = 218234944;      !  Collating field. This field must be unique across 
!  all entries in this database.
literal NFB$C_XD5_DST = 218234945;      !  Destination DTE address 
literal NFB$C_XD5_CMK = 218234946;      !  Call mask 
literal NFB$C_XD5_CVL = 218234947;      !  Call value 
literal NFB$C_XD5_GRP = 218234948;      !  Group name 
literal NFB$C_XD5_SDTE = 218234949;     !  Sending DTE address (formally number)
literal NFB$C_XD5_OBJ = 218234950;      !  && Object name 
literal NFB$C_XD5_FIL = 218234951;      !  Command procedure to execute when starting object 
literal NFB$C_XD5_USR = 218234952;      !  User name 
literal NFB$C_XD5_PSW = 218234953;      !  Password 
literal NFB$C_XD5_ACC = 218234954;      !  Account 
literal NFB$C_XD5_cdte = 218234955;     !  Called DTE
literal NFB$C_XD5_rdte = 218234956;     !  Receiving DTE
literal NFB$C_XD5_net = 218234957;      !  Network
literal NFB$C_XD5_emk = 218234958;      !  Extension mask
literal NFB$C_XD5_evl = 218234959;      !  Extension value
literal NFB$C_XD5_acl = 218234960;      !  ACL, a list of ACE'structure, parto of ORB
literal NFB$C_XD5_idte = 218234961;     !  Incoming address
! 
literal NFB$C_XS9_LCK = 234881025;      !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_XS9_MCI = 234946576;      !  Maximum circuits allowed 
literal NFB$C_XS9_STA = 234946577;      !  State 
literal NFB$C_XS9_ACI = 234946578;      !  Active circuits 
literal NFB$C_XS9_CTM = 234946579;      !  Counter timer 
! 
literal NFB$C_XS9_COL = 235012160;      !  Collating field. This field must be unique across 
!  all entries in this database.
literal NFB$C_XS9_CNT = 235012161;      !  Counters 
! 
literal NFB$C_XD9_LCK = 251658241;      !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_XD9_PRI = 251723792;      !  Priority 
literal NFB$C_XD9_SAD = 251723793;      !  Subaddress range 
!  (lower word = lower limit, upper word = upper limit)
literal NFB$C_XD9_NOD = 251723794;      !  Remote node address containing server (gateways only) 
literal NFB$C_XD9_red = 251723795;      !  Redirect reason
! 
literal NFB$C_XD9_COL = 251789376;      !  Collating field. This field must be unique across 
!  all entries in this database.
literal NFB$C_XD9_DST = 251789377;      !  Destination DTE address 
literal NFB$C_XD9_CMK = 251789378;      !  Call mask 
literal NFB$C_XD9_CVL = 251789379;      !  Call value 
literal NFB$C_XD9_GRP = 251789380;      !  Group name 
literal NFB$C_XD9_sdte = 251789381;     !  Sending DTE 
literal NFB$C_XD9_OBJ = 251789382;      !  && Object name 
literal NFB$C_XD9_FIL = 251789383;      !  Command procedure to execute when starting object 
literal NFB$C_XD9_USR = 251789384;      !  User name 
literal NFB$C_XD9_PSW = 251789385;      !  Password 
literal NFB$C_XD9_ACC = 251789386;      !  Account 
literal NFB$C_XD9_cdte = 251789387;     !  Caller DTE
literal NFB$C_XD9_rdte = 251789388;     !  Receiving DTE
literal NFB$C_XD9_net = 251789389;      !  Network
literal NFB$C_XD9_emk = 251789390;      !  Extension mask
literal NFB$C_XD9_evl = 251789391;      !  Extension value
literal NFB$C_XD9_acl = 251789392;      !  ACL, a list of ACE'structure, parto of ORB
literal NFB$C_XD9_idte = 251789393;     !  Incoming address
! 
literal NFB$C_XTI_LCK = 268435457;      !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_XTI_STA = 268501008;      !  State 
literal NFB$C_XTI_BFZ = 268501009;      !  Buffer size 
literal NFB$C_XTI_CPL = 268501010;      !  Capture limit 
literal NFB$C_XTI_MBK = 268501011;      !  Maximum blocks/file 
literal NFB$C_XTI_MBF = 268501012;      !  Maximum number of buffers 
literal NFB$C_XTI_MVR = 268501013;      !  Maximum trace file version number 
! 
literal NFB$C_XTI_COL = 268566592;      !  Collating field. This field must be unique across 
!  all entries in this database.
literal NFB$C_XTI_FNM = 268566593;      !  Trace file name 
! 
literal NFB$C_XTT_LCK = 285212673;      !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_XTT_TST = 285278224;      !  State 
literal NFB$C_XTT_CPS = 285278225;      !  Capture size 
! 
literal NFB$C_XTT_COL = 285343808;      !  Collating field. This field must be unique across 
!  all entries in this database.
literal NFB$C_XTT_TPT = 285343809;      !  Tracepoint name 
! 
literal NFB$C_XAI_LCK = 452984833;      !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_XAI_NDA = 453050384;      !  Node address 
! 
literal NFB$C_XAI_COL = 453115968;      !  Collating field 
literal NFB$C_XAI_NET = 453115969;      !  Network 
literal NFB$C_XAI_USR = 453115970;      !  User id 
literal NFB$C_XAI_PSW = 453115971;      !  Password 
literal NFB$C_XAI_ACC = 453115972;      !  Account 
literal NFB$C_XAI_NOD = 453115973;      !  Node id 
! 
literal NFB$C_XDTE_LCK = 352321537;     !  Set if conditionally writable fields are not writable
!     C(,$C_XDTE_,(((NFB$C_DB_XDTE@24)+(NFB$C_TYP_LNG@16)+16)),1
literal NFB$C_XDTE_COL = 352452672;     !  Collating field
literal NFB$C_XDTE_NET = 352452673;     !  Network
literal NFB$C_XDTE_DTE = 352452674;     !  DTE address
literal NFB$C_XDTE_ID = 352452675;      !  ID list, ARB rights list
literal NFB$C_XDTE_ACL = 352452676;     !  ACL, a list of ACE's, part of ORB
! 
literal NFB$C_SPI_LCK = 301989889;      !  Set if conditionally writable fields are not writable 
literal NFB$C_SPI_PRL = 301989890;      !  Proxy flag which initially started server process 
! 
literal NFB$C_SPI_PID = 302055440;      !  Server PID 
literal NFB$C_SPI_IRP = 302055441;      !  IRP of waiting DECLSERV QIO (0 if process active) 
literal NFB$C_SPI_CHN = 302055442;      !  Channel associated with DECLSERV IRP 
literal NFB$C_SPI_RNA = 302055443;      !  Remote node address which initially started server 
! 
literal NFB$C_SPI_COL = 302121024;      !  Collating field 
literal NFB$C_SPI_ACS = 302121025;      !  ACS used to initally start server process 
literal NFB$C_SPI_RID = 302121026;      !  Remote user ID which initially started server 
literal NFB$C_SPI_SFI = 302121027;      !  Last (current) SFI given to server process 
literal NFB$C_SPI_NCB = 302121028;      !  Last (current) NCB given to server process 
literal NFB$C_SPI_PNM = 302121029;      !  Last (current) process name given to server 
! 
literal NFB$C_AJI_LCK = 318767105;      !  Set if conditionally writable fields are not writable 
literal NFB$C_AJI_REA = 318767106;      !  Reachable (set if two-way communication established) 
literal NFB$C_AJI_RRA = 318767107;      !  Reachable Routing Adjacency
! 
literal NFB$C_AJI_ADD = 318832656;      !  Node address 
literal NFB$C_AJI_TYP = 318832657;      !  Node type 
literal NFB$C_AJI_LIT = 318832658;      !  Listen timer for this adjacency 
literal NFB$C_AJI_BLO = 318832659;      !  Partner's block size 
literal NFB$C_AJI_RPR = 318832660;      !  Partner's router priority (on NI) 
! 
literal NFB$C_AJI_COL = 318898240;      !  Collating field 
literal NFB$C_AJI_NNA = 318898241;      !  Node name 
literal NFB$C_AJI_CIR = 318898242;      !  Circuit name 
! 
literal NFB$C_SDI_LCK = 436207617;      !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_SDI_SUB = 436273168;      !  Service substate 
literal NFB$C_SDI_PID = 436273169;      !  PID of process owning this DLE link 
! 
literal NFB$C_SDI_COL = 436338752;      !  Collating field 
literal NFB$C_SDI_CIR = 436338753;      !  Circuit name 
literal NFB$C_SDI_PHA = 436338754;      !  Service physical address (BC only) 
literal NFB$C_SDI_PRC = 436338755;      !  Name of process owning this DLE link 
! 
literal NFB$C_ARI_LCK = 335544321;      !  Set if conditionally writable fields are not writable 
literal NFB$C_ARI_REA = 335544322;      !  Set if node is reachable 
! 
literal NFB$C_ARI_ADD = 335609872;      !  Address 
literal NFB$C_ARI_DCO = 335609873;      !  Destination Cost 
literal NFB$C_ARI_DHO = 335609874;      !  Destination Hops 
literal NFB$C_ARI_NND = 335609875;      !  Next node address 
! 
literal NFB$C_ARI_COL = 335675456;      !  Collating field 
literal NFB$C_ARI_DLI = 335675457;      !  Circuit used for normal traffic to area 
! 
literal NFB$C_PROXY_LCK = 469762049;    !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_PROXY_RUIC = 469827600;   !  Remote UIC
! 
literal NFB$C_PROXY_RNODE = 469893184;  !  Remote node
literal NFB$C_PROXY_RNAME = 469893185;  !  Remote user name
literal NFB$C_PROXY_DEFACCOUNT = 469893186; !  Default local proxy account
literal NFB$C_PROXY_ACCOUNT1 = 469893187; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT2 = 469893188; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT3 = 469893189; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT4 = 469893190; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT5 = 469893191; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT6 = 469893192; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT7 = 469893193; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT8 = 469893194; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT9 = 469893195; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT10 = 469893196; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT11 = 469893197; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT12 = 469893198; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT13 = 469893199; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT14 = 469893200; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT15 = 469893201; !  Local proxy account
literal NFB$C_PROXY_HASHKEY = 469893202; !  Hash key lookup string
literal NFB$C_PROXY_COL = 469893184;    !  Collating field 
literal NFB$C_PROXY_MAXACC = 15;        !  Maximum numver of local proxy accounts
!   including the default
literal NFB$S_NFBDEF4 = 2;              !  old size name - synonym
literal NFB$S_NFB4 = 2;
macro NFB$W_STR_COUNT = 0,0,16,0 %;     !  String count field 
macro NFB$B_STR_TEXT = 2,0,0,0 %;       !  Start of string data 
! 
!   Define identifiers for each parameter in all database
! 
!    **  The low order 16 bits for each parameter must be unique  **
!   ***  with respect to all other parameters in its particular   ***
!    **  database.						 **
! 
!  Define a field identifier index for each parameter in the NDI database.
! 
! 
!    Boolean parameters
! 
!    "Longword" Parameters
! 
!    String parameters
! 
!  Define a field identifier index for each parameter in the LNI database.
! 
! 
!    Boolean parameters
! 
!    "Longword parameters
! 
!    String parameters
! 
!  Define a field identifier index for each parameter in the OBI database.
! 
! 
!    Boolean Parameters
! 
!    Longword Parameters
! 
!    String Parameters
! 
!  Define a field identifier index for each parameter in the CRI database.
! 
! 
! 			/* Use
! 			/* ----
! 			C = common
! 			E = Executor (used by Transport)
! 			X = Native X.25 network management
! 			D = DECnet (not X.25)
! 
! 
!    Boolean Parameters
! 
! 
!    "Longword" parameters
! 
!    String Parameters
! 
!  Define a field identifier index for each parameter in the PLI database.
! 
! 			C = common
! 			L = LAPB (X.25)
! 			D = DDCMP (not X.25)
! 			E = Ethernet
! 
! 			/* Use
!  ----
! 
!    Boolean Parameters
! 
!    "Longword"  Parameters
! 
!    String Parameters
! 
!  Define a field identifier index for each parameter in the EFI database.
! 
! 
!    Boolean Parameters
! 
!    "Longword" Parameters
! 
!    String Parameters
! 
!  Define a field identifier index for each parameter in the ESI database.
! 
! 
!    Boolean Parameters
! 
!    "Longword" Parameters
! 
!    String Parameters
! 
!  Define a field identifier index for each parameter in the LLI database.
! 
! 
!    Boolean Parameters
! 
!    Longword Parameters
! 
!    String Parameters
! 
!  X.25 network parameters (part of MODULE X25-PROTOCOL)
! 
!  Define a field identifier index for each parameter in the XNI database.
! 
! 
!    Boolean Parameters
! 
!    "Longword" Parameters
! 
!    String Parameters
! 
!  X.25 DTE parameters (qualified by a given network)
! 
!  Define a field identifier index for each parameter in the XDI database.
! 
! 
!    Boolean Parameters
! 
!    "Longword" Parameters
! 
!    String Parameters
! 
!  X.25 group parameters (qualified by a given DTE)
! 
!  Define a field identifier index for each parameter in the XGI database.
! 
! 
!    Boolean Parameters
! 
!    "Longword" Parameters
! 
!    String Parameters
! 
!  X.25 server parameters (global parameters for all destinations)
! 
!  Define a field identifier index for each parameter in the XS5 database.
! 
! 
!    Boolean Parameters
! 
!    "Longword" Parameters
! 
!    String Parameters
! 
!  X.25 destination parameters (part of MODULE X25-SERVER)
! 
!  Define a field identifier index for each parameter in the XD5 database.
! 
! 
!    Boolean Parameters
! 
!    "Longword" Parameters
! 
!    String Parameters
! 
!  X.29 server parameters (global parameters for all destinations)
! 
!  Define a field identifier index for each parameter in the XS9 database.
! 
! 
!    Boolean Parameters
! 
!    "Longword" Parameters
! 
!    String Parameters
! 
!  X.29 destination parameters (part of MODULE X29-SERVER)
! 
!  Define a field identifier index for each parameter in the XD9 database.
! 
! 
!    Boolean Parameters
! 
!    "Longword" Parameters
! 
!    String Parameters
! 
!  X.25 tracing facility (global) parameters.
! 
!  Define a field identifier index for each parameter in the XTI database.
! 
! 
!    Boolean Parameters
! 
!    "Longword" Parameters
! 
!    String Parameters
! 
!  X.25 tracpoint (local) parameters.
! 
!  Define a field identifier index for each parameter in the XTT database.
! 
! 
!    Boolean Parameters
! 
!    "Longword" Parameters
! 
!    String Parameters
! 
!  X.25 Access (qualified by a given network)
! 
!  Define a field identifier index for each parameter in the XAI database.
! 
! 
!    Boolean Parameters
! 
!    "Longword" Parameters
! 
!    String Parameters
! 
!  X.25 Security (qualified by a given network)
! 
!  Define a field identifier index for each parameter in the XDTE database.
! 
! 
!    Boolean Parameters
! 
! 
!    "Longword" Parameters
! 
!     )
! 
!    String Parameters
! 
!  Define SPI (Server Process) parameters
! 
! 
!    Boolean Parameters
! 
!    Longword Parameters
! 
!    String Parameters
! 
!  Define AJI (Adjacency) parameters
! 
! 
!    Boolean Parameters
! 
!    Longword Parameters
! 
!    String Parameters
! 
!  Define SDI (Service DLE) parameters
! 
! 
!    Boolean Parameters
! 
!    Longword Parameters
! 
!    String Parameters
! 
!  Define the AREA database (read only) for level 2 Phase IV routers only.
! 
! 
!    Boolean parameters
! 
!    "Longword" Parameters
! 
!    String parameters
! 
!  Define the PROXY database 
! 
! 
!    Boolean parameters
! 
!    "Longword" Parameters
! 
!    String parameters
! 
 
!*** MODULE $DRDEF ***
! 
!  DISCONNECT REASONS
! 
literal NET$C_DR_NORMAL = 0;            !  NO ERROR (SYNCH DISCONNECT) 
literal NET$C_DR_RSU = 1;               !  COULDN'T ALLOCATE UCB ADDRESS 
literal NET$C_DR_NONODE = 2;            !  Unrecognized node name 
literal NET$C_DR_SHUT = 3;              !  NODE OR LINE SHUTTING DOWN 
literal NET$C_DR_NOBJ = 4;              !  UNKNOWN OBJECT TYPE OR PROCESS 
literal NET$C_DR_FMT = 5;               !  ILLEGAL PROCESS NAME FIELD 
literal NET$C_DR_BUSY = 6;              !  Object too busy 
literal NET$C_DR_PROTCL = 7;            !  GENERAL PROTOCOL ERROR 
literal NET$C_DR_THIRD = 8;             !  THIRD PARTY DISCONNECT 
literal NET$C_DR_ABORT = 9;             !  DISCONNECT ABORT 
literal NET$C_DR_IVNODE = 2;            !  Invalid node name format 
literal NET$C_DR_NONZ = 21;             !  NON-ZERO DST ADDRESS 
literal NET$C_DR_BADLNK = 22;           !  INCONSISTENT DSTLNK 
literal NET$C_DR_ZERO = 23;             !  ZERO SOURCE ADDRESS 
literal NET$C_DR_BADFC = 24;            !  FCVAL ILLEGAL 
literal NET$C_DR_NOCON = 32;            !  NO CONNECT SLOTS AVAILABLE 
literal NET$C_DR_ACCESS = 34;           !  INVALID ACCESS CONTROL 
literal NET$C_DR_BADSRV = 35;           !  LOGICAL LINK SERVICES MISMATCH 
literal NET$C_DR_ACCNT = 36;            !  INVALID ACCOUNT INFORMATION 
literal NET$C_DR_SEGSIZ = 37;           !  SEGSIZE TOO SMALL 
literal NET$C_DR_EXIT = 38;             !  USER EXIT OR TIMEOUT 
literal NET$C_DR_NOPATH = 39;           !  NO PATH TO DESTINATION NODE 
literal NET$C_DR_LOSS = 40;             !  LOSS OF DATA HAS OCCURRED 
literal NET$C_DR_NOLINK = 41;           !  ILLEGAL MSG FOR LINK NOLINK STATE 
literal NET$C_DR_CONF = 42;             !  REAL DISCONNECT CONFIRM 
literal NET$C_DR_IMLONG = 43;           !  IMAGE DATA FIELD TOO LONG 
literal NET$C_DR_MISLSCV = 50;          !  MISSING CRYPTOGRAPHIC KEY
literal NET$C_DR_EXPSCV = 51;           !  EXPIRED CRYPTOGRAPHIC KEY
literal NET$C_DR_MACFAIL = 53;          !  INTEGRITY CHECK FAILED
literal NET$C_DR_SRVMMAT = 54;          !  CRYPTOGRAPHIC SERVICE MISMATCH
literal NET$C_DR_VERFAIL = 55;          !  CRYPTOGRAPHIC CONNECT VERIFICATION FAILURE
literal NET$C_DR_CSWRAP = 56;           !  CRYPTOGRAPHIC SEQUENCE SPACE EXHAUSED
! 
! ****************************************************************************
! *                                                                          *
! *  Copyright (c) 1995                                                      *
! *  by DIGITAL Equipment Corporation, Maynard, Mass.                        *
! *                                                                          *
! *  This software is furnished under a license and may be used and  copied  *
! *  only  in  accordance  with  the  terms  of  such  license and with the  *
! *  inclusion of the above copyright notice.  This software or  any  other  *
! *  copies  thereof may not be provided or otherwise made available to any  *
! *  other person.  No title to and ownership of  the  software  is  hereby  *
! *  transferred.                                                            *
! *                                                                          *
! *  The information in this software is subject to change  without  notice  *
! *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment  *
! *  Corporation.                                                            *
! *                                                                          *
! *  DIGITAL assumes no responsibility for the use or  reliability  of  its  *
! *  software on equipment which is not supplied by DIGITAL.                 *
! *                                                                          *
! ****************************************************************************
! ********************************************************************************************************************************
!  Created:  4-MAY-1995 17:59:28 by OpenVMS SDL EV1-36     
!  Source:  25-MAY-1993 14:18:47 $64$DUA3210:[LIB.SRC]RMSPUBSTR.SDL;1 
! ********************************************************************************************************************************
 
!*** MODULE $FSBDEF ***
! 
!          FSB field definitions
! 
!         File statistics block (fsb)
! 
! 	An FSB is associated with a file when the ACE$V_STATISTICS
! 	bit is set in the RMS attributes ACE. It is used to keep track
! 	of RMS file statistics.
! 
literal FSB$M_PRIVATE = %X'1';
literal FSB$M_RMSDEV = %X'2';
literal FSB$C_BID = 25;                 !  fsb id code 
literal FSB$K_STANDARD_BLN = 276;       !  Length of FSB without RMS development specific fields
literal FSB$C_STANDARD_BLN = 276;       !  Length of FSB without RMS development specific fields
!  Reserved for RMS development private monitoring
literal FSBFLG$_GET = 0;                !  Flags used for keeping track of relative file statistics updates
literal FSBFLG$_FIND = 1;
literal FSBFLG$_PUT = 2;
literal FSBFLG$_UPDATE = 3;
literal FSBFLG$_DELETE = 4;
literal FSBFLG$_MAX = 5;
literal FSB$K_VERSION = 1;              !  Current version of FSB
literal FSB$C_VERSION = 1;              !  Current version of FSB
literal FSB$C_SEQ = 1;
literal FSB$C_REL = 2;
literal FSB$C_IDX = 3;                  !  File organization constants 
literal FSB$K_BLN = 368;                !  Length of FSB
literal FSB$C_BLN = 368;                !  Length of FSB
literal FSB$S_FSBDEF = 368;             !  Old size name - synonym
literal FSB$S_FSB = 368;
macro FSB$W_FLAGS = 6,0,16,0 %;         !  fsb flags
macro FSB$V_PRIVATE = 6,0,1,0 %;        !  FSB is for only one stream
macro FSB$V_RMSDEV = 6,1,1,0 %;         !  Reserved RMS fields being used
macro FSB$B_BID = 8,0,8,0 %;            !  block id 
macro FSB$B_BLN = 9,0,8,0 %;            !  block length in longwords 
macro FSB$B_ORG = 10,0,8,0 %;           !  file organization
macro FSB$B_VERSION = 11,0,8,0 %;       !  current version of FSB
macro FSB$L_SEQGETS = 12,0,32,0 %;      !  # of sequential gets to file
macro FSB$L_KEYGETS = 16,0,32,0 %;      !  # of keyed gets to file
macro FSB$L_RFAGETS = 20,0,32,0 %;      !  # of gets by RFA to file
macro FSB$Q_GETBYTES = 24,0,0,0 %;
literal FSB$S_GETBYTES = 8;             !  Total size of all gets in bytes
macro FSB$L_SEQPUTS = 32,0,32,0 %;      !  # of sequential puts
macro FSB$L_KEYPUTS = 36,0,32,0 %;      !  # of puts by key
macro FSB$Q_PUTBYTES = 40,0,0,0 %;
literal FSB$S_PUTBYTES = 8;             !  Total size of all puts in bytes
macro FSB$L_UPDATES = 48,0,32,0 %;      !  # of updates
macro FSB$Q_UPDATEBYTES = 52,0,0,0 %;
literal FSB$S_UPDATEBYTES = 8;          !  Total size of all updates in bytes
macro FSB$L_DELETES = 60,0,32,0 %;      !  # of deletes
macro FSB$L_TRUNCATES = 64,0,32,0 %;    !  # of truncates
macro FSB$L_TRUNCBLKS = 68,0,32,0 %;    !  Total size in blocks of all truncates
macro FSB$L_SEQFINDS = 72,0,32,0 %;     !  # of sequential finds
macro FSB$L_KEYFINDS = 76,0,32,0 %;     !  # of keyed finds
macro FSB$L_RFAFINDS = 80,0,32,0 %;     !  # of finds by RFA
macro FSB$L_READS = 84,0,32,0 %;        !  # of $READs to file
macro FSB$Q_READBYTES = 88,0,0,0 %;
literal FSB$S_READBYTES = 8;            !  # of bytes of all $READs
macro FSB$L_CONNECTS = 96,0,32,0 %;     !  # of connects to this file
macro FSB$L_DISCONNECTS = 100,0,32,0 %; !  # of disconnects from file
macro FSB$L_EXTENDS = 104,0,32,0 %;     !  # of extends of file
macro FSB$L_EXTBLOCKS = 108,0,32,0 %;   !  # of blocks file has been extended
macro FSB$L_FLUSHES = 112,0,32,0 %;     !  # of flushes of file
macro FSB$L_REWINDS = 116,0,32,0 %;     !  # of rewinds of file
macro FSB$L_WRITES = 120,0,32,0 %;      !  # of $WRITEs to file
macro FSB$Q_WRITEBYTES = 124,0,0,0 %;
literal FSB$S_WRITEBYTES = 8;           !  # of bytes of all $WRITEs to file
macro FSB$L_FLCKENQS = 132,0,32,0 %;    !  # of file lock ENQ's
macro FSB$L_FLCKDEQS = 136,0,32,0 %;    !  # of file lock DEQ's
macro FSB$L_FLCKCNVS = 140,0,32,0 %;    !  # of file lock conversions
macro FSB$L_LBLCKENQS = 144,0,32,0 %;   !  # of local buffer lock ENQ's
macro FSB$L_LBLCKDEQS = 148,0,32,0 %;   !  # of local buffer lock DEQ's
macro FSB$L_LBLCKCNVS = 152,0,32,0 %;   !  # of local buffer lock conversions
macro FSB$L_GBLCKENQS = 156,0,32,0 %;   !  # of global buffer lock ENQ's
macro FSB$L_GBLCKDEQS = 160,0,32,0 %;   !  # of global buffer lock DEQ's
macro FSB$L_GBLCKCNVS = 164,0,32,0 %;   !  # of global buffer lock conversions
macro FSB$L_GSLCKENQS = 168,0,32,0 %;   !  # of global section lock ENQ's
macro FSB$L_GSLCKDEQS = 172,0,32,0 %;   !  # of global section lock DEQ's
macro FSB$L_GSLCKCNVS = 176,0,32,0 %;   !  # of global section lock conversions
macro FSB$L_RLCKENQS = 180,0,32,0 %;    !  # of record lock ENQ's
macro FSB$L_RLCKDEQS = 184,0,32,0 %;    !  # of record lock DEQ's
macro FSB$L_RLCKCNVS = 188,0,32,0 %;    !  # of record lock conversions
macro FSB$L_APPLCKENQS = 192,0,32,0 %;  !  # of append lock ENQ's
macro FSB$L_APPLCKDEQS = 196,0,32,0 %;  !  # of append lock DEQ's
macro FSB$L_APPLCKCNVS = 200,0,32,0 %;  !  # of append lock conversions
macro FSB$L_FLBLKASTS = 204,0,32,0 %;   !  # of file lock blocking ASTs queued
macro FSB$L_LBLBLKASTS = 208,0,32,0 %;  !  # of local buffer lock blocking ASTs queued
macro FSB$L_GBLBLKASTS = 212,0,32,0 %;  !  # of global buffer lock blocking ASTs queued
macro FSB$L_APPBLKASTS = 216,0,32,0 %;  !  # of shared append lock blocking ASTs queued
macro FSB$L_LCACHEHITS = 220,0,32,0 %;  !  # of cache hits on local buffers
macro FSB$L_LCACHE_ATTEMPTS = 224,0,32,0 %; !  # of attempts to use the local buffer cache
macro FSB$L_GCACHEHITS = 228,0,32,0 %;  !  # of cache hits on global buffers
macro FSB$L_GCACHE_ATTEMPTS = 232,0,32,0 %; !  # of attempts to use the global buffer cache
macro FSB$L_GBRDIRIOS = 236,0,32,0 %;   !  # of direct io's due to global buffer reads
macro FSB$L_GBWDIRIOS = 240,0,32,0 %;   !  # of direct io's due to global buffer writes
macro FSB$L_LBRDIRIOS = 244,0,32,0 %;   !  # of direct io's due to local buffer reads
macro FSB$L_LBWDIRIOS = 248,0,32,0 %;   !  # of direct io's due to local buffer writes
macro FSB$L_BKTSPLT = 252,0,32,0 %;     !  # of 2 bucket splits
macro FSB$L_MBKTSPLT = 256,0,32,0 %;    !  # of multi-bucket splits
macro FSB$L_OPENS = 260,0,32,0 %;       !  # of times the file is opened
macro FSB$L_CLOSES = 264,0,32,0 %;      !  # of times the file is closed
macro FSB$L_GSBLKASTS = 268,0,32,0 %;   !  # of global section lock blocking ASTs queued
macro FSB$L_XQPQIOS = 272,0,32,0 %;     !  Count of XQP QIOs requested by RMS
macro FSB$L_FLWAITS = 276,0,32,0 %;     !  # of waits forced by getting the file lock
macro FSB$L_LBWAITS = 280,0,32,0 %;     !  # of waits forced by getting local buffer locks
macro FSB$L_GBWAITS = 284,0,32,0 %;     !  # of waits forced by getting global buffer locks
macro FSB$L_GSWAITS = 288,0,32,0 %;     !  # of waits forced by getting the global section lock
macro FSB$L_RLWAITS = 292,0,32,0 %;     !  # of waits forced by getting record locks
macro FSB$L_APWAITS = 296,0,32,0 %;     !  # of waits forced by getting the Append lock
macro FSB$L_TOTWAITS = 300,0,32,0 %;    !  Total # of waits (or stalls) performed by RMS. 
macro FSB$L_OUTBUFQUO = 304,0,32,0 %;   !  Number of times a process runs out of global buffer quota
macro FSB$L_RMSDEV1 = 308,0,32,0 %;     !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV2 = 312,0,32,0 %;     !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV3 = 316,0,32,0 %;     !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV4 = 320,0,32,0 %;     !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV5 = 324,0,32,0 %;     !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV6 = 328,0,32,0 %;     !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV7 = 332,0,32,0 %;     !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV8 = 336,0,32,0 %;     !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV9 = 340,0,32,0 %;     !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV10 = 344,0,32,0 %;    !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV11 = 348,0,32,0 %;    !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV12 = 352,0,32,0 %;    !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV13 = 356,0,32,0 %;    !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV14 = 360,0,32,0 %;    !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV15 = 364,0,32,0 %;    !  Reserved for RMS development private monitoring
 
!*** MODULE $RMSEDTDEF ***
! 
! 	RMS Extension Dispatch Table
! 
! 	The RMS extension dispatch table defines the vector area for RMS processing
! 	callouts.
! 
literal RMSEDT$K_CURVER = 1;
literal RMSEDT$C_CURVER = 1;
literal RMSEDT$K_XAB_DISPLAY = 63;
literal RMSEDT$K_LENGTH = 180;
literal RMSEDT$C_LENGTH = 180;
literal RMSEDT$S_RMSEDTDEF = 180;       !  Old size name - synonym
literal RMSEDT$S_RMSEDT = 180;
macro RMSEDT$W_SIZE = 0,0,16,0 %;
macro RMSEDT$B_VERSION = 2,0,8,0 %;
macro RMSEDT$B_FLAGS = 3,0,8,0 %;
macro RMSEDT$A_CLOSE = 4,0,32,0 %;
macro RMSEDT$A_CONNECT = 8,0,32,0 %;
macro RMSEDT$A_CREATE = 12,0,32,0 %;
macro RMSEDT$A_IMPLIED_CREATE = 16,0,32,0 %;
macro RMSEDT$A_DELETE = 20,0,32,0 %;
macro RMSEDT$A_DISCONNECT = 24,0,32,0 %;
macro RMSEDT$A_DISPLAY = 28,0,32,0 %;
macro RMSEDT$A_ERASE = 32,0,32,0 %;
macro RMSEDT$A_IMPLIED_ERASE = 36,0,32,0 %;
macro RMSEDT$A_EXTEND = 40,0,32,0 %;
macro RMSEDT$A_AUTOEXTEND = 44,0,32,0 %;
macro RMSEDT$A_FIND = 48,0,32,0 %;
macro RMSEDT$A_FLUSH = 52,0,32,0 %;
macro RMSEDT$A_GET = 56,0,32,0 %;
macro RMSEDT$A_OPEN = 60,0,32,0 %;
macro RMSEDT$A_PUT = 64,0,32,0 %;
macro RMSEDT$A_READ = 68,0,32,0 %;
macro RMSEDT$A_RENAME = 72,0,32,0 %;
macro RMSEDT$A_IMPLIED_RENAME = 76,0,32,0 %;
macro RMSEDT$A_REWIND = 80,0,32,0 %;
macro RMSEDT$A_INIT_WCC_SEARCH = 84,0,32,0 %;
macro RMSEDT$A_NEXT_ECXT_SEARCH = 88,0,32,0 %;
macro RMSEDT$A_DELETE_WCC_SEARCH = 92,0,32,0 %;
macro RMSEDT$A_SPACE = 96,0,32,0 %;
macro RMSEDT$A_TRUNCATE = 100,0,32,0 %;
macro RMSEDT$A_UPDATE = 104,0,32,0 %;
macro RMSEDT$A_WRITE = 108,0,32,0 %;
macro RMSEDT$A_OPEN_LTJ = 112,0,32,0 %;
macro RMSEDT$A_CLOSE_LTJ = 116,0,32,0 %;
macro RMSEDT$A_FORMAT_JOURNAL = 120,0,32,0 %;
macro RMSEDT$A_WRITE_JOURNAL = 124,0,32,0 %;
macro RMSEDT$A_FLUSH_JOURNAL = 128,0,32,0 %;
macro RMSEDT$A_CREATE_RUJ = 132,0,32,0 %;
macro RMSEDT$A_CLOSE_RUJ = 136,0,32,0 %;
macro RMSEDT$A_DISPOSE_RU = 140,0,32,0 %;
macro RMSEDT$A_WRITE_RUJ = 144,0,32,0 %;
macro RMSEDT$A_FLUSH_RUJ = 148,0,32,0 %;
macro RMSEDT$A_LOCK_RECORD = 152,0,32,0 %;
macro RMSEDT$A_UNLOCK_RECORD = 156,0,32,0 %;
macro RMSEDT$A_UNLOCK_ALL_RECORDS = 160,0,32,0 %;
macro RMSEDT$A_IS_RECORD_LOCKED = 164,0,32,0 %;
macro RMSEDT$A_IS_RECORD_WRITE_LOCKED = 168,0,32,0 %;
macro RMSEDT$A_IS_RECORD_LOCK_HELD = 172,0,32,0 %;
macro RMSEDT$A_XAB_DISPATCH = 176,0,32,0 %;
 
!*** MODULE $DISPLAY_WILDEF ***
! 
!   $DISPLAY_WILD
! 
!     Display File
! 
!       $DISPLAY_WILD fab, [err], [suc], ctx
! 
!       fab_rab	= address of fab or rab
! 
! 	err	= address of user error completion routine
! 
! 	suc	= address of user success completion routine
! 	ctx	= address of a longword used to hold the next ifi.
! 
%if not %declared(%quote SDL$$DISPLAY_WILDEF_REQ) %then
! MACRO to emit warning and default to 0 if required argument is missing
!
macro
SDL$$DISPLAY_WILDEF_REQ(ARG1, arg2) =
    %IF not %NULL(ARG1) %THEN ARG1
    %else
	%warn(%string('REQUIRED ARGUMENT ', %NAME(ARG2), ' MISSING')) 0
    %FI %;
%fi
 
%if not %declared(%quote SDL$$DISPLAY_WILDEF_OPT) %then
! Defaults omitted arguments to 0 if followed by additional arguments
!
macro
SDL$$DISPLAY_WILDEF_OPT[ARG] =
    %IF %NULL(ARG)
    %THEN
	%IF NOT %NULL(%REMAINING)
	%THEN
	    0
	%FI
    %ELSE
	ARG
    %FI %;
%fi
 
%if not %declared(%quote SDL$$DISPLAY_WILDEF_LIST_0_REQ) %then
! Handles LIST parameters that are also OPTIONAL
!
macro
SDL$$DISPLAY_WILDEF_LIST_0_REQ(ARG) =
    %IF NOT %NULL(ARG) %THEN %REMOVE(ARG) %FI %;
%fi
 
%if not %declared(%quote SDL$$DISPLAY_WILDEF_LIST_1_REQ) %then
! Handles LIST parameters that are not OPTIONAL
! Emits warning and defaults to 0 if required argument is missing
!
macro
SDL$$DISPLAY_WILDEF_LIST_1_REQ(ARG, ARG2) =
    %IF %NULL(ARG) %THEN
	 %warn(%string('REQUIRED ARGUMENT ', %NAME(ARG2), ' MISSING')) 0
    %ELSE
        SDL$$DISPLAY_WILDEF_LIST_0_REQ(ARG) %FI %;
%fi
 
%if not %declared(%quote SDL$$DISPLAY_WILDEF_CONCAT) %then
! Eliminates trailing null arguments
!
macro
SDL$$DISPLAY_WILDEF_CONCAT[ARG] =
    %IF NOT %NULL(ARG) %THEN ARG %FI %;
%fi
 
!             ***********************************	
 
KEYWORDMACRO $DISPLAY_WILD (FAB_RAB,ERR=0,SUC=0,CTX) =
   BEGIN
   EXTERNAL ROUTINE SYS$DISPLAY : BLISS ADDRESSING_MODE (GENERAL);
	   SYS$DISPLAY (SDL$$DISPLAY_WILDEF_CONCAT( SDL$$DISPLAY_WILDEF_REQ(FAB_RAB, %QUOTE FAB_RAB) , 
	   ERR, SUC, SDL$$DISPLAY_WILDEF_REQ(CTX, %QUOTE CTX) ))
   END %;
 
 
!*** MODULE $MODDEF ***
! 
!                 RMS MODify definitions
! 
!   The following values identify various requests for non-standard rms
!   functions.  They are currently input to the $modify function in the
!   ctx field of the fab only if the esc bit is set in fop (rab functions
!   are also accepted).  Incorrect use of these capabilties could cause 
!   RMS to fail, hence great caution should be exercised in their use.
! 
!   The first five functions are also called RME$C_xxxx. They are defined
!   in the public module RMSUSR.SDL and cannot be changed. 
! 
!   FAB function calls
literal MOD$C_SETRFM = 1;               !  change rfm, mrs, and fsz (if vfc) in ifab only 
literal MOD$C_PPFECHO = 2;              !  enable echo of SYS$INPUT to SYS$OUTPUT
literal MOD$C_SETRCF = 3;               !  change recovery mode
literal MOD$C_KEEP_LOCK_ON = 4;         !  Turn on Keep Lock behavior
literal MOD$C_KEEP_LOCK_OFF = 5;        !  Turn off Keep Lock behavior
literal MOD$C_RU_ACE_ON = 6;            !  Turn on RU ACE locking
literal MOD$C_RU_ACE_OFF = 7;           !  Turn off RU ACE locking
!   RAB function calls
literal MOD$C_LOCK_RECORD = 1;          !  Lock a record 
literal MOD$C_ASSOCIATE = 2;            !  Associate a stream with a transaction
! 
! ****************************************************************************
! *                                                                          *
! *  Copyright (c) 1995                                                      *
! *  by DIGITAL Equipment Corporation, Maynard, Mass.                        *
! *                                                                          *
! *  This software is furnished under a license and may be used and  copied  *
! *  only  in  accordance  with  the  terms  of  such  license and with the  *
! *  inclusion of the above copyright notice.  This software or  any  other  *
! *  copies  thereof may not be provided or otherwise made available to any  *
! *  other person.  No title to and ownership of  the  software  is  hereby  *
! *  transferred.                                                            *
! *                                                                          *
! *  The information in this software is subject to change  without  notice  *
! *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment  *
! *  Corporation.                                                            *
! *                                                                          *
! *  DIGITAL assumes no responsibility for the use or  reliability  of  its  *
! *  software on equipment which is not supplied by DIGITAL.                 *
! *                                                                          *
! ****************************************************************************
! ********************************************************************************************************************************
!  Created:  4-MAY-1995 17:59:25 by OpenVMS SDL EV1-36     
!  Source:   9-JUN-1993 15:42:57 $64$DUA3210:[LIB.SRC]RMSFILSTR.SDL;1 
! ********************************************************************************************************************************
 
!*** MODULE $PLGDEF ***
literal PLG$M_NOEXTEND = %X'1';
literal PLG$C_VER_NO = 1;               !  current prolog version number 
literal PLG$C_VER_IDX = 2;              !  new plg for indexed files 
literal PLG$C_VER_3 = 3;                !  new plg for compression, space reclamation (plg 3) 
literal PLG$K_BLN = 122;
literal PLG$C_BLN = 122;
literal PLG$S_PLGDEF = 122;             !  Old size name - synonym
literal PLG$S_PLG = 122;
macro PLG$B_DBKTSIZ = 11,0,8,0 %;       !  data bucket size 
macro PLG$B_FLAGS = 16,0,8,0 %;         !  flag bits
macro PLG$V_NOEXTEND = 16,0,1,0 %;      !  no extend allowed (rel)
macro PLG$B_AVBN = 102,0,8,0 %;         !  vbn of first area descriptor 
macro PLG$B_AMAX = 103,0,8,0 %;         !  maximum number of areas 
macro PLG$W_DVBN = 104,0,16,0 %;        !  first data bucket vbn 
macro PLG$L_MRN = 108,0,32,0 %;         !  maximum record number (rel) 
macro PLG$L_EOF = 112,0,32,0 %;         !  eof vbn (rel) 
macro PLG$W_VER_NO = 116,0,16,0 %;      !  version number 
macro PLG$W_GBC = 118,0,16,0 %;         !  default global buffer count 
macro PLG$W_COLVBN = 120,0,16,0 %;      !  VBN where collate tables begin (if any)
 
!*** MODULE $DLCDEF ***
! 
! 
!   relative file deletion control byte bit definitions
! 
literal DLC$M_DELETED = %X'4';
literal DLC$M_REC = %X'8';
literal DLC$S_DLCDEF = 1;               !  Old size name - synonym
literal DLC$S_DLC = 1;
macro DLC$R_DLCDEF_BITS = 0,0,8,0 %;
macro DLC$V_DELETED = 0,2,1,0 %;        !  record deleted 
macro DLC$V_REC = 0,3,1,0 %;            !  record exists (but may have been deleted) 
 
!*** MODULE $BKTDEF ***
! 
!  index bucket definition
! 
!  this is the bucket format for RMS-11/RMS-32 index files.
! 
literal BKT$K_OVERHDSZ = 14;            !  length of bucket overhead 
literal BKT$C_OVERHDSZ = 14;            !  length of bucket overhead 
literal BKT$M_LASTBKT = %X'1';
literal BKT$M_ROOTBKT = %X'2';
literal BKT$M_PTR_SZ = %X'18';
literal BKT$C_ENDOVHD = 4;              !  end of bucket overhead 
literal BKT$C_DATBKTOVH = 2;            !  end of bucket overhead for data buckets 
literal BKT$C_DUPBKTOVH = 4;            !  additional end of data bucket overhead 
!   when duplicates are allowed (LCB pointer
literal BKT$C_MAXBKTSIZ = 63;           !  maximum bucket size
literal BKT$S_BKTDEF = 14;              !  Old size name - synonym
literal BKT$S_BKT = 14;
macro BKT$B_CHECKCHAR = 0,0,8,0 %;      !  bucket check character 
macro BKT$R_AREANO_OVERLAY = 1,0,8,0 %;
macro BKT$B_AREANO = 1,0,8,0 %;         !  area number form which bucket was allocated 
macro BKT$B_INDEXNO = 1,0,8,0 %;        !  index to which this bucket belongs (plg 3) 
macro BKT$W_ADRSAMPLE = 2,0,16,0 %;     !  address sample - low 16 bits of first vbn in bucket 
macro BKT$R_FREESPACE_OVERLAY = 4,0,16,0 %;
macro BKT$W_FREESPACE = 4,0,16,0 %;     !  displacement in bucket of first free byte 
macro BKT$W_KEYFRESPC = 4,0,16,0 %;     !  pointer to key's free space (plg 3) 
macro BKT$R_NXTRECID_OVERLAY = 6,0,16,0 %;
macro BKT$W_NXTRECID = 6,0,16,0 %;      !  next available word record id (plg 3) 
macro BKT$R_NXTRECID_FIELDS = 6,0,16,0 %;
macro BKT$B_NXTRECID = 6,0,8,0 %;       !  next available record id 
macro BKT$B_LSTRECID = 7,0,8,0 %;       !  last id in range 
macro BKT$L_NXTBKT = 8,0,32,0 %;        !  vbn of next bucket 
macro BKT$B_LEVEL = 12,0,8,0 %;         !  bucket level number 
macro BKT$R_BKTCB_OVERLAY = 13,0,8,0 %;
macro BKT$B_BKTCB = 13,0,8,0 %;         !  bucket control bits 
macro BKT$R_BKTCB_BITS = 13,0,8,0 %;
macro BKT$V_LASTBKT = 13,0,1,0 %;       !  last bucket in horizontal chain 
macro BKT$V_ROOTBKT = 13,1,1,0 %;       !  root bucket 
macro BKT$V_PTR_SZ = 13,3,2,0 %;
literal BKT$S_PTR_SZ = 2;               !  size of vbn pointers in this bucket 
 
!*** MODULE $IRCDEF ***
! 
!  index record definition
! 
!  this is the definition of RMS-11/RMS-32 index file record formats
! 
literal IRC$M_PTRSZ = %X'3';
literal IRC$M_RECORDCB = %X'FC';
literal IRC$M_DELETED = %X'4';
literal IRC$M_NOPTRSZ = %X'10';
literal IRC$M_FIRST_KEY = %X'80';
literal IRC$M_RRV = %X'8';
literal IRC$M_NODUPCNT = %X'10';
literal IRC$M_RU_DELETE = %X'20';
literal IRC$M_RU_UPDATE = %X'40';
literal IRC$C_IDXPTRBAS = 2;            !  used to determine size of pointer in index 
literal IRC$C_IDXOVHDSZ = 1;            !  includes record control byte 
! 
literal IRC$S_IRCDEF = 1;               !  Old size name - synonym
literal IRC$S_IRC = 1;
macro IRC$B_CONTROL = 0,0,8,0 %;        !  record control byte 
macro IRC$R_CONTROL_BITS0 = 0,0,8,0 %;
macro IRC$V_PTRSZ = 0,0,2,0 %;
literal IRC$S_PTRSZ = 2;                !  size of pointer 
macro IRC$V_RECORDCB = 0,2,6,0 %;
literal IRC$S_RECORDCB = 6;             !  record control bits 
! 
!  record control bits used only in primary data record and SIDR array element
!  control bytes
! 
macro IRC$R_CONTROL_BITS1 = 0,0,8,0 %;
macro IRC$V_DELETED = 0,2,1,0 %;        !  record is deleted 
macro IRC$V_NOPTRSZ = 0,4,1,0 %;        !  no RRV
macro IRC$V_FIRST_KEY = 0,7,1,0 %;
! 
!  record control bits used only in primary data record control bytes
! 
macro IRC$R_CONTROL_BITS2 = 0,0,8,0 %;
macro IRC$V_RRV = 0,3,1,0 %;            !  rrv record 
! 
!  record control bits used only in prologue 2 SIDR record control bytes
! 
macro IRC$R_CONTROL_BITS3 = 0,0,8,0 %;
macro IRC$V_NODUPCNT = 0,4,1,0 %;       !  DUP_CNT field absent
! 
!  record control bits used only in prologue 3 RRV, UDR and SIDR record control
!  bytes of RU journalled files. (RU_UPDATE is set only in UDR record control
!  bytes)
! 
macro IRC$R_CONTROL_BITS4 = 0,0,8,0 %;
macro IRC$V_RU_DELETE = 0,5,1,0 %;      !  record is RU deleted
macro IRC$V_RU_UPDATE = 0,6,1,0 %;      !  record is RU updated
! 
!  record control bits reserved for RMS-11 use only (these may not be re-defined
!  except for prologue 3 records)
! 
!  Bit number 5
!  Bit number 6
! 
! 
!  index bucket record
! 
macro IRC$R_CONTROL_FIELDS4 = 0,0,8,0 %;
macro IRC$T_BUCKETPTR = 1,0,0,0 %;      !  bucket pointer (not referenced in the code, 
!   just present for consistency)
!  data bucket record
! 
literal IRC$S_IRCDEF1 = 3;              !  Old size name - synonym
literal IRC$S_IRC1 = 3;
macro IRC$B_ID = 1,0,8,0 %;             !  record id 
macro IRC$B_RRV_ID = 2,0,8,0 %;         !  rrv's id -- always in the same place 
! 
!  prologue 3 data bucket record
! 
literal IRC$C_DATSZFLD = 2;             !  size of size field in variable length records 
literal IRC$C_DATPTRBAS = 3;            !  used to determine size of RRV in data buckets
literal IRC$C_DCNTSZFLD = 4;            !  size of duplicate count field in Plg 2 SIDRs
literal IRC$C_DATOVHDSZ = 2;            !  includes the record control byte, and the id 
literal IRC$C_FIXOVHDSZ = 7;            !  the record overhead for fixed record 
literal IRC$C_VAROVHDSZ = 9;            !  record overhead for variable records 
literal IRC$C_RRVOVHDSZ = 7;            !  size of RRV
! 
literal IRC$C_DATPTRBS3 = 4;            !  used to determine size of RRV in data buckets 
literal IRC$C_DATOVHSZ3 = 3;            !  record control byte, and id 
literal IRC$C_FIXOVHSZ3 = 9;            !  record overhead for fixed length records
literal IRC$C_VAROVHSZ3 = 11;           !  record overhead for variable length records
literal IRC$C_RRVOVHSZ3 = 9;            !  size of RRV
literal IRC$C_SDROVHSZ3 = 2;            !  record overhead for SIDRs
literal IRC$C_KEYCMPOVH = 2;            !  key compression overhead 
literal IRC$C_DATCMPOVH = 3;            !  data compression overhead 
literal IRC$S_IRCDEF2 = 5;              !  Old size name - synonym
literal IRC$S_IRC2 = 5;
macro IRC$W_ID = 1,0,16,0 %;            !  record id 
macro IRC$W_RRV_ID = 3,0,16,0 %;        !  rrv's id -- always in the same place 
! 
!  constants
! 
!  prologue 3 constants
! 
 
!*** MODULE $KEYDEF ***
! 
!  definitions for the key descriptors in the prologue
! 
!  these definitions are associated w/ the plg and area definitions
! 
literal KEY$M_DUPKEYS = %X'1';
literal KEY$M_CHGKEYS = %X'2';
literal KEY$M_NULKEYS = %X'4';
literal KEY$M_IDX_COMPR = %X'8';
literal KEY$M_INITIDX = %X'10';
literal KEY$M_KEY_COMPR = %X'40';
literal KEY$M_REC_COMPR = %X'80';
literal KEY$C_MAX_DAT = 10;             !  (PLG3) Maximum size of a non-compressed data 
!   record
literal KEY$C_MAX_PRIMARY = 6;          !  (PLG3) Maximum size of a non-compressed 
!   primary key
literal KEY$C_MAX_INDEX = 6;            !  (PLG3) Maximum size of a non-compressed 
!   index and SIDR key
literal KEY$C_STRING = 0;               !  string data type 
literal KEY$C_SGNWORD = 1;              !  signed binary word 
literal KEY$C_UNSGNWORD = 2;            !  unsigned binary word 
literal KEY$C_SGNLONG = 3;              !  signed binary long word 
literal KEY$C_UNSGNLONG = 4;            !  unsigned binary long word 
literal KEY$C_PACKED = 5;               !  packed decimal
literal KEY$C_SGNQUAD = 6;              !  signed binary quadword
literal KEY$C_UNSGNQUAD = 7;            !  unsigned binary quadword
literal KEY$C_COLLATED = 8;             !  collated
literal KEY$C_MAX_ASCEND = 8;           !  maximum ASCENDING data type
literal KEY$C_DSTRING = 32;             !  descending string data type 
literal KEY$C_DSGNWORD = 33;            !     "       signed binary word 
literal KEY$C_DUNSGNWORD = 34;          !     "       unsigned binary word 
literal KEY$C_DSGNLONG = 35;            !     "       signed binary long word 
literal KEY$C_DUNSGNLONG = 36;          !     "       unsigned binary long word 
literal KEY$C_DPACKED = 37;             !     "       packed decimal
literal KEY$C_DSGNQUAD = 38;            !     "       signed binary quadword
literal KEY$C_DUNSGNQUAD = 39;          !     "       unsigned binary quadword
literal KEY$C_DCOLLATED = 40;           !     "	      collated
literal KEY$C_MAX_DATA = 40;            !  maximum data type value allowed 
literal KEY$K_BLN = 96;                 !  length of key descriptor in the prologue (plg 3) 
literal KEY$C_BLN = 96;                 !  length of key descriptor in the prologue (plg 3) 
literal KEY$C_SPARE = 6;                !  these are spare words in key block (plg 3) 
literal KEY$S_KEYDEF = 96;              !  Old size name - synonym
literal KEY$S_PROLOGUE_KEY = 96;
macro KEY$L_IDXFL = 0,0,32,0 %;         !  vbn for next key descriptor 
macro KEY$W_NOFF = 4,0,16,0 %;          !  offset to next key descriptor 
macro KEY$B_IANUM = 6,0,8,0 %;          !  index area number 
macro KEY$B_LANUM = 7,0,8,0 %;          !  level 1 area number 
macro KEY$B_DANUM = 8,0,8,0 %;          !  data area number 
macro KEY$B_ROOTLEV = 9,0,8,0 %;        !  root level 
macro KEY$B_IDXBKTSZ = 10,0,8,0 %;      !  index bucket size 
macro KEY$B_DATBKTSZ = 11,0,8,0 %;      !  data bucket size 
macro KEY$L_ROOTVBN = 12,0,32,0 %;      !  root bucket pointer 
macro KEY$R_FLAGS_OVERLAY = 16,0,8,0 %;
macro KEY$B_FLAGS = 16,0,8,0 %;         !  flag bits 
macro KEY$R_FLAGS_BITS0 = 16,0,8,0 %;
macro KEY$V_DUPKEYS = 16,0,1,0 %;       !  duplicate key values allowed 
macro KEY$V_CHGKEYS = 16,1,1,0 %;       !  key value may change on $update operation 
macro KEY$V_NULKEYS = 16,2,1,0 %;       !  null key character enabled 
macro KEY$V_IDX_COMPR = 16,3,1,0 %;     !  index is compressed 
macro KEY$V_INITIDX = 16,4,1,0 %;       !  index must be initialized 
macro KEY$V_KEY_COMPR = 16,6,1,0 %;     !  (PLG3) key is compressed in data record 
macro KEY$R_FLAGS_BITS1 = 16,0,8,0 %;
macro KEY$V_REC_COMPR = 16,7,1,0 %;     !  (PLG3) Data record is compressed 
macro KEY$B_DATATYPE = 17,0,8,0 %;      !  data type for key 
macro KEY$B_SEGMENTS = 18,0,8,0 %;      !  number of segments in key 
macro KEY$B_NULLCHAR = 19,0,8,0 %;      !  "null" character 
macro KEY$B_KEYSZ = 20,0,8,0 %;         !  total key size 
macro KEY$B_KEYREF = 21,0,8,0 %;        !  key of reference 
macro KEY$W_MINRECSZ = 22,0,16,0 %;     !  minimum record length 
macro KEY$W_IDXFILL = 24,0,16,0 %;      !  index fill quantity 
macro KEY$W_DATFILL = 26,0,16,0 %;      !  data fill quantity 
macro KEY$R_POSITION_OVERLAY = 28,0,16,0 %;
macro KEY$W_POSITION = 28,0,16,0 %;     !  key seg position 
macro KEY$W_POSITION0 = 28,0,16,0 %;    !  another name for position 0 
macro KEY$W_POSITION1 = 30,0,16,0 %;    !  position 1 
macro KEY$W_POSITION2 = 32,0,16,0 %;    !  position 2 
macro KEY$W_POSITION3 = 34,0,16,0 %;    !  position 3 
macro KEY$W_POSITION4 = 36,0,16,0 %;    !  position 4 
macro KEY$W_POSITION5 = 38,0,16,0 %;
macro KEY$W_POSITION6 = 40,0,16,0 %;
macro KEY$W_POSITION7 = 42,0,16,0 %;
macro KEY$R_SIZE_OVERLAY = 44,0,8,0 %;
macro KEY$B_SIZE = 44,0,8,0 %;          !  key segment size 
macro KEY$B_SIZE0 = 44,0,8,0 %;         !  another name for size 
macro KEY$B_SIZE1 = 45,0,8,0 %;         !  size 1 
macro KEY$B_SIZE2 = 46,0,8,0 %;
macro KEY$B_SIZE3 = 47,0,8,0 %;
macro KEY$B_SIZE4 = 48,0,8,0 %;
macro KEY$B_SIZE5 = 49,0,8,0 %;
macro KEY$B_SIZE6 = 50,0,8,0 %;
macro KEY$B_SIZE7 = 51,0,8,0 %;
macro KEY$T_KEYNAM = 52,0,0,0 %;
literal KEY$S_KEYNAM = 32;              !  key name 
macro KEY$L_LDVBN = 84,0,32,0 %;        !  first data bucket 
macro KEY$R_TYPE_OVERLAY = 88,0,8,0 %;
macro KEY$B_TYPE = 88,0,8,0 %;          !  key segment datatype (plg 3) 
macro KEY$B_TYPE0 = 88,0,8,0 %;         !  another name for first datatype (plg 3) 
macro KEY$B_TYPE1 = 89,0,8,0 %;         !  (plg 3) 
macro KEY$B_TYPE2 = 90,0,8,0 %;         !  (plg 3) 
macro KEY$B_TYPE3 = 91,0,8,0 %;         !  (plg 3) 
macro KEY$B_TYPE4 = 92,0,8,0 %;         !  (plg 3) 
macro KEY$B_TYPE5 = 93,0,8,0 %;         !  (plg 3) 
macro KEY$B_TYPE6 = 94,0,8,0 %;         !  (plg 3) 
macro KEY$B_TYPE7 = 95,0,8,0 %;         !  (plg 3) 
 
!*** MODULE $AREADEF ***
! 
! 
!  definitions for the area descriptor in the prologue
! 
! 
literal AREA$C_CYL = 1;                 !  cylinded alignment 
literal AREA$C_LBN = 2;                 !  logical block alignment 
literal AREA$C_VBN = 3;                 !  virtual block alignment 
literal AREA$C_RFI = 4;                 !  allocate close to related file by fid 
literal AREA$M_HARD = %X'1';
literal AREA$M_ONC = %X'2';
literal AREA$M_CBT = %X'20';
literal AREA$M_CTG = %X'80';
literal AREA$K_BLN = 64;                !  length of area descriptor in the prologue 
literal AREA$C_BLN = 64;                !  length of area descriptor in the prologue 
literal AREA$S_AREADEF = 64;            !  Old size name - synonym
literal AREA$S_PROLOGUE_AREA = 64;
macro AREA$B_FLAGS = 1,0,8,0 %;         !  not currently used 
macro AREA$B_AREAID = 2,0,8,0 %;        !  area id 
macro AREA$B_ARBKTSZ = 3,0,8,0 %;       !  bucket size for area 
macro AREA$W_VOLUME = 4,0,16,0 %;       !  relative volume number 
macro AREA$B_ALN = 6,0,8,0 %;           !  extend allocation alignment 
macro AREA$R_AOP_OVERLAY = 7,0,8,0 %;
macro AREA$B_AOP = 7,0,8,0 %;           !  alignment options 
macro AREA$R_AOP_BITS = 7,0,8,0 %;
macro AREA$V_HARD = 7,0,1,0 %;          !  absolute alignment or nothing 
macro AREA$V_ONC = 7,1,1,0 %;           !  locate on cylinder 
macro AREA$V_CBT = 7,5,1,0 %;           !  contiguous best try 
macro AREA$V_CTG = 7,7,1,0 %;           !  contiguous 
macro AREA$L_AVAIL = 8,0,32,0 %;        !  available (returned) buckets 
macro AREA$L_CVBN = 12,0,32,0 %;        !  start vbn for current extent 
macro AREA$L_CNBLK = 16,0,32,0 %;       !  number of blocks in current extent 
macro AREA$L_USED = 20,0,32,0 %;        !  number of blocks used 
macro AREA$L_NXTVBN = 24,0,32,0 %;      !  next vbn to use 
macro AREA$L_NXT = 28,0,32,0 %;         !  start vbn for next extent 
macro AREA$L_NXBLK = 32,0,32,0 %;       !  number of blocks in next extent 
macro AREA$W_DEQ = 36,0,16,0 %;         !  default extend quantity 
macro AREA$L_LOC = 40,0,32,0 %;         !  start lbn on volume 
macro AREA$W_RFI = 44,0,0,0 %;
literal AREA$S_RFI = 6;                 !  related file id 
macro AREA$L_TOTAL_ALLOC = 50,0,32,0 %; !  total block allocation
macro AREA$W_CHECK = 62,0,16,0 %;       !  checksum 
 
!*** MODULE $RJRDEF ***
! 
! 
!  definitions for the journal records in RMS journal files
! 
! 
literal RJR$C_RMS_AI = 1;               !  after-image journal
literal RJR$C_RMS_BI = 2;               !  before-image journal
literal RJR$C_RMS_RU = 3;               !  recovery unit
literal RJR$C_RMS_AT = 4;               !  audit trail
literal RJR$C_MAXJNL = 4;               !  jnl type limit
literal RJR$C_VER1 = 1;                 !  journal version 1
literal RJR$C_CURVER = 1;               !  current version
literal RJR$C_NULL = 0;                 !  No entry follows the header
literal RJR$C_LEADER = 1;               !  leader entry
literal RJR$C_TRAILER = 2;              !  trailer entry
literal RJR$C_RECORD = 3;               !  record entry (AI, BI, RU)
literal RJR$C_BLOCK = 4;                !  block entry  (AI, BI, RU)
literal RJR$C_EXTEND = 5;               !  extend entry (AI, AT)
literal RJR$C_CREATE = 6;               !  create entry (AI, AT)
literal RJR$C_AT_RECORD = 7;            !  audit trail record (AT)
literal RJR$C_DEFINE_JNL = 8;           !  Journal creation record
literal RJR$C_BACKUP = 9;               !  Backup done entry (AI, BI)
literal RJR$C_COMMIT = 10;              !  RU commit entry (AI, BI)
literal RJR$C_ABORT = 11;               !  RU abort entry (AI, BI)
literal RJR$C_PREPARE = 12;             !  RU prepare entry (AI, BI, RU)
literal RJR$C_FORCED_COMMIT = 13;       !  RU forced commit for AI jnls
literal RJR$C_MAXTYP = 13;              !  entry-type limit
literal RJR$C_SEQ = 0;                  !  sequential file org
literal RJR$C_REL = 1;                  !  relative file org
literal RJR$C_IDX = 2;                  !  indexed file org
literal RJR$C_HSH = 3;                  !  hashed file org
literal RJR$C_MAXORG = 3;               !  org limit
literal RJR$_CLOSE = 1;                 !  close
literal RJR$_CONNECT = 2;               !  connect
literal RJR$_CREATE = 3;                !  create
literal RJR$_DELETE = 4;                !  delete
literal RJR$_DISCONNECT = 5;            !  disconnect
literal RJR$_DISPLAY = 6;               !  display
literal RJR$_ENTER = 7;                 !  enter
literal RJR$_ERASE = 8;                 !  erase
literal RJR$_EXTEND = 9;                !  extend
literal RJR$_FIND = 10;                 !  find
literal RJR$_FLUSH = 11;                !  flush
literal RJR$_FREE = 12;                 !  free
literal RJR$_GET = 13;                  !  get
literal RJR$_MODIFY = 14;               !  modify
literal RJR$_NXTVOL = 15;               !  next volume
literal RJR$_OPEN = 16;                 !  open
literal RJR$_PARSE = 17;                !  parse
literal RJR$_PUT = 18;                  !  put
literal RJR$_READ = 19;                 !  block I/O read
literal RJR$_RELEASE = 20;              !  release
literal RJR$_REMOVE = 21;               !  remove
literal RJR$_RENAME = 22;               !  rename
literal RJR$_REWIND = 23;               !  rewind
literal RJR$_SEARCH = 24;               !  search
literal RJR$_SPACE = 25;                !  block I/O space
literal RJR$_TRUNCATE = 26;             !  truncate
literal RJR$_UPDATE = 27;               !  update
literal RJR$_WAIT = 28;                 !  wait
literal RJR$_WRITE = 29;                !  block I/O write
literal RJR$_TPT = 30;                  !  truncate on PUT
literal RJR$_MAXOPER = 30;              !  oper limit
literal RJR$C_HDRLEN = 72;              !  common header len
literal RJR$K_HDRLEN = 72;              !  common header len
literal RJR$C_COMMITLEN = 72;           !  commit entry len
literal RJR$K_COMMITLEN = 72;           !  commit entry len
literal RJR$C_ABORTLEN = 72;            !  abort entry len
literal RJR$K_ABORTLEN = 72;            !  abort entry len
literal RJR$C_FORCED_COMMITLEN = 72;    !  forced commit entry len
literal RJR$K_FORCED_COMMITLEN = 72;    !  forced commit entry len
! 
literal RJR$C_LDRLEN = 169;             !  leader entry len
literal RJR$K_LDRLEN = 169;             !  leader entry len
!  the 3 filespec strings above appear here
literal RJR$C_TRLLEN = 107;             !  trailer entry len
literal RJR$K_TRLLEN = 107;             !  trailer entry len
!  filespec of next journal file appears here
literal RJR$C_RECLEN = 100;             !  record entry len
literal RJR$K_RECLEN = 100;             !  record entry len
literal RJR$C_BLKLEN = 96;              !  block i/o entry len
literal RJR$K_BLKLEN = 96;              !  block i/o entry len
literal RJR$M_EXT_USE_XAB = %X'1';
literal RJR$C_EXTLEN = 114;             !  extend entry len
literal RJR$K_EXTLEN = 114;             !  extend entry len
literal RJR$M_ATR_UCHAR = %X'1';
literal RJR$M_ATR_PROT = %X'2';
literal RJR$M_ATR_UIC = %X'4';
literal RJR$M_ATR_REC = %X'8';
literal RJR$M_ATR_EXPIRE = %X'10';
literal RJR$C_FIBLEN = 64;
literal RJR$K_FIBLEN = 64;
literal RJR$C_RECATRLEN = 32;
literal RJR$K_RECATRLEN = 32;
literal RJR$C_CRELEN = 226;
literal RJR$K_CRELEN = 226;
literal RJR$C_AT_RECLEN = 104;
literal RJR$K_AT_RECLEN = 104;
literal RJR$C_BACKUPLEN = 92;
literal RJR$K_BACKUPLEN = 92;
literal RJR$C_PREPARELEN = 112;         !  prepare entry len
literal RJR$K_PREPARELEN = 112;         !  prepare entry len
!  actual node name string follows here
literal RJR$C_BLN = 226;                !  length of RJR descriptor in the prologue 
literal RJR$K_BLN = 226;                !  length of RJR descriptor in the prologue 
literal RJR$S_RJRDEF = 226;             !  Old size name - synonym
literal RJR$S_RJR = 226;
macro RJR$W_FACILITY = 0,0,16,0 %;      !  facility code (=1)
macro RJR$W_FLAGS = 2,0,16,0 %;         !  flags
macro RJR$V_FIRST_RU_RECORD = 2,0,1,0 %; !  first journal record for this RU
macro RJR$V_RUJ_IN_LTJ = 2,1,1,0 %;     !  this is a RU record written to a LTJ
macro RJR$V_WRITTEN_BY_RECOVER = 2,2,1,0 %; !  written during detached reocvery
macro RJR$V_FIRST_STREAM_RU_RECORD = 2,3,1,0 %; !  first journal record for this stream and RU
macro RJR$V_RECOVERED = 2,4,1,0 %;      !  entries for leader record already recovered
macro RJR$V_NOPAD = 2,5,1,0 %;          !  Do not pad AI record
macro RJR$L_JNLIDX = 4,0,32,0 %;        !  journal stream index
macro RJR$B_JNL_TYPE = 8,0,8,0 %;       !  journaling type
macro RJR$B_VERSION = 9,0,8,0 %;        !  RMS journal version #
macro RJR$B_ENTRY_TYPE = 10,0,8,0 %;    !  journal entry type
macro RJR$B_ORG = 11,0,8,0 %;           !  file organization
macro RJR$B_OPER = 12,0,8,0 %;          !  RMS operation id
macro RJR$T_RUID = 16,0,0,0 %;
literal RJR$S_RUID = 16;                !  RUID (if operation performed in an RU)
macro RJR$T_TID = 16,0,0,0 %;
literal RJR$S_TID = 16;                 !  TID is the RUID under DDTM
macro RJR$L_EPID = 32,0,32,0 %;         !  EPID of the process writing the entry
macro RJR$Q_DATE = 36,0,0,0 %;
literal RJR$S_DATE = 8;                 !  date/time of record
macro RJR$L_AT_STS = 44,0,32,0 %;       !  status of operation (AT)
macro RJR$L_AT_STV = 48,0,32,0 %;       !  secondary status (AT)
macro RJR$L_AT_CTX = 52,0,32,0 %;       !  user FAB/RAB CTX field (AT)
!  End of common RJR header. Begin entry-specific definitions.
! 
! 
!  Leader record. First record in each journal file.
! 
macro RJR$W_FILESPEC_OFF = 72,0,16,0 %; !  offset to filespec of file being journaled (from top of RJR)
macro RJR$W_FILESPEC_LEN = 74,0,16,0 %; !  length of filespec of file being journaled
macro RJR$B_VOLNAM_LEN = 76,0,8,0 %;    !  length of volume name string
macro RJR$T_VOLNAM = 77,0,0,0 %;
literal RJR$S_VOLNAM = 12;              !  volume name of file being journaled
macro RJR$T_FID = 89,0,0,0 %;
literal RJR$S_FID = 6;                  !  FID of file being journaled
macro RJR$Q_CDATE = 95,0,0,0 %;
literal RJR$S_CDATE = 8;                !  creation date of file being journaled
macro RJR$W_J_FILESPEC_OFF = 103,0,16,0 %; !  offset to filespec of journal file (from top of RJR)
macro RJR$W_J_FILESPEC_LEN = 105,0,16,0 %; !  length of filespec of journal file
macro RJR$B_J_VOLNAM_LEN = 107,0,8,0 %; !  length of volume name string
macro RJR$T_J_VOLNAM = 108,0,0,0 %;
literal RJR$S_J_VOLNAM = 12;            !  volume name of journal file
macro RJR$T_J_FID = 120,0,0,0 %;
literal RJR$S_J_FID = 6;                !  FID of journal file
macro RJR$Q_J_CDATE = 126,0,0,0 %;
literal RJR$S_J_CDATE = 8;              !  creation date of journal file
macro RJR$W_PJ_FILESPEC_OFF = 134,0,16,0 %; !  offset to filespec of previous journal file (from top of RJR)
macro RJR$W_PJ_FILESPEC_LEN = 136,0,16,0 %; !  length of filespec of previous journal file
macro RJR$B_PJ_VOLNAM_LEN = 138,0,8,0 %; !  length of volume name string
macro RJR$T_PJ_VOLNAM = 139,0,0,0 %;
literal RJR$S_PJ_VOLNAM = 12;           !  volume name of previous journal file
macro RJR$T_PJ_FID = 151,0,0,0 %;
literal RJR$S_PJ_FID = 6;               !  FID of previous journal file
macro RJR$Q_PJ_CDATE = 157,0,0,0 %;
literal RJR$S_PJ_CDATE = 8;             !  creation date of previous journal file
macro RJR$L_PJ_JNLIDX = 165,0,32,0 %;   !  journal stream index of the previous journal file
! 
!  Trailer record. This record is only present in AI or BI journal files that
!  have newer versions. It is written to the old journal file when a file that
!  was already marked for journaling is re-marked for journaling to point to
!  a newer version of a journal file.
! 
macro RJR$W_NJ_FILESPEC_OFF = 72,0,16,0 %; !  offset to filespec of next journal file (from top of RJR)
macro RJR$W_NJ_FILESPEC_LEN = 74,0,16,0 %; !  length of filespec of next journal file
macro RJR$B_NJ_VOLNAM_LEN = 76,0,8,0 %; !  length of volume name string
macro RJR$T_NJ_VOLNAM = 77,0,0,0 %;
literal RJR$S_NJ_VOLNAM = 12;           !  volume name of next journal file
macro RJR$T_NJ_FID = 89,0,0,0 %;
literal RJR$S_NJ_FID = 6;               !  FID of next journal file
macro RJR$Q_NJ_CDATE = 95,0,0,0 %;
literal RJR$S_NJ_CDATE = 8;             !  creation date of next journal file
macro RJR$L_NJ_JNLIDX = 103,0,32,0 %;   !  Journal stream index of the next journal file
! 
!  Record entry. Used for AI, BI, and RU to journal record operations.
! 
macro RJR$L_CHKSUM = 88,0,32,0 %;       !  checksum of old record
macro RJR$W_RFA = 92,0,0,0 %;
literal RJR$S_RFA = 6;                  !  RFA of record
macro RJR$L_RFA0 = 92,0,32,0 %;         !  alternate RFA def
macro RJR$W_RFA4 = 96,0,16,0 %;
macro RJR$L_RRN = 92,0,32,0 %;          !  relative record number
macro RJR$W_RSIZE = 98,0,16,0 %;        !  record size
macro RJR$T_RIMAGE = 100,0,0,0 %;       !  record data
! 
!  The block entry is used for ISAM AI/BI bucket entries, $WRITEs, and AT.
! 
macro RJR$L_BLOCK_VBN = 88,0,32,0 %;    !  vbn of block
macro RJR$W_BLOCK_SIZE = 92,0,16,0 %;   !  transfer size
macro RJR$W_JBLOCK_SIZE = 94,0,16,0 %;  !  actual size of
!  journaled data
macro RJR$T_BLOCK = 96,0,0,0 %;         !  block data
! 
!  RJR$C_BLKLEN must be a quadword multiple or indexed data buffers
!  will not be quadword aligned!!! This constant is used to size
!  indexed data buffers which have imbedded AI and BI RJR headers
!  when long term journaling is used.
! 
! 
!  The extend entry is common to both AT and AI journaling.
! 
macro RJR$L_EXT_FLAGS = 88,0,32,0 %;
macro RJR$V_EXT_USE_XAB = 88,0,1,0 %;   !  ALL XAB fields present
! 
!  Fields EXT_AOP (unused) through EXT_RFI are in same relative locations as
!  the same fields in allocation XAB.
! 
macro RJR$B_EXT_AOP = 92,0,8,0 %;       !  align options
macro RJR$B_EXT_ALN = 93,0,8,0 %;       !  alignment boundary
macro RJR$W_EXT_VOL = 94,0,16,0 %;      !  relative volume number
macro RJR$L_EXT_LOC = 96,0,32,0 %;      !  location
macro RJR$L_EXT_ALQ = 100,0,32,0 %;     !  allocation quantity
macro RJR$W_EXT_DEQ = 104,0,16,0 %;     !  default extension
macro RJR$B_EXT_BKZ = 106,0,8,0 %;      !  bucket size
macro RJR$B_EXT_AID = 107,0,8,0 %;      !  area ID
macro RJR$W_EXT_RFI = 108,0,0,0 %;
literal RJR$S_EXT_RFI = 6;              !  related file IFI
macro RJR$T_EXT_ENDALL = 114,0,0,0 %;   !  end of all info
! 
!  The CREATE entry is used to record the information required to re-create
!  a file for AI journaling, and to record a create for AT journaling.
! 
macro RJR$L_ATR_FLAGS = 88,0,32,0 %;
macro RJR$V_ATR_UCHAR = 88,0,1,0 %;     !  UCHAR attribute present
macro RJR$V_ATR_PROT = 88,1,1,0 %;      !  PROT attribute present
macro RJR$V_ATR_UIC = 88,2,1,0 %;       !  UIC attribute present
macro RJR$V_ATR_REC = 88,3,1,0 %;       !  RECORD attributes present
macro RJR$V_ATR_EXPIRE = 88,4,1,0 %;    !  EXPIRATION present
macro RJR$L_UIC = 92,0,32,0 %;          !  owner UIC
macro RJR$L_PROT = 96,0,32,0 %;         !  prot mask
macro RJR$L_ALLOC = 100,0,32,0 %;       !  initial allocation (audit)
macro RJR$L_UCHAR = 104,0,32,0 %;       !  user characteristics (create)
macro RJR$Q_EXPIRE = 108,0,0,0 %;
literal RJR$S_EXPIRE = 8;               !  expiration date (create)
macro RJR$B_FAC = 116,0,8,0 %;          !  file access (audit)
macro RJR$B_SHR = 117,0,8,0 %;          !  sharing allowed (audit)
macro RJR$W_DID = 118,0,0,0 %;
literal RJR$S_DID = 6;                  !  directory ID (create, volume recovery)
macro RJR$T_FIB = 126,0,0,0 %;
literal RJR$S_FIB = 64;                 !  FIB (create)
macro RJR$T_REC_ATTR = 190,0,0,0 %;
literal RJR$S_REC_ATTR = 32;            !  record attributes (create)
macro RJR$W_C_FILESPEC_OFF = 222,0,16,0 %; !  offset to full filespec (from top of RJR)
macro RJR$W_C_FILESPEC_LEN = 224,0,16,0 %; !  length of full filespec
! 
!  The AT record is used for audit-trail journaling.
! 
macro RJR$L_AT_ROP = 88,0,32,0 %;       !  record options
macro RJR$B_AT_KRF = 92,0,8,0 %;        !  key of reference
macro RJR$B_AT_KSZ = 93,0,8,0 %;        !  key size
macro RJR$B_AT_RAC = 94,0,8,0 %;        !  record access mode
macro RJR$W_AT_RFA = 96,0,0,0 %;
literal RJR$S_AT_RFA = 6;               !  RFA of record
macro RJR$L_AT_RFA0 = 96,0,32,0 %;      !  alternate RFA def
macro RJR$W_AT_RFA4 = 100,0,16,0 %;
macro RJR$L_AT_RRN = 96,0,32,0 %;       !  relative record number
macro RJR$T_AT_KEY = 104,0,0,0 %;       !  key if used
! 
!   The BACKUP_ENTRY record is used to flag that a backup has been taken on the
!   data file being journaled.  It provides a known starting point for rollforward.
! 
macro RJR$L_BACKUP_SEQNO = 88,0,32,0 %; !  Backup sequence number
! 
!  The prepare record is written to RU, AI, and BI journals for transactions
!  that required a two-phase commit protocol.
! 
macro RJR$T_DDTM_LOG_ID = 72,0,0,0 %;
literal RJR$S_DDTM_LOG_ID = 16;         !  DDTM log id
macro RJR$T_RUJ_LOG_ID = 88,0,0,0 %;
literal RJR$S_RUJ_LOG_ID = 16;          !  RMS RUJ log id
macro RJR$W_NODE_NAME_OFF = 104,0,16,0 %; !  offset to node name string
macro RJR$W_NODE_NAME_LEN = 106,0,16,0 %; !  length of node name string
macro RJR$W_RM_NAME_OFF = 108,0,16,0 %; !  offset to resource manager name string
macro RJR$W_RM_NAME_LEN = 110,0,16,0 %; !  length of resource manager name string
! OBJREQMAC.REQ  -  REQUIRE FILE FOR BLISS-32 INTERFACE TO OBJECT MANAGEMENT
!	Version 'X-2'
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984, 1990 BY			    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
!
!++
!
! FACILITY:	Security Class Registration Interface from BLISS
!
! FUNCTIONAL DESCRIPTION:
!
!	This module defines the macros that are used to generate
!	the template structures used during the registration of
!	a security object class.
!
! ENVIRONMENT:  No specific constraints.
!
! AUTHOR:	Scott A. Shurts 	CREATION DATE:  18-Jun-1990
!
! MODIFIED BY:
!
!	X-2	CEG		Clair Grant		12-MAR-1993
!		Remove use of obsolete symbol NSA$K_ACC_LENGTH from
!		$ACCESS_VECTOR macro.
!
!   	X-1     CEG	        Clair Grant             25-JUN-1992
!		Initial port to Alpha, no changes.
!		
!	X-2	CRB0603		Colin R. Blake		18-DEC-1991 12:50:32.39
!		This is the C2 version being inserted into mainline.
!
!	X-1T3A1	SAD0170		Stuart A. Davidson	26-NOV-1991
!		Tranquility OSR support.
!
!	T-4	SAD0138		Stuart A. Davidson	 4-OCT-1991
!		ORB flags field is a word (not a byte).
!
!	T-2	SAD		Stuart A. Davidson	13-MAY-1991
!		Make all OSRs but PREPROCESS be optional.
!		Use ORB$L_ORIGINAL_ORB for template list.
!
!	X-3T1	SAD0109 	Stuart A. Davidson	11-MAR-1991
!		remove TLV_TO_ORB
!
!	X-3	SAS0233		Scott A. Shurts		7-Oct-1990
!		Add TLV_TO_ORB and FIXUP_BTIME_ORBS to $osr_vector.
!		Also make GET_ITEM and SET_ITEM optional.
!
!	X-2	SAS0227		Scott A. Shurts		8-Aug-1990
!		Remove embedded ARM$V_ processing to allow any
!		symbol/value input (ie. lps or customers) 
!		Also, include the support for multiple template (default)
!		object_rights by adding the NEXT and OBJNAM parameters.
!		Add check_access OSR routine and make access_exception 
!		optional.
!
!--

!++
!  $BLD_BITMASK  
!	Takes a list of bitnames and then constructs their mask name
!  	based on the PREFIX parameter and creates a mask by a logical
!  	OR.
!--

MACRO
	$BLD_BITMASK (PREFIX, BIT_NAME) [] =
	    %IF %NULL (PREFIX)
		%THEN
		    BIT_NAME $BLD_BITMASK_OR (%REMAINING)
		    $BLD_BITMASK (PREFIX, %REMAINING)
		%ELSE
		    %NAME (PREFIX, '$M_', BIT_NAME) $BLD_BITMASK_OR (%REMAINING)
		    $BLD_BITMASK (PREFIX, %REMAINING)
		%FI %,

	$BLD_BITMASK_OR [] =
		OR %;

!++
!
!  $ACCESS_BITNAMES  
!	Creates the bitname translation table from the list
!  	access names and address of ASCID strings.  The translation table is a
!  	vector or 32 longwords with the access name symbol used as an
!  	index into the table of ASCID string addresses.
!
!--

MACRO

	$ACCESS_BITNAMES (ACCESS_PAIR) =
		VECTOR [32] PRESET ( $ACCESS_BITS (ACCESS_PAIR)
				     %IF %LENGTH-1 GTR 0 %THEN,
				     $ACCESS_BITS (%REMAINING) %FI) %,

	$ACCESS_BITS (ACCESS_PAIR) [] =
		$ACCESS_ENTRY (%REMOVE (ACCESS_PAIR)) %IF %LENGTH-1 GTR 0 %THEN, $ACCESS_BITS (%REMAINING) %FI %, 

	$ACCESS_ENTRY (INDEX, STRING_ADDR) =
		[INDEX] = STRING_ADDR %;

!++
!
! $ACCESS_VECTOR
!	Declare an Access Vector for either audits or alarms.
!	This vector is used to determine if audits/alarms are generated
!	as the result of an access attempt.
!--

KEYWORDMACRO
	$ACCESS_VECTOR ( SUCCESS,
			 FAILURE,
			 SYSPRV,
			 BYPASS,
			 UPGRADE,
			 DOWNGRADE,
			 GRPPRV,
			 READALL,
			 OTHER ) =

	BLOCK [NSA$K_ACCESS_LENGTH+12, BYTE] PRESET (
		[NSA$L_ACC_FAILURE] = 	%IF %NULL( FAILURE )
   					    %THEN 0
					    %ELSE $BLD_BITMASK (, %REMOVE (FAILURE))
				     	%FI,
		[NSA$L_ACC_SUCCESS] = 	%IF %NULL( SUCCESS )
					    %THEN 0
				            %ELSE $BLD_BITMASK (, %REMOVE (SUCCESS))
				      	%FI,
		[NSA$L_ACC_SYSPRV] = 	%IF %NULL( SYSPRV )
					    %THEN 0
					    %ELSE $BLD_BITMASK (, %REMOVE (SYSPRV))
					%FI,
		[NSA$L_ACC_BYPASS] = 	%IF %NULL( BYPASS )
					    %THEN 0
					    %ELSE $BLD_BITMASK (, %REMOVE (BYPASS))
					%FI,
		[NSA$L_ACC_UPGRADE] = 	%IF %NULL( UPGRADE )
					    %THEN 0
					    %ELSE $BLD_BITMASK (, %REMOVE (UPGRADE))
					%FI,
		[NSA$L_ACC_DOWNGRADE] = %IF %NULL( DOWNGRADE )
					    %THEN 0
					    %ELSE $BLD_BITMASK (, %REMOVE (DOWNGRADE))
					%FI,
		[NSA$L_ACC_READALL] = 	%IF %NULL( READALL )
					    %THEN 0
					    %ELSE $BLD_BITMASK (, %REMOVE (READALL))
					%FI,
		[NSA$L_ACC_OTHER] = 	%IF %NULL( OTHER )
					    %THEN 0
					    %ELSE $BLD_BITMASK (, %REMOVE (OTHER))
					%FI  ) %;

!++
!
! $OBJECT_CLASS
!	Creates a template Object Class Block (OCB) used for registration
!	requests (EXE$REGISTER_SECURITY_CLASS).
!
!--

KEYWORDMACRO
	$OBJECT_CLASS ( 
		FLAGS,
		DEFAULT_ORB = 0,
		CLASS_ORB = 0,
		ACCESS_BITNAMES = 0,
		ACCESS_AUDITS = 0,
		ACCESS_ALARMS = 0 ) =

	BLOCK [OCB$K_LENGTH, BYTE] PRESET (
		[OCB$L_FLAGS] = %IF %NULL( FLAGS )
				    %THEN 0
				    %ELSE $BLD_BITMASK (OCB, %REMOVE (FLAGS))
				    %FI,
		[OCB$L_DEFAULT_ORB] = DEFAULT_ORB,
		[OCB$L_CLASS_ORB] = CLASS_ORB,
		[OCB$L_ACCESS_BITNAMES] = ACCESS_BITNAMES,
		[OCB$AR_ACC_AUDITS] = ACCESS_AUDITS,
		[OCB$AR_ACC_ALARMS] = ACCESS_ALARMS ) %;


!++
!
! $OBJECT_RIGHTS
!	Creates a template Object Rights Block (ORB) used for registration
!	requests (EXE$REGISTER_SECURITY_CLASS).
!
!--

KEYWORDMACRO
	$OBJECT_RIGHTS	(
		OWNER = 0,
		FLAGS,
		SYS_PROT,
		OWN_PROT,
		GRP_PROT,
		WOR_PROT,
		OBJNAM,
		NEXT = 0,
		OBJECT_SPECIFIC = 0 ) =

	BLOCK [ORB$K_LENGTH, BYTE] PRESET ( 
		[ORB$L_ORIGINAL_ORB] = NEXT,
		[ORB$L_OBJECT_SPECIFIC] = OBJECT_SPECIFIC,
		[ORB$L_OWNER] = OWNER,
		[ORB$W_FLAGS] = %IF %NULL( FLAGS )
				    %THEN 0
				    %ELSE $BLD_BITMASK (ORB, %REMOVE (FLAGS))
				%FI,
		[ORB$L_SYS_PROT] =  %IF %NULL( SYS_PROT )
				    	%THEN -1
				    	%ELSE NOT ($BLD_BITMASK (ARM, %REMOVE (SYS_PROT)))
				    %FI,
		[ORB$L_OWN_PROT] =  %IF %NULL( OWN_PROT )
				    	%THEN -1
				    	%ELSE NOT ($BLD_BITMASK (ARM, %REMOVE (OWN_PROT)))
				    %FI,
		[ORB$L_GRP_PROT] =  %IF %NULL( GRP_PROT )
				    	%THEN -1
				    	%ELSE NOT ($BLD_BITMASK (ARM, %REMOVE (GRP_PROT)))
				    %FI,
		[ORB$L_WOR_PROT] =  %IF %NULL( WOR_PROT )
				    	%THEN -1
				    	%ELSE NOT ($BLD_BITMASK (ARM, %REMOVE (WOR_PROT)))
				    %FI ,
		[ORB$L_NAME_POINTER] = OBJNAM ) %;

!++
!
! $OSR_VECTOR
!	Creates the Object Support Routine Vector for dispatching.  The
!	OSRV stucture is used by the security subsystem to dispatch to
!	various class specific processing routines.
!
!--

KEYWORDMACRO
	$OSR_VECTOR (
		ACCESS_EXCEPTION = 0,
		CLONE_PROFILE,
		GET_ITEM = 0,
		PREPROCESS,
		RUNDOWN = 0,
		SET_ITEM = 0,
		UPDATE_PROFILE = 0,
		CHECK_ACCESS = 0,
		FIXUP_BTIME_ORBS = 0,
		RESOLVE_ACL = 0,
		READ_PROFILE = 0,
		SET_TRANQUILITY = 0,
		CLEAR_TRANQUILITY = 0 ) =

	BLOCK [OSRV$K_LENGTH, BYTE] PRESET (
		[OSRV$L_ACCESS_EXCEPTION] = ACCESS_EXCEPTION,
		[OSRV$L_CLONE_PROFILE] = CLONE_PROFILE,
		[OSRV$L_GET_ITEM] = GET_ITEM,
		[OSRV$L_PREPROCESS] = PREPROCESS,
		[OSRV$L_RUNDOWN] = RUNDOWN,
		[OSRV$L_SET_ITEM] = SET_ITEM,
		[OSRV$L_UPDATE_PROFILE] = UPDATE_PROFILE,
		[OSRV$L_CHECK_ACCESS] = CHECK_ACCESS,
		[OSRV$L_FIXUP_BTIME_ORBS] = FIXUP_BTIME_ORBS,
		[OSRV$L_RESOLVE_ACL] = RESOLVE_ACL,
		[OSRV$L_READ_PROFILE] = READ_PROFILE,
		[OSRV$L_SET_TRANQUILITY] = SET_TRANQUILITY,
		[OSRV$L_CLEAR_TRANQUILITY] = CLEAR_TRANQUILITY ) %;

! X-20

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1990, 1991, 1993 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY: SYSTEM, BUGCHECK
!
! ABSTRACT:
!	This include file contains the macros AND BUGCHECK information
!	necessary to create the BUGCHECK codes, a buffer of BUGCHECK
!	messages and a lookup table (to match a code to the message).
!
!	To define the BUGCHECK codes, table or messages in a Bliss source
!	module, use the following macro calls.
!
!		GENBUGCHECKMSGS (CODES)
!		GENBUGCHECKMSGS (TABLE, <psect-name>)
!		GENBUGCHECKMSGS (MESSAGES, <psect-name>)
!
!	The table and messages are defined by the BUGCHECK.B32 module in
!	the SYS facility (in EXCEPTIONS.EXE)
! 
!	New BUGCHECK codes/messages should be appended at the end of the
!	file before the PLACE_HOLDER. The format is:                                                 
!
!		GENINFO (<code-name>, %ASCII'<code-text>')
!	
!--

!                   
!                                                     
! MODIFIED BY:
!
!       X-20    TGC0043          Tom Carr                23-FEB-1995
!               Add BUG$_SHADZEROMBR.
!
!	X-19			Nancy Jean Burkholder	12-Oct-1994
!		Add INSF_NONPAGED for Shadowing and DU/TUDRIVER.
!
!	X-18	MAH		Mark A. Howell		 8-Sep-1994
!		Add Dollar specific bug check codes
!
! 	X-18	RS00474		Richard Sayde		22-Nov-1993
! 		Changed VAXCluster to VMSCluster in message text. Also
! 		removed -VAX portion from DECnet-VAX message.
! 
! 	X-17	RFB001		Ray Boucher		22-Oct-1993
!		Added TMSCP BUGCHECK code.
!
! 	X-16	RS00465		Richard Sayde		29-Sep-1993
! 		Added LASTBUG bugcheck code as an indicator of the
! 		last possibel bugcheck code.
! 
!	X-15	SDD		Steve DiPirro		10-Sep-1993
!		Add ASSERTFAIL for system C code assert failures.
!
!	X-14	DBM0001		David B. Miller		14-Apr-1993
!		Add SYSAPLERR for OPCOM.
!
!	X-13	CEG		Clair Grant		13-APR-1993
!		Undo previous change.
!
!	X-12	CEG		Clair Grant		12-APR-1993
!		Add SECAUDERR
!
!	X-11	CEG		Clair Grant		26-MAR-1993
!		Add NSABLOST, SECAUDTCB, SECIPLHIGH
!
!	X-10	TRB		Tom Benson		11-Mar-1993
!		Added REGCORDET, "register corruption detected after fork",
!		so that INCON_SCHED doesn't have to be used for that purpose
!		anymore.
!
!	X-8	CEG		Clair Grant		12-MAR-1993
!		Add SECOSRERR.
!		Match version number with CMS generation.
!
!	X-9	EMB0211		Ellen M. Batbouta	17-Sep-1992
!		Add bugcheck code, NOCALLTRANS, to signal that it
!		is illegal for inner-mode native code to call
!		translated code.
!
!	X-8			Sue Lewis		28-Jul-1992
!		Add code for generic I/O induced crashes.
!	X-7	RLP001		Ray Pfau		31-Jan-1992
!		Add bugcheck code for CTRLERR (controller error).
!
!	X-6	HH0808		Hai Huang		11-Dec-1991
!		Add generic POSIX bugcheck code (POSIXBUG).
!
!	X-5	BJT244		Benjamin J. Thomas III	14-Sep-1991
!		Add I/O Mailbox error code (IOMBXERR)
!
!	X-4	MSH1158		Michael S. Harvey	29-Aug-1991
!		Replace BADSWPVBN with BADSWPPAG.
!
!	X-3	JJA0077		Jeffrey J. Anuszczyk	12-Jun-1991
!		Add codes for new error halt restart bugchecks.
!
!	X-2	JTK		Jim Klumpp		20-Mar-1991
!		Add bugcheck code for invalid map register parameter.
!
!	X-1K11	RS00089		Richard Sayde		 6-Mar-1991
! 		Remove mention of interrupt stack for BUGCHECK code
!		INVEXCEPTN as it no longer exists on Alpha.
!
!	X-1K10	SDD		Steve DiPirro		28-Feb-1991
!		Add bugcheck code for XDELTA/DELTA-induced BUGCHECKs.
!
!	X-1K9	JJA0033		Jeffrey J. Anuszczyk	 7-Jan-1991
!		Add bugcheck code for [SYSLOA] OPdriver.
!
!	X-1K8	RS00055		Richard Sayde		 7-Jan-1991
!		Added BUGCHECK code string to error message. This should
! 		simplify searching for BUGCHECK codes in listings.
!
!   	X-1K7	PAJ0335   	Paul A. Jacobi	   	15-Oct-1990
!		Added several new BUGCHECK code for the [APB] and [SYSBOOT]
!		facility.
!
!	X-1K6	MSH1028		Michael S. Harvey	29-Aug-1990
!		Add INCONMMGST. Delete Polarstar bugchecks and BADPSL.
!
!	X-1K5	KLN1038		Karen Noel		24-Aug-1990
!		Add incon_shell
!
!	X-1K4	RS00024		Richard Sayde		10-Aug-1990
!		Fix a couple of bugs - change %ASCID to %ASCIC in icon_sched
!		BUGCHECK and a bug in how the table is built (Calculated
!		alignment incorrectly).
!
!	X-1K3	WMC00K3		Wayne Cardoza		02-Aug-1990
!		Remove shared memory bugchecks.
!
!	X-1K2	WMC00K2		Wayne Cardoza		26-Jul-1990
!		Delete queuempty, add incon_sched
!
!	X-1	RS00010		Richard Sayde		 2-Jul-1990
!		Create this module.
!

%IF (%DECLARED (BugCheckMacrosDefined) EQL 0) %THEN
  COMPILETIME 	BugCheckMacrosDefined = 1,
		CodeNum = 8,
		NewBufIndex = 0,
		BufIndex = 0,
		BufNum = 0,
		ZeroBytes = 0,
		GenTable = 0,
		GenMessages = 0;


  MACRO
    STARTMSG(PsectName) =
      %ASSIGN (CodeNum, 8)
      %ASSIGN (NewBufIndex, 0)
      %ASSIGN (BufIndex, 0)
      %ASSIGN (BufNum, 0)
      %ASSIGN (ZeroBytes, 0)
      %IF (GenTable EQL 1) %THEN
        GLOBAL BIND BUG$TABLE = UPLIT 
	%IF (%LENGTH EQL 1) %THEN
	  PSECT (PsectName) 
	%FI
	WORD (0
      %ELSE
        %IF (GenMessages EQL 1) %THEN
  	  GLOBAL BIND BUG$MESSAGES = UPLIT 
	  %IF (%LENGTH EQL 1) %THEN
	    PSECT (PsectName)
	  %FI
	   BYTE (
        %FI
      %FI %,
  
    ENDMSG =
      %IF (GenTable EQL 1) %THEN
        ): VECTOR [, WORD];
      %ELSE
        %IF (GenMessages EQL 1) %THEN
        	0): VECTOR[,BYTE];
        %FI
      %FI %,
  
    GENZEROS(Count)[] =
      %IF (Count GTR 0) %THEN
        0, GENZEROS(Count - 1)
      %FI %,

    MSGSTRING(CODE,STRING) =
	%STRING (%CHAR(%CHARCOUNT (%STRING (CODE, ', ', STRING))),
		 CODE, ', ', STRING) %,
  
    GENINFO(CODE,STRING) =
      %IF (GenTable EQL 1) OR (GenMessages EQL 1) %THEN
        %ASSIGN (NewBufIndex, BufIndex + %CHARCOUNT (MSGSTRING(CODE,STRING)))
        %IF (%NUMBER(NewBufIndex) GEQ %NUMBER(BlockSize)) %THEN
          ! this message goes over a block boundary, align it at the next
	  ! boundary
	  %ASSIGN (ZeroBytes, ZeroBytes + BlockSize - BufIndex)
	  %ASSIGN (BufIndex, 0)
	  %ASSIGN (BufNum, BufNum + 1)
        %FI
  
        %IF (GenTable EQL 1) %THEN
	  ! add the table info to the uplit
	  , %NUMBER(BufNum) * %NUMBER(BlockSize) + %NUMBER(BufIndex)
        %ELSE
	  ! add the messages info to the uplit
	  GENZEROS(ZeroBytes) MSGSTRING(CODE,STRING), 
        %FI

        ! update BufIndex 
        %IF (%NUMBER(NewBufIndex) LSS %NUMBER(BlockSize)) %THEN
          %ASSIGN (BufIndex, NewBufIndex)
	%ELSE
	  %ASSIGN (BufIndex, BufIndex + %CHARCOUNT (MSGSTRING(CODE,STRING)))
        %FI
        
        ! quadword align the buffer index
        %ASSIGN (NewBufIndex, ((BufIndex + 8) / 8) * 8)
        %ASSIGN (ZeroBytes, NewBufIndex - BufIndex)
        %ASSIGN (BufIndex, NewBufIndex)
  
      %ELSE
        GLOBAL LITERAL %NAME ('BUG$_', CODE) = CodeNum;
      %FI 
      %ASSIGN (CodeNum, CodeNum + 8) %,

    PLACE_HOLDER =
      %IF (GenTable EQL 1) %THEN
      	 , 0, 0
      %FI %,

    GENBUGCHECKMSGS (GenType, PsectName) =
      ! determine what to generate, codes, table or message buffer
      %IF (%IDENTICAL (GenType, CODES)) %THEN
	%ASSIGN (GenTable, 0)
	%ASSIGN (GenMessages, 0)
      %ELSE
	%IF (%IDENTICAL (GenType, TABLE)) %THEN
	  %ASSIGN (GenTable, 1)
	  %ASSIGN (GenMessages, 0)
	%ELSE
	  %IF (%IDENTICAL (GenType, MESSAGES)) %THEN
	    %ASSIGN (GenTable, 0)
	    %ASSIGN (GenMessages, 1)
	  %ELSE
	    %ERROR (%ASCII'Invalid bugcheck generate type ', GenType)
	    %EXITMACRO
	  %FI
	%FI
      %FI

      ! do the work
      %IF (%LENGTH EQL 2) %THEN
      	 STARTMSG (PsectName)
      %ELSE
      	 STARTMSG ()
      %FI
      GENINFO (ACPMBFAIL, %ASCII'ACP failure to read mailbox')
      GENINFO (ACPVAFAIL, %ASCII'ACP failure to return virtual address space')
      GENINFO (ALCPHD, %ASCII'Allocate process header error')
      GENINFO (ALCSMBCLR, %ASCII'ACP tried to allocate space already allocated')
      GENINFO (APTREFHIGH, %ASCII'Inconsistent active page table reference count')
      GENINFO (APTWRTERR, %ASCII'Active page table swap write error')
      GENINFO (ASYNCWRTER, %ASCII'Asynchronous write memory failure')
      GENINFO (BADALORQSZ, %ASCII'Bad memory allocation request size')
      GENINFO (BADBUFADR, %ASCII'ACP buffer address out of range of buffer pool')
      GENINFO (BADBUFTYP, %ASCII'Bad ACP buffer type code')
      GENINFO (BADDALRQSZ, %ASCII'Bad memory deallocation request size or address')
      GENINFO (BADFID, %ASCII'ACP file number out of range for this volume')
      GENINFO (BADFORKIPL, %ASCII'Bad FORK exit interrupt priority level')
      GENINFO (BADLCKWSLE, %ASCII'Bad locked working set list entry, not a page table')
      GENINFO (BADMCKCOD, %ASCII'Bad machine check code')
      GENINFO (BADPAGFILA, %ASCII'Bad page file address allocated')
      GENINFO (BADPAGFILD, %ASCII'Bad page file address deallocated')
      GENINFO (BADPAGTYPE, %ASCII'Bad page type')
      GENINFO (BADRSEIPL, %ASCII'Bad IPL at entrance to report schedule event')
      GENINFO (BADSBMBLK, %ASCII'ACP tried to reference off end of bitmap')
      GENINFO (BADSWPPAG, %ASCII'Swap page specified for non-process page')
      GENINFO (BADWCBPT, %ASCII'Bad WCB pointer in IRP')
      GENINFO (CHMONIS, %ASCII'Change mode instruction while on interrupt stack')
      GENINFO (CONTRACT, %ASCII'Contract virtual address space error')
      GENINFO (DBLERR, %ASCII'Double error halt restart')
      GENINFO (DECPTREF, %ASCII'Decrement page table reference count error')
      GENINFO (DELCONPFN, %ASCII'Fatal error in delete contents of PFN')
      GENINFO (DELGBLSEC, %ASCII'Delete global section error')
      GENINFO (DELGBLWCB, %ASCII'Delete global section window error')
      GENINFO (BADBOOTCB, %ASCII'Corrupted Boot Control Block')
      GENINFO (DELWSLEX, %ASCII'Delete working set list entry index error')
      GENINFO (DIRENTRY, %ASCII'ACP failed to find same directory entry')
      GENINFO (DOUBLDALOC, %ASCII'Double deallocation of swap file space')
      GENINFO (DOUBLDEALO, %ASCII'Double deallocation of memory block')
      GENINFO (ERRHALT, %ASCII'Halt with error interrupt pending')
      GENINFO (EXHFUL, %ASCII'File extension header has no room')
      GENINFO (EXPANDPHD, %ASCII'Expand process header error')
      GENINFO (FATALEXCPT, %ASCII'Fatal executive or kernel mode exception')
      GENINFO (FREEPAGREF, %ASCII'Free page reference count is nonzero')
      GENINFO (FREWSLX, %ASCII'Free working set list index, resource wait')
      GENINFO (GBLPAGSZRO, %ASCII'Global page share count is zero')
      GENINFO (GBLWSLXERR, %ASCII'Global working set list entry not found')
      GENINFO (GPGNULPGFL, %ASCII'Global page has null page file address')
      GENINFO (HALT, %ASCII'Halt instruction restart')
      GENINFO (HDRNOTMAP, %ASCII'Allocated file header not mapped')
      GENINFO (ICONPFNDAT, %ASCII'Inconsistent PFN data base')
      GENINFO (ICPAGELOC, %ASCII'Inconsistent page location')
      GENINFO (IFREPAGCNT, %ASCII'Inconsistent free page count')
      GENINFO (ILLEVTNUM, %ASCII'Illegal event number')
      GENINFO (ILLVEC, %ASCII'Illegal interrupt or exception vector restart')
      GENINFO (INCONSTATE, %ASCII'Inconsistent I/O data base')
      GENINFO (INCPTREF, %ASCII'Increment page table reference count error')
      GENINFO (INSNFREPAG, %ASCII'Insufficient nonfree pages')
      GENINFO (INSSWPFIL, %ASCII'Insufficient swap file space')
      GENINFO (INSWAPERR, %ASCII'Inswap read error')
      GENINFO (INVCHAN, %ASCII'Invalid ACP channel number')
      GENINFO (INVEXCEPTN, %ASCII'Exception while above ASTDEL')
      GENINFO (INVPTEFMT, %ASCII'Invalid page table entry format')
      GENINFO (INVTQEFMT, %ASCII'Invalid time queue entry format')
      GENINFO (IVBAKADIO, %ASCII'Invalid backing store address for I/O')
      GENINFO (IVGBLTYP, %ASCII'Invalid global master PTE type')
      GENINFO (IVLISTK, %ASCII'Interrupt stack invalid restart')
      GENINFO (IVSSRVRQST, %ASCII'Invalid system service request')
      GENINFO (IVWSETLIST, %ASCII'Invalid working set list entry')
      GENINFO (KRNLSTAKNV, %ASCII'Kernel stack not valid')
      GENINFO (MACHINECHK, %ASCII'Machine check while in kernel mode')
      GENINFO (MAKEWSLE, %ASCII'Make working set list entry error')
      GENINFO (MODRELNBAK, %ASCII'No backing store address for modified page')
      GENINFO (MFYNULPGFL, %ASCII'FREWSLE - no backing store, page not modified')
      GENINFO (MPWALCIRP, %ASCII'Modified page writer failed to allocate I/O Packet')
      GENINFO (MTXCNTNONZ, %ASCII'Mutex count nonzero at system service exit')
      GENINFO (NETNOBUF, %ASCII'NETACP - buffer allocation failure')
      GENINFO (NETNOSTATE, %ASCII'NETACP - no state transition')
      GENINFO (NETRCVPKT, %ASCII'NETACP - no receive I/O packet')
      GENINFO (NETSYSSRV, %ASCII'NETACP - unexpected system service failure')
      GENINFO (NETTRANCNT, %ASCII'NETACP - transaction count zero')
      GENINFO (NOACPCHAN, %ASCII'Failure to assign ACP channel')
      GENINFO (NOACPMAIL, %ASCII'Failure to create ACP mailbox')
      GENINFO (NOAQBACP, %ASCII'No AQB for ACP')
      GENINFO (NOBUFPCKT, %ASCII'Required buffer packet not present')
      GENINFO (NOBVPVCB, %ASCII'Blocked volume virtual page not found in VCB')
      GENINFO (NOMULTBK, %ASCII'ACP multiple block buffering not supported yet')
      GENINFO (NONEXSTACP, %ASCII'Nonexistent ACP process')
      GENINFO (NORCVBUF, %ASCII'NETACP - no receive buffer available')
      GENINFO (NOTDDBDDB, %ASCII'Corrupted DDB list')
      GENINFO (NOTFCBFCB, %ASCII'FCB linkage broken')
      GENINFO (NOTFCBWCB, %ASCII'Bad FCB pointer in window')
      GENINFO (NOTFCPWCB, %ASCII'Not FCP window in IRP')
      GENINFO (NOTIRPAQB, %ASCII'Not IRP pointer in AQB')
      GENINFO (NOTMTLMTL, %ASCII'Corrupted mounted volume list')
      GENINFO (NOTPCB, %ASCII'Structure not PCB')
      GENINFO (NOTRVTVCB, %ASCII'Not RVT pointer in VCB')
      GENINFO (NOTUCBIRP, %ASCII'Not UCB pointer in IRP')
      GENINFO (NOTUCBRVT, %ASCII'Not UCB pointer in RVT')
      GENINFO (NOTUCBUCB, %ASCII'Corrupted UCB list')
      GENINFO (NOTVCBUCB, %ASCII'Not VCB pointer in UCB')
      GENINFO (NOTVVPVCB, %ASCII'Not volume virtual page pointer in VCB')
      GENINFO (NOTWCBIRP, %ASCII'Not WCB Pointer in IRP')
      GENINFO (NOUSRWCS, %ASCII'No user WCS halt restart')
      GENINFO (OUTSWPERR, %ASCII'Outswap write error')
      GENINFO (PAGEREDERR, %ASCII'Page read error')
      GENINFO (PAGEWRTERR, %ASCII'Page write error')
      GENINFO (PAGNTRNVAL, %ASCII'Page not in transition or valid')
      GENINFO (PFNLISTCNT, %ASCII'Inconsistent PFN list count')
      GENINFO (PFNREFNZRO, %ASCII'PFN reference count nonzero')
      GENINFO (PGFGBLBAD, %ASCII'Pagefault, global page table entry bad format')
      GENINFO (PGFIPLHI, %ASCII'Pagefault with IPL too high')
      GENINFO (PGFLOCBAD, %ASCII'Pagefault, location field has bad value')
      GENINFO (PROCGONE, %ASCII'Process not in system')
      GENINFO (PTELENVIOL, %ASCII'Unexpected page table length violation')
      GENINFO (PTRCNT, %ASCII'ACP block count exceeds retrieval pointer size')
      GENINFO (PURGWSSCN, %ASCII'Purge working set scan error')
      GENINFO (INCON_SCHED, %ASCII'Inconsistent scheduling state')
      GENINFO (RDSNONRES, %ASCII'Read data substitute page nonresident')
      GENINFO (REFCNTNEG, %ASCII'PFN reference count is negative')
      GENINFO (RMSBUG, %ASCII'RMS has detected an invalid condition')
      GENINFO (SCANDEADPT, %ASCII'Scan dead page table error')
      GENINFO (SECREFNEG, %ASCII'Section reference count went negative')
      GENINFO (SHRCNTNEG, %ASCII'PFN share count negative')
      GENINFO (SSRVEXCEPT, %ASCII'Unexpected system service exception')
      GENINFO (STRNOTWCB, %ASCII'Data structure not window block')
      GENINFO (SWAPWSLE, %ASCII'Swap working set list entries error')
      GENINFO (SYSADJWSL, %ASCII'System service adjust working set limit error')
      GENINFO (SYSTRMERR, %ASCII'SYSINIT-terminal IO error')
      GENINFO (TIPCUFLOW, %ASCII'NETACP - transmit count underflow')
      GENINFO (UBMAPEXCED, %ASCII'UNIBUS map register allocation exceeded')
      GENINFO (UNABLCREVA, %ASCII'Unable to create virtual address space')
      GENINFO (UNEXPIOINT, %ASCII'Unexpected I/O adapter interrupt')
      GENINFO (UNKRSTRT, %ASCII'Unknown restart code')
      GENINFO (UNXINTEXC, %ASCII'Unexpected interrupt or exception')
      GENINFO (UNXSIGNAL, %ASCII'Unexpected signal name in ACP')
      GENINFO (VBNMAPFAIL, %ASCII'Virtual block map failure')
      GENINFO (WACKQEMPTY, %ASCII'NETACP - ack wait queue empty')
      GENINFO (WRTINVBUF, %ASCII'ACP attempted to write an invalid buffer')
      GENINFO (WRTINVHDR, %ASCII'ACP attempted to write an invalid file header')
      GENINFO (WRTPGSBAK, %ASCII'Write pages back - inconsistent data base')
      GENINFO (WSLENOVAL, %ASCII'Working set list entry not valid')
      GENINFO (WSLPAGCNT, %ASCII'Working set list page count error')
      GENINFO (WSLVANVAL, %ASCII'Working set list virtual adr has non-valid PTE')
      GENINFO (WSLXVANMAT, %ASCII'Working set list entry does not match VA')
      GENINFO (ZEROPAGE, %ASCII'Zero page table entry from swap map')
      GENINFO ( OPERATOR, %ASCII'Operator requested system shutdown')
      GENINFO (BADQHDR, %ASCII'Interlocked queue header corrupted')
      GENINFO (UNKNPRQ, %ASCII'Unknown Inter-processor Request Message')
      GENINFO (BDPPURGERR, %ASCII'Buffered datapath purge incomplete')
      GENINFO (BRDMSGLOST, %ASCII'Broadcast queue pointer has no related entry')
      GENINFO (	MBACBHUNG, %ASCII'MBA CBHUNG bit set')
      GENINFO (ACPRECURS, %ASCII'Attempted recursion in ACP secondary operation')
      GENINFO (ACPUNSTAK, %ASCII'Attempted unstack in ACP primary context')
      GENINFO (BADRVNWCB, %ASCII'Inconsistent RVN in window map pointer')
      GENINFO (ERRCACHFUL, %ASCII'Error cache is full')
      GENINFO (EXTCACHIV, %ASCII'Contents of extent cache is garbage')
      GENINFO (MAPCNTZER, %ASCII'Attempted to generate zero length map pointer')
      GENINFO (NOTUCBWCB, %ASCII'Bad UCB pointer in window')
      GENINFO (CHMVEC, %ASCII'CHM vector bits <1:0> not 0')
      GENINFO (FILCNTNONZ, %ASCII'Open file count nonzero after process rundown')
      GENINFO (WSSIZEERR, %ASCII'Working set size less than pages in use')
      GENINFO (DEQSUBLCKS, %ASCII'Tried to dequeue lock with sublocks')
      GENINFO (LKBREFNEG, %ASCII'LKB reference count negative')
      GENINFO (RSBREFNEG, %ASCII'RSB reference count negative')
      GENINFO (RSBREFNZRO, %ASCII'Tried to deallocate RSB with non-zero ref. count')
      GENINFO (SCBRDERR, %ASCII'SCB physical read error halt')
      GENINFO (STATENTSVD, %ASCII'Software state not saved during powerfail')
      GENINFO (LKBGRANTED, %ASCII'LKB is granted, but shouldnt be')
      GENINFO (NOTLKB, %ASCII'Structure is not an LKB')
      GENINFO (INVRSPID, %ASCII'RSPID not valid')
      GENINFO (WCBFCBMNG, %ASCII'WCB/FCB correspondence broken')
      GENINFO (NOTWCBWCB, %ASCII'Corrupted WCB list')
      GENINFO (UDAPORT, %ASCII'Fatal error detected by UDA port driver (PUDRIVER)')
      GENINFO (DISKCLASS, %ASCII'Fatal error detected by Disk Class driver (DUDRIVER)')
      GENINFO (CIPORT, %ASCII'Fatal error detected by CI port driver (PADRIVER)')
      GENINFO (NODEFFONT, %ASCII'Default font not in system font queue.')
      GENINFO (BADDOP, %ASCII'Error in DOP data')
      GENINFO (VWSNONPOOL, %ASCII'Insufficient nonpaged pool to continue drawing')
      GENINFO (VWSNOPPOOL, %ASCII'Insufficient paged pool to continue drawing')
      GENINFO (BADBITMAPID, %ASCII'Invalid bitmap ID specified in DOP')
      GENINFO (VWS1, %ASCII'Workstation bugcheck code #1')
      GENINFO (RUF, %ASCII'Fatal error detected by Recovery Unit Facility')
      GENINFO (TAPECLASS, %ASCII'Fatal error detected by Tape Class driver (TUDRIVER)')
      GENINFO (LOCKMGRERR, %ASCII'Error detected by Lock Manager')
      GENINFO (CNXMGRERR, %ASCII'Error detected by VMScluster Connection Manager')
      GENINFO (XQPERR, %ASCII'Error detected by file system XQP')
      GENINFO (INVLOCKID, %ASCII'Invalid lock id.')
      GENINFO (SBIAERROR, %ASCII'Fatal SBIA error')
      GENINFO (WCSCORR, %ASCII'WCS error correction failed')
      GENINFO (CPUCEASED, %ASCII'CPU ceased execution')
      GENINFO (CLUEXIT, %ASCII'Node voluntarily exiting VMScluster')
      GENINFO (UNSUPRTCPU, %ASCII'Unsupported CPU')
      GENINFO (VWS2, %ASCII'Workstation bugcheck code #2')
      GENINFO (VWS3, %ASCII'Workstation bugcheck code #3')
      GENINFO (OUTOFSYNC, %ASCII'Processor clocks out of synch')
      GENINFO (IVBYTEALGN, %ASCII'Invalid byte alignment for I/O transfer')
      GENINFO (ACCVIOMCHK, %ASCII'ACV or TNV during machine check exception')
      GENINFO (ACCVIOKSTK, %ASCII'ACV or TNV during kernel stack not valid exception')
      GENINFO (MSCPSERV, %ASCII'Fatal error detected by MSCP server')
      GENINFO (RESEXH, %ASCII'Resources exhausted, system shutting down')
      GENINFO (CONSOLRX50, %ASCII'Fatal error detected by Console RX50 driver')
      GENINFO (KRPEMPTY, %ASCII'P1 lookaside list is empty')
      GENINFO (MSCPCLASS, %ASCII'Fatal error detected by MSCP class driver')
      GENINFO (ICONCLUDAT, %ASCII'Inconsistent Cluster data base')
      GENINFO (OPERCRASH, %ASCII'Operator forced system crash')
      GENINFO (INSFPOOL, %ASCII'Insufficient nonpaged pool to remaster locks on this system')
      GENINFO (INSFLOCKID, %ASCII'Insufficient lockids to remaster locks on this system')
      GENINFO (CTERM, %ASCII'Fatal error detected by CTERM driver (CTDRIVER)')
      GENINFO (IVDSKCONFG, %ASCII'Invalid Disk Configuration')
      GENINFO (UCODEREV, %ASCII'CPU or CI port microcode rev inadequate for CI activity')
      GENINFO (MPCPUCEASED, %ASCII'Secondary CPU ceased execution')
      GENINFO (DUPCLASS, %ASCII'Fatal error detected by FYDRIVER')
      GENINFO (CWSERR, %ASCII'Error detected while processing cluster-wide service request')
      GENINFO (VWS4, %ASCII'Workstation bugcheck code #4')
      GENINFO (VWS5, %ASCII'Workstation bugcheck code #5')
      GENINFO (VWS6, %ASCII'Workstation bugcheck code #6')
      GENINFO (CPUEXIT, %ASCII'Shutdown requested by another CPU')
      GENINFO (SPLACQERR, %ASCII'Spinlock(s) of higher rank already owned by CPU')
      GENINFO (SPLRELERR, %ASCII'Spinlock to be released is not owned')
      GENINFO (SPLRSTERR, %ASCII'Spinlock to be conditionally released is not owned')
      GENINFO (SPLIPLLOW, %ASCII'IPL has fallen below level of owned spinlock(s)')
      GENINFO (SPLIPLHIGH, %ASCII'Current IPL exceeds synchronization IPL of desired spinlock')
      GENINFO (SPLNOTSPL, %ASCII'Not a spinlock structure')
      GENINFO (SPLINVIPL, %ASCII'New spinlock IPL too low')
      GENINFO (SPLNOTMAP, %ASCII'Spinlock address was not found in rank map')
      GENINFO (VAXPORT, %ASCII'Fatal error detected by VAX port driver')
      GENINFO (CLUSWVER, %ASCII'Software version incompatible with existing VMScluster')
      GENINFO (BADVECTOR, %ASCII'Inconsistency found while loading a system service vector')
      GENINFO (SSVECFULL, %ASCII'Ran out of system service vector numbers')
      GENINFO (PFNFIXUP, %ASCII'Instruction mismatch during PFN fixups')
      GENINFO (BADRTPRI, %ASCII'Real-time current priority not equal to base priority')
      GENINFO (ILLQBUSCFG, %ASCII'Illegal Qbus configuration detected by interrupt dispatcher')
      GENINFO (WATCHPOINT, %ASCII'Watchpoint encountered by the watchpoint driver (WPDRIVER)>')
      GENINFO (WPDRVRERR, %ASCII'Fatal error detected in the watchpoint driver (WPDRIVER)>')
      GENINFO (NOTSYSVA, %ASCII'Not a system virtual address')
      GENINFO (TTDRVR, %ASCII'No more fork blocks')
      GENINFO (BADPRCPGFLX, %ASCII'PTE contains bad process pagefile index')
      GENINFO (BADPPFLREFCNT, %ASCII'Process page file reference count is invalid')
      GENINFO (BADPRCPGFLC, %ASCII'Current process pagefile assignment is invalid')
      GENINFO (PFLREFNEG, %ASCII'PFL reference count negative')
      GENINFO (NOPRCPGFL, %ASCII'Failure to assign process pagefile')
      GENINFO (CPUSANITY, %ASCII'CPU sanity timer expired')
      GENINFO (CPUBUSYWAIT, %ASCII'CPU miscellaneous busywait timer expired')
      GENINFO (POOLCHECK, %ASCII'Corruption or inconsistency in pool discovered by pool checker')
      GENINFO (CPUSPINWAIT, %ASCII'CPU spinwait timer expired')
      GENINFO (DISKSERVE, %ASCII'Error detected during attempt to MSCP serve disk')
      GENINFO (VAXCLUSTER, %ASCII'Error detected by VMScluster software')
      GENINFO (FATMEMERR, %ASCII'Fatal memory error detected')
      GENINFO (TTDRVR1, %ASCII'TTDRVR bugcheck code #1')
      GENINFO (CPUNOTPRIMARY, %ASCII'Primary-only operation attempted on secondary CPU')
      GENINFO (LICENSERR, %ASCII'Fatal software licensing inconsistency')
      GENINFO (NOCONSBUFF, %ASCII'Unable to allocate console disk data buffers')
      GENINFO (NETDLLERR, %ASCII'DECnet Datalink Layer detected a fatal error')
      GENINFO (NETRTGERR, %ASCII'DECnet Routing Layer detected a fatal error')
      GENINFO (NETECLERR, %ASCII'DECnet End Communication Layer detected a fatal error')
      GENINFO (NETSESERR, %ASCII'DECnet Session Layer detected a fatal error')
      GENINFO (MULDEALNPAG, %ASCII'Multiple deallocation of nonpaged pool')
      GENINFO (PPGFLVANEG, %ASCII'PPGFLVA count in PHD is negative')
      GENINFO (SECAUDEXH, %ASCII'Security auditing shutdown due to resource exhaustion')
      GENINFO ( SECURITY1, %ASCII'SECURITY bugcheck code #1')
      GENINFO ( SECURITY2, %ASCII'SECURITY bugcheck code #2')
      GENINFO (MCHKMCHK, %ASCII'Machine check during machine check exception')
      GENINFO (MCHKSTKNV, %ASCII'Machine check during kernel stack not valid exception')
      GENINFO (WRONGPRIMARY, %ASCII'Console restarted wrong CPU as primary after power failure')
      GENINFO (INVPFLMAP, %ASCII'Invalid page file mapping window')
      GENINFO (SECAUDERR, %ASCII'Fatal error attempting to perform a security audit')
      GENINFO ( DSSIPORT, %ASCII'Fatal error detected by DSSI port driver (PIDRIVER)')
      GENINFO ( DECWINDOWS, %ASCII'DECwindows fatal error')
      GENINFO (DDTMBUG, %ASCII'DDTM has detected an invalid condition')
      GENINFO (IPCBUG, %ASCII'IPC has detected an invalid condition')
      GENINFO (CSLBUG, %ASCII'CSL has detected an invalid condition')
      GENINFO (LOGFAIL, %ASCII'Fatal write error to system log')
      GENINFO ( VMSTESTERR, %ASCII'VMSTEST fatal error (REF: $HELP @SYS$TEST:VMSTEST BUGCODE)>')
      GENINFO (VPIPLHIGH, %ASCII'IPL too high to use the Vector Facility')
      GENINFO (VPERR, %ASCII'Fatal error detected by the Vector Facility')
      GENINFO (BADSETFUNC, %ASCII'Bad SET function detected by CTDRIVER')
      GENINFO (DCBCNTRBAD, %ASCII'DCB counter not zero when DECnet output task is idle (CTDRIVER)')
      GENINFO (NOTIDLE, %ASCII'DECnet output task not idle when flag clear (CTDRIVER)')
      GENINFO (INVCTERMMSG, %ASCII'Invalid CTERM message with matching IRP')
      GENINFO (	SCSIPORT, %ASCII'Fatal error detected by SCSI port driver (PK%DRIVER)')
      GENINFO (CORRUPTEMB, %ASCII'EMB packet header has been corrupted')
      GENINFO (SHADDETINCON, %ASCII'SHADOWING detects inconsistent state.')
      GENINFO (GFX_INVTB, %ASCII'Extended Graphics Invalidation Error')
      GENINFO (TOOMANYUIDS, %ASCII'Too many UIDs generated in one clock tick')
      GENINFO (SHADBOOTFAIL, %ASCII'SHADOWING failed to boot from system disk shadow set.')
      GENINFO (DECNET, %ASCII'DECnet detected a fatal error')
      GENINFO (REMOTE_AGENT, %ASCII'Remote privileged agent requested system crash')
      GENINFO (CUSTOMER, %ASCII'Reserved for customer use')
      GENINFO (RSVD_ISV, %ASCII'Reserved for non-Digital product use')
      GENINFO (RSVD_LP, %ASCII'Reserved for Digital layered product use')
      GENINFO (SEQ_NUM_OVF, %ASCII'Sequence number overflow')
      GENINFO (INCON_SHELL, %ASCII'Inconsistent SHELL state')
      GENINFO (INCONMMGST, %ASCII'Inconsistent memory management state')
      GENINFO (BADHOMEBLK, %ASCII'Bad checksum on home block')
      GENINFO (BADINDEXHDR, %ASCII'Bad checksum on index file header')
      GENINFO (BADROOTHDR, %ASCII'Bad checksum on root directory file header')
      GENINFO (BADFILEHDR, %ASCII'Bad checksum on file header')
      GENINFO (NOSUCHFILE, %ASCII'Unable to locate bootstrap file')
      GENINFO (UNABLCREVM, %ASCII'Unable to create virtual memory space')
      GENINFO (L1PTNOTMAP, %ASCII'Failed to map level 1 page table')
      GENINFO (L1PTNOTUNMAP, %ASCII'Failed to unmap level 1 page table')
      GENINFO (L2PTNOTUNMAP, %ASCII'Failed to unmap level 2 page table')
      GENINFO (INCON_CONSOLE, %ASCII'Inconsistent console terminal state')
      GENINFO (DEBUGCRASH, %ASCII'Debugger forced system crash')
      GENINFO (INV_MAPREG_PAR, %ASCII'Invalid map register parameter')
      GENINFO (INVSCBB, %ASCII'Invalid System Control Block Base')
      GENINFO (INVPTBR, %ASCII'Invalid Page Table Base Register')
      GENINFO (IOMBXERR, %ASCII'I/O Mailbox Error')
      GENINFO (POSIXBUG, %ASCII'Fatal internal error detected in VMS/POSIX')
      GENINFO (CTRLERR, %ASCII'Controller error')
      GENINFO (IOMACHINECHK, %ASCII'I/O induced machine check')
      GENINFO (NOCALLTRANS, %ASCII'Inner mode native code cannot call translated code')
      GENINFO (SECOSRERR, %ASCII'Fatal error detected by security object support routine')
      GENINFO (REGCORDET, %ASCII'Register corruption detected after fork')
      GENINFO (NSABLOST, %ASCII'Security audit block stranded in non-paged pool')
      GENINFO (SECAUDTCB, %ASCII'Security auditing failure reported by TCB')
      GENINFO (SECIPLHIGH, %ASCII'Security subsystem detected IPL too high')
      GENINFO (SYSAPLERR, %ASCII'System process detected fatal error')
      GENINFO (ASSERTFAIL, %ASCII'System ASSERT failure detected')
      GENINFO (TMSCPSERV, %ASCII'Fatal error detected by TMSCP server')
      GENINFO (F64ERR, %ASCII'Fatal error detected by Files-64 file system')
      GENINFO (LFSERR, %ASCII'Fatal error detected by LFS')
      GENINFO (XFSCERR, %ASCII'Fatal error detected by XFS client')
      GENINFO (XFSSERR, %ASCII'Fatal error detected by XFS server')
      GENINFO (INSF_NONPAGED, %ASCII'Insufficient nonpaged pool')
      GENINFO (SHADZEROMBR, %ASCII'SHADOWING detects a zero member set.')

      !New messages get added before this point. ***
      PLACE_HOLDER
      PLACE_HOLDER

      ! This is a place holder for the last bugcheck code. This is needed
      ! so that we can figure out if a bugcheck code is in range or not in
      ! SDA and other tools. No bugcheck codes should be added after this
      ! bugcheck code.
      GENINFO (LASTBUG, %ASCII'Place holder for last bugcheck code')
      ENDMSG
    %;
%FI

! IOGEN_MACROS.REQ
!
! Macros used by autoconfiguration routines
!
! Version:	'X-6'
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1991, 1992 BY						    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:	System Library
!
! ABSTRACT:
!
!	These are common macros used by Alpha autoconfiguration routines.
!
! ENVIRONMENT:
!
!	Autoconfigration routines typically run in exec mode at IPL 0.
!
! MODIFICATION HISTORY:
!
!	X-6	SWA             Scott W. Apgar                  24-Aug-1994
!               Add the novector loading flag to the flags longword of the 
!               config table.
!
!	X-5	JPJ   		James P. Janetos     		30-Aug-1993
!               Make the iogen config table a global structure so that
!               it can be referenced in modules other than the one in
!               which it is declared.
!
!	X-4	JPJ   		James P. Janetos     		27-Oct-1992
!               Add num_units field to iogen$build_config_table macro.
!
!	X-3	JPJ   		James P. Janetos     		20-Aug-1992
!               Change hw_id_mask in iogen$build_config_table from a longword
!               to a quadword.  Change the hw_id field in each entry in the
!               config table to a quadword.
!
!               Reset CMS generation number (reserved as generation 2).
!
!	X-4	RWC077		Richard W. Critz, Jr.		11-Mar-1992
!		Remove all support for the MSCP flag in the config table.
!		
!	X-3	RWC064		Richard W. Critz, Jr.		20-Dec-1991
!		Add IOGEN_CFG_TBL$L_HW_ID_MASK since it was inadvertantly
!		omitted.
!		
!	X-2	RWC060		Richard W. Critz, Jr.		18-Dec-1991
!		Fix IOGEN$CALL_KERNEL_ROUTINE to handle zero arguments
!		correctly.  Update documentation to reflect what
!		IOGEN$BUILD_CONFIG_TABLE actually does.  Fix IOGEN$BUILD_ABM to
!		handle more than 2 adapter types.  Change names associated with
!		the config table to fix a build breaker.
!
!	X-1	JTK		Jim Klumpp			12-Dec-1991
!		Initial version.
!		
!--
!
!
! AUTHOR:  Jim Klumpp		 CREATION DATE:  12-Dec-1991

! IOGEN$CALL_KERNEL_ROUTINE
!                   
! This macro is used to call a routine in kernel mode. Since autoconfiguration
! routines typically run in exec mode, they can read - but not write - the system
! I/O database. Whenever the I/O database needs to be updated, for example when
! the no reconnect bit is set in a bus array entry, a kernel mode routine must
! be called. This macro simply makes calling the kernel mode routine easier. A
! typical invocation of this macro is:
!
!	STATUS = CALL_KERNEL_ROUTINE (SET_NORECONNECT, .BUS_ARRAY_ENTRY);

MACRO
    iogen$call_kernel_routine (routine_name) [] =
        BEGIN

        EXTERNAL ROUTINE
            sys$cmkrnl;

        LOCAL
            arglist: VECTOR [%LENGTH, LONG, SIGNED] INITIAL (LONG (%LENGTH-1
		%IF %LENGTH GTR 1 %THEN , %REMAINING %FI));

        sys$cmkrnl (routine_name, arglist)
        END %;

! IOGEN$BUILD_ABM
!
! This macro builds an autoconfiguration bus mapping table. This table 
! associates adapter types with autoconfiguration routines to invoke 
! when an ADP with that type is found. The table has the following format:
!
!	+-----------------------+
!	|     Adapter type	|
!	+-----------------------+
!	|   Autoconfig routine	|
!	+-----------------------+
!	|     Adapter type	|
!	+-----------------------+
!	|   Autoconfig routine	|
!	+-----------------------+
!	|	    .		|
!	|	    .		|
!	+-----------------------+
!	|	    0		|
!	+-----------------------+
!	|	    0		|
!	+-----------------------+
!
! A typical invocation of this macro is:
!
! IOGEN$BUILD_ABM (LASER_ABM,
!
!	Adapter type		Configuration routine
!	------------		---------------------
!	AT$_XMI,		IOGEN$XMI_CONFIG,
!	AT$_FBUS,       	IOGEN$FBUS_CONFIG);

MACRO
    iogen$build_abm (table_name, adap_type, config_routine) [] =
        %IF %COUNT EQL 0 %THEN
            bind table_name = uplit long (adap_type, config_routine, iogen$build_abm (table_name, %REMAINING) 0, 0);
        %ELSE
            adap_type, config_routine, iogen$build_abm (table_name, %REMAINING)
        %FI
    %;

! IOGEN$BUILD_CONFIG_TABLE
!
! The following macros build an autoconfiguration table. These tables
! associate a hardware ID which is read from the device configuration
! register with the device name and driver to load for the device. In
! addition, the table contains a count of interrupt vectors required 
! for the device and a set of flags used to perform special actions such
! as loading the SCSI class drivers.
!
! The table has a header with the following format:
!
!        31                           0
!	+------------------------------+
!	|  Hardware ID bitmask (31:0)  |
!	+------------------------------+
!	|  Hardware ID bitmask (63:32) |
!	+------------------------------+
!
! The hardware ID bitmask can be ANDed with the hardware ID from the
! bus array entry to extract the device identification information.
! The result can then be compared with the hardware ID field from each
! entry in the configuration table. The format of a table entry is:
!
!	 31		       0
!	+-----------------------+
!	|   Hardware ID (31:00)	|
!	+-----------------------+
!	|   Hardware ID (63:32)	|
!	+-----------------------+
!	|  Driver name (ascid)	|
!	+-----------------------+
!	|  Device name (ascii)	|
!	+-----------------------+
!	|     Vector count	|
!	+-----------------------+
!	|   Vector alignment	|
!	+-----------------------+
!	|    Number of units	|
!	+-----------------------+
!	|	 Flags		|
!	+-----------------------+
!
! The table is terminated with a quadword of zero.
!
! A typical invocation of this macro is:
!
!   BUILD_CONFIG_TABLE (XMI_CONFIG_TABLE, hw_id_mask_lo, hw_id_mask_hi,
!
!	HW ID LO     HW ID HI   Driver name	Device 	Vecs Align Num_units Flags
!	----------   --------   -----------	------	---- ----- --------- -----
!	NDT$_XZA_SCSI,	0,      SYS$PKZDRIVER,	PK,	4,    0,      1,     SCSI,
!	NDT$_XZA_DSSI,	0,      SYS$PIDRIVER,	PN,	4,    0,      1,     0,
!	NDT$_DEMNA,	0,      SYS$EXDRIVER,	EX,	1,    0,      1,     0,
!	NDT$_KDM70,	0,      SYS$PUDRIVER,	PU,	1,    0,      1,     0,
!	NDT$_CIMNA,	0,      SYS$PNDRIVER,	PN,	4,    0,      1,     0);
!
MACRO
    iogen$build_config_table (
        table_name, hardware_id_mask_lo, hardware_id_mask_hi, 
                hardware_id_lo, hardware_id_hi, driver_name, device_name, vector_count, vector_align, num_units, flags) [] =
        %IF %COUNT EQL 0 %THEN
            GLOBAL
                table_name : ALIAS BLOCKVECTOR [(%LENGTH/8)+1, iogen_cfg_tbl$k_entry_size, BYTE]
                    INITIAL (LONG (hardware_id_mask_lo, 
                                   hardware_id_mask_hi,
                                   hardware_id_lo, 
                                   hardware_id_hi, 
                                   %ASCID %STRING (driver_name),
                                   UPLIT BYTE (%ASCII %STRING (device_name)), 
                                   vector_count,
                                   vector_align,
                                   num_units,
                                   iogen$parse_flags (%REMOVE (flags))
                                   iogen$build_config_table (table_name, 0, 0, %REMAINING), 0, 0));
        %ELSE
            , hardware_id_lo
            , hardware_id_hi
            , %ASCID %STRING (driver_name)
            , UPLIT BYTE (%ASCII %STRING (device_name))
            , vector_count
            , vector_align
            , num_units
            , iogen$parse_flags (%REMOVE (flags))
            iogen$build_config_table (table_name, 0, 0, %REMAINING)
        %FI
    %,

    iogen$parse_flags (flag) [] = 
        BEGIN
        %IF %IDENTICAL (0, flag) %THEN
            0
        %ELSE 
            %NAME ('iogen_cfg_tbl$m_', flag) 
            %IF %LENGTH GTR 1 %THEN
                + iogen$parse_flags (%REMAINING)
            %FI
        %FI
        END %,

    iogen_cfg_tbl$l_hw_id_mask    = 0, 0, 32, 0 %,
    iogen_cfg_tbl$l_hw_id_mask_lo = 0, 0, 32, 0 %,
    iogen_cfg_tbl$l_hw_id_mask_hi = 4, 0, 32, 0 %,
    iogen_cfg_tbl$q_hw_id_mask    = 0, 0, 64, 0 %,
    
    iogen_cfg_tbl$l_hw_id        = 0, 0, 32, 0 %,
    iogen_cfg_tbl$l_hw_id_lo     = 0, 0, 32, 0 %,
    iogen_cfg_tbl$l_hw_id_hi     = 4, 0, 32, 0 %,
    iogen_cfg_tbl$q_hw_id        = 0, 0, 64, 0 %,
    iogen_cfg_tbl$ps_driver_name = 8, 0, 32, 1 %,
    iogen_cfg_tbl$ps_devnam      = 12, 0, 32, 1 %,
    iogen_cfg_tbl$l_vector_cnt   = 16, 0, 32, 0 %,
    iogen_cfg_tbl$l_vector_align = 20, 0, 32, 0 %,
    iogen_cfg_tbl$l_num_units    = 24, 0, 32, 0 %,
    iogen_cfg_tbl$l_flags        = 28, 0, 32, 0 %,
    iogen_cfg_tbl$v_scsi         = 28, 1, 1, 0 %,
    iogen_cfg_tbl$v_novector     = 28, 2, 1, 0 %;

LITERAL
    iogen_cfg_tbl$k_header_len = 8,
    iogen_cfg_tbl$k_entry_size = 32,
    iogen_cfg_tbl$m_scsi = 2,
    iogen_cfg_tbl$m_novector = 4;
