!Version:	X-34
!
! COPYRIGHT (c) 1988 BY
! DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
! ALL RIGHTS RESERVED.
!
! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
! ONLY  IN  ACCORDANCE  OF  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
! INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
! COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
! OTHER PERSON.  NO TITLE TO AND  OWNERSHIP OF THE  SOFTWARE IS  HEREBY
! TRANSFERRED.
!
! THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
! AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
! CORPORATION.
!
! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.

!++
! FACILITY:
! 
!   VMSLIB -- VMS-MACROS.REQ
! 
! ABSTRACT:
! 
!   This module contains a lot of handy macros for systems programming in
!   BLISS.  They are of a general sort, and will be included in LIB.REQ and
!   LIB.L32.
! 
! AUTHORS:
! 
!   VMS Development
! 
! CREATION DATE: 13 September, 1988
! 
! MODIFICATION HISTORY:
!
!	X-34	JLBB0015	J.L. Berg		26-Apr-1991
!		Fixup EXE$CLEANUP_ORB_LINKAGE declaration.
!
!	X-33	JLBBP01		J.L. Berg		28-Feb-1991
!		Added linkages for a number of routines.  Added some
!		driver support macros. Add initialization routine macro.
!
!	X-32	Ray Guzman made some linkage and other changes, but forgot
!		to write a header.
!
!	X-6	CAM0088		Christopher A. Mega	16-Nov-1989
!		Fix $INSQHI, $INSQTI, $REMQHI, $REMQTI macros.  Fixes
!		provided by Dave Marsh, Reading.  Change involves swapping
!		parameters to macros, and updating them to return the
!		correct status of the actual queue operation.
!		Bump version to match CMS generation
!
!	X-4	JDC0558		Jon Callas		 3-NOV-1989
!		$PROBE is not preserving R1 and R2 properly.
!
!       X-3	DDP0393		Derrell D. Piper       28-JUL-1989  14:16
!		Move UTLDEFB to here.  Add a couple of new macros:
!		    $xxx_WITH_RETRY
!		    $MOVE_QUAD
!		    $SAY
!		    $XDELTA
!
!	X-2	EMB0423		Ellen M. Batbouta	21-Jul-1989
!		Add $INSQHI, $INSQTI, $REMQHI and $REMQTI.
!
!	X-1	JDC0407		Jon Callas		13-SEP-1988
!		Create module.
!--


LINKAGE
    COM$DELATTNAST_lINKAGE = 
	JSB ( REGISTER = 4, 				! Attention AST listhead address
	      REGISTER = 5 ) :				! UCB address
	PRESERVE (0,1,2,3,4,5,6,7)
	NOTUSED (8,9,10,11),

    COM$DRVDEALMEM_LINKAGE = 
	JSB  (REGISTER = 0):				! Address of block to be deallocated
	PRESERVE (0,1,2,3,4,5)
	NOTUSED (6,7,8,9,10,11),

    COM$FLUSHATTNS_LINKAGE = 
	JSB (REGISTER = 4, 				! PCB address
	     REGISTER = 5, 				! UCB address
	     REGISTER = 6,  				! Number of the assigned I/O channel
	     REGISTER = 7) :				! AST listhead address - destroyed on output
	PRESERVE    (3,4,5,6)
	NOPRESERVE  (0,1,2,7)				! R0 returns SS$_NORMAL, R1 and R2 are scratch.
	NOTUSED (8,9,10,11),

    COM$POST_LINKAGE = 
    ! Note: R1 is documented as not being presrved
	JSB (REGISTER = 3, 				! IRP address
	     REGISTER = 5):				! UCB address
	PRESERVE (1,2,3,4,5)
	NOPRESERVE (0)					! R0, R1 scratch
	NOTUSED (6,7,8,9,10,11),

    COM$SETATTNAST_LINKAGE = 
	JSB (REGISTER = 3,				! IRP address
	     REGISTER = 4, 				! PCB address
	     REGISTER = 5, 				! UCB address 
	     REGISTER = 7 ) :				! AST listhead address - destroyed on output
	PRESERVE (3,4,5,9,10)		
	NOPRESERVE (0,1,2,6,7,8),			! R1, R2, R8 scratch

    DEVICEDRIVER_FDT_LINKAGE = 
	JSB (REGISTER = 3, 				! IRP address
	     REGISTER = 4,				! PCB address
	     REGISTER = 5,				! UCB address
	     REGISTER = 6,				! CCB address
	     REGISTER = 7) :				! Function Code
	NOPRESERVE (0,1,2,9,10,11)			! R0, R1, R2, R9, R10, R11 scratch
	PRESERVE (3,4,5,6,7,8),				! Preserve R3 thru R8

     DEVICEDRIVER_SEL_CANCEL_LINKAGE = 
	JSB (REGISTER = 4,				! Address of PCB (Process Control Block)
	     REGISTER = 5,				! Address of UCB (Unit Control Block)
	     REGISTER = 6,				! Negative channel index number
	     REGISTER = 7,				! Address of a vector of IOSBs of I/O requests to be cancelled
	     REGISTER = 8) :				! Number of I/O requests in IOSB vector

	PRESERVE (1,2,3,4,5,6,7,8,9,10,11)		
	NOPRESERVE (0),					

     DEVICEDRIVER_CANCEL_LINKAGE = 
	JSB (REGISTER = 2,				! Negative channel index number
	     REGISTER = 3,				! address of IRP (I/O Request Packet)
	     REGISTER = 4,				! Address of PCB (Process Control Block)
	     REGISTER = 5,				! Address of UCB (Unit Control Block)
	     REGISTER = 8) :				! Cancellation reason

	PRESERVE (5,6,7,8,9,10,11)			! NOTE: Device Driver manual says R0-R5 are
							!  nopreserve, however R5 must still contain the
							!  UCB address on return.
	NOPRESERVE (0,1,2,3,4),				! R0, R1, R2, R3, R4 scatch

    EXE$ABORTIO_LINKAGE = 
	JSB (REGISTER = 0, 				! Status for 1st longword of IOSB
	     REGISTER = 3, 				! IRP address
	     REGISTER = 4,				! PCB address
	     REGISTER = 5) :				! UCB address
	PRESERVE (1,2,3,4,5,6,7,8,9,10,11)		! NOTE: this is not quite accurate, however EXE$ABORTIO
							!  will issue a RET - restoring registers and cleaning up the
							!  stack so the NOPRESRVE list is irrelevant and may as well be 
							!  as short as possible.  The caller of EXE$ABORTIO will not
	NOPRESERVE (0),					!  be returned to.

    EXE$ALLOCBUF_LINKAGE  = 
	JSB (REGISTER = 1;				! request size
	     REGISTER = 2):				! address of block
	NOPRESERVE (3,4) 
	PRESERVE (5) 
	NOTUSED (6,7,8,9,10,11),

    EXE$ALONONPAGED_LINKAGE = 
	JSB (REGISTER = 1;				! size of block required
	     REGISTER = 1,				! actual size of allocated block
	     REGISTER = 2) :				! address of allocated block
	PRESERVE (3,4,5,6,7,8,9,10,11),

    EXE$ALONPAGWAIT_LINKAGE = 
	JSB (REGISTER = 0,				! address of cleanup routine (0 = none)
	     REGISTER = 1;				! size of block required
	     REGISTER = 1,				! actual size of allocated block
	     REGISTER = 2) :				! address of allocated block
	NOPRESERVE (3,4,5),

    EXE$ALONPAGWAITS_LINKAGE = 
	JSB (REGISTER = 0,				! address of cleanup routine (0 = none)
	     REGISTER = 1;				! size of block required
	     REGISTER = 1,				! actual size of allocated block
	     REGISTER = 2) :				! address of allocated block
	NOPRESERVE (3,4,5),

    EXE$ALOP0IMAG_LINKAGE = 
	JSB (REGISTER = 1;				! size of block required
	     REGISTER = 1,				! actual size of allocated block
	     REGISTER = 2) :				! address of allocated block
	NOPRESERVE (3),

    EXE$ALOP1IMAG_LINKAGE = 
	JSB (REGISTER = 1;				! size of block required
	     REGISTER = 1,				! actual size of allocated block
	     REGISTER = 2) :				! address of allocated block
	NOPRESERVE (3),

    EXE$ALOP1PROC_LINKAGE = 
	JSB (REGISTER = 1;				! size of block required
	     REGISTER = 1,				! actual size of allocated block
	     REGISTER = 2) :				! address of allocated block
	NOPRESERVE (3),

    EXE$ALOPAGED_LINKAGE = 
	JSB (REGISTER = 1;				! size of block required
	     REGISTER = 1,				! actual size of allocated block
	     REGISTER = 2) :				! address of allocated block
	NOPRESERVE (3,4,5),

    EXE$CHKACCESS_LINKAGE = 
    ! CHECK ACCESS PROTECTION:
    ! G^EXE$CHKCREACCES - CHECK CREATE ACCESS
    ! G^EXE$CHKDELACCES - CHECK DELETE ACCESS
    ! G^EXE$CHKLOGACCES - CHECK LOGICAL I/O FUNCTION ACCESS
    ! G^EXE$CHKPHYACCES - CHECK PHYSICAL I/O FUNCTION ACCESS
    ! G^EXE$CHKRDACCES - CHECK READ ACCESS
    ! G^EXE$CHKWRTACCES - CHECK WRITE ACCESS
    ! G^EXE$CHKEXEACCES - CHECK EXECUTE ACCESS (IMPLIED BY READ ACCESS)
    !
    ! INPUTS:
    !	R0 = ADDRESS OF THE AGENT'S RIGHTS BLOCK
    !	R1 = ADDRESS OF THE OBJECT'S RIGHTS BLOCK
    !	R5 = 0
    !		OR
    !	R4 = ADDRESS OF THE ACCESSOR'S PCB
    !	R5 = ADDRESS OF THE OBJECT'S UCB
    !
    ! OUTPUTS:
    !	R0 = SS$_NORMAL FOR ACCESS ALLOWED
    !	R0 = SS$_NOPRIV FOR ACCESS DENIED
    !
    !	R2, R3, AND R4 ARE PRESERVED ACROSS CALL.
    ! NOTE THAT THE FOLLOWING LINKAGE DECLARATION is for the second type of
    ! access.
	JSB (REGISTER = 4, 				! PCB Address
	     REGISTER = 5):				! UCB Address
	NOPRESERVE (1)					! NOTE: I believe R1 is preserved, but to be safe...
	PRESERVE (2,3,4,5,6,7,8,9,10,11),

    EXE$CHKPRO_INT_LINKAGE = 
	JSB (REGISTER = 0,				! address of ARB	
	     REGISTER = 1,				! address of ORB
	     REGISTER = 2,				! address of CHPCTL
	     REGISTER = 3),				! address of CHPRET

    EXE$CLEANUP_ARB_LINKAGE = 
	JSB (REGISTER = 0),				! address of ARB to cleanup

    EXE$CLEANUP_ORB_LINKAGE=				! address of ORB to cleanup
	JSB(REGISTER=1):
	NOPRESERVE(2, 3),

    EXE$COPY_ARB_LINKAGE = 
	JSB (REGISTER = 0;				! address of source ARB
	     REGISTER = 1),				! address of cloned ARB

    EXE$COPY_ORB_LINKAGE = 
	JSB (REGISTER = 0;				! address of source ORB
	     REGISTER = 1),				! address of cloned ORB

    EXE$CREATE_ARB_LINKAGE = 
	JSB (;						! no input arguments
	     REGISTER = 1),				! address of new ARB

    EXE$CREATE_DEFAULT_ORB_LINKAGE = 
	JSB (REGISTER = 0;				! address of OCB
	     REGISTER = 1),				! address of cloned ORB

    EXE$CREATE_ORB_LINKAGE = 
	JSB (;						! no input arguments
	     REGISTER = 1),				! address of new ORB

    EXE$DEANONPAGED_LINKAGE = 
	JSB (REGISTER = 0):				! address of block to deallocate
	PRESERVE (4,5,6,7,8,9,10,11)
	NOPRESERVE (1,2,3),				! NOTE: SCH$RAVAIL may be called which is DOCUMENTED as
							!  destroying R3, however I don't believe it does.  In
							!  the philosophy of "better safe than sorry" however...

    EXE$DEANONPGDSIZ_LINKAGE  = 
	JSB (REGISTER = 0,				! address of block to deallocate
	     REGISTER = 1) :				! size of block to deallocate
	NOPRESERVE (2,3,4,5),
		  
    EXE$DEAP1_LINKAGE = 
	JSB (REGISTER = 0,				! address of block to deallocate
	     REGISTER = 1) :				! size of block to deallocate
	NOPRESERVE (2,3),
		  
    EXE$DEAPAGED_LINKAGE = 
	JSB (REGISTER = 0) :				! address of block to deallocate
	NOPRESERVE (2,3,4,5),
		  
    EXE$DEAPGDSIZ_LINKAGE = 
	JSB (REGISTER = 0,				! address of block to deallocate
	     REGISTER = 1) :				! size of block to deallocate
	NOPRESERVE (2,3,4,5),
		  
    EXE$DELETE_ARB_LINKAGE = 
	JSB (REGISTER = 0),				! address of ARB to delete

    EXE$DELETE_ORB_LINKAGE = 
	JSB (REGISTER = 0),				! address of ORB to delete

    EXE$EPID_TO_IPID_LINKAGE  = 
	JSB (REGISTER = 0;				! EPID to be converted
	     REGISTER = 0):				! IPID or zero if any problems
	PRESERVE (1,2,3,4,5) 
	NOTUSED (6,7,8,9,10,11),

    EXE$EPID_TO_PCB_LINKAGE = 
	JSB (REGISTER = 0;				! EPID
	     REGISTER = 0):				! PCB address or zero if any problems
	PRESERVE (1,2,3,4,5)
	NOTUSED (6,7,8,9,10,11),

    EXE$FINISHIO_LINKAGE = 
	JSB  (REGISTER = 0,				! Status for 1st longword of IOSB
	      REGISTER = 1,				! Status for second longword of IOSB
	      REGISTER = 3,				! IRP address
	      REGISTER = 4,				! PCB address
	      REGISTER = 5) :				! UCB address
	PRESERVE (1,2,3,4,5,6,7,8,9,10,11),		! See EXE$ABORTIO_LINKAGE comments

    EXE$FINISHIOC_LINKAGE = 
	JSB  (REGISTER = 0,				! Status for first longword of IOSB
	      REGISTER = 3,				! IRP address
	      REGISTER = 4,				! PCB address
	      REGISTER = 5) :				! UCB address
	NOPRESERVE (1)					! cleared 
	PRESERVE (2,3,4,5,6,7,8,9,10,11 ),		! See EXE$ABORTIO_LINKAGE comments

    EXE$IORSNWAIT_LINKAGE = 
    !	ROUTINE NOTES: CONTROL IS TRANSFERED TO EXE$ABORTIO IF NO RESOURCE WAIT
    !	HAS BEEN REQUESTED, OR TO SCH$WAIT IF RESOURCE WAIT IS REQUESTED.
	JSB (REGISTER = 0,				! Status to return if NO WAIT requested
	     REGISTER = 1,				! Resource to wait for
	     REGISTER = 3,				! IRP address
	     REGISTER = 4,				! PCB address
	     REGISTER = 5,				! UCB address
							! NOTE: documentaton for EXE$IORSNWAIT does
							!  not specify R5, but it IS required if EXE$ABORTIO
							! is called.
	     REGISTER = 6) :				! Address of CCB
	NOPRESERVE (0,1,2,3)				! R0-R3 scratch
	PRESERVE (4,5,6,7,8,9,10,11),

    EXE$IPID_TO_EPID_LINKAGE  = 
	JSB (REGISTER = 0;				! IPID to be converted
	     REGISTER = 0):				! EPID or zero if any problems
	PRESERVE (1,2,3,4,5) 
	NOTUSED (6,7,8,9,10,11),

    EXE$IPID_TO_PCB_LINKAGE = 
	JSB (REGISTER = 0;				! IPID
	     REGISTER = 0):				! PCB address or zero if any problems
	PRESERVE (1,2,3,4,5)
	NOTUSED (6,7,8,9,10,11),

    EXE$LOCATE_SEC_CLASS_LINKAGE =	
	JSB (REGISTER = 1,				! address of class_name
	     REGISTER = 2),				! address of OCB

    EXE$QIODRVPKT_LINKAGE = 
	JSB (REGISTER = 3,				! IRP address
	     REGISTER = 4, 				! PCB address
	     REGISTER = 5) : 				! UCB address
	PRESERVE (0,1,2,3,4,5,6,7,8,9,10,11),		! See EXE$ABORTIO_LINKAGE, RET is issued, so PRESERVE
							!  statement serves only to prevent BLISS from saving a
							!  buncha things it really doesn't need to.

    EXE$QIORETURN_LINKAGE = 
	JSB (REGISTER = 5):				! UCB address
	PRESERVE (0,1,2,3,4,5,6,7,8,9,10,11),		! See EXE$ABORTIO_LINKAGE, RET is issued, so PRESERVE
							!  statement serves only to prevent BLISS from saving a
							!  buncha things it really doesn't need to.

    EXE$READCHK_LINKAGE = 
	JSB (REGISTER = 0, 				! Address of buffer
	     REGISTER = 1, 				! length of buffer
	     REGISTER = 3) :				! IRP address
	PRESERVE (3,4,5,6,7,8,9,10,11)
	NOPRESERVE (0,1,2),				! R2 Scratch

    EXE$REGISTER_SEC_CLASS_LINKAGE =
	JSB (REGISTER = 1,				! address of class_name
	     REGISTER = 3,				! address of class type
	     REGISTER = 4,				! address of osrv
	     REGISTER = 5,				! address of object_class template
	     REGISTER = 2),				! address of OCB

    EXE$SEARCH_RIGHT_LINKAGE = 
	JSB (REGISTER = 2,				! identifier being sought
	     REGISTER = 4;				! address of the rights segment descriptors
	     REGISTER = 1,				! address of the ID quadword (if found)
	     REGISTER = 5),				! address of the rights segment containing the ID (if found)
    
    EXE$SNDEVMSG_LINKAGE = 
    ! Linkage for EXE$SNDEVMSG routine in Mailbox Driver.
    ! The parameters, PRESERVE and NOPRESERVEs are as documented below, simply
    ! for compatibility reasons.  
	JSB(REGISTER = 3,				! Mailbox UCB address
	    REGISTER = 4, 				! Message Type
	    REGISTER = 5) :				! Device UCB address
	NOPRESERVE (0,1,2,3,4)
	PRESERVE (5,6,7,8,9,10,11),

    EXE$SENDMSG_LINKAGE = 
	JSB (REGISTER = 3,				! Message size
	     REGISTER = 4,				! Message address
	     REGISTER = 5) :				! UCB address of mailbox
	NOPRESERVE (2),

    EXE$WRITECHK_LINKAGE = 
	JSB (REGISTER = 0, 				! Address of buffer
	     REGISTER = 1, 				! Size of buffer
	     REGISTER = 3 ) :				! IRP address
	PRESERVE (3,4,5,6,7,8,9,10,11)
	NOPRESERVE (0,1,2),

    EXE$WRTMAILBOX_LINKAGE = 
    ! The parameters, PRESERVE and NOPRESERVEs are as documented below, simply
    ! for compatibility reasons.  
	JSB( REGISTER = 3, 				! Message Size
	     REGISTER = 4, 				! Message Address
	     REGISTER = 5):				! Mailbox UCB Address
	PRESERVE (3,4,5,6,7,8,9,10,11)
	NOPRESERVE (0,1,2),

    EXE$ACQUIRE_OLCK_LINKAGE	= 
	JSB (	REGISTER = 2, 				! rsn
		REGISTER = 3, 				! parid
		REGISTER = 4, 				! flags
		REGISTER = 5 ),				! olck

    EXE$RELEASE_OLCK_LINKAGE	= 
	JSB (	REGISTER = 1, 				! flags
		REGISTER = 4 ),				! olck

    EXE$RUNDOWN_OLCKS_LINKAGE	= JSB,

    EXE$_CLEANUP_ORB_LINKAGE	= 
	JSB (	REGISTER = 0, 				! orb
		REGISTER = 2),				! deallocation routine

    EXE$_DELETE_ORB_LINKAGE	= 
	JSB (	REGISTER = 0, 				! orb
		REGISTER = 2),				! deallocation routine

    INITIALIZATION_RTN_JSB = 				! Loadable image init routine
	JSB (REGISTER = 5; 				! Inirtn flags
	     REGISTER = 0) :				! Return status
	NOPRESERVE(0,1,2,3)
	PRESERVE (4,5,6,7,8,9,10,11),

    IOC$CVT_DEVNAM_LINKAGE = 
	JSB (REGISTER = 0,				! Input length of output buffer, output final conversion status
							!			  SS$_NORMAL or
							!			  SS$_BUFFEROVF (an alternate success status which 
							!				indicates that the supplied buffer could not
							!				hold the device name string)
	     REGISTER = 1,				! Input address of output buffer
	     REGISTER = 4,				! Input name string formation mode
	     REGISTER = 5;				! Address of device UCB
	     REGISTER = 1):				! Output  Length of conversion string.  R1 = 0 if the alternate path name
							!  was requested, but none exists.
	NOPRESERVE (0,1)
	PRESERVE (2,3,4,5,6,7,8,9,10,11),

    IOC$REQCOM_LINKAGE = 
	JSB (REGISTER = 0, 				! I/O STATUS first longword
	     REGISTER = 1, 				! I/O Status second word
	     REGISTER = 5):				! UCB address
	PRESERVE (4,5,6,7,8,9,10,11)
	NOPRESERVE (0,1,2,3),

    LNM$LOCKR_LINKAGE = 
	JSB (REGISTER = 4) :				! PCB address
	PRESERVE (1,4,5,6,7,8,9,10,11)
	NOPRESERVE (0,2,3),				

    LNM$LOCKW_LINKAGE = 
	JSB (REGISTER = 4):				! PCB address
	PRESERVE (1,4,5,6,7,8,9,10,11)
	NOPRESERVE (0,2,3),				


    LNM$UNLOCK_LINKAGE = 
	JSB (REGISTER = 4) :				! PCB
	PRESERVE (4,5,6,7,8,9,10,11)
	NOPRESERVE (0,1,2,3),				! R0-R3 scratch

    LNM$DELETELNMB_LINKAGE = 
	JSB ( REGISTER = 1):				! Address of logical name table entry
	PRESERVE (4,5,6,7,8,9,10,11)
	NOPRESERVE (0,1,2,3),				! R0 - Status: 
							!  SS$_NORPRIV if logical name table is a directory
							!  SS$_NORMAL
							!  SS$_NOLOGNAM if there are o such logical names.

    NSA$ALLOCATE_NSAB_LINKAGE =
	JSB (REGISTER = 2;				! size of required NSAB
	     REGISTER = 3),				! actual address of NSAB

    NSA$AUDIT_EVENT_LINKAGE = 
	JSB (REGISTER = 0,				! address of NSAB
	     REGISTER = 1) :				! supplied packet mask
	PRESERVE (2,3,4,5,6,7,8,9,10,11),

    NSA$AUDIT_FAILURE_LINKAGE =
	JSB (REGISTER = 0,				! failing status
	     REGISTER = 1),				! audit flags

    NSA$CHECK_AUDIT_LINKAGE = 
	JSB (REGISTER = 0,				! protection check status
	     REGISTER = 1,				! event type and subtype
	     REGISTER = 2,				! address of CHPCTL block
	     REGISTER = 3) :				! address of CHPRET block
	PRESERVE (4,5,6,7,8,9,10,11),

    NSA$CHECK_PRIVILEGE_LINKAGE = 
	JSB (REGISTER = 0,				! privilege bit, privilege mask address, or identifier address
	     REGISTER = 1,				! address of control structure ($NSAIFPDEF)
	     REGISTER = 4),				! PCB address of process to check (0 = use current process)
	     
    NSA$COMPUTE_SUMMARY_LINKAGE = 
	JSB (REGISTER = 4),				! PCB address (0 = use current PCB)

    NSA$ITMLST_TO_PKTLST_LINKAGE =
	JSB (REGISTER = 2,				! address of item list
	     REGISTER = 3,				! address of buffer to receive packet list
	     REGISTER = 4,				! address of NSAS (with journal names)
	     REGISTER = 5),				! address of username descriptor

    NSA$RESOURCE_LINKAGE = 
	JSB (REGISTER = 0,				! reason mask
	     REGISTER = 1) :				! audit flags ($NSADEF)
	PRESERVE (2,3,4,5,6,7,8,9,10,11),

    NSA$SIZE_NSAB_LINKAGE =
	JSB (REGISTER = 2,				! address of item list
	     REGISTER = 3),				! NSAS structure address

    NSA$VALIDATE_JOURNAL_LINKAGE =
	JSB (REGISTER = 2,				! journal type flag
	     REGISTER = 3,				! address of journal name descriptor
	     REGISTER = 4,				! address of username descriptor
	     REGISTER = 5),				! address of journal name descriptor

    OSR$ACCESS_EXCEPTION_LINKAGE = 
	JSB (REGISTER = 8,				! address of ARB
	     REGISTER = 9,				! address of ORB
	     REGISTER = 10,				! address of CHPCTL
	     REGISTER = 11,				! address of CHPRET
	     REGISTER = 0),				! input status

    SCH$FORCEDEXIT_LINKAGE  = 
	JSB (REGISTER = 0,
	     REGISTER = 3,
	     REGISTER = 4) :
	NOPRESERVE(1,2) 
	PRESERVE(5) 
	NOTUSED(6,7,8,9,10,11),

    SCH$LOCKR_LINKAGE = 
	JSB (REGISTER = 0,				! address of mutex
	     REGISTER = 4) :				! address of PCB
	NOPRESERVE (2,3),				

    SCH$LOCKW_LINKAGE = 
	JSB (REGISTER = 0,				! address of mutex
	     REGISTER = 4) :				! address of PCB
	NOPRESERVE (2,3),				

    SCH$LOCKREXEC_LINKAGE	= JSB (REGISTER = 0) :	! address of mutex
				       NOPRESERVE (1, 2, 3),

    SCH$UNLOCKEXEC_LINKAGE	= JSB (REGISTER = 0) :	! address of mutex
				       NOPRESERVE (1, 2, 3),

    SCH$POSTEF_LINKAGE = 
	JSB (REGISTER = 1,				! PID
	     REGISTER = 2,				! priority increment class number
	     REGISTER = 3;				! EFN number
	     REGISTER = 4) :				! PCB address of process specified by PID
	PRESERVE (5,6,7,8,9,10,11),

    SCH$QAST_LINKAGE  = 
	JSB (REGISTER = 2, 
	     REGISTER = 5) :
	NOPRESERVE (1,2,3,4,5) 
	NOTUSED (6,7,8,9,10,11),

    SCH$RAVAIL_LINKAGE = 				! Implicit input: IPL <= SYNCH
	JSB  ( REGISTER = 0 ):				! Resource Number
	PRESERVE (4,5,6,7,8,9,10,11)
	NOPRESERVE (0,1,2,3),				! R1-R3 are destroyed	 
							! (NOTE: I think only R2 is actually destroyed, but just to be safe...)

    SCH$UNLOCK_LINKAGE = 
	JSB (REGISTER = 0,				! address of mutex
	     REGISTER = 4) :				! address of PCB
	NOPRESERVE (2,3);


MACRO
    $probe ($$loc, $$len, $$type, $$mode) =
!+
! This macro probes a range using PROBEx or EXE$PROBEx.
!
! $$loc is the starting address of the range.
! $$len is the length of the range
! $$type is the type of probe to be done, allowable values are:
! 
!   R -- probe for read access. If the probe is a compile-time constant less
!   than a page in length, then PROBER is used, otherwise EXE$PROBER is used.
!
!   W -- probe for write access as per R above.
!
!   RQ -- probe for read access, but always use a PROBER instruction. A Mnemonic
!   for the Q is "quick."
!
!   WQ -- probe for write access, as per RQ.
!
! $$mode is the mode of the probe -- defaults to 0.
!
! The macro returns a value that is either true or false, suitable for use in an
! IF statement.
! 
!-
	BEGIN
	COMPILETIME quick = 0;

	%IF %LENGTH LSS 3
	%THEN
	    %ERROR('Too few parameters in $PROBE')
	%FI

	%IF (NOT %IDENTICAL($$type,r)) AND
	    (NOT %IDENTICAL($$type,w)) AND
	    (NOT %IDENTICAL($$type,rq)) AND
	    (NOT %IDENTICAL($$type,wq)) 
	%THEN
	    %ERROR('Error in $PROBE, ',$$type,' is an illegal type.')
	%FI

	%IF %IDENTICAL($$type,rq) OR %IDENTICAL($$type,wq)
	%THEN
	    %ASSIGN(quick,1)
	%FI

	%IF quick OR (%CTCE($$len) AND ($$len LEQ 512))
	%THEN

	    MACRO pbuiltin = 
		%IF %IDENTICAL($$type,r) or %IDENTICAL($$type,rq)
		%THEN
		    PROBER
		%ELSE
		    PROBEW
		%FI

		%QUOTE % ;

	    BUILTIN
		pbuiltin;
		
	    pbuiltin(%REF(%IF %NULL($$mode) %THEN 0 %ELSE $$mode %FI),%REF($$len),$$loc)

	%ELSE
	    LINKAGE
		probe_linkage = JSB (REGISTER = 0, REGISTER = 1, REGISTER = 3) : NOPRESERVE(1,2);

	    EXTERNAL ROUTINE
		%NAME('EXE$PROBE',$$type) : probe_linkage ADDRESSING_MODE(GENERAL);


	    %NAME('EXE$PROBE',$$type)($$loc,$$len,%IF %NULL($$mode) %THEN 0 %ELSE $$mode %FI)

	%FI
	END %;

MACRO
    $bug_check ($$name, $$type) =
!+
! This macro generates a bugcheck. It is analogous to the MACRO-32 BUG_CHECK
! macro. You use it with a call like $BUG_CHECK(VAXPORT,FATAL);
!
! Note that this macro generates a reference to an external symbol for the
! BUG$_WHATEVER code. It would be real nice if the BUG$_ codes were in LIB, but
! they're not, so they get resolved at link time. Sorry.
!
! $$name is the name of the of the bugcheck. VAXPORT, KRPEMPTY, etc.
! $$type is the type of the bugcheck. FATAL makes it a fatal bugcheck, anything
!        else is a non-fatal bugcheck. Case doesn't matter.
!-
	BEGIN
	EXTERNAL LITERAL
	    %NAME('BUG$_',$$name);

	BUILTIN
	    bugw;

	%IF %IDENTICAL($$type,fatal)
	%THEN
	    BUGW(4 OR %NAME('BUG$_',$$name))
	%ELSE
	    BUGW(%NAME('BUG$_',$$name))
	%FI

	END %;

!+
! $INSQHI - Execute an interlocked queue insert instruction and retry if 
!	    failure. 
! $INSQTI 
!
!	INPUT:
!
!	ENTRY -  Address of entry to be inserted in queue
!	HEAD  -  Address of queue header
!
!	Note: System is bug_checked if queue operation fails because secondary
!	interlock bit stays set.
!-
MACRO
    $INSQHI (ENTRY, HEAD) =
    BEGIN
	BUILTIN INSQHI;

    LOCAL
	COUNTER : INITIAL (0),
	STATUS;

    WHILE (STATUS = INSQHI (ENTRY, HEAD)) EQL 1 DO
	IF ((COUNTER = .COUNTER + 1) GTRU 90000)
	THEN
	    $BUG_CHECK (BADQHDR, FATAL);

    .STATUS
    END%;


MACRO
    $INSQTI (ENTRY, HEAD) =

    BEGIN
	BUILTIN	INSQTI;

    LOCAL
	COUNTER : INITIAL (0),
	STATUS;

    WHILE (STATUS = INSQTI (ENTRY, HEAD)) EQL 1 DO
	IF ((COUNTER = .COUNTER + 1) GTRU 90000)
	THEN
	    $BUG_CHECK (BADQHDR, FATAL);

    .STATUS
    END%;


!+
! $REMQHI - Execute an interlocked queue remove instruction and retry if failure
! $REMQTI
!
!	INPUT:
!
!	Head -  Address of queue header
!	Entry - Address of a longword where the address of the entry removed
!		is to be stored
!	
!	
!	Note: System is bug_checked if queue operation fails because secondary
!	      interlock bit stays set.
!-
MACRO
    $REMQHI (HEAD, ENTRY) =
    BEGIN
	BUILTIN REMQHI;

    LOCAL
	COUNTER : INITIAL (0),
	STATUS;

    WHILE (STATUS = REMQHI (HEAD, ENTRY)) EQL 1 DO
	IF ((COUNTER = .COUNTER + 1) GTRU 90000)
	THEN
	    $BUG_CHECK (BADQHDR, FATAL);

    .STATUS
    END %;

MACRO
    $REMQTI (HEAD, ENTRY) =
    BEGIN
	BUILTIN REMQTI;
    
    LOCAL
	COUNTER : INITIAL (0),
	STATUS;

    WHILE (STATUS = REMQTI (HEAD, ENTRY)) EQL 1 DO
	IF ((COUNTER = .COUNTER + 1) GTRU 90000)
	THEN
	    $BUG_CHECK (BADQHDR, FATAL);

    .STATUS
    END %;

!+
! $GET_WITH_RETRY	perform an RMS $GET with automatic retry
! $PUT_WITH_RETRY	perform an RMS $PUT with automatic retry
! $UPDATE_WITH_RETRY	perform an RMS $UPDATE with automatic retry
! $DELETE_WITH_RETRY	perform an RMS $DELETE with automatic retry
!
! INPUT:
!
!	RAB	address of RAB
!	SUC	address of routine to execute on successful completion
!	ERR	address of routine to execute on failure
!-

! This macro is used by the RMS retry macros.

MACRO
   $$RETRY (SERVICE, R, E, S) =
	BEGIN
	LITERAL
	    $$RETRY_LIMIT = 10,			! number of times to retry
	    $$SLEEP_RLK   = 500;		! 500 ms before retrying

	BIND
	    $$WAKEDELTA = UPLIT LONG (-10*1000*$$SLEEP_RLK,-1);
	
	LOCAL 
	    COUNTER, STATUS;

	COUNTER = $$RETRY_LIMIT;
	WHILE ((STATUS = SERVICE (RAB = R
				  %IF NOT %NULL(E) %THEN , ERR = E %FI
				  %IF NOT %NULL(S) %THEN , SUC = S %FI)
				 ) EQL RMS$_RLK) AND ((COUNTER = .COUNTER - 1) GEQ 0) DO
	    IF $SCHDWK (DAYTIM = $$WAKEDELTA) THEN $HIBER;
	.STATUS
	END %;

! The following four keyword macros mimic the real RMS macro definitions.  Each
! of these macros performs the normal RMS operation while providing for
! automatic retry on record-locked errors.  Each operation will be retried ten
! times with a retry interval of 500 ms.
! 
KEYWORDMACRO
    $GET_WITH_RETRY (RAB, ERR, SUC) =
	$$RETRY (%QUOTE %QUOTE $GET, RAB, ERR, SUC) %,

    $PUT_WITH_RETRY (RAB, ERR, SUC) =
	$$RETRY (%QUOTE %QUOTE $PUT, RAB, ERR, SUC) %,

    $UPDATE_WITH_RETRY (RAB, ERR, SUC) =
	$$RETRY (%QUOTE %QUOTE $UPDATE, RAB, ERR, SUC) %,

    $DELETE_WITH_RETRY (RAB, ERR, SUC) =
	$$RETRY (%QUOTE %QUOTE $DELETE, RAB, ERR, SUC) %;

!+
!
! Macro to copy a quadword using two MOVLs.
!
! Usage:
!
!   $MOVE_QUAD (SOURCE, DEST);
!
!-
MACRO
    $MOVE_QUAD (SRC, DST) =
	BEGIN
	(DST)+0 = .(SRC)<0, 32>;
	(DST)+4 = .(SRC)<32,32>;
	END %;

!+
!
! Macro to output a formatted string.
!
! Usage:
!
!   $SAY ('This is a simple string...');
!   $SAY ('This is a !AS string with a unsigned longword (!XL) in it...', %ascid'formatted', 42);
!
!-
MACRO
    $SAY (STRING) =
    BEGIN
    EXTERNAL ROUTINE LIB$PUT_OUTPUT, SYS$FAO;
    LOCAL OUT_BUF : BLOCK[132,BYTE], OUT : VECTOR[2] INITIAL(%ALLOCATION(OUT_BUF), OUT_BUF);
    SYS$FAO(%ASCID STRING, OUT, OUT, %REMAINING);
    LIB$PUT_OUTPUT(OUT);
    END %;

!+
!
! Macro to take an XDELTA breakpoint, if XDELTA is loaded.
!
! Usage:
!
!   $XDELTA;
!
!-
MACRO
    $XDELTA = 
    BEGIN
    LINKAGE L_INI$BRK = JSB (STANDARD);
    EXTERNAL ROUTINE INI$BRK : L_INI$BRK;
    INI$BRK();
    END %;

%SBTTL	'DECLARE_PSECT Bliss Macro Definition'
!+
! DECLARE_PSECT MACRO
!
!	This macro is used to declare psects within the loadable images
!   of the VMS executive.  It makes sure all the psects have compatible
!   attibutes across all the images.
!
!   Inputs:
!     PSECT_NAME - PSECT_NAME is one of the standard VMS executive psects:
!
!             EXEC$NONPAGED_DATA
!             EXEC$NONPAGED_CODE
!             EXEC$PAGED_DATA
!             EXEC$PAGED_CODE
!             EXEC$INIT_001
!             EXEC$INIT_CODE
!             EXEC$INIT_PFNTBL_001
!             EXEC$INIT_SSTBL_001
!     ALIGNMENT - If a different alignment that the default is required
!
!   Example:
!
!     DECLARE_PSECT (PSECT_NAME = EXEC$NONPAGED_DATA);
!     DECLARE_PSECT (PSECT_NAME = EXEC$NONPAGED_CODE);
!-
 
COMPILETIME PSECTDEF = 0;

    KEYWORDMACRO
	DECLARE_PSECT ( PSECT_NAME, ALIGNMENT=0 ) =
            %ASSIGN(PSECTDEF,0)
	    %IF %IDENTICAL( %STRING( PSECT_NAME ), %STRING( EXEC$NONPAGED_DATA ))
	    %THEN
		%IF %IDENTICAL( %STRING( ALIGNMENT ), %STRING ( 0 ))
		%THEN
		    PSECT PLIT   =  EXEC$NONPAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(3));  ! QUADWORD ALIGNMENT
		    PSECT OWN    =  EXEC$NONPAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(3));
		    PSECT GLOBAL =  EXEC$NONPAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(3));
		%ELSE
		    %IF %IDENTICAL( %STRING ( ALIGNMENT ), %STRING( QUAD ))
                    %THEN
		        PSECT PLIT   =  EXEC$NONPAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(3));  ! QUADWORD ALIGNMENT
		        PSECT OWN    =  EXEC$NONPAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(3));
		        PSECT GLOBAL =  EXEC$NONPAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(3));
                    %FI
		    %IF %IDENTICAL( %STRING ( ALIGNMENT ), %STRING( LONG ))
                    %THEN
		        PSECT PLIT   =  EXEC$NONPAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(2));  ! LONGWORD ALIGNMENT
		        PSECT OWN    =  EXEC$NONPAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(2));
		        PSECT GLOBAL =  EXEC$NONPAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(2));
                    %FI
		    %IF %IDENTICAL( %STRING ( ALIGNMENT ), %STRING( WORD ))
                    %THEN
		        PSECT PLIT   =  EXEC$NONPAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(1));  ! WORD ALIGNMENT
		        PSECT OWN    =  EXEC$NONPAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(1));
		        PSECT GLOBAL =  EXEC$NONPAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(1));
                    %FI
		    %IF %IDENTICAL( %STRING ( ALIGNMENT ), %STRING( BYTE ))
                    %THEN
		        PSECT PLIT   =  EXEC$NONPAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(0));  ! BYTE ALIGNMENT
		        PSECT OWN    =  EXEC$NONPAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(0));
		        PSECT GLOBAL =  EXEC$NONPAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(0));
                    %FI
		%FI
                %ASSIGN(PSECTDEF,1)
	    %FI

	    %IF %IDENTICAL( %STRING( PSECT_NAME ), %STRING( EXEC$NONPAGED_CODE ))
	    %THEN
		%IF %IDENTICAL( %STRING( ALIGNMENT ), %STRING ( 0 ))
		%THEN
		    PSECT CODE = EXEC$NONPAGED_CODE (PIC,NOWRITE,EXECUTE,ALIGN(2));  ! LONGWORD ALIGNMENT
		%ELSE
		    %IF %IDENTICAL( %STRING ( ALIGNMENT ), %STRING( LONG ))
                    %THEN
		        PSECT CODE = EXEC$NONPAGED_CODE (PIC,NOWRITE,EXECUTE,ALIGN(2));  ! LONGWORD ALIGNMENT
                    %FI
		    %IF %IDENTICAL( %STRING ( ALIGNMENT ), %STRING( WORD ))
                    %THEN
		        PSECT CODE = EXEC$NONPAGED_CODE (PIC,NOWRITE,EXECUTE,ALIGN(1));  ! WORD ALIGNMENT
                    %FI
		    %IF %IDENTICAL( %STRING ( ALIGNMENT ), %STRING( BYTE ))
                    %THEN
		        PSECT CODE = EXEC$NONPAGED_CODE (PIC,NOWRITE,EXECUTE,ALIGN(0));  ! BYTE ALIGNMENT
                    %ELSE
                        %ERROR('You specified an illegal ALIGNMENT')
                    %FI
		%FI
                %ASSIGN(PSECTDEF,1)
            %FI

	    %IF %IDENTICAL( %STRING( PSECT_NAME ), %STRING( EXEC$PAGED_DATA ))
	    %THEN
		%IF %IDENTICAL( %STRING( ALIGNMENT ), %STRING ( 0 ))
		%THEN
	            PSECT PLIT    = EXEC$PAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(3));  ! QUADWORD ALIGNMENT
	            PSECT OWN     = EXEC$PAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(3));  ! QUADWORD ALIGNMENT
	            PSECT GLOBAL  = EXEC$PAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(3));  ! QUADWORD ALIGNMENT
		%ELSE
		    %IF %IDENTICAL( %STRING ( ALIGNMENT ), %STRING( QUAD ))
                    %THEN
	                PSECT PLIT   = EXEC$PAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(3));  ! QUADWORD ALIGNMENT
	                PSECT OWN    = EXEC$PAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(3));  ! QUADWORD ALIGNMENT
	                PSECT GLOBAL = EXEC$PAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(3));  ! QUADWORD ALIGNMENT
                    %FI
		    %IF %IDENTICAL( %STRING ( ALIGNMENT ), %STRING( LONG ))
                    %THEN
	                PSECT PLIT   = EXEC$PAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(2));  ! LONGWORD ALIGNMENT
	                PSECT OWN    = EXEC$PAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(2));  ! LONGWORD ALIGNMENT
	                PSECT GLOBAL = EXEC$PAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(2));  ! LONGWORD ALIGNMENT
                    %FI
		    %IF %IDENTICAL( %STRING ( ALIGNMENT ), %STRING( WORD ))
                    %THEN
	                PSECT PLIT   = EXEC$PAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(1));  ! WORD ALIGNMENT
	                PSECT OWN    = EXEC$PAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(1));  ! WORD ALIGNMENT
	                PSECT GLOBAL = EXEC$PAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(1));  ! WORD ALIGNMENT
                    %FI
		    %IF %IDENTICAL( %STRING ( ALIGNMENT ), %STRING( BYTE ))
                    %THEN
	                PSECT PLIT   = EXEC$PAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(0));  ! BYTE ALIGNMENT
	                PSECT OWN    = EXEC$PAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(0));  ! BYTE ALIGNMENT
	                PSECT GLOBAL = EXEC$PAGED_DATA (PIC,WRITE,NOEXECUTE,ALIGN(0));  ! BYTE ALIGNMENT
                    %ELSE
                        %ERROR('You specified an illegal ALIGNMENT')
                    %FI
		%FI
                %ASSIGN(PSECTDEF,1)
            %FI

	    %IF %IDENTICAL( %STRING( PSECT_NAME ), %STRING( EXEC$PAGED_CODE ))
	    %THEN
		%IF %IDENTICAL( %STRING( ALIGNMENT ), %STRING ( 0 ))
		%THEN
	            PSECT CODE = EXEC$PAGED_CODE (PIC,NOWRITE,EXECUTE,ALIGN(2));  ! LONGWORD ALIGNMENT
		%ELSE
		    %IF %IDENTICAL( %STRING ( ALIGNMENT ), %STRING( LONG ))
                    %THEN
		        PSECT CODE = EXEC$PAGED_CODE (PIC,NOWRITE,EXECUTE,ALIGN(2));  ! LONGWORD ALIGNMENT
                    %FI
		    %IF %IDENTICAL( %STRING ( ALIGNMENT ), %STRING( WORD ))
                    %THEN
		        PSECT CODE = EXEC$PAGED_CODE (PIC,NOWRITE,EXECUTE,ALIGN(1));  ! WORD ALIGNMENT
                    %FI
		    %IF %IDENTICAL( %STRING ( ALIGNMENT ), %STRING( BYTE ))
                    %THEN
		        PSECT CODE = EXEC$PAGED_CODE (PIC,NOWRITE,EXECUTE,ALIGN(0));  ! BYTE ALIGNMENT
                    %ELSE
                        %ERROR('You specified an illegal ALIGNMENT')
                    %FI
		%FI
                %ASSIGN(PSECTDEF,1)
            %FI


	    %IF %IDENTICAL( %STRING( PSECT_NAME ), %STRING( EXEC$INIT_001 ))
	    %THEN                                                
		PSECT CODE = EXEC$INIT_001 (PIC,WRITE,EXECUTE,ALIGN(2));
                %ASSIGN(PSECTDEF,1)
            %FI

	    %IF %IDENTICAL( %STRING( PSECT_NAME ), %STRING( EXEC$INIT_PFNTBL_001 ))
	    %THEN
		PSECT CODE = EXEC$INIT_PFNTBL_001 (PIC,WRITE,EXECUTE,ALIGN(2));	    ! LONGWORD ALIGNMENT	
                %ASSIGN(PSECTDEF,1)
            %FI

	    %IF %IDENTICAL( %STRING( PSECT_NAME ), %STRING( EXEC$INIT_CODE ))
	    %THEN
		%IF %IDENTICAL( %STRING( ALIGNMENT ), %STRING ( 0 ))
		%THEN
	            PSECT CODE = EXEC$INIT_CODE (PIC,WRITE,EXECUTE,ALIGN(2));  ! LONGWORD ALIGNMENT
		%ELSE
		    %IF %IDENTICAL( %STRING ( ALIGNMENT ), %STRING( LONG ))
                    %THEN
		        PSECT CODE = EXEC$INIT_CODE (PIC,WRITE,EXECUTE,ALIGN(2));  ! LONGWORD ALIGNMENT
                    %FI
		    %IF %IDENTICAL( %STRING ( ALIGNMENT ), %STRING( WORD ))
                    %THEN
		        PSECT CODE = EXEC$INIT_CODE (PIC,WRITE,EXECUTE,ALIGN(1));  ! WORD ALIGNMENT
                    %FI
		    %IF %IDENTICAL( %STRING ( ALIGNMENT ), %STRING( BYTE ))
                    %THEN
		        PSECT CODE = EXEC$INIT_CODE (PIC,WRITE,EXECUTE,ALIGN(0));  ! BYTE ALIGNMENT
                    %ELSE
                        %ERROR('You specified an illegal ALIGNMENT')
                    %FI
		%FI
                %ASSIGN(PSECTDEF,1)
            %FI

	    %IF %IDENTICAL( %STRING( PSECT_NAME ), %STRING( EXEC$INIT_SSTBL_001 ))
	    %THEN                                        
		PSECT CODE = EXEC$INIT_SSTBL_001 (PIC,WRITE,EXECUTE,ALIGN(2));	    ! LONGWORD ALIGNMENT	
                %ASSIGN(PSECTDEF,1)
            %FI

	   %IF %IDENTICAL( %NUMBER( PSECTDEF ),0)
	   %THEN
              %ERROR('You specified an illegal PSECT name')               	       
           %FI
           %;


%SBTTL	'INITIALIZATION_ROUTINE Macro Definition'
!+
! INITIALIZATION_ROUTINE
!	This macro declares a routine to be an initialization routine.  It
!	enters a self-relative vector for the routine in the initialization
! 	routine vector table, guaranteeing that this routine will be called
!	when the image is loaded by the VMS linker/loader.
!
! INPUTS:
!	NAME - name of the initialization routine.
!	SYSTEM_RTN - 1 if the initialization routine is external to this
!		image (i.e. in system space).  Defaults to 0.
!
! OUTPUTS:
!	A vector and a flags longword is entered into the initialization
!	routine vector table for each routine.
!-

COMPILETIME INITFLAGS = 0;

    KEYWORDMACRO
	INITIALIZATION_ROUTINE ( NAME, SYSTEM_RTN=0 ) =   
	    DECLARE_PSECT(PSECT_NAME = EXEC$INIT_001);
            %ASSIGN(INITFLAGS,0)
	    %IF %IDENTICAL( %STRING( SYSTEM_RTN ), %STRING( 1 ))
	    %THEN
		PSECT OWN    = EXEC$INIT_001 (PIC,WRITE,EXECUTE,ALIGN(2));  ! LONGWORD ALIGNMENT
		PSECT GLOBAL = EXEC$INIT_001 (PIC,WRITE,EXECUTE,ALIGN(2));  ! LONGWORD ALIGNMENT
		PSECT PLIT   = EXEC$INIT_001 (PIC,WRITE,EXECUTE,ALIGN(2));  ! LONGWORD ALIGNMENT
		OWN
		    RTN_NAME : INITIAL(NAME);
		    %ASSIGN(INITFLAGS,%NUMBER(INIRTN$M_SYSRTN))
	    %ELSE
		PSECT OWN    = EXEC$INIT_001 (PIC,WRITE,EXECUTE,ALIGN(2));  ! LONGWORD ALIGNMENT
		PSECT GLOBAL = EXEC$INIT_001 (PIC,WRITE,EXECUTE,ALIGN(2));  ! LONGWORD ALIGNMENT
		PSECT PLIT   = EXEC$INIT_001 (PIC,WRITE,EXECUTE,ALIGN(2));  ! LONGWORD ALIGNMENT
		OWN
		    RTN_NAME : INITIAL(NAME-RTN_NAME);
            %FI
	    PSECT OWN    = EXEC$INIT_001 (PIC,WRITE,EXECUTE,ALIGN(2));  ! LONGWORD ALIGNMENT
	    PSECT GLOBAL = EXEC$INIT_001 (PIC,WRITE,EXECUTE,ALIGN(2));  ! LONGWORD ALIGNMENT
	    PSECT PLIT   = EXEC$INIT_001 (PIC,WRITE,EXECUTE,ALIGN(2));  ! LONGWORD ALIGNMENT
	    OWN
		FLAGS : INITIAL(INITFLAGS);

	    PSECT OWN    = EXEC$INIT_CODE (PIC,WRITE,EXECUTE,ALIGN(2));  ! LONGWORD ALIGNMENT
	    PSECT GLOBAL = EXEC$INIT_CODE (PIC,WRITE,EXECUTE,ALIGN(2));  ! LONGWORD ALIGNMENT
	    PSECT PLIT   = EXEC$INIT_CODE (PIC,WRITE,EXECUTE,ALIGN(2));  ! LONGWORD ALIGNMENT
	    %;

!
! Macros to lock/unlock SMP SPINLOCKS
!
! Version:	'X-16'
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1986, 1987, 1988 BY					    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:	System Library
!
! ABSTRACT:
!
!	These macros are used to generate SMP locking code.
!
! ENVIRONMENT:
!
!	Native mode VAX processor; no operating system facilities are used.
!
!--
!
!
! AUTHOR:  Rod Gamache,		 CREATION DATE:  13-Jan-1986
!
! MODIFIED BY:
!
!	X-15,16	EMB		Ellen M. Batbouta	19-Jul-1989
!		Try again to fix $SYS_LOCK.
!
!	X-14	EMB0419		Ellen M. Batbouta	17-Jul-1989
!		Fix several of the SMP macros.  In the $FORKUNLOCK and
!		$FORKLOCK macros, FKB$B_FLCK was misspelled.  In the 
!		$SYS_UNLOCK macro, the mutex count in the per-CPU database 
!		was being incremented instead of decremented when releasing 
!		the mutex with read access.  In the $SYS_LOCK macro, an extra 
!		SETIPL is being done on the SMP enabled path.
!		
!
!	X-13	EMB0381		Ellen M. Batbouta	09-Jan-1989
!		Remove extra SETIPL from KEYWORDMACRO $SYS_LOCK.
!
!	X-12	JDC0408		Jon Callas		13-SEP-1988
!		Change references to BUG_CHECK. Not only is there no BUG_CHECK, 
!		but it really should be $BUG_CHECK. A $BUG_CHECK has been
!		added to LIB via VMS-MACROS.REQ with this.
!
!	X-11	RNG5011		Rod N. Gamache		21-Dec-1987
!		Fix BLISS macros to use $FIND_CPU_DATA call.
!		Fix $FORKUNLOCK to check if FIPL or FLCK.
!
!	X-10	RNG5010		Rod N. Gamache		11-Sep-1987
!		Add separate non-keyword macros for SYS_LOCK, SYS_UNLOCK,
!		FORKLOCK and FORKUNLOCK.
!
!	X-9	BAS5009		Barry A Scott		4-Sep-1987
!		Completely re-write most of the BLISS macros.
!
!	X-8	RNG5008		Rod N. Gamache		12-Aug-1987
!		Change refs from SMP$C_xxx to SPL$C_xxx.
!
!	X-7	WCT0047		Ward C. Travis		19-Mar-1987
!		Create  macros  for  Bliss   system  page  lockdown
!		requests.
!
!	X-6	WCT0023		Ward C. Travis		27-Jan-1987
!		Merge  in  changes   by  RNG  to   activate  SAVIPL
!		parameter in SYS_LOCK macros.
!
!	X-5	WCT0021		Ward C. Travis		21-Jan-1987
!		Changes made in  WCT0015 updated.  LOCK  and UNLOCK
!		now have the names SYS_LOCK and SYS_UNLOCK.
!
!	X-4	WCT0015		Ward C. Travis		14-Jan-1987
!		Bugfix to X-3;  renaming  SMPLOCK to  LOCK caused a
!		name conflict with the first parameter to FORKLOCK.
!
!	X-3	WCT0015		Ward C. Travis		 7-Jan-1987
!		Update outdated  SMPLOCK, SMPUNLOCK  definitions to
!		LOCK, UNLOCK for SMP.
!
!**


!
! The KEYWORD SMP MACROS:
!

KEYWORDMACRO
	$DSBINT( NEWIPL, DST, ENVIRON=MULTIPROCESSOR ) =
		BEGIN
		BUILTIN
			MFPR, MTPR;
		%IF NOT %NULL( DST )
		%THEN
			MFPR( PR$_IPL, DST );
		%ELSE
			%ERROR('DST parameter is mandatory')
		%FI
		%IF NOT %NULL( NEWIPL )
		%THEN
			MTPR( %REF( NEWIPL ), PR$_IPL );
			%IF NOT %IDENTICAL( %STRING( ENVIRON ), %STRING( UNIPROCESSOR ) )
			%THEN
				%IF NOT %CTCE( NEWIPL ) OR (%CTCE( NEWIPL ) AND NEWIPL GTR IPL$_ASTDEL)
				%THEN
					%WARN('Raising IPL to ',NEWIPL,' provides no multiprocessing synchronization')
				%FI
			%FI
		%ELSE
			MTPR( %REF( IPL$_POWER ), PR$_IPL );
			%IF NOT %IDENTICAL( %STRING( ENVIRON ), %STRING( UNIPROCESSOR ) )
			%THEN
				%WARN('Raising IPL to ',NEWIPL,' provides no multiprocessing synchronization')
			%FI
		%FI
		END
	%;

KEYWORDMACRO
	$ENBINT( SRC ) =
		BEGIN
		BUILTIN
			MTPR;
		%IF %NULL( SRC )
		%THEN
			%ERROR('SRC parameter is mandatory')
		%ELSE
			MTPR( %REF( SRC ), PR$_IPL );
		%FI
		END
	%;

KEYWORDMACRO
	$GET_CURPCB =
		BEGIN
		LOCAL
			$$OLDIPL,
			$$TEMP	: REF BLOCK[,BYTE];

		$DSBINT( DST = $$OLDIPL, ENVIRON = UNIPROCESSOR );
		$$TEMP = $FIND_CPU_DATA();
		$$TEMP = .$$TEMP[ CPU$L_CURPCB ];
		$ENBINT( SRC = .$$OLDIPL );
		.$$TEMP
		END
	%;

KEYWORDMACRO
	$SYS_LOCK( LOCKNAME, LOCKIPL, SAVIPL, CONDITION, MUTEX, SHARE ) =
	BEGIN
	BUILTIN
		MTPR,
		MFPR,
		TESTBITCCI,
		TESTBITSSI;
	EXTERNAL
		SGN$GL_SMP_SPINWAIT	: ADDRESSING_MODE( GENERAL ),
		EXE$GL_TENUSEC		: ADDRESSING_MODE( GENERAL ),
		EXE$GL_UBDELAY		: ADDRESSING_MODE( GENERAL ),
		SMP$GL_FLAGS		: BLOCK[4,BYTE] ADDRESSING_MODE( GENERAL );
	LINKAGE
		SMP_ROUTINE = JSB ( REGISTER = 0 ) : NOTUSED (1,2,3,4,5,6,7,8,9,10,11);
	EXTERNAL ROUTINE
		SMP$TIMEOUT		: SMP_ROUTINE ADDRESSING_MODE( GENERAL ),
		SMP$ACQUIRE		: SMP_ROUTINE ADDRESSING_MODE( GENERAL );
	LOCAL
		$$SAVED_IPL,
		$$TEMP,
		$$CPU_DATA	: REF BLOCK[,BYTE];
	%IF NOT %NULL( MUTEX )
	%THEN
		EXTERNAL
			MUTEX	: ADDRESSING_MODE( GENERAL ) BLOCK[4,BYTE];
	%IF %IDENTICAL( %STRING( SHARE ), %STRING( YES ) )
	%THEN
		$DSBINT( DST=$$SAVED_IPL, ENVIRON=UNIPROCESSOR );
		$$CPU_DATA = $FIND_CPU_DATA();
		DO
			BEGIN
			LABEL
				WAIT_LOOP;
WAIT_LOOP:		BEGIN
			WHILE 1
			DO
				BEGIN
				DECR TEMP
				FROM .SGN$GL_SMP_SPINWAIT * .EXE$GL_TENUSEC * .EXE$GL_UBDELAY
				TO 0
				DO
					BEGIN
					IF NOT .MUTEX[ MTX$V_INTERLOCK ]
					THEN
						LEAVE WAIT_LOOP;
					IF .$$CPU_DATA[ CPU$V_BUGCHK ]
					THEN
						$BUG_CHECK( CPUEXIT,FATAL );
					END;
				SMP$TIMEOUT();
				END
			END
			END
		WHILE
			TESTBITSSI( MUTEX[ MTX$V_INTERLOCK ] );

		$$CPU_DATA[ CPU$B_CPUMTX ] = .$$CPU_DATA[ CPU$B_CPUMTX ] + 1;
		MUTEX[ MTX$W_WRT ] = .MUTEX[ MTX$W_WRT ] + 1;
		TESTBITCCI( MUXTEX[ MTX$V_INTERLOCK ] );
		$ENBINT( SRC = $$SAVED_IPL );

	%ELSE
		$DSBINT( DST = $$SAVED_IPL, ENVIRON=UNIPROCESSOR )
		$$CPU_DATA = $FIND_CPU_DATA();
		WHILE 1
		DO
			BEGIN
				DO
					BEGIN
					LABEL
						WAIT_LOOP;
WAIT_LOOP:				BEGIN
					WHILE 1
					DO
						BEGIN
						DECR TEMP
						FROM .SGN$GL_SMP_SPINWAIT * .EXE$GL_TENUSEC * .EXE$GL_UBDELAY
						TO 0
						DO
							BEGIN
							IF .MUTEX[ MTX$W_WRT ] EQL -1	! CMPW
							THEN
								LEAVE WAIT_LOOP;
							IF .$$CPU_DATA[ CPU$V_BUGCHK ]
							THEN
								$BUG_CHECK( CPUEXIT,FATAL );
							END;
						SMP$TIMEOUT();
						END
					END
					END
				WHILE
					TESTBITSSI( MUTEX[ MTX$V_INTERLOCK ] );
			IF .MUTEX[ MTX$W_WRT ] EQL -1
			THEN
				EXITLOOP;
			TESTBITCCI( MUTEX[ MTX$V_INTERLOCK ] );
			END;
	%FI
	%FI
	%IF NOT %NULL( LOCKNAME )
	%THEN
		%IF NOT %NULL( SAVIPL )
		%THEN
			MFPR( PR$_IPL, SAVIPL );
		%FI
	IF .SMP$GL_FLAGS[ SMP$V_ENABLED ]
	THEN
		SMP$ACQUIRE( %NAME( SPL$C_, LOCKNAME ) );

	%IF  NOT %IDENTICAL( %STRING( CONDITION ), %STRING( NOSETIPL ) )
	%THEN
		IF NOT .SMP$GL_FLAGS[ SMP$V_ENABLED ]
		THEN
			$SETIPL( NEWIPL = %NAME( IPL$_, LOCKNAME ), ENVIRON=UNIPROCESSOR );
	%FI
	%FI
	END
	%;


KEYWORDMACRO
	$SYS_UNLOCK( LOCKNAME, NEWIPL, CONDITION, MUTEX, SHARE ) =
	BEGIN
	BUILTIN
		MTPR,
		TESTBITCCI,
		TESTBITSSI;
	EXTERNAL
		SGN$GL_SMP_SPINWAIT	: ADDRESSING_MODE( GENERAL ),
		EXE$GL_TENUSEC		: ADDRESSING_MODE( GENERAL ),
		EXE$GL_UBDELAY		: ADDRESSING_MODE( GENERAL ),
		SMP$GL_FLAGS		: ADDRESSING_MODE( GENERAL ) BLOCK [ 4, BYTE ];
	LINKAGE
		SMP_ROUTINE = JSB ( REGISTER = 0 ) : NOTUSED (1,2,3,4,5,6,7,8,9,10,11);
	EXTERNAL ROUTINE
		SMP$TIMEOUT		: SMP_ROUTINE ADDRESSING_MODE( GENERAL ),
		SMP$RELEASE		: SMP_ROUTINE ADDRESSING_MODE( GENERAL ),
		SMP$RESTORE		: SMP_ROUTINE ADDRESSING_MODE( GENERAL );
	LOCAL
		$$SAVED_IPL,
		$$TEMP,
		$$CPU_DATA	: REF BLOCK[,BYTE];
	%IF NOT %NULL( MUTEX )
	%THEN
	%IF %IDENTICAL( %STRING( SHARE ),%STRING( YES ) )
	%THEN
		$DSBINT( DST=$$SAVED_IPL, ENVIRON=UNIPROCESSOR );
		$$CPU_DATA = $FIND_CPU_DATA();
		DO
			BEGIN
			LABEL
				WAIT_LOOP;
WAIT_LOOP:		BEGIN
			WHILE 1
			DO
				BEGIN
				DECR TEMP
				FROM .SGN$GL_SMP_SPINWAIT * .EXE$GL_TENUSEC * .EXE$GL_UBDELAY
				TO 0
				DO
					BEGIN
					IF NOT .MUTEX[ MTX$V_INTERLOCK ]
					THEN
						LEAVE WAIT_LOOP;
					IF .$$CPU_DATA[ CPU$V_BUGCHK ]
					THEN
						$BUG_CHECK( CPUEXIT,FATAL );
					END;
				SMP$TIMEOUT();
				END
			END
		WHILE
			TESTBITSSI( MUTEX[ MTX$V_INTERLOCK ] );

		$$CPU_DATA[ CPU$B_CPUMTX ] = .$$CPU_DATA[ CPU$B_CPUMTX ] - 1;
		MUTEX[ MTX$W_WRT ] = .MUTEX[ MTX$W_WRT ] - 1;
		TESTBITCCI( MUTEX[ MTX$V_INTERLOCK ] );
		$ENBINT( SRC = $$SAVED_IPL );
	%ELSE
		TESTBITCCI( MUTEX[ MTX$V_INTERLOCK ] );
		! tHE FOLLOWING LINE IS WHAT "INVALID( ENVIRON=LOCAL )" WOULD EXPAND TO
		MTPR( %REF( 0 ), PR$_TBIA );

		$ENBINT( DST=$$SAVED_IPL );
	%FI
	%FI
	%IF NOT %NULL( LOCKNAME )
	%THEN
	IF .SMP$GL_FLAGS[ SMP$V_ENABLED ]
	THEN
		BEGIN
		%IF NOT %NULL( CONDITION )
		%THEN
			%IF %IDENTICAL( %STRING( CONDITION ), %STRING( RESTORE ) )
			%THEN
				SMP$RESTORE( %NAME( SPL$C_, LOCKNAME ) );
			%ELSE
				%ERROR( 'Bad argument value - condition' )
			%FI
		%ELSE
			SMP$RELEASE( %NAME( SPL$C_, LOCKNAME ) );
		%FI
		END;
	%FI
	%IF NOT %NULL( NEWIPL )
	%THEN
		MTPR( %REF( NEWIPL ), PR$_IPL );
	%FI
	END
	%;

KEYWORDMACRO
	$FIND_CPU_DATA( AMOD=GENERAL, ISTACK=NO ) =
		BEGIN
		BUILTIN
			MFPR,
			SP;
		EXTERNAL
			SMP$GL_BASE_MSK	: ADDRESSING_MODE( AMOD );
		%IF %IDENTICAL( %STRING( ISTACK ), %STRING( YES ) )
		%THEN
			.SP AND NOT .SMP$GL_BASE_MSK
		%ELSE
			LOCAL
				TEMP;
			MFPR( PR$_ISP, TEMP );
			.TEMP AND NOT .SMP$GL_BASE_MSK
		%FI
		END
	%;


KEYWORDMACRO
	!
	! LOCK FORK SPINLOCK
	!
	$FORKLOCK
	(
	LOCK = .UCB[ FKB$B_FLCK], 
	LOCKIPL, 
	SAVIPL, 
	PRESERVE = YES,
	FIPL = NO
	)
		=
	BEGIN
	!
	! LINKAGES:
	!
	LINKAGE
		SMP_ROUTINE = JSB ( REGISTER = 0 ) : NOTUSED (1,2,3,4,5,6,7,8,9,10,11);
	EXTERNAL ROUTINE
		SMP$ACQUIRE	: SMP_ROUTINE NOVALUE ADDRESSING_MODE (GENERAL);
	EXTERNAL
		SMP$GL_FLAGS	: ADDRESSING_MODE( GENERAL ) BLOCK [ 4, BYTE ],
		SMP$AL_IPLVEC	: ADDRESSING_MODE( GENERAL ) VECTOR [ , LONG ];
	BUILTIN
		MFPR;

	%IF NOT %NULL( SAVIPL )
	%THEN
		MFPR( PR$_IPL, SAVIPL );
	%FI
	IF ((LOCK) AND %X'20') EQL 0
	THEN
		$SETIPL( NEWIPL = LOCK, ENVIRON=UNIPROCESSOR )
	ELSE
		IF .SMP$GL_FLAGS[ SMP$V_ENABLED ] 
		THEN
			SMP$ACQUIRE( LOCK )
		ELSE
			$SETIPL ( NEWIPL = .SMP$AL_IPLVEC[ LOCK ], ENVIRON = UNIPROCESSOR );
	END
	% ;

!
! UNLOCK FORK SPINLOCK
!
KEYWORDMACRO
	$FORKUNLOCK
	(
	LOCK = .UCB[ FKB$B_FLCK], 
	NEWIPL, 
	CONDITION, 
	PRESERVE = YES
	)
		=
	BEGIN
	!
	! LINKAGES:
	!
	LINKAGE
		SMP_ROUTINE = JSB ( REGISTER = 0 ) : NOTUSED (1,2,3,4,5,6,7,8,9,10,11);
	EXTERNAL ROUTINE
		SMP$RESTORE : SMP_ROUTINE NOVALUE ADDRESSING_MODE (GENERAL),
		SMP$RELEASE : SMP_ROUTINE NOVALUE ADDRESSING_MODE (GENERAL);
	EXTERNAL
		SMP$GL_FLAGS	 : BLOCK [ 4, BYTE ] ADDRESSING_MODE( GENERAL );
	BUILTIN
		MTPR;

	IF .SMP$GL_FLAGS[ SMP$V_ENABLED ] 
	THEN
	%IF %IDENTICAL ( %STRING( CONDITION ), %STRING( RESTORE ) )
	%THEN
		IF ((LOCK) AND %X'20') NEQ 0
		THEN
			SMP$RESTORE ( LOCK );
	%ELSE
		IF ((LOCK) AND %X'20') NEQ 0
		THEN
			SMP$RELEASE ( LOCK );
	%FI	
	%IF NOT %NULL( NEWIPL )
	%THEN
		MTPR( %REF( NEWIPL ), PR$_IPL );
	%FI
	END
	% ;


KEYWORDMACRO
	$DEVICELOCK
	(
	LOCKADDR = .UCB[ UCB$L_DLCK ], 
	LOCKIPL, 
	SAVIPL, 
	CONDITION, 
	PRESERVE = YES
	)
		=
	BEGIN
	!
	! LINKAGES:
	!
	LINKAGE
		SMP_ROUTINE = JSB ( REGISTER = 0 ) : NOTUSED (1,2,3,4,5,6,7,8,9,10,11);
	EXTERNAL ROUTINE
		SMP$ACQUIREL	: SMP_ROUTINE NOVALUE ADDRESSING_MODE (GENERAL),
		SMP$ACQNOIPL	: SMP_ROUTINE NOVALUE ADDRESSING_MODE (GENERAL);
	EXTERNAL
		SMP$GL_FLAGS	: ADDRESSING_MODE( GENERAL ) BLOCK [ 4, BYTE ];
	LOCAL
		$$$SPINLOCK	: REF BLOCK [, BYTE ];
	BUILTIN
		MFPR;

	$$$SPINLOCK = LOCKADDR;

	%IF NOT %NULL( SAVIPL )
	%THEN
		MFPR( PR$_IPL, SAVIPL );
	%FI

	%IF NOT %NULL( LOCKIPL )
	%THEN
		IF .SMP$GL_FLAGS[ SMP$V_ENABLED ] 
		THEN
		%IF %IDENTICAL (%STRING( CONDITION ), %STRING( NOSETIPL ))
		%THEN
			SMP$ACQNOIPL( .$$$SPINLOCK );
		%ELSE
			SMP$ACQUIREL( .$$$SPINLOCK );
		%FI
		%IF NOT %IDENTICAL( %STRING( CONDITION ), %STRING( NOSETIPL ) )
		%THEN
			$SETIPL( NEWIPL = LOCKIPL, ENVIRON = UNIPROCESSOR );
		%FI
	%ELSE
		IF .SMP$GL_FLAGS[ SMP$V_ENABLED ] 
		THEN
		%IF %IDENTICAL( %STRING( CONDITION ), %STRING( NOSETIPL ) )
		%THEN
			SMP$ACQNOIPL( .$$$SPINLOCK );
		%ELSE
			SMP$ACQUIREL( .$$$SPINLOCK );
		%FI
		%IF NOT %IDENTICAL( %STRING( CONDITION ), %STRING( NOSETIPL ) )
		%THEN
			$SETIPL(  NEWIPL = .$$$SPINLOCK[ SPL$B_IPL ], ENVIRON = UNIPROCESSOR );
		%FI
	%FI

	END
	%;

!
! UNLOCK DEVICE SPINLOCK
!
KEYWORDMACRO
	$DEVICEUNLOCK
	(
	LOCKADDR = .UCB[ UCB$L_DLCK ],
	NEWIPL, 
	CONDITION, 
	PRESERVE = YES
	)
		=
	BEGIN
	!
	! LINKAGES:
	!
	LINKAGE
		SMP_ROUTINE = JSB(  REGISTER = 0 ) : NOTUSED( 1,2,3,4,5,6,7,8,9,10,11);
	EXTERNAL ROUTINE
		SMP$RESTOREL	: SMP_ROUTINE NOVALUE ADDRESSING_MODE( GENERAL),
		SMP$RELEASEL	: SMP_ROUTINE NOVALUE ADDRESSING_MODE( GENERAL);
	EXTERNAL
		SMP$GL_FLAGS	: BLOCK[ 4, BYTE ] ADDRESSING_MODE( GENERAL );
	BUILTIN
		MTPR;

	IF .SMP$GL_FLAGS[ SMP$V_ENABLED ] 
	THEN
	%IF %IDENTICAL(  %STRING( CONDITION ), %STRING( RESTORE ) )
	%THEN
		SMP$RESTOREL( LOCKADDR );
	%ELSE
		SMP$RELEASEL( LOCKADDR );
	%FI	
	%IF NOT %NULL( NEWIPL )
	%THEN
		MTPR( %REF( NEWIPL ), PR$_IPL );
	%FI
	END
	%;

KEYWORDMACRO
	$READ_SYSTIME( DST ) =
	BEGIN
	LOCAL
		$$SAVE_IPL;
	EXTERNAL
		EXE$GQ_SYSTIME	: ADDRESSING_MODE( GENERAL ) VECTOR[ 2, LONG ] VOLATILE;

	$SYS_LOCK( LOCKNAME=HWCLK, SAVIPL=$$SAVE_IPL );
	
	(DST)<0,32,0> = .EXE$GQ_SYSTIME[0];
	(DST)<32,32,0> = .EXE$GQ_SYSTIME[1];

	$SYS_UNLOCK( LOCKNAME=HWCLK, NEWIPL=.$$SAVE_IPL );
	END
	%;

KEYWORDMACRO
	$SETIPL( NEWIPL, ENVIRON=MULTIPROCESSOR ) =
		BEGIN
		BUILTIN
			MTPR;
		%IF NOT %NULL( NEWIPL )
		%THEN
			MTPR( %REF( NEWIPL ), PR$_IPL );
			%IF NOT %IDENTICAL( %STRING( ENVIRON ), %STRING( UNIPROCESSOR ) )
			%THEN
				%IF NOT %CTCE( NEWIPL ) OR (%CTCE( NEWIPL ) AND NEWIPL GTR IPL$_ASTDEL)
				%THEN
					%WARN('Raising IPL to ',NEWIPL,' provides no multiprocessing synchronization')
				%FI
			%FI
		%ELSE
			MTPR( %REF( IPL$_POWER ), PR$_IPL );
			%IF NOT %IDENTICAL( %STRING( ENVIRON ), %STRING( UNIPROCESSOR ) )
			%THEN
				%WARN( 'Raising ipl to newipl provides no multiprocessing synchronization' )
			%FI
		%FI
		END
	%;

KEYWORDMACRO
    $LOCK_SYSTEM_PAGES ( LSP_START, LSP_END, NEWIPL ) =
        BEGIN

	LINKAGE
	    MMG_LOCK_SYSTEM_PAGES_CALL = JSB (REGISTER = 0, REGISTER = 1) :
					      NOTUSED (2,3,4,5,6,7,8,9,10,11);
			    
        EXTERNAL ROUTINE
	    MMG$LOCK_SYSTEM_PAGES_CALL	: MMG_LOCK_SYSTEM_PAGES_CALL
				    	  ADDRESSING_MODE (GENERAL)
				  	  NOVALUE;
	BUILTIN
	    MTPR;
	
	MMG$LOCK_SYSTEM_PAGES_CALL (LSP_START, LSP_END);

	%IF NOT %NULL (NEWIPL)
	%THEN
	    MTPR (%REF(NEWIPL), PR$_IPL);
	%FI
    END %;

KEYWORDMACRO
    $UNLOCK_SYSTEM_PAGES ( LSP_START, LSP_END, NEWIPL ) =
	BEGIN
	
	LINKAGE
	    MMG_UNLOCK_SYSTEM_PAGES_CALL = JSB (REGISTER = 0, REGISTER = 1) :
						NOTUSED (2,3,4,5,6,7,8,9,10,11);

        EXTERNAL ROUTINE
	    MMG$UNLOCK_SYSTEM_PAGES_CALL: MMG_UNLOCK_SYSTEM_PAGES_CALL
					  ADDRESSING_MODE (GENERAL)
					  NOVALUE;
	BUILTIN
	    MTPR;

	MMG$UNLOCK_SYSTEM_PAGES_CALL (LSP_START, LSP_END);
	
	%IF NOT %NULL (NEWIPL)
	%THEN
	    MTPR (%REF(NEWIPL), PR$_IPL);
	%FI
    END %;

!
! The simple SMP MACROS:
!

MACRO
    !
    ! Lock SYSTEM SPINLOCK
    !
    SYS_LOCK (LOCKNAME, LOCKIPL, SAVIPL, CONDITION) =
	BEGIN
	!
	! LINKAGES:
	!
	LINKAGE
	    SMP_ACQUIRE = JSB ( REGISTER = 0 ) :
			NOTUSED (1,2,3,4,5,6,7,8,9,10,11)
	    ;

	EXTERNAL ROUTINE
	    SMP$ACQUIRE : SMP_ACQUIRE NOVALUE ADDRESSING_MODE (GENERAL)
	    ;

	BUILTIN
	    MFPR
	;

	%IF NOT %NULL(SAVIPL)
	%THEN
	    MFPR (PR$_IPL, %REF(SAVIPL))
	%FI

	SMP$ACQUIRE (%NAME('SPL$C_', LOCKNAME))
	END % ;

MACRO
    !
    ! Unlock SYSTEM SPINLOCK
    !
    SYS_UNLOCK (LOCKNAME, NEWIPL, CONDITION) =
	BEGIN
	!
	! LINKAGES:
	!

	LINKAGE
	    SMP_RESTORE = JSB ( REGISTER = 0 ) :
			NOTUSED (1,2,3,4,5,6,7,8,9,10,11),
	    SMP_RELEASE = JSB ( REGISTER = 0 ) :
			NOTUSED (1,2,3,4,5,6,7,8,9,10,11)
	    ;

	EXTERNAL ROUTINE
	    SMP$RESTORE : SMP_RESTORE NOVALUE ADDRESSING_MODE (GENERAL),
	    SMP$RELEASE : SMP_RELEASE NOVALUE ADDRESSING_MODE (GENERAL)
	    ;

	BUILTIN
	    MTPR
	    ;

	%IF %IDENTICAL (CONDITION,'RESTORE')
	%THEN
	    SMP$RESTORE (%NAME('SPL$C_', LOCKNAME));
	%ELSE
	    SMP$RELEASE (%NAME('SPL$C_', LOCKNAME));
	%FI

	%IF NOT %NULL(NEWIPL)
	%THEN
	    MTPR (%REF(NEWIPL), PR$_IPL)
	%FI

	END % ;

MACRO
    !
    ! Lock FORK SPINLOCK
    !
    FORKLOCK (LOCKID, LOCKIPL, SAVIPL, CONDITION) =
	BEGIN
	!
	! LINKAGES:
	!
	LINKAGE
	    SMP_ACQUIRE = JSB ( REGISTER = 0 ) :
			NOTUSED (1,2,3,4,5,6,7,8,9,10,11)
	    ;

	EXTERNAL ROUTINE
	    SMP$ACQUIRE : SMP_ACQUIRE NOVALUE ADDRESSING_MODE (GENERAL)
	    ;

	SMP$ACQUIRE (LOCKID)
	END % ;

MACRO
    !
    ! Unlock SYSTEM SPINLOCK
    !
    FORKUNLOCK (LOCKID, NEWIPL, CONDITION) =
	BEGIN
	!
	! LINKAGES:
	!

	LINKAGE
	    SMP_RESTORE = JSB ( REGISTER = 0 ) :
			NOTUSED (1,2,3,4,5,6,7,8,9,10,11),
	    SMP_RELEASE = JSB ( REGISTER = 0 ) :
			NOTUSED (1,2,3,4,5,6,7,8,9,10,11)
	    ;

	EXTERNAL ROUTINE
	    SMP$RESTORE : SMP_RESTORE NOVALUE ADDRESSING_MODE (GENERAL),
	    SMP$RELEASE : SMP_RELEASE NOVALUE ADDRESSING_MODE (GENERAL)
	    ;

	BUILTIN
	    MTPR
	    ;

	%IF %IDENTICAL (CONDITION,'RESTORE')
	%THEN
	    SMP$RESTORE (LOCKID);
	%ELSE
	    SMP$RELEASE (LOCKID);
	%FI

	%IF NOT %NULL(NEWIPL)
	%THEN
	    MTPR (%REF(NEWIPL), PR$_IPL)
	%FI

	END % ;

! 
! ****************************************************************************
! *                                                                          *
! *  Copyright (c) 1992                                                      *
! *  by DIGITAL Equipment Corporation, Maynard, Mass.                        *
! *                                                                          *
! *  This software is furnished under a license and may be used and  copied  *
! *  only  in  accordance  with  the  terms  of  such  license and with the  *
! *  inclusion of the above copyright notice.  This software or  any  other  *
! *  copies  thereof may not be provided or otherwise made available to any  *
! *  other person.  No title to and ownership of  the  software  is  hereby  *
! *  transferred.                                                            *
! *                                                                          *
! *  The information in this software is subject to change  without  notice  *
! *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment  *
! *  Corporation.                                                            *
! *                                                                          *
! *  DIGITAL assumes no responsibility for the use or  reliability  of  its  *
! *  software on equipment which is not supplied by DIGITAL.                 *
! *                                                                          *
! ****************************************************************************
! ********************************************************************************************************************************
!  Created  7-JUL-1992 20:02:11 by VAX SDL T3.2-8      Source:  7-JUL-1992 19:53:46 _$22$DIA9:[SHRLIB]SYSDEF.SDL;1 
! ********************************************************************************************************************************
 
!*** MODULE $ACMDEF ***
! +
!  ACMDEF - ACCOUNTING MANAGER DEFINITIONS
! -
literal ACM$S_ACMDEF = 2;
macro ACM$V_PROCESS = 0,0,1,0 %;        !  PROCESS ACCOUNTING ENABLED 
macro ACM$V_IMAGE = 0,1,1,0 %;          !  IMAGE ACCOUNTING ENABLED 
macro ACM$V_INTERACTIVE = 0,2,1,0 %;    !  INTERACTIVE ACCOUNTING ENABLED 
macro ACM$V_LOGFAIL = 0,3,1,0 %;        !  LOGIN FAILURE ACCOUNTING ENABLED 
macro ACM$V_SUBPROCESS = 0,4,1,0 %;     !  SUBPROCESS ACCOUNTING ENABLED 
macro ACM$V_DETACHED = 0,5,1,0 %;       !  DETACHED PROCESS ACCOUNTING ENABLED 
macro ACM$V_BATCH = 0,6,1,0 %;          !  BATCH ACCOUNTING ENABLED 
macro ACM$V_NETWORK = 0,7,1,0 %;        !  NETWORK PROCESS ACCOUNTING ENABLED 
macro ACM$V_PRINT = 0,8,1,0 %;          !  PRINT JOB ACCOUNTING ENABLED 
macro ACM$V_USER_DATA = 0,9,1,0 %;      !  USER_DATA ACCOUNTING ENABLED 
macro ACM$V_ACM_FUNC = 0,10,1,0 %;      !  ACM FUNCTION ACCOUNTING ENABLED 
macro ACM$V_SYS_FUNC = 0,11,1,0 %;      !  SYSTEM FUNCTION ACCOUNTING ENABLED 
macro ACM$V_CCAENAB = 0,12,1,0 %;       !  CHARGE CODE ACCOUNTING ENABLED 
macro ACM$V_CCVENAB = 0,13,1,0 %;       !  CHARGE CODE VALIDATION ENABLED 
literal ACM$S_ACMDEF1 = 76;
macro ACM$W_MSGSTS = -8,0,16,0 %;       !  MSG STATUS IN MAILBOX IOSB (JOBCTL SPECIFIC) 
macro ACM$W_MSGLEN = -6,0,16,0 %;       !  MSG LENGTH IN MAILBOX IOSB (JOBCTL SPECIFIC) 
macro ACM$L_PROCID = -4,0,32,0 %;       !  PROCESS ID IN MAILBOX IOSB (JOBCTL SPECIFIC) 
macro ACM$W_TYPE = 0,0,16,0 %;          !  MESSAGE TYPE 
macro ACM$W_MAILBOX = 2,0,16,0 %;       !  MAILBOX UNIT NUMBER 
macro ACM$Q_PRVMSK = 4,0,0,0 %;
literal ACM$S_PRVMSK = 8;               !  PROCESS PRIVILEGE MASK 
macro ACM$L_UIC = 12,0,32,0 %;          !  PROCESS UIC
macro ACM$W_MEM = 12,0,16,0 %;          !  MEMBER UIC 
macro ACM$W_GRP = 14,0,16,0 %;          !  GROUP UIC 
macro ACM$L_ARB_ADDRESS = 4,0,32,0 %;   !  ADDRESS OF CLONED ARB
macro ACM$T_USERNAME = 16,0,0,0 %;
literal ACM$S_USERNAME = 12;            !  USERNAME 
macro ACM$T_ACCOUNT = 28,0,0,0 %;
literal ACM$S_ACCOUNT = 8;              !  ACCOUNT NAME 
macro ACM$B_PROCPRI = 36,0,8,0 %;       !  PROCESS BASE PRIORITY 
macro ACM$B_RMOD = 37,0,8,0 %;          !  REQUESTOR'S ACCESS MODE
macro ACM$L_PID = 40,0,32,0 %;          !  PROCESS ID 
macro ACM$L_STS = 44,0,32,0 %;          !  PROCESS STATUS 
macro ACM$L_OWNER = 48,0,32,0 %;        !  OWNER PROCESS ID (0 => NONE) 
macro ACM$T_TERMINAL = 52,0,0,0 %;
literal ACM$S_TERMINAL = 8;             !  TERMINAL NAME (COUNTED ASCII STRING) 
macro ACM$Q_SYSTIME = 60,0,0,0 %;
literal ACM$S_SYSTIME = 8;              !  CURRENT SYSTEM TIME 
! 
!  SEND TO ACCOUNTING MANAGER FIELDS
! 
literal ACM$S_ACMDEF2 = 326;
macro ACM$W_USERREQ = 68,0,16,0 %;      !  USER REQUEST TYPE 
macro ACM$T_DATA = 70,0,0,0 %;
literal ACM$S_DATA = 256;               !  USER DATA 
! 
!  PROCESS/IMAGE DELETE/PURGE FIELDS
! 
literal ACM$K_PROCLEN = 128;            !  MIN. PROCESS/IMAGE TERMINATION MESSAGE LENGTH 
literal ACM$C_PROCLEN = 128;            !  MIN. PROCESS/IMAGE TERMINATION MESSAGE LENGTH 
literal ACM$S_ACMDEF3 = 144;
macro ACM$Q_LOGIN = 68,0,0,0 %;
literal ACM$S_LOGIN = 8;                !  PROCESS/IMAGE START TIME 
macro ACM$L_FINALSTS = 76,0,32,0 %;     !  PROCESS FINAL STATUS 
macro ACM$L_IMGCNT = 80,0,32,0 %;       !  IMAGE EXECUTION COUNT 
macro ACM$L_CPUTIME = 84,0,32,0 %;      !  CPU USAGE 
macro ACM$L_PAGEFLTS = 88,0,32,0 %;     !  PAGEFAULT COUNT 
macro ACM$L_PGFLTIO = 92,0,32,0 %;      !  PAGEFAULT I/O 
macro ACM$L_WSPEAK = 96,0,32,0 %;       !  WORKING SET PEAK 
macro ACM$L_PGFLPEAK = 100,0,32,0 %;    !  PAGE FILE PEAK 
macro ACM$L_DIOCNT = 104,0,32,0 %;      !  DIRECT I/O COUNT 
macro ACM$L_BIOCNT = 108,0,32,0 %;      !  BUFFERED I/O COUNT 
macro ACM$L_VOLUMES = 112,0,32,0 %;     !  VOLUME MOUNT COUNT 
macro ACM$L_VP_CPUTIME = 116,0,32,0 %;  !  VECTOR CPU TIME
macro ACM$W_NODEADDR = 120,0,16,0 %;    !  MESSAGE OFFSET TO REMOTE NODE ADDRESS 
macro ACM$W_NODENAME = 122,0,16,0 %;    !  MESSAGE OFFSET TO REMOTE NODE NAME 
macro ACM$W_REMOTEID = 124,0,16,0 %;    !  MESSAGE OFFSET TO REMOTE ID 
macro ACM$W_IMAGENAME = 126,0,16,0 %;   !  MESSAGE OFFSET TO IMAGE NAME 
macro ACM$L_QMGRS_USED = 128,0,0,1 %;
literal ACM$S_QMGRS_USED = 16;          !  BITMAP OF QUEUE MANAGERS ACCESSED BY PROCESS
! 
!  SNDJBC MESSAGE FIELDS
! 
literal ACM$S_SNDJBCDEF = 90;
literal ACM$S_ACMDEF4 = 90;
macro ACM$L_IMAGECNT = 68,0,32,0 %;     !  IMAGE COUNT FOR PROCESS
macro ACM$L_EFN = 72,0,32,0 %;          !  COMPLETION EVENT FLAG
macro ACM$L_IOSB = 76,0,32,0 %;         !  COMPLETION IOSB ADDRESS
macro ACM$L_ASTADR = 80,0,32,0 %;       !  COMPLETION AST ADRESS
macro ACM$L_ASTPRM = 84,0,32,0 %;       !  COMPLETION AST PARAMETER
macro ACM$W_FUNC = 88,0,16,0 %;         !  SNDJBC/GETQUI FUNCTION CODE
macro ACM$T_ITMLST = 90,0,0,0 %;        !  START OF ITEMLIST DATA
 
!*** MODULE $ACBDEF ***
! +
!  AST CONTROL BLOCK DEFINITIONS
! 
!  AST CONTROL BLOCKS EXIST AS SEPARATE STRUCTURES AND AS SUBSTRUCTURES
!  WITHIN LARGER CONTROL BLOCKS SUCH AS I/O REQUEST PACKETS AND TIMER
!  QUEUE ENTRIES.
! 
! -
literal ACB$M_POSIX_ACB = 8;
literal ACB$M_PKAST = 16;
literal ACB$M_NODELETE = 32;
literal ACB$M_QUOTA = 64;
literal ACB$M_KAST = 128;
literal ACB$K_LENGTH = 28;              !  Length of block. 
literal ACB$C_LENGTH = 28;              !  Length of block. 
literal ACB$S_ACBDEF = 28;
macro ACB$L_ASTQFL = 0,0,32,0 %;        ! AST QUEUE FORWARD LINK 
macro ACB$L_ASTQBL = 4,0,32,0 %;        ! AST QUEUE BACKWARD LINK 
macro ACB$W_SIZE = 8,0,16,0 %;          ! STRUCTURE SIZE IN BYTES 
macro ACB$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE CODE 
macro ACB$B_RMOD = 11,0,8,0 %;          ! REQUEST ACCESS MODE 
macro ACB$V_MODE = 11,0,2,0 %;
literal ACB$S_MODE = 2;                 ! MODE FOR FINAL DELIVERY 
macro ACB$V_POSIX_ACB = 11,3,1,0 %;     ! USED FOR DELIVERING SIGNALS/EVENTS
macro ACB$V_PKAST = 11,4,1,0 %;         ! PIGGY BACK SPECIAL KERNEL AST 
macro ACB$V_NODELETE = 11,5,1,0 %;      ! DON'T DELETE ACB ON DELIVERY 
macro ACB$V_QUOTA = 11,6,1,0 %;         ! ACCOUNT FOR QUOTA 
macro ACB$V_KAST = 11,7,1,0 %;          ! SPECIAL KERNEL AST 
macro ACB$L_PID = 12,0,32,0 %;          ! PROCESS ID OF REQUEST 
macro ACB$L_AST = 16,0,32,0 %;          ! AST ROUTINE ADDRESS 
macro ACB$L_ASTPRM = 20,0,32,0 %;       ! AST PARAMETER 
macro ACB$L_KAST = 24,0,32,0 %;         ! INTERNAL KERNEL MODE XFER ADDRESS 
 
!*** MODULE $ACFDEF ***
! 
!  CONFIGURATION CONTROL BLOCK OFFSET DEFINITIONS
! 
literal ACF$M_RELOAD = 1;
literal ACF$M_CRBBLT = 2;
literal ACF$M_SCBVEC = 4;
literal ACF$M_NOLOAD_DB = 8;
literal ACF$M_SUPPORT = 16;
literal ACF$M_GETDONE = 32;
literal ACF$M_BVP = 64;
literal ACF$K_LENGTH = 40;              ! LENGTH OF DEVICE DESCRIPTOR ARGUMENT LIST 
literal ACF$C_LENGTH = 40;              ! LENGTH OF DEVICE DESCRIPTOR ARGUMENT LIST 
literal ACF$S_ACFDEF = 40;
macro ACF$L_ADAPTER = 0,0,32,0 %;       ! ADDRESS OF ADAPTER CONTROL BLOCK 
macro ACF$L_CONFIGREG = 4,0,32,0 %;     ! ADDRESS OF CONFIGURATION STATUS REGISTER 
macro ACF$W_AVECTOR = 8,0,16,0 %;       ! OFFSET TO ADAPTER INTERRUPT VECTOR (SCB) 
macro ACF$B_AUNIT = 10,0,8,0 %;         ! ADAPTER UNIT NUMBER 
macro ACF$B_AFLAG = 11,0,8,0 %;         ! ADAPTER GENERATION CONTROL FLAGS 
macro ACF$V_RELOAD = 11,0,1,0 %;        !  RELOAD DRIVER 
macro ACF$V_CRBBLT = 11,1,1,0 %;        !  CRB AND IDB ARE BUILT 
macro ACF$V_SCBVEC = 11,2,1,0 %;        !  CVECTOR IS OFFSET INTO SCB 
macro ACF$V_NOLOAD_DB = 11,3,1,0 %;     !  DON'T LOAD DATABASE, ONLY LOAD DRIVER 
macro ACF$V_SUPPORT = 11,4,1,0 %;       !  DEVICE IS SUPPORTED 
macro ACF$V_GETDONE = 11,5,1,0 %;       !  GET OF IO DATABASE ALREADY DONE
macro ACF$V_BVP = 11,6,1,0 %;           !  MULTI-PORT BVP ADAPTER
macro ACF$L_CONTRLREG = 12,0,32,0 %;    ! ADDRESS OF CONTROL REGISTER 
macro ACF$W_CVECTOR = 16,0,16,0 %;      ! OFFSET TO CONTROLLER INTERRUPT VECTOR (TABLE) 
macro ACF$W_CUNIT = 18,0,16,0 %;        ! CONTROLLER UNIT NUMBER 
macro ACF$L_DEVNAME = 20,0,32,0 %;      ! ADDRESS OF DEVICE NAME COUNTED STRING 
macro ACF$L_DRVNAME = 24,0,32,0 %;      ! ADDRESS OF DRIVER NAME COUNTED STRING 
macro ACF$W_MAXUNITS = 28,0,16,0 %;     ! MAXIMUM UNITS THAT CAN BE CONNECTED 
macro ACF$B_CNUMVEC = 30,0,8,0 %;       ! NUMBER OF CONTROLLER VECTORS 
macro ACF$B_COMBO_VECTOR_OFFSET = 31,0,8,1 %; ! OFFSET TO START OF VECTORS FOR A COMBO STYLE DEVICE
macro ACF$B_COMBO_CSR_OFFSET = 32,0,8,1 %; ! OFFSET TO START OF CONTROL REGISTERS FOR A COMBO DEVICE
macro ACF$B_NUMUNIT = 33,0,8,0 %;       ! NUMBER OF UNITS TO CONFIGURE 
macro ACF$L_DLVR_SCRH = 36,0,32,0 %;    ! SCRATCH FOR DELIVER ROUTINES 
 
!*** MODULE $ADBDEF ***
! +
! 
!  Generalized Event Notification Definitions
! 
!  AST Data Block
! 
!  This is the fourth level structure of the event notification
!  database.  This block is used to store request specific
!  information in the event database.
! 
! -
literal ADB$M_LOCAL = 1;
literal ADB$M_RSVD = 62;
literal ADB$K_LENGTH = 68;              !  LENGTH OF BLOCK
literal ADB$C_LENGTH = 68;              !  LENGTH OF BLOCK
literal ADB$S_ADBDEF = 68;
macro ADB$L_QFL = 0,0,32,0 %;           !  QUEUE FORWARD LINK 
macro ADB$L_QBL = 4,0,32,0 %;           !  QUEUE BACKWARD LINK
macro ADB$W_SIZE = 8,0,16,0 %;          !  STRUCTURE SIZE IN BYTES
macro ADB$B_TYPE = 10,0,8,0 %;          !  STRUCTURE TYPE CODE
macro ADB$B_SUBTYPE = 11,0,8,0 %;       !  STRUCTURE SUBTYPE CODE
macro ADB$L_FLAGS = 12,0,32,0 %;        !  FLAGS
macro ADB$V_LOCAL = 12,0,1,0 %;         !   LOCAL NODE
!    FLOST, ULOST, WILDCARD
! ******* START OF ACB
macro ADB$L_ACB_QFL = 16,0,32,0 %;      !  FORWARD LINK
macro ADB$L_ACB_QBL = 20,0,32,0 %;      !  BACKWARD LINK
macro ADB$W_ACB_SIZE = 24,0,16,0 %;     !  STRUCTURE SIZE IN BYTES
macro ADB$B_ACB_TYPE = 26,0,8,0 %;      !  STRUCTURE TYPE CODE
macro ADB$B_ACB_RMOD = 27,0,8,0 %;      !  REQUEST ACCESS MODE
macro ADB$L_PID = 28,0,32,0 %;          !  PROCESS ID
macro ADB$L_EVTADR = 32,0,32,0 %;       !  EVENT AST ROUTINE ADDRESS
macro ADB$L_EVTPRM = 36,0,32,0 %;       !  EVENT AST PARAMETER
macro ADB$L_KAST = 40,0,32,0 %;         !  INTERNAL KERNEL MODE XFER ADDRESS 
! ******* END OF ACB
macro ADB$L_UNIQID = 44,0,32,0 %;       !  GENERATED ID
macro ADB$L_ADB_LINK = 48,0,32,0 %;     !  PROCESS SPECIFIC ADB LINK
macro ADB$L_IDENTIFIER = 52,0,32,0 %;   !  IDENTIFIER OF REQUESTOR PROCESS
macro ADB$L_NAB_LINK = 56,0,32,0 %;     !  LINK TO NAME BLOCK
macro ADB$W_INITIAL_CREDIT = 60,0,16,1 %; !  INITIAL CREDIT
macro ADB$W_RESERVE_CREDIT = 62,0,16,0 %; !  CREDIT HELD IN RESERVE
macro ADB$B_ACMODE = 64,0,8,0 %;        !  ACCESS MODE
macro ADB$W_EVTFAC = 65,0,16,0 %;       !  FACILITY CODE
 
!*** MODULE $ADPDEF ***
! +
!  ADAPTER CONTROL BLOCK DEFINITIONS
! 
!  THERE IS ONE ADP FOR EACH SYSTEM INTERCONNECT ADAPTER THAT IS
!  USED FOR ANY TYPE OF I/O.  FOR EXAMPLE: MASBUSS ADAPTER, UNIBUS
!  ADAPTER.  THERE IS NO ADAPTER CONTROL BLOCK FOR MAIN MEMORY ADAPTERS.
! -
literal ADP$M_MAPPED = 1;
literal ADP$M_SHUTDOWN = 2;
literal ADP$M_SELFTEST = 4;
literal ADP$M_PORTONLY = 8;
literal ADP$M_BVP_LOCK = 16;
literal ADP$M_POWER_FAIL = 1;
literal ADP$M_POWER_FAIL_RECOVERY = 2;
literal ADP$M_BI_USE = 1;
literal ADP$M_BLA = 2;
literal ADP$M_ADPDISP_INIT = 1;
literal ADP$M_ADAP_MAPPING = 2;
literal ADP$M_DIRECT_VECTOR = 4;
literal ADP$M_AUTOPURGE_DP = 8;
literal ADP$M_BUFFERED_DP = 16;
literal ADP$M_ODD_XFER_BDP = 32;
literal ADP$M_ODD_XFER_DDP = 64;
literal ADP$M_EXTENDED_MAPREG = 128;
literal ADP$M_QBUS = 256;
literal ADP$M_PSWITCH_COMMIT = 512;
literal ADP$M_CRAMIO = 1024;
literal ADP$K_MBAADPLEN = 56;           ! LENGTH OF ADP FOR MASSBUS ADAPTER 
literal ADP$C_MBAADPLEN = 56;           ! LENGTH OF ADP FOR MASSBUS ADAPTER 
literal ADP$K_DRADPLEN = 56;            ! LENGTH OF ADP FOR DR32 
literal ADP$C_DRADPLEN = 56;            ! LENGTH OF ADP FOR DR32 
literal ADP$K_CIADPLEN = 56;            ! LENGTH OF ADP FOR CI 
literal ADP$C_CIADPLEN = 56;            ! LENGTH OF ADP FOR CI 
literal ADP$K_GBIADPLEN = 56;           ! LENGTH OF ADP FOR Generic BI device
literal ADP$C_GBIADPLEN = 56;           ! LENGTH OF ADP FOR Generic BI device
literal ADP$K_MBUSADPLEN = 56;          ! LENGTH OF ADP FOR MBUS
literal ADP$C_MBUSADPLEN = 56;          ! LENGTH OF ADP FOR MBUS
literal ADP$K_MINADPLEN = 56;           ! LENGTH OF SMALLEST AVAILABLE ADP
literal ADP$C_MINADPLEN = 56;           ! LENGTH OF SMALLEST AVAILABLE ADP
literal ADP$K_MPMADPLEN = 76;           ! LENGTH OF ADP FOR MULTI-PORT MEMORY 
literal ADP$C_MPMADPLEN = 76;           ! LENGTH OF ADP FOR MULTI-PORT MEMORY 
literal ADP$K_XBIADPLEN = 88;           ! LENGTH OF ADP FOR XBIA
literal ADP$C_XBIADPLEN = 88;           ! LENGTH OF ADP FOR XBIA
literal ADP$K_XJADPLEN = 100;           ! LENGTH OF ADP FOR XJA
literal ADP$C_XJADPLEN = 100;           ! LENGTH OF ADP FOR XJA
literal ADP$K_UBAADPLEN = 608;          ! LENGTH OF ADP FOR UNIBUS ADAPTER 
literal ADP$C_UBAADPLEN = 608;          ! LENGTH OF ADP FOR UNIBUS ADAPTER 
literal ADP$K_TCADPLEN = 608;           ! Length of ADP for a Turbochannel adapter
literal ADP$C_TCADPLEN = 608;           ! Length of ADP for a Turbochannel adapter
literal ADP$C_NUMDATAP = 16;            !  UBA - NUMBER OF DATAPATHS 
!  DATA STRUCTURES FOR SECOND SET OF MAP REGISTERS (497-8192)
literal ADP$K_QBAADPLEN = 1132;         !  LENGTH OF ADP FOR QBUS ADAPTER 
literal ADP$C_QBAADPLEN = 1132;         !  LENGTH OF ADP FOR QBUS ADAPTER 
literal ADP$C_VMEADPLEN = 1132;         !  LENGTH OF ADP FOR THE VME
literal ADP$K_VMEADPLEN = 1132;         !  LENGTH OF ADP FOR THE VME
literal ADP$C_BVPADPLEN = 156;          ! BVP ADP size with BVP extension
literal ADP$C_BVP_PAGES = 16;           ! BVP Pages mapped to the adapter registers
literal ADP$M_SGEC_SA = 1;
literal ADP$M_SGEC_SE = 2;
literal ADP$K_NIADPLEN = 64;
literal ADP$C_NIADPLEN = 64;
literal ADP$M_CIR_VALID = 1;
literal ADP$M_CIR_INITDEV = 2;
literal ADP$M_CIR_TRAENA = 4;
literal ADP$C_CIRADPLEN = 140;          !  CIRRUS ADP length
literal ADP520$K_MODEMPTY = 0;          !  Empty slot
literal ADP520$K_MODCIO = 1;            !  CIO (KFE52) module
literal ADP520$K_MODMEM = 3;            !  Memory module
literal ADP520$K_MODCOMM = 4;           !  DSF32 module
literal ADP520$K_MODCPU = 5;            !  CPU module
literal ADP520$K_MODUNK = 15;           !  Unknown module
literal ADP520$K_END = 6;               !  CPU module
literal ADP$S_ADPDEF = 1132;
macro ADP$L_CSR = 0,0,32,0 %;           ! ADAPTER CONFIGURATION STATUS REGISTER ADDRESS 
macro ADP$L_LINK = 4,0,32,0 %;          ! ADDRESS OF NEXT ADAPTER CONTROL BLOCK 
macro ADP$W_SIZE = 8,0,16,0 %;          ! STRUCTURE SIZE IN BYTES 
macro ADP$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE CODE 
macro ADP$B_NUMBER = 11,0,8,0 %;        ! ORDINAL ADAPTER NUMBER 
macro ADP$W_TR = 12,0,16,0 %;           ! CONFIGURATION TR NUMBER 
macro ADP$W_ADPTYPE = 14,0,16,0 %;      ! SOFTWARE ADAPTER TYPE 
macro ADP$L_VECTOR = 16,0,32,0 %;       ! UBA - ADDRESS OF VECTOR JUMP TABLE 
macro ADP$L_CRB = 16,0,32,0 %;          ! MBA OR DR32 - ADDRESS OF ADAPTER'S CRB 
macro ADP$L_DPQFL = 20,0,32,0 %;        ! UBA - DATAPATH WAIT QUEUE FORWARD LINK 
macro ADP$L_PRQQFL = 20,0,32,0 %;       ! MPM - INTER-PROCESSOR REQUEST WAIT QUEUE FLINK 
macro ADP$L_MBASCB = 20,0,32,0 %;       ! MBA - SCB VECTOR VALUE FOR MBA NEXUS 
macro ADP$L_CIMAP = 20,0,32,0 %;        ! CI  - CI mapping status
macro ADP$L_VPORTSTS = 20,0,32,0 %;     ! BVP - Vax port status bits
macro ADP$V_MAPPED = 20,0,1,0 %;        ! BVP,CI - adapter is mapped
macro ADP$V_SHUTDOWN = 20,1,1,0 %;      ! BVP,CI - adapter microcode is stopped
macro ADP$V_SELFTEST = 20,2,1,0 %;      ! BVP - adapter self test is in progress
macro ADP$V_PORTONLY = 20,3,1,0 %;      ! BVP - port restart only -- no adapter restart
macro ADP$V_BVP_LOCK = 20,4,1,0 %;      ! BVP - multi-port lock bit
macro ADP$L_XJA_STATUS = 20,0,32,0 %;   ! XJA - Interrupt Handler Status bits
!  Note following bit definitions
!   apply to ADP$L_XJA_STATUS and to
!   ADP$L_BI_STATUS, which are really
!   equivalent.
macro ADP$V_POWER_FAIL = 20,0,1,0 %;    ! Set on at time of power failure
macro ADP$V_POWER_FAIL_RECOVERY = 20,1,1,0 %; ! Set on at time of power failure recovery
macro ADP$L_BI_STATUS = 20,0,32,0 %;    ! BI - Interrupt Handler Status bits
macro ADP$L_DPQBL = 24,0,32,0 %;        ! UBA - DATAPATH WAIT QUEUE BACKWARD LINK 
macro ADP$L_PRQQBL = 24,0,32,0 %;       ! MPM - INTER-PROCESSOR REQUEST WAIT QUEUE BLINK 
macro ADP$L_MBASPTE = 24,0,32,0 %;      ! MBA - SPTE VALUE WHICH MAPS MBA ADDRESS SPACE 
macro ADP$L_CISPTE = 24,0,32,0 %;       ! CI  - SPTE VALUE WHICH MAPS CI ADDRESS SPACE
macro ADP$L_AVECTOR = 28,0,32,0 %;      !  ADDR OF 1ST SCB VECTOR FOR THIS ADAPTOR
macro ADP$L_CRB_LINKS = 32,0,0,1 %;
literal ADP$S_CRB_LINKS = 16;
macro ADP$L_CRB_PTRS = 32,0,32,0 %;
macro ADP$L_SII_CRB = 32,0,32,1 %;      !  Link to SII CRB
macro ADP$L_LANCE_CRB = 36,0,32,1 %;    !  Link to LANCE CRB
macro ADP$L_DZ_CRB = 40,0,32,1 %;       !  Link to DZ CRB
macro ADP$L_SPARE_CRB = 44,0,32,1 %;    !  spare link
macro ADP$L_BI_ONLY = 32,0,0,0 %;
literal ADP$S_BI_ONLY = 16;             ! BI ADAPTER VOLATILE INFO
macro ADP$L_BI_IDR = 32,0,32,0 %;       ! BIIC INTERRUPT DESTINATION REGISTER
macro ADP$W_BI_FLAGS = 36,0,16,0 %;     ! FLAGS FIELD
macro ADP$V_BI_USE = 36,0,1,0 %;        ! VECTOR FIELD VALID IF THIS BIT IS SET
macro ADP$V_BLA = 36,1,1,0 %;           ! IF SET, ADAPTER IS BLA.
macro ADP$W_BI_VECTOR = 38,0,16,0 %;    ! STORE SCB VECTOR OFFSET
macro ADP$L_SCB_PAGE = 40,0,32,0 %;     ! STORE SCB PAGE OFFSET
! FOR BI.
macro ADP$L_BIMASTER = 44,0,32,0 %;     ! ADP address for BI
! master (ie. XBI)
macro ADP$W_ADPDISP_FLAGS = 48,0,16,0 %; !  Flags used by ADPDISP macro
macro ADP$V_ADPDISP_INIT = 48,0,1,0 %;  !  ADPDISP flags have been initialized
macro ADP$V_ADAP_MAPPING = 48,1,1,0 %;  !  Adapter mapping supported
macro ADP$V_DIRECT_VECTOR = 48,2,1,0 %; !  Direct vectored interrupts
macro ADP$V_AUTOPURGE_DP = 48,3,1,0 %;  !  Autopurging datapath
macro ADP$V_BUFFERED_DP = 48,4,1,0 %;   !  Buffered datapath supported
macro ADP$V_ODD_XFER_BDP = 48,5,1,0 %;  !  Odd xfers supported ob buffered DP
macro ADP$V_ODD_XFER_DDP = 48,6,1,0 %;  !  Odd xfers supported on direct DP
macro ADP$V_EXTENDED_MAPREG = 48,7,1,0 %; !  Extended # of map regs
macro ADP$V_QBUS = 48,8,1,0 %;          !  QBUS adapter
macro ADP$V_PSWITCH_COMMIT = 48,9,1,0 %; !  Commit XMI adapters to primary switch
macro ADP$V_CRAMIO = 48,10,1,0 %;       !  Performs Mailbox I/O
macro ADP$B_ADDR_BITS = 51,0,8,0 %;     !  Number of adapter addr bits
macro ADP$L_PSWITCH_CALLBACK = 52,0,32,0 %; !  primary switch XMI callback address
macro ADP$L_SHB = 56,0,32,0 %;          ! MPM - SHARED MEMORY CONTROL BLOCK ADDR 
macro ADP$L_XBIA_CSR = 56,0,32,0 %;     !  CSR for XBIA
macro ADP$L_XMI_NODE_SP = 56,0,32,0 %;  !  Address of XMI Node Space
macro ADP$B_PORT = 60,0,8,0 %;          ! MPM - PORT NUMBER 
macro ADP$W_XBIA_TR = 60,0,16,0 %;      !  XMI node id
macro ADP$B_REL_BI = 62,0,8,0 %;        !  Relative BI #, for multiple XMI systems
macro ADP$W_XMI_NODE_NO = 60,0,16,0 %;  !  XMI node id
macro ADP$L_INTD = 64,0,0,0 %;
literal ADP$S_INTD = 12;                ! MPM,UBA - INTERRUPT TRANSFER VECTOR 
macro ADP$L_INTD2 = 76,0,0,0 %;
literal ADP$S_INTD2 = 12;               !  XBI needs 2 INTDs
macro ADP$L_INTD3 = 88,0,0,0 %;
literal ADP$S_INTD3 = 12;               !  XJA needs 3 INTDs
macro ADP$L_MRQFL = 56,0,32,0 %;        ! UBA - MAP REGISTER WAIT QUEUE FORWARD LINK 
macro ADP$L_MRQBL = 60,0,32,0 %;        ! UBA - MAP REGISTER WAIT QUEUE BACKWARD LINK 
macro ADP$L_UBASCB = 76,0,0,0 %;
literal ADP$S_UBASCB = 16;              ! UBA - SCB VECTOR VALUE FOR 4 UBA VECTORS 
macro ADP$W_DIRVECPG = 86,0,16,0 %;     ! SCB PAGE NUMBER FOR UNIBUS DEVICES
macro ADP$L_UBASPTE = 92,0,0,0 %;
literal ADP$S_UBASPTE = 8;              !  UBA - SPTE VALUES FOR MAPPING UBA ADDRESSES 
macro ADP$L_MRACTMDRS = 100,0,32,0 %;   !  UBA - ! active map register descriptors 
macro ADP$W_DPBITMAP = 104,0,16,0 %;    !  UBA - Datapath Allocation Bitmap 
macro ADP$W_MRNFENCE = 106,0,16,0 %;    !  Fence preceeding array. Init'ed to -1 
macro ADP$W_MRNREGARY = 108,0,0,0 %;
literal ADP$S_MRNREGARY = 248;          !  ! map regs in an extent array 
macro ADP$W_MRFFENCE = 356,0,16,0 %;    !  Fence precedding array. Init'ed to -1 
macro ADP$W_MRFREGARY = 358,0,0,0 %;
literal ADP$S_MRFREGARY = 248;          !  1st reg in extent array. 
macro ADP$W_UMR_DIS = 606,0,16,0 %;     !  Num of Map Registers to disable 
!  NOTE** - UNIBUS ADP must be integral
!   number of longwords long so that 780
!   interrupt vectors are longword aligned.
!  These are uVAX2 QBUS registers not used by UNIBUS devices
macro ADP$L_MR2QFL = 608,0,32,0 %;      !  QBA - 2nd MAP REGISTER WAIT QUEUE FORWARD LINK 
macro ADP$L_MR2QBL = 612,0,32,0 %;      !  QBA - 2nd MAP REGISTER WAIT QUEUE BACKWARD LINK 
macro ADP$L_MR2ACTMDR = 616,0,32,0 %;   !  QBA - number of active map register descriptors
macro ADP$W_MR2NFENCE = 622,0,16,0 %;   !  Fence preceeding array. Init'ed to -1 
macro ADP$W_MR2NREGAR = 624,0,0,0 %;
literal ADP$S_MR2NREGAR = 248;          !  number of map regs in an extent array 
macro ADP$W_MR2FFENCE = 872,0,16,0 %;   !  Fence precedding array. Init'ed to -1 
macro ADP$W_MR2FREGAR = 874,0,0,0 %;
literal ADP$S_MR2FREGAR = 248;          !  1st reg in extent array. 
macro ADP$W_UMR2_DIS = 1122,0,16,0 %;   !  Num of Map Registers to disable
macro ADP$L_MR2ADDR = 1124,0,32,0 %;    !  Address of map registers in CPU node private space
macro ADP$L_VMEADP = 1128,0,32,0 %;     !  VME adapter id
macro ADP$L_HOSTNODE = 56,0,32,0 %;     ! BVP Address of the host's BIIC nodespace base
macro ADP$W_INCARN = 60,0,16,0 %;       ! BVP Adapter incarnation - incremented on restart or self test
!  The following fields are reserved for use by BVP$LOCK_WAIT, BVP$LOCK_NOWAIT and BVP$UNLOCK
macro ADP$L_BVPOWNER = 62,0,32,0 %;     ! BVP Lock owner UCB (zero if free)
macro ADP$L_BVPWAITFL = 66,0,32,0 %;    ! BVP Queue of port drivers waiting
macro ADP$L_BVPWAITBL = 70,0,32,0 %;    ! BVP  for the ADP interlock
!  The following fields are reserved for use by BVP$INIT_PORT
macro ADP$W_BVP_STATE = 74,0,16,0 %;    ! BVP software state
macro ADP$L_BVP_COUNT = 76,0,32,0 %;    ! BVP timeout count
macro ADP$L_BVP_PROG = 80,0,32,0 %;     ! BVP progress counter
macro ADP$L_BVPSAVR5 = 84,0,32,0 %;     ! BVP Saved R5 
macro ADP$L_BVPRETURN = 88,0,32,0 %;    ! BVP Return address
macro ADP$L_BVPTEST = 92,0,32,0 %;      ! BVP self test action routine
macro ADP$L_BVPSTOP = 96,0,32,0 %;      ! BVP Stopped state action routine
macro ADP$L_BVPUNDEF = 100,0,32,0 %;    ! BVP Undefined state action
macro ADP$L_BVPINIT = 104,0,32,0 %;     ! BVP Initialized state action
macro ADP$L_BVPNOTIFY = 108,0,32,0 %;   ! BVP Error notify fork block
macro ADP$L_BVPCTRL = 112,0,32,0 %;     ! BVP Address of the port regs
!  The following queue header is a list of fork blocks to be activated on a fatal adapter error
macro ADP$L_BVPERRFL = 116,0,32,0 %;    ! BVP error notification flink
macro ADP$L_BVPERRBL = 120,0,32,0 %;    ! BVP error notification blink
!  The following field is used for CI-compatible adapter mapping and unmapping
macro ADP$L_INTSERV = 132,0,32,0 %;     ! BVP Address of the interrupt service routine
!  The following fields are reserved for use by BVP$ALLOC_DUMP and BVP$MEM_DUMP
macro ADP$L_LSDUMP = 136,0,32,0 %;      ! BVP Address of physical contiguous
! BVP  memory for the adapter memory dump.
macro ADP$L_LSINDX = 140,0,32,0 %;      ! BVP Offset into the adapter memory for start of the dump.
macro ADP$L_LSLENGTH = 144,0,32,0 %;    ! BVP Length (longwords) of the adapter memory
!  The following field is a sequence number for diagnostic use in tracing events from multiple drivers
!  which access a single adapter.  This field is normally unused.
macro ADP$L_SEQUENCE = 148,0,32,0 %;    ! BVP event sequence number
macro ADP$L_ADP_PAGES = 152,0,32,0 %;   !  (TYC0001) # of adapter pages to map 
macro ADP$L_NI_HWA = 56,0,32,0 %;
macro ADP$B_NI_HWO = 60,0,8,0 %;
macro ADP$B_NI_DIPL = 61,0,8,0 %;
macro ADP$B_SGEC_BURST = 62,0,8,0 %;
macro ADP$B_SGEC_MODE = 63,0,8,0 %;
macro ADP$V_SGEC_SA = 63,0,1,0 %;
macro ADP$V_SGEC_SE = 63,1,1,0 %;
macro ADP$W_CIRFLAGS = 56,0,16,0 %;     !  CIRRUS flags
macro ADP$V_CIR_VALID = 56,0,1,0 %;
macro ADP$V_CIR_INITDEV = 56,1,1,0 %;
macro ADP$V_CIR_TRAENA = 56,2,1,0 %;
macro ADP$W_CIRSLOT = 58,0,16,0 %;      !  Cirrus slot number (1-14)
macro ADP$W_CIRMODTYPE = 60,0,16,0 %;   !  CIRRUS module type
macro ADP$W_CIRSERNO = 62,0,16,0 %;     !  CIRRUS serial number
macro ADP$W_CIRREVNO = 64,0,16,0 %;     !  CIRRUS revision number
macro ADP$W_CIRPAGMA = 66,0,16,0 %;     !  CIRRUS pages mapped
macro ADP$W_CIRSPTENO = 68,0,16,0 %;    !  CIRRUS number of SPTEs for this  adapter
macro ADP$W_CIRMEMMODSIZE = 70,0,16,0 %; !  CIRRUS memory module size in  megabytes
macro ADP$L_CIRVAIOS = 72,0,32,0 %;     !  CIRRUS virtual address IO space
macro ADP$L_CIRCPUEEROM = 72,0,32,0 %;  !  Base VA of CPU EEPROM
macro ADP$L_CIRMEMEEROM = 72,0,32,0 %;  !  Base VA of Memory EEPROM
macro ADP$L_CIRSPTEVA = 76,0,32,0 %;    !  CIRRUS virtual address of first SPTE
macro ADP$L_CIRCIOCOMM = 80,0,32,0 %;   !  CIRRUS base VA of Communications
!   area for a CIO module
macro ADP$L_CIRMEMPWRA = 80,0,32,0 %;   !  VA of memory primary read
!   write address register
macro ADP$L_CIRCIOETH = 84,0,32,0 %;    !  CIRRUS base VA of Ethernet address
!   area for a CIO module
macro ADP$L_CIRMEMPRA = 84,0,32,0 %;    !  VA of memory primary read 
!   address register
macro ADP$L_CIRCIOSSC = 88,0,32,0 %;    !  CIRRUS base VA of SSC (TODR)
!   area for a CIO module
macro ADP$L_CIRMEMMWRA = 88,0,32,0 %;   !  VA of memory mirror write
!   read address register
macro ADP$L_CIRCIOSLB = 92,0,32,0 %;    !  CIRRUS base VA of buffer ram
!   area for a CIO module
macro ADP$L_CIRMEMDWR = 92,0,32,0 %;    !  VA of memory data
!   write read register
macro ADP$L_CIRCIOFIR = 96,0,32,0 %;    !  CIRRUS base VA of Firewall registers
!   area for a CIO module
macro ADP$L_CIRMEMWRERR = 96,0,32,0 %;  !  VA of memory write read
!   error control register
macro ADP$L_CIRCIODMA = 100,0,32,0 %;   !  CIRRUS base VA of DMA registers
!   area for a CIO module
macro ADP$L_CIRCIOFIRCTL = 104,0,32,0 %; !  CIRRUS base VA of Firewall
!  control register on CIO module
macro ADP$L_CIRCIOPCM = 108,0,32,0 %;   !  CIRRUS base VA of PCM
!  area for a CIO module
macro ADP$L_CIRCIOCON = 112,0,32,0 %;   !  CIRRUS base VA of Console registers
macro ADP$L_CIRDSFCON = 112,0,32,0 %;   !  area for a CIO and DSF module
macro ADP$L_CIRCIOSLI = 116,0,32,0 %;   !  CIRRUS base VA of SLIM registers
macro ADP$L_CIRCIOSWI = 120,0,32,0 %;   !  CIRRUS base VA of SWIFT registers
macro ADP$L_CIRDSFTURBO = 120,0,32,0 %; !  CIRRUS VA of DSF TURBO registers
macro ADP$L_CIRCIOLAN = 124,0,32,0 %;   !  CIRRUS base VA of LANCE registers
macro ADP$L_CIRDSFMOD = 124,0,32,0 %;   !  Base VA of Modem control for DSF 
macro ADP$L_SWIFT_CRB = 128,0,32,0 %;   !  SWIFT CRB address
macro ADP$L_DSF_CRB = 128,0,32,0 %;     !  DSF CRB address
macro ADP$L_LANCEC_CRB = 132,0,32,0 %;  !  Lance CRB address
macro ADP$L_PCM_CRB = 136,0,32,0 %;     !  PCM CRB address	
 
!*** MODULE $AIBDEF ***
! +
!  FORMAT OF ACP I/O BUFFER PACKET. THIS PACKET CONTAINS ALL THE DATA
!  TRANSMITTED FROM THE USER TO THE ACP AND BACK FOR AN ACP FUNCTION.
!  NOTE THAT THE DESCRIPTORS IN THE PACKET ARE TREATED BY BLISS CODE
!  AS A BLOCKVECTOR.
! -
literal AIB$K_LENGTH = 12;              !  LENGTH OF PACKET HEADER 
literal AIB$C_LENGTH = 12;              !  LENGTH OF PACKET HEADER 
literal AIB$S_AIBDEF = 12;
macro AIB$L_DESCRIPT = 0,0,32,0 %;      !  ADDRESS OF START OF DESCRIPTORS 
macro AIB$W_SIZE = 8,0,16,0 %;          !  SIZE OF PACKET 
macro AIB$B_TYPE = 10,0,8,0 %;          !  PACKET TYPE CODE 
 
!*** MODULE $ABDDEF ***
literal ABD$K_LENGTH = 8;               !  SIZE OF DESCRIPTOR 
literal ABD$C_LENGTH = 8;               !  SIZE OF DESCRIPTOR 
literal ABD$C_WINDOW = 0;               !  DESCRIPTOR FOR WINDOW ADDRESS 
literal ABD$C_FIB = 1;                  !  DESCRIPTOR FOR FIB 
literal ABD$C_NAME = 2;                 !  DESCRIPTOR FOR NAME STRING 
literal ABD$C_RESL = 3;                 !  DESCRIPTOR FOR RESULT LENGTH 
literal ABD$C_RES = 4;                  !  DESCRIPTOR FOR RESULT STRING 
literal ABD$C_ATTRIB = 5;               !  FIRST ATTRIBUTE DESCRIPTOR 
literal ABD$S_ABDDEF = 8;
macro ABD$W_TEXT = 0,0,16,0 %;          !  WORD OFFSET TO DATA TEXT 
macro ABD$W_COUNT = 2,0,16,0 %;         !  BYTE COUNT OF TEXT 
macro ABD$L_USERVA = 4,0,32,0 %;        !  USER VIRTUAL ADDRESS OF TEXT 
 
!*** MODULE $ALFDEF ***
! +
! 
!  $ALFDEF - structure for auto-login file.
! 
! -
literal ALF$C_LENGTH = 128;
literal ALF$K_LENGTH = 128;
literal ALF$S_ALFDEF = 128;
macro ALF$T_DEVNAME = 0,0,0,0 %;
literal ALF$S_DEVNAME = 63;             !  Terminal device name
macro ALF$T_USERNAME = 63,0,0,0 %;
literal ALF$S_USERNAME = 32;            !  Associated username
 
!*** MODULE $AQBDEF ***
! +
!  DEFINITION OF ACP QUEUE HEADER
! -
literal AQB$M_UNIQUE = 1;
literal AQB$M_DEFCLASS = 2;
literal AQB$M_DEFSYS = 4;
literal AQB$M_CREATING = 8;
literal AQB$M_XQIOPROC = 16;
literal AQB$K_UNDEFINED = 0;            !  UNDEFINED ACP 
literal AQB$K_F11V1 = 1;                !  FILES-11 STRUCTURE LEVEL 1 
literal AQB$K_F11V2 = 2;                !  FILES-11 STRUCTURE LEVEL 2 
literal AQB$K_MTA = 3;                  !  MAGTAPE 
literal AQB$K_NET = 4;                  !  NETWORKS 
literal AQB$K_REM = 5;                  !  REMOTE I/O 
literal AQB$K_HBS = 6;                  !  HOST BASED SHADOWING
literal AQB$K_LENGTH = 32;              !  SIZE OF AQB 
literal AQB$C_LENGTH = 32;              !  SIZE OF AQB 
literal AQB$S_AQBDEF = 32;
macro AQB$Q_ACPIQ = 0,0,0,0 %;
literal AQB$S_ACPIQ = 8;                !  INTERLOCKED QUEUE
macro AQB$R_ACP_Q_STRUCTURE = 0,0,0,0 %;
literal AQB$S_ACP_Q_STRUCTURE = 8;
macro AQB$L_ACPQFL = 0,0,32,0 %;        !  QUEUE FORWARD LINK 
macro AQB$L_ACPQBL = 4,0,32,0 %;        !  QUEUE BACK LINK 
macro AQB$W_SIZE = 8,0,16,0 %;          !  CONTROL BLOCK SIZE IN BYTES 
macro AQB$B_TYPE = 10,0,8,0 %;          !  BLOCK TYPE CODE 
macro AQB$B_MNTCNT = 11,0,8,0 %;        !  THIS FIELD IS NOW OBSOLETE
!   AND HAS BEEN REPLACED BY
!   AQB$L_MOUNT_COUNT 
macro AQB$L_ACPPID = 12,0,32,0 %;       !  ACP PROCESS PID 
macro AQB$L_LINK = 16,0,32,0 %;         !  AQB LIST LINKAGE 
macro AQB$B_STATUS = 20,0,8,0 %;        !  STATUS BYTE 
macro AQB$V_UNIQUE = 20,0,1,0 %;        !  ACP IS UNIQUE TO THIS DEVICE 
macro AQB$V_DEFCLASS = 20,1,1,0 %;      !  ACP IS DEFAULT FOR THIS CLASS 
macro AQB$V_DEFSYS = 20,2,1,0 %;        !  ACP IS DEFAULT FOR THE SYSTEM 
macro AQB$V_CREATING = 20,3,1,0 %;      !  ACP IS CURRENTLY BEING CREATED 
macro AQB$V_XQIOPROC = 20,4,1,0 %;      !  eXtended QIO PROCessor is being used.
macro AQB$B_ACPTYPE = 21,0,8,0 %;       !  ACP TYPE CODE 
! 
!  ***** The following ACP type codes are now a user visible interface
!  ***** and the values may not be changed.  There are parallel definitions
!  ***** in the $DVIDEF macro that define symbols of the form:
!  *****
!  *****                DVI$C_ACP_F11V1
!  *****                DVI$C_ACP_F11V2
!  *****                DVI$C_ACP_MTA
!  *****                ...
!  *****
!  ***** All new ACP type values must be added at the end and the names
!  ***** must be 5 characters or less to keep the DVI form of the name
!  ***** 15 characters or less.  Any additions must also be made in $DVIDEF
!  ***** and in the list of ASSUMES in the module SYSGETDEV in [SYS.SRC]
! 
macro AQB$B_CLASS = 22,0,8,0 %;         !  ACP CLASS CODE 
macro AQB$L_BUFCACHE = 24,0,32,0 %;     !  POINTER TO BUFFER CACHE
macro AQB$L_MOUNT_COUNT = 28,0,32,0 %;  !  ACP MOUNT COUNT (REPLACES AQB$B_MNTCNT)
 
!*** MODULE $ARBDEF ***
! +
! 
!  Access Rights Block - structure defining process access rights and
!  privileges. Currently part of the PCB (meaning that the size of the
!  ARB declared here must track in the PCB).
! 
! -
literal ARB$C_HEADER = 52;              !  Length of header
literal ARB$K_HEADER = 52;              !  Length of header
literal ARB$K_LENGTH = 124;             !  Structure length 
literal ARB$C_LENGTH = 124;             !  Structure length 
literal ARB$S_ARBDEF = 124;
macro ARB$Q_PRIV = 0,0,0,0 %;
literal ARB$S_PRIV = 8;                 !  Privilege mask
macro ARB$W_SIZE = 8,0,16,0 %;          !  Structure size
macro ARB$B_TYPE = 10,0,8,0 %;          !  Structure type
macro ARB$B_FLAGS = 11,0,8,0 %;         !  ARB flags (unused)
macro ARB$R_CLASS = 12,0,0,0 %;
literal ARB$S_CLASS = 20;               !  Security classification mask
macro ARB$L_RIGHTSLIST = 32,0,0,0 %;
literal ARB$S_RIGHTSLIST = 20;          !  Rights list descriptors
macro ARB$L_PROCESS = 32,0,32,0 %;      !  process rights
macro ARB$L_SYSTEM = 36,0,32,0 %;       !  system rights
macro ARB$L_EXTENDED = 40,0,32,0 %;     !  extended process rights
macro ARB$L_IMAGE = 44,0,32,0 %;        !  image rights
macro ARB$L_RESERVED = 48,0,32,0 %;     !  reserved
macro ARB$R_RIGHTSDESC = 52,0,0,0 %;
literal ARB$S_RIGHTSDESC = 8;           !  Descriptor for local rights list
macro ARB$R_LOCALRIGHTS = 60,0,0,0 %;
literal ARB$S_LOCALRIGHTS = 64;         !  Process local rights list
macro ARB$L_UIC = 60,0,32,0 %;          !  Process UID
macro ARB$W_MEM = 60,0,16,0 %;          !  Member number
macro ARB$W_GRP = 62,0,16,0 %;          !  Group number
 
!*** MODULE $ARCDEF ***
! +
! 
!  Bit definitions for EXE$GL_ARCHFLAG - flags for VAX architecture differences
! 
! -
literal ARC$M_CHAR_EMUL = 16;
literal ARC$M_DCML_EMUL = 32;
literal ARC$M_EDPC_EMUL = 64;
literal ARC$M_CRC_EMUL = 128;
literal ARC$M_DFLT_EMUL = 256;
literal ARC$M_FFLT_EMUL = 512;
literal ARC$M_GFLT_EMUL = 1024;
literal ARC$M_HFLT_EMUL = 2048;
literal ARC$M_EMOD_EMUL = 4096;
literal ARC$M_POLY_EMUL = 8192;
literal ARC$M_VIRT_SCB = 16384;
literal ARC$M_VIRT_SPT = 32768;
literal ARC$M_VIRT_PCB = 65536;
literal ARC$M_LOAD_SMP = 131072;
literal ARC$M_CRAMIO = 262144;
literal ARC$M_INTLCK_EMUL = 2097152;
literal ARC$S_ARCDEF = 4;
macro ARC$R_ARCDEF_BITS = 0,0,32,0 %;
macro ARC$V_CHAR_EMUL = 0,4,1,0 %;      !  Char Str Ins Emul 
macro ARC$V_DCML_EMUL = 0,5,1,0 %;      !  Decimal String Emul
macro ARC$V_EDPC_EMUL = 0,6,1,0 %;      !  EDITPC Instr Emul 
macro ARC$V_CRC_EMUL = 0,7,1,0 %;       !  CRC Instr Emul
macro ARC$V_DFLT_EMUL = 0,8,1,0 %;      !  D-flt Data Type Emul
macro ARC$V_FFLT_EMUL = 0,9,1,0 %;      !  F-flt Data Type Emul
macro ARC$V_GFLT_EMUL = 0,10,1,0 %;     !  G-flt Data Type Emul
macro ARC$V_HFLT_EMUL = 0,11,1,0 %;     !  H-flt Data Type Emul
macro ARC$V_EMOD_EMUL = 0,12,1,0 %;     !  EMOD Instr Emul
macro ARC$V_POLY_EMUL = 0,13,1,0 %;     !  POLY Instr Emul
macro ARC$V_VIRT_SCB = 0,14,1,0 %;      !  SCB located in virtual memory
macro ARC$V_VIRT_SPT = 0,15,1,0 %;      !  SPT located in virtual memory
macro ARC$V_VIRT_PCB = 0,16,1,0 %;      !  HWPCB located in virtual memory
macro ARC$V_LOAD_SMP = 0,17,1,0 %;      !  Load SMP uncoditionally
macro ARC$V_CRAMIO = 0,18,1,0 %;        !  Laser CRAM I/O system
macro ARC$V_INTLCK_EMUL = 0,21,1,0 %;   !  System requires interlock emulation on bus
 
!*** MODULE $BBSDEF ***
! +
! 
!  Structure of message from disk ACP to bad block scan utility.
! 
! -
literal BBS$K_LENGTH = 18;
literal BBS$C_LENGTH = 18;
literal BBS$S_BBSDEF = 18;
macro BBS$B_MSGTYPE = 0,0,8,0 %;        !  message type code (MSG$C_SCANBAD) 
macro BBS$W_SEQUENCE = 4,0,16,0 %;      !  message sequence number 
macro BBS$L_UCB = 8,0,32,0 %;           !  UCB address of device 
macro BBS$W_FID = 12,0,0,0 %;
literal BBS$S_FID = 6;                  !  file ID of file 
 
!*** MODULE $BIICDEF ***
! +
!  BI Interface Chip Register Offset Definitions
! -
literal BIIC$M_NONDEC = 32768;
literal BIIC$M_ARBCNTL = 48;
literal BIIC$M_SEIE = 64;
literal BIIC$M_HEIE = 128;
literal BIIC$M_UWP = 256;
literal BIIC$M_SST = 1024;
literal BIIC$M_STS = 2048;
literal BIIC$M_BROKE = 4096;
literal BIIC$M_INIT = 8192;
literal BIIC$M_SES = 16384;
literal BIIC$M_HES = 32768;
literal BIIC$M_NPE = 1;
literal BIIC$M_CRD = 2;
literal BIIC$M_IPE = 4;
literal BIIC$M_UPEN = 8;
literal BIIC$M_ICE = 65536;
literal BIIC$M_NEX = 131072;
literal BIIC$M_BTO = 262144;
literal BIIC$M_STO = 524288;
literal BIIC$M_RTO = 1048576;
literal BIIC$M_RDS = 2097152;
literal BIIC$M_SPE = 4194304;
literal BIIC$M_CPE = 8388608;
literal BIIC$M_IVE = 16777216;
literal BIIC$M_TDF = 33554432;
literal BIIC$M_ISE = 67108864;
literal BIIC$M_MPE = 134217728;
literal BIIC$M_CTE = 268435456;
literal BIIC$M_MTCE = 536870912;
literal BIIC$M_NMR = 1073741824;
literal BIIC$M_EIFORCE = 1048576;
literal BIIC$M_EISENT = 2097152;
literal BIIC$M_EIINTC = 8388608;
literal BIIC$M_EIINTAB = 16777216;
literal BIIC$M_RTOEVEN = 8;
literal BIIC$M_PNXTEN = 16;
literal BIIC$M_IPINTREN = 32;
literal BIIC$M_INTREN = 64;
literal BIIC$M_BICSREN = 128;
literal BIIC$M_UCSREN = 256;
literal BIIC$M_WINVALEN = 512;
literal BIIC$M_INVALEN = 1024;
literal BIIC$M_IDENTEN = 2048;
literal BIIC$M_RESEN = 4096;
literal BIIC$M_STOPEN = 8192;
literal BIIC$M_BDCSTEN = 16384;
literal BIIC$M_MSEN = 32768;
literal BIIC$M_IPINTRF = 65536;
literal BIIC$M_BURSTEN = 131072;
literal BIIC$M_GPR0 = 268435456;
literal BIIC$M_GPR1 = 536870912;
literal BIIC$M_GPR2 = 1073741824;
literal BIIC$M_GPR3 = -2147483648;
literal BIIC$M_MIDEN = 2048;
literal BIIC$M_EXVECTOR = 32768;
literal BIIC$S_BIICDEF = 256;
! +
!  BI Required Registers
! -
macro BIIC$L_DTREG = 0,0,32,0 %;        ! Device Type Register
macro BIIC$W_DEVTYPE = 0,0,16,0 %;      !  Device Type Field
!  Lo order devtype bits
macro BIIC$V_MEMNODE = 0,8,7,0 %;
literal BIIC$S_MEMNODE = 7;             !  If zero, then memory
macro BIIC$V_NONDEC = 0,15,1,0 %;       !  If set, non-DEC node
macro BIIC$W_REVCODE = 2,0,16,0 %;      !  Revision code
macro BIIC$L_BICSR = 4,0,32,0 %;        ! BI Control/Status Register
macro BIIC$V_NODE_ID = 4,0,4,0 %;
literal BIIC$S_NODE_ID = 4;             !  Node ID
macro BIIC$V_ARBCNTL = 4,4,2,0 %;
literal BIIC$S_ARBCNTL = 2;             !  Arbitration Control
macro BIIC$V_SEIE = 4,6,1,0 %;          !  Soft Error interrupt enable
macro BIIC$V_HEIE = 4,7,1,0 %;          !  Hard Error interrupt enable
macro BIIC$V_UWP = 4,8,1,0 %;           !  Unlock Write Pending
macro BIIC$V_SST = 4,10,1,0 %;          !  Start Self test
macro BIIC$V_STS = 4,11,1,0 %;          !  Self test Status
macro BIIC$V_BROKE = 4,12,1,0 %;        !  Broke bit
macro BIIC$V_INIT = 4,13,1,0 %;         !  Init bit
macro BIIC$V_SES = 4,14,1,0 %;          !  Soft error summary
macro BIIC$V_HES = 4,15,1,0 %;          !  Hard error summary
macro BIIC$V_BIICTYPE = 4,16,8,0 %;
literal BIIC$S_BIICTYPE = 8;            !  BIIC type
macro BIIC$V_BIICREVN = 4,24,8,0 %;
literal BIIC$S_BIICREVN = 8;            !  BIIC Revision Number
macro BIIC$L_BER = 8,0,32,0 %;          ! Bus Error Register
macro BIIC$V_NPE = 8,0,1,0 %;           !  Null Bus Parity Error
macro BIIC$V_CRD = 8,1,1,0 %;           !  Corrected Read Data
macro BIIC$V_IPE = 8,2,1,0 %;           !  ID Parity Error
macro BIIC$V_UPEN = 8,3,1,0 %;          !  User Parity Enabled
macro BIIC$V_ICE = 8,16,1,0 %;          !  Illegal Confirmation Error
macro BIIC$V_NEX = 8,17,1,0 %;          !  Non-existent Address
macro BIIC$V_BTO = 8,18,1,0 %;          !  Bus Timeout
macro BIIC$V_STO = 8,19,1,0 %;          !  Stall Timeout
macro BIIC$V_RTO = 8,20,1,0 %;          !  Retry Timeout
macro BIIC$V_RDS = 8,21,1,0 %;          !  Read Data Substitute
macro BIIC$V_SPE = 8,22,1,0 %;          !  Slave Parity Error
macro BIIC$V_CPE = 8,23,1,0 %;          !  Command Parity Error
macro BIIC$V_IVE = 8,24,1,0 %;          !  IDENT Vector Error
macro BIIC$V_TDF = 8,25,1,0 %;          !  Transmitter During Fault
macro BIIC$V_ISE = 8,26,1,0 %;          !  Interlock Sequence Error
macro BIIC$V_MPE = 8,27,1,0 %;          !  Master Parity Error
macro BIIC$V_CTE = 8,28,1,0 %;          !  Control Transmit Error
macro BIIC$V_MTCE = 8,29,1,0 %;         !  Master Transmit Check Error
macro BIIC$V_NMR = 8,30,1,0 %;          !  No Ack to Multi-Responder Command
macro BIIC$L_EICR = 12,0,32,0 %;        ! Error Interrupt Control Register
macro BIIC$V_EIVECTOR = 12,2,12,0 %;
literal BIIC$S_EIVECTOR = 12;           !  Vector
macro BIIC$V_LEVEL = 12,16,4,0 %;
literal BIIC$S_LEVEL = 4;               !  Interrupt Level
macro BIIC$V_EIFORCE = 12,20,1,0 %;     !  Force
macro BIIC$V_EISENT = 12,21,1,0 %;      !  INTR command sent
macro BIIC$V_EIINTC = 12,23,1,0 %;      !  Interrupt Complete
macro BIIC$V_EIINTAB = 12,24,1,0 %;     !  Interrupt Abort
macro BIIC$L_IDR = 16,0,32,0 %;         !  Interrupt Destination
!   decoded ID in Lo order
! +
!  BIIC Specific Device Registers
! -
macro BIIC$L_IPIMR = 20,0,32,0 %;       !  IP Interrupt Mask
!   decoded ID in Hi order
macro BIIC$L_IPIDR = 24,0,32,0 %;       !  IP Interrupt Destination
!   decoded ID in Lo order
macro BIIC$L_IPISR = 28,0,32,0 %;       !  IP Interrupt Source
!   decoded ID in Hi order
! Note: following two
!  registers have lo order
!  18 bits MBZ. This means
!  memories are multiples
!  of 256KB.
macro BIIC$L_SAR = 32,0,32,0 %;         !  Starting Address Register
macro BIIC$L_EAR = 36,0,32,0 %;         !  Ending Address Register
macro BIIC$L_BCICR = 40,0,32,0 %;       ! BCI Control Register
macro BIIC$V_RTOEVEN = 40,3,1,0 %;      !  RTO EV Enable
macro BIIC$V_PNXTEN = 40,4,1,0 %;       !  Pipeline NXT Enable
macro BIIC$V_IPINTREN = 40,5,1,0 %;     !  IP Interrupt Enable
macro BIIC$V_INTREN = 40,6,1,0 %;       !  Interrupt Enable
macro BIIC$V_BICSREN = 40,7,1,0 %;      !  BIIC CSR Space Enable
macro BIIC$V_UCSREN = 40,8,1,0 %;       !  User CSR Space Enable
macro BIIC$V_WINVALEN = 40,9,1,0 %;     !  Write Invalidate Enable
macro BIIC$V_INVALEN = 40,10,1,0 %;     !  INVAL Enable
macro BIIC$V_IDENTEN = 40,11,1,0 %;     !  IDENT Enable
macro BIIC$V_RESEN = 40,12,1,0 %;       !  Reserved Enable
macro BIIC$V_STOPEN = 40,13,1,0 %;      !  STOP Enable
macro BIIC$V_BDCSTEN = 40,14,1,0 %;     !  Broadcast Enable
macro BIIC$V_MSEN = 40,15,1,0 %;        !  Multicast Space Enable
macro BIIC$V_IPINTRF = 40,16,1,0 %;     !  IP Interrupt Force
macro BIIC$V_BURSTEN = 40,17,1,0 %;     !  Burst Enable
macro BIIC$L_WSR = 44,0,32,0 %;         ! Write Status Register
macro BIIC$V_GPR0 = 44,28,1,0 %;        !  These bits indicate
macro BIIC$V_GPR1 = 44,29,1,0 %;        !   that the corresponding
macro BIIC$V_GPR2 = 44,30,1,0 %;        !   General Purpose Register
macro BIIC$V_GPR3 = 44,31,1,0 %;        !   has been written to.
macro BIIC$L_IPISTPF = 48,0,32,0 %;     ! IPINTR/STOP Force CMD Reg
macro BIIC$V_MIDEN = 48,11,1,0 %;       !  Determines whether Master ID
!   transmitted on BI D<31:16>.
macro BIIC$V_CMD = 48,12,4,0 %;
literal BIIC$S_CMD = 4;                 !  Command (IPINTR or STOP).
macro BIIC$L_UICR = 64,0,32,0 %;        ! UserInterrupt Control Register
macro BIIC$V_UIVECTOR = 64,2,12,0 %;
literal BIIC$S_UIVECTOR = 12;           !  Vector
macro BIIC$V_EXVECTOR = 64,15,1,0 %;    !  External Vector
macro BIIC$V_UIFORCE = 64,16,4,0 %;
literal BIIC$S_UIFORCE = 4;             !  Force (1 for each level)
macro BIIC$V_UISENT = 64,20,4,0 %;
literal BIIC$S_UISENT = 4;              !  INTR command sent(1 for each level)
macro BIIC$V_UIINTC = 64,24,4,0 %;
literal BIIC$S_UIINTC = 4;              !  Interrupt Complete(1 for each level)
macro BIIC$V_UIINTAB = 64,28,4,0 %;
literal BIIC$S_UIINTAB = 4;             !  Interrupt Abort(1 for each level)
! +
!  BIIC General Purpose Device Registers
! -
macro BIIC$L_GPR0 = 240,0,32,0 %;       ! General Purpose Register 0
macro BIIC$L_GPR1 = 244,0,32,0 %;       ! General Purpose Register 1
macro BIIC$L_GPR2 = 248,0,32,0 %;       ! General Purpose Register 2
macro BIIC$L_GPR3 = 252,0,32,0 %;       ! General Purpose Register 3
 
!*** MODULE $BIMEMDEF ***
! +
!  BI Memory Node Registers
! -
literal BIMEM$M_INTLV = 256;
literal BIMEM$M_CNTLERR = 512;
literal BIMEM$M_MWRITER = 1024;
literal BIMEM$M_BROKE = 4096;
literal BIMEM$M_INTLK = 8192;
literal BIMEM$M_MEMVAL = 16384;
literal BIMEM$M_INHCRD = 32768;
literal BIMEM$M_ECCDIS = 536870912;
literal BIMEM$M_ECCDIAG = 1073741824;
literal BIMEM$M_ERRSUM = -2147483648;
literal BIMEM$M_INTLVAD = 256;
literal BIMEM$M_ADRSERR = 268435456;
literal BIMEM$M_CRDLOGR = 536870912;
literal BIMEM$M_HIERATE = 1073741824;
literal BIMEM$M_RDSLOGR = -2147483648;
literal BIMEM$S_BIMEMDEF = 264;
macro BIMEM$L_CSR1 = 256,0,32,0 %;      ! CSR 1
macro BIMEM$V_DIAGBTS = 256,0,7,0 %;
literal BIMEM$S_DIAGBTS = 7;            !  Used during ECC diag cycles
macro BIMEM$V_INTLV = 256,8,1,0 %;      !  1=> internally lnterleaved
macro BIMEM$V_CNTLERR = 256,9,1,0 %;    !  Controller error
macro BIMEM$V_MWRITER = 256,10,1,0 %;   !  RDS on masked write
macro BIMEM$V_BROKE = 256,12,1,0 %;     !  Broke bit
macro BIMEM$V_INTLK = 256,13,1,0 %;     !  Interlock flag
macro BIMEM$V_MEMVAL = 256,14,1,0 %;    !  Memory contents valid
macro BIMEM$V_INHCRD = 256,15,1,0 %;    !  Inhib. CRD reporting
macro BIMEM$V_RAMTYPE = 256,16,2,0 %;
literal BIMEM$S_RAMTYPE = 2;            !  00=>64Ks, 01=>256Ks
macro BIMEM$V_MEMSIZE = 256,18,11,0 %;
literal BIMEM$S_MEMSIZE = 11;           !  Size in 256KB increments
macro BIMEM$V_ECCDIS = 256,29,1,0 %;    !  Used with following bit
macro BIMEM$V_ECCDIAG = 256,30,1,0 %;   !  
macro BIMEM$V_ERRSUM = 256,31,1,0 %;    !  Error summary(includes CSR2)
macro BIMEM$L_CSR2 = 260,0,32,0 %;      ! CSR 2
macro BIMEM$V_ERRSYND = 260,0,7,0 %;
literal BIMEM$S_ERRSYND = 7;            !  Error syndrome
macro BIMEM$V_INTLVAD = 260,8,1,0 %;    !  Interleave Address
macro BIMEM$V_ERRADDR = 260,9,15,0 %;
literal BIMEM$S_ERRADDR = 15;           !  Internal addr of error
macro BIMEM$V_ADRSERR = 260,28,1,0 %;   !  Internal address parity error
macro BIMEM$V_CRDLOGR = 260,29,1,0 %;   !  CRD Error Log REQ
macro BIMEM$V_HIERATE = 260,30,1,0 %;   !  Hi Error Rate
macro BIMEM$V_RDSLOGR = 260,31,1,0 %;   !  RDS Error Log REQ
 
!*** MODULE $BIPBDEF ***
! +
!  Define Generic BI device Parameter Block area for passing block data
!  between SYSLOA and SYSGEN modules.
! -
literal BIPB$K_LEN = 16;                !  Length of the BIPB parameter block
literal BIPB$S_BIPBDEF = 16;
macro BIPB$L_BI_IDR = 0,0,32,1 %;       !  BI interrupt destination node ID
macro BIPB$L_SCB_PAGE = 4,0,32,1 %;     !  SCB page offset for this BI
macro BIPB$L_BINODE = 8,0,32,1 %;       !  BI node ID of this device
macro BIPB$L_BIMASTER = 12,0,32,1 %;    !  Pointer to ADP of BI adapter
 
!*** MODULE $BODDEF ***
! +
!  BOD - Buffer Object Descriptor
!  
!   A buffer object descriptor defines a buffer object used
!   by the I/O subsystem.
! -
literal BOD$M_DELPEN = 1;
literal BOD$M_NOQUOTA = 2;
literal BOD$K_LENGTH = 48;              !  LENGTH OF STRUCTURE
literal BOD$C_LENGTH = 48;              !  LENGTH OF STRUCTURE
literal BOD$S_BODDEF = 48;
macro BOD$L_FLINK = 0,0,32,0 %;         !   FLINK into PCB list
macro BOD$L_BLINK = 4,0,32,0 %;         !   BLINK into PCB list
macro BOD$W_SIZE = 8,0,16,0 %;          !   Size of fixed portion of BOOTCB 
macro BOD$B_TYPE = 10,0,8,0 %;          !   Type of control block 
macro BOD$B_ACMODE = 11,0,8,0 %;        !   Owner access mode
macro BOD$L_SEQNUM = 12,0,32,0 %;       !   Sequence # at object creation
macro BOD$W_REFCNT = 16,0,16,0 %;       !   No. of references to this BOD
macro BOD$W_FLAGS = 18,0,16,0 %;        !   Flags word
macro BOD$V_DELPEN = 18,0,1,0 %;        !   Delete pending
macro BOD$V_NOQUOTA = 18,1,1,0 %;       !   No quota charge for S0 window
macro BOD$L_PID = 20,0,32,0 %;          !   PID of creating process
macro BOD$L_PAGCNT = 24,0,32,0 %;       !   No. of pages in buffer object
macro BOD$L_BASEPVA = 28,0,32,0 %;      !   Base process address of buffer object
macro BOD$L_BASESVA = 32,0,32,0 %;      !   Base system  address of buffer object
macro BOD$L_SPARE_1 = 36,0,32,0 %;      !   SPARE
macro BOD$L_SPARE_2 = 40,0,32,0 %;      !   SPARE
macro BOD$L_SPARE_3 = 44,0,32,0 %;      !   SPARE
 
!*** MODULE $BOODEF ***
! +
!  BOO - Boot Control Block
! 
!  A boot control block is produced by SYSBOOT and placed in non-paged
!  pool.  It is pointed to by the cell EXE$GL_BOOTCB and contains
!  the mapping information for SYSDUMP.DMP.
! -
literal BOO$K_LENGTH = 40;
literal BOO$C_LENGTH = 40;
literal BOO$S_BOODEF = 40;
macro BOO$L_CHECKSUM = 0,0,32,0 %;      !  Checksum 
macro BOO$L_TIMELBN = 4,0,32,0 %;       !  LBN of system time quadword
macro BOO$W_SIZE = 8,0,16,0 %;          !  Size of fixed portion of BOOTCB 
macro BOO$B_TYPE = 10,0,8,0 %;          !  Type of control block 
macro BOO$B_SUBTYP = 11,0,8,0 %;        !  Sub-type 
macro BOO$L_DMP_VBN = 12,0,32,0 %;      !  Starting VBN for dump file 
macro BOO$L_DMP_SIZE = 16,0,32,0 %;     !  Size in blocks of dump file 
!  from starting VBN to end of file
macro BOO$L_DMP_MAP = 20,0,32,0 %;      !  Adr of map for SYSDUMP.DMP 
macro BOO$L_BUG_WCB = 24,0,32,0 %;      !  Adr of WCB for bugcheck image
macro BOO$L_BUG_LBN = 28,0,32,0 %;      !  LBN of first page of bugcheck code
macro BOO$L_BUG_IMAGE_VA = 32,0,32,0 %; !  Base VA of image containing bugcheck
macro BOO$L_SCB_LBN = 36,0,32,0 %;      !  LBN of the storage control block (SCB) on system disk
 
!*** MODULE $BPTDEF ***
!  +
! 
!   Define bits which control which hardcoded calls to INI$BRK (the initial BPT)
!   will be executed as a system is being booted.
! 
!  -
literal BPT$M_INITBEGIN = 1;
literal BPT$M_INITEND = 2;
literal BPT$M_SMPSTART = 4;
literal BPT$S_BPTDEF = 4;
macro BPT$V_INITBEGIN = 0,0,1,0 %;      !  BRK at start of INIT
macro BPT$V_INITEND = 0,1,1,0 %;        !  BRK at end of INIT
macro BPT$V_SMPSTART = 0,2,1,0 %;       !  BRK at INIT call to setup SMP
 
!*** MODULE $BQODEF ***
! +
! 
!  Offsets into the IO vector of the BOOT driver.
! 
! -
literal BQO$S_BQODEF = 96;
macro BQO$L_QIO = 0,0,32,0 %;           !  QIO entry 
macro BQO$L_MAP = 4,0,32,0 %;           !  Mapping entry 
macro BQO$L_SELECT = 8,0,32,0 %;        !  Selection entry 
macro BQO$L_DRIVRNAME = 12,0,32,0 %;    !  Offset to driver name 
macro BQO$W_VERSION = 16,0,16,0 %;      !  Version number of VMB 
macro BQO$W_VERCHECK = 18,0,16,0 %;     !  Check field 
macro BQO$L_RESELECT = 20,0,32,0 %;     !  Reselection entry 
macro BQO$L_MOVE = 24,0,32,0 %;         !  Move driver entry 
macro BQO$L_UNIT_INIT = 28,0,32,0 %;    !  Unit initialization entry 
macro BQO$L_AUXDRNAME = 32,0,32,0 %;    !  Offset to auxiliary driver name 
macro BQO$L_UMR_DIS = 36,0,32,0 %;      !  UNIBUS Map Registers to disable 
macro BQO$L_UCODE = 40,0,32,0 %;        !  Absolute address of booting microcode 
macro BQO$L_UNIT_DISC = 44,0,32,0 %;    !  Unit disconnecting entry
macro BQO$L_DEVNAME = 48,0,32,0 %;      !  Offset to boot device name
macro BQO$L_UMR_TMPL = 52,0,32,0 %;     !  UNIBUS map register template
macro BQO$B_UMR_DP = 56,0,8,0 %;        !  UNIBUS map register data path
macro BQO$B_CPUTYPE = 57,0,8,0 %;       !  Cpu type from SID
macro BQO$L_CPUDATA = 58,0,32,0 %;      !  Cpu data from SID
macro BQO$L_TENUSEC = 62,0,32,0 %;      !  TIMEDWAIT loop delay counter
macro BQO$L_UBDELAY = 66,0,32,0 %;      !  TIMEDWAIT loop delay counter
macro BQO$W_RSVDW = 70,0,16,0 %;        !  reserved word to put
!  back on longword boundary
macro BQO$L_UMR_PHY = 72,0,32,0 %;      !  phy. addr of BDA map reg.
macro BQO$L_UMR_VIR = 76,0,32,0 %;      !  vir. addr of BDA map reg.
macro BQO$L_AUXDRLIST = 80,0,32,0 %;    !  Offset to auxiliary driver list
macro BQO$L_CRAM_CMD = 84,0,32,0 %;     !  Offset to CRAM command
macro BQO$Q_DYNAMIC_STORAGE_DESCR = 88,0,32,0 %; !  Allocated dynamic storage descriptor
macro BQO$L_DYNAMIC_STORAGE_LEN = 88,0,32,0 %; !  Allocated dynamic storage size in bytes
macro BQO$L_DYNAMIC_STORAGE_OFFSET = 92,0,32,0 %; !  Allocated dynamic storage offset
 
!*** MODULE $BRKTDEF ***
! 
!  +
!  
!   Structure of breakthru message descriptor block.
!  
!  -
literal BRK$M_LOCKED = 1;
literal BRK$M_DONE = 2;
literal BRK$M_CHKPRIV = 4;
literal BRK$C_LENGTH = 142;
literal brk2$C_LENGTH = 14;
literal S_$BRKTDEF = 142;
macro BRKTHRU_OVERLAY = 0,0,0,0 %;      !  set up overlay
macro BRKTHRU_1 = 0,0,0,0 %;
literal BRK$S_BRKTHRU_1 = 142;
!  
!   Common Storage
!   
macro BRK$Q_PRIVS = 0,0,0,0 %;
literal BRK$S_PRIVS = 8;                !   privs to set
macro BRK$W_SIZE = 8,0,16,0 %;          !   block size
macro BRK$W_OUTCNT = 10,0,16,0 %;       !   outstanding I/O count
macro BRK$T_DEVNAME = 12,0,0,0 %;
literal BRK$S_DEVNAME = 16;             !   device name for $ASSIGN
macro BRK$L_PCB = 28,0,32,0 %;          !   Address of PCB
macro BRK$L_IOSB = 32,0,32,0 %;         !   Address of return IOSB
macro BRK$L_ASTADR = 36,0,32,0 %;       !   Address of AST routine
macro BRK$L_ASTPRM = 40,0,32,0 %;       !   Value of AST parameter
macro BRK$Q_TIMEOUT = 44,0,0,0 %;
literal BRK$S_TIMEOUT = 8;              !   Timeout value
macro BRK$L_CARCON = 52,0,32,0 %;       !   carriage control
macro BRK$L_FLAGS = 56,0,32,0 %;        !   flags
macro BRK$T_SENDNAME = 60,0,0,0 %;
literal BRK$S_SENDNAME = 16;            !   username/terminal name
macro BRK$W_SENDTYPE = 76,0,16,0 %;     !   send descriptor type
macro BRK$W_SECONDS = 78,0,16,0 %;      !   Timeout in seconds
macro BRK$L_REQID = 80,0,32,0 %;        !   send requestor ID
!  
!   miscellaneous context
!  
macro BRK$L_PIDCTX = 84,0,32,0 %;       !   Last PID in user search
macro BRK$L_UCBCTX = 88,0,32,0 %;       !   Last UCB in TTY search
macro BRK$L_DDBCTX = 92,0,32,0 %;       !   Last DDB in TTY search
macro BRK$L_QIOCTX = 96,0,32,0 %;       !   per QIO context address
macro BRK$W_EFN = 100,0,16,0 %;         !   user event flag *BYTE***?
macro BRK$B_STS = 102,0,8,0 %;          !   status flags
macro BRK$V_LOCKED = 102,0,1,0 %;       !  I/O dataabse locked
macro BRK$V_DONE = 102,1,1,0 %;         !  done looking for terminals
macro BRK$V_CHKPRIV = 102,2,1,0 %;      !  check privilege
macro BRK$B_PRVMODE = 103,0,8,0 %;      !   previous mode
macro BRK$L_SCRMSGLEN = 104,0,32,0 %;   !   screen message length
macro BRK$L_SCRMSG = 108,0,32,0 %;      !   screen message address
!  
!   status block
!   
macro BRK$W_STATUS = 112,0,16,0 %;      !   status
macro BRK$W_SUCCESSCNT = 114,0,16,0 %;  !   Success count
macro BRK$W_TIMEOUTCNT = 116,0,16,0 %;  !   Timeout count
macro BRK$W_REFUSEDCNT = 118,0,16,0 %;  !   Refused count
!  
!   start of mailbox message 
!  
macro BRK$W_TRMMSG = 120,0,16,0 %;      !   mailbox message code
macro BRK$W_TRMUNIT = 122,0,16,0 %;     !   tty unit number
macro BRK$T_TRMNAME = 124,0,0,0 %;
literal BRK$S_TRMNAME = 16;             !   terminal name
!  
!   real message starts here
!  
macro BRK$W_MSGLEN = 140,0,16,0 %;      !   length of msgbuf
macro BRK$T_MSGBUF = 142,0,0,0 %;       !   start of message    
! 
!  Length
! 
macro BRKTHRU_2 = 0,0,0,0 %;
literal brk2$S_BRKTHRU_2 = 14;
!  
!   Per QIO storage
!  
macro brk2$L_COMMON = 0,0,32,0 %;       !   address of common area
macro brk2$Q_IOSB = 4,0,0,0 %;
literal brk2$S_IOSB = 8;                !   iosb for QIO
macro brk2$W_CHAN = 12,0,16,0 %;        !   channel
! 
!  Length of Per QIO context
! 
 
!*** MODULE $BTBDEF ***
literal BTB$K_LENGTH_PART1 = 480;       !  Length of 1st part of boot block
literal BTB$M_NOTCONTIG = 1;
literal BTB$K_LENGTH = 512;             !  Length of a boot block
literal BTB$S_BTBDEF = 512;
macro BTB$B_NOP1 = 0,0,8,0 %;           !  Contains NOP opcode
macro BTB$B_BRB = 1,0,8,0 %;            !  Contains BRB opcode
macro BTB$B_BRB_OFFSET = 2,0,8,0 %;     !  Contains PC relative offset of branch
macro BTB$B_NOP2 = 3,0,8,0 %;           !  Contains NOP opcode
macro BTB$L_LBN1 = 4,0,32,1 %;          !  Starting LBN of 1st boot file
macro BTB$W_HIGH_LBN = 4,0,16,0 %;      !  High 32-bits of LBN
macro BTB$W_LOW_LBN = 6,0,16,0 %;       !  Low 32-bits of LBN
macro BTB$B_VAX_BRB = 12,0,8,0 %;       !  Contains BRB opcode (VAX)
macro BTB$B_VAX_OFFSET = 13,0,8,0 %;    !  Contains PC relative offset of branch
macro BTB$B_PDP_BRB = 15,0,8,0 %;       !  Contain BRB opcode (PDP)
macro BTB$B_PDP_OFFSET = 16,0,8,0 %;    !  Contains PC relative offset of branch
macro BTB$B_INST_SET = 22,0,8,0 %;      !  Instruction set code (%x18=VAX)
macro BTB$B_FILE_STR = 23,0,8,0 %;      !  File structure (ODS-II =2)
macro BTB$B_COMP3 = 24,0,8,0 %;         !  Complement of sum of previous 3 bytes
macro BTB$B_VERSION = 26,0,8,0 %;       !  Boot block version=1
macro BTB$L_SIZE = 28,0,32,0 %;         !  Size in LBNs of image
macro BTB$L_LOAD_OFFSET = 32,0,32,0 %;  !  Load offset into good memory
macro BTB$L_START_OFFSET = 36,0,32,0 %; !  Offset to begin execution
macro BTB$L_CHECKSUM = 40,0,32,0 %;     !  Checksum of three previous longwords
macro BTB$B_CODE = 44,0,0,1 %;
literal BTB$S_CODE = 92;                !  VAX boot block code 
macro BTB$B_FILL4 = 136,0,0,1 %;
literal BTB$S_FILL4 = 344;              !  Reserved for future use
macro BTB$Q_SIZE2 = 480,0,0,0 %;
literal BTB$S_SIZE2 = 8;                !  Size of 2nd boot file
macro BTB$L_LOW_SIZE2 = 480,0,32,1 %;   !  Low 32-bits of size
macro BTB$L_HIGH_SIZE2 = 484,0,32,1 %;  !  High 32-bits of size
macro BTB$Q_LBN2 = 488,0,0,0 %;
literal BTB$S_LBN2 = 8;                 !  Starting LBN of 2nd boot file
macro BTB$L_LOW_LBN2 = 488,0,32,1 %;    !  Low 32-bits of LBN
macro BTB$L_HIGH_LBN2 = 492,0,32,1 %;   !  High 32-bits of LBN
macro BTB$Q_FLAGS = 496,0,0,0 %;
literal BTB$S_FLAGS = 8;                !  Boot block flags
macro BTB$L_LOW_FLAGS = 496,0,32,0 %;   !  Low longword of flags
macro BTB$L_HIGH_FLAGS = 500,0,32,0 %;  !  High longword of flags
macro BTB$V_NOTCONTIG = 496,0,1,0 %;    !  Bootstrap is not contiguous
macro BTB$Q_CHECKSUM2 = 504,0,0,0 %;
literal BTB$S_CHECKSUM2 = 8;            !  Checksum of entire block
macro BTB$L_LOW_CHECK2 = 504,0,32,1 %;  !  Low 32-bits of checksum
macro BTB$L_HIGH_CHECK2 = 508,0,32,1 %; !  High 32-bits of checksum
 
!*** MODULE $BTDDEF ***
! +
! 
!  Boot device codes
! 
! -
!  "$K_" added, 8/30/79, CHP
literal BTD$K_MB = 0;                   !  Massbus device
!  Types 1-31. reserved for
!   Unibus(Qbus) devices
literal BTD$K_DM = 1;                   !  RK06/7
literal BTD$K_DL = 2;                   !  RL02
literal BTD$K_DQ = 3;                   !  RB02/RB80
literal BTD$K_PROM = 8;                 !  PROM (not copied)
literal BTD$K_PROM_COPY = 9;            !  PROM copied (Mayflower)
literal BTD$K_UDA = 17;                 !  UDA
literal BTD$K_TK50 = 18;                !  TK50 (MAYA)
literal BTD$K_KFQSA = 19;               !  KFQSA
literal BTD$K_QBUS_SCSI = 20;           !  Qbus SCSI adapter
!  End of Unibus(Qbus) devices
literal BTD$K_HSCCI = 32;               !  HSC on CI
literal BTD$K_BDA = 33;                 !  BI disk adapter
literal BTD$K_BVPSSP = 34;              !  BVP Storage Systems ports
literal BTD$K_AIE_TK50 = 35;            !  AIE/TK50 port
literal BTD$k_ST506_DISK = 36;          !  ST506 disk (PVAX/VAXstar)
literal BTD$K_KA410_DISK = 36;          !  VAXstar ST506 disk
literal BTD$K_KA420_DISK = 36;          !  PVAX ST506 disk
literal BTD$K_SCSI_5380_TAPE = 37;      !  NCR 5380 SCSI tape (PVAX/VAXstar)
literal BTD$K_KA410_TAPE = 37;          !  VAXstar SCSI tape
literal BTD$K_KA420_TAPE = 37;          !  PVAX SCSI tape
literal BTD$K_DISK9 = 38;               !  Disk on 009
literal BTD$K_SII = 39;                 !  Embedded DSSI controller
literal BTD$K_SHAC = 41;                !  Single chip DSSI adapter.
literal BTD$K_SCSI_5380_DISK = 42;      !  NCR 5380 SCSI disk (PVAX)
literal BTD$K_HSX = 43;
literal BTD$K_KDM70 = 43;
literal BTD$K_HSXTAPE = 44;
literal BTD$K_KDM70TAPE = 44;
literal BTD$K_SWIFT = 45;               !  Another embedded DSSI controller-CIRRUS
literal BTD$K_SCSI_53C94_DISK = 46;
literal BTD$K_SCSI_53C94_TAPE = 47;
literal BTD$K_CONSOLE = 64;             !  Console block storage device
!  Network boot devices (96-103)
literal BTD$K_NET_DLL = 96;             !  Start of network boot devices
!   Codes 96-127 reserved
literal BTD$K_QNA = 96;                 !  DEQNA
literal BTD$K_UNA = 97;                 !  DEUNA
literal BTD$K_AIE_NI = 98;              !  AIE/NI
literal BTD$K_LANCE = 99;               !  LANCE NI chip
literal BTD$K_KA410_NI = 99;            !  VAXstar NI (LANCE chip)
literal BTD$K_KA420_NI = 99;            !  PVAX NI (LANCE chip)
literal BTD$K_SGEC = 100;               !  SGEC chip
literal BTD$K_SERVER_DEBNA = 101;
literal BTD$K_SERVER_DEBNI = 102;
literal BTD$K_SERVER_XNA = 103;
literal BTD$K_DEBNI = 104;              !  DEBNI
literal BTD$K_DEMNA = 105;              !  DEMNA
literal BTD$K_KA520_NI = 106;           !  CIRRUS NI
literal BTD$K_SERVER_QNA = 107;
literal BTD$K_SERVER_AIE_NI = 108;
literal BTD$K_SERVER_LANCE = 109;
literal BTD$K_SERVER_SGEC = 110;
literal BTD$K_SERVER_KA520_NI = 111;
literal BTD$K_DEMFA = 112;              !  DEMFA
literal BTD$K_SERVER_DEMFA = 113;       !  NI-CDROM server
literal BTD$K_DEFZA = 114;
literal BTD$K_SERVER_DEFZA = 115;
literal BTD$K_PMAD = 116;
literal BTD$K_SERVER_PMAD = 117;
literal BTD$K_NETWORK_BOOT = 128;       !  Generic boot over NI
literal BTD$K_NISCS = 128;              !  SCS disk over NI
 
!*** MODULE $BUADEF ***
! +
!  BI Bus UNIBUS Adapter Register Offset Definitions
! -
literal BUA$M_UBPUP = 1;
literal BUA$M_ONE = 32768;
literal BUA$M_REGDMP = 65536;
literal BUA$M_UPI = 131072;
literal BUA$M_EIE = 1048576;
literal BUA$M_PARDIS = 2097152;
literal BUA$M_BADBDP = 16777216;
literal BUA$M_IMR = 33554432;
literal BUA$M_UIE = 67108864;
literal BUA$M_USSTO = 134217728;
literal BUA$M_BIF = 268435456;
literal BUA$M_BADPARITY = 536870912;
literal BUA$M_ERR = -2147483648;
literal BUA$M_PURGE = 1;
literal BUA$M_MAP_BO = 33554432;
literal BUA$M_LWAEN = 67108864;
literal BUA$M_PPIE = 1073741824;
literal BUA$M_MAP_VALID = -2147483648;
literal BUA$C_MAXDP = 5;                ! MAXIMUM DATAPATH ! 
literal BUA$S_BUADEF = 4032;
macro BUA$L_GPR0 = 240,0,32,0 %;
macro BUA$V_UBPUP = 240,0,1,0 %;        !  UNIBUS Power Up (RO)
macro BUA$V_IEN_COPY = 240,16,16,0 %;
literal BUA$S_IEN_COPY = 16;            !  Internal Error Number copied
!   here from BUACSR.
!   is 720 (Hex)
!  This register holds the error summaries and error interrupt enable for BUA.
macro BUA$L_CSR = 1824,0,32,0 %;        !  Control and Status Register
macro BUA$V_IEN = 1824,0,8,0 %;
literal BUA$S_IEN = 8;                  !  Instruction Error Number (RO)
!   Self Test failure code
macro BUA$V_ONE = 1824,15,1,0 %;        !  RO bit that is always read as one.
!   If bit is zero, this implies that
!   we have lost UNIBUS power.
macro BUA$V_REGDMP = 1824,16,1,0 %;     !  uDiagnostic Register Dump bit.  (WO)
!   When 1 is written, causes uEngine to
!   dump stored internal registers.
macro BUA$V_UPI = 1824,17,1,0 %;        !  UNIBUS Power Initialization bit. (WO)
!   When 1 written, causes power up init
!   on UNIBUS.
macro BUA$V_EIE = 1824,20,1,0 %;        !  BUA Error Interrupt Enable (R/W)
macro BUA$V_PARDIS = 1824,21,1,0 %;     !  BUA PARity Disable. When a ONE is
!   written to this bit, the BUA will
!   not generate any parity while
!   writing its internal RAM. For
!   diagnostic use.
macro BUA$V_BADBDP = 1824,24,1,0 %;     !  Bit set if BDP 6 or 7 selected (W1C).
macro BUA$V_IMR = 1824,25,1,0 %;        !  Invalid Map Register (W1C)
macro BUA$V_UIE = 1824,26,1,0 %;        !  Bit set if DATO(B) does not follow
!   DATIP on UNIBUS (W1C)
macro BUA$V_USSTO = 1824,27,1,0 %;      !  UNIBUS SSYNC timeout (W1C)
macro BUA$V_BIF = 1824,28,1,0 %;        !  UNIBUS to BI failure (W1C)
macro BUA$V_BADPARITY = 1824,29,1,0 %;  !  This bit is set if the BUA found a
!   parity error during reading of its
!   internal RAM.
macro BUA$V_ERR = 1824,31,1,0 %;        !  Logical OR of error bits in CSR (RO)
!  BUA Vector Offset Register - BITS [13:09] of the VOR register are
!   concatenated with the incoming UNIBUS vector to form a 14 bit BI vector.
macro BUA$L_VOR = 1828,0,32,0 %;        !  Vector Offset Register
macro BUA$V_VECOFF = 1828,9,5,0 %;
literal BUA$S_VECOFF = 5;               !  Vector Offset (R/W)
!  Failed UNIBUS Address Register (FUBAR)
macro BUA$L_FUBAR = 1832,0,32,0 %;      !  Failed UNIBUS Address Register
macro BUA$V_FUBAR_ADR = 1832,0,16,0 %;
literal BUA$S_FUBAR_ADR = 16;           !  Failed UNIBUS Address (Hi 16 bits)
macro BUA$L_BIFAR = 1836,0,32,0 %;      !  BI Failed Address Register
macro BUA$L_BDP1 = 1840,0,32,0 %;       !  BDP1
macro BUA$V_STATUS = 1840,0,16,0 %;
literal BUA$S_STATUS = 16;              !  Bit for each byte
macro BUA$V_ADDR = 1840,16,16,0 %;
literal BUA$S_ADDR = 16;                !  UNIBUS addr of octaword
macro BUA$L_BDP2 = 1844,0,32,0 %;       !  BDP2
macro BUA$L_BDP3 = 1848,0,32,0 %;       !  BDP3
macro BUA$L_BDP4 = 1852,0,32,0 %;       !  BDP4
macro BUA$L_BDP5 = 1856,0,32,0 %;       !  BDP5
macro BUA$L_DPCSR0 = 1872,0,32,0 %;     !  Datapath 0 CSR
macro BUA$V_PURGE = 1872,0,1,0 %;       !  Purge (WO) bit
macro BUA$V_DPSEL = 1872,21,3,0 %;
literal BUA$S_DPSEL = 3;                !  Data Path #
macro BUA$L_DPCSR1 = 1876,0,32,0 %;     !  Datapath 1 CSR
macro BUA$L_DPCSR2 = 1880,0,32,0 %;     !  Datapath 2 CSR
macro BUA$L_DPCSR3 = 1884,0,32,0 %;     !  Datapath 3 CSR
macro BUA$L_DPCSR4 = 1888,0,32,0 %;     !  Datapath 4 CSR
macro BUA$L_DPCSR5 = 1892,0,32,0 %;     !  Datapath 5 CSR
macro BUA$L_MAP = 2048,0,0,0 %;
literal BUA$S_MAP = 1984;               !  Map Registers
macro BUA$V_MAP_ADDR = 2048,0,21,0 %;
literal BUA$S_MAP_ADDR = 21;            !  PFN
macro BUA$V_MAP_DPD = 2048,21,3,0 %;
literal BUA$S_MAP_DPD = 3;              !  Datapath Designator
macro BUA$V_MAP_BO = 2048,25,1,0 %;     !  Byte Offset
macro BUA$V_LWAEN = 2048,26,1,0 %;      !  Long Word Access Enable
macro BUA$V_PPIE = 2048,30,1,0 %;       !  Reserved for use on BUA's
!   with PDP-11 on UNIBUS.
macro BUA$V_MAP_VALID = 2048,31,1,0 %;  !  Map Register Valid
 
!*** MODULE $BVPDEF ***
! +
!  BI VAX Port Register Definitions
! -
literal BVP$M_CTRL_INSTR = 127;
literal BVP$C_CTR_NULL = 0;             !  Null Command
literal BVP$C_CTR_INIT = 1;             !  Initialize Port
!   Data contains high 24 bits
literal BVP$C_CTR_ENABLE = 2;           !  Enable Queue Processing
literal BVP$C_CTR_PIV = 3;              !  Read Vector (PIV)
literal BVP$C_CTR_SHUT = 4;             !  Port Shutdown
literal BVP$C_CTR_MAINT = 5;            !  Enter Maintenance State
literal BVP$C_CTR_CMDQ = 6;             !  Command queue non-empty
!   Data contains the command
literal BVP$C_CTR_FREQ = 7;             !  Free queue non-empty
!   Data contains the free
literal BVP$C_CTR_STATUS = 8;           !  Port status queery
literal BVP$C_CTR_ENSOFT = 9;           !  Enable soft error reports
literal BVP$C_CTR_DSSOFT = 10;          !  Disable soft error reports
literal BVP$C_CTR_START = 11;           !  Restart the port
! 
literal BVP$C_CTR_ADADDR = 26;          !  Load adapter memory address
!  register from port data reg.
literal BVP$C_CTR_BIADDR = 27;          !  Load BI memory address
!  register from port data reg.
literal BVP$C_CTR_READ = 28;            !  Read adapter memory into
!  BI memory
literal BVP$C_CTR_WRITE = 29;           !  Copy BI memory into adapter
!  memory
literal BVP$M_CTRL_OWNER = 128;
literal BVP$M_CTRL_DATA = -256;
literal BVP$M_STAT_SUME = 64;
literal BVP$M_STAT_RSQ = 128;
literal BVP$M_STAT_ETYPE = 65280;
literal BVP$C_TYP_TRANS = 1;            !  Transient BI error
literal BVP$C_TYP_ADAPT = 2;            !  Adapter-wide fatal error
literal BVP$C_TYP_RECVBI = 3;           !  Non-fatal BI error
literal BVP$C_TYP_FATLBI = 4;           !  Fatal BI error
literal BVP$C_TYP_DSE = 5;              !  Data structure error
literal BVP$C_TYP_PLE = 6;              !  Port Logical Error
literal BVP$C_TYP_ADPHD = 7;            !  Adapter hard error
literal BVP$M_STAT_PST = 458752;
literal BVP$C_STA_UNDEF = 1;            !  Undefined
literal BVP$C_STA_INIT = 2;             !  Initialized
literal BVP$C_STA_ENAB = 4;             !  Enabled
literal BVP$C_STA_STOP = 6;             !  Stopped
literal BVP$C_STA_MAINT = 7;            !  Maintenance
literal BVP$C_STA_TEST = 8;             !  Adapter is in self test
literal BVP$C_STA_UNKN = 9;             !  Adapter halted with BI STOP
literal BVP$M_STAT_FQE = 33554432;
literal BVP$M_STAT_ERL = 67108864;
literal BVP$M_STAT_XSTP = 134217728;
literal BVP$M_STAT_ACC = 268435456;
literal BVP$M_STAT_STD = 536870912;
literal BVP$M_STAT_RSPQ = 1073741824;
literal BVP$M_STAT_OWNER = -2147483648;
literal BVP$M_ERROR_CODE = 16777215;
literal BVP$C_ER_ADPHD = 1;             !  Adapter hardware failure
literal BVP$C_ER_BUGCHK = 2;            !  Adapter bugcheck
literal BVP$C_ER_MIN_ST = 3;            !  Failed minimal self test
literal BVP$C_ER_BI_ST = 4;             !  Failed BI self test
literal BVP$C_ER_EXT_ST = 5;            !  Failed extended self-test
literal BVP$C_ER_UCLOAD = 6;            !  Failed microcode load
literal BVP$C_ER_NOUCOD = 7;            !  Microcode not loaded
literal BVP$C_ER_IN_PQB = 8;            !  Invalid PQB contents
literal BVP$C_ER_QRETRY = 9;            !  Queue retry failure
literal BVP$C_ER_BADQOF = 10;           !  Bad queue offset
literal BVP$C_ER_BADINS = 11;           !  Bad port instruction
literal BVP$C_ER_ILLINS = 12;           !  Bad state for port instr.
literal BVP$C_ER_OWNTMO = 13;           !  Ownership timeout
literal BVP$C_ER_HWTMO = 14;            !  Host inactivity timeout
literal BVP$C_ER_FRQE = 15;             !  Free queue exhausted
literal BVP$C_ER_MAINT = 16;            !  Failed to enter MAINT state
literal BVP$C_ER_INIT = 17;             !  Failed to enter INIT state
literal BVP$C_ER_ENABL = 18;            !  Failed to enter ENABLED state
literal BVP$C_ER_BDTKEY = 19;           !  BDT key mismatch
literal BVP$C_ER_BDTSIZ = 20;           !  BDT size too small
literal BVP$C_ER_BDTACC = 21;           !  BDT access check violation
literal BVP$C_ER_BDTPTE = 22;           !  Bad PTE entry
literal BVP$C_ER_BDTIND = 23;           !  BDT index out of range	
literal BVP$M_ERROR_PORT = -16777216;
literal BVP$C_REGDMPLEN = 40;           !  Size of register dump area of error log
literal BVP$S_BVPDEF = 20;
macro BVP$L_CTRL = 0,0,32,0 %;          !  Port Control Register
macro BVP$V_CTRL_INSTR = 0,0,7,0 %;
literal BVP$S_CTRL_INSTR = 7;           !  Port Instruction
!   of the physical PQB address
!   queue number
!   queue number
! 	Port Maintenance Instructions
! 
!  Data field contains byte count
!  Port data reg has progress cnt
!  Data field contains byte count
!  Port data reg has progress cnt
macro BVP$V_CTRL_OWNER = 0,7,1,0 %;     !  Ownership Bit (Set by host, cleared by adapter)
macro BVP$V_CTRL_DATA = 0,8,24,0 %;
literal BVP$S_CTRL_DATA = 24;           !  Instruction-specific data
macro BVP$L_STAT = 4,0,32,0 %;          !  Port Status Register
macro BVP$V_STAT_SUME = 4,6,1,0 %;      !  Summary error bit
macro BVP$V_STAT_RSQ = 4,7,1,0 %;       !  Response queue non-empty
macro BVP$V_STAT_ETYPE = 4,8,8,0 %;
literal BVP$S_STAT_ETYPE = 8;           !  Error Type
macro BVP$V_STAT_PST = 4,16,3,0 %;
literal BVP$S_STAT_PST = 3;             !  Port State
macro BVP$V_STAT_FQE = 4,25,1,0 %;      !  Free queue empty
macro BVP$V_STAT_ERL = 4,26,1,0 %;      !  Error Lost
macro BVP$V_STAT_XSTP = 4,27,1,0 %;     !  Extended self test passed
macro BVP$V_STAT_ACC = 4,28,1,0 %;      !  Adapter can communicate
macro BVP$V_STAT_STD = 4,29,1,0 %;      !  Self test done
macro BVP$V_STAT_RSPQ = 4,30,1,0 %;     !  Response to status query
macro BVP$V_STAT_OWNER = 4,31,1,0 %;    !  Ownership bit (Set by adapter, cleared by host)
macro BVP$L_ERROR = 8,0,32,0 %;         !  Port Error Register
macro BVP$V_ERROR_CODE = 8,0,24,0 %;
literal BVP$S_ERROR_CODE = 24;          !  Error Code
macro BVP$V_ERROR_PORT = 8,24,8,0 %;
literal BVP$S_ERROR_PORT = 8;           !  Port number
macro BVP$L_DATA = 12,0,32,0 %;         !  Port Data Register
macro BVP$L_STATE = 16,0,32,0 %;        !  BVP port state (See PST bit definitions)
 
!*** MODULE $CADEF ***
! +
!  CONDITIONAL ASSEMBLY PARAMETER DEFINITIONS
! 
!         A NONZERO PARAMETER VALUE INDICATES PRESENCE OF THE FEATURE.
!         A ZERO PARAMETER VALUE INDICATES ABSENCE OF THE FEATURE
! 
!         ALL PARAMETERS MUST BE DEFINED
! -
literal CA$_SIMULATOR = 1;              ! INCLUDE SIMULATOR SUPPORT CODE 
literal CA$_MEASURE = 2;                ! INCLUDE PERFORMANCE MEASUREMENT HOOKS 
literal CA$_MEASURE_IOT = 4;            ! INCLUDE I/O TRANSACTION DATA COLLECTION 
 
!*** MODULE $CANDEF ***
! +
!  CAN - DEFINE DRIVER CANCEL ROUTINE REASON CODES
! 
!  THESE CODES ARE PASSED TO THE CANCEL ROUTINE OF A DRIVER SO THAT
!  THE ROUTINE CAN DISTINGUISH BETWEEN CALLS FROM $DASSGN AND $CANCEL.
! 
! -
literal CAN$C_CANCEL = 0;               ! CANCEL INVOKED DUE TO $CANCEL SERVICE 
literal CAN$C_DASSGN = 1;               ! CANCEL INVOKED DUE TO $DASSGN SERVICE 
literal CAN$C_AMBXDGN = 2;              ! CANCEL INVOKED DUE TO MB DISASSOCIATION
 
!*** MODULE $CDRPDEF ***
! +
!  CDRP - CLASS DRIVER I/O REQUEST PACKET
! 
!  This structure contains within it, at negative offsets, a full IRP.
!  For this reason all IRP fields must be at the same relative offsets
!  as the corresponding fields in the IRP.
! 
! -
literal CDRP$K_CDRPBASE = 0;
literal CDRP$C_CDRPBASE = 0;
literal CDRP$K_LENGTH = 44;
literal CDRP$C_LENGTH = 44;
! 	CDRP extensions
literal CDRP$K_BT_LEN = 64;
literal CDRP$C_BT_LEN = 64;
literal CDRP$M_CAND = 1;
literal CDRP$M_CANIO = 2;
literal CDRP$M_ERLIP = 4;
literal CDRP$M_PERM = 8;
literal CDRP$M_HIRT = 16;
literal CDRP$M_DENSCK = 32;
literal CDRP$M_CONNWALK = 64;
literal CDRP$M_COPYSHAD = 128;
literal CDRP$M_IVCMD = 256;
literal CDRP$M_WALK_2P = 512;
literal CDRP$M_LOC_ONLY = 1024;
literal CDRP$M_LOADBAL = 2048;
literal CDRP$K_CD_LEN = 72;
literal CDRP$C_CD_LEN = 72;
literal CDRP$K_NORMAL = 0;              !  The standard case (particulary no block xfer)
literal CDRP$K_REQUESTOR = 1;           !  Block transfer requestor
literal CDRP$K_PARTNER = 2;             !  Block transfer partner, active
literal CDRP$K_PART_IDLE = 3;           !  Block transfer partner, idle
literal CDRP$K_REQ_MAP = 4;             !  Block transfer requestor, waiting for buffer handle
literal CDRP$K_PART_MAP = 5;            !  Block transfer partner, waiting for buffer handle
literal CDRP$K_CM_LENGTH = 104;
! 
literal CDRP$K_CM_LONG_LENGTH = 108;
literal CDRP$S_CDRPDEF = 204;
macro CDRP$L_IOQFL = -96,0,32,0 %;      ! I/O QUEUE FORWARD LINK 
macro CDRP$L_IOQBL = -92,0,32,0 %;      ! I/O QUEUE BACKWARD LINK 
macro CDRP$W_IRP_SIZE = -88,0,16,0 %;   ! SIZE OF IRP IN BYTES 
macro CDRP$B_IRP_TYPE = -86,0,8,0 %;    ! STRUCTURE TYPE FOR IRP 
macro CDRP$B_RMOD = -85,0,8,0 %;        ! ACCESS MODE OF REQUEST 
macro CDRP$L_PID = -84,0,32,0 %;        ! PROCESS ID OF REQUESTING PROCESS 
macro CDRP$L_AST = -80,0,32,0 %;        ! ADDRESS OF AST ROUTINE 
macro CDRP$L_SHD_IOFL = -80,0,32,0 %;   ! LINK TO CLONE IRPS
macro CDRP$L_ASTPRM = -76,0,32,0 %;     ! AST PARAMETER 
macro CDRP$L_SHAD = -76,0,32,0 %;       ! SHAD ADDRESS
macro CDRP$L_HRB = -76,0,32,0 %;        ! HRB ADDRESS 
macro CDRP$L_WIND = -72,0,32,0 %;       ! ADDRESS OF WINDOW BLOCK 
macro CDRP$L_MIRP = -72,0,32,0 %;       ! LINK TO MASTER IRP
macro CDRP$L_UCB = -68,0,32,0 %;        ! ADDRESS OF DEVICE UCB 
macro CDRP$W_FUNC = -64,0,16,0 %;       ! I/O FUNCTION CODE AND MODIFIERS 
macro CDRP$B_EFN = -62,0,8,0 %;         ! EVENT FLAG NUMBER AND EVENT GROUP 
macro CDRP$B_CLN_INDX = -62,0,8,0 %;    ! Shadow Clone membership index
macro CDRP$B_PRI = -61,0,8,0 %;         ! BASE PRIORITY OF REQUESTING PROCESS 
macro CDRP$B_SHD_FLAGS = -61,0,8,0 %;   !  Shadow Clone Flags
! 
macro CDRP$L_IOSB = -60,0,32,0 %;       ! ADDRESS OF I/O STATUS DOUBLE LONGWORD 
macro CDRP$L_CLN_WLE = -60,0,32,0 %;    ! Write log entry
macro CDRP$W_CHAN = -56,0,16,0 %;       ! PROCESS I/O CHANNEL NUMBER 
macro CDRP$W_STS = -54,0,16,0 %;        ! REQUEST STATUS 
macro CDRP$L_SVAPTE = -52,0,32,0 %;     ! SYSTEM VIRTUAL ADDRESS OF FIRST PTE 
macro CDRP$W_BOFF = -48,0,16,0 %;       ! BYTE OFFSET IN FIRST PAGE 
macro CDRP$L_BCNT = -46,0,32,0 %;       ! BYTE COUNT OF TRANSFER 
macro CDRP$W_BCNT = -46,0,16,0 %;       !  OLD WORD DEFINITION FOR COMPATIBILITY 
macro CDRP$L_DCD_BLK_COUNT = -46,0,32,0 %; ! DISK COPY DATA TRANSFER BLOCK COUNT
macro CDRP$W_STS2 = -42,0,16,0 %;       !  Same as IRPDEF
macro CDRP$L_IOST1 = -40,0,32,0 %;      ! FIRST I/O STATUS LONGWORD (FOR I/O POST) 
macro CDRP$L_MEDIA = -40,0,32,0 %;      ! MEDIA ADDRESS 
macro CDRP$L_IOST2 = -36,0,32,0 %;      ! SECOND I/O STATUS LONGWORD 
macro CDRP$L_TT_TERM = -36,0,32,0 %;    ! ADDRESS OF READ TERMINATORS MASK 
macro CDRP$B_CARCON = -36,0,8,0 %;      ! CARRIAGE CONTROL 
macro CDRP$Q_NT_PRVMSK = -32,0,0,0 %;
literal CDRP$S_NT_PRVMSK = 8;           !  PRIVILEGE MASK FOR DECNET 
macro CDRP$Q_STATION = -32,0,0,0 %;
literal CDRP$S_STATION = 8;             !  STATION FIELD FOR DECNET DRIVERS
macro CDRP$Q_TT_STATE = -32,0,0,0 %;
literal CDRP$S_TT_STATE = 8;            !  TERMINAL STATE DEFINITIONS 
macro CDRP$L_ABCNT = -32,0,32,0 %;      !  ACCUMULATED BYTES TRANSFERED 
macro CDRP$W_ABCNT = -32,0,16,0 %;      !  OLD WORD DEFINITION FOR COMPATIBILITY 
macro CDRP$L_OBCNT = -28,0,32,0 %;      !  ORIGINAL TRANSFER BYTE COUNT 
macro CDRP$W_OBCNT = -28,0,16,0 %;      !  OLD WORD DEFINITION FOR COMPATIBILITY 
macro CDRP$L_SEGVBN = -24,0,32,0 %;     !  VIRTUAL BLOCK NUMBER OF CURRENT SEGMENT 
macro CDRP$L_DIAGBUF = -20,0,32,0 %;    !  DIAGNOSTIC BUFFER ADDRESS 
macro CDRP$L_SCB_BUF = -20,0,32,0 %;    !  SCB BUFFER ADDRESS
macro CDRP$W_TT_PRMPT = -20,0,16,0 %;   !  PROMPT SIZE 
macro CDRP$L_SEQNUM = -16,0,32,0 %;     !  SEQUENCE NUMBER 
macro CDRP$L_DCD_SRC_UCB = -16,0,32,0 %; !  DISK COPY DATA SOURCE UCB
macro CDRP$L_EXTEND = -12,0,32,0 %;     !  ADDRESS OF IRPE 
macro CDRP$L_ARB = -8,0,32,0 %;         !  ACCESS RIGHTS BLOCK ADDRESS 
macro CDRP$L_SHDSPC = -8,0,32,0 %;      !  Shadowing return PC
macro CDRP$L_KEYDESC = -4,0,32,0 %;     !  ADDRESS OF ENCRYPTION DESCRIPTOR
macro CDRP$L_WLE_PTR = -4,0,32,0 %;     !  Clone Write log index
macro CDRP$B_CPY_MODE = -4,0,8,0 %;     !  Copy mode identifier
! 
! 
macro CDRP$L_FQFL = 0,0,32,0 %;         !  Fork Queue FLINK 
macro CDRP$L_FQBL = 4,0,32,0 %;         !  Fork Queue Blink 
macro CDRP$W_CDRPSIZE = 8,0,16,0 %;     !  Size field for positive section only 
macro CDRP$B_CD_TYPE = 10,0,8,0 %;      !  Type, always of interest 
macro CDRP$B_FLCK = 11,0,8,0 %;         !  Fork lock
macro CDRP$B_FIPL = 11,0,8,0 %;         !  Fork IPL
macro CDRP$L_FPC = 12,0,32,0 %;         !  Fork PC 
macro CDRP$L_FR3 = 16,0,32,0 %;         !  Fork R3 
macro CDRP$L_FR4 = 20,0,32,0 %;         !  Fork R4 
macro CDRP$L_SAVD_RTN = 24,0,32,0 %;    !  Saved return address from level 1 JSB 
macro CDRP$L_MSG_BUF = 28,0,32,0 %;     !  Address of allocated MSCP buffer 
macro CDRP$L_RSPID = 32,0,32,0 %;       !  Allocated Request ID 
macro CDRP$L_CDT = 36,0,32,0 %;         !  Address of Connection Descriptor Table 
macro CDRP$L_RWCPTR = 40,0,32,0 %;      !  RWAITCNT pointer 
! 	Block Transfer Extension
macro CDRP$L_LBUFH_AD = 44,0,32,0 %;    !  Local BUFfer Handle ADress 
macro CDRP$L_LBOFF = 48,0,32,0 %;       !  Local Byte OFFset 
macro CDRP$L_RBUFH_AD = 52,0,32,0 %;    !  Remote BUFfer Handle ADress 
macro CDRP$L_RBOFF = 56,0,32,0 %;       !  Remote Byte OFFset 
macro CDRP$L_XCT_LEN = 60,0,32,0 %;     !  Transfer length in bytes 
! 	Class Driver Extension
macro CDRP$T_LBUFHNDL = 48,0,0,0 %;
literal CDRP$S_LBUFHNDL = 12;           !  Local buffer handle 
macro CDRP$L_UBARSRCE = 60,0,32,0 %;    !  UNIBUS mapping resources allocated 
macro CDRP$L_DUTUFLAGS = 64,0,32,0 %;   !  Class driver status flags:
macro CDRP$V_CAND = 64,0,1,0 %;         !   canceled I/O request
macro CDRP$V_CANIO = 64,1,1,0 %;        !   cancel operation I/O request
macro CDRP$V_ERLIP = 64,2,1,0 %;        !   error log in progress
macro CDRP$V_PERM = 64,3,1,0 %;         !   CDDB permanent IRP/CDRP
macro CDRP$V_HIRT = 64,4,1,0 %;         !   HIRT permanent IRP/CDRP
macro CDRP$V_DENSCK = 64,5,1,0 %;       !   Tape density check required
macro CDRP$V_CONNWALK = 64,6,1,0 %;     !   Thread walking connections
macro CDRP$V_COPYSHAD = 64,7,1,0 %;     !   CDRP represents an active IO$_COPYSHAD
macro CDRP$V_IVCMD = 64,8,1,0 %;        !   Invalid command processing in progress
macro CDRP$V_WALK_2P = 64,9,1,0 %;      !   Thread trying secondary path before walking other connections
macro CDRP$V_LOC_ONLY = 64,10,1,0 %;    !   VMS MSCPservers are to be ignored during this connection walk
macro CDRP$V_LOADBAL = 64,11,1,0 %;     !   A load balancing pass of connection walking is active
macro CDRP$W_DUTUCNTR = 68,0,16,0 %;    !  General purpose counter
macro CDRP$W_ENDMSGSIZ = 70,0,16,0 %;   !  Size of most recent MSCP end message
! 	Disk Copy Data Extension
macro CDRP$B_SUBCMD_STS = 48,0,0,0 %;
literal CDRP$S_SUBCMD_STS = 12;         !  Subcommand status
! 	Connection management extension
macro CDRP$L_VAL1 = 44,0,32,0 %;        !  data value 1
macro CDRP$L_VAL2 = 48,0,32,0 %;        !  data value 2
macro CDRP$L_VAL3 = 52,0,32,0 %;        !  data value 3
macro CDRP$L_VAL4 = 56,0,32,0 %;        !  data value 4
macro CDRP$L_VAL5 = 60,0,32,0 %;        !  data value 5
macro CDRP$L_VAL6 = 64,0,32,0 %;        !  data value 6
macro CDRP$L_VAL7 = 68,0,32,0 %;        !  data value 7
macro CDRP$L_VAL8 = 72,0,32,0 %;        !  data value 8
macro CDRP$L_FILL_VAL = 48,0,0,1 %;
literal CDRP$S_FILL_VAL = 16;
macro CDRP$L_CNXSVAPTE = 64,0,32,0 %;   !  Block SVAPTE
macro CDRP$W_CNXBOFF = 68,0,16,0 %;     !  Block buffer offset
macro CDRP$L_CNXBCNT = 70,0,32,0 %;     !  Block xfer length
macro CDRP$B_CNXRMOD = 74,0,8,0 %;      !  Block access mode
macro CDRP$B_CLTSTS = 75,0,8,0 %;       !  A client's status field
macro CDRP$L_MSGBLD = 76,0,32,0 %;      !  Address of MSG BUILD routine
macro CDRP$L_SAVEPC = 80,0,32,0 %;      !  Caller's saved PC
macro CDRP$W_SENDSEQNM = 84,0,16,0 %;   !  Message sequence number
macro CDRP$B_CNXSTATE = 86,0,8,0 %;     !  CNX message state
!  Possible states:
macro CDRP$L_RETRSPID = 88,0,32,0 %;    !  RSPID to return
macro CDRP$L_VAL9 = 92,0,32,0 %;        !  data value 9
macro CDRP$L_VAL10 = 96,0,32,0 %;       !  data value 10
macro CDRP$L_VAL11 = 100,0,32,0 %;      !  data value 11
!  The following fields are only valid
!  for long connection manager CDRPs.
! 
macro CDRP$L_VAL12 = 104,0,32,0 %;      !  data value 12
 
!*** MODULE $CINDEF ***
! +
! 
!  Connect to interrupt definitions for QIO parameters
! 
! -
literal CIN$M_EFN = 1;
literal CIN$M_USECAL = 2;
literal CIN$M_REPEAT = 4;
literal CIN$M_AST = 8;
literal CIN$M_INIDEV = 16;
literal CIN$M_START = 32;
literal CIN$M_ISR = 64;
literal CIN$M_CANCEL = 128;
literal CIN$M_EFNUM = -65536;
literal CIN$S_CINDEF = 4;
macro CIN$V_EFN = 0,0,1,0 %;            !  Set event flag on interrupt. 
macro CIN$V_USECAL = 0,1,1,0 %;         !  Use CALL interface. 
macro CIN$V_REPEAT = 0,2,1,0 %;         !  Do repeated interrupt service. 
macro CIN$V_AST = 0,3,1,0 %;            !  Queue AST on interrupt. 
macro CIN$V_INIDEV = 0,4,1,0 %;         !  Device initialization to do. 
macro CIN$V_START = 0,5,1,0 %;          !  Start I/O routine. 
macro CIN$V_ISR = 0,6,1,0 %;            !  ISR to execute. 
macro CIN$V_CANCEL = 0,7,1,0 %;         !  Cancel I/O routine. 
macro CIN$V_EFNUM = 0,16,16,0 %;
literal CIN$S_EFNUM = 16;               !  Event flag number. 
literal CIN$S_CINDEF1 = 16;
macro CIN$L_INIDEV = 0,0,32,0 %;        !  Offset to device init routine. 
macro CIN$L_START = 4,0,32,0 %;         !  Offset to start device routine. 
macro CIN$L_ISR = 8,0,32,0 %;           !  Offset to interrupt service routine. 
macro CIN$L_CANCEL = 12,0,32,0 %;       !  Offset to cancel I/O routine. 
literal CIN$S_CINDEF2 = 8;
macro CIN$L_SPTCOUNT = 0,0,32,0 %;      !  Number of SPTs allocated. 
macro CIN$L_STARTVPN = 4,0,32,0 %;      !  Starting VPN allocated. 
macro CIN$L_STARTBIT = 4,0,32,0 %;      !  Starting bit in bitmap. 
 
!*** MODULE $CCADEF ***
literal CCA$k_revision = 3;
literal CCA$M_BOOTIP = 1;
literal CCA$M_USE_ICACHE = 2;
literal CCA$M_USE_ECACHE = 4;
literal CCA$M_ECACHE_CLEARABLE = 8;
literal CCA$M_REBOOT = 16;
literal CCA$M_RBOOTIP = 1;
literal CCA$M_USE_PCACHE = 2;
literal CCA$M_USE_BCACHE = 4;
literal CCA$M_BCACHE_CLEARABLE = 8;
literal CCA$M_RREBOOT = 16;
literal CCA$M_REPROMPT = 32;
literal CCA$M_CON_REBOOT = 64;
literal CCA$K_HEADER_SZ = 512;          !  Size of the header
literal CCA$R_BUFFER0 = 512;            !  Offset to first communications buffer
literal CCA$R_MODULE_SN0 = 3200;        !  Offset to first module Serial # buffer
literal CCA$S_CCADEF = 512;
!   The CCA header page
macro CCA$L_BASE = 0,0,32,0 %;          !  Physical address of the base of CCA 
macro CCA$W_SIZE = 4,0,16,0 %;          !  Size in bytes of CCA
macro CCA$W_IDENT = 6,0,16,0 %;         !  Ident string 'CC'
macro CCA$B_NPROC = 8,0,8,0 %;          !  Number of supported processors
macro CCA$B_CHKSUM = 9,0,8,0 %;         !  Checksum of previous bytes
macro CCA$B_HFLAGS = 10,0,8,0 %;        !  Header flags
macro CCA$V_BOOTIP = 10,0,1,0 %;        !  Bootstrap in progress
macro CCA$V_USE_ICACHE = 10,1,1,0 %;    !  OK to turn on internal cache
macro CCA$V_USE_ECACHE = 10,2,1,0 %;    !  OK to turn on external cache
macro CCA$V_ECACHE_CLEARABLE = 10,3,1,0 %; !  External cache clear works
macro CCA$V_REBOOT = 10,4,1,0 %;        !  If set when primary enters console,
!  reboot operating system using default
!  boot device
macro CCA$V_RBOOTIP = 10,0,1,0 %;       !  Bootstrap in progress (Rigel)
macro CCA$V_USE_PCACHE = 10,1,1,0 %;    !  OK to turn on primary cache
macro CCA$V_USE_BCACHE = 10,2,1,0 %;    !  OK to turn on backup cache
macro CCA$V_BCACHE_CLEARABLE = 10,3,1,0 %; !  Backup cache clear works
macro CCA$V_RREBOOT = 10,4,1,0 %;       !  If set when primary enters console,
!  reboot operating system using default
!  boot device (Rigel)
!   The remaining flags are used internally by the console
macro CCA$V_REPROMPT = 10,5,1,0 %;      !  This flag is used when the location
!  of the primary is changed by a SET
!  CPU command.  It causes the new
!  primary to issue a console prompt.
macro CCA$V_CON_REBOOT = 10,6,1,0 %;    !  Performs the same function as
!  REBOOT, except used by secondary
!  CPU's.  Response to this bit is not
!  affected by the "Secure" keyswitch
macro CCA$B_REVISION = 11,0,8,0 %;      !  CCA Revision number
macro CCA$Q_READY = 12,0,0,0 %;
literal CCA$S_READY = 8;                !  Bitmask of processors with data
!  ready in transmit buffers
macro CCA$Q_CONSOLE = 20,0,0,0 %;
literal CCA$S_CONSOLE = 8;              !  Bitmask of processors known to be
!  in console mode
macro CCA$Q_ENABLED = 28,0,0,0 %;
literal CCA$S_ENABLED = 8;              !  Bitmask of processors enabled to 
!  leave console mode.
macro CCA$L_BITMAP_SZ = 36,0,32,0 %;    !  Size in bytes of physical memory 
!  bitmap.  Pages marked are available
!  to system software.
macro CCA$L_BITMAP = 40,0,32,0 %;       !  Address of the bitmap
macro CCA$L_BITMAP_CKSUM = 44,0,32,0 %; !  Checksum of bitmap
!  Unused on XCP
macro CCA$B_TK50_NODE = 48,0,8,0 %;     !  XMI/BI node of console TK50
macro CCA$B_RSRVD2 = 49,0,24,1 %;
literal CCA$S_RSRVD2 = 3;               !  Reserved byte...
macro CCA$Q_SECSTART = 52,0,0,0 %;
literal CCA$S_SECSTART = 8;             !  OS starting secondary flags
macro CCA$Q_RESTARTIP = 60,0,0,0 %;
literal CCA$S_RESTARTIP = 8;            !  Restart in progress flags
macro CCA$B_PRIMARY = 68,0,8,0 %;       !  XMI node-id of primary CPU
macro CCA$B_RSRVD3 = 69,0,8,1 %;
literal CCA$S_RSRVD3 = 1;               !  Skip power_system byte
macro CCA$W_SSN_EXT = 70,0,16,0 %;      !  High 2 characters of system serial #
macro CCA$B_RSRVD4 = 72,0,0,1 %;
literal CCA$S_RSRVD4 = 8;               !  unused
macro CCA$Q_USER_HALTED = 80,0,0,0 %;
literal CCA$S_USER_HALTED = 8;          !  Bitmask of processors which entered
!  console due to user intervention
macro CCA$Q_SERIALNUM = 88,0,0,0 %;
literal CCA$S_SERIALNUM = 8;            !  System serial number
!   (Expanded to quadword)
macro CCA$Q_HW_REVISION = 96,0,0,0 %;
literal CCA$S_HW_REVISION = 128;        !  Array of processor hardware revisions
macro CCA$Q_VECTOR_ENABLED = 224,0,0,0 %;
literal CCA$S_VECTOR_ENABLED = 8;       !  Bitmaks of available vectors
macro CCA$Q_VECTOR_PRESENT = 232,0,0,0 %;
literal CCA$S_VECTOR_PRESENT = 8;       !  bitmask of vectors in system
!   The layout of the hardware revision field.
!   These values are obtained from the EEPROM on the processor.
!   The CVAX, SSC, and FPU values are two nibbles with an implied "decimal"
!   point (i.e. 22 ==> 2.2).  The same holds true for the REX520 and RSSC values.
!   The module revision are the 4 ASCII characters of the module revision.
literal CCA$S_CCA_HW_REVISION = 8;
macro CCA$R_CPU_REV = 0,0,8,0 %;
literal CCA$S_CPU_REV = 1;
macro CCA$B_REX520_REV = 0,0,8,0 %;     !  The Rigel "P" chip revision
macro CCA$B_CVAX_REV = 0,0,8,0 %;       !  The CVAX revision
macro CCA$R_SUPPORT_REV = 1,0,8,0 %;
literal CCA$S_SUPPORT_REV = 1;
macro CCA$B_RSSC_REV = 1,0,8,0 %;       !  The RSSC revision
macro CCA$B_SSC_REV = 1,0,8,0 %;        !  The SSC revision
macro CCA$B_FPU_REV = 2,0,8,0 %;        !  The FPA revision
macro CCA$B_COMPAT_GROUP = 3,0,8,0 %;
macro CCA$V_COMPAT_GRP = 3,0,4,0 %;
literal CCA$S_COMPAT_GRP = 4;           !  Compatibility Group
macro CCA$V_FILL1 = 3,4,1,0 %;
macro CCA$V_FILL2 = 3,5,1,0 %;
macro CCA$V_COPR = 3,6,1,0 %;           !  Continue On Passive Release	
macro CCA$V_MDIE = 3,7,1,0 %;           !  Multi-Destination Interrupt Enable
macro CCA$L_MODULE_REV = 4,0,32,0 %;    !  The module revision
!   The layout of a buffer area
literal CCA$M_RXRDY = 1;
literal CCA$M_ZDEST = 2;
literal CCA$M_ZSRC = 4;
literal CCA$M_ZALT = 8;
literal CCA$M_ZRDY = 32768;
literal CCA$K_TXSZ = 80;
literal CCA$K_RXSZ = 80;
literal CCA$K_BUFAREA_SZ = 168;         !  Size of a buffer area
literal CCA$S_BUFFERAREA = 168;
macro CCA$B_FLAGS = 0,0,8,0 %;          !  The buffer flags
macro CCA$V_RXRDY = 0,0,1,0 %;          !  When set, there is a message in our
!  CCA$T_RX buffer
macro CCA$V_ZDEST = 0,1,1,0 %;          !  The CCA$B_ZDEST field is valid
!  (i.e. we are sending Z data)
macro CCA$V_ZSRC = 0,2,1,0 %;           !  The CCA$B_ZSRC field is valid
!  (i.e. we are receiving Z data)
macro CCA$V_ZALT = 0,3,1,0 %;           !  We are sending Z data to a node
!  requires alternate RXCD protocol
macro CCA$B_ZDEST = 1,0,8,0 %;          !  Target of our Z command
macro CCA$B_ZSRC = 2,0,8,0 %;           !  Node sending us Z data
macro CCA$B_ZNID = 3,0,8,0 %;           !  The value to use as our
!  node number in the ZRXCD
macro CCA$B_TXLEN = 4,0,8,0 %;          !  Length of data in CCA$T_TX
macro CCA$B_RXLEN = 5,0,8,0 %;          !  Length of data in CCA$T_RX
macro CCA$W_ZRXCD = 6,0,16,0 %;         !  Buffer for RXCD style communication
macro CCA$B_ZDATA = 6,0,8,0 %;          !  The data byte
macro CCA$V_ZNODE = 6,8,4,0 %;
literal CCA$S_ZNODE = 4;                !  The sending node's number
macro CCA$V_ZRDY = 6,15,1,0 %;          !  Flag that there is data and a node nr
macro CCA$T_TX = 8,0,0,0 %;
literal CCA$S_TX = 80;                  !  Transmit to primary
macro CCA$T_RX = 88,0,0,0 %;
literal CCA$S_RX = 80;                  !  Receive from primary
literal CCA$K_MODULE_SN_AREA_SZ = 12;   !  Size of each SN area
literal CCA$S_MODULE_SN_AREA = 12;
macro CCA$T_MODULE_SN = 0,0,0,0 %;
literal CCA$S_MODULE_SN = 10;           !  Each SN is 10 characters
literal CCA$K_NPROC = 16;
 
!*** MODULE $CCA520DEF IDENT 4.0 ***
literal CCA520$K_REVISION = 4;
literal CNF$S_CNFG = 4;                 !  Address of configuration info
macro CNF$V_SIZE = 0,0,16,0 %;
literal CNF$S_SIZE = 16;                !  When the module is memory
macro CNF$V_REVISION = 0,16,8,0 %;
literal CNF$S_REVISION = 8;             !  Revision of the module
macro CNF$V_STATUS = 0,24,4,0 %;
literal CNF$S_STATUS = 4;               !  Goodness or badness
macro CNF$V_TYPE = 0,28,4,0 %;
literal CNF$S_TYPE = 4;                 !  either CPU,IO,MEM
literal EDCB$S_EDCB_ENTRY = 36;         !  Extended DCB entry format
macro EDCB$V_SIZE = 0,0,16,0 %;
literal EDCB$S_SIZE = 16;               !  Memory module size
macro EDCB$V_REVISION = 0,16,8,0 %;
literal EDCB$S_REVISION = 8;            !  Module revision (truncated)
macro EDCB$V_STATUS = 0,24,4,0 %;
literal EDCB$S_STATUS = 4;              !  Module status
macro EDCB$V_TYPE = 0,28,4,0 %;
literal EDCB$S_TYPE = 4;                !  Module type
macro EDCB$T_MOD_NAME = 4,0,32,0 %;
literal EDCB$S_MOD_NAME = 4;            !  ASCII module name
macro EDCB$T_MOD_REV = 8,0,0,0 %;
literal EDCB$S_MOD_REV = 6;             !  ASCII module revision
macro EDCB$T_MOD_SERNO = 14,0,0,0 %;
literal EDCB$S_MOD_SERNO = 10;          !  ASCII module serial number
macro EDCB$W_MOD_ROM_REV = 24,0,16,0 %; !  Module ROM revision level
macro EDCB$W_MOD_PAT_REV = 26,0,16,0 %; !  Module patch revision level
macro EDCB$L_RSRVD1 = 28,0,32,0 %;      !  Reserved longword 1
macro EDCB$L_RSRVD2 = 32,0,32,0 %;      !  Reserved longword 2
literal DCBS$S_DCBS_STRUCTURE = 560;
macro DCBS$B_DCB_BLOCK = 0,0,0,1 %;
literal DCBS$S_DCB_BLOCK = 56;
macro DCBS$B_EDCB_BLOCK = 56,0,0,1 %;
literal DCBS$S_EDCB_BLOCK = 504;
literal CCA520$M_BOOTIP = 1;
literal CCA520$M_RESTARTIP = 2;
literal CCA520$M_AUTOBOOT = 4;
literal CCA520$M_REBOOT = 8;
literal CCA520$M_FAILSTOP = 16;
literal CCA520$M_SYNCHABLE = 32;
literal CCA520$K_HEADER_SZ = 139;       !  Size of the header
literal CCA520$R_BUFFER = 139;          !  Offset to the first buffer
!   The layout of a buffer area
literal CCA520$M_RXRDY = 1;
literal CCA520$M_ZDEST = 2;
literal CCA520$M_ZSRC = 4;
literal CCA520$M_ZALT = 8;
literal CCA520$M_CMS = 16;
literal ISTREAM$K_ROM = 0;
literal ISTREAM$K_LOCAL_A = 1;
literal ISTREAM$K_REMOTE_A = 2;
literal ISTREAM$K_LOCAL_B = 3;
literal ISTREAM$K_REMOTE_B = 4;
literal ISTREAM$K_SLINK = 5;
literal ISTREAM$K_CDCR = 6;
! --
literal CCA520$k_romcon_stall = 64;
literal CCA520$K_TXSZ = 81;
literal CCA520$K_RXSZ = 81;
literal CCA520$K_BUFAREA_SZ = 419;      !  Size of a buffer area
literal CCA520$R_BOOT_PARAM_BLOCK = 558; !  Offset from CCA begin to BPB
literal CCA520$K_BOOT_PARAM_BLOCK_SZ = 84;
literal CCA520$R_REG_BLOCK = 642;       !  Offset from CCA begin to BPB
literal CCA520$K_REG_BLOCK_SIZE = 196;
! 
literal CCA520$R_DCBS = 838;            !  Offset from CCA begin to BPB
literal CCA520$K_CCA_SIZE = 1398;
literal CCA520$k_cca$s_cca = 1398;
literal CCA520$S_CCADEF = 1398;
!   The CCA header page
macro CCA520$L_BASE = 0,0,32,0 %;       !  Physical address of the base of CCA 
macro CCA520$W_SIZE = 4,0,16,0 %;       !  Size in bytes of CCA
macro CCA520$W_IDENT = 6,0,16,0 %;      !  Ident string 'CI'
macro CCA520$B_CHKSUM = 8,0,8,0 %;      !  Checksum of previous bytes
macro CCA520$B_HFLAGS = 9,0,8,0 %;      !  Header flags
macro CCA520$V_BOOTIP = 9,0,1,0 %;      !  Bootstrap in progress
macro CCA520$V_RESTARTIP = 9,1,1,0 %;   !  Restart in progress
macro CCA520$V_AUTOBOOT = 9,2,1,0 %;    !  indicate to O.S. that boot
!  occurred with no Human 
!  intervention.
macro CCA520$V_REBOOT = 9,3,1,0 %;      !  If set when primary enters console,
!  reboot operating system using default
!  boot device
macro CCA520$V_FAILSTOP = 9,4,1,0 %;    !  Indicate to O.S. That System
!  should allow FAILSTOP
macro CCA520$V_SYNCHABLE = 9,5,1,0 %;   !  Indicates that synch test
!    has passed between zones
!   The remaining flags are used internally by the console
macro CCA520$B_REVISION = 10,0,8,0 %;   !  CCA Revision number
macro CCA520$L_BITMAP_SZ = 11,0,32,0 %; !  Size in bytes of physical memory 
!  bitmap.  Pages marked are available
!  to system software.
macro CCA520$L_BITMAP = 15,0,32,0 %;    !  Address of the bitmap
macro CCA520$L_BITMAP_CKSUM = 19,0,32,0 %; !  Checksum of bitmap
!  Unused on XCP
macro CCA520$L_CONFIG_BLK = 23,0,0,1 %;
literal CCA520$S_CONFIG_BLK = 56;       !  Sys configuration from zone test
macro CCA520$L_BOOT_DEVICE_CSR_1 = 79,0,32,0 %;
!  used by VMS for device failover,
!  not used by Console 
macro CCA520$L_BOOT_DEVICE_CSR_2 = 83,0,32,0 %;
!  used by VMS for device failover,
!  not used by Console 
macro CCA520$L_BOOT_PARAM_PTR = 87,0,32,0 %;
!  pointer to Current boot device
!  used for VMB restart.
macro CCA520$L_BOOT_PARAM = 91,0,32,0 %; !  Address or parameter block passed
!  from Console to VMB.
macro CCA520$Q_SERIALNUM = 95,0,0,0 %;
literal CCA520$S_SERIALNUM = 8;         !  System serial number
!   (Expanded to quadword)
macro CCA520$Q_HW_REVISION = 103,0,0,0 %;
literal CCA520$S_HW_REVISION = 8;       !  processor hardware revisions.
macro CCA520$L_NSCR_ADDR = 111,0,32,0 %; !  address of console structures in
!  local ram
macro CCA520$L_REG_BLOCK_ADDR = 115,0,32,0 %; !  Address of register save block
macro CCA520$L_REG_BLOCK_SIZE = 119,0,32,0 %; !  Size of register save block
macro CCA520$L_DCBS_ADDR = 123,0,32,0 %; !  Addr of structure that 
!  contains DCB and extended DCB
macro CCA520$L_SELFTEST_STATUS = 127,0,32,0 %; !  Diagnostic self test status
macro CCA520$L_ZONETEST_STATUS = 131,0,32,0 %; !  Diagnostic zone test status
macro CCA520$L_SYSTEMTEST_STATUS = 135,0,32,0 %; !  Diagnostic system test status
macro CCA520$B_FLAGS = 139,0,8,0 %;     !  The buffer flags
macro CCA520$V_RXRDY = 139,0,1,0 %;     !  When set, there is a message in our
!  CCA$T_RX buffer
macro CCA520$V_ZDEST = 139,1,1,0 %;     !  The CCA$B_ZDEST field is valid
!  (i.e. we are sending Z data)
macro CCA520$V_ZSRC = 139,2,1,0 %;      !  The CCA$B_ZSRC field is valid
!  (i.e. we are receiving Z data)
macro CCA520$V_ZALT = 139,3,1,0 %;      !  We are sending Z data to a node
!  requires alternate RXCD protocol
macro CCA520$V_CMS = 139,4,1,0 %;       !  When set indicates a CIO is
!  sending a command to the CPU.
!  Remains set until command is
!  completed processing.
! ++
!  define place to keep track of input stream and values it will contain.
macro CCA520$B_ISTREAM = 140,0,8,0 %;   !  Where the last Character input
!  came from.
!  the local and remote isteam identifiers must be 1,3 and 5,6 respectively
!  so that the difference between the zone A and zone B inputs are indicated by
!  one bit and the local/remote id is indicated as the stream number whic the
!  CIO uses to pass the data throug the UCCR.
!  12-AUG-1989 16:52:27.90  DM
!  ROM console must use main memory to be in lockstep
! 
macro CCA520$L_ROMCON_STATUS = 141,0,32,0 %; !  Shared by both rails for ROMCON
macro CCA520$B_ZDEST = 145,0,8,0 %;     !  Target of our Z command
macro CCA520$B_ZSRC = 146,0,8,0 %;      !  Node sending us Z data
macro CCA520$B_TXLEN = 147,0,8,0 %;     !  Length of data in CCA$T_TX
macro CCA520$B_ROM_RXLEN = 148,0,8,0 %; !  Length of data in CCA$T_RX
macro CCA520$B_UCCR_A_RXLEN = 149,0,8,0 %; !  Length of data in CCA$T_RX
macro CCA520$B_UCCR_B_RXLEN = 150,0,8,0 %; !  Length of data in CCA$T_RX
macro CCA520$B_SLINK_RXLEN = 151,0,8,0 %; !  Length of data in CCA$T_RX
macro CCA520$B_CDCR_RXLEN = 152,0,8,0 %; !  Length of data in CCA$T_RX
macro CCA520$T_ROM_RX = 153,0,0,0 %;
literal CCA520$S_ROM_RX = 81;           !  Receive from ROM terminal
macro CCA520$T_UCCR_A_RX = 234,0,0,0 %;
literal CCA520$S_UCCR_A_RX = 81;        !  Receive from Zone A UCCR
macro CCA520$T_UCCR_B_RX = 315,0,0,0 %;
literal CCA520$S_UCCR_B_RX = 81;        !  Receive from Zone B UCCR
macro CCA520$T_SLINK_RX = 396,0,0,0 %;
literal CCA520$S_SLINK_RX = 81;         !  Receive through IZC
macro CCA520$T_CDCR_RX = 477,0,0,0 %;
literal CCA520$S_CDCR_RX = 81;          !  Receive through Z mode
! 
!   Boot parameter block
! 
! 
!  Allocate space for BPB in CCA
! 
macro CCA520$L_BOOT_PARAM_BLOCK = 558,0,0,1 %;
literal CCA520$S_BOOT_PARAM_BLOCK = 84;
! 
!  REGISTER BLOCK
! 
! 
!  Allocate space for register block
! 
macro CCA520$L_REG_BLOCK = 642,0,0,1 %;
literal CCA520$S_REG_BLOCK = 196;
!  Here is where the two DCB blocks are kept. First, is the
!  standard (non-extended) DCB supported in CIRRUS I. Followed
!  by the extended DCB also provided in CIRRUS II.
! 
macro CCA520$B_DCBS = 838,0,0,1 %;
literal CCA520$S_DCBS = 560;
! 
! 
! 
literal BPB$k_max = 20;                 !  Max allowed boot paths that can be specified
!  Boot Parameter Structure, a sub structure contained within the CCA
literal BPB$S_BPBLK = 84;
macro BPB$L_BPLEN = 0,0,32,1 %;         !  number of longword ZSUs
macro BPB$R_BP_PARAM1 = 4,0,0,0 %;
literal BPB$S_BP_PARAM1 = 80;
macro BPB$L_BPBASE = 4,0,32,1 %;        !  first ZSUs of block
macro BPB$L_BP_PARAMS = 4,0,0,1 %;
literal BPB$S_BP_PARAMS = 80;
!  Configuration block type field definitions
literal CCA520$K_EMPTY = 0;             !  Slot is empty
literal CCA520$K_CPUMODULE = 5;         !  CPU module
literal CCA520$K_MEMMODULE = 3;         !  MEMORY module
literal CCA520$K_CIOMOD = 1;            !  IO module
literal CCA520$K_COMIOMOD = 4;          !  Communication module
!  Configuration block status field definitions
literal CCA520$K_MODSTSBAD = 0;         !  Module bad
literal CCA520$K_MODSTSGOOD = 1;        !  Module good
literal CCA520$K_MODSTSNOTPRES = 2;     !  Module not present
literal BP$M_UNIT = 65535;
literal BP$M_BUSID = 16711680;
literal BP$M_SLOT1 = 117440512;
literal BP$M_ZONE1 = 134217728;
literal BP$M_SLOT2 = 1879048192;
literal BP$M_ZONE2 = -2147483648;
literal BP$S_ZSZSBU = 4;
macro BP$V_UNIT = 0,0,16,0 %;
literal BP$S_UNIT = 16;
macro BP$V_BUSID = 0,16,8,0 %;
literal BP$S_BUSID = 8;
macro BP$V_SLOT1 = 0,24,3,0 %;
literal BP$S_SLOT1 = 3;
macro BP$V_ZONE1 = 0,27,1,0 %;
macro BP$V_SLOT2 = 0,28,3,0 %;
literal BP$S_SLOT2 = 3;
macro BP$V_ZONE2 = 0,31,1,0 %;
!   The layout of the hardware revision field.
!   These values are obtained from the EEPROM on the processor.
!   The CVAX, SSC, and FPU values are two nibbles with an implied "decimal"
!   point (i.e. 22 ==> 2.2)
!   The module revision are the 4 ASCII characters of the module revision.
literal CCA520$S_CCA_HW_REVISION = 8;
macro CCA520$B_CVAX_REV = 0,0,8,0 %;    !  The CVAX revision
macro CCA520$B_FPU_REV = 1,0,8,0 %;     !  The FPA revision
macro CCA520$B_MCTL_REV = 2,0,8,0 %;    !  The MCTL revision
macro CCA520$B_CLINK_REV = 3,0,8,0 %;   !  The CLINK revision
macro CCA520$L_MODULE_REV = 4,0,32,0 %; !  The module revision
 
!*** MODULE $CCBDEF ***
! +
!  CCB - CHANNEL CONTROL BLOCK
! 
!  THERE IS ONE CHANNEL CONTROL BLOCK FOR EACH SOFTWARE CHANNEL THAT A
!  PROCESS MAY INITIATE I/O REQUESTS ON. THE NUMBER OF SUCH I/O CHANNELS
!  IS DETERMINED BY THE FIXED NUMBER ASSIGNED TO A PROCESS PLUS ANY
!  ADDITIONAL CHANNELS REQUIRED BY THE IMAGE CURRENTLY BEING EXECUTED
!  BY THE PROCESS.
!      
!  **** WARNING ****
!         THE CHANNEL CONTROL BLOCK IS ASSUMED TO BE FOUR LONG WORDS
!  THROUGHOUT THE EXEC.  ITS SIZE MAY BE CHANGED BUT ONLY BY POWERS OF 2.
! -
literal CCB$M_AMB = 1;
literal CCB$M_IMGTMP = 2;
literal CCB$M_RDCHKDON = 4;
literal CCB$M_WRTCHKDON = 8;
literal CCB$M_LOGCHKDON = 16;
literal CCB$M_PHYCHKDON = 32;
literal CCB$M_NOREADACC = 64;
literal CCB$M_NOWRITEACC = 128;
literal CCB$K_LENGTH = 16;              ! LENGTH OF CCB 
literal CCB$C_LENGTH = 16;              ! LENGTH OF CCB 
literal CCB$S_CCBDEF = 16;
macro CCB$L_UCB = 0,0,32,0 %;           ! ADDRESS OF ASSIGNED DEVICE UCB 
macro CCB$L_WIND = 4,0,32,0 %;          ! ADDRESS OF WINDOW BLOCK 
macro CCB$B_STS = 8,0,8,0 %;            ! CHANNEL STATUS 
macro CCB$V_AMB = 8,0,1,0 %;            !  MAILBOX ASSOCIATED WITH CHANNEL 
macro CCB$V_IMGTMP = 8,1,1,0 %;         !  IMAGE TEMPORARY
macro CCB$V_RDCHKDON = 8,2,1,0 %;       !  READ PROTECTION CHECK COMPLETED
macro CCB$V_WRTCHKDON = 8,3,1,0 %;      !  WRITE PROTECTION CHECK COMPLETED
macro CCB$V_LOGCHKDON = 8,4,1,0 %;      !  LOGICAL I/O ACCESS CHECK DONE
macro CCB$V_PHYCHKDON = 8,5,1,0 %;      !  PHYSICAL I/O ACCESS CHECK DONE
macro CCB$V_NOREADACC = 8,6,1,0 %;      !  READ ACCESS TO DEVICE DISABLED
macro CCB$V_NOWRITEACC = 8,7,1,0 %;     !  WRITE ACCESS TO DEVICE DISABLED
macro CCB$B_AMOD = 9,0,8,0 %;           ! ACCESS MODE THAT ASSIGNED CHANNEL 
macro CCB$W_IOC = 10,0,16,0 %;          ! NUMBER OF OUTSTANDING I/O REQUESTS ON CHANNEL 
macro CCB$L_DIRP = 12,0,32,0 %;         ! DEACCESS I/O REQUEST PACKET ADDRESS 
 
!*** MODULE $CDDBDEF ***
! +
!  CDDB - Class Driver Data Block
! 
!  Auxiliary data block pointed at by the CRB$L_AUXSTRUC of an MSCP speaking
!  intelligent disk or tape controller.  There is one CDDB per such intelligent
!  controller.
! 
! -
literal CDDB$M_SNGLSTRM = 1;
literal CDDB$M_IMPEND = 2;
literal CDDB$M_INITING = 4;
literal CDDB$M_RECONNECT = 8;
literal CDDB$M_RESYNCH = 16;
literal CDDB$M_POLLING = 32;
literal CDDB$M_ALCLS_SET = 64;
literal CDDB$M_NOCONN = 128;
literal CDDB$M_RSTRTWAIT = 256;
literal CDDB$M_QUORLOST = 512;
literal CDDB$M_DAPBSY = 1024;
literal CDDB$M_2PBSY = 2048;
literal CDDB$M_BSHADOW = 4096;
literal CDDB$M_DISABLED = 8192;
literal CDDB$M_PATHMOVE = 16384;
literal CDDB$M_PRMBSY = 32768;
literal CDDB$M_DISC_PEND = 1;
literal CDDB$M_CRNSET = 2;
literal CDDB$K_LENGTH = 112;            ! Standard length of CDDB 
literal CDDB$C_LENGTH = 112;            ! Standard length of CDDB 
literal CDDB$S_CDDBDEF = 116;
macro CDDB$L_CDRPQFL = 0,0,32,0 %;      ! Active CDRP Q FLINK 
macro CDDB$L_CDRPQBL = 4,0,32,0 %;      ! Active CDRP Q BLINK 
macro CDDB$W_SIZE = 8,0,16,0 %;         ! Size of CDDB in bytes 
macro CDDB$B_TYPE = 10,0,8,0 %;         ! Major structure type for Class Driver 
macro CDDB$B_SUBTYPE = 11,0,8,0 %;      !  CDDB structure subtype field 
macro CDDB$B_SYSTEMID = 12,0,0,0 %;
literal CDDB$S_SYSTEMID = 6;            ! 48 bit system ID. 
macro CDDB$W_STATUS = 18,0,16,0 %;      ! Status word 
macro CDDB$V_SNGLSTRM = 18,0,1,0 %;     !  Single stream mode after VC crash 
macro CDDB$V_IMPEND = 18,1,1,0 %;       !  IMmediate command PENDing 
macro CDDB$V_INITING = 18,2,1,0 %;      !  Currently initializing CONNECTION 
macro CDDB$V_RECONNECT = 18,3,1,0 %;    !  Currently re-CONNECTING to MSCP server 
macro CDDB$V_RESYNCH = 18,4,1,0 %;      !  re_CONNECT initiated by Class Driver 
macro CDDB$V_POLLING = 18,5,1,0 %;      !  Polling for units
macro CDDB$V_ALCLS_SET = 18,6,1,0 %;    !  Allocation class has been set
macro CDDB$V_NOCONN = 18,7,1,0 %;       !  CDDB currently has no connection
macro CDDB$V_RSTRTWAIT = 18,8,1,0 %;    !  Waiting to RESTART_NEXT_CDRP
macro CDDB$V_QUORLOST = 18,9,1,0 %;     !  CNXMAN quorum lost processing
macro CDDB$V_DAPBSY = 18,10,1,0 %;      !  DAP CDRP is busy
macro CDDB$V_2PBSY = 18,11,1,0 %;       !  Failover fork block is busy
macro CDDB$V_BSHADOW = 18,12,1,0 %;     !  Controller uses "bundled" shadowing
macro CDDB$V_DISABLED = 18,13,1,0 %;    !  Controller not in use by class driver action
macro CDDB$V_PATHMOVE = 18,14,1,0 %;    !  Closing connection for port load balance
macro CDDB$V_PRMBSY = 18,15,1,0 %;      !  Permanent CDRP in use
macro CDDB$L_PDT = 20,0,32,0 %;         ! Port Descriptor Table address 
macro CDDB$L_CRB = 24,0,32,0 %;         ! CRB address 
macro CDDB$L_DDB = 28,0,32,0 %;         ! DDB address 
macro CDDB$Q_CNTRLID = 32,0,0,0 %;
literal CDDB$S_CNTRLID = 8;             ! Controller ID returned by MSCP END PACKET 
macro CDDB$B_CNTRLMDL = 38,0,8,0 %;     !  Controller model ! (byte 6 of controller id) 
macro CDDB$B_CNTRLCLS = 39,0,8,0 %;     !  Controller class (byte 7 of controller id) 
macro CDDB$W_CNTRLFLGS = 40,0,16,0 %;   ! Controller flags also returned by END PACKET 
macro CDDB$W_CNTRLTMO = 42,0,16,0 %;    ! Controller timeout also returned by END PACKET 
macro CDDB$L_OLDRSPID = 44,0,32,0 %;    ! RSPID of oldest outstanding MSCP command 
macro CDDB$L_OLDCMDSTS = 48,0,32,0 %;   ! Latest MSCP command status for this command 
macro CDDB$L_RSTRTCDRP = 52,0,32,0 %;   ! Addr of only active CDRP after VC re-establish 
macro CDDB$B_RETRYCNT = 56,0,8,0 %;     ! # retries remaining for CDRP after VC reset 
macro CDDB$B_DAPCOUNT = 57,0,8,0 %;     ! # DU$TMR loops until DAP_THREAD
macro CDDB$W_RSTRTCNT = 58,0,16,0 %;    ! # of resynch or connection error since boot
macro CDDB$L_RSTRTQFL = 60,0,32,0 %;    ! Queue wherein we accumulate, sort and select 
macro CDDB$L_RSTRTQBL = 64,0,32,0 %;    !  for re-submission following VC re-establish 
macro CDDB$L_SAVED_PC = 68,0,32,0 %;    ! Saved PC on internal subroutine calls 
macro CDDB$L_UCBCHAIN = 72,0,32,0 %;    ! Chain of UCBs on connection
macro CDDB$L_ORIGUCB = 76,0,32,0 %;     ! Ptr to Orig. UCB if unchained
macro CDDB$L_ALLOCLS = 80,0,32,0 %;     ! Device Allocation Class
macro CDDB$L_DAPCDRP = 84,0,32,0 %;     ! Ptr to Deter.Acc.Path CDRP
macro CDDB$L_CDDBLINK = 88,0,32,0 %;    ! Link in CDDB chain
macro CDDB$B_FOVER_CTR = 92,0,8,0 %;    !  counter of reconnect intervals per failover try
macro CDDB$B_STS2 = 93,0,8,0 %;         ! Further status bits
macro CDDB$V_DISC_PEND = 93,0,1,0 %;    !  Connection disconnect pending
macro CDDB$V_CRNSET = 93,1,1,0 %;       !  Setting controller
!   reference number.
macro CDDB$W_WTUCBCTR = 94,0,16,0 %;    !  counter of UCBs waiting for mount ver. to finish
macro CDDB$B_CSVRSN = 96,0,8,0 %;       !  Controller microcode version
macro CDDB$B_CHVRSN = 97,0,8,0 %;       !  Controller hardware version
macro CDDB$W_CPYSEQNUM = 98,0,16,0 %;   !  Base value IO$_COPYSHAD sequence number
macro CDDB$L_MAXBCNT = 100,0,32,0 %;    !  Max byte count for this connection
macro CDDB$L_CTRLTR_MASK = 104,0,32,0 %; !  Mask of controller letters (ddCu:) used by this controller
macro CDDB$W_LOAD_AVAIL = 108,0,16,0 %; !  Load available from MSCP server
macro CDDB$W_RSVD4 = 110,0,16,0 %;      !  reserved word
macro CDDB$L_PERMCDRP = 112,0,32,0 %;   ! Beginning of a permanent CDRP allocated 
!   contiguous to CDDB
 
!*** MODULE $CDLDEF ***
! +
!  CDL - SCS CONNECTION DESCRIPTOR LIST
! 
!  THERE IS A SYSTEM WIDE LIST OF CONNECTION DESCRIPTORS POINTED
!  TO BY THE CDL.
! -
literal CDL$C_LENGTH = 16;              ! LENGTH OF NEG PORTION OF STRUCTURE 
literal CDL$S_CDLDEF = 20;
macro CDL$W_MAXCONIDX = -16,0,16,0 %;   ! MAXIMUM ! OF CDT'S 
macro CDL$L_FREECDT = -12,0,32,0 %;     ! ADDR OF 1ST FREE CDT 
macro CDL$W_SIZE = -8,0,16,0 %;         ! STRUCTURE SIZE IN BYTES 
macro CDL$B_TYPE = -6,0,8,0 %;          ! SCS STRUCTURE TYPE 
macro CDL$B_SUBTYP = -5,0,8,0 %;        ! SCS STRUCT SUBTYPE FOR CDL 
macro CDL$L_NOCDT_CNT = -4,0,32,0 %;    ! Count of CDT allocation failures
macro CDL$L_BASE = 0,0,32,0 %;          ! BASE OF THE TABLE 
 
!*** MODULE $CDTDEF ***
! +
!  CDT - SCS CONNECTION DESCRIPTOR TABLE
! 
!  THESE DESCRIPTORS ARE POINTED TO BY THE SYSTEM WIDE CONNECTION
!  DESCRIPTOR LIST (CDL).  ONE CDT IS USED PER SCS VIRTUAL CIRCUIT
!  OR LISTENING CONNECTION.
! -
literal CDT$C_CLOSED = 0;               !  CLOSED 
literal CDT$C_LISTEN = 1;               !  LISTENING FOR CONNX REQUESTS 
literal CDT$C_OPEN = 2;                 !  OPEN 
literal CDT$C_DISC_ACK = 3;             !  DISCONNECT ACKNOWLEDGED 
literal CDT$C_DISC_REC = 4;             !  DISCONNECT REQ RECEIVED 
literal CDT$C_DISC_SENT = 5;            !  DISCONNECT SENT 
literal CDT$C_DISC_MTCH = 6;            !  DISCONNECT MATCH 
literal CDT$C_CON_SENT = 7;             !  CONNECT REQ SENT 
literal CDT$C_CON_ACK = 8;              !  CONNECT REQ SENT AND ACK'ED 
literal CDT$C_CON_REC = 9;              !  CONNECT REQ RECEIVED 
literal CDT$C_ACCP_SENT = 10;           !  ACCEPT REQ SENT 
literal CDT$C_REJ_SENT = 11;            !  REJECT SENT 
literal CDT$C_DISC_MTCH_RSPQ = 12;      !  MATCHING DISCONNECT RESPONSE IN PROGRESS
literal CDT$C_DISC_RSPQ = 13;           !  DISCONNECT RESPONSE IN PROGRESS
literal CDT$C_VC_FAIL = 14;             !  VIRTUAL CIRCUIT FAILED 
!  
literal CDT$C_CON_PEND = 1;             !  WAITING TO SEND CONNECT REQ 
literal CDT$C_ACCP_PEND = 2;            !  WAITING TO SEND ACCEPT REQ 
literal CDT$C_REJ_PEND = 3;             !  WAITING TO SEND REJECT REQ 
literal CDT$C_DISC_PEND = 4;            !  WAITING TO SEND DISCONNECT REQ 
literal CDT$C_CR_PEND = 5;              !  WAITING TO SEND CREDIT 
literal CDT$C_DCR_PEND = 6;             !  WAITING TO SEND CREDIT IN 
!   PREPARATION FOR DISCONNECT
literal CDT$C_RATING0 = 0;              !  (TYC 4-JAN-89) Undefined yet but valid value
literal CDT$C_RATING1 = 1;              !  (TYC 4-JAN-89) Undefined yet but valid value
literal CDT$C_RATING2 = 2;              !  (TYC 4-JAN-89) Undefined yet but valid value
literal CDT$C_RATING3 = 3;              !  (TYC 4-JAN-89) Undefined yet but valid value
!  MOVE SUGGESTED FOR AN EQUAL PATH (I.E. CI->CI)
literal CDT$C_YELLOW = 4;               !  (TYC 4-JAN-89) port is in YELLOW zone
literal CDT$C_RATING5 = 5;              !  (TYC 4-JAN-89) Undefined yet but valid value
literal CDT$C_RED = 6;                  !  port is in RED zone (i.e. port is saturated)
literal CDT$C_UNEQUAL_PATH = 7;         !  MOVE SUGGESTED FOR AN UNEQUAL PATH (I.E. NI->CI)
literal CDT$C_LOAD_SHARE_DISABLE = 8;   !  load sharing disabled
!  
literal CDT$C_BAD_RATING = -2147483648; !  (TYC 4-JAN-89) Bad load rating marker
literal CDT$K_BAD_RATING = -2147483648;
literal CDT$C_LOADSHARE = 0;            !  (TYC 21-Jun-89) Load sharing SYSAP
literal CDT$C_PRE_LOADSHARE = 1;        !  (TYC 21-Jun-89) Pre-load sharing SYSAP
!  
literal CDT$K_LENGTH = 347;             ! LENGTH OF CDT 
literal CDT$C_LENGTH = 347;             ! LENGTH OF CDT 
literal CDT$S_CDTDEF = 347;
macro CDT$L_MSGINPUT = 0,0,32,0 %;      ! ADDR OF MSG INPUT DISPATCHER 
macro CDT$L_LINK = 0,0,32,0 %;          !  OR LINK TO NEXT FREE CDT 
macro CDT$L_DGINPUT = 4,0,32,0 %;       ! ADDR TO CALL ON DG RECEIVED 
macro CDT$W_SIZE = 8,0,16,0 %;          ! STRUCTURE SIZE IN BYTES 
macro CDT$B_TYPE = 10,0,8,0 %;          ! SCS STRUCTURE TYPE 
macro CDT$B_SUBTYP = 11,0,8,0 %;        ! SCS STRUCT SUBTYPE FOR CDT 
macro CDT$L_ERRADDR = 12,0,32,0 %;      ! ADDR TO CALL FOR ERROR NOTIFICATION 
macro CDT$L_PDT = 16,0,32,0 %;          ! ADDR OF ASSOC PORT DESC TABLE 
macro CDT$L_RCONID = 20,0,32,0 %;       ! REMOTE CONNECTION ID 
macro CDT$L_LCONID = 24,0,32,0 %;       ! LOCAL CONNECTION ID 
macro CDT$L_PB = 28,0,32,0 %;           ! ADDR OF ASSOC PATH BLOCK 
macro CDT$B_RSTATION = 32,0,0,0 %;
literal CDT$S_RSTATION = 6;             ! REMOTE STATION ADDR 
macro CDT$W_REASON = 38,0,16,0 %;       ! REJECT/DISCONNECT REASON 
macro CDT$W_STATE = 40,0,16,0 %;        ! CONNECTION STATE 
! STATE VALUES:
!  0 ORIGIN, INCREMENTS OF 1: 
macro CDT$W_BLKSTATE = 42,0,16,0 %;     ! SCS SEND BLOCKED STATE 
! STATE VALUES:
!  1 ORIGIN, INCREMENTS OF 1: 
!  
macro CDT$L_SCSMSG = 44,0,32,0 %;       ! ADDR OF SCS RECEIVE BUFFER 
macro CDT$L_WAITQFL = 48,0,32,0 %;      ! SEND SCS MSG WAIT QUEUE FLINK 
macro CDT$L_WAITQBL = 52,0,32,0 %;      ! SEND SCS MSG WAIT QUEUE BLINK 
macro CDT$L_CRWAITQFL = 56,0,32,0 %;    ! SEND CREDIT WAIT QUEUE FLINK 
macro CDT$L_CRWAITQBL = 60,0,32,0 %;    ! SEND CREDIT WAIT QUEUE BLINK 
macro CDT$W_SEND = 64,0,16,0 %;         ! CURRENT SEND CREDIT 
macro CDT$W_REC = 66,0,16,0 %;          ! RECEIVE CREDIT (SEND CREDIT 
!  HELD BY REMOTE
macro CDT$W_MINREC = 68,0,16,0 %;       ! MINIMUM RECEIVE CREDIT (MIN 
!  SEND REQUIRED BY REMOTE)
macro CDT$W_PENDREC = 70,0,16,0 %;      ! RECEIVE CREDIT NOT YET EXTENDED 
!  TO REMOTE
macro CDT$W_INITLREC = 72,0,16,0 %;     ! INITIAL RECEIVE CREDIT 
macro CDT$W_MINSEND = 74,0,16,0 %;      ! MINIMUM SEND CREDIT 
macro CDT$W_DGREC = 76,0,16,0 %;        ! DATAGRAMS QUEUED FOR RECEIVE 
macro CDT$B_PRIORITY = 78,0,8,0 %;      ! BLOCK TRANSFER PRIORIY 
macro CDT$L_RPROCNAM = 80,0,32,0 %;     ! ADDR OF REMOTE PROCESS NAME 
macro CDT$L_LPROCNAM = 84,0,32,0 %;     ! ADDR OF LOCAL PROCESS NAME 
macro CDT$L_CONDAT = 88,0,32,0 %;       ! ADDR OF CONNECT DATA 
macro CDT$L_AUXSTRUC = 92,0,32,0 %;     ! ADDR OF AUXILARY DATA STRUCTURE 
macro CDT$L_BADRSP = 96,0,32,0 %;       ! ADDR IN SYSAP TO CALL WITH 
!  BAD RESPONSE(UNIMPLEMENTED) 
macro CDT$L_FPC = 100,0,32,0 %;         ! SAVED FORK PROCESS PC 
macro CDT$L_FR5 = 104,0,32,0 %;         ! SAVED FORK PROCESS R5 
macro CDT$L_CDTLST = 108,0,32,0 %;      ! LINK FOR CDT LIST FROM PB 
macro CDT$L_DGSENT = 112,0,32,0 %;      ! # APPLICATION DGS SENT
macro CDT$L_DGRCVD = 116,0,32,0 %;      ! # APPLICATION DGS REC'D
macro CDT$L_DGDISCARD = 120,0,32,0 %;   ! # DGS DISCARDED BY DRIVER
macro CDT$L_MSGSENT = 124,0,32,0 %;     ! # APPLICATION MSGS SENT
macro CDT$L_MSGRCVD = 128,0,32,0 %;     ! # APPLICATION MSGS REC'D
macro CDT$L_SNDDATS = 132,0,32,0 %;     ! # SEND DATAS INITIATED
macro CDT$L_BYTSENT = 136,0,32,0 %;     ! # BYTES SENT VIA SEND DATAS
macro CDT$L_REQDATS = 140,0,32,0 %;     ! #REQ DATAS INITIATED
macro CDT$L_BYTREQD = 144,0,32,0 %;     ! BYTES REC'D VIA REQ DATAS
macro CDT$L_BYTMAPD = 148,0,32,0 %;     ! TOTAL BYTES MAPPED
macro CDT$W_QCR_CNT = 152,0,16,0 %;     ! # TIMES QUEUED FOR SEND CREDIT
macro CDT$W_QBDT_CNT = 154,0,16,0 %;    ! # TIMES QUEUED FOR BDT
!  (TYC 14-FEB-89) LOAD SHARING FIELDS
macro CDT$L_MOVE_PATH_ADDR = 156,0,32,0 %; !  CONNECTION MOVE ADDRESS
!  1 ORIGIN, INCREMENTS OF 1: 
macro CDT$L_SHARE_FLINK = 160,0,32,0 %; ! DYNAMIC LOAD SHARING CDT QUEUE FLINK
macro CDT$L_SHARE_BLINK = 164,0,32,0 %; ! DYNAMIC LOAD SHARING CDT QUEUE BLINK
macro CDT$L_SB = 168,0,32,0 %;          ! SYSTEM BLOCK ADDRESS
!  R1 load rating on entry (TYC 4-JAN-89)
macro CDT$L_CON_REQ_CTR = 172,0,32,0 %; !  (TYC 25-Apr-89) # of times CONN REQ sent
macro CDT$L_LOAD_RATING = 176,0,32,0 %; !  LOAD RATING (TYC 4-JAN-89 now used)
macro CDT$L_TIME_STAMP = 180,0,32,0 %;  !  TIME STAMP (EXE$GL_ABSTIM) OF CONNECTION FORMATION
macro CDT$L_QUEUE_TIME_STAMP = 184,0,32,0 %; !  (TYC 15-Feb-89) TIME STAMP OF MOVING CDT TO QUEUE
macro CDT$L_DISCON_COUNTER = 188,0,32,0 %; !  (TYC 15-Feb-89) LOAD SHARING DISCONNECT COUNTER
!  used with conditional assembly
macro CDT$L_OPTIMAL_PATH = 192,0,32,0 %; !  (TYC 15-Feb-89) PATH ADDRESS OF THE OPTIMAL PORT
macro CDT$L_BYTES_XFER = 196,0,32,0 %;  !  (TYC 15-Feb-89) TOTAL BYTES XFERRED (BOTH XMIT & RCV)
macro CDT$L_BYTES_DG_XMT = 200,0,32,0 %; !  (TYC 15-Feb-89) TOTAL DG BYTES XMITTED 
macro CDT$L_BYTES_DG_RCV = 204,0,32,0 %; !  (TYC 15-Feb-89) TOTAL DG BYTES RECEIVED
macro CDT$L_BYTES_MSG_XMT = 208,0,32,0 %; !  (TYC 15-Feb-89) TOTAL MSG BYTES XMITTED
macro CDT$L_BYTES_MSG_RCV = 212,0,32,0 %; !  (TYC 15-Feb-89) TOTAL MSG BYTES RECEIVED
macro CDT$L_BYTES_XFER_LAST = 216,0,32,0 %; !  (TYC 31-Aug-89) TOTAL BYTES XFERRED 
!  UP TO LAST LOAD SHARING INTERVAL
macro CDT$L_BYTES_DG_XMT_LAST = 220,0,32,0 %; !  (TYC 31-Aug-89) TOTAL DG BYTES XMITTED
!  UP TO LAST LOAD SHARING INTERVAL
macro CDT$L_BYTES_DG_RCV_LAST = 224,0,32,0 %; !  (TYC 31-Aug-89) TOTAL DG BYTES RECEIVED 
!  UP TO LAST LOAD SHARING INTERVAL
macro CDT$L_BYTES_MSG_XMT_LAST = 228,0,32,0 %; !  (TYC 31-Aug-89) TOTAL MSG BYTES XMITTED 
!  UP TO LAST LOAD SHARING INTERVAL
macro CDT$L_BYTES_MSG_RCV_LAST = 232,0,32,0 %; !  (TYC 31-Aug-89) TOTAL MSG BYTES RECEIVED
!  UP TO LAST LOAD SHARING INTERVAL
macro CDT$L_BYTMAPD_LAST = 236,0,32,0 %; !  (TYC 31-Aug-89) TOTAL BYTES MAPPED 
!  UP TO LAST LOAD SHARING INTERVAL
macro CDT$L_DGSENT_LAST = 240,0,32,0 %; !  (TYC 31-Aug-89) TOTAL DGS XMITTED 
!  UP TO LAST LOAD SHARING INTERVAL
macro CDT$L_DGRCVD_LAST = 244,0,32,0 %; !  (TYC 31-Aug-89) TOTAL DGS RECEIVED
!  UP TO LAST LOAD SHARING INTERVAL
macro CDT$L_MSGSENT_LAST = 248,0,32,0 %; !  (TYC 31-Aug-89) TOTAL MSGS XMITTED
!  UP TO LAST LOAD SHARING INTERVAL
macro CDT$L_MSGRCVD_LAST = 252,0,32,0 %; !  (TYC 31-Aug-89) TOTAL MSGS RECEIVED 
!  UP TO LAST LOAD SHARING INTERVAL
!  (TYC 17-Feb-89) peak counters used with conditional assembly
macro CDT$L_BYTES_XFER_PEAK = 256,0,32,0 %; !  PEAK VALUE OF TOTAL BYTES XFERRED 
macro CDT$L_BYTES_DG_XMT_PEAK = 260,0,32,0 %; !  PEAK VALUE OF TOTAL DG BYTES XMITTED 
macro CDT$L_BYTES_DG_RCV_PEAK = 264,0,32,0 %; !  PEAK VALUE OF TOTAL DG BYTES RECEIVED 
macro CDT$L_BYTES_MSG_XMT_PEAK = 268,0,32,0 %; !  PEAK VALUE OF TOTAL MSG BYTES XMITTED 
macro CDT$L_BYTES_MSG_RCV_PEAK = 272,0,32,0 %; !  PEAK VALUE OF TOTAL MSG BYTES RECEIVED
macro CDT$L_BYTMAPD_PEAK = 276,0,32,0 %; !  PEAK VALUE OF TOTAL BYTES MAPPED 
macro CDT$L_DGSENT_PEAK = 280,0,32,0 %; !  PEAK VALUE OF TOTAL DGS XMITTED 
macro CDT$L_DGRCVD_PEAK = 284,0,32,0 %; !  PEAK VALUE OF TOTAL DGS RECEIVED
macro CDT$L_MSGSENT_PEAK = 288,0,32,0 %; !  PEAK VALUE OF TOTAL MSGS XMITTED
macro CDT$L_MSGRCVD_PEAK = 292,0,32,0 %; !  PEAK VALUE OF TOTAL MSGS RECEIVED 
!  (TYC 17-Feb-89) average counters used with conditional assembly
macro CDT$L_BYTES_XFER_AVG = 296,0,32,0 %; !  AVERAGE VALUE OF TOTAL BYTES XFERRED 
macro CDT$L_BYTES_DG_XMT_AVG = 300,0,32,0 %; !  AVERAGE VALUE OF TOTAL DG BYTES XMITTED 
macro CDT$L_BYTES_DG_RCV_AVG = 304,0,32,0 %; !  AVERAGE VALUE OF TOTAL DG BYTES RECEIVED 
macro CDT$L_BYTES_MSG_XMT_AVG = 308,0,32,0 %; !  AVERAGE VALUE OF TOTAL MSG BYTES XMITTED 
macro CDT$L_BYTES_MSG_RCV_AVG = 312,0,32,0 %; !  AVERAGE VALUE OF TOTAL MSG BYTES RECEIVED
macro CDT$L_BYTMAPD_AVG = 316,0,32,0 %; !  AVERAGE VALUE OF TOTAL BYTES MAPPED 
macro CDT$L_DGSENT_AVG = 320,0,32,0 %;  !  AVERAGE VALUE OF TOTAL DGS XMITTED 
macro CDT$L_DGRCVD_AVG = 324,0,32,0 %;  !  AVERAGE VALUE OF TOTAL DGS RECEIVED
macro CDT$L_MSGSENT_AVG = 328,0,32,0 %; !  AVERAGE VALUE OF TOTAL MSGS XMITTED
macro CDT$L_MSGRCVD_AVG = 332,0,32,0 %; !  AVERAGE VALUE OF TOTAL MSGS RECEIVED 
macro CDT$L_BYTES_XFER_INT = 336,0,32,0 %; !  (TYC 31-AUG-89) TOTAL BYTES XFERRED
!  DURING LAST LOAD SHARING INTERVAL
!  (TYC 21-Jun-89) Moved fields
macro CDT$W_LOCAL_INDEX = 340,0,16,0 %; !  LOCAL PROCESS NAME INDEX
macro CDT$B_LS_FLAG = 342,0,8,0 %;      !  (TYC 15-Feb-89) LOAD SHARING FLAG.  IF SET,
!  THE CONNECTION IS REQUESTED TO DISCONNECT
macro CDT$B_SYSAP_VERSION = 343,0,8,0 %; !  (TYC 21-Jun-89) Flag for SYSAP version
!  (TYC 21-Jun-89) SYSAP version constants
 
!*** MODULE $CEBDEF ***
! +
!  COMMON EVENT BLOCK
! -
literal CEB$M_VALID = 1;
literal CEB$M_LOCKED = 2;
literal CEB$M_REFCNTLCK = 4;
literal CEB$K_LENGTH = 60;              ! LENGTH OF NORMAL COMMON EVENT BLOCK 
literal CEB$C_LENGTH = 60;              ! LENGTH OF NORMAL COMMON EVENT BLOCK 
! 
literal CEB$K_SLAVLNG = 72;             ! LENGTH OF SHMEM SLAVE COMMON EVENT BLK 
literal CEB$C_SLAVLNG = 72;             ! LENGTH OF SHMEM SLAVE COMMON EVENT BLK 
literal CEB$S_CEBDEF = 72;
macro CEB$L_CEBFL = 0,0,32,0 %;         ! POINTER TO NEXT COMMON EVENT BLOCK 
macro CEB$V_VALID = 0,0,1,0 %;          ! SHMEM MASTER CEB, SET IF VALID ENTRY 
macro CEB$V_LOCKED = 0,1,1,0 %;         ! SHMEM MASTER CEB, SET IF ENTRY LOCKED 
macro CEB$V_REFCNTLCK = 0,2,1,0 %;      ! SHMEM MASTER CEB, LOCKED FOR REFCNT CHG 
macro CEB$L_CEBBL = 4,0,32,0 %;         ! POINTER TO PREVIOUS COMMON EVENT BLOCK 
macro CEB$W_SIZE = 8,0,16,0 %;          ! SIZE OF COMMON EVENT BLOCK IN BYTES 
macro CEB$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE CODE FOR CEB 
macro CEB$B_STS = 11,0,8,0 %;           ! STATUS FLAGS FOR CEB 
macro CEB$V_NOQUOTA = 11,0,1,0 %;       ! NO QUOTA UPDATE 
macro CEB$V_PERM = 11,1,1,0 %;          ! PERMANENT CLUSTER 
macro CEB$L_PID = 12,0,32,0 %;          ! PID OF CREATOR 
macro CEB$L_EFC = 16,0,32,0 %;          ! EVENT FLAGS (32 BIT VECTOR) 
macro CEB$L_WQFL = 20,0,32,0 %;         ! HEAD OF WAIT QUEUE 
macro CEB$L_WQBL = 24,0,32,0 %;         ! TAIL OF WAIT QUEUE 
macro CEB$W_WQCNT = 28,0,16,0 %;        ! WAIT QUEUE COUNT(LENGTH) 
! SHMEM FIELDS IN THIS WORD
macro CEB$B_LOCK = 28,0,8,0 %;          ! SHMEM MASTER CEB, ! OF PORT OWNING LOCK 
macro CEB$B_PROCCNT = 29,0,8,0 %;       ! SHMEM MASTER CEB, MAX ! OF PROCESSORS 
macro CEB$W_STATE = 30,0,16,0 %;        ! CEF WAIT STATE NUMBER 
! SHMEM FIELDS IN THIS WORD
macro CEB$B_CREATPORT = 30,0,8,0 %;     ! SHMEM MASTER CEB, ! OF CREATOR PORT 
macro CEB$B_DELETPORT = 31,0,8,0 %;     ! SHMEM MASTER CEB, ! OF DELETER PORT 
macro CEB$L_ORB = 32,0,32,0 %;          ! POINTER TO THE ORB
macro CEB$L_UIC = 36,0,32,0 %;          ! USER IDENT OF CEB CREATOR 
macro CEB$W_GRP = 38,0,16,0 %;          ! GROUP NUMBER OF OWNER 
macro CEB$W_PROT = 40,0,16,0 %;         ! PROTECTION MASK 
macro CEB$W_REFC = 42,0,16,0 %;         ! REFERENCE COUNT FOR CEB 
macro CEB$T_EFCNAM = 44,0,0,0 %;
literal CEB$S_EFCNAM = 16;              ! EVENT CLUSTER TEXT NAME 
!  THE FOLLOWING FIELDS ARE DEFINED FOR SHARED MEMORY COMMON EVENT BLOCKS.
!  CEB$L_SHB, CEB$W_INDX, AND CEB$L_MASTER ARE CONTAINED IN THE SLAVE CEB WHILE
!  CEB$L_VASLAVE1 IS THE OFFSET IN THE MASTER CEB TO THE FIRST SLAVE CEB.
! 
macro CEB$L_SHB = 60,0,32,0 %;          ! SHMEM SLAVE CEB, SHMEM CTL BLK ADR 
macro CEB$L_VASLAVE1 = 60,0,32,0 %;     ! SHMEM MASTER CEB, PTR TO 1ST SLAVE CEB 
macro CEB$W_INDX = 64,0,16,0 %;         ! SHMEM SLAVE CEB, INDEX TO MASTER CEB 
! SHMEM MASTER CEB, FIELDS IN NEXT N
!  LONGWORDS ARE PROCESSOR REFCNTS
!  (ONE WORD FOR EACH PROCESSOR)
!  (OFFSET IS COMPUTED AT RUN-TIME)
macro CEB$L_MASTER = 68,0,32,0 %;       ! SHMEM SLAVE CEB, VA OF MASTER CEB 
 
!*** MODULE $CHPCTLDEF ***
! +
! 
!  CHeck Protection ConTroL block definition.  This block contains the
!  information concerning the type of access check being made.
! 
! -
literal CHPCTL$M_READ = 1;
literal CHPCTL$M_WRITE = 2;
literal CHPCTL$M_USEREADALL = 4;
literal CHPCTL$K_LENGTH = 12;
literal CHPCTL$C_LENGTH = 12;
literal CHPCTL$S_CHPCTL = 12;
macro CHPCTL$L_ACCESS = 0,0,32,0 %;     !  Type of access desired
macro CHPCTL$L_FLAGS = 4,0,32,0 %;      !  Control flags
macro CHPCTL$V_READ = 4,0,1,0 %;        !  Read access
macro CHPCTL$V_WRITE = 4,1,1,0 %;       !  Write access
macro CHPCTL$V_USEREADALL = 4,2,1,0 %;  !  Try for read access via READALL
macro CHPCTL$B_MODE = 8,0,8,0 %;        !  Access mode of request
 
!*** MODULE $CHPRETDEF ***
! +
! 
!  CHeck Protection ConTroL RETurn argument block.  This block contains
!  the information needed to return arguments from the protection check.
! 
! -
literal CHPRET$K_LENGTH = 40;
literal CHPRET$C_LENGTH = 40;
literal CHPRET$S_CHPRET = 40;
macro CHPRET$W_AUDITLEN = 0,0,16,0 %;   !  Size of the audit ACE buffer
macro CHPRET$L_AUDIT = 4,0,32,0 %;      !  Address of the audit ACE buffer
macro CHPRET$L_AUDITRET = 8,0,32,0 %;   !  Address of word to get ACE length
macro CHPRET$W_ALARMLEN = 12,0,16,0 %;  !  Size of the alarm ACE buffer
macro CHPRET$L_ALARM = 16,0,32,0 %;     !  Address of the alarm ACE buffer
macro CHPRET$L_ALARMRET = 20,0,32,0 %;  !  Address of word to get ACE length
macro CHPRET$W_MATCHED_ACELEN = 24,0,16,0 %; !  Size of the matched ACE buffer
macro CHPRET$L_MATCHED_ACE = 28,0,32,0 %; !  Address of the matched ACE buffer
macro CHPRET$L_MATCHED_ACERET = 32,0,32,0 %; !  Address of word to get ACE length
macro CHPRET$L_PRIVS_USED = 36,0,32,0 %; !  Address of longword to get privileges used
 
!*** MODULE $CIADEF ***
! +
!  CIA - Compound Intrusion Analysis block
! 
!  Contains information about suspected and known intruders
! -
literal CIA$K_TERMINAL = 1;             !  Unknown user at terminal
literal CIA$K_TERM_USER = 2;            !  Known username at terminal
literal CIA$K_NETWORK = 3;              !  Network source
literal CIA$K_USERNAME = 4;             !  Username of parent process
!literal CIA$M_INTRUDER = 1;
literal CIA$K_LENGTH = 152;             !  Length of CIA block
literal CIA$C_LENGTH = 152;             !  Length of CIA block
literal CIA$S_CIADEF = 152;
macro CIA$L_FLINK = 0,0,32,0 %;         !  Forward link to next block
macro CIA$L_BLINK = 4,0,32,0 %;         !  Backward link to previous block
macro CIA$W_SIZE = 8,0,16,0 %;          !  Size of block
macro CIA$B_TYPE = 10,0,8,0 %;          !  Structure type 
macro CIA$B_SUBTYPE = 11,0,8,0 %;       !  Structure subtype
!  Source of breakin attempt
macro CIA$W_FLAGS = 12,0,16,0 %;        !  Breakin type flags 
!macro CIA$V_INTRUDER = 12,0,1,0 %;      !  Entry is an intruder
macro CIA$W_COUNT = 14,0,16,0 %;        !  Count of attempts
macro CIA$Q_TIME = 16,0,0,0 %;
literal CIA$S_TIME = 8;                 !  Expiration time of entry
macro CIA$T_DATA = 24,0,0,0 %;
literal CIA$S_DATA = 128;               !  Data area
 
!*** MODULE $CIBDTDEF ***
! +
!  CIBDT - CI BUFFER DESCRIPTOR TABLE
! 
!  THIS TABLE IS SHARABLE AMONG ALL CI PORTS ON A SYSTEM.  BUFFER
!  DESCRIPTORS (BD'S) ARE ALLOCATED FOR CI BLOCK TRANSFERS.
! -
literal CIBDT$K_BDLIST = 0;             ! START OF BUFFER DESCRIPTORS 
literal CIBDT$C_BDLIST = 0;             ! START OF BUFFER DESCRIPTORS 
literal CIBDT$C_LENGTH = 32;            ! LENGTH OF NEGATIVE PORTION OF STRUCT 
! 
literal CIBDT$S_CIBDTDEF = 33;
macro CIBDT$L_WAITFL = -32,0,32,0 %;    ! BD WAIT QUEUE FWD LINK 
macro CIBDT$L_WAITBL = -28,0,32,0 %;    ! BD WAIT QUEUE BACK LINK 
macro CIBDT$W_SIZE = -24,0,16,0 %;      ! STRUCTURE SIZE IN BYTES 
macro CIBDT$B_TYPE = -22,0,8,0 %;       ! CI STRUCTURE TYPE 
macro CIBDT$B_SUBTYP = -21,0,8,0 %;     ! CI STRUCT SUBTYPE FOR CI BDT 
macro CIBDT$L_OLDBL = -20,0,32,0 %;     ! Pre 4.4 backward link must be zero for V4.5 or after
macro CIBDT$L_FREEBD = -12,0,32,0 %;    ! ADDR OF FIRST FREE BD 
macro CIBDT$L_MAXIDX = -8,0,32,0 %;     ! MAX INDEX INTO BUFFER DESCRIPTORS 
macro CIBDT$L_QBDT_CNT = -4,0,32,0 %;   ! Count of BDT waits
 
!*** MODULE $CIBDDEF ***
! +
!  BD - CI BUFFER DESCRIPTOR FORMAT
! -
literal CIBD$M_AC = 4096;
literal CIBD$M_V = 32768;
literal CIBD$K_LENGTH = 16;             ! LENGTH OF A BUFFER DESCRIPTOR 
literal CIBD$C_LENGTH = 16;             ! LENGTH OF A BUFFER DESCRIPTOR 
literal CIBD$S_CIBDDEF = 16;
macro CIBD$W_FLAGS = 0,0,16,0 %;        ! FLAGS WORD 
macro CIBD$V_BOFF = 0,0,9,0 %;
literal CIBD$S_BOFF = 9;                !  BYTE OFFSET OF START OF BUFFER 
macro CIBD$V_AC = 0,12,1,0 %;           !  ACCESS MODE CHECK ENABLED IF SET 
macro CIBD$V_ACMOD = 0,13,2,0 %;
literal CIBD$S_ACMOD = 2;               !  ACCESS MODE REQ'D IN PTE'S 
macro CIBD$V_V = 0,15,1,0 %;            !  VALID BIT 
macro CIBD$W_KEY = 2,0,16,0 %;          ! SEQUENCE NUMBER 
macro CIBD$L_BLEN = 4,0,32,0 %;         ! LENGTH OF MAPPED BUFFER 
macro CIBD$L_SVAPTE = 8,0,32,0 %;       ! SVA OF PTE MAPPING START OF BUFFER 
macro CIBD$L_CDRP = 12,0,32,0 %;        ! ADDR OF ASSOCIATED CDRP 
macro CIBD$L_LINK = 12,0,32,0 %;        !  OR ADDR OF NEXT FREE DESCRIPTOR 
 
!*** MODULE $CIBHANDEF ***
! +
!  CIBHAN - CI BUFFER HANDLE FORMAT
! -
literal CIBHAN$K_LENGTH = 12;           ! LENGTH OF CI BUFFER HANDLE 
literal CIBHAN$C_LENGTH = 12;           ! LENGTH OF CI BUFFER HANDLE 
literal CIBHAN$S_CIBHANDEF = 12;
macro CIBHAN$L_BOFF = 0,0,32,0 %;       ! BYTE OFFSET IN LOCAL BUFFER 
macro CIBHAN$L_BNAME = 4,0,32,0 %;      ! NAME OF LOCAL BUFFER 
macro CIBHAN$L_RCONID = 8,0,32,0 %;     ! REMOTE CONNECTION ID 
 
!*** MODULE $CIFQDTDEF ***
! +
!  CIFQDT - CI FREE MESSAGE/DATAGRAM QUEUE DESCRIPTOR TABLE
! 
!  THIS DATA STRUCTURE AND THE QUEUES IT HAS HEADERS FOR MAY BE
!  SHARED AMONG ALL CI'S ON THE SYSTEM.
! -
literal CIFQDT$K_LENGTH = 32;           ! LENGTH OF CI FQDT 
literal CIFQDT$C_LENGTH = 32;           ! LENGTH OF CI FQDT 
literal CIFQDT$S_CIFQDTDEF = 32;
macro CIFQDT$W_DGSIZ = 0,0,16,0 %;      ! DATAGRAM SIZE (INCL PORT HEADER) 
macro CIFQDT$W_MSGSIZ = 2,0,16,0 %;     ! MESSAGE SIZE (INCL PORT HEADER) 
macro CIFQDT$W_SIZE = 8,0,16,0 %;       ! STRUCTURE SIZE IN BYTES 
macro CIFQDT$B_TYPE = 10,0,8,0 %;       ! CI STRUCTURE TYPE 
macro CIFQDT$B_SUBTYP = 11,0,8,0 %;     ! CI STRUCT SUBTYPE FOR CI FQDT 
macro CIFQDT$W_DGCNT = 12,0,16,0 %;     ! SUM OF INITL DG CREDITS FOR ALL CONNX 
macro CIFQDT$W_MSGCNT = 14,0,16,0 %;    ! SUM OF INITL MSG CREDITS FOR ALL CONNX 
macro CIFQDT$L_DGFL = 16,0,32,0 %;      ! DG FREE QUEUE FWD LINK 
macro CIFQDT$L_DGBL = 20,0,32,0 %;      ! DG FREE QUEUE BACK LINK 
macro CIFQDT$L_MSGFL = 24,0,32,0 %;     ! MSG FREE QUEUE FWD LINK 
macro CIFQDT$L_MSGBL = 28,0,32,0 %;     ! MSG FREE QUEUE BACK LINK 
 
!*** MODULE $CLUDEF ***
! +
!  CLUDEF - CLUSTER DEFINITIONS
! -
literal CLU$C_MAX_NODES = 256;          !  MAX CLUSTER NODES
literal CLU$K_MAX_NODES = 256;          !  MAX CLUSTER NODES
 
!*** MODULE $CLUBDEF ***
! +
!  CLUB - CLUSTER BLOCK.  
! 
! 	THERE IS ONE CLUB IN A VMS SYSTEM THAT IS PART OF A CLUSTER.
! 	THE CLUB DEFINES THE STATE OF THE THE CLUSTER AS KNOWN TO
! 	THE LOCAL SYSTEM.
! -
! 
! 	THE CLUB FORK BLOCK (CLUBFKB) IS A SUBBLOCK OF THE CLUB THAT IS
! 	USED WHEN IT NECESSARY TO WAIT IN ORDER TO ALLOCATE MEMORY OR
! 	WHEN IT IS DESIRABLE TO FORK TO ALLOW OTHER FORK PROCESSES A
! 	CHANCE TO RUN.
literal CLUBFKB$M_FKB_BUSY = 1;
literal CLUBFKB$M_FORKQ = 2;
literal CLUBFKB$C_LENGTH = 32;          !  LENGTH OF CLUBFKB
literal CLUBFKB$K_LENGTH = 32;          !  LENGTH OF CLUBFKB
literal CLUBFKB$S_CLUBFKBDEF = 32;
macro CLUBFKB$B_FORK_BLOCK = 0,0,0,1 %;
literal CLUBFKB$S_FORK_BLOCK = 24;      !  FORK BLOCK TO WAIT IN
macro CLUBFKB$L_PC2 = 24,0,32,0 %;      !  SAVED PC
macro CLUBFKB$L_STATUS = 28,0,32,0 %;   !  CLUSTER FAILOVER STATUS FLAGS
macro CLUBFKB$V_FKB_BUSY = 28,0,1,0 %;  !   FORK BLOCK IN USE FLAG
macro CLUBFKB$V_FORKQ = 28,1,1,0 %;     !   FORK BLOCK ON FORK QUEUE
! 
! 	THE CLUB POWERFAIL FORK BLOCK (CLUBPWF) IS A SUBBLOCK OF THE CLUB
! 	THAT IS USED TO FORK FROM IPL 31 TO IPL SCS DURING POWER RECOVERY.
literal CLUBPWF$M_BUSY = 1;
literal CLUBPWF$C_LENGTH = 28;          !  LENGTH OF CLUBPWF
literal CLUBPWF$K_LENGTH = 28;          !  LENGTH OF CLUBPWF
literal CLUBPWF$S_CLUBPWFDEF = 28;
macro CLUBPWF$B_FORK_BLOCK = 0,0,0,1 %;
literal CLUBPWF$S_FORK_BLOCK = 24;      !  FORK BLOCK TO WAIT IN
macro CLUBPWF$L_STATUS = 24,0,32,0 %;   !  BLOCK STATUS FLAGS
macro CLUBPWF$V_BUSY = 24,0,1,0 %;      !   FORK BLOCK IN USE FLAG
! 
! 	THE CLUSTER FAILOVER CONTROL BLOCK (CLUFCB) IS A SUBBLOCK OF
! 	THE CLUB THAT IS USED TO SEQUENCE FAILOVER ACTIONS IN A CLUSTER.
! 
literal CLUFCB$M_ACTIVE = 1;
literal CLUFCB$M_PENDING = 2;
literal CLUFCB$M_SYNC_NODE = 4;
literal CLUFCB$M_FKB_BUSY = 8;
literal CLUFCB$M_WAITING = 16;
literal CLUFCB$M_AUX = 32;
literal CLUFCB$M_RB_SUSPEND = 64;
literal CLUFCB$C_LENGTH = 112;          !  LENGTH OF CLUFCB
literal CLUFCB$K_LENGTH = 112;          !  LENGTH OF CLUFCB
literal CLUFCB$S_CLUFCBDEF = 112;
macro CLUFCB$B_FORK_BLOCK = 0,0,0,1 %;
literal CLUFCB$S_FORK_BLOCK = 24;       !  FORK BLOCK TO WAIT IN
macro CLUFCB$L_STEP = 24,0,32,0 %;      !  CURRENT FAILOVER STEP INDEX
macro CLUFCB$L_ID = 28,0,32,0 %;        !  FAILOVER INSTANCE IDENTIFICATION
macro CLUFCB$L_STATUS = 32,0,32,0 %;    !  CLUSTER FAILOVER STATUS FLAGS
macro CLUFCB$V_ACTIVE = 32,0,1,0 %;     !   FAILOVER ROUTINE ACTIVE
macro CLUFCB$V_PENDING = 32,1,1,0 %;    !   FAILOVER PENDING
macro CLUFCB$V_SYNC_NODE = 32,2,1,0 %;  !   LOCAL NODE IS SYNCHRONIZER
macro CLUFCB$V_FKB_BUSY = 32,3,1,0 %;   !   FORK BLOCK IN USE FLAG
macro CLUFCB$V_WAITING = 32,4,1,0 %;    !   WAITING FOR NODES TO RESPOND
macro CLUFCB$V_AUX = 32,5,1,0 %;        !   AUXILIARY FORK BLOCK ALLOCATED
macro CLUFCB$V_RB_SUSPEND = 32,6,1,0 %; !   REBUILD SUSPENDED
macro CLUFCB$L_SYNC_CSB = 36,0,32,0 %;  !  ADDRESS OF CSB OF SYNCHRONIZING SYSTEM
macro CLUFCB$B_NODEMAP = 40,0,0,1 %;
literal CLUFCB$S_NODEMAP = 32;          !  BITMAP OF ALL INVOLVED NODES
macro CLUFCB$B_RESPMAP = 72,0,0,1 %;
literal CLUFCB$S_RESPMAP = 32;          !  BITMAP OF NODES READY FOR A STEP
macro CLUFCB$L_INDEX = 104,0,32,0 %;    !  STORAGE FOR BIT MAP INDEX
macro CLUFCB$L_AUX_FKB = 108,0,32,0 %;  !  ADDRESS OF AUXILIARY FORK BLOCK 
literal CLUB$M_CLUSTER = 1;
literal CLUB$M_QF_ACTIVE = 2;
literal CLUB$M_QF_DYNVOTE = 4;
literal CLUB$M_QF_WATCHER = 8;
literal CLUB$M_SHUTDOWN = 16;
literal CLUB$M_QF_REFRESH_REQ = 32;
literal CLUB$M_STS_PPHASE = 256;
literal CLUB$M_STS_PH0 = 512;
literal CLUB$M_STS_PH1B = 1024;
literal CLUB$M_STS_PH1 = 2048;
literal CLUB$M_STS_PH2 = 4096;
literal CLUB$M_FKB_BUSY = 65536;
literal CLUB$M_UNLOCK = 131072;
literal CLUB$M_NO_FORM = 262144;
literal CLUB$M_INIT = 524288;
literal CLUB$M_BACKOUT = 1048576;
literal CLUB$M_PRIOR_PROTOCOL = 2097152;
literal CLUB$M_VERBOSE = 4194304;
literal CLUB$M_LOST_CNX = 8388608;
literal CLUB$M_QF_FAILED_NODE = 16777216;
literal CLUB$M_QF_VOTE = 33554432;
literal CLUB$M_QF_NEWVOTE = 67108864;
literal CLUB$M_ADJ_QUORUM = 134217728;
literal CLUB$M_QUORUM = 268435456;
literal CLUB$M_TRANSITION = 536870912;
literal CLUB$M_RESLOCKIP = 1073741824;
literal CLUB$M_QTQEBSY = -2147483648;
literal CLUB$M_LK_MERGEIP = 4;
literal CLUB$M_LK_DO_FULL = 8;
literal CLUB$M_LK_FULL = 16;
literal CLUB$M_LK_DO_DIR = 32;
literal CLUB$M_LK_DIR = 64;
literal CLUB$M_LK_NO_RMVDIR = 128;
literal CLUB$M_LK_INIT_RBLD = 256;
literal CLUB$M_LK_NO_RM = 512;
literal CLUB$M_LK_TABLE_V51 = 1024;
literal CLUB$M_LK_SPECIAL_1 = 2048;
literal CLUB$M_LK_RM_DSBL = 4096;
literal CLUB$M_LK_TABLE_1 = 8192;
literal CLUB$M_LK_SHUTDOWN = 16384;
literal CLUB$M_LK_SHUT_IP = 32768;
literal CLUB$M_NO_FQUORUM = 1;
literal CLUB$M_NO_DQUORUM = 2;
literal CLUB$M_IFW_REQ = 4;
literal CLUB$M_RNS_REQ = 8;
literal CLUB$M_CLUGEN_VALID = 1;
literal CLUB$C_LENGTH = 532;            !  LENGTH OF CLUB 
literal CLUB$K_LENGTH = 532;            !  LENGTH OF CLUB 
literal CLUB$S_CLUBDEF = 532;
macro CLUB$L_CSBQFL = 0,0,32,0 %;       !  CSB QUEUE FORWARD LINK
macro CLUB$L_CSBQBL = 4,0,32,0 %;       !  CSB QUEUE BACKWARD LINK
macro CLUB$W_SIZE = 8,0,16,0 %;         !  SIZE OF CLUB IN BYTES
macro CLUB$B_TYPE = 10,0,8,0 %;         !  STRUCTURE TYPE 
macro CLUB$B_SUBTYPE = 11,0,8,0 %;      !  STRUCTURE SUBTYPE
macro CLUB$L_POLL_CTX = 12,0,32,0 %;    !  SCS POLLER CONTEXT
macro CLUB$L_LOCAL_CSB = 16,0,32,0 %;   !  ADDRESS OF THE CSB FOR LOCAL SYSTEM
macro CLUB$L_ASTQFL = 20,0,32,0 %;      !  AST QUEUE FORWARD LINK
macro CLUB$L_ASTQBL = 24,0,32,0 %;      !  AST QUEUE BACKWARD LINK
macro CLUB$L_FLAGS = 28,0,32,0 %;       !  CLUSTER STATUS FLAGS
macro CLUB$V_CLUSTER = 28,0,1,0 %;      !   THIS NODE IS MEMBER OF CLUSTER
macro CLUB$V_QF_ACTIVE = 28,1,1,0 %;    !   QUORUM FILE IS READABLE, CONTRIBUTE TO STATIC QUORUM
macro CLUB$V_QF_DYNVOTE = 28,2,1,0 %;   !   QUORUM FILE CAN CONTRIBUTE TO DYNAMIC QUORUM
macro CLUB$V_QF_WATCHER = 28,3,1,0 %;   !   NODE IS QUORUM FILE WATCHER
macro CLUB$V_SHUTDOWN = 28,4,1,0 %;     !   NODE READY FOR CLUSTER SHUTDOWN
macro CLUB$V_QF_REFRESH_REQ = 28,5,1,0 %; !   QUORUM FILE REFRESH REQUESTED
macro CLUB$V_STS_PPHASE = 28,8,1,0 %;   !   STATUS ANALYZER POLLING PHASE
macro CLUB$V_STS_PH0 = 28,9,1,0 %;      !   STATUS ANALYZER, PHASE 0 SEEN
macro CLUB$V_STS_PH1B = 28,10,1,0 %;    !   STATUS ANALYZER, PHASE 1 (COORD CNX BROKEN) SEEN
macro CLUB$V_STS_PH1 = 28,11,1,0 %;     !   STATUS ANALYZER, PHASE 1 (COORD CNX OK) SEEN
macro CLUB$V_STS_PH2 = 28,12,1,0 %;     !   STATUS ANALYZER, PHASE 2 SEEN
macro CLUB$V_FKB_BUSY = 28,16,1,0 %;    !   FORK BLOCK IN USE
macro CLUB$V_UNLOCK = 28,17,1,0 %;      !   UNLOCK REQUESTED
macro CLUB$V_NO_FORM = 28,18,1,0 %;     !   PROHIBIT NODE FROM FORMING A NEW CLUSTER
macro CLUB$V_INIT = 28,19,1,0 %;        !   READY FOR CLUSTER JOIN/FORMATION
macro CLUB$V_BACKOUT = 28,20,1,0 %;     !   MUST EVENTUALLY BACK-OUT TRANSITION
macro CLUB$V_PRIOR_PROTOCOL = 28,21,1,0 %; !   Earlier version protocol present 
macro CLUB$V_VERBOSE = 28,22,1,0 %;     !   VERBOSE MODE
macro CLUB$V_LOST_CNX = 28,23,1,0 %;    !   CONNECTION TO CLUSTER MEMBER HAS BEEN LOST
macro CLUB$V_QF_FAILED_NODE = 28,24,1,0 %; !   A NODE HAS BEEN FAILED OUT
macro CLUB$V_QF_VOTE = 28,25,1,0 %;     !   QUORUM DISK IS CONTRIBUTING A (STATIC) VOTE
macro CLUB$V_QF_NEWVOTE = 28,26,1,0 %;  !   STAGING FOR QF_VOTE
macro CLUB$V_ADJ_QUORUM = 28,27,1,0 %;  !   QUORUM ADJUSTMENT REQUESTED
macro CLUB$V_QUORUM = 28,28,1,0 %;      !   CLUSTER IS IN QUORUM
macro CLUB$V_TRANSITION = 28,29,1,0 %;  !   STATE TRANSITION IN PROGRESS
macro CLUB$V_RESLOCKIP = 28,30,1,0 %;   !   RESERVATION LOCK IN PROGRESS
macro CLUB$V_QTQEBSY = 28,31,1,0 %;     !   QUORUM TQE IS ALREADY IN QUE
macro CLUB$L_LK_FLAGS = 32,0,32,0 %;
macro CLUB$V_LK_MERGEIP = 32,2,1,0 %;   !   MERGE IN PROGRESS (LOCAL)
macro CLUB$V_LK_DO_FULL = 32,3,1,0 %;   !   DO A FULL REBUILD
macro CLUB$V_LK_FULL = 32,4,1,0 %;      !   FULL REBUILD
macro CLUB$V_LK_DO_DIR = 32,5,1,0 %;    !   DO A DIRECTORY REBUILD
macro CLUB$V_LK_DIR = 32,6,1,0 %;       !   DIRECTORY REBUILD
macro CLUB$V_LK_NO_RMVDIR = 32,7,1,0 %; !   INHIBIT RMVDIRS
macro CLUB$V_LK_INIT_RBLD = 32,8,1,0 %; !   INITIAL REBUILD FLAG
macro CLUB$V_LK_NO_RM = 32,9,1,0 %;     !   (obsolete)
macro CLUB$V_LK_TABLE_V51 = 32,10,1,0 %; !   (obsolete)
macro CLUB$V_LK_SPECIAL_1 = 32,11,1,0 %; !   (obsolete)
macro CLUB$V_LK_RM_DSBL = 32,12,1,0 %;  !   REMASTER DISABLED DUE TO REBUILD
macro CLUB$V_LK_TABLE_1 = 32,13,1,0 %;  !   FAILOVER TABLE 1 IN USE
macro CLUB$V_LK_SHUTDOWN = 32,14,1,0 %; !   SHUTDOWN REQUESTED
macro CLUB$V_LK_SHUT_IP = 32,15,1,0 %;  !   SHUTDOWN IN PROGRESS
macro CLUB$W_RSEQNUM = 36,0,16,0 %;     !   FULL REBUILD SEQUENCE NUMBER
macro CLUB$W_DIRSEQNUM = 38,0,16,0 %;   !   DIRECTORY REBUILD SEQ
macro CLUB$B_QSTATUS = 40,0,8,0 %;      !  QUORUM STATUS FLAGS
macro CLUB$V_NO_FQUORUM = 40,0,1,0 %;   !   NO FORMAL QUORUM
macro CLUB$V_NO_DQUORUM = 40,1,1,0 %;   !   NO DYNAMIC QUORUM
macro CLUB$V_IFW_REQ = 40,2,1,0 %;      !   INCARNATION FILE WRITE REQUIRED
macro CLUB$V_RNS_REQ = 40,3,1,0 %;      !   REMOVED NODE STATUS REQUIRED
macro CLUB$W_QDVOTES = 42,0,16,0 %;     !  VOTES HELD BY QUORUM DISK
macro CLUB$W_QUORUM = 44,0,16,0 %;      !  CLUSTER QUORUM
macro CLUB$W_VOTES = 46,0,16,0 %;       !  CLUSTER VOTES
macro CLUB$W_CEVOTES = 48,0,16,0 %;     !  UNIVERSE OF VOTES
macro CLUB$W_ADJ_CEVOTES = 50,0,16,0 %; !  UNIVERSE OF VOTES ADJUSTMENT REQUESTED VALUE
macro CLUB$W_NODES = 52,0,16,0 %;       !  NODES IN CLUSTER
macro CLUB$B_FSYSID = 54,0,0,1 %;
literal CLUB$S_FSYSID = 6;              !  FOUNDING NODE'S SYSID
macro CLUB$Q_FTIME = 60,0,0,0 %;
literal CLUB$S_FTIME = 8;               !  FOUNDING TIME
macro CLUB$L_LST_XTN = 68,0,32,0 %;     !  LAST COMPLETED TRANSACTION NUMBER
macro CLUB$L_LST_COORD = 72,0,32,0 %;   !  LAST COMPLETED TRANSACTION COORDINATOR CSID
macro CLUB$Q_LST_TIME = 76,0,0,0 %;
literal CLUB$S_LST_TIME = 8;            !  LAST COMPLETED TRANSACTION TIME-STAMP
macro CLUB$B_LST_CODE = 84,0,8,0 %;     !  LAST COMPLETED TRANSACTION CODE
macro CLUB$B_LST_PHASE = 85,0,8,0 %;    !  LAST COMPLETED TRANSACTION CODE
macro CLUB$W_NEWQDVOTES = 86,0,16,0 %;  !  STAGING FOR QDVOTES
macro CLUB$L_CUR_XTN = 88,0,32,0 %;     !  CURRENT TRANSACTION NUMBER
macro CLUB$L_CUR_COORD = 92,0,32,0 %;   !  CURRENT TRANSACTION COORDINATOR CSID
macro CLUB$Q_CUR_TIME = 96,0,0,0 %;
literal CLUB$S_CUR_TIME = 8;            !  CURRENT TRANSACTION TIME-STAMP
macro CLUB$B_CUR_CODE = 104,0,8,0 %;    !  TRANSACTION CODE
macro CLUB$B_CUR_PHASE = 105,0,8,0 %;   !  TRANSACTION PHASE
macro CLUB$W_MSGCNT = 106,0,16,0 %;     !  OUTSTANDING/WAITING MESSAGE COUNT
macro CLUB$L_COORD = 108,0,32,0 %;      !  COORDINATOR'S CSB ADDRESS
macro CLUB$L_LOCAL_CSID = 112,0,32,0 %; !  LOCAL SYSTEM CSID
macro CLUB$W_LOCAL_CSID_IDX = 112,0,16,0 %; !  SLOT INDEX
macro CLUB$W_LOCAL_CSID_SEQ = 114,0,16,0 %; !  SEQUENCE NUMBER
macro CLUB$W_NEXT_CSID = 116,0,16,0 %;  !  INDEX OF NEXT CSID TO ASSIGN
macro CLUB$W_FIRST_INDEX = 118,0,16,0 %; !  INDEX OF FIRST CSID ASSIGNED
macro CLUB$L_MAX_XTN = 120,0,32,0 %;    !  LARGEST TRANSACTION ID SEEN
macro CLUB$L_RETRYCNT = 124,0,32,0 %;   !  RESOURCE ALLOCATION RETRIES AVAILABLE
macro CLUB$L_CTX0 = 128,0,32,0 %;       !  LEVEL 0 CONTEXT AREA
macro CLUB$L_RET1 = 132,0,32,0 %;       !  LEVEL 1 SUBROUTINE RETURN
macro CLUB$L_CTX1 = 136,0,32,0 %;       !  LEVEL 1 CONTEXT AREA
macro CLUB$L_RET2 = 140,0,32,0 %;       !  LEVEL 2 SUBROUTINE RETURN
macro CLUB$L_CTX2 = 144,0,32,0 %;       !  LEVEL 2 CONTEXT AREA
macro CLUB$L_TQE = 148,0,32,0 %;        !  ADDRESS OF TIMER ENTRY
macro CLUB$L_CSPIPID = 152,0,32,0 %;    !  PID OF CLUSTER SERVER (FOR SCH$WAKE)
macro CLUB$Q_NEWTIME = 156,0,0,0 %;
literal CLUB$S_NEWTIME = 8;             !  NEW VALUE OF TIME
macro CLUB$Q_NEWTIME_REF = 164,0,0,0 %;
literal CLUB$S_NEWTIME_REF = 8;         !  LOCAL REFERENCE FOR NEW TIME
macro CLUB$W_NEWQUORUM = 172,0,16,0 %;  !  NEW VALUE FOR QUORUM
macro CLUB$W_NEWCEVOTES = 174,0,16,0 %; !  NEW UNIVERSE OF VOTES 
macro CLUB$L_FMERIT = 176,0,32,0 %;     !  FIGURE OF MERIT FOR OPTIMAL CLUSTER
macro CLUB$L_E_MEMSEQ = 180,0,32,0 %;   !  EXTENDED MEMBERSHIP STATE SEQUENCE NUMBER
macro CLUB$W_MEMSEQ = 180,0,16,0 %;     !  MEMBERSHIP STATE SEQUENCE NUMBER
macro CLUB$L_RANDOM = 184,0,32,0 %;     !  RANDOM NUMBER GENERATOR CONTEXT
macro CLUB$L_CLUDCB = 188,0,32,0 %;     !  ADDRESS OF QUORUM DISK CONTROL BLOCK
macro CLUB$T_QDNAME = 192,0,0,0 %;
literal CLUB$S_QDNAME = 16;             !  QUORUM DISK FULLDEVNAM
macro CLUB$L_CLUICB = 208,0,32,0 %;     !  ADDRESS OF INCARNATION FILE CONTROL BLOCK
macro CLUB$L_FOREIGN_CLUSTER = 212,0,32,0 %; !  SHIFT REGISTER INDICATING FOREIGN CLUSTER SEEN
macro CLUB$L_ENBL_VERBOSE = 216,0,32,0 %; !  TIME TO ENABLE VERBOSE MODE
macro CLUB$L_QLOST_CLUGEN = 220,0,32,0 %; !  CLUSTER GENERATION WHEN QUORUM LOST
macro CLUB$L_STG_JOIN_CLUGEN = 224,0,32,0 %; !  STAGING AREA FOR CLUSTER GENERATION
macro CLUB$L_JOIN_CLUGEN = 228,0,32,0 %; !  JOINING NODE'S LAST CLUSTER GENERATION NUMBER
macro CLUB$W_STG_JOIN_FLAGS = 232,0,16,0 %; !  STAGING AREA FOR JOIN FLAGS
macro CLUB$W_JOIN_FLAGS = 234,0,16,0 %; !  JOINING NODE'S FLAGS
macro CLUB$V_CLUGEN_VALID = 234,0,1,0 %; !   GENERATION DATA FIELDS VALID
macro CLUB$Q_CSPQ = 240,0,0,0 %;
literal CLUB$S_CSPQ = 8;                !  QUEUE FOR COMMUNICATION WITH CSP
macro CLUB$B_FORK_BLOCK = 248,0,0,1 %;
literal CLUB$S_FORK_BLOCK = 32;         !  FORK BLOCK TO WAIT IN (CLUBFKB SUB-STRUCTURE)
macro CLUB$B_NODEMAP = 280,0,0,1 %;
literal CLUB$S_NODEMAP = 32;            !  BITMAP OF ALL POSSIBLE NODES
macro CLUB$B_CLUFCB = 312,0,0,1 %;
literal CLUB$S_CLUFCB = 112;            !  CLUSTER FAILOVER CONTROL BLOCK
macro CLUB$B_HANG_FKB = 424,0,0,1 %;
literal CLUB$S_HANG_FKB = 24;           !  FORK BLOCK TO USE TO BLOCK ACTIVITY AT IPL 4
macro CLUB$B_CLUBPWF = 448,0,0,1 %;
literal CLUB$S_CLUBPWF = 28;            !  FORK BLOCK TO USE DURING POWER RECOVERY
!  New cells located at end to minimize rebuiding.  Should be moved someday.
macro CLUB$L_RESLOCKTMO = 476,0,32,0 %; !  RESERVATION EXPIRATION TIME
macro CLUB$L_RESLOCKCSID = 480,0,32,0 %; !  CSID OF RESERVATION HOLDER
macro CLUB$L_LOCKTIME = 484,0,32,0 %;   !  TIME LOCKED
macro CLUB$W_MERGE_CNT = 488,0,16,0 %;  !  MERGE COUNTER
macro CLUB$W_PARSEQNUM = 490,0,16,0 %;  !  PARTIAL REBUILD SEQUENCE NUMBER
macro CLUB$B_NEWRBLD_REQ = 492,0,8,0 %; !  PROPOSED REBUILD REQUEST
macro CLUB$B_RBLD_CLU = 493,0,8,0 %;    !  REBUILD IN PROGRESS IN CLUSTER
macro CLUB$B_RBLD_LOC = 494,0,8,0 %;    !  REBUILD IN PROGRESS ON LOCAL NODE
macro CLUB$L_CLURCBFL = 496,0,32,0 %;   !  ACTIVE RCBs
macro CLUB$L_CLURCBBL = 500,0,32,0 %;   ! 
macro CLUB$W_RBLD_INHIB = 504,0,16,0 %; !  REASONS TO INHIBIT A LOCK REBUILD
macro CLUB$B_RM_QUOTA = 506,0,8,0 %;    !  REMASTERING QUOTA
macro CLUB$W_NCNID = 508,0,16,0 %;      !  NEXT CLUSTER NODE ID
macro CLUB$W_NEWNCNID = 510,0,16,0 %;   !  NEW NEXT CLUSTER NODE ID
macro CLUB$L_TOFF = 512,0,32,0 %;       !  LOCKING OFF
macro CLUB$L_TON = 516,0,32,0 %;        !  LOCKING ON
macro CLUB$L_TBLS = 520,0,32,0 %;       !  TABLE START
macro CLUB$L_QTQE = 524,0,32,0 %;       !  POINTER TO QUORUM LOSS TQE
macro CLUB$L_SYNC_STEP = 528,0,32,0 %;  !  SYNC STEP COUNT (move to clurcb)
 
!*** MODULE $CLUDCBDEF ***
! +
!  CLUDCB - Cluster Quorum Disk Control Block
! -
literal CLUDCB$M_QS_REM_INA = 1;
literal CLUDCB$M_QS_REM_ACT = 2;
literal CLUDCB$M_QS_NOT_READY = 4;
literal CLUDCB$M_QS_READY = 8;
literal CLUDCB$M_QS_ACTIVE = 16;
literal CLUDCB$M_QS_CLUSTER = 32;
literal CLUDCB$M_QS_VOTE = 64;
literal CLUDCB$M_QF_INQTMO = 1;
literal CLUDCB$M_QF_INQIP = 2;
literal CLUDCB$M_QF_TIM = 4;
literal CLUDCB$M_QF_RIP = 8;
literal CLUDCB$M_QF_WIP = 16;
literal CLUDCB$M_QF_ERROR = 32;
literal CLUDCB$M_QF_FIRST_ERR = 64;
literal CLUDCB$M_QF_WRL_ERR = 128;
literal CLUDCB$M_QF_NOACCESS = 256;
literal CLUDCB$M_CSP_ACK = 1;
literal CLUDCB$M_CSP_LBN_VALID = 2;
literal CLUDCB$M_CSP_MVHELP = 4;
literal CLUDCB$K_F_LENGTH = 43;         !  Length of fixed portion of CLUDCB
literal CLUDCB$C_F_LENGTH = 43;         !  Length of fixed portion of CLUDCB
literal CLUDCB$K_LENGTH = 560;          !  Length of CLUDCB
literal CLUDCB$C_LENGTH = 560;          !  Length of CLUDCB
!  The quorum disk is specified with 4 sysgen parameters. DISK_QUORUM1
literal CLUDCB$S_DISK_QUORUM = 16;
literal CLUDCB$S_CLUDCB = 560;
macro CLUDCB$L_CLUDCBFL = 0,0,32,0 %;   !  Forward Link (not used)
macro CLUDCB$L_CLUDCBBL = 4,0,32,0 %;   !  Backward Link (not used)
macro CLUDCB$W_SIZE = 8,0,16,0 %;       !  Size of CLUDCB (bytes)
macro CLUDCB$B_TYPE = 10,0,8,0 %;       !  Structure type
macro CLUDCB$B_SUBTYPE = 11,0,8,0 %;    !  Structure subtype
macro CLUDCB$L_UCB = 12,0,32,0 %;       !  Address of quorum disk UCB
macro CLUDCB$L_IRP = 16,0,32,0 %;       !  Address of IRP
macro CLUDCB$L_TQE = 20,0,32,0 %;       !  Address of timer queue entry
macro CLUDCB$L_WATCHER_CSID = 24,0,32,0 %; !  CSID of quorum file watcher
macro CLUDCB$L_ACT_COUNT = 28,0,32,0 %; !  Saved activity counter
macro CLUDCB$L_QFLBN = 32,0,32,0 %;     !  Quorum file logical block number
macro CLUDCB$W_STATE = 36,0,16,0 %;     !  Quorum disk state bits
macro CLUDCB$V_QS_REM_INA = 36,0,1,0 %; !  Remote inactive
macro CLUDCB$V_QS_REM_ACT = 36,1,1,0 %; !  Remote active
macro CLUDCB$V_QS_NOT_READY = 36,2,1,0 %; !  Not ready
macro CLUDCB$V_QS_READY = 36,3,1,0 %;   !  Ready
macro CLUDCB$V_QS_ACTIVE = 36,4,1,0 %;  !  Active
macro CLUDCB$V_QS_CLUSTER = 36,5,1,0 %; !  Active and this node is a cluster member
macro CLUDCB$V_QS_VOTE = 36,6,1,0 %;    !  Potential vote
macro CLUDCB$W_FLAGS = 38,0,16,0 %;     !  CLUDCB status bits
macro CLUDCB$V_QF_INQTMO = 38,0,1,0 %;  !  Status inquiry timed out
macro CLUDCB$V_QF_INQIP = 38,1,1,0 %;   !  Remote inquiry in progress
macro CLUDCB$V_QF_TIM = 38,2,1,0 %;     !  Read or write timed out
macro CLUDCB$V_QF_RIP = 38,3,1,0 %;     !  Read in progress
macro CLUDCB$V_QF_WIP = 38,4,1,0 %;     !  Write in progress
macro CLUDCB$V_QF_ERROR = 38,5,1,0 %;   !  Quorum disk error has been reported
macro CLUDCB$V_QF_FIRST_ERR = 38,6,1,0 %; !  First error has already been seen
macro CLUDCB$V_QF_WRL_ERR = 38,7,1,0 %; !  Quorum disk is write-locked
macro CLUDCB$V_QF_NOACCESS = 38,8,1,0 %; !  Never access the quorum disk directly
macro CLUDCB$W_CSP_FLAGS = 40,0,16,0 %; !  Flags for interlocked communication with CSP
macro CLUDCB$V_CSP_ACK = 40,0,1,0 %;    !  CSP request has been acknowledged
macro CLUDCB$V_CSP_LBN_VALID = 40,1,1,0 %; !  CSP has found a quorum file
macro CLUDCB$V_CSP_MVHELP = 40,2,1,0 %; !  Restart mount verification 
macro CLUDCB$B_COUNTER = 42,0,8,0 %;    !  Iteration counter
macro CLUDCB$T_BUFFER = 44,0,0,0 %;
literal CLUDCB$S_BUFFER = 516;          !  Quorum file buffer
!  to DISK_QUORUM4. Each parameter can specify 4 bytes.
 
!*** MODULE $CLUICBDEF ***
! +
!  CLUICB - Incarnation File Control Block
! -
literal CLUICB$M_WIP = 1;
literal CLUICB$M_WREQ = 2;
literal CLUICB$K_F_LENGTH = 24;         !  Length of fixed portion
literal CLUICB$C_F_LENGTH = 24;         !  Length of fixed portion
!  End of fixed portion of the block
literal CLUICB$T_BUFFER = 24;           !  Start of incarnation
!   file buffer area
literal CLUICB$S_CLUICB = 24;
!  Fixed portion
macro CLUICB$L_FL = 0,0,32,0 %;         !  Forward Link
macro CLUICB$L_BL = 4,0,32,0 %;         !  Backward Link
macro CLUICB$W_SIZE = 8,0,16,0 %;       !  Size of block
macro CLUICB$B_TYPE = 10,0,8,0 %;       !  Structure type
macro CLUICB$B_SUBTYPE = 11,0,8,0 %;    !  Structure subtype
macro CLUICB$L_IRP = 12,0,32,0 %;       !  Address of IRP
macro CLUICB$L_LBN = 16,0,32,0 %;       !  Incarnation file logical block number
macro CLUICB$W_WIP_CNT = 20,0,16,0 %;   !  Write-in-progress counter
macro CLUICB$W_FLAGS = 22,0,16,0 %;     !  Flags
macro CLUICB$V_WIP = 22,0,1,0 %;        !  Write-in-progress bit 
macro CLUICB$V_WREQ = 22,1,1,0 %;       !  Write requested bit
 
!*** MODULE $CLUOPTDEF ***
! +
!  CLUOPT - Cluster Optimal ReConfiguration Context Block
! -
literal CLUOPT$K_LENGTH = 116;          !  Length of CLUOPT
literal CLUOPT$C_LENGTH = 116;          !  Length of CLUOPT
literal CLUOPT$S_CLUOPT = 116;
macro CLUOPT$L_PREV = 0,0,32,0 %;       !  Link to previous CLUOPT block
macro CLUOPT$W_SIZE = 8,0,16,0 %;       !  Size of CLUOPT (bytes)
macro CLUOPT$B_TYPE = 10,0,8,0 %;       !  Structure type
macro CLUOPT$B_SUBTYPE = 11,0,8,0 %;    !  Structure subtype
macro CLUOPT$L_CMERIT = 12,0,32,0 %;    !  Figure of merit of nodes in CMAP
macro CLUOPT$L_ACMERIT = 16,0,32,0 %;   !  Figure of merit of nodes in AMAP + CMAP
macro CLUOPT$B_CMAP = 20,0,0,1 %;
literal CLUOPT$S_CMAP = 32;             !  Map of nodes in proposed cluster
macro CLUOPT$B_AMAP = 52,0,0,1 %;
literal CLUOPT$S_AMAP = 32;             !  Map of nodes available for cluster
macro CLUOPT$B_RMAP = 84,0,0,1 %;
literal CLUOPT$S_RMAP = 32;             !  Map of nodes remaining for consideration
 
!*** MODULE $CLUPBDEF ***
! +
!  CLUPB - PARALLEL CONTEXT BLOCK
! 
! -
literal CLUPB$M_BUSY = 1;
literal CLUPB$K_FIX_LENGTH = 44;
!   Optional extensions for user's of the service
literal CLUPB$K_RBLD_LENGTH = 64;
literal CLUPB$K_LENGTH = 64;            ! LENGTH
literal CLUPB$C_LENGTH = 64;            ! LENGTH
literal CLUPB$S_CLUPBDEF = 64;
!  This section reserved for the service itself
macro CLUPB$B_FORK_BLOCK = 0,0,0,1 %;
literal CLUPB$S_FORK_BLOCK = 24;        !  FORK BLOCK
macro CLUPB$W_FLAGS = 24,0,16,0 %;      !  STATUS FLAGS
macro CLUPB$V_BUSY = 24,0,1,0 %;
macro CLUPB$B_THREADS = 26,0,8,0 %;     !  ACTIVE THREADS
macro CLUPB$B_MAX_THREADS = 27,0,8,0 %; !  MAX ACTIVE THREADS
macro CLUPB$L_PARENT = 28,0,32,0 %;     !  PARENT CONTEXT BLOCK
!  This section filled in by user of service
macro CLUPB$L_ACTION = 32,0,32,0 %;     !  ACTION ROUTINE
macro CLUPB$L_CPLRTN = 36,0,32,0 %;     !  COMPLETION ROUTINE
macro CLUPB$L_CPLPRM = 40,0,32,0 %;     !  COMPLETION PARAMETER
!   Lock rebuild extensions
macro CLUPB$L_RTN1 = 44,0,32,0 %;       !  SAVED RETURN ADDRESS
macro CLUPB$L_RTRSB = 48,0,32,0 %;      !  ROOT RSB
macro CLUPB$L_RSB_LIST = 52,0,32,0 %;   !  RSB LIST ADDRESS
macro CLUPB$L_LKB_LIST = 56,0,32,0 %;   !  LKB LIST ADDRESS
macro CLUPB$B_QCNT = 60,0,8,0 %;        !  QUEUE COUNTER
!   Other extensions can go here
 
!*** MODULE $CLURCBDEF ***
! +
!  CLURCB - REMASTER CONTROL BLOCK
! 
! -
literal CLURCB$M_BUSY = 1;
literal CLURCB$M_FQ = 2;
literal CLURCB$M_EXP_DONE_VLD = 4;
literal CLURCB$M_QUOTA = 8;
literal CLURCB$M_OLDMST = 16;
literal CLURCB$M_EXPMSG = 32;
literal CLURCB$K_LENGTH = 228;          ! LENGTH OF CLURCB
literal CLURCB$C_LENGTH = 228;          ! LENGTH OF CLURCB
literal CLURCB$S_CLURCBDEF = 228;
macro CLURCB$L_CLURCBFL = 0,0,32,0 %;   !  FORWARD LINK
macro CLURCB$L_CLURCBBL = 4,0,32,0 %;   !  BACKWARD LINK
macro CLURCB$W_SIZE = 8,0,16,0 %;       !  SIZE IN BYTES
macro CLURCB$B_TYPE = 10,0,8,0 %;       !  STRUCTURE TYPE 
macro CLURCB$B_SUBTYPE = 11,0,8,0 %;    !  STRUCTURE SUBTYPE
macro CLURCB$B_FORK_BLOCK = 12,0,0,1 %;
literal CLURCB$S_FORK_BLOCK = 24;       !  FORK BLOCK TO WAIT IN
macro CLURCB$L_FLAGS = 36,0,32,0 %;     !  STATUS FLAGS
macro CLURCB$V_BUSY = 36,0,1,0 %;       !  Fork block in use
macro CLURCB$V_FQ = 36,1,1,0 %;         !  On fork queue
macro CLURCB$V_EXP_DONE_VLD = 36,2,1,0 %; !  Expected done count valid
macro CLURCB$V_QUOTA = 36,3,1,0 %;      !  Quota charged
macro CLURCB$V_OLDMST = 36,4,1,0 %;     !  Old master
macro CLURCB$V_EXPMSG = 36,5,1,0 %;     !  Message expected
macro CLURCB$B_QCNT = 40,0,8,0 %;       !  LOCK QUEUE COUNTER
macro CLURCB$L_LKB_LIST = 44,0,32,0 %;  !  ADDRESS OF LKB LIST
macro CLURCB$L_RSB_LIST = 48,0,32,0 %;  !  ADDRESS OF RSB LIST
macro CLURCB$L_CNTX1 = 52,0,32,0 %;     !  CONTEXT STORAGE
macro CLURCB$L_CNTX2 = 56,0,32,0 %;     !  CONTEXT STORAGE
macro CLURCB$L_WAITRET = 60,0,32,0 %;   !  RETURN PC STORAGE
macro CLURCB$W_EXP_DONE = 64,0,16,0 %;  !  RBLD_DONES expected
macro CLURCB$W_RCV_DONE = 66,0,16,0 %;  !  RBLD_DONES received
macro CLURCB$W_RSEQNUM = 68,0,16,0 %;   !  FULL REBUILD SEQ NUM
macro CLURCB$W_PARSEQNUM = 70,0,16,0 %; !  PARTIAL REBUILD SEQ NUM
macro CLURCB$L_NEWMASTER = 72,0,32,0 %; !  NEW MASTER'S CSID
macro CLURCB$L_OLDMASTER = 76,0,32,0 %; !  OLD MASTER'S CSID
macro CLURCB$L_RSB = 80,0,32,0 %;       !  ADDRESS OF ROOT RSB
macro CLURCB$L_CLUB = 84,0,32,0 %;      !  ADDRESS OF CLUB
macro CLURCB$W_RESPCNT = 88,0,16,0 %;   !  EXPECTED RESPONSE COUNT
macro CLURCB$W_INDEX = 90,0,16,0 %;     !  MAP INDEX    
macro CLURCB$L_SAVRTN = 92,0,32,0 %;    !  SAVED RETURN ADDRESS
macro CLURCB$L_MSGBLD = 96,0,32,0 %;    !  MESSAGE BUILD ROUTINE
macro CLURCB$B_NODEMAP = 100,0,0,1 %;
literal CLURCB$S_NODEMAP = 32;          !  NODES TO REBUILD
macro CLURCB$B_SHUTMAP = 132,0,0,1 %;
literal CLURCB$S_SHUTMAP = 32;          !  NODES WITH TRAFFIC SHUTDOWN
macro CLURCB$B_ACKMAP = 164,0,0,1 %;
literal CLURCB$S_ACKMAP = 32;           !  NODES RETURNING ACKS
macro CLURCB$B_RESMAP = 196,0,0,1 %;
literal CLURCB$S_RESMAP = 32;           !  NODES NEEDING RESUMPTION
 
!*** MODULE $CONDEF ***
! +
! 
!  Console function codes (defined in SRM).
! 
! -
literal CON$C_SWDONE = 1;               !  Software done
literal CON$C_BOOTCPU = 2;              !  Boot function code
literal CON$C_CLRWARM = 3;              !  Clear warm start flag
literal CON$C_CLRCOLD = 4;              !  Clear cold start flag
! +
! 
!  Routine specifier codes used when calling CON$ASSIST_PSWITCH
! 
! -
literal CON$C_START_SWITCH = 1;         !  Start primary switch operation
literal CON$C_ABORT_SWITCH = 2;         !  Abort primary switch operation
literal CON$C_FINISH_SWITCH = 3;        !  Finish primary switch operation
literal RXCST$M_IE = 64;
literal RXCST$M_RDY = 128;
literal RXCST$S_RXCST = 1;
macro RXCST$V_IE = 0,6,1,0 %;           !  Receiver Interrupt Enable
macro RXCST$V_RDY = 0,7,1,0 %;          !  Receiver Data Ready
literal TXCST$M_IE = 64;
literal TXCST$M_RDY = 128;
literal TXCST$M_ERR = 32768;
literal TXCST$S_TXCST = 2;
macro TXCST$V_IE = 0,6,1,0 %;           !  Transmitter Interrupt Enable
macro TXCST$V_RDY = 0,7,1,0 %;          !  Transmitter Ready for Input
macro TXCST$V_ERR = 0,15,1,0 %;         !  Error sending, pls re-transmit
literal RXTX$M_ERR = 32768;
literal RXTX$S_RXTX = 2;
macro RXTX$V_DATA = 0,0,8,0 %;
literal RXTX$S_DATA = 8;                !  Data field of RXDB/TXDB
macro RXTX$V_ID = 0,8,4,0 %;
literal RXTX$S_ID = 4;                  !  ID field of RXDB/TXDB
macro RXTX$V_ERR = 0,15,1,0 %;          !  Error bit, RXDB only
 
!*** MODULE $CON9AQDEF ***
! 
!  Aquarius console function codes.
! 
literal CON9AQ$C_SFTWR_DONE = 1;        !  Software done
literal CON9AQ$C_COLD_STRT = 2;         !  Cold start system request
literal CON9AQ$C_CLR_WRMSTRT = 3;       !  Clear warm start flag
literal CON9AQ$C_CLR_CLDSTRT = 4;       !  Clear cold start flag
! +
! 
!  Routine specifier codes used when calling CON$ALLOC_DALLOC_BUF
! 
! -
literal CON9AQ$C_ALLOC_DMD = 1;         !  Allocate/initialize a DMD structure
literal CON9AQ$C_DEALLOC_DMD = 2;       !  Deallocate an existing DMD structure
literal CON9AQ$C_DEALLOC_LINK = 3;      !  Deallocate all structures for datalink(s)
! 
!  Fields in the RXCS IPR
! 
literal RXS$M_IE = 64;
literal RXS$M_DONE = 128;
literal RXS$M_DTR = 16711680;
literal RXS$M_CONSTERM = 65536;
literal RXS$M_REMPORT = 131072;
literal RXS$S_RXS = 6;
macro RXS$V_IE = 0,6,1,0 %;             !  Interrupt Enable
macro RXS$V_DONE = 0,7,1,0 %;           !  Done bit
macro RXS$V_DTR = 0,16,8,0 %;
literal RXS$S_DTR = 8;                  !  DTR field
macro RXS$V_CONSTERM = 3,16,1,0 %;      !  Console terminal DTR
macro RXS$V_REMPORT = 3,17,1,0 %;       !  Remote terminal DTR
! 
!  Fields in the TXCS IPR
! 
literal TXS$M_IE = 64;
literal TXS$M_RDY = 128;
literal TXS$M_ID = 3840;
literal TXS$M_WRTENA = 32768;
literal TXS$M_TEM = 16711680;
literal TXS$M_CONSTERM = 65536;
literal TXS$M_REMPORT = 131072;
literal TXS$S_TXS = 6;
macro TXS$V_IE = 0,6,1,0 %;             !  Interrupt Enable
macro TXS$V_RDY = 0,7,1,0 %;            !  Ready bit
macro TXS$V_ID = 0,8,4,0 %;
literal TXS$S_ID = 4;                   !  ID field
macro TXS$V_WRTENA = 0,15,1,0 %;        !  Write enable to mask
macro TXS$V_TEM = 0,16,8,0 %;
literal TXS$S_TEM = 8;                  !  Transmit enable mask
macro TXS$V_CONSTERM = 3,16,1,0 %;      !  Console terminal
macro TXS$V_REMPORT = 3,17,1,0 %;       !  Remote terminal
! 
!  Fields in the RXDB IPR
! 
literal RXD$M_DATA = 255;
literal RXD$M_ID = 3840;
literal RXD$M_ERR = 32768;
literal RXD$M_CARRIER = 16711680;
literal RXD$M_CONSTERM = 65536;
literal RXD$M_REMPORT = 131072;
literal RXD$M_CONSRETURN = 262144;
literal RXD$S_RXD = 6;
macro RXD$V_DATA = 0,0,8,0 %;
literal RXD$S_DATA = 8;                 !  Data field
macro RXD$V_ID = 0,8,4,0 %;
literal RXD$S_ID = 4;                   !  ID field
macro RXD$V_ERR = 0,15,1,0 %;           !  Receiver error bit
macro RXD$V_CARRIER = 0,16,8,0 %;
literal RXD$S_CARRIER = 8;              !  Carrier field
macro RXD$V_CONSTERM = 3,16,1,0 %;      !  Console terminal
macro RXD$V_REMPORT = 3,17,1,0 %;       !  Remote terminal
macro RXD$V_CONSRETURN = 3,18,1,0 %;    !  Console return indicator
! 
!  IDs returned in the RXDB and TXCS IPRs
! 
literal RXTX9AQ$C_ID_CONSTERM = 0;      !  OPA0 data
literal RXTX9AQ$C_ID_REMPORT = 1;       !  Remote port data
literal RXTX9AQ$C_ID_LOGCONS = 3;       !  Logical console
 
!*** MODULE $CPBDEF ***
! +
! 
!  Constants defining CPU capability numbers and flags for routines
! 
literal CPB$C_PRIMARY = 0;              !  Primary CPU (aka TIMEKEEPER)
literal CPB$C_NS = 1;                   !  future
literal CPB$C_QUORUM = 2;               !  Cluster quorum required
literal CPB$C_RUN = 3;                  !  Run capability
literal CPB$C_HARDAFF = 31;
literal CPB$C_MAX = 32;
literal CPB$C_VECTOR = 1;               !  equate NS with VECTOR
literal CPB$M_PRIMARY = 1;
literal CPB$M_VECTOR = 2;
literal CPB$M_QUORUM = 4;
literal CPB$M_RUN = 8;
literal CPB$M_IMPLICIT_AFFINITY = 1073741824;
literal CPB$M_EXPLICIT_AFFINITY = -2147483648;
literal CPB$S_CPBDEF = 4;
macro CPB$L_CPB = 0,0,32,0 %;
macro CPB$V_PRIMARY = 0,0,1,0 %;        !  Primary (timekeeper)
macro CPB$V_VECTOR = 0,1,1,0 %;         !  Vector processor
macro CPB$V_QUORUM = 0,2,1,0 %;         !  Cluster quorum required
macro CPB$V_RUN = 0,3,1,0 %;            !  CPU can run processes
macro CPB$V_IMPLICIT_AFFINITY = 0,30,1,0 %; !  Implicit affinity to a CPU
macro CPB$V_EXPLICIT_AFFINITY = 0,31,1,0 %; !  Explicit affinity to a CPU
literal CPB$M_FLAG_CHECK_CPU = 1;
literal CPB$M_FLAG_PERMANENT = 2;
literal CPB$M_FLAG_PRIMARY = 4;
literal CPB$S_CPB_FLAGSDEF = 1;
macro CPB$R_CPB_FLAGS = 0,0,8,0 %;
literal CPB$S_CPB_FLAGS = 1;
macro CPB$V_FLAG_CHECK_CPU = 0,0,1,0 %; !  Check that process can run
macro CPB$V_FLAG_PERMANENT = 0,1,1,0 %; !  Affect process permanent mask
macro CPB$V_FLAG_PRIMARY = 0,2,1,0 %;   !  Request to run on primary cpu
macro CPB$V_FLAG_FILLER = 0,3,3,0 %;
literal CPB$S_FLAG_FILLER = 3;          ! *** ADD ALL NEW BITFIELDS BEFORE THIS DECLARATION 
! *** THIS FIELD IS USED TO ASSURE MASKS ARE WITHIN RANGE
 
!*** MODULE $CPUDEF ***
! +
! 
!  Per-CPU Database definitions. The per-CPU database is page aligned. It is
!  also defined to have whole page length. There is one of these structures
!  for each CPU that is participating in multiprocessor execution of VMS.
! 
! -
literal CPU$C_RESERVED = 0;             !  Zero is reserved
literal CPU$C_INIT = 1;                 !  CPU is being INITialized
literal CPU$C_RUN = 2;                  !  CPU is RUNning
literal CPU$C_STOPPING = 3;             !  CPU is STOPping
literal CPU$C_STOPPED = 4;              !  CPU is STOPPED
literal CPU$C_TIMOUT = 5;               !  Boot of CPU timed out
literal CPU$C_BOOT_REJECTED = 6;        !  CPU refuses to join SMP
literal CPU$C_BOOTED = 7;               !  CPU booted - waiting for "go"
literal CPU$M_INV_TBS = 1;
literal CPU$M_INV_TBA = 2;
literal CPU$M_TBACK = 4;
literal CPU$M_BUGCHK = 8;
literal CPU$M_BUGCHKACK = 16;
literal CPU$M_RECALSCHD = 32;
literal CPU$M_UPDASTLVL = 64;
literal CPU$M_UPDTODR = 128;
literal CPU$M_WORK_FQP = 256;
literal CPU$M_QLOST = 512;
literal CPU$M_RESCHED = 1024;
literal CPU$M_VIRTCONS = 2048;
literal CPU$M_IOPOST = 4096;
literal CPU$M_INV_ISTREAM = 8192;
literal CPU$M_CPUFILL_1 = 268435455;
literal CPU$M_CPUSPEC1 = 268435456;
literal CPU$M_CPUSPEC2 = 536870912;
literal CPU$M_CPUSPEC3 = 1073741824;
literal CPU$M_CPUSPEC4 = -2147483648;
literal CPU$M_XNNFILL_1 = 268435455;
literal CPU$M_XNNSPEC1 = 268435456;
literal CPU$M_XNNSPEC2 = 536870912;
literal CPU$M_XNNSPEC3 = 1073741824;
literal CPU$M_XNNSPEC4 = -2147483648;
literal CPU$M_XSSFILL_1 = 268435455;
literal CPU$M_XSSSPEC1 = 268435456;
literal CPU$M_XSSSPEC2 = 536870912;
literal CPU$M_XSSSPEC3 = 1073741824;
literal CPU$M_XSSSPEC4 = -2147483648;
literal CPU$M_XCCFILL_1 = 268435455;
literal CPU$M_XCCSPEC1 = 268435456;
literal CPU$M_XCCSPEC2 = 536870912;
literal CPU$M_XCCSPEC3 = 1073741824;
literal CPU$M_XCCSPEC4 = -2147483648;
literal CPU$M_XRRFILL_1 = 268435455;
literal CPU$M_XRRSPEC1 = 268435456;
literal CPU$M_XRRSPEC2 = 536870912;
literal CPU$M_XRRSPEC3 = 1073741824;
literal CPU$M_XRRSPEC4 = -2147483648;
literal CPU$M_X9AQFILL_1 = 268435455;
literal CPU$M_X9AQSPEC1 = 268435456;
literal CPU$M_X9AQSPEC2 = 536870912;
literal CPU$M_X9AQSPEC3 = 1073741824;
literal CPU$M_X9AQSPEC4 = -2147483648;
literal CPU$M_X60FILL_1 = 268435455;
literal CPU$M_X60SPEC1 = 268435456;
literal CPU$M_X60SPEC2 = 536870912;
literal CPU$M_X60SPEC3 = 1073741824;
literal CPU$M_X60SPEC4 = -2147483648;
literal CPU$M_X1202FILL_1 = 268435455;
literal CPU$M_X1202SPEC1 = 268435456;
literal CPU$M_X1202SPEC2 = 536870912;
literal CPU$M_X1202SPEC3 = 1073741824;
literal CPU$M_X1202SPEC4 = -2147483648;
literal CPU$M_X1302FILL_1 = 268435455;
literal CPU$M_X1302SPEC1 = 268435456;
literal CPU$M_X1302SPEC2 = 536870912;
literal CPU$M_X1302SPEC3 = 1073741824;
literal CPU$M_X1302SPEC4 = -2147483648;
literal CPU$M_X1701FILL_1 = 268435455;
literal CPU$M_X1701SPEC1 = 268435456;
literal CPU$M_X1701SPEC2 = 536870912;
literal CPU$M_X1701SPEC3 = 1073741824;
literal CPU$M_X1701SPEC4 = -2147483648;
literal CPU$C_MAX_CPUS = 32;            !  Maximum number of CPUs supported
literal CPU$C_8NN_CPUS = 2;             !    Maximum NAUTILUS CPUs
literal CPU$C_8PS_CPUS = 4;             !    Maximum Polarstar CPUs
literal CPU$C_8SS_CPUS = 16;            !    Maximum SCORPIO CPUs
literal CPU$C_9CC_CPUS = 16;            !    Maximum CALYPSO/CVAX CPUs
literal CPU$C_9RR_CPUS = 16;            !    Maximum CALYPSO/XRP CPUs
literal CPU$C_9AQ_CPUS = 4;             !    Maximum AQUARIUS CPUs
literal CPU$C_60_CPUS = 32;             !    Maximum Firefox CPU number
literal CPU$C_1202_CPUS = 16;           !    Maximum Mariah CPU number
literal CPU$C_1302_CPUS = 16;           !    Maximum NVAX CPU number
literal CPU$C_1701_CPUS = 8;            !    Maximum Laser/Neon CPU number
literal CPU$K_PAGE0_LENGTH = 120;       !  Used bytes in page 0
literal CPU$C_PAGE0_LENGTH = 120;       !  Used bytes in page 0
literal CPU$K_NUM_SWIQS = 6;            !  Number of software interrupt queues
literal CPU$M_VP_POWERFAIL = 1;
literal CPU$M_VP_BUGCHECK = 2;
literal CPU$M_VP_CTX_INIT = 4;
literal CPU$M_VP_CTX_SAVE = 8;
literal CPU$M_VP_CTX_RESTORE = 16;
literal CPU$M_SCHED = 1;
literal CPU$M_FOREVER = 2;
literal CPU$M_NEWPRIM = 4;
literal CPU$M_PSWITCH = 8;
literal CPU$M_STOPPING = 1;
literal CPU$K_LENGTH = 852;             !  Total structure size
literal CPU$C_LENGTH = 852;             !  Total structure size
literal CPU$C_PAGECNT = 2;              !  Page count of database
literal CPU$C_STACK = 2048;             !  Offset to empty boot stack
literal CPU$S_CPUDEF = 852;
! ******************************************************************************
!  IMPORTANT NOTE:
! 
!  With some exceptions, the first page is reserved for those cells which
!  must be accessed with memory management disabled, e.g., initial boot 
!  sequence, power fail, and some types of error handling.
! 
! ******************************************************************************
macro CPU$T_CPUDEF_PAGE0 = 0,0,0,0 %;
literal CPU$S_CPUDEF_PAGE0 = 512;
macro CPU$L_CURPCB = 0,0,32,0 %;        !  Address of CPU's current PCB
macro CPU$L_REALSTACK = 4,0,32,0 %;     !  Physical address of boot stack
macro CPU$W_SIZE = 8,0,16,0 %;          !  Structure size
macro CPU$B_TYPE = 10,0,8,0 %;          !  Structure type
macro CPU$B_SUBTYPE = 11,0,8,0 %;       !  Structure subtype
macro CPU$B_BUSYWAIT = 12,0,8,0 %;      !  Concurrent busy wait count for CPU
macro CPU$B_STATE = 13,0,8,0 %;         !  State of this processor
macro CPU$B_CPUMTX = 14,0,8,0 %;        !  Count of CPUMTX acquires
macro CPU$B_CUR_PRI = 15,0,8,0 %;       !  Current Process Priority
macro CPU$L_INTSTK = 16,0,32,0 %;       !  Address of initial Interrupt Stack
macro CPU$R_WORK_REQ_OVERLAY = 20,0,32,0 %;
macro CPU$L_WORK_REQ = 20,0,32,0 %;     !  Work request bitmask
! 
!   Work request bits
! 
macro CPU$V_INV_TBS = 20,0,1,0 %;       !  Invalidate TB single
macro CPU$V_INV_TBA = 20,1,1,0 %;       !  Invalidate TB all
macro CPU$V_TBACK = 20,2,1,0 %;         !  Invalidate TB ACK     
macro CPU$V_BUGCHK = 20,3,1,0 %;        !  BUG_CHECK requested
macro CPU$V_BUGCHKACK = 20,4,1,0 %;     !  BUG_CHECK acked
macro CPU$V_RECALSCHD = 20,5,1,0 %;     !  Recalculate per cpu mask,reschedule
macro CPU$V_UPDASTLVL = 20,6,1,0 %;     !  Update ASTLVL register
macro CPU$V_UPDTODR = 20,7,1,0 %;       !  Update TODR register
macro CPU$V_WORK_FQP = 20,8,1,0 %;      !  Process work queue
macro CPU$V_QLOST = 20,9,1,0 %;         !  Stall until quorum regained
macro CPU$V_RESCHED = 20,10,1,0 %;      !  Issue IPL 3 SOFTINT
macro CPU$V_VIRTCONS = 20,11,1,0 %;     !  Enter virtual console mode (primary)
macro CPU$V_IOPOST = 20,12,1,0 %;       !  Issue IPL 4 SOFTINT
macro CPU$V_INV_ISTREAM = 20,13,1,0 %;  !  Invalidate instruction cache
! 
!  Define 4 CPU specific work request bits as bit #s 28-31. 
! 
macro CPU$R_CPUSPEC_OVERLAY = 20,0,32,0 %; !  CPU specific work requests
macro CPU$V_CPUSPEC1 = 20,28,1,0 %;     !  CPU specific
macro CPU$V_CPUSPEC2 = 20,29,1,0 %;     !  CPU specific
macro CPU$V_CPUSPEC3 = 20,30,1,0 %;     !  CPU specific
macro CPU$V_CPUSPEC4 = 20,31,1,0 %;     !  CPU specific
macro CPU$V_XNNSPEC1 = 20,28,1,0 %;     !  NAUTILUS specific
macro CPU$V_XNNSPEC2 = 20,29,1,0 %;     !  NAUTILUS specific
macro CPU$V_XNNSPEC3 = 20,30,1,0 %;     !  NAUTILUS specific
macro CPU$V_XNNSPEC4 = 20,31,1,0 %;     !  NAUTILUS specific
macro CPU$V_XSSSPEC1 = 20,28,1,0 %;     !  SCORPIO specific
macro CPU$V_XSSSPEC2 = 20,29,1,0 %;     !  SCORPIO specific
macro CPU$V_XSSSPEC3 = 20,30,1,0 %;     !  SCORPIO specific
macro CPU$V_XSSSPEC4 = 20,31,1,0 %;     !  SCORPIO specific
macro CPU$V_XCCSPEC1 = 20,28,1,0 %;     !  CALYPSO/CVAX specific
macro CPU$V_XCCSPEC2 = 20,29,1,0 %;     !  CALYPSO/CVAX specific
macro CPU$V_XCCSPEC3 = 20,30,1,0 %;     !  CALYPSO/CVAX specific
macro CPU$V_XCCSPEC4 = 20,31,1,0 %;     !  CALYPSO/CVAX specific
macro CPU$V_XRRSPEC1 = 20,28,1,0 %;     !  Calypso/Rigel specific
macro CPU$V_XRRSPEC2 = 20,29,1,0 %;     !  Calypso/Rigel specific
macro CPU$V_XRRSPEC3 = 20,30,1,0 %;     !  Calypso/Rigel specific
macro CPU$V_XRRSPEC4 = 20,31,1,0 %;     !  Calypso/Rigel specific
macro CPU$V_X9AQSPEC1 = 20,28,1,0 %;    !  AQUARIUS specific
macro CPU$V_X9AQSPEC2 = 20,29,1,0 %;    !  AQUARIUS specific
macro CPU$V_X9AQSPEC3 = 20,30,1,0 %;    !  AQUARIUS specific
macro CPU$V_X9AQSPEC4 = 20,31,1,0 %;    !  AQUARIUS specific
macro CPU$V_X60SPEC1 = 20,28,1,0 %;     !  Firefox specific
macro CPU$V_X60SPEC2 = 20,29,1,0 %;     !  Firefox specific
macro CPU$V_X60SPEC3 = 20,30,1,0 %;     !  Firefox specific
macro CPU$V_X60SPEC4 = 20,31,1,0 %;     !  Firefox specific
macro CPU$V_X1202SPEC1 = 20,28,1,0 %;   !  Mariah specific
macro CPU$V_X1202SPEC2 = 20,29,1,0 %;   !  Mariah specific
macro CPU$V_X1202SPEC3 = 20,30,1,0 %;   !  Mariah specific
macro CPU$V_X1202SPEC4 = 20,31,1,0 %;   !  Mariah specific
macro CPU$V_X1302SPEC1 = 20,28,1,0 %;   !  Nvax specific
macro CPU$V_X1302SPEC2 = 20,29,1,0 %;   !  Nvax specific
macro CPU$V_X1302SPEC3 = 20,30,1,0 %;   !  Nvax specific
macro CPU$V_X1302SPEC4 = 20,31,1,0 %;   !  Nvax specific
macro CPU$V_X1701SPEC1 = 20,28,1,0 %;   !  Nvax+ specific
macro CPU$V_X1701SPEC2 = 20,29,1,0 %;   !  Nvax+ specific
macro CPU$V_X1701SPEC3 = 20,30,1,0 %;   !  Nvax+ specific
macro CPU$V_X1701SPEC4 = 20,31,1,0 %;   !  Nvax+ specific
! 
macro CPU$L_PERCPUVA = 24,0,32,0 %;     !  VA of this per-CPU database
macro CPU$L_SAVED_AP = 28,0,32,0 %;     !  HALT Restart code
macro CPU$L_HALTPC = 32,0,32,0 %;       !  HALT PC for restart
macro CPU$L_HALTPSL = 36,0,32,0 %;      !  HALT PSL for restart
macro CPU$L_SAVED_ISP = 40,0,32,0 %;    !  Saved ISP for restart
macro CPU$L_PCBB = 44,0,32,0 %;         !  PCBB from powerdown
macro CPU$L_SCBB = 48,0,32,0 %;         !  SCBB from powerdown
macro CPU$L_SISR = 52,0,32,0 %;         !  SISR from powerdown
! 
!  The following 5 longwords are used by POWERFAIL and/or BUGCHECK code
! 
macro CPU$L_P0BR = 56,0,32,0 %;         !  P0 Base Register
macro CPU$L_P0LR = 60,0,32,0 %;         !  P0 Length Register
macro CPU$L_P1BR = 64,0,32,0 %;         !  P1 Base Register
macro CPU$L_P1LR = 68,0,32,0 %;         !  P1 Length Register
macro CPU$L_BUGCODE = 72,0,32,0 %;      !  BUGCHECK code
! 
!  The SYSTEM ID REGISTER (SID) must always be the first longword of the
!  CPU type-specific longwords in CPUDATA.  The BUGCHECK code depends upon it.
! 
macro CPU$B_CPUDATA = 76,0,0,0 %;
literal CPU$S_CPUDATA = 32;             !  Generic label for CPU data
macro CPU$L_SID = 76,0,32,0 %;          !  System ID register
! 
!  NAUTILUS specific offsets in CPUDATA block (8 longwords)
! 
macro CPU$L_8NN_SID = 76,0,32,0 %;      !    System ID register
macro CPU$L_8NN_REVR2 = 80,0,32,0 %;    !    REV LEVEL 2 register
macro CPU$L_8NN_SPARE = 84,0,32,0 %;    !    RESERVED
macro CPU$L_8NN_INFO = 88,0,32,0 %;     !    GET_CPU_INFO response
macro CPU$L_8NN_SPARE1 = 92,0,32,0 %;   !  Spare longword
macro CPU$L_8NN_SPARE2 = 96,0,32,0 %;   !  Spare longword
macro CPU$L_8NN_SPARE3 = 100,0,32,0 %;  !  Spare longword
macro CPU$L_8NN_SPARE4 = 104,0,32,0 %;  !  Spare longword
! 
!  SCORPIO specific offsets in CPUDATA block (8 longwords)
! 
macro CPU$L_8SS_SID = 76,0,32,0 %;      !    System ID register
macro CPU$W_8SS_BOOTCNT = 80,0,16,0 %;  !    Pending boot thread count
macro CPU$W_8SS_IPINTR = 82,0,16,0 %;   !    CPUs that may interrupt this CPU
macro CPU$L_8SS_BIWINDOW = 84,0,32,0 %; !    BI window virtual address
macro CPU$L_8SS_MPB = 88,0,32,0 %;      !    MPB ADDRESS
macro CPU$L_8SS_SPARE1 = 92,0,32,0 %;   !  Spare longword
macro CPU$L_8SS_SPARE2 = 96,0,32,0 %;   !  Spare longword
macro CPU$L_8SS_SPARE3 = 100,0,32,0 %;  !  Spare longword
macro CPU$L_8SS_SPARE4 = 104,0,32,0 %;  !  Spare longword
! 
!  CALYPSO/CVAX specific offsets in CPUDATA block (8 longwords)
! 
macro CPU$L_9CC_SID = 76,0,32,0 %;      !    System ID register
macro CPU$L_9CC_NODESPACE = 80,0,32,0 %; !  XMI nodespace address
macro CPU$L_9CC_MPB = 84,0,32,0 %;      !    MPB ADDRESS
macro CPU$L_9CC_XSID = 88,0,32,0 %;     !  Extended SID
macro CPU$L_9CC_SPARE1 = 92,0,32,0 %;   !  Spare longword
macro CPU$L_9CC_SPARE2 = 96,0,32,0 %;   !  Spare longword
macro CPU$L_9CC_SPARE3 = 100,0,32,0 %;  !  Spare longword
macro CPU$L_9CC_SPARE4 = 104,0,32,0 %;  !  Spare longword
! 
!  CALYPSO/XRP specific offsets in CPUDATA block (8 longwords)
! 
macro CPU$L_9RR_SID = 76,0,32,0 %;      !    System ID register
macro CPU$L_9RR_NODESPACE = 80,0,32,0 %; !  XMI nodespace address
macro CPU$L_9RR_MPB = 84,0,32,0 %;      !    MPB ADDRESS
macro CPU$L_9RR_XSID = 88,0,32,0 %;     !  Extended SID
macro CPU$L_9RR_SPARE1 = 92,0,32,0 %;   !  Spare longword
macro CPU$L_9RR_SPARE2 = 96,0,32,0 %;   !  Spare longword
macro CPU$L_9RR_SPARE3 = 100,0,32,0 %;  !  Spare longword
macro CPU$L_9RR_SPARE4 = 104,0,32,0 %;  !  Spare longword
! 
!  AQUARIUS specific offsets in CPUDATA block (8 longwords)
! 
macro CPU$L_9AQ_SID = 76,0,32,0 %;      !    System ID register
macro CPU$L_9AQ_SPARE0 = 80,0,32,0 %;   !  Spare longword
macro CPU$L_9AQ_SPARE1 = 84,0,32,0 %;   !  Spare longword
macro CPU$L_9AQ_SPARE2 = 88,0,32,0 %;   !  Spare longword
macro CPU$L_9AQ_CPUCNF = 92,0,32,0 %;   !  CPU Configuration
macro CPU$L_9AQ_SPARE3 = 96,0,32,0 %;   !  Spare longword
macro CPU$L_9AQ_SPARE4 = 100,0,32,0 %;  !  Spare longword
macro CPU$L_9AQ_SPARE5 = 104,0,32,0 %;  !  Spare longword
! 
!  Firefox specific offsets in CPUDATA block (8 longwords)
! 
macro CPU$L_60_SID = 76,0,32,0 %;       !   System ID register
macro CPU$L_60_NODESPACE = 80,0,32,0 %; !  MBUS nodespace address
macro CPU$L_60_MPB = 84,0,32,0 %;       !    MPB ADDRESS
macro CPU$L_60_XSID = 88,0,32,0 %;      !  Extended SID
macro CPU$L_60_SPARE1 = 92,0,32,0 %;    !  Spare longword
macro CPU$L_60_SPARE2 = 96,0,32,0 %;    !  Spare longword
macro CPU$L_60_SPARE3 = 100,0,32,0 %;   !  Spare longword
macro CPU$L_60_SPARE4 = 104,0,32,0 %;   !  Spare longword
! 
!  Mariah specific offsets in CPUDATA block (8 longwords)
! 
macro CPU$L_1202_SID = 76,0,32,0 %;     !   System ID register
macro CPU$L_1202_NODESPACE = 80,0,32,0 %; !  XMI-2 nodespace address
macro CPU$L_1202_MPB = 84,0,32,0 %;     !    MPB ADDRESS
macro CPU$L_1202_XSID = 88,0,32,0 %;    !  Extended SID
macro CPU$L_1202_SPARE1 = 92,0,32,0 %;  !  Spare longword
macro CPU$L_1202_SPARE2 = 96,0,32,0 %;  !  Spare longword
macro CPU$L_1202_SPARE3 = 100,0,32,0 %; !  Spare longword
macro CPU$L_1202_SPARE4 = 104,0,32,0 %; !  Spare longword
! 
!  Nvax specific offsets in CPUDATA block (8 longwords)
! 
macro CPU$L_1302_SID = 76,0,32,0 %;     !   System ID register
macro CPU$L_1302_NODESPACE = 80,0,32,0 %; !  XMI-2 nodespace address
macro CPU$L_1302_MPB = 84,0,32,0 %;     !    MPB ADDRESS
macro CPU$L_1302_XSID = 88,0,32,0 %;    !  Extended SID
macro CPU$L_1302_SPARE1 = 92,0,32,0 %;  !  Spare longword
macro CPU$L_1302_SPARE2 = 96,0,32,0 %;  !  Spare longword
macro CPU$L_1302_SPARE3 = 100,0,32,0 %; !  Spare longword
macro CPU$L_1302_SPARE4 = 104,0,32,0 %; !  Spare longword
! 
!  Nvax+ specific offsets in CPUDATA block (8 longwords)
! 
macro CPU$L_1701_SID = 76,0,32,0 %;     !  System ID register
macro CPU$L_1701_NODESPACE = 80,0,32,0 %; !  LSB nodespace address
macro CPU$L_1701_MPB = 84,0,32,0 %;     !  MPB Address
macro CPU$L_1701_XSID = 88,0,32,0 %;    !  Extended SID
macro CPU$L_1701_SPARE1 = 92,0,32,0 %;  !  Spare longword
macro CPU$L_1701_SPARE2 = 96,0,32,0 %;  !  Spare longword
macro CPU$L_1701_SPARE3 = 100,0,32,0 %; !  Spare longword
macro CPU$L_1701_SPARE4 = 104,0,32,0 %; !  Spare longword
! 
!  Define cells for machine check recovery block. These two longwords  
!  are assumed to be adjacent.
! 
macro CPU$L_MCHK_MASK = 108,0,32,0 %;   !  Function mask for current recovery block
macro CPU$L_MCHK_SP = 112,0,32,0 %;     !  Saved SP for return at end of block
!  0 (zero) if no current recovery block
! 
macro CPU$L_P0PT_PAGE = 116,0,32,0 %;   !  SVA of page reserved to this CPU to be
!   used as a P0 page table page when memory
!   management is being enabled.
! 
! *****************************************************************************
!  IMPORTANT NOTE:
! 
!  Any cells after this point MUST NOT be accessed using physical addressing.
!   
! *****************************************************************************
! 
!  The following structures are placed at the beginning of the 2nd page to
!  guarantee that they are at least quadword aligned.
!                                                 
macro CPU$Q_SWIQFL = 512,0,0,0 %;
literal CPU$S_SWIQFL = 48;              !  Software interrupt queues
macro CPU$L_PSFL = 560,0,32,0 %;        !  POST QUEUE forward link
macro CPU$L_PSBL = 564,0,32,0 %;        !  POST QUEUE backward link
! 
!  (still quadword aligned from above)
! 
macro CPU$Q_WORK_FQFL = 568,0,0,0 %;
literal CPU$S_WORK_FQFL = 8;            !  Work packet queue
macro CPU$Q_WORK_IFQ = 568,0,0,0 %;
literal CPU$S_WORK_IFQ = 8;             !  Work packet queue
! 
!  The following fork block is used to stall when quorum is lost
!  (still quadword aligned from above)
! 
macro CPU$L_QLOST_FQFL = 576,0,32,0 %;  !  quorum loss fork queue flink
macro CPU$L_QLOST_FQBL = 580,0,32,0 %;  !  quorum loss fork queue blink
macro CPU$W_QLOST_SIZE = 584,0,16,0 %;  !  quorum loss fork block size
macro CPU$B_QLOST_TYPE = 586,0,8,0 %;   !  quorum loss fork block type
macro CPU$B_QLOST_FLCK = 587,0,8,0 %;   !  quorum loss fork lock
macro CPU$L_QLOST_FPC = 588,0,32,0 %;   !  quorum loss fork PC
macro CPU$L_QLOST_FR3 = 592,0,32,0 %;   !  quorum loss fork R3
macro CPU$L_QLOST_FR4 = 596,0,32,0 %;   !  quorum loss fork R4
! 
macro CPU$Q_BOOT_TIME = 600,0,0,0 %;
literal CPU$S_BOOT_TIME = 8;            !  System time this cpu booted
macro CPU$Q_CPUID_MASK = 608,0,0,0 %;
literal CPU$S_CPUID_MASK = 8;           !  CPU ID in bitmask form
macro CPU$L_CPUID_MASK = 608,0,32,0 %;
macro CPU$L_PHY_CPUID = 616,0,32,0 %;   !  CPU ID number
macro CPU$L_CAPABILITY = 620,0,32,0 %;  !  bitmask of capabilities of this CPU
! 
!  Per-CPU delay weighting factors
! 
macro CPU$L_TENUSEC = 624,0,32,0 %;     !  Ten u-sec delay value
macro CPU$L_UBDELAY = 628,0,32,0 %;     !  UNIBUS delay counter
! 
!  Time counters defined as follows:
!  (Also applies to UKERNEL and UNULLCPU cells)
! 
!           KERNEL mode on KERNEL stack, no spinlock busywait active
!           EXECUTIVE mode
!           SUPERVISOR mode
!           USER mode
!           KERNEL mode on INTERRUPT stack
!           Compatibility mode
!           KERNEL mode on KERNEL or Interrupt stack, spinlock busywait is active
! 
!           NULL job counter
! 
macro CPU$L_KERNEL = 632,0,0,0 %;
literal CPU$S_KERNEL = 28;              !  Clock ticks in each mode
macro CPU$L_MPSYNCH = 656,0,32,0 %;     !  Clock ticks in MP synchron.
macro CPU$L_NULLCPU = 660,0,32,0 %;     !  Clock ticks in null job
macro CPU$W_UKERNEL = 664,0,0,0 %;
literal CPU$S_UKERNEL = 14;             !  # clock tics left to reach 10 ms in each mode
macro CPU$W_UNULLCPU = 678,0,16,0 %;    !  # clock tics left to reach 10 ms in null job
macro CPU$W_CLKUTICS = 680,0,16,0 %;    !  # clock tics left to reach 10 ms for this CPU
!  (Only maintained if SMP configuration)
macro CPU$W_HARDAFF = 682,0,16,0 %;     !  Count of processes with
!   hard affinity for this CPU.
! 
!  Spinlock acquisition/release tracking and verification data
! 
macro CPU$L_RANK_VEC = 684,0,32,0 %;    !  Ranks of spinlocks currently held
macro CPU$L_IPL_VEC = 688,0,32,0 %;     !  IPL vector of held spinlocks
macro CPU$L_IPL_ARRAY = 692,0,0,1 %;
literal CPU$S_IPL_ARRAY = 128;          !  IPL counts of held spinlocks
! 
!  Cells for CPU sanity timer
! 
macro CPU$L_TPOINTER = 820,0,32,0 %;    !  Address of SANITY_TIMER of
!   CPU being watched
macro CPU$W_SANITY_TIMER = 824,0,16,0 %; !  # of sanity cycles before this CPU times out
macro CPU$W_SANITY_TICKS = 826,0,16,0 %; !  # of ticks until next sanity cycle
! 
!  Per-CPU structures for vector processing support
! 
macro CPU$L_VP_OWNER = 828,0,32,0 %;    !  PCB address of the vector consumer
macro CPU$L_VP_VARIANT_EXIT = 832,0,32,0 %; !  Disabled fault handler variant exit address
macro CPU$L_VP_FLAGS = 836,0,32,0 %;    !  Vector processing flags
macro CPU$V_VP_POWERFAIL = 836,0,1,0 %; !  Powerfail variant
macro CPU$V_VP_BUGCHECK = 836,1,1,0 %;  !  Bugcheck variant
macro CPU$V_VP_CTX_INIT = 836,2,1,0 %;  !  Vector context init in progress
macro CPU$V_VP_CTX_SAVE = 836,3,1,0 %;  !  Vector context save in progress
macro CPU$V_VP_CTX_RESTORE = 836,4,1,0 %; !  Vector context restore in progress
macro CPU$L_VP_CPUTIM = 840,0,32,0 %;   !  Clock ticks that a vector consumer is scheduled
macro CPU$B_FLAGS = 844,0,8,0 %;        !  Various flags
macro CPU$V_SCHED = 844,0,1,0 %;        !  Idle loop vying for SCHED
macro CPU$V_FOREVER = 844,1,1,0 %;      !  STOP/CPU with /FOREVER qualifier
macro CPU$V_NEWPRIM = 844,2,1,0 %;      !  Primary-to-be CPU
macro CPU$V_PSWITCH = 844,3,1,0 %;      !  Live primary switch requested by primary CPU
macro CPU$W_RESERVED = 845,0,16,0 %;    !  Reserved for future use
macro CPU$B_RESERVED = 847,0,8,0 %;     !  Reserved for future use
! 
!  The following field, INTFLAGS, must be longword aligned since it uses
!  interlocked instructions to access the bitfields.
! 
macro CPU$L_INTFLAGS = 848,0,32,0 %;    !  Interlocked flags
macro CPU$V_STOPPING = 848,0,1,0 %;     !  CPU stopping flag
literal CPUDB$K_LENGTH = 12;            ! Length of structure
!  at negative offset.
literal CPUDB$S_CPUDB = 16;
macro CPUDB$L_CPUCNF = -12,0,32,0 %;    !  System configuration before
!   powerfailure
macro CPUDB$L_RESTART_PRIMARY = -8,0,32,0 %; !  Physical address of RESTART
!  PRIMARY CPU routine in
!  OPDRVxxx
macro CPUDB$L_PRIMID = -4,0,32,0 %;     !  Primary CPU's node id
macro CPUDB$L_VECTOR = 0,0,32,0 %;      !  Reference point for negative
!  offsets.
 
!*** MODULE $CQBICDEF ***
! ++
! 	CQBIC definitions
! --
!  Offsets within page containing interprocessor doorbell registers
literal CQBIC$W_INTPR0 = 320;           ! Arbiter doorbell
literal CQBIC$W_INTPR1 = 322;           ! Auxiliary #1 doorbell
literal CQBIC$W_INTPR2 = 324;           ! Auxiliary #2 doorbell
literal CQBIC$W_INTPR3 = 326;           ! Auxiliary #3 doorbell
literal CQBIC$W_INTPR4 = 328;           ! Auxiliary #4 doorbell
literal CQBIC$W_INTPR5 = 330;           ! Auxiliary #5 doorbell
literal CQBIC$W_INTPR6 = 332;           ! Auxiliary #6 doorbell
literal CQBIC$W_INTPR7 = 334;           ! Auxiliary #7 doorbell
!  Offsets within page containing SCR, memory and map registers
literal CQBIC$L_SCR = 0;                ! System configuration
literal CQBIC$L_DSER = 4;               ! DMA system error
literal CQBIC$L_MEAR = 8;               ! DMA master error
literal CQBIC$L_SEAR = 12;              ! DMA slave error
literal CQBIC$L_MAP_BASE = 16;          ! Scatter/gather map base
literal CQBIC$M_INTPR_DBIRQ = 1;
literal CQBIC$M_INTPR_LMEAE = 32;
literal CQBIC$M_INTPR_DBIIE = 64;
literal CQBIC$M_INTPR_AUXHLT = 256;
literal CQBIC$M_INTPR_TBIA = 16384;
literal CQBIC$M_INTPR_DMAQME = 32768;
literal CQBIC$S_INTPR = 2;
macro CQBIC$V_INTPR_DBIRQ = 0,0,1,0 %;  !  Doorbell interrupt request
macro CQBIC$V_INTPR_MBZ_1 = 0,1,4,0 %;
literal CQBIC$S_INTPR_MBZ_1 = 4;
macro CQBIC$V_INTPR_LMEAE = 0,5,1,0 %;  !  Local memory enable
macro CQBIC$V_INTPR_DBIIE = 0,6,1,0 %;  !  Doorbell interrupt enable
macro CQBIC$V_INTPR_MBZ_2 = 0,7,1,0 %;
macro CQBIC$V_INTPR_AUXHLT = 0,8,1,0 %; !  Auxiliary halt
macro CQBIC$V_INTPR_MBZ_3 = 0,9,5,0 %;
literal CQBIC$S_INTPR_MBZ_3 = 5;
macro CQBIC$V_INTPR_TBIA = 0,14,1,0 %;  !  Xlate buffer invalidate all
macro CQBIC$V_INTPR_DMAQME = 0,15,1,0 %; !  DMA memory space error
 
!*** MODULE $CRAMDEF ***
! +
!  CRAM - CSR Register Access Mailbox
! 
!  The CSR register access mailbox describes the remote I/O CSR access to be
!  performed.
! 
! -
literal CRAM$M_CRAM_IN_USE = 1;
literal CRAM$M_B = 1073741824;
literal CRAM$M_W = -2147483648;
literal CRAM$M_MBX_DONE = 1;
literal CRAM$M_MBX_ERROR = 2;
literal CRAM$K_LENGTH = 128;            !  Length of structure
!  Define common command indices
literal CRAMCMD$K_RDQUAD32 = 1;         !  Quadword read  in 32 bit space
literal CRAMCMD$K_RDLONG32 = 2;         !  Longword "     "  "  "   "
literal CRAMCMD$K_RDWORD32 = 3;         !  Word     "     "  "  "   "
literal CRAMCMD$K_RDBYTE32 = 4;         !  Byte     "     "  "  "   "
literal CRAMCMD$K_WTQUAD32 = 5;         !  Quadword write "  "  "   "
literal CRAMCMD$K_WTLONG32 = 6;         !  Longword "     "  "  "   "
literal CRAMCMD$K_WTWORD32 = 7;         !  Word     "     "  "  "   "
literal CRAMCMD$K_WTBYTE32 = 8;         !  Byte     "     "  "  "   "
literal CRAMCMD$K_RDQUAD64 = 9;         !  Quadword read  in 64 bit space
literal CRAMCMD$K_RDLONG64 = 10;        !  Longword "     "  "  "   "
literal CRAMCMD$K_RDWORD64 = 11;        !  Word     "     "  "  "   "
literal CRAMCMD$K_RDBYTE64 = 12;        !  Byte     "     "  "  "   "
literal CRAMCMD$K_WTQUAD64 = 13;        !  Quadword write "  "  "   "
literal CRAMCMD$K_WTLONG64 = 14;        !  Longword "     "  "  "   "
literal CRAMCMD$K_WTWORD64 = 15;        !  Word     "     "  "  "   "
literal CRAMCMD$K_WTBYTE64 = 16;        !  Byte     "     "  "  "   "
literal CRAMCMD$K_MININDEX = 1;
literal CRAMCMD$K_MAXINDEX = 16;
literal CRAM$S_CRAMDEF = 128;
macro CRAM$L_FLINK = 0,0,32,1 %;        !  Forward link
macro CRAM$L_BLINK = 4,0,32,1 %;        !  Backward link
macro CRAM$W_SIZE = 8,0,16,0 %;         !  Structure size in bytes
macro CRAM$B_TYPE = 10,0,8,0 %;         !  Structure type
macro CRAM$B_SUBTYPE = 11,0,8,0 %;      !  Structure subtype
macro CRAM$L_MBPR = 12,0,32,1 %;        !  Address of MBPR
macro CRAM$Q_HW_MBX = 16,0,0,0 %;
literal CRAM$S_HW_MBX = 8;              !  PA of hardward mailbox
macro CRAM$Q_QUEUE_TIME = 24,0,0,0 %;
literal CRAM$S_QUEUE_TIME = 8;          !  Queue timeout time
macro CRAM$Q_WAIT_TIME = 32,0,0,0 %;
literal CRAM$S_WAIT_TIME = 8;           !  Wait timeout
macro CRAM$L_DRIVER = 40,0,32,0 %;      !  Spare longword for driver
macro CRAM$L_IDB = 44,0,32,1 %;         !  Pointer to IDB
macro CRAM$L_UCB = 48,0,32,1 %;         !  Pointer to UCB
macro CRAM$R_CRAM_FLAGS_OVERLAY = 52,0,8,0 %;
macro CRAM$B_CRAM_FLAGS = 52,0,8,0 %;   !  Flags bitmask
macro CRAM$V_CRAM_IN_USE = 52,0,1,0 %;  !  CRAM is valid
macro CRAM$L_CRAMHADDR = 56,0,32,0 %;   !  Header entry address
!  This piece must be 64 byte aligned - this is the hardware mailbox
macro CRAM$L_COMMAND = 64,0,32,0 %;     !  Bus command
macro CRAM$L_COMMAND_FLAGS = 64,0,32,0 %; !  Flag bits in command field
macro CRAM$V_B = 64,30,1,0 %;           !  "BRIDGE" bit
macro CRAM$V_W = 64,31,1,0 %;           !  "WRITE" bit
macro CRAM$B_BYTE_MASK = 68,0,8,0 %;    !  Active byte mask
macro CRAM$B_HOSE = 70,0,8,0 %;         !  I/O bus number
macro CRAM$Q_RBADR = 72,0,0,0 %;
literal CRAM$S_RBADR = 8;               !  Remote bus address
macro CRAM$Q_WDATA = 80,0,0,0 %;
literal CRAM$S_WDATA = 8;               !  Data to be written
macro CRAM$Q_RDATA = 96,0,0,0 %;
literal CRAM$S_RDATA = 8;               !  Returned read data
macro CRAM$W_MBX_FLAGS = 104,0,16,0 %;  !  Flags bitmask
macro CRAM$V_MBX_DONE = 104,0,1,0 %;    !  Mailbox operation completed
macro CRAM$V_MBX_ERROR = 104,1,1,0 %;   !  Error in operation
macro CRAM$W_ERROR_BITS = 106,0,0,0 %;  !  Device specific error bits
!  Mailbox data structure used by hardware and bootstrap code
literal HW_CRAM$M_MBX_DONE = 1;
literal HW_CRAM$M_MBX_ERROR = 2;
literal HW_CRAM$K_LENGTH = 64;          !  Length of structure
literal HW_CRAM$S_HW_CRAMDEF = 64;
macro HW_CRAM$L_COMMAND = 0,0,32,0 %;   !  Bus command
macro HW_CRAM$B_BYTE_MASK = 4,0,8,0 %;  !  Active byte mask
macro HW_CRAM$B_HOSE = 6,0,8,0 %;       !  I/O bus number
macro HW_CRAM$Q_RBADR = 8,0,0,0 %;
literal HW_CRAM$S_RBADR = 8;            !  Remote bus address
macro HW_CRAM$Q_WDATA = 16,0,0,0 %;
literal HW_CRAM$S_WDATA = 8;            !  Data to be written
macro HW_CRAM$Q_RDATA = 32,0,0,0 %;
literal HW_CRAM$S_RDATA = 8;            !  Returned read data
macro HW_CRAM$W_MBX_FLAGS = 40,0,16,0 %; !  Flags bitmask
macro HW_CRAM$V_MBX_DONE = 40,0,1,0 %;  !  Mailbox operation completed
macro HW_CRAM$V_MBX_ERROR = 40,1,1,0 %; !  Error in operation
macro HW_CRAM$W_ERROR_BITS = 42,0,0,0 %; !  Device specific error bits
!  Command table definition.  Note -- the order of the longwords in the
!  CMDARRAY vector must be the same as the order of the constant command
!  indices defined above.
! 
literal CMDTABLEHEADER$K_LENGTH = 12;
literal CMDTABLE$K_LENGTH = 80;         !  Length of structure
literal CMDTABLE$S_CMDTABLEDEF = 80;
macro CMDTABLE$L_ADP = 0,0,32,0 %;
macro CMDTABLE$W_BUS_TYPE = 4,0,16,0 %; !  Bus Type
macro CMDTABLE$W_SIZE = 8,0,16,0 %;     !  Structure size in bytes
macro CMDTABLE$B_TYPE = 10,0,8,0 %;     !  Structure type
macro CMDTABLE$B_SUBTYPE = 11,0,8,0 %;  !  Structure subtype
macro CMDTABLE$L_CMD_VECTOR = 12,0,0,0 %; !  beginning of vector of commands
macro CRAMCMD$L_RDQUAD32 = 16,0,32,0 %; !  Quadword read  in 32 bit space
macro CRAMCMD$L_RDLONG32 = 20,0,32,0 %; !  Longword "     "  "  "   "
macro CRAMCMD$L_RDWORD32 = 24,0,32,0 %; !  Word     "     "  "  "   "
macro CRAMCMD$L_RDBYTE32 = 28,0,32,0 %; !  Byte     "     "  "  "   "
macro CRAMCMD$L_WTQUAD32 = 32,0,32,0 %; !  Quadword write "  "  "   "
macro CRAMCMD$L_WTLONG32 = 36,0,32,0 %; !  Longword "     "  "  "   "
macro CRAMCMD$L_WTWORD32 = 40,0,32,0 %; !  Word     "     "  "  "   "
macro CRAMCMD$L_WTBYTE32 = 44,0,32,0 %; !  Byte     "     "  "  "   "
macro CRAMCMD$L_RDQUAD64 = 48,0,32,0 %; !  Quadword read  in 64 bit space
macro CRAMCMD$L_RDLONG64 = 52,0,32,0 %; !  Longword "     "  "  "   "
macro CRAMCMD$L_RDWORD64 = 56,0,32,0 %; !  Word     "     "  "  "   "
macro CRAMCMD$L_RDBYTE64 = 60,0,32,0 %; !  Byte     "     "  "  "   "
macro CRAMCMD$L_WTQUAD64 = 64,0,32,0 %; !  Quadword write "  "  "   "
macro CRAMCMD$L_WTLONG64 = 68,0,32,0 %; !  Longword "     "  "  "   "
macro CRAMCMD$L_WTWORD64 = 72,0,32,0 %; !  Word     "     "  "  "   "
macro CRAMCMD$L_WTBYTE64 = 76,0,32,0 %; !  Byte     "     "  "  "   "
 
!*** MODULE $CRAMHDEF ***
! +
!  CRAMH - CSR Regsiter Access Mailbox Header
! 
!  The CSR register access mailbox header describes the page of mailboxes
! 
! -
literal CRAMH$K_LENGTH = 128;           !  Length of structure
literal CRAMH$S_CRAMHDEF = 128;
macro CRAMH$L_FLINK = 0,0,32,1 %;       !  Forward link
macro CRAMH$L_BLINK = 4,0,32,1 %;       !  Backward link
macro CRAMH$W_SIZE = 8,0,16,0 %;        !  Structure size in bytes
macro CRAMH$B_TYPE = 10,0,8,0 %;        !  Structure type
macro CRAMH$B_SUBTYPE = 11,0,8,0 %;     !  Structure subtype
macro CRAMH$L_MAX = 12,0,32,0 %;        !  Mailbox max index
macro CRAMH$Q_PA_BASE = 16,0,0,0 %;
literal CRAMH$S_PA_BASE = 8;            !  Base PA of page
macro CRAMH$L_AVAIL = 24,0,32,0 %;      !  Mailboxes available
macro CRAMH$B_MAP = 28,0,0,0 %;
literal CRAMH$S_MAP = 64;               !  Usage bitmap
!  Sized for 64KB page max
 
!*** MODULE $CRBDEF ***
! +
!  CRB - CHANNEL REQUEST BLOCK
! 
!  THERE IS ONE CHANNEL REQUEST BLOCK FOR EACH SET OF DEVICES WHOSE
!  ACCESS TO A SET OF CONTROLLERS MUST BE SYNCHRONIZED. EACH CHANNEL
!  CONTROL BLOCK ALLOWS UP TO FOUR CONTROLLERS TO WHICH THE INDIVIDUAL
!  DEVICES CAN BE ATTACHED.
! -
literal CRB$M_BSY = 1;
literal CRB$M_UNINIT = 2;
literal CRB$K_LENGTH = 120;             ! LENGTH OF STANDARD CRB 
literal CRB$C_LENGTH = 120;             ! LENGTH OF STANDARD CRB 
literal CRB$S_CRBDEF = 176;
macro CRB$L_FQFL = 0,0,32,0 %;          ! FORK QUEUE FORWARD LINK
macro CRB$L_FQBL = 4,0,32,0 %;          ! FORK QUEUE BACKWARD LINK
macro CRB$W_SIZE = 8,0,16,0 %;          ! SIZE OF CRB IN BYTES 
macro CRB$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE FOR CRB 
macro CRB$B_FLCK = 11,0,8,0 %;          ! FORK LOCK NUMBER
macro CRB$L_FPC = 12,0,32,0 %;          ! FORK PC
macro CRB$L_FR3 = 16,0,32,0 %;          ! FORK R3
macro CRB$L_FR4 = 20,0,32,0 %;          ! FORK R4
macro CRB$L_WQFL = 24,0,32,0 %;         ! WAIT QUEUE FORWARD LINK
macro CRB$L_WQBL = 28,0,32,0 %;         ! WAIT QUEUE BACKWARD LINK
macro CRB$L_RAM_BUFFER_SIZE = 32,0,32,0 %; ! Size of RAM buffer
macro CRB$B_TT_TYPE = 32,0,8,0 %;       ! controler type (DZ11, DZ32)
macro CRB$B_SPARE = 33,0,24,0 %;
literal CRB$S_SPARE = 3;                ! spare bytes
macro CRB$W_REFC = 36,0,16,0 %;         ! REFERENCE COUNT OF UCB'S 
macro CRB$B_MASK = 38,0,8,0 %;          ! CHANNEL ALLOCATION MASK 
macro CRB$V_BSY = 38,0,1,0 %;           !  CHANNEL IS BUSY (1=YES) 
macro CRB$V_UNINIT = 38,1,1,0 %;        !  GENBI  CRB is uninitialized. (1=YES) 
macro CRB$B_UNIT_BRK = 39,0,8,0 %;      ! Break bits for lines
macro CRB$L_AUXSTRUC = 40,0,32,0 %;     ! Auxiliary structure addr (CDDB for class driver) 
macro CRB$L_TIMELINK = 44,0,32,0 %;     ! Thread of CRB's for periodic wakeup 
macro CRB$L_TT_MODEM = 44,0,32,0 %;     ! modem control timer thread
macro CRB$L_DUETIME = 48,0,32,0 %;      ! Due time for periodic wakeup 
macro CRB$L_DZ_MODEM = 48,0,32,0 %;     ! DZ11 modem transition detection timer thread
macro CRB$L_TOUTROUT = 52,0,32,0 %;     ! Address of periodic wakeup routine 
macro CRB$B_DZ_RING = 52,0,8,0 %;       ! last sampled ring for DZ11
macro CRB$B_DZ_CARRIER = 53,0,8,0 %;    ! last sampled carrier for DZ11
macro CRB$B_DZ_DTR = 54,0,8,0 %;        ! last output DTR for DZ11
macro CRB$B_TT_TIMREFC = 55,0,8,0 %;    ! lines with active modem timers
macro CRB$L_LINK = 56,0,32,0 %;         ! ADDRESS OF SECONDARY CRB 
macro CRB$L_DLCK = 60,0,32,0 %;         ! ADDRESS OF DEVICE SPINLOCK
macro CRB$L_INTD = 80,0,0,0 %;
literal CRB$S_INTD = 40;                ! DEFAULT TRANSFER VECTOR START
macro CRB$L_INTD2 = 136,0,0,0 %;
literal CRB$S_INTD2 = 40;               ! 2ND DEFAULT TRANSFER VECTOR START
 
!*** MODULE $VECDEF ***
! +
!  CRB INTERRUPT TRANSFER VECTOR STRUCTURE DEFINITIONS
!  
!  NOTE: THAT THE ORIGIN OF THE VECDEF STRUCTURE DOES NOT BEGIN AT RTINTD.
!  THIS BECAUSE CRB$L_INTD HAS BEEN USED IN MANY DRIVERS AS THE IMPLICIT
!  BEGINNING OF VECDEF.  EXTENSIONS TO VECDEF HAVE NEGATIVE OFFSETS TO
!  AVOID HAVING TO CHANGE ALL REFERENCES TO CRB$L_INTD.
!  
! 
! -
literal VEC$M_MAPLOCK = 32768;
literal VEC$M_LWAE = 32;
literal VEC$M_PATHLOCK = 128;
literal VEC$M_ALTLOCK = 32768;
literal VEC$K_LENGTH = 56;              ! LENGTH OF STANDARD DISPATCHER 
literal VEC$C_LENGTH = 56;              ! LENGTH OF STANDARD DISPATCHER 
literal VEC$S_VECDEF = 56;
! CRB INTERRUPT TRANSFER VECTOR 
macro VEC$L_BUGCHECK = -16,0,32,0 %;    ! ADDRESS OF ILLQBUSCFG BUG_CHECK 
macro VEC$L_RTINTD = -12,0,0,0 %;
literal VEC$S_RTINTD = 12;              ! Q-22 BUS MULTI-LEVEL INTR DISPATCH CODE START
macro VEC$L_INTD = 0,0,32,0 %;          ! DEFAULT INTR DISPATCH CODE START
macro VEC$L_ISR = 4,0,32,0 %;           ! ADDRESS OF INTERRUPT SERVICE ROUTINE
macro VEC$Q_DISPATCH = 0,0,0,0 %;
literal VEC$S_DISPATCH = 8;
macro VEC$L_IDB = 8,0,32,0 %;           ! ADDRESS OF ASSOCIATED IDB 
macro VEC$L_INITIAL = 12,0,32,0 %;      ! CONTROLLER INITIALIZATION ENTRY ADDRESS 
macro VEC$W_MAPREG = 16,0,16,0 %;       ! STARTING MAP REGISTER ALLOCATED 
macro VEC$V_MAPREG = 16,0,15,0 %;
literal VEC$S_MAPREG = 15;              !  MAP REGISTER NUMBER 
macro VEC$V_MAPLOCK = 16,15,1,0 %;      !  MAP REGISTER ALLOCATION PERMANENT 
macro VEC$B_NUMREG = 18,0,8,0 %;        ! NUMBER OF MAP REGISTERS ALLOCATED 
macro VEC$B_DATAPATH = 19,0,8,0 %;      ! BUFFERED DATAPATH ALLOCATED 
macro VEC$V_DATAPATH = 19,0,5,0 %;
literal VEC$S_DATAPATH = 5;             !  DATAPATH NUMBER 
macro VEC$V_LWAE = 19,5,1,0 %;          !  LONGWORD ACCESS ENABLED 
macro VEC$V_PATHLOCK = 19,7,1,0 %;      !  DATAPATH PERMANENT 
macro VEC$L_ADP = 20,0,32,0 %;          ! ADDRESS OF ADP 
macro VEC$L_UNITINIT = 24,0,32,0 %;     ! ADDRESS OF UNIT INITIALIZE 
macro VEC$L_START = 28,0,32,0 %;        ! ADDRESS OF UNIT START 
macro VEC$L_UNITDISC = 32,0,32,0 %;     ! ADDRESS OF UNIT DISCONNECT 
macro VEC$W_MAPALT = 36,0,16,0 %;       ! STARTING ALTERNATE MAP REGISTER ALLOCATED 
macro VEC$V_MAPALT = 36,0,15,0 %;
literal VEC$S_MAPALT = 15;              !  ATERNATE MAP REGISTER NUMBER 
macro VEC$V_ALTLOCK = 36,15,1,0 %;      !  ALTERNATE MAP REGISTER ALLOCATION PERMANENT 
macro VEC$W_NUMALT = 38,0,16,0 %;       ! NUMBER OF ALTERNATE MAP REGISTERS ALLOCATED 
 
!*** MODULE $CTSIDEF ***
literal CTSI$K_REVISION = 1;            !  CTSI Revision 1 only.
literal CTSI$C_REVISION = 1;
literal CTMD$K_SIZE = 8;                !  Size
literal CTMD$C_SIZE = 8;                !  Size
literal CTMD$S_CTMD = 8;                !  Module descriptor in the CTSIA.
macro CTMD$W_PGCOUNT = 0,0,16,0 %;      !  Module length in pages
macro CTMD$L_BASEADDR = 4,0,32,0 %;     !  Base physical addr.
literal CTCB$K_SIZE = 28;               !  Length of channel block
literal CTCB$C_SIZE = 28;               !  Length of channel block
literal CTCB$S_CTCB = 28;               !  Channel block in the CTSIA.
macro CTCB$B_DVATR = 0,0,8,0 %;         !  Device attributes
macro CTCB$B_CHATR = 1,0,8,0 %;         !  Channel attributes
macro CTCB$W_STATESZ = 2,0,16,0 %;      !  State size
macro CTCB$L_PHY_ENTRY = 4,0,32,0 %;    !  Physical entry point
macro CTCB$L_VIR_ENTRY = 8,0,32,0 %;    !  Virtual entry point
macro CTCB$L_PHY_SEGMENT = 12,0,32,0 %; !  IO segment physical addr
macro CTCB$L_VIR_SEGMENT = 16,0,32,0 %; !  IO segment virtual addr
macro CTCB$L_PHY_EXTEND = 20,0,32,0 %;  !  Extended state phys. addr
macro CTCB$L_VIR_EXTEND = 24,0,32,0 %;  !  Extended state virt. addr
literal CTIOS$K_SIZE = 8;               !  Descriptor length
literal CTIOS$C_SIZE = 8;               !  Descriptor length
literal CTIOS$S_CTIOS = 8;
!  Console I/O segment array and descriptors
macro CTIOS$W_SGMT_COUNT = 0,0,16,0 %;  !  # segments for channel
macro CTIOS$B_BASE_SEGMENT = 4,0,8,0 %; !  Offset for first segment dx.
macro CTIOS$W_PGCOUNT = 0,0,16,0 %;     !  Pages in this segment
macro CTIOS$L_SEGMENT = 4,0,32,0 %;     !  Physical Segment address
literal CTSI$K_MODULE_COUNT = 6;
literal CTSI$C_MODULE_COUNT = 6;
literal CTSI$K_CHN_COUNT = 6;
literal CTSI$C_CHN_COUNT = 6;
literal CTSI$M_CMUSE = 3;
literal CTSI$M_INUSE = 4;
literal CTSI$M_CM = 16;
literal CTSI$S_CTSIDEF = 316;
macro CTSI$L_BASE = 0,0,32,0 %;         !  Physical base address of CTSI
macro CTSI$W_SIZE = 4,0,16,0 %;         !  Size in bytes of CTSI
macro CTSI$W_IDENT = 6,0,16,0 %;        !  Indent string "CT"
macro CTSI$B_SPARE0 = 8,0,8,0 %;
macro CTSI$B_CHKSUM = 9,0,8,0 %;        !  Checksum of first bytes
macro CTSI$B_FLAGS = 10,0,8,0 %;        !  Flags
macro CTSI$V_CMUSE = 10,0,2,0 %;
literal CTSI$S_CMUSE = 2;
macro CTSI$V_INUSE = 10,2,1,0 %;        !  Routine in use
macro CTSI$V_SPARE0 = 10,3,1,0 %;
macro CTSI$V_CM = 10,4,1,0 %;           !  Console mode
macro CTSI$B_REVISN = 11,0,8,0 %;       !  Console revision
macro CTSI$Q_MODULE_DESC = 12,0,0,0 %;
literal CTSI$S_MODULE_DESC = 48;        !  Module descriptors
macro CTSI$L_CHNBLK = 60,0,0,0 %;
literal CTSI$S_CHNBLK = 168;            !  Channel blocks of size = (7 longs)
macro CTSI$Q_SAVE = 228,0,0,0 %;
literal CTSI$S_SAVE = 8;                !  Save ptrs
macro CTSI$Q_RESTORE = 236,0,0,0 %;
literal CTSI$S_RESTORE = 8;             !  Restore pointers
macro CTSI$Q_TRANS = 244,0,0,0 %;
literal CTSI$S_TRANS = 8;               !  Translate ptrs
macro CTSI$Q_GETCHR = 252,0,0,0 %;
literal CTSI$S_GETCHR = 8;              !  GET CHAR ptrs
macro CTSI$L_GETCHR_STATE = 260,0,0,0 %;
literal CTSI$S_GETCHR_STATE = 16;       !  GET CHAR state
macro CTSI$Q_PUTCHR = 276,0,0,0 %;
literal CTSI$S_PUTCHR = 8;              !  PUT CHAR ptrs
macro CTSI$L_PUTCHR_STATE = 284,0,0,0 %;
literal CTSI$S_PUTCHR_STATE = 16;       !  PUT CHAR state
macro CTSI$Q_PUTMSG = 300,0,0,0 %;
literal CTSI$S_PUTMSG = 8;              !  Put message routine
macro CTSI$Q_READPROMPT = 308,0,0,0 %;
literal CTSI$S_READPROMPT = 8;          !  Read with prompt routine
 
!*** MODULE $CRD_ARGDEF ***
! +
!  Selected SYSLOAnnn routines will make use of extended CRD error handling.
!  If so, the INT54 handlers will set up system-dependent parameters and pass
!  them via CALLG to common CRD handlers ([SYSLOA]CRDERR.MAR).  These structure
!  offsets are intended to be used as offsets from an argument block, typically
!  (AP), both by the caller of the CRD routines and the CRD routines themselves.
! -
literal CRD_ARG$M_HWSCRUB = 1;
literal CRD_ARG$M_PROCESS_SYNC = 2;
literal CRD_ARG$M_GLOBAL_SYNC = 4;
literal CRD_ARG$M_NOSCRUB = 8;
literal CRD_ARG$M_NOREPLACE = 16;
literal CRD_ARG$K_LENGTH = 40;          !  Length of argument area
literal CRD_ARG$C_LENGTH = 40;          !  Length of argument area
literal CRD_ARG$S_CRD_ARGDEF = 40;
macro CRD_ARG$Q_FOOTPRINT = 0,0,0,0 %;
literal CRD_ARG$S_FOOTPRINT = 8;        !  64-bits of error syndrome
macro CRD_ARG$Q_SYSTIME = 8,0,0,0 %;
literal CRD_ARG$S_SYSTIME = 8;          !  System time of the CRD
macro CRD_ARG$Q_ADDRESS = 16,0,0,0 %;
literal CRD_ARG$S_ADDRESS = 8;          !  64-bit hardware-supplied address containing CRD
macro CRD_ARG$L_FLAGS = 24,0,32,0 %;    !  Status bits for this CRD
macro CRD_ARG$V_HWSCRUB = 24,0,1,0 %;   !  HW has scrubbed data.  SW doesn't need to.
macro CRD_ARG$V_PROCESS_SYNC = 24,1,1,0 %; !  System synchronization required for process pages
macro CRD_ARG$V_GLOBAL_SYNC = 24,2,1,0 %; !  System synchronization required for global pages
macro CRD_ARG$V_NOSCRUB = 24,3,1,0 %;   !  Update fprint only - do not attempt scrub
macro CRD_ARG$V_NOREPLACE = 24,4,1,0 %; !  Update fprint only - do not attempt replace
macro CRD_ARG$L_SCRUB_BLKSIZ = 28,0,32,0 %; !  Size, in bytes, of area to scrub
macro CRD_ARG$L_MAX_PAGREP = 32,0,32,0 %; !  Max # pages that can be replaced from the memory 'unit' reporting this CRD
macro CRD_ARG$L_UNIT_ID = 36,0,32,0 %;  !  Memory controller 'unit' ID
 
!*** MODULE $CRD_FOOTDEF ***
! +
!  Selected SYSLOAnnn routines will make use of extended CRD error handling.
!  INT54 handlers will set up system-dependent parameters and pass
!  them via CALLG to common CRD handlers ([SYSLOA]CRDERR.MAR).  These arguments
!  are then loaded into 'local' CRD Footprint Blocks (CRD_FOOT) and used for the
!  extended error handling.  The CRD_FOOT definitions should remain local to
!  SYSLOA.
! -
literal CRD_FOOT$K_MAX_FOOTPRINTS = 16; !  Max # of fprints
literal CRD_FOOT_SFLAGS$M_BUSY = 1;
literal CRD_FOOT_SFLAGS$M_HW_SCRUBBED = 2;
literal CRD_FOOT_SFLAGS$M_SW_SCRUBBED = 4;
literal CRD_FOOT_SFLAGS$M_PAGREP = 8;
literal CRD_FOOT_SFLAGS$M_PAGREPNOPFN = 16;
literal CRD_FOOT_SFLAGS$M_LOGGED = 32;
literal CRD_FOOT_DFLAGS$M_INUSENOW = 1;
literal CRD_FOOT_DFLAGS$M_READONLY = 2;
literal CRD_FOOT_CFLAGS$M_HWSCRUB = 1;
literal CRD_FOOT_CFLAGS$M_PROCESS_SYNC = 2;
literal CRD_FOOT_CFLAGS$M_NOSCRUB = 4;
literal CRD_FOOT_CFLAGS$M_NOREPLACE = 8;
literal CRD_FOOT_PAGTYP$M_PROCESS = 1;
literal CRD_FOOT_PAGTYP$M_SYSTEM = 2;
literal CRD_FOOT_PAGTYP$M_GLOBAL = 4;
literal CRD_FOOT_PAGTYP$M_GBLWRT = 8;
literal CRD_FOOT_PAGTYP$M_PPGTBL = 16;
literal CRD_FOOT_PAGTYP$M_GPGTBL = 32;
literal CRD_FOOT_PAGTYP$M_UNKNOWN = 64;
literal CRD_FOOT_FAILMSK$M_PFNTOOBIG = 1;
literal CRD_FOOT_FAILMSK$M_NONPAGED = 2;
literal CRD_FOOT_FAILMSK$M_BADREFCNT = 4;
literal CRD_FOOT_FAILMSK$M_NOTACTIVE = 8;
literal CRD_FOOT_FAILMSK$M_PHYCNTG = 16;
literal CRD_FOOT_FAILMSK$M_PFNLOCK = 32;
literal CRD_FOOT_FAILMSK$M_SCB = 64;
literal CRD_FOOT_FAILMSK$M_SPT = 128;
literal CRD_FOOT_FAILMSK$M_GPT = 256;
literal CRD_FOOT_FAILMSK$M_RPB = 512;
literal CRD_FOOT_FAILMSK$M_SYS = 1024;
literal CRD_FOOT_FAILMSK$M_BALSET = 2048;
literal CRD_FOOT_FAILMSK$M_CPUDB = 4096;
literal CRD_FOOT_FAILMSK$M_ISTACK = 8192;
literal CRD_FOOT_FAILMSK$M_SYSLREGION = 16384;
literal CRD_FOOT_FAILMSK$M_S0_VECTOR = 32768;
literal CRD_FOOT_FAILMSK$M_NOSYNC = 65536;
literal CRD_FOOT_FAILMSK$M_PFNALCFAIL = 131072;
literal CRD_FOOT_FAILMSK$M_WRONGPFN = 262144;
literal CRD_FOOT_FAILMSK$M_NOTVALID = 524288;
literal CRD_FOOT_FAILMSK$M_UNIT_THRESH = 1048576;
literal CRD_FOOT_FAILMSK$M_SYS_THRESH = 2097152;
literal CRD_FOOT_FAILMSK$M_NOTPOWER2 = 4194304;
literal CRD_FOOT_FAILMSK$M_BADPAGTYP = 8388608;
literal CRD_FOOT_FAILMSK$M_INCONSTATE = 16777216;
literal CRD_FOOT_FAILMSK$M_MCHK = 33554432;
literal CRD_FOOT_FAILMSK$M_RELPENDING = 67108864;
literal CRD_FOOT_FAILMSK$M_WINDOW_PTE = 134217728;
literal CRD_FOOT_FAILMSK$M_FLUNKED = 268435456;
literal CRD_FOOT_FAILMSK$M_EOF = -2147483648;
literal CRD_FOOT_PGLOCATION$M_PROCESS = 1;
literal CRD_FOOT_PGLOCATION$M_BALSET = 2;
literal CRD_FOOT_PGLOCATION$M_SPT = 4;
literal CRD_FOOT_PGLOCATION$M_GPT = 8;
literal CRD_FOOT_PGLOCATION$M_SCB = 16;
literal CRD_FOOT_PGLOCATION$M_RPB = 32;
literal CRD_FOOT_PGLOCATION$M_PPOOL = 64;
literal CRD_FOOT_PGLOCATION$M_XFER_VEC = 128;
literal CRD_FOOT_PGLOCATION$M_PFNDB = 256;
literal CRD_FOOT_PGLOCATION$M_SYSPHD = 512;
literal CRD_FOOT_PGLOCATION$M_ISTACK = 1024;
literal CRD_FOOT_PGLOCATION$M_LDIMG = 2048;
literal CRD_FOOT_PGLOCATION$M_READONLY = 4096;
literal CRD_FOOT$K_LENGTH = 108;        !  Length of argument area
literal CRD_FOOT$C_LENGTH = 108;        !  Length of argument area
literal CRD_FOOT$S_CRD_FOOTDEF = 108;
macro CRD_FOOT$Q_FOOTPRINT = 0,0,0,0 %;
literal CRD_FOOT$S_FOOTPRINT = 8;       !  64-bits of error syndrome
macro CRD_FOOT$Q_SYSTIME = 8,0,0,0 %;
literal CRD_FOOT$S_SYSTIME = 8;         !  System time of the CRD
macro CRD_FOOT$Q_ADDR_LOW = 16,0,0,0 %;
literal CRD_FOOT$S_ADDR_LOW = 8;        !  64-bit lowest address associated with this CRD
macro CRD_FOOT$Q_ADDR_HIGH = 24,0,0,0 %;
literal CRD_FOOT$S_ADDR_HIGH = 8;       !  64-bit highest address associated with this CRD
macro CRD_FOOT$Q_ADDR_CUM = 32,0,0,0 %;
literal CRD_FOOT$S_ADDR_CUM = 8;        !  64-bit bitmask of lowest address XORed, then ORed with all new addresses
macro CRD_FOOT$W_STATIC_FLAGS = 40,0,16,0 %; !  Footprint flags
macro CRD_FOOT_SFLAGS$V_BUSY = 40,0,1,0 %; !  Indicates this CRD_FOOT in use
macro CRD_FOOT_SFLAGS$V_HW_SCRUBBED = 40,1,1,0 %; !  CRD already scrubbed by hardware
macro CRD_FOOT_SFLAGS$V_SW_SCRUBBED = 40,2,1,0 %; !  CRD already scrubbed by software
macro CRD_FOOT_SFLAGS$V_PAGREP = 40,3,1,0 %; !  Indicates page was replaced
macro CRD_FOOT_SFLAGS$V_PAGREPNOPFN = 40,4,1,0 %; !  Indicates replaced page is not in PFN database
macro CRD_FOOT_SFLAGS$V_LOGGED = 40,5,1,0 %; !  Indicates this CRD_FOOT has been flushed to the error log
macro CRD_FOOT$W_DYNAMIC_FLAGS = 42,0,16,0 %; !  Footprint flags
macro CRD_FOOT_DFLAGS$V_INUSENOW = 42,0,1,0 %; !  SCRUB or REPLACE in progress
macro CRD_FOOT_DFLAGS$V_READONLY = 42,1,1,0 %; !  Page is read-only, means no synchronization required to scrub
macro CRD_FOOT$L_CALLER_FLAGS = 44,0,32,0 %; !  Status bits for this CALLER
macro CRD_FOOT_CFLAGS$V_HWSCRUB = 44,0,1,0 %; !  HW scrubbed this data
macro CRD_FOOT_CFLAGS$V_PROCESS_SYNC = 44,1,1,0 %; !  Process page requires system synchronization before scrubbing/replacing page
macro CRD_FOOT_CFLAGS$V_NOSCRUB = 44,2,1,0 %; !  Only update the footprint info - do not attempt scrub
macro CRD_FOOT_CFLAGS$V_NOREPLACE = 44,3,1,0 %; !  Only update the footprint info - do not attempt replace
macro CRD_FOOT$L_SCRUB_BLKSIZ = 48,0,32,0 %; !  Size, in bytes, of area to scrub
macro CRD_FOOT$W_MAX_PAGREP = 52,0,16,0 %; !  Max # pages that can be replaced from the memory 'unit' reporting this CRD
macro CRD_FOOT$W_UNIT_ID = 54,0,16,0 %; !  Memory controller 'unit' ID
macro CRD_FOOT$B_PAGTYP = 56,0,8,0 %;   !  Indicates page type 
macro CRD_FOOT_PAGTYP$V_PROCESS = 56,0,1,0 %; !  Process page (process)
macro CRD_FOOT_PAGTYP$V_SYSTEM = 56,1,1,0 %; !  System page  (system)
macro CRD_FOOT_PAGTYP$V_GLOBAL = 56,2,1,0 %; !  Global page  (global)
macro CRD_FOOT_PAGTYP$V_GBLWRT = 56,3,1,0 %; !  Global read/write page  (global)
macro CRD_FOOT_PAGTYP$V_PPGTBL = 56,4,1,0 %; !  Process page table page (system)
macro CRD_FOOT_PAGTYP$V_GPGTBL = 56,5,1,0 %; !  Global page table page  (system)
macro CRD_FOOT_PAGTYP$V_UNKNOWN = 56,6,1,0 %; !  Unknown page (not contained within PFN database)
macro CRD_FOOT$L_SCRUB_FAILMSK = 60,0,32,0 %; !  Contains collective reasons why page couldn't be scrubbed
macro CRD_FOOT$L_PAGREP_FAILMSK = 64,0,32,0 %; !  Contains collective reasons why page couldn't be replaced
macro CRD_FOOT_FAILMSK$V_PFNTOOBIG = 64,0,1,0 %; !  Footprint PFN was greater than the system maximum.
macro CRD_FOOT_FAILMSK$V_NONPAGED = 64,1,1,0 %; !  Page was part of nonpaged pool
macro CRD_FOOT_FAILMSK$V_BADREFCNT = 64,2,1,0 %; !  REFCNT for this page .NEQ. 1
macro CRD_FOOT_FAILMSK$V_NOTACTIVE = 64,3,1,0 %; !  Page was not ACTIVE in the PFN state array
macro CRD_FOOT_FAILMSK$V_PHYCNTG = 64,4,1,0 %; !  Page was part of a physically contiguous region
macro CRD_FOOT_FAILMSK$V_PFNLOCK = 64,5,1,0 %; !  Page was mapped by PFN and can't be touched
macro CRD_FOOT_FAILMSK$V_SCB = 64,6,1,0 %; !  Page was part of the SCB
macro CRD_FOOT_FAILMSK$V_SPT = 64,7,1,0 %; !  Page was part of the system page table
macro CRD_FOOT_FAILMSK$V_GPT = 64,8,1,0 %; !  Page was part of the global page table
macro CRD_FOOT_FAILMSK$V_RPB = 64,9,1,0 %; !  Page was (part of) the Restart Parameter Block
macro CRD_FOOT_FAILMSK$V_SYS = 64,10,1,0 %; !  Page was (part of) some generic system area that could not be touched
macro CRD_FOOT_FAILMSK$V_BALSET = 64,11,1,0 %; !  Page was part of the balance set
macro CRD_FOOT_FAILMSK$V_CPUDB = 64,12,1,0 %; !  Page was part of primary CPU's database
macro CRD_FOOT_FAILMSK$V_ISTACK = 64,13,1,0 %; !  Page was part of another CPU's interrupt stack
macro CRD_FOOT_FAILMSK$V_SYSLREGION = 64,14,1,0 %; !  Page was part of a SYSLOA-specified noscrub/noreplace region
macro CRD_FOOT_FAILMSK$V_S0_VECTOR = 64,15,1,0 %; !  Page is part of the S0 vector table
macro CRD_FOOT_FAILMSK$V_NOSYNC = 64,16,1,0 %; !  Synchronization was required, but couldn't be done
macro CRD_FOOT_FAILMSK$V_PFNALCFAIL = 64,17,1,0 %; !  Couldn't allocate a PFN for page replacement
macro CRD_FOOT_FAILMSK$V_WRONGPFN = 64,18,1,0 %; !  SPT PTE<PFN> changed between time of search and time of PFN replacement
macro CRD_FOOT_FAILMSK$V_NOTVALID = 64,19,1,0 %; !  PTE of page to be scrubbed is not valid
macro CRD_FOOT_FAILMSK$V_UNIT_THRESH = 64,20,1,0 %; !  Page replacement would exceed #pages allowed for this unit
macro CRD_FOOT_FAILMSK$V_SYS_THRESH = 64,21,1,0 %; !  Page replacement would exceed #pages allowed for entire system
macro CRD_FOOT_FAILMSK$V_NOTPOWER2 = 64,22,1,0 %; !  Scrub blksiz was not an integral power of 2
macro CRD_FOOT_FAILMSK$V_BADPAGTYP = 64,23,1,0 %; !  Bad PFN page type - inconsistent state
macro CRD_FOOT_FAILMSK$V_INCONSTATE = 64,24,1,0 %; !  Inconsistent internal state somewhere
macro CRD_FOOT_FAILMSK$V_MCHK = 64,25,1,0 %; !  Machine check occurred during scrub
macro CRD_FOOT_FAILMSK$V_RELPENDING = 64,26,1,0 %; !  Page has its release pending bit set
macro CRD_FOOT_FAILMSK$V_WINDOW_PTE = 64,27,1,0 %; !  PTE has a window bit set for this page
macro CRD_FOOT_FAILMSK$V_FLUNKED = 64,28,1,0 %; !  Page was NOT found in the YESSCRUB/YESREPLACE table
macro CRD_FOOT_FAILMSK$V_EOF = 64,31,1,0 %; !  Marks end of tables (bit 31)
macro CRD_FOOT$L_SCRUB_PGLOCATION = 68,0,32,0 %; !  Contains location in the system where page resides
macro CRD_FOOT$L_PAGREP_PGLOCATION = 72,0,32,0 %; !  Contains location in the system where the replaced page resides
macro CRD_FOOT_PGLOCATION$V_PROCESS = 72,0,1,0 %; !  Page is a process page
macro CRD_FOOT_PGLOCATION$V_BALSET = 72,1,1,0 %; !  Page was a member of the balance set
macro CRD_FOOT_PGLOCATION$V_SPT = 72,2,1,0 %; !  Page was part of the SPT
macro CRD_FOOT_PGLOCATION$V_GPT = 72,3,1,0 %; !  Page was part of the GPT
macro CRD_FOOT_PGLOCATION$V_SCB = 72,4,1,0 %; !  Page was part of the SCB
macro CRD_FOOT_PGLOCATION$V_RPB = 72,5,1,0 %; !  Page was the RPB
macro CRD_FOOT_PGLOCATION$V_PPOOL = 72,6,1,0 %; !  Page was part of paged pool
macro CRD_FOOT_PGLOCATION$V_XFER_VEC = 72,7,1,0 %; !  Page was part of transfer vector area
macro CRD_FOOT_PGLOCATION$V_PFNDB = 72,8,1,0 %; !  Page was part of the PFN database
macro CRD_FOOT_PGLOCATION$V_SYSPHD = 72,9,1,0 %; !  Page was part of the system header
macro CRD_FOOT_PGLOCATION$V_ISTACK = 72,10,1,0 %; !  Page was part of this CPU's interrupt stack
macro CRD_FOOT_PGLOCATION$V_LDIMG = 72,11,1,0 %; !  Page was part of a loadable image
macro CRD_FOOT_PGLOCATION$V_READONLY = 72,12,1,0 %; !  Page was part of Kernel read-only space
macro CRD_FOOT$L_MATCH_CNT = 76,0,32,0 %; !  Total CRDs which match this footprint
macro CRD_FOOT$L_PAGREP_CNT = 80,0,32,0 %; !  Number of times a page was replaced
macro CRD_FOOT$L_PRESCRUB_CNT = 84,0,32,0 %; !  Counts matching CRDs before page could be scrubbed
macro CRD_FOOT$Q_PRESCRUB_TIME = 88,0,0,0 %;
literal CRD_FOOT$S_PRESCRUB_TIME = 8;   !  Time at which last non-scrubbed CRD matched footprint
macro CRD_FOOT$L_POSTSCRUB_CNT = 96,0,32,0 %; !  Counts matching CRDs after page was scrubbed
macro CRD_FOOT$Q_POSTSCRUB_TIME = 100,0,0,0 %;
literal CRD_FOOT$S_POSTSCRUB_TIME = 8;  !  Time at which last CRD matched footprint after scrubbing
 
!*** MODULE $CRSHDEF ***
! +
!   Saved crash context structure definitions.  As part of the system 
!   bugcheck process, each CPU is required to save its current context on 
!   its current operating stack.  A CPU's stack after saving its context
!   should look like this:
! 
! 		00(SP)	ASTLVL
! 		04(SP)	USP
! 		08(SP)	SSP
! 		12(SP)	ESP
! 		16(SP)	KSP
! 		20(SP)	ISP
! 		24(SP)	ICCS
! 		28(SP)	count of CPU specific IPRS
! 
!   The count is followed by the CPU specific IPRS, followed by the
!   GPRS and PC/PSL pair.  This structure defines up to and including 
!   the count field  since this is the standard portion of the saved 
!   context for all processors.  
! 
! -
literal CRSH$K_LENGTH = 32;             ! LENGTH OF STRUCTURE 
literal CRSH$C_LENGTH = 32;             ! LENGTH OF STRUCTURE
literal CRSH$S_CRSHDEF = 32;
macro CRSH$L_ASTLVL = 0,0,32,0 %;       ! AST LEVEL REGISTER
macro CRSH$L_USP = 4,0,32,0 %;          ! USER STACK POINTER
macro CRSH$L_SSP = 8,0,32,0 %;          ! SUPERVISOR STACK PTR
macro CRSH$L_ESP = 12,0,32,0 %;         ! EXEC STACK POINTER
macro CRSH$L_KSP = 16,0,32,0 %;         ! KERNEL STACK POINTER
macro CRSH$L_ISP = 20,0,32,0 %;         ! INTERRUPT STACK PTR
macro CRSH$L_ICCS = 24,0,32,0 %;        ! INTERVAL TIMER CONTROL
macro CRSH$L_COUNT_IPRS = 28,0,32,0 %;  ! COUNT OF IPRS ON STACK 
 
!*** MODULE $CSBDEF ***
! +
!  CSB - CLUSTER SYSTEM BLOCK.
! 
!      	THERE IS ONE CSB FOR EACH SYSTEM IN THE CLUSTER.
! -
literal CSB$K_OPEN = 1;                 !   OPEN
literal CSB$K_STATUS = 2;               !   SENDING/WAITING FOR STATUS
literal CSB$K_RECONNECT = 3;            !   ATTEMPTING TO RECONNECT
literal CSB$K_NEW = 4;                  !   BRAND NEW BLOCK
literal CSB$K_CONNECT = 5;              !   ATTEMPTING INITIAL CONNECTION
literal CSB$K_ACCEPT = 6;               !   ACCEPTING INITIAL CONNECTION
literal CSB$K_DISCONNECT = 7;           !   DISCONNECT IN PROGRESS
literal CSB$K_REACCEPT = 8;             !   ACCEPTING RECONNECT REQUEST
literal CSB$K_WAIT = 9;                 !   TIME-OUT IN PROGRESS
literal CSB$K_DEAD = 10;                !   NO CONNECTION POSSIBLE
literal CSB$K_LOCAL = 11;               !   LOCAL SYSTEM CSB
literal CSB$M_LONG_BREAK = 1;
literal CSB$M_MEMBER = 2;
literal CSB$M_REMOVED = 4;
literal CSB$M_QF_SAME = 8;
literal CSB$M_QF_WATCHER = 16;
literal CSB$M_QF_NOACCESS = 32;
literal CSB$M_OLDVER_1 = 64;
literal CSB$M_CWPS = 128;
literal CSB$M_CLUSTER = 256;
literal CSB$M_QF_ACTIVE = 512;
literal CSB$M_SHUTDOWN = 1024;
literal CSB$M_GONE = 2048;
literal CSB$M_MULTITASK = 4096;
literal CSB$M_RANGELOCK = 8192;
literal CSB$M_DYN_REMASTER = 16384;
literal CSB$M_LOCKED = 65536;
literal CSB$M_SELECTED = 131072;
literal CSB$M_VCC = 262144;
literal CSB$M_LOCAL = 16777216;
literal CSB$M_STATUS_RCVD = 33554432;
literal CSB$M_SEND_STATUS = 67108864;
literal CSB$M_QF_RFRSH_RQD = 134217728;
literal CSB$M_QF_RFRSH_IP = 268435456;
literal CSB$M_QF_IOSYNCH = 536870912;
literal CSB$M_ACT_LSHARE = 1073741824;
literal CSB$M_PASS_LSHARE = -2147483648;
literal CSB$C_LENGTH = 188;             !  LENGTH OF CSB 
literal CSB$K_LENGTH = 188;             !  LENGTH OF CSB 
literal CSB$S_CSBDEF = 188;
macro CSB$L_SYSQFL = 0,0,32,0 %;        !  SYSTEM QUEUE FORWARD LINK
macro CSB$L_SYSQBL = 4,0,32,0 %;        !  SYSTEM QUEUE BACKWARD LINK
macro CSB$W_SIZE = 8,0,16,0 %;          !  SIZE OF CSB IN BYTES
macro CSB$B_TYPE = 10,0,8,0 %;          !  STRUCTURE TYPE 
macro CSB$B_SUBTYPE = 11,0,8,0 %;       !  STRUCTURE SUBTYPE
macro CSB$L_CDT = 12,0,32,0 %;          !  CDT ADDRESS
macro CSB$L_PDT = 16,0,32,0 %;          !  PDT ADDRESS
macro CSB$L_SENTQFL = 20,0,32,0 %;      !  SENT LIST HEAD LINK
macro CSB$L_SENTQBL = 24,0,32,0 %;      !  SENT LIST TAIL LINK
macro CSB$L_RESENDQFL = 28,0,32,0 %;    !  RESEND LIST HEAD LINK
macro CSB$L_RESENDQBL = 32,0,32,0 %;    !  RESEND LIST TAIL LINK
macro CSB$L_WARMCDRPQFL = 36,0,32,0 %;  !  WARM CDRP QUEUE FORWARD LINK
macro CSB$L_WARMCDRPQBL = 40,0,32,0 %;  !  WARM CDRP QUEUE BACKWARD LINK
macro CSB$W_SENDSEQNM = 44,0,16,0 %;    !  NEXT SEQUENCE NUMBER TO SEND
macro CSB$W_RCVDSEQNM = 46,0,16,0 %;    !  LAST SEQUENCE NUMBER RECEIVED
macro CSB$W_ACKRSEQNM = 48,0,16,0 %;    !  LAST ACK RECEIVED SEQ. NUM.
macro CSB$B_UNACKEDMSGS = 50,0,8,0 %;   !  NUMBER OF UNACKED MESSAGES
macro CSB$B_REMACKLIM = 51,0,8,0 %;     !  REMOTE SIDE'S ACK LIMIT
macro CSB$L_CURRCDRP = 52,0,32,0 %;     !  ADDRESS OF CDRP IN CRITICAL SECTION
macro CSB$Q_SWINCARN = 56,0,0,0 %;
literal CSB$S_SWINCARN = 8;             !  REMOTE SOFTWARE INCARN. NUM.
macro CSB$B_ECOLVL = 64,0,8,0 %;        !  PROTOCOL ECO LEVEL
macro CSB$B_VERNUM = 65,0,8,0 %;        !  PROTOCOL VERSION NUMBER
macro CSB$B_WARMCDRPS = 66,0,8,0 %;     !  NUMBER OF CDRPS ON FREE QUEUE
macro CSB$B_STATE = 67,0,8,0 %;         !  STATE OF CONNECTION
!  STATE VALUES:
macro CSB$L_TQE = 68,0,32,0 %;          !  ADDRESS OF TIMER QUEUE ENTRY
macro CSB$L_TIMEOUT = 72,0,32,0 %;      !  TIME TO GIVE UP RECONNECTING
macro CSB$L_CSID = 76,0,32,0 %;         !  Cluster System ID
macro CSB$W_CSID_IDX = 76,0,16,0 %;     !  Slot index
macro CSB$W_CSID_SEQ = 78,0,16,0 %;     !  Sequence number
macro CSB$W_VOTES = 80,0,16,0 %;        !  VOTES HELD BY NODE
macro CSB$W_QUORUM = 82,0,16,0 %;       !  QUORUM SET IN NODE
macro CSB$W_LCKDIRWT = 84,0,16,0 %;     !  LOCK MANAGER DISTRIBUTED DIRECTORY WEIGHT
macro CSB$W_QDVOTES = 86,0,16,0 %;      !  VOTES ASSIGNED TO QUORUM DISK
macro CSB$L_PARTNERQFL = 88,0,32,0 %;   !  LISTHEAD FWD PTR FOR BLOCK-XFER PARTNER BTXs
macro CSB$L_PARTNERQBL = 92,0,32,0 %;   !  LISTHEAD BACK PTR FOR BLOCK-XFER PARTNER BTXs
macro CSB$L_STATUS = 96,0,32,0 %;       !  STATUS OF NODE IN CLUSTER
!  THE FOLLOWING BITS ARE ALWAYS MEANINGFUL
!  BYTE 0
macro CSB$V_LONG_BREAK = 96,0,1,0 %;    !   LONG BREAK IN CONNECTION
macro CSB$V_MEMBER = 96,1,1,0 %;        !   NODE IS MEMBER OF LOCAL CLUSTER
macro CSB$V_REMOVED = 96,2,1,0 %;       !   NODE REMOVED FROM CLUSTER
macro CSB$V_QF_SAME = 96,3,1,0 %;       !   REMOTE QUORUM DISK MATCHES LOCAL DISK
macro CSB$V_QF_WATCHER = 96,4,1,0 %;    !   REMOTE NODE IS WATCHING A QUORUM FILE
macro CSB$V_QF_NOACCESS = 96,5,1,0 %;   !   NODE WILL NEVER ACCESS QUORUM DISK
macro CSB$V_OLDVER_1 = 96,6,1,0 %;      !   OLD VERSION PROTOCOL FLAG
macro CSB$V_CWPS = 96,7,1,0 %;          !   NODE SPEAKS CWPS
!  BYTE 1
macro CSB$V_CLUSTER = 96,8,1,0 %;       !   REMOTE NODE IS CLUSTER MEMBER
macro CSB$V_QF_ACTIVE = 96,9,1,0 %;     !   REMOTE NODE'S QUORUM FILE IS READABLE
macro CSB$V_SHUTDOWN = 96,10,1,0 %;     !   REMOTE NODE READY FOR CLUSTER SHUTDOWN
macro CSB$V_GONE = 96,11,1,0 %;         !   KNOWN TO HAVE SHUTDOWN
macro CSB$V_MULTITASK = 96,12,1,0 %;    !   NODE SPEAKS MULTITASK
macro CSB$V_RANGELOCK = 96,13,1,0 %;    !   supports ranges and priorities
macro CSB$V_DYN_REMASTER = 96,14,1,0 %; !   supports dynamic remastering 
!  THE FOLLOWING BITS ARE MEANINGFUL IF THIS NODE IS THE COORDINATOR
!  BYTE 2
macro CSB$V_LOCKED = 96,16,1,0 %;       !   NODE LOCKED BY COORDINATOR
macro CSB$V_SELECTED = 96,17,1,0 %;     !   NODE SELECTED BY COORDINATOR
macro CSB$V_VCC = 96,18,1,0 %;          !  supports VCC
!  THE FOLLOWING BITS ARE OF LOCAL SIGNIFICANCE ONLY
!  BYTE 3
macro CSB$V_LOCAL = 96,24,1,0 %;        !   MARK CSB FOR LOCAL SYSTEM
macro CSB$V_STATUS_RCVD = 96,25,1,0 %;  !   STATUS RECEIVED FROM REMOTE SYSTEM
macro CSB$V_SEND_STATUS = 96,26,1,0 %;  !   NEED TO SEND STATUS TO REMOTE SYSTEM
macro CSB$V_QF_RFRSH_RQD = 96,27,1,0 %; !   NEED QUORUM FILE REFRESH
macro CSB$V_QF_RFRSH_IP = 96,28,1,0 %;  !   QF REFRESH IN PROGRESS
macro CSB$V_QF_IOSYNCH = 96,29,1,0 %;   !   QF IO SYNCH DONE
macro CSB$V_ACT_LSHARE = 96,30,1,0 %;   !   ACTIVE SIDE TO LOAD SHARING
macro CSB$V_PASS_LSHARE = 96,31,1,0 %;  !   PASSIVE SIDE TO LOAD SHARING
macro CSB$L_CLUB = 100,0,32,0 %;        !  ADDRESS OF CLUB
macro CSB$L_SB = 104,0,32,0 %;          !  ADDRESS OF SB FOR REMOTE SYSTEM
macro CSB$B_REF_CNT = 108,0,8,0 %;      !  REFERENCE COUNT
macro CSB$B_CLUVER = 109,0,8,0 %;       !  CLUSTER VERSION NUMBER
macro CSB$W_NODES = 110,0,16,0 %;       !  Number of nodes in remote cluster
macro CSB$W_CNX_STS_R0 = 112,0,16,0 %;  !  CONNECTION REQUEST R0 STATUS
macro CSB$W_CNX_STS_R1 = 114,0,16,0 %;  !  CONNECTION REQUEST R1 STATUS
macro CSB$Q_REFTIME = 116,0,0,0 %;
literal CSB$S_REFTIME = 8;              !  CREATION/ADDITION/REMOVAL TIME
macro CSB$L_RMAX_VCTMO = 124,0,32,0 %;  !  MAX REMOTE VC TIMEOUT INTERVAL
macro CSB$W_LASTSENT = 128,0,16,0 %;    !  SEQ. NUM. OF MESSAGE LAST SENT
macro CSB$W_EVOTES = 130,0,16,0 %;      !  REMOTE NODE'S EXPECTED VOTES
macro CSB$B_CNCT = 132,0,0,1 %;
literal CSB$S_CNCT = 16;                !  CONNECT/ACCEPT DATA AREA
macro CSB$B_NODEMAP = 148,0,0,1 %;
literal CSB$S_NODEMAP = 32;             !  BITMAP OF NODE CONNECTIVITY
macro CSB$W_CNID = 180,0,16,0 %;        !  CLUSTER NODE ID
macro CSB$W_PASS_CNTR = 182,0,16,0 %;   !  Total Passive loadshare ops
macro CSB$W_ACT_CNTR = 184,0,16,0 %;    !  Total Active loadshare ops
macro CSB$W_ERR_CNTR = 186,0,16,0 %;    !  Total Errors on connection
 
!*** MODULE $CTLP1FLAGSDEF ***
!  +
!  CTL P1 flags
! 
!  These are flags in the CTL p1 region to define miscellaneous things.
!  They reside in the cell CTL$GQ_MISC_P1_FLAGS, defined in SHELL.MAR.
! 
!  -
literal CTLP1FLAGS$M_GSD_CLEAN = 1;
literal CTLP1FLAGS$M_IPC_CLEAN = 2;
literal CTLP1FLAGS$M_PSX_PML = 4;
literal CTLP1FLAGS$M_PSX_PML_ERROR = 8;
literal CTLP1FLAGS$S_CTLP1DEF = 1;
macro CTLP1FLAGS$V_GSD_CLEAN = 0,0,1,0 %; !  GSD clean-up is in progress
macro CTLP1FLAGS$V_IPC_CLEAN = 0,1,1,0 %; !  $IPC association clean-up is in progress
macro CTLP1FLAGS$V_PSX_PML = 0,2,1,0 %; !  POSIX Dynamic Memory Locking requested 
macro CTLP1FLAGS$V_PSX_PML_ERROR = 0,3,1,0 %; !  POSIX Dynamic Memory Locking error
 
!*** MODULE $CWPSDEF ***
! +
!  cwpssrv - Common service structure header
! 
!   All cwpsxxx$ packets contain the following header information.
! 
!  Fields marked with ++ must be filled/zeroed by service-specific
!  routines (at least for pcntrl services)
!  
! -
! 
!  The CWPSSRV$ structure is exchanged with remote nodes.  Any updates to this
!  structure must take mixed-version operation into account.
! 
literal cwpssrv$m_btx_done = 1;
literal cwpssrv$m_sec_class = 1;
literal cwpssrv$m_jpibuf = 2;
literal cwpssrv$m_noquota = 4;
literal cwpssrv$k_retry_cnt = 5;        !  five retries is about
!   4 seconds
literal cwpssrv$k_length = 112;         !  length of data structure common
literal cwpssrv$k_srvcode_begin = 0;    !  - marker for beginning of codes
literal cwpssrv$k_canwak = 1;           !  $CANWAK service
literal cwpssrv$k_delprc = 2;           !  $DELPRC service
literal cwpssrv$k_forcex = 3;           !  $FORCEX service
literal cwpssrv$k_resume = 4;           !  $RESUME service
literal cwpssrv$k_schdwk = 5;           !  $SCHDWK service
literal cwpssrv$k_setpri = 6;           !  $SETPRI service
literal cwpssrv$k_suspnd = 7;           !  $SUSPND service
literal cwpssrv$k_wake = 8;             !  $WAKE service
literal cwpssrv$k_srvcode_end = 9;      !  - marker for end of SRV codes
!  CWPS subtypes for other services
literal cwpssrv$k_getjpi = 20;          !  $GETJPI service
literal cwpssrv$k_creprc = 21;          !  $CREPRC service
literal cwpssrv$k_termin = 22;          !  process termination message
!  CWPS subtypes for security service codes
literal cwpssrv$k_grantid = 28;         !  $GRANTID service
literal cwpssrv$k_revokid = 29;         !  $WAKE service
literal cwpssrv$k_version_1 = 1;        !  initial version
literal cwpssrv$k_version_2 = 2;
literal cwpssrv$k_version_3 = 3;
literal cwpssrv$k_version_4 = 4;
literal cwpssrv$k_version_5 = 5;
literal cwpssrv$k_version_6 = 6;
literal cwpssrv$k_version_7 = 7;
literal cwpssrv$k_version_8 = 8;
literal cwpssrv$k_version_9 = 9;
literal cwpssrv$k_version_10 = 10;
literal cwpssrv$k_version_11 = 11;
literal cwpssrv$k_version_12 = 12;
literal cwpssrv$k_initial_maj_vers = 1;
literal cwpssrv$k_initial_min_vers = 1;
literal cwpssrv$S_$cwpssrvdef = 112;
macro cwpssrv$l_send_length = 0,0,32,0 %; !  length sent to partner
macro cwpssrv$l_return_length = 4,0,32,0 %; !  length returned from partner
macro cwpssrv$w_size = 8,0,16,0 %;      !  size of structure	++
macro cwpssrv$b_type = 10,0,8,0 %;      !  structure type code	++
macro cwpssrv$b_subtype = 11,0,8,0 %;   !  structure subtype and service code  ++
macro cwpssrv$w_btx_status = 12,0,16,0 %; !  status of block transfer request
macro cwpssrv$b_btx_flags = 14,0,8,0 %; !  state of block transfer
macro cwpssrv$v_btx_done = 14,0,1,0 %;  !  block transfer is complete
macro cwpssrv$b_func = 15,0,8,0 %;      !  CLSMSG request function code
macro cwpssrv$w_srv_maj_vers = 16,0,16,0 %; !  incompatible version formats
macro cwpssrv$w_srv_min_vers = 18,0,16,0 %; !  upwards compatible extensions
macro cwpssrv$w_ext_maj_vers = 20,0,16,0 %; !  incompatible version formats
macro cwpssrv$w_ext_min_vers = 22,0,16,0 %; !  upwards compatible extensions
macro cwpssrv$l_status = 24,0,32,0 %;   !  status from remote service
macro cwpssrv$l_bxfr_status = 28,0,32,0 %; !  status from block transfer
macro cwpssrv$l_maximum_length = 32,0,32,0 %; !  maximum possible return length
macro cwpssrv$l_flags = 36,0,32,0 %;    !  longword of flags
macro cwpssrv$v_sec_class = 36,0,1,0 %; !  sec class present...
macro cwpssrv$v_jpibuf = 36,1,1,0 %;    !  jpi requests buffered
macro cwpssrv$v_noquota = 36,2,1,0 %;   !  quota has not been charged
macro cwpssrv$l_ext_offset = 40,0,32,0 %; !  offset to service-specific extension
macro cwpssrv$a_post_routine = 44,0,32,0 %; !  address of post-processing routine  ++
macro cwpssrv$l_rqstr_csid = 48,0,32,0 %; !  CSID of the requestor's node
macro cwpssrv$l_rqstr_pid = 52,0,32,0 %; !  IPID of the requestor
macro cwpssrv$l_rqstr_epid = 56,0,32,0 %; !  EPID of the requestor
macro cwpssrv$l_rqstr_imgcnt = 60,0,32,0 %; !  image count of requestor
macro cwpssrv$l_rqstr_rightslen = 64,0,32,0 %; !  length of process rights info
macro cwpssrv$l_rqstr_rightsoff = 68,0,32,0 %; !  offset to start of rights info
macro cwpssrv$l_rqstr_pidadr = 72,0,32,0 %; !  original pid address from user
macro cwpssrv$l_partner_csid = 76,0,32,0 %; !  CSID of the partner node
macro cwpssrv$l_sought_epid = 80,0,32,0 %; !  epid for target process
macro cwpssrv$l_return_epid = 84,0,32,0 %; !  actual epid from target process
macro cwpssrv$w_prcnamlen = 88,0,16,0 %; !  length of target process name
macro cwpssrv$w_prcnamoff = 90,0,16,0 %; !  offset to start of target process name
macro cwpssrv$l_free_offset = 92,0,32,0 %; !  offset to free data area
macro cwpssrv$l_spare1 = 96,0,32,0 %;   !  zero if unused
macro cwpssrv$w_spare2 = 100,0,16,0 %;  !  zero if unused
macro cwpssrv$b_spare3 = 102,0,8,0 %;   !  zero if unused
macro cwpssrv$b_retries_left = 103,0,8,0 %; !  number of retries remaining
macro cwpssrv$q_time = 104,0,0,0 %;
literal cwpssrv$s_time = 8;             !  time structure allocated
literal cwps$_enabled = 1;              !  assemble the code
literal cwps$_nervous = 1;              !  do reasonable checking
literal cwps$_scared = 1;               !  do a lot of consistency checking
literal cwps$_paranoid = 1;             !  do excessive checking
literal cwps$_statistics = 1;           !  collect statistics
literal cwpscan$k_length = 0;           !  length of $CANWAK
literal cwpsdel$k_length = 0;           !  length of $DELPRC
literal cwpsres$k_length = 0;           !  length of $RESUME
literal cwpssus$k_length = 0;           !  length of $SUSPND
literal cwpswak$k_length = 0;           !  length of $WAKE
! 
!  The CWPSFEX$ structure is exchanged with remote nodes.  Any updates to this
!  structure must take mixed-version operation into account.
! 
literal cwpsfex$k_length = 4;           !  length of data structure
literal cwpsfex$S_$cwpsfexdef = 4;
macro cwpsfex$l_code = 0,0,32,0 %;      !  code to pass to remote
! 
!  The CWPSPRI$ structure is exchanged with remote nodes.  Any updates to this
!  structure must take mixed-version operation into account.
! 
literal cwpspri$k_length = 12;          !  length of data structure
literal cwpspri$S_$cwpspridef = 12;
macro cwpspri$l_user_prvpri = 0,0,32,0 %; !  address of user's cell
macro cwpspri$l_pri = 4,0,32,0 %;       !  priority we send to remote
macro cwpspri$l_prvpri = 8,0,32,0 %;    !  priority we receive from remote
! 
!  The CWPSSWK$ structure is exchanged with remote nodes.  Any updates to this
!  structure must take mixed-version operation into account.
! 
literal cwpsswk$k_length = 16;          !  length of data structure
literal cwpsswk$S_$cwpsswkdef = 16;
macro cwpsswk$q_daytim = 0,0,0,0 %;
literal cwpsswk$s_daytim = 8;           !  time to wake up
macro cwpsswk$q_reptim = 8,0,0,0 %;
literal cwpsswk$s_reptim = 8;           !  time to repeat wake up
! 
!  The CWPSJPI$ structure is exchanged with remote nodes.  Any updates to this
!  structure must take mixed-version operation into account.
! 
literal cwpsjpi$k_length = 60;          !  length of data structure
literal cwpsjpi$S_$cwpsjpidef = 60;
macro cwpsjpi$l_pscan_off = 0,0,32,0 %; !  offset to start of pscanctx
macro cwpsjpi$l_itmoff = 4,0,32,0 %;    !  offset to item list in structure
macro cwpsjpi$l_bufoff = 8,0,32,0 %;    !  offset to return buffer
macro cwpsjpi$l_vecoff = 12,0,32,0 %;   !  offset to vector for item addr
macro cwpsjpi$l_acboff = 16,0,32,0 %;   !  offset to acb structure
macro cwpsjpi$l_itmlst = 20,0,32,0 %;   !  address of original item list
macro cwpsjpi$l_buflen = 24,0,32,0 %;   !  length of user's buffers
macro cwpsjpi$l_iosbadr = 28,0,32,0 %;  !  user's I/O status address
macro cwpsjpi$q_iosb = 32,0,0,0 %;
literal cwpsjpi$s_iosb = 8;             !  return iosb contents
macro cwpsjpi$l_astadr = 40,0,32,0 %;   !  AST address
macro cwpsjpi$l_astprm = 44,0,32,0 %;   !  AST parameter
macro cwpsjpi$l_pscanctx_addr = 48,0,32,0 %; !  PSCANCTX record address
macro cwpsjpi$w_pscan_seqnum = 52,0,16,0 %; !  sequence number of PSCANCTX
macro cwpsjpi$b_efn = 54,0,8,0 %;       !  event flag to set 
macro cwpsjpi$b_acmode = 55,0,8,0 %;    !  access mode of original call
macro cwpsjpi$w_ctlflags = 56,0,16,0 %; !  JPI$_GETJPI_CONTROL_FLAGS bits
macro cwpsjpi$w_spare0 = 58,0,16,0 %;   !  spare, align
! 
!  The CWPSVEC$ structure is a local structure.  If modified, you do not need
!  to take mixed-version operation into account, however you must be sure that
!  all modules and images which reference the structure are updated together.
! 
literal cwpsvec$k_length = 8;           !  length of data structure
literal cwpsvec$S_$cwpsvecdef = 8;
macro cwpsvec$l_usr_bufadr = 0,0,32,0 %; !  user's address for buffer items
macro cwpsvec$l_usr_lenadr = 4,0,32,0 %; !  user's address for returned length
! 
!  The CWPSACB$ structure is a local structure.  If modified, you do not need
!  to take mixed-version operation into account, however you must be sure that
!  all modules and images which reference the structure are updated together.
! 
literal cwpsacb$k_acb_length = 28;      !  length of embedded block
literal cwpsacb$k_length = 80;          !  length of data structure (less PCB)
literal cwpsacb$S_$cwpsacbdef = 81;
macro cwpsacb$l_astqfl = 0,0,32,0 %;    !  ast queue forward link 
macro cwpsacb$l_astqbl = 4,0,32,0 %;    !  ast queue backward link 
macro cwpsacb$w_size = 8,0,16,0 %;      !  structure size in bytes 
macro cwpsacb$b_type = 10,0,8,0 %;      !  structure type code 
macro cwpsacb$b_rmod = 11,0,8,0 %;      !  request access mode 
macro cwpsacb$l_pid = 12,0,32,0 %;      !  process id of request 
macro cwpsacb$l_ast = 16,0,32,0 %;      !  ast routine address 
macro cwpsacb$l_astprm = 20,0,32,0 %;   !  ast parameter 
macro cwpsacb$l_kast = 24,0,32,0 %;     !  internal kernel mode xfer address 
macro cwpsacb$l_bufadr = 28,0,32,0 %;   !  address of buffer
macro cwpsacb$l_buflen = 32,0,32,0 %;   !  length of the buffer
macro cwpsacb$l_msgbuf = 36,0,32,0 %;   !  message buffer address
macro cwpsacb$l_csb = 40,0,32,0 %;      !  csb address
macro cwpsacb$l_cdrp = 44,0,32,0 %;     !  cdrp address
macro cwpsacb$l_read_length = 48,0,32,0 %; !  length of bxfr read request
macro cwpsacb$l_write_length = 52,0,32,0 %; !  length of bxfr write request
macro cwpsacb$l_rightsdesc = 56,0,0,0 %;
literal cwpsacb$s_rightsdesc = 8;       !  descriptor for rightslist
macro cwpsacb$b_func = 64,0,8,0 %;      !  function code from message
macro cwpsacb$b_spare0 = 65,0,8,0 %;
macro cwpsacb$w_spare1 = 66,0,16,0 %;
macro cwpsacb$l_spare2 = 68,0,32,0 %;   !  trojan PCB should be octaword
macro cwpsacb$l_spare3 = 72,0,32,0 %;   !  aligned
macro cwpsacb$l_spare4 = 76,0,32,0 %;
macro cwpsacb$b_trojan_pcb = 80,0,8,0 %; !  start of false PCB
! 
!  The CWPSSQH$ structure is a local structure.  If modified, you do not need
!  to take mixed-version operation into account, however you must be sure that
!  all modules and images which reference the structure are updated together.
! 
literal cwpssqh$k_length = 32;          !  length of data structure
literal cwpssqh$S_$cwpssqhdef = 32;
macro cwpssqh$l_flink = 0,0,32,0 %;     !  forward link
macro cwpssqh$l_blink = 4,0,32,0 %;     !  back link
macro cwpssqh$w_size = 8,0,16,0 %;      !  size of structure (SQH only)
macro cwpssqh$b_type = 10,0,8,0 %;      !  structure type code
macro cwpssqh$b_subtype = 11,0,8,0 %;   !  structure subtype
macro cwpssqh$l_alloc_length = 12,0,32,0 %; !  actual length of allocation
macro cwpssqh$l_mpid = 16,0,32,0 %;     !  master pid
macro cwpssqh$l_spare0 = 20,0,32,0 %;   !  enough to make it octaword
macro cwpssqh$l_spare1 = 24,0,32,0 %;   !  aligned...
macro cwpssqh$l_spare3 = 28,0,32,0 %;
! 
!  The CWPSNODI*$ structures are local structures.  If modified, you do not need
!  to take mixed-version operation into account, however you must be sure that
!  all modules and images which reference the structures are updated together.
! 
literal cwpsnodih$k_header = 16;        !  length of data structure
literal cwpsnodih$S_$cwpsnodihdef = 17;
macro cwpsnodih$l_flink = 0,0,32,0 %;   !  forward link
macro cwpsnodih$l_blink = 4,0,32,0 %;   !  back link
macro cwpsnodih$w_size = 8,0,16,0 %;    !  size of structure
macro cwpsnodih$b_type = 10,0,8,0 %;    !  structure type code
macro cwpsnodih$b_subtype = 11,0,8,0 %; !  structure subtype
macro cwpsnodih$l_count = 12,0,32,0 %;  !  count of nodes
macro cwpsnodih$b_node_list = 16,0,8,0 %; !  start of list of node blocks
literal cwpsnodi$k_length = 28;         !  length of data structure
literal cwpsnodi$S_$cwpsnodidef = 28;
macro cwpsnodi$l_hwtype = 0,0,32,0 %;   !  hardware type (and flink)
macro cwpsnodi$w_hw_model = 4,0,16,0 %; !  integer model code
macro cwpsnodi$l_csid = 8,0,32,0 %;     !  node's csid
macro cwpsnodi$b_name = 12,0,0,0 %;
literal cwpsnodi$s_name = 16;           !  node's name (ASCIC)
 
!*** MODULE $CXBDEF ***
!  +
!   CXB - COMPLEX CHAINED BUFFER
!  
!   THESE OFFSETS ARE USED IN THE HEADER OF DISJOINT SEGMENTS
!   WHICH ARE TO BE PRESENTED TO THE USER AS A UNIT.
!  
!  -
literal CXB$M_RESP = 1;
literal CXB$L_NI_ALTXMT = 28;           !  ALTSTART XMT parameters
literal CXB$C_AGENT_SCRATCH_LEN = 44;
!  This marks the length of the standard CXB.
literal CXB$K_LENGTH = 84;
literal CXB$C_LENGTH = 84;
!  Data link layer scratch space
literal CXB$M_FLTR_MCA = 1;
literal CXB$M_FLTR_CTL = 2;
literal CXB$M_FLTR_SRC = 4;
literal CXB$M_FLTR_STARTUP = 1;
literal CXB$M_FLTR_INTXMIT = 2;
literal CXB$T_R_DATA = 120;             !  Start of RCV data
literal CXB$W_R_LEN_802 = 132;          !  802 length field
literal CXB$T_R_USER_ETH = 134;         !  Start of user ETH data
literal CXB$W_R_SIZE = 134;             !  Size of message if padded
literal CXB$X_R_CTL = 136;              !  802 CTL field
literal CXB$G_R_PID = 137;              !  5-byte Protocol Identifier
literal CXB$T_R_USER_802E = 142;        !  Start of user 802E data
literal CXB$C_DLL = 52;                 !  Size of CXB$T_DLL 
literal CXB$C_DLL_SCRATCH_LEN = 52;     !  Size of CXB$T_DLL 
!  ** This field must be quadword aligned for CNDRIVER.
literal CXB$K_HEADER = 136;             !  CXB size up to this point 
literal CXB$C_HEADER = 136;             !  CXB size up to this point 
literal CXB$C_TRAILER = 4;              !  Space after CXB data for CRC code 
literal CXB$K_OVERHEAD = 140;           !  CXB$C_HEADER + CXB$C_TRAILER 
literal CXB$C_OVERHEAD = 140;           !  CXB$C_HEADER + CXB$C_TRAILER 
literal CXB$S_CXBDEF = 140;
macro CXB$L_FL = 0,0,32,0 %;            !  Forward queue link 
macro CXB$L_BL = 4,0,32,0 %;            !  Backward queue link 
macro CXB$W_SIZE = 8,0,16,0 %;          !  Block size 
macro CXB$B_TYPE = 10,0,8,0 %;          !  Block type 
macro CXB$B_FLAG = 11,0,8,0 %;          !  Flag byte
macro CXB$V_RESP = 11,0,1,0 %;          !   Command/Response indicator
macro CXB$W_BOFF = 12,0,16,0 %;         !  Offset to data link data
macro CXB$W_BCNT = 14,0,16,0 %;         !  Size of data link data
macro CXB$L_DATA_CHAIN = 16,0,32,0 %;   !  Pointer to data chain buffer descriptor
macro CXB$Q_STATION = 20,0,0,0 %;
literal CXB$S_STATION = 8;              !  Contains destination address or source address
macro CXB$W_CTL = 28,0,16,0 %;          !  802.2 ctl field either byte or word value
macro CXB$B_CTL_SIZE = 30,0,8,0 %;      !  802.2 ctl field value size
macro CXB$B_DSAP = 31,0,8,0 %;          !  802.2 ALT/FFI XMT dest sap
macro CXB$Q_RESERVED = 32,0,0,0 %;
literal CXB$S_RESERVED = 8;             !  Reserved for future use
!  Agent specific scratch space.
macro CXB$T_AGENT_SCRATCH = 40,0,0,0 %;
literal CXB$S_AGENT_SCRATCH = 44;
!  DECnet-VAX agent specific fields.
macro CXB$T_AGENT_DECNET = 40,0,0,0 %;
literal CXB$S_AGENT_DECNET = 44;
macro CXB$W_LENGTH = 40,0,16,0 %;       !  Length of data 
macro CXB$W_OFFSET = 42,0,16,0 %;       !  Offset to start of nsp message 
macro CXB$B_CODE = 44,0,8,0 %;          !  Buffer code 
macro CXB$B_STS = 45,0,8,0 %;           !  Status fields
macro CXB$W_CHANNEL = 46,0,16,0 %;      !  Store channel number for AST 
macro CXB$L_LINK = 48,0,32,0 %;         !  Link word for chained data message 
macro CXB$L_IRP = 52,0,32,0 %;          !  IRP address for transmits 
macro CXB$L_END_ACTION = 56,0,32,0 %;   !  Pointer to I/O done routine
!  The following fields contain the context that NSP needs to process a packet
!  which has been received out of order.
macro CXB$L_R_NSP_MSG = 60,0,32,0 %;    !  This is the address of the next
!  byte in the NSP message after
!  the segment number field (R1)
macro CXB$L_R_DATA_SIZE = 64,0,32,0 %;  !  This is the number of as yet
!  unaccounted bytes in message (R2)
macro CXB$W_R_SEG_NUM = 68,0,16,0 %;    !  This is the messages segment number (R3)
!   Backlink pointer for NSP to associate the CXB with the user's originating
!   IRP.  The non-agent specific field, CXB$L_IRP, cannot be used because the
!   datalink drivers use this field for the same purpose, but different IRP.
!   The datalink's IRP is the DECnet routing supplied IRP queued to the 
!   altstart interface.
macro CXB$L_USER_IRP = 70,0,32,0 %;     !  link to user's IRP
macro CXB$L_LAST_DCB = 74,0,32,0 %;     !  pointer to last DCB
!  Size of the agent scratch area 
macro CXB$T_DLL = 84,0,0,0 %;
literal CXB$S_DLL = 52;
!  The following three structures define the fields used by the
!  Ethernet/802 datalink drivers.
macro CXB$T_DLL_NI802 = 84,0,0,0 %;
literal CXB$S_DLL_NI802 = 52;
macro CXB$B_NI_FUNC = 84,0,8,0 %;       !  Internal function code
macro CXB$B_R_FLAGS = 85,0,8,0 %;       !  Flags
macro CXB$W_NI_RID = 86,0,16,0 %;       !  Request ID
macro CXB$B_NI_SLOT = 86,0,8,0 %;       !  Mapping slot number
macro CXB$B_NI_RING = 87,0,8,0 %;       !  Ring Entry number
macro CXB$L_T_IRP = 88,0,32,0 %;        !  User IRP address
macro CXB$W_R_NCHAIN = 92,0,16,0 %;     !  Number of buffers in chain
macro CXB$W_R_LENERR = 94,0,16,0 %;     !  Length and Rcv error status
macro CXB$L_R_UCB = 96,0,32,0 %;        !  UCB address of receiver
macro CXB$W_HDR_SIZE = 100,0,16,0 %;    !  Size of receive header
macro CXB$B_R_FMT = 102,0,8,0 %;        !  Receive packet format
macro CXB$r_filter = 103,0,8,0 %;
literal CXB$s_filter = 1;
macro CXB$B_R_FILTER = 103,0,8,0 %;     !  Receive CXB filtering mask word
macro CXB$V_FLTR_MCA = 103,0,1,0 %;     !  MCA filtering has been performed
macro CXB$V_FLTR_CTL = 103,1,1,0 %;     !  CTL filtering has been performed
macro CXB$V_FLTR_SRC = 103,2,1,0 %;     !  SRC filtering has been performed
macro CXB$B_T_FILTER = 103,0,8,0 %;     !  Transmit CXB filtering mask word
macro CXB$V_FLTR_STARTUP = 103,0,1,0 %; !  Delete CXB, complete IRP
macro CXB$V_FLTR_INTXMIT = 103,1,1,0 %; !  Add CXB to Receive list
macro CXB$T_DLL_NI802XMT = 84,0,0,0 %;
literal CXB$S_DLL_NI802XMT = 52;
macro CXB$T_T_DATA = 122,0,0,0 %;
literal CXB$S_T_DATA = 14;              !  Start of standard XMT
macro CXB$T_DLL_NI802RCV = 84,0,0,0 %;
literal CXB$S_DLL_NI802RCV = 52;
macro CXB$G_R_DEST = 120,0,0,0 %;
literal CXB$S_R_DEST = 6;               !  Destination address
macro CXB$G_R_SRC = 126,0,0,0 %;
literal CXB$S_R_SRC = 6;                !  Source address
macro CXB$W_R_PTYPE = 132,0,16,0 %;     !  Protocol type
macro CXB$B_R_DSAP = 134,0,8,0 %;       !  802 DSAP field
macro CXB$B_R_SSAP = 135,0,8,0 %;       !  802 SSAP field
!  the CRC trailer
 
!*** MODULE $DALDEF ***
! +
!  DAL - Device Allocation Lock (value block contents)
! 
!  This structure defines the contents of the lock value block for a 
!  device allocation lock.
! -
literal DAL$M_NOTFIRST_MNT = 1;
literal DAL$M_FOREIGN = 2;
literal DAL$M_GROUP = 4;
literal DAL$M_SYSTEM = 8;
literal DAL$M_WRITE = 16;
literal DAL$M_NOQUOTA = 32;
literal DAL$M_OVR_PROT = 64;
literal DAL$M_OVR_OWNUIC = 128;
literal DAL$M_NOINTERLOCK = 256;
literal DAL$M_SHADOW_MBR = 512;
literal DAL$S_DALDEF = 8;
macro DAL$W_FLAGS = 0,0,16,0 %;         !  Device usage flags:
macro DAL$V_NOTFIRST_MNT = 0,0,1,0 %;   !    not first time device mounted.
macro DAL$V_FOREIGN = 0,1,1,0 %;        !    device mounted /FOREIGN
macro DAL$V_GROUP = 0,2,1,0 %;          !    device mounted /GROUP
macro DAL$V_SYSTEM = 0,3,1,0 %;         !    device mounted /SYSTEM
macro DAL$V_WRITE = 0,4,1,0 %;          !    write access allowed
macro DAL$V_NOQUOTA = 0,5,1,0 %;        !    quota checking disabled
macro DAL$V_OVR_PROT = 0,6,1,0 %;       !    override protection
macro DAL$V_OVR_OWNUIC = 0,7,1,0 %;     !    override volume ownership
macro DAL$V_NOINTERLOCK = 0,8,1,0 %;    !    access NOT VAXcluster interlocked
macro DAL$V_SHADOW_MBR = 0,9,1,0 %;     !    shadow set member
macro DAL$W_PROTECTION = 2,0,16,0 %;    !  Volume protection
macro DAL$L_OWNER_UIC = 4,0,32,0 %;     !  Volume owner UIC
 
!*** MODULE $DCBDEF ***
!  +
!   DCB - Data link layer chained buffer descriptor
!  
!   This descriptor may be used in onw of two ways. The first way is to 
!   use this descriptor to describe a direct I/O transfer. The second 
!   is to use this descriptor to describe a chain of buffers to transmit
!   or a chain of buffers which have been received.
!  
!  -
literal DCB$M_TYPE_IO = 1;
literal DCB$K_HEADER = 28;              !  DCB size up to this point 
literal DCB$C_HEADER = 28;              !  DCB size up to this point 
literal DCB$S_DCBDEF = 28;
macro DCB$L_FLINK = 0,0,32,0 %;         !  Forward link
macro DCB$L_BLINK = 4,0,32,0 %;         !  Backward link
macro DCB$W_SIZE = 8,0,16,0 %;          !  Size of block
macro DCB$B_TYPE = 10,0,8,0 %;          !  Type of block
macro DCB$B_MODE = 11,0,8,0 %;          !  Access mode of agent
macro DCB$L_LINK = 12,0,32,0 %;         !  Link to next buffer in chain
macro DCB$W_STS = 16,0,16,0 %;          !  Describe I/O
macro DCB$V_TYPE_IO = 16,0,1,0 %;       !  If set DIRECT if clear buffered
macro DCB$W_RESV = 18,0,16,0 %;         !  Reserved for future use
macro DCB$L_SVAPTE = 20,0,32,0 %;       !  SVAPTE of buffer if not specified
!  then the buffer is embedded 
!  in this buffer
macro DCB$W_BOFF = 24,0,16,0 %;         !  Offset to start of data. Data
!  link headers must be back built
!  from this offset.
macro DCB$W_BCNT = 26,0,16,0 %;         !  For transmits size in bytes of this
!  segment of the data. For receives
!  contains the size of the segment
!  of data contained in this buffer.
 
!*** MODULE $DDBDEF ***
! +
!  DDB - DEVICE DATA BLOCK
! 
!  THERE IS ONE DEVICE DATA BLOCK FOR EACH CONTROLLER IN A SYSTEM.
! +
literal DDB$K_PACK = 1;                 ! LARGE DISK PACKS 
literal DDB$K_CART = 2;                 ! DISK CARTRIDGES 
literal DDB$K_SLOW = 3;                 ! SLOW (CHEAP) DISKS (E.G., FLOPPY) 
literal DDB$K_TAPE = 4;                 ! BLOCK STRUCTURED TAPE (E.G., TU58) 
literal DDB$K_LENGTH = 68;              ! LENGTH OF STANDARD DDB 
literal DDB$C_LENGTH = 68;              ! LENGTH OF STANDARD DDB 
literal DDB$S_DDBDEF = 68;
macro DDB$L_LINK = 0,0,32,0 %;          ! ADDRESS OF NEXT DDB IN LIST (0=LAST) 
macro DDB$L_UCB = 4,0,32,0 %;           ! ADDRESS OF FIRST UCB FOR THIS DDB 
macro DDB$W_SIZE = 8,0,16,0 %;          ! SIZE OF DDB IN BYTES 
macro DDB$B_TYPE = 10,0,8,0 %;          ! TYPE OF DATA STRUCTURE FOR DDB 
macro DDB$L_DDT = 12,0,32,0 %;          ! ADDRESS OF THE DRIVER DISPATCH TABLE 
macro DDB$L_ACPD = 16,0,32,0 %;         ! NAME OF DEFAULT ACP FOR DEVICE UNITS 
macro DDB$B_ACPCLASS = 19,0,8,0 %;      ! CLASS CODE OF DEFAULT ACP 
! ACP CLASS CODE FOR DISKS 
macro DDB$T_NAME = 20,0,0,0 %;
literal DDB$S_NAME = 16;                !    OF THE DEVICE 
!  AS AN
macro DDB$B_NAME_LEN = 20,0,8,0 %;      !  	CHARACTER COUNT
macro DDB$T_NAME_STR = 21,0,0,0 %;
literal DDB$S_NAME_STR = 15;            !  	CHARACTER STRING
macro DDB$T_DRVNAME = 36,0,0,0 %;
literal DDB$S_DRVNAME = 16;             ! 
!  AS AN
macro DDB$B_DRVNAM_LEN = 36,0,8,0 %;    !  	CHARACTER COUNT
macro DDB$T_DRVNAM_STR = 37,0,0,0 %;
literal DDB$S_DRVNAM_STR = 15;          !  	CHARACTER STRING
macro DDB$L_SB = 52,0,32,0 %;           ! ADDR OF SYSTEMBLOCK
macro DDB$L_CONLINK = 56,0,32,0 %;      ! NEXT DDB IN CONNECTION SUB-CHAIN
macro DDB$L_ALLOCLS = 60,0,32,0 %;      ! DEVICE ALLOCATION CLASS
macro DDB$L_2P_UCB = 64,0,32,0 %;       !  ADDRESS OF FIRST UCB ON SECONDARY PATH
macro DDB$L_DP_UCB = 64,0,32,0 %;       !  OLD STYLE SYNONYM FOR ABOVE
 
!*** MODULE $DDTDEF ***
! +
!  DDT - DRIVER DISPATCH TABLE
! 
!  EACH DEVICE DRIVER HAS A DRIVER DISPATCH TABLE.
! -
literal DDT$K_LENGTH = 72;              ! LENGTH OF DDT 
literal DDT$C_LENGTH = 72;              ! LENGTH OF DDT 
literal DDT$S_DDTDEF = 72;
macro DDT$L_START = 0,0,32,0 %;         ! ADDRESS OF DRIVER START I/O ROUTINE 
macro DDT$L_UNSOLINT = 4,0,32,0 %;      ! ADDRESS OF UNSOLICITED INTERRUPT ROUTINE 
macro DDT$L_FDT = 8,0,32,0 %;           ! ADDRESS OF FUNCTION DECISION TABLE 
macro DDT$L_CANCEL = 12,0,32,0 %;       ! ADDRESS OF CANCEL I/O ENTRY POINT 
macro DDT$L_REGDUMP = 16,0,32,0 %;      ! ADDRESS OF DEVICE REGISTER DUMP ROUTINE 
macro DDT$W_DIAGBUF = 20,0,16,0 %;      ! SIZE OF DIAGNOSTIC BUFFER IN BYTES 
macro DDT$W_ERRORBUF = 22,0,16,0 %;     ! SIZE OF ERROR LOG BUFFER IN BYTES 
macro DDT$L_UNITINIT = 24,0,32,0 %;     ! UNIT INITIALIZATION ENTRY POINT 
macro DDT$L_ALTSTART = 28,0,32,0 %;     ! ALTERNATE START I/O ENTRY POINT 
macro DDT$L_MNTVER = 32,0,32,0 %;       ! ADDRESS OF MOUNT VERIFICATION ROUTINE 
macro DDT$L_CLONEDUCB = 36,0,32,0 %;    ! ADDRESS OF CLONED UCB ENTRY POINT
macro DDT$W_FDTSIZE = 40,0,16,0 %;      ! SIZE OF FDT IN BYTES 
macro DDT$L_MNTV_SSSC = 44,0,32,0 %;    ! ADDRESS OF SHADOW SET STATE CHANGE MV ENTRY
macro DDT$L_MNTV_FOR = 48,0,32,0 %;     ! ADDRESS OF FOREIGN DEVICE MV ENTRY
macro DDT$L_MNTV_SQD = 52,0,32,0 %;     ! ADDRESS OF SEQUENTIAL DEVICE MV ENTRY
macro DDT$L_AUX_STORAGE = 56,0,32,0 %;  ! ADDRESS OF AUXILIARY STORAGE AREA
macro DDT$L_AUX_ROUTINE = 60,0,32,0 %;  ! ADDRESS OF AUXILIARY ROUTINE
macro DDT$L_CHANNEL_ASSIGN = 64,0,32,0 %; ! ADDRESS OF ROUTINE TO CALL FROM $ASSIGN
macro DDT$L_CANCEL_SELECTIVE = 68,0,32,0 %; ! ADDRESS OF SELECTIVE CANCEL I/O ENTRY POINT
 
!*** MODULE $DJIDEF ***
! 
!  Item codes for interface from job controller to LOGINOUT.
! 
literal DJI$K_CPU_MAXIMUM = 1;          !  (longword)	CPU maximum (10 ms units)
literal DJI$K_FILE_IDENTIFICATION = 2;  !  (28 bytes)	DVI, FID, DID of command procedure
literal DJI$K_FLAGS = 3;                !  (longword)	flags
literal DJI$K_JOB_NAME = 4;             !  (string)	job name
literal DJI$K_LOG_QUEUE = 5;            !  (string)	log file queue
literal DJI$K_LOG_SPECIFICATION = 6;    !  (string)	log file specification
literal DJI$K_PARAMETER_1 = 7;          !  (string)	value of P1
literal DJI$K_PARAMETER_2 = 8;          !  (string)	value of P2
literal DJI$K_PARAMETER_3 = 9;          !  (string)	value of P3
literal DJI$K_PARAMETER_4 = 10;         !  (string)	value of P4
literal DJI$K_PARAMETER_5 = 11;         !  (string)	value of P5
literal DJI$K_PARAMETER_6 = 12;         !  (string)	value of P6
literal DJI$K_PARAMETER_7 = 13;         !  (string)	value of P7
literal DJI$K_PARAMETER_8 = 14;         !  (string)	value of P8
literal DJI$K_RESTART = 15;             !  (string)	value of BATCH$RESTART
literal DJI$K_USERNAME = 16;            !  (string)	username
literal DJI$K_WSDEFAULT = 17;           !  (longword)	working set default
literal DJI$K_WSEXTENT = 18;            !  (longword)	working set extent
literal DJI$K_WSQUOTA = 19;             !  (longword)	working set quota
literal DJI$K_ADJUST_PRIORITY = 20;     !  (longword)   adjusted priority
literal DJI$K_CLI = 21;                 !  (string)	CLI name
literal DJI$K_CLASS = 22;               !  (20 bytes)	process classification
literal DJI$K_NOTE = 23;                !  (string)	the job's note
literal DJI$K_CHARGE_CODE_NAME = 24;    !  (string)	account or charge code name
literal DJI$K_INPUT_FLAGS = 32769;      !  (longword)	flags
literal DJI$K_CONDITION_VECTOR = 32770; !  (1 to 3 longwords) error conditions
literal DJI$K_FILE_SPECIFICATION = 32771; !  (string)	filespec of failed logfile
literal DJI$S_ITEM_HEADER = 4;
macro DJI$W_ITEM_SIZE = 0,0,16,0 %;     !  Item size
macro DJI$W_ITEM_CODE = 2,0,16,0 %;     !  Item code
! 
!  Structure of FLAGS item.
! 
literal DJI$M_DELETE_FILE = 1;
literal DJI$M_LOG_DELETE = 2;
literal DJI$M_LOG_NULL = 4;
literal DJI$M_LOG_SPOOL = 8;
literal DJI$M_NOTIFY = 16;
literal DJI$M_RESTARTING = 32;
literal DJI$M_TERMINATE = 64;
literal DJI$M_USE_CPU_MAXIMUM = 128;
literal DJI$M_USE_WSDEFAULT = 256;
literal DJI$M_USE_WSEXTENT = 512;
literal DJI$M_USE_WSQUOTA = 1024;
literal DJI$S_FLAGS = 4;
macro DJI$L_FLAGS = 0,0,32,0 %;
macro DJI$V_DELETE_FILE = 0,0,1,0 %;    !  delete command procedure
macro DJI$V_LOG_DELETE = 0,1,1,0 %;     !  delete log file
macro DJI$V_LOG_NULL = 0,2,1,0 %;       !  log specification is NLA0:
macro DJI$V_LOG_SPOOL = 0,3,1,0 %;      !  spool log file
macro DJI$V_NOTIFY = 0,4,1,0 %;         !  spool log file with /NOTIFY
macro DJI$V_RESTARTING = 0,5,1,0 %;     !  job is restarting
macro DJI$V_TERMINATE = 0,6,1,0 %;      !  job should terminate
macro DJI$V_USE_CPU_MAXIMUM = 0,7,1,0 %; !  use specified CPU_MAXIMUM
macro DJI$V_USE_WSDEFAULT = 0,8,1,0 %;  !  use specified WSDEFAULT
macro DJI$V_USE_WSEXTENT = 0,9,1,0 %;   !  use specified WSEXTENT
macro DJI$V_USE_WSQUOTA = 0,10,1,0 %;   !  use specified WSQUOTA
! 
!  Structure of INPUT_FLAGS item.
! 
literal DJI$M_NO_FILE = 1;
literal DJI$S_INPUT_FLAGS = 4;
macro DJI$L_INPUT_FLAGS = 0,0,32,0 %;
macro DJI$V_NO_FILE = 0,0,1,0 %;        !  do not return a file
 
!*** MODULE $DMBDEF ***
! +
!  DMB32 (BICOMBO) specific register definitions
! -
literal DMB$M_FORCE_FAIL = 1;
literal DMB$M_PROGRAM_RESET = 2;
literal DMB$M_PTE_VALID = 4;
literal DMB$M_SKIP_SELFTEST = 8;
literal DMB$M_MAINT_LEVEL1 = 16;
literal DMB$M_MAINT_LEVEL2 = 32;
literal DMB$M_SYNC = 256;
literal DMB$M_ASYNC = 512;
literal DMB$M_PRINT = 1024;
literal DMB$M_DIAG_FAIL = 2048;
literal DMB$M_X21_SUPPORT = 4096;
literal DMB$M_CABLE_KEY = 8192;
literal DMB$M_TURN_CONN = 16384;
literal DMB$M_MANF_CONN = 32768;
literal DMB$M_RX_I_E = 256;
literal DMB$M_TX_I_E = 512;
literal DMB$M_SYNC_I_E = 2048;
literal DMB$M_PR_I_E = 2048;
literal DMB$M_PR_DAVFU_READY = 65536;
literal DMB$M_PR_CONNECT_VERIFY = 131072;
literal DMB$M_PR_OFFLINE = 262144;
literal DMB$M_ASYNC_RESET = 1024;
literal DMB$M_SYNC_RESET = 1024;
literal DMB$M_PRINTER_RESET = 1024;
literal DMB$M_PR_DMA_START = 1;
literal DMB$M_PR_DMA_PTE = 2;
literal DMB$M_PR_DMA_PHYS = 4;
literal DMB$M_PR_DMA_ABORT = 256;
literal DMB$M_PR_FORMAT = 512;
literal DMB$M_PR_TAB = 16777216;
literal DMB$M_PR_TRUNC = 33554432;
literal DMB$M_PR_AUTO_RETURN = 67108864;
literal DMB$M_PR_AUTO_FORM = 134217728;
literal DMB$M_PR_NON_PRINT = 268435456;
literal DMB$M_PR_DAVFU = 536870912;
literal DMB$M_PR_WRAP = 1073741824;
literal DMB$M_PR_UPPER = -2147483648;
literal DMB$M_TX1_DMA_START = 1;
literal DMB$M_TX1_DMA_PTE = 2;
literal DMB$M_TX1_DMA_PHYS = 4;
literal DMB$M_TX1_X21 = 8;
literal DMB$M_TX1_PAR = 16;
literal DMB$M_TX1_DMA_ABORT = 256;
literal DMB$M_RX1_DMA_START = 1;
literal DMB$M_RX1_DMA_PTE = 2;
literal DMB$M_RX1_DMA_PHYS = 4;
literal DMB$M_RX1_X21 = 8;
literal DMB$M_RX1_DMA_ABORT = 256;
literal DMB$M_RX_ENABLE = 1;
literal DMB$M_RX_MATCH_ENA = 4;
literal DMB$M_RX_PRIMARY = 8;
literal DMB$M_X21ENABLE = 16;
literal DMB$M_CLOCK_CONTROL = 64;
literal DMB$M_CODING_TYPE = 128;
literal DMB$M_BAUD_RATE = 3840;
literal DMB$M_LOOP = 4096;
literal DMB$M_V35_SELECT = 8192;
literal DMB$M_V10_SELECT = 16384;
literal DMB$M_MODEM_SUPPRESS = 32768;
literal DMB$M_LINE_RESET = -2147483648;
literal DMB$M_SYNC_ML1 = 1;
literal DMB$M_SYNC_DTR = 2;
literal DMB$M_SYNC_DRS = 4;
literal DMB$M_SYNC_ML2 = 8;
literal DMB$M_SYNC_RTS = 16;
literal DMB$M_SPARE_MODEM = 224;
literal DMB$M_SYNC_RXCLOCK = 256;
literal DMB$M_SYNC_TXCLOCK = 512;
literal DMB$M_SYNC_TI = 1024;
literal DMB$M_SYNC_CTS = 4096;
literal DMB$M_SYNC_DCD = 8192;
literal DMB$M_SYNC_RI = 16384;
literal DMB$M_SYNC_DSR = 32768;
literal DMB$M_PROTOCOL = 458752;
literal DMB$C_PRO_DDCMP = 0;
literal DMB$C_PRO_SDLC = 1;
literal DMB$C_PRO_HDLC = 2;
literal DMB$C_PRO_BISYNC = 3;
literal DMB$C_PRO_GENBYTE = 7;
literal DMB$M_ERROR_TYPE = 3670016;
literal DMB$C_ERR_CRC1 = 0;
literal DMB$C_ERR_CRC0 = 1;
literal DMB$C_ERR_LVE = 2;
literal DMB$C_ERR_CRC16 = 3;
literal DMB$C_ERR_LRC0 = 4;
literal DMB$C_ERR_LRCE = 5;
literal DMB$C_ERR_LVO = 6;
literal DMB$C_NOCON = 7;
literal DMB$M_RX_BPC = 29360128;
literal DMB$M_TX_BPC = 234881024;
literal DMB$M_STRIP_SYNC = 268435456;
literal DMB$M_EBCDIC_CODE = 536870912;
literal DMB$M_IDLE_SYNC = 1073741824;
literal DMB$M_MODEM_OVERRIDE = -2147483648;
literal DMB$M_TX2_DMA_START = 1;
literal DMB$M_TX2_DMA_PTE = 2;
literal DMB$M_TX2_DMA_PHYS = 4;
literal DMB$M_TX2_X21 = 8;
literal DMB$M_TX2_PAR = 16;
literal DMB$M_TX2_DMA_ABORT = 256;
literal DMB$M_RX2_DMA_START = 1;
literal DMB$M_RX2_DMA_PTE = 2;
literal DMB$M_RX2_DMA_PHYS = 4;
literal DMB$M_RX2_X21 = 8;
literal DMB$M_RX2_DMA_ABORT = 256;
literal DMB$M_SYNC_CABLE = 251658240;
literal DMB$M_SYNC_LOOP = 536870912;
literal DMB$M_SYNC_VALID = 1073741824;
literal DMB$M_SYNC_X21 = -2147483648;
literal DMB$M_PREEMPT_GO = 32768;
literal DMB$M_ML = 1;
literal DMB$M_DTR = 2;
literal DMB$M_DRS = 4;
literal DMB$M_RTS = 16;
literal DMB$M_TX_INT_DELAY = 512;
literal DMB$M_RX_ENA = 1024;
literal DMB$M_BREAK = 2048;
literal DMB$M_MAINT = 12288;
literal DMB$M_REPORT_MODEM = 16384;
literal DMB$M_DISCARD_FLOW = 32768;
literal DMB$M_CHAR_LENGTH = 196608;
literal DMB$M_PARITY_ENAB = 262144;
literal DMB$M_EVEN_PARITY = 524288;
literal DMB$M_STOP_CODE = 1048576;
literal DMB$M_USE_CTS = 2097152;
literal DMB$M_IAUTO_FLOW = 4194304;
literal DMB$M_OAUTO_FLOW = 8388608;
literal DMB$M_RX_SPEED = 251658240;
literal DMB$M_TX_SPEED = -268435456;
literal DMB$M_TX_DMA_START = 1;
literal DMB$M_TX_DMA_PTE = 2;
literal DMB$M_TX_DMA_PHYS = 4;
literal DMB$M_TX_OUT_ABORT = 256;
literal DMB$M_ML2 = 1024;
literal DMB$M_CTS = 4096;
literal DMB$M_DCD = 8192;
literal DMB$M_RI = 16384;
literal DMB$M_DSR = 32768;
literal DMB$M_SNDOFF = 8388608;
literal DMB$M_TX_ENA = -2147483648;
literal DMB$M_TX_PREEMPT = 256;
literal DMB$M_TX_FIFO_DONE = 512;
literal DMB$M_TX_ACT = -2147483648;
literal DMB$M_SYNC_MODEM = 256;
literal DMB$M_SYNC_TX_ACT = 512;
literal DMB$M_SYNC_SECOND_BUFFER = 1024;
literal DMB$M_PARITY_ERR = 4096;
literal DMB$M_FRAME_ERR = 8192;
literal DMB$M_OVERRUN_ERR = 16384;
literal DMB$M_NON_CHAR = 32768;
literal DMB$M_DATA_VALID = -2147483648;
literal DMB$C_NO_ERROR = 0;
literal DMB$C_DMA_ERROR = 1;
literal DMB$C_MSG_ERROR = 2;
literal DMB$C_LAST_CHAR_ERROR = 3;
literal DMB$C_BUFFER_ERROR = 4;
literal DMB$C_MODEM_ERROR = 5;
literal DMB$C_ABORT_ERROR = 6;
literal DMB$C_X21_ERROR = 7;
literal DMB$C_OFFLINE_ERROR = 8;
literal DMB$C_INTERNAL_ERROR = 9;
literal DMB$C_HEADER_CRC_ERROR = 1;
literal DMB$C_DATA_CRC_ERROR = 2;
literal DMB$C_LENGTH_ERROR = 3;
literal DMB$C_LENGTH_AND_CRC_ERROR = 4;
literal DMB$C_ABORT_CHARACTER_ERROR = 5;
literal DMB$C_INVALID_CHARACTER_ERROR = 6;
literal DMB$C_HOST_ABORT_ERROR = 1;
literal DMB$C_DMB_ABORT_ERROR = 2;
literal DMB$C_RX_OVERRUN_ERROR = 1;
literal DMB$C_TX_UNDERRUN_ERROR = 2;
literal DMB$S_DMBDEF = 528;
macro DMB$L_MAINT = 256,0,32,0 %;       ! Maintenance register
macro DMB$V_FORCE_FAIL = 256,0,1,0 %;   ! Force failure
macro DMB$V_PROGRAM_RESET = 256,1,1,0 %; ! Programmed reset
macro DMB$V_PTE_VALID = 256,2,1,0 %;    ! Page tables valid
macro DMB$V_SKIP_SELFTEST = 256,3,1,0 %; ! Skip self test
macro DMB$V_MAINT_LEVEL1 = 256,4,1,0 %; ! Maintenance level 1
macro DMB$V_MAINT_LEVEL2 = 256,5,1,0 %; ! Maintenance level 2
macro DMB$V_SYNC = 256,8,1,0 %;         ! Sync lines present
macro DMB$V_ASYNC = 256,9,1,0 %;        ! Async lines present
macro DMB$V_PRINT = 256,10,1,0 %;       ! Printer present
macro DMB$V_DIAG_FAIL = 256,11,1,0 %;   ! Diagnostic error
macro DMB$V_X21_SUPPORT = 256,12,1,0 %; ! X21 firmware support present
macro DMB$V_CABLE_KEY = 256,13,1,0 %;   ! Cable key signal present
macro DMB$V_TURN_CONN = 256,14,1,0 %;   ! stag. loopback conn. present
macro DMB$V_MANF_CONN = 256,15,1,0 %;   ! Mfg. loopback conn. present
! 
!  The following 3 registers are the Control Status Registers (CSRs) for
!  the Async, Sync, and Printer ports in that order.
!            
macro DMB$L_ACSR = 260,0,32,0 %;        ! Async Control Status Register
macro DMB$B_ASYNC_IND_ADD = 260,0,8,1 %; ! Indirect Addr. Register Ptr.
macro DMB$V_RX_I_E = 260,8,1,0 %;       ! Receive Interrupt Enable
macro DMB$V_TX_I_E = 260,9,1,0 %;       ! Transmit Interrupt Enable
macro DMB$L_SCSR = 264,0,32,0 %;        ! Sync Control Status Register
macro DMB$B_SYNC_IND_ADD = 264,0,8,1 %; ! Indirect Addr. Register Ptr.
macro DMB$V_SYNC_I_E = 264,11,1,0 %;    ! Sync Interrupt Enable
macro DMB$L_PCSR = 268,0,32,0 %;        ! Printer Control Status Register
macro DMB$V_PR_I_E = 268,11,1,0 %;      ! Printer Interrupt Enable
macro DMB$V_PR_DAVFU_READY = 268,16,1,0 %; ! DAVFU ready
macro DMB$V_PR_CONNECT_VERIFY = 268,17,1,0 %; ! Connect verify
macro DMB$V_PR_OFFLINE = 268,18,1,0 %;  ! Line printer error
! 
!  Configuration of devices on DMB32.
! 
macro DMB$L_CONFIG = 276,0,32,0 %;      ! Device Configuration
macro DMB$B_ASYNC_LINES = 276,0,8,1 %;  ! Number of async lines
macro DMB$B_SYNC_LINES = 277,0,8,1 %;   ! Number of sync lines
macro DMB$B_PRINTER_LINES = 278,0,8,1 %; ! Number of printer ports
! 
!  The following 3 registers are the 2nd Control Status Registers for
!  each of the ports on the DMB32 (Async, Sync, and Printer).
!   	
macro DMB$L_ACSR2 = 280,0,32,1 %;       ! 2ND Async Control Status Register
macro DMB$V_ASYNC_RESET = 280,10,1,0 %; ! Async Port reset
macro DMB$B_RX_TIMER = 282,0,8,1 %;     ! Rcv Interrupt delay timer
macro DMB$L_SCSR2 = 284,0,32,1 %;       ! 2ND Sync Control Status Register
macro DMB$V_SYNC_RESET = 284,10,1,0 %;  ! Sync Port reset
macro DMB$L_PCSR2 = 288,0,32,0 %;       ! 2ND Printer Control Status Register
macro DMB$V_PRINTER_RESET = 288,10,1,0 %; ! Printer Port reset
macro DMBDEF$$_FILL_11 = 292,0,0,1 %;
literal DMBDEFS_FILL_11 = 44;
macro DMB$L_SPTE = 336,0,32,0 %;        ! SPTE system page table register
macro DMB$L_SPTS = 340,0,32,0 %;        ! System page table size register
macro DMB$L_GPTE = 344,0,32,0 %;        ! Global page table register
macro DMB$L_GPTS = 348,0,32,0 %;        ! Global page table size register
! 
!  The following 6 registers are specific to the printer port on the
!  DMB32.
! 
macro DMB$L_PFIX = 352,0,32,0 %;        ! Printer prefix/suffix control
macro DMB$B_PREFIX_COUNT = 352,0,8,1 %; ! Prefix count
macro DMB$B_PREFIX_CHAR = 353,0,8,1 %;  ! Prefix character
macro DMB$B_SUFFIX_COUNT = 354,0,8,1 %; ! Suffix count
macro DMB$B_SUFFIX_CHAR = 355,0,8,1 %;  ! Suffix character
macro DMB$L_PBUFAD = 356,0,32,0 %;      ! Printer Buffer Address            
macro DMB$L_PBUFCT = 360,0,32,0 %;      ! Printer Buffer count/offset
macro DMB$W_PR_BUFF_OFF = 360,0,16,1 %; ! printer buffer offset
macro DMB$W_PR_BUFF_CT = 362,0,16,1 %;  ! transmit DMA char. count
macro DMB$L_PCTRL = 364,0,32,0 %;       ! Printer Control Register
macro DMB$V_PR_DMA_START = 364,0,1,0 %; ! Start a DMA transfer
macro DMB$V_PR_DMA_PTE = 364,1,1,0 %;   ! PTE address
macro DMB$V_PR_DMA_PHYS = 364,2,1,0 %;  ! Physical address
macro DMB$V_PR_DMA_ABORT = 364,8,1,0 %; ! Abort a DMA transfer
macro DMB$V_PR_FORMAT = 364,9,1,0 %;    ! Format control
macro DMB$B_PR_ERROR = 366,0,8,1 %;     ! Error code
macro DMB$V_PR_TAB = 364,24,1,0 %;      ! Tab expansion
macro DMB$V_PR_TRUNC = 364,25,1,0 %;    ! Truncation of Data
macro DMB$V_PR_AUTO_RETURN = 364,26,1,0 %; ! Auto CR insert
macro DMB$V_PR_AUTO_FORM = 364,27,1,0 %; ! Auto FF to LF convert
macro DMB$V_PR_NON_PRINT = 364,28,1,0 %; ! Non printing char. accept
macro DMB$V_PR_DAVFU = 364,29,1,0 %;    ! DAVFU
macro DMB$V_PR_WRAP = 364,30,1,0 %;     ! Line Wrap
macro DMB$V_PR_UPPER = 364,31,1,0 %;    ! Convert to upper case
macro DMB$L_PCAR = 368,0,32,0 %;        ! Printer Carriage Counter
macro DMB$W_PR_LINE = 368,0,16,1 %;     ! Lines printed
macro DMB$W_PR_CHAR = 370,0,16,1 %;     ! Characters transmitted
macro DMB$L_PSIZE = 372,0,32,0 %;       ! Printer page size
macro DMB$W_PR_WIDTH = 372,0,16,1 %;    ! Line Width
macro DMB$W_PR_PAGE = 374,0,16,1 %;     ! Page size
! 
!  The next 16 registers are specific to the SYNC port on the DMB32.
! 
macro DMB$L_TBUFFAD1 = 384,0,32,0 %;    ! Transmit Buffer Address 1
macro DMB$L_TBUFFCT1 = 388,0,32,0 %;    ! Transmit Buffer Count/offset 1
macro DMB$W_TX_BUFF_OFF1 = 388,0,16,1 %; ! Transmit buffer offset
macro DMB$W_TX_CHAR_CT1 = 390,0,16,1 %; ! Transmit DMA character count
macro DMB$L_RBUFFAD1 = 392,0,32,0 %;    ! Receive Buffer Address 1
macro DMB$L_RBUFFCT1 = 396,0,32,0 %;    ! Receive Buffer Count/offset 1
macro DMB$W_RX_BUFF_OFF1 = 396,0,16,1 %; ! Receive buffer offset
macro DMB$W_RX_CHAR_CT1 = 398,0,16,1 %; ! Receive DMA character count
macro DMB$L_TLNCTRL1 = 400,0,32,0 %;    ! Buffer 1 Transmit Control
macro DMB$V_TX1_DMA_START = 400,0,1,0 %; ! Start a DMA transfer
macro DMB$V_TX1_DMA_PTE = 400,1,1,0 %;  ! PTE address
macro DMB$V_TX1_DMA_PHYS = 400,2,1,0 %; ! Physical address
macro DMB$V_TX1_X21 = 400,3,1,0 %;      ! X.21 mode
macro DMB$V_TX1_PAR = 400,4,1,0 %;      ! Parameter change
macro DMB$V_TX1_DMA_ABORT = 400,8,1,0 %; ! Transmitter DMA abort
macro DMB$B_TX1_ERROR = 403,0,8,1 %;    ! Transmitter Error bits
macro DMB$L_RLNCTRL1 = 404,0,32,0 %;    ! Buffer 1 Receive Control
macro DMB$V_RX1_DMA_START = 404,0,1,0 %; ! Start a DMA transfer
macro DMB$V_RX1_DMA_PTE = 404,1,1,0 %;  ! PTE address
macro DMB$V_RX1_DMA_PHYS = 404,2,1,0 %; ! Physical address
macro DMB$V_RX1_X21 = 404,3,1,0 %;      ! X.21 mode
macro DMB$V_RX1_DMA_ABORT = 404,8,1,0 %; ! Receiver DMA abort
macro DMB$B_RX1_ERROR = 407,0,8,1 %;    ! Receiver error bits
macro DMB$L_LPR1 = 408,0,32,0 %;        ! Sync line parameters 1
macro DMB$V_RX_ENABLE = 408,0,1,0 %;    ! Receiver Enable
macro DMB$V_RX_MATCH_ENA = 408,2,1,0 %; ! Receiver Match character enable
macro DMB$V_RX_PRIMARY = 408,3,1,0 %;   ! Primary-Secondary Station
macro DMB$V_X21ENABLE = 408,4,1,0 %;    ! X21 Protocol Enable
macro DMB$V_CLOCK_CONTROL = 408,6,1,0 %; ! Clock control bit
macro DMB$V_CODING_TYPE = 408,7,1,0 %;  ! Data coding type
macro DMB$V_BAUD_RATE = 408,8,4,0 %;
literal DMB$S_BAUD_RATE = 4;            ! Internal B.R. Generator speed
macro DMB$V_LOOP = 408,12,1,0 %;        ! Maintenance Loop back
macro DMB$V_V35_SELECT = 408,13,1,0 %;  ! V.35 select
macro DMB$V_V10_SELECT = 408,14,1,0 %;  ! V.10 select
macro DMB$V_MODEM_SUPPRESS = 408,15,1,0 %; ! Supress modem change ints
macro DMB$B_NUMBER_SYNC = 410,0,8,1 %;  ! Number of sync characters
macro DMB$V_LINE_RESET = 408,31,1,0 %;  ! Line reset request
macro DMB$L_LPR2 = 412,0,32,0 %;        ! Sync line parameters 2
macro DMB$V_SYNC_ML1 = 412,0,1,0 %;     ! Modem loop output
macro DMB$V_SYNC_DTR = 412,1,1,0 %;     ! Data terminal ready output
macro DMB$V_SYNC_DRS = 412,2,1,0 %;     ! Data rate select output
macro DMB$V_SYNC_ML2 = 412,3,1,0 %;     ! 2nd modem loop output
macro DMB$V_SYNC_RTS = 412,4,1,0 %;     ! Request to send output
macro DMB$V_SPARE_MODEM = 412,5,3,0 %;
literal DMB$S_SPARE_MODEM = 3;          ! 
macro DMB$V_SYNC_RXCLOCK = 412,8,1,0 %; ! Receive clock running
macro DMB$V_SYNC_TXCLOCK = 412,9,1,0 %; ! Transmit clock running
macro DMB$V_SYNC_TI = 412,10,1,0 %;     ! Test indicator
macro DMB$V_SYNC_CTS = 412,12,1,0 %;    ! Clear to send input
macro DMB$V_SYNC_DCD = 412,13,1,0 %;    ! Data carrier detect input
macro DMB$V_SYNC_RI = 412,14,1,0 %;     ! Ring indicator input
macro DMB$V_SYNC_DSR = 412,15,1,0 %;    ! Data set ready input
macro DMB$V_PROTOCOL = 412,16,3,0 %;
literal DMB$S_PROTOCOL = 3;             ! Protocol type
macro DMB$V_ERROR_TYPE = 412,19,3,0 %;
literal DMB$S_ERROR_TYPE = 3;
macro DMB$V_RX_BPC = 412,22,3,0 %;
literal DMB$S_RX_BPC = 3;               ! #of receive bits per char.  
macro DMB$V_TX_BPC = 412,25,3,0 %;
literal DMB$S_TX_BPC = 3;               ! # of transmit bits per char.
macro DMB$V_STRIP_SYNC = 412,28,1,0 %;  ! Strip Sync
macro DMB$V_EBCDIC_CODE = 412,29,1,0 %; ! Character code
macro DMB$V_IDLE_SYNC = 412,30,1,0 %;   ! Idle Sync
macro DMB$V_MODEM_OVERRIDE = 412,31,1,0 %; ! Modem control override
macro DMB$L_TBUFFAD2 = 416,0,32,0 %;    ! Transmit Buffer Address 2
macro DMB$L_TBUFFCT2 = 420,0,32,0 %;    ! Transmit Buffer count/offset 1
macro DMB$W_TX_BUFF_OFF2 = 420,0,16,1 %; ! Transmit buffer offset
macro DMB$W_TX_CHAR_CT2 = 422,0,16,1 %; ! Transmit DMA character count
macro DMB$L_RBUFFAD2 = 424,0,32,0 %;    ! Receive Buffer Address 2
macro DMB$L_RBUFFCT2 = 428,0,32,0 %;    ! Receive Buffer count/offset 2
macro DMB$W_RX_BUFF_OFF2 = 428,0,16,1 %; ! Receive buffer offset
macro DMB$W_RX_CHAR_CT2 = 430,0,16,1 %; ! Receive DMA character count
macro DMB$L_TLNCTRL2 = 432,0,32,0 %;    ! Buffer 2 Transmit Control
macro DMB$V_TX2_DMA_START = 432,0,1,0 %; ! Start a DMA transfer
macro DMB$V_TX2_DMA_PTE = 432,1,1,0 %;  ! PTE address
macro DMB$V_TX2_DMA_PHYS = 432,2,1,0 %; ! Physical address
macro DMB$V_TX2_X21 = 432,3,1,0 %;      ! X.21 mode
macro DMB$V_TX2_PAR = 432,4,1,0 %;      ! Parameter change
macro DMB$V_TX2_DMA_ABORT = 432,8,1,0 %; ! Transmitter DMA abort
macro DMB$B_TX2_ERROR = 435,0,8,1 %;    ! Transmitter error bits
macro DMB$L_RLNCTRL2 = 436,0,32,0 %;    ! Buffer 2 Receive control
macro DMB$V_RX2_DMA_START = 436,0,1,0 %; ! Start a DMA transfer
macro DMB$V_RX2_DMA_PTE = 436,1,1,0 %;  ! PTE address
macro DMB$V_RX2_DMA_PHYS = 436,2,1,0 %; ! Physical address
macro DMB$V_RX2_X21 = 436,3,1,0 %;      ! X.21 mode
macro DMB$V_RX2_DMA_ABORT = 436,8,1,0 %; ! Receiver DMA abort
macro DMB$B_RX2_ERROR = 439,0,8,1 %;    ! Receiver error bits
macro DMB$L_LPR3 = 440,0,32,0 %;        ! Sync Line parameters 3
macro DMB$B_SYNC_CHAR = 440,0,8,1 %;    ! Sync character
macro DMB$B_RX_MATCH = 441,0,8,1 %;     ! Receive match character
macro DMB$B_ADDRESS1 = 442,0,8,1 %;     ! First address character
macro DMB$B_ADDRESS2 = 443,0,8,1 %;     ! Second address character
macro DMB$L_BUFCTRL = 444,0,32,0 %;     ! Sync Buffer Control Bits
macro DMB$B_TX_BUFF_PRIO = 444,0,8,1 %; ! Transmitter Buf. Priority
macro DMB$B_RX_BUFF_PRIO = 445,0,8,1 %; ! Receiver Buffer Priority
macro DMB$B_SYNC_TEST_INPUT = 446,0,8,1 %; ! Test inputs
macro DMB$V_SYNC_CABLE = 444,24,4,0 %;
literal DMB$S_SYNC_CABLE = 4;           ! Electrical Configuration
macro DMB$V_SYNC_LOOP = 444,29,1,0 %;   ! Loopback present
macro DMB$V_SYNC_VALID = 444,30,1,0 %;  ! Valid cable
macro DMB$V_SYNC_X21 = 444,31,1,0 %;    ! X.21 Mode
! 
!  The next 10 registers are for the async port on the DMB32
!                                               
macro DMB$L_PREEMPT = 448,0,32,0 %;     ! Preempt Buffer
macro DMB$B_PREEMPT_CHAR = 448,0,8,1 %; ! Character to Transmit
macro DMB$V_PREEMPT_GO = 448,15,1,0 %;  ! Start Preempt
macro DMB$L_TBUFFAD = 452,0,32,0 %;     ! Transmit Buffer Address
macro DMB$L_TBUFFCT = 456,0,32,0 %;     ! Transmit Buffer Count-Offset
macro DMB$W_TX_BUFF_OFF = 456,0,16,1 %; ! Transmit Buffer Offset
macro DMB$W_TX_CHAR_CT = 458,0,16,1 %;  ! Transmit Buffer Count
macro DMB$L_LPR = 460,0,32,0 %;         ! Line parameter register
macro DMB$V_ML = 460,0,1,0 %;           ! Modem Loop
macro DMB$V_DTR = 460,1,1,0 %;          ! Data Terminal Ready
macro DMB$V_DRS = 460,2,1,0 %;          ! Data Rate Select
macro DMB$V_RTS = 460,4,1,0 %;          ! Request to Send
macro DMB$V_TX_INT_DELAY = 460,9,1,0 %; ! Transmit Interrupt Control
macro DMB$V_RX_ENA = 460,10,1,0 %;      ! Receiver Enable
macro DMB$V_BREAK = 460,11,1,0 %;       ! Break control
macro DMB$V_MAINT = 460,12,2,0 %;
literal DMB$S_MAINT = 2;                ! Maintenance Mode
macro DMB$V_REPORT_MODEM = 460,14,1,0 %; ! Report Modem changes
macro DMB$V_DISCARD_FLOW = 460,15,1,0 %; ! Discard flow contr. characters
macro DMB$V_CHAR_LENGTH = 460,16,2,0 %;
literal DMB$S_CHAR_LENGTH = 2;          ! character length
macro DMB$V_PARITY_ENAB = 460,18,1,0 %; ! Parity enable
macro DMB$V_EVEN_PARITY = 460,19,1,0 %; ! Even parity
macro DMB$V_STOP_CODE = 460,20,1,0 %;   ! Stop code
macro DMB$V_USE_CTS = 460,21,1,0 %;     ! CTS controls output
macro DMB$V_IAUTO_FLOW = 460,22,1,0 %;  ! Auto f.c. of incoming data
macro DMB$V_OAUTO_FLOW = 460,23,1,0 %;  ! Auto f.c. of outgoing data
macro DMB$V_RX_SPEED = 460,24,4,0 %;
literal DMB$S_RX_SPEED = 4;             ! Received data speed
macro DMB$V_TX_SPEED = 460,28,4,0 %;
literal DMB$S_TX_SPEED = 4;             ! Transmitted data rate
macro DMB$L_LNCTRL = 464,0,32,0 %;      ! Line Control
macro DMB$V_TX_DMA_START = 464,0,1,0 %; ! Start a DMA transfer
macro DMB$V_TX_DMA_PTE = 464,1,1,0 %;   ! PTE address
macro DMB$V_TX_DMA_PHYS = 464,2,1,0 %;  ! Physical address
macro DMB$V_TX_OUT_ABORT = 464,8,1,0 %; ! Transmitter output abort
macro DMB$B_TX_ERROR = 466,0,8,1 %;     ! Transmitter error bits
macro DMB$L_LSTAT = 468,0,32,0 %;       ! Line status register
macro DMB$V_ML2 = 468,10,1,0 %;         ! Spare modem control lead
macro DMB$V_CTS = 468,12,1,0 %;         ! Clear to send
macro DMB$V_DCD = 468,13,1,0 %;         ! Data carrier detected
macro DMB$V_RI = 468,14,1,0 %;          ! Ring indicator
macro DMB$V_DSR = 468,15,1,0 %;         ! Data set ready
macro DMB$V_SNDOFF = 468,23,1,0 %;      ! Send XOFF
macro DMB$V_TX_ENA = 468,31,1,0 %;      ! Transmitter enable
macro DMB$L_FLOWC = 472,0,32,0 %;       ! Flow control characters
macro DMB$B_SENT_XOFF = 472,0,8,1 %;    ! Transmitted XOFF
macro DMB$B_SENT_XON = 473,0,8,1 %;     ! Transmitted XON
macro DMB$B_RECEIVED_XOFF = 474,0,8,1 %; ! Received XOFF
macro DMB$B_RECEIVED_XON = 475,0,8,1 %; ! Received XON
macro DMB$L_TBUF = 516,0,32,0 %;        ! Transmit completion fifo
macro DMB$B_TX_LINE = 516,0,8,1 %;      ! Transmit line number
macro DMB$V_TX_PREEMPT = 516,8,1,0 %;   ! Preempt completed
macro DMB$V_TX_FIFO_DONE = 516,9,1,0 %; ! fifo empty
macro DMB$B_TX_DMA_ERROR = 518,0,8,1 %; ! Transmit error code
macro DMB$V_TX_ACT = 516,31,1,0 %;      ! Transmitter action
macro DMB$L_SBUF = 520,0,32,0 %;        ! Sync line completion fifo
macro DMB$B_SYNC_LINE = 520,0,8,1 %;    ! Sync line number
macro DMB$V_SYNC_MODEM = 520,8,1,0 %;   ! Modem change
macro DMB$V_SYNC_TX_ACT = 520,9,1,0 %;  ! Sync Transmit complete
macro DMB$V_SYNC_SECOND_BUFFER = 520,10,1,0 %; ! buffer number
macro DMB$V_SBUF_SPARE = 520,11,5,0 %;
literal DMB$S_SBUF_SPARE = 5;           ! 
macro DMB$R_SBUF_X = 522,0,8,0 %;
literal DMB$S_SBUF_X = 1;               ! 
macro DMB$B_SYNC_MODEM_STATUS = 522,0,8,1 %; ! Sync line new modem status
macro DMB$B_SYNC_ERROR = 522,0,8,1 %;   ! Sync line error code
macro DMB$L_RBUF = 524,0,32,0 %;        ! Async Receiver Buffer
macro DMB$B_RXCHAR = 524,0,8,1 %;       ! Received character
macro DMB$V_PARITY_ERR = 524,12,1,0 %;  ! Parity error
macro DMB$V_FRAME_ERR = 524,13,1,0 %;   ! Framing error
macro DMB$V_OVERRUN_ERR = 524,14,1,0 %; ! Overrun error
macro DMB$V_NON_CHAR = 524,15,1,0 %;    ! non character data
macro DMB$B_RX_LINE = 526,0,8,1 %;      ! Receive line number
macro DMB$V_DATA_VALID = 524,31,1,0 %;  ! Data valid
 
!*** MODULE $DIAGDEF ***
! *
! 
!  Constants defining literals used in $DIAGNOSE system service
! 
literal DIAG$C_SETAFF = 1;              !  request to set affinity -- Set/Release
!  explicit process affinity to any CPU.
literal DIAG$C_ACTVCPUS = 2;            !  request to read SMP$GL_ACTIVE_CPUS
literal DIAG$C_DISABLAFF = 0;           !  disable explicit affinity to a CPU
literal DIAG$C_ENABLAFF = 1;            !  enable explicit affinity to a CPU
 
!*** MODULE $DPTDEF ***
! +
!  DPT - DRIVER PROLOGUE TABLE
! 
!  EACH DEVICE DRIVER HAS A DRIVER PROLOGUE TABLE.
! -
literal DPT$M_SUBCNTRL = 1;
literal DPT$M_SVP = 2;
literal DPT$M_NOUNLOAD = 4;
literal DPT$M_SCS = 8;
literal DPT$M_DUSHADOW = 16;
literal DPT$M_SCSCI = 32;
literal DPT$M_BVPSUBS = 64;
literal DPT$M_UCODE = 128;
literal DPT$M_SMPMOD = 256;
literal DPT$M_DECW_DECODE = 512;
literal DPT$M_TPALLOC = 1024;
literal DPT$M_SNAPSHOT = 2048;
literal DPT$M_NO_IDB_DISPATCH = 4096;
literal DPT$M_EXTENDED_DDT = 8192;
literal DPT$C_VERSION = 5;              ! CURRENT VERSION NUMBER 
literal DPT$K_LENGTH = 130;             ! LENGTH OF PROLOGUE TABLE 
literal DPT$C_LENGTH = 130;             ! LENGTH OF PROLOGUE TABLE 
literal DPT$S_DPTDEF = 130;
macro DPT$L_FLINK = 0,0,32,0 %;         ! FORWARD LINK TO NEXT DPT 
macro DPT$L_BLINK = 4,0,32,0 %;         ! BACKWARD LINK TO PREVIOUS DPT 
macro DPT$W_SIZE = 8,0,16,0 %;          ! SIZE OF DRIVER 
macro DPT$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE 
macro DPT$B_REFC = 11,0,8,0 %;          ! COUNT OF DDB'S THAT REFERENCE DRIVER 
macro DPT$B_ADPTYPE = 12,0,8,0 %;       ! ADAPTER TYPE CODE 
macro DPT$W_UCBSIZE = 14,0,16,0 %;      ! SIZE OF UCB 
macro DPT$B_FLAGS = 16,0,8,0 %;         ! DRIVER LOADER FLAGS 
macro DPT$L_FLAGS = 16,0,32,0 %;        ! Add more bits 
macro DPT$V_SUBCNTRL = 16,0,1,0 %;      ! DEVICE IS A SUB-CONTROLLER 
macro DPT$V_SVP = 16,1,1,0 %;           ! DEVICE REQUIRES A SYSTEM PAGE 
macro DPT$V_NOUNLOAD = 16,2,1,0 %;      ! DRIVER IS NOT TO BE UNLOADED 
macro DPT$V_SCS = 16,3,1,0 %;           ! Load common SCS code with driver
macro DPT$V_DUSHADOW = 16,4,1,0 %;      ! SHADOWING DISK CLASS DRIVER
macro DPT$V_SCSCI = 16,5,1,0 %;         ! Load common SCS/CI subroutines with driver
macro DPT$V_BVPSUBS = 16,6,1,0 %;       ! Load common BVP subroutines with driver
macro DPT$V_UCODE = 16,7,1,0 %;         ! Driver has associated microcode image
macro DPT$V_SMPMOD = 16,8,1,0 %;        ! Driver has been modified for SMP
macro DPT$V_DECW_DECODE = 16,9,1,0 %;   ! DECwindows decoder (class) driver
macro DPT$V_TPALLOC = 16,10,1,0 %;      ! Use tape allocation class parameter
macro DPT$V_SNAPSHOT = 16,11,1,0 %;     ! Driver has been certified for system snapshot
macro DPT$V_NO_IDB_DISPATCH = 16,12,1,0 %; ! Don't use IDB$L_UCBLST for UCB vectors
macro DPT$V_EXTENDED_DDT = 16,13,1,0 %; ! Do not allocate extended DDT
macro DPT$W_INITTAB = 20,0,16,0 %;      ! OFFSET TO INIT TABLE 
macro DPT$W_REINITTAB = 22,0,16,0 %;    ! OFFSET TO RE-INIT TABLE 
macro DPT$W_UNLOAD = 24,0,16,0 %;       ! OFFSET TO UNLOAD ACTION ROUTINE 
macro DPT$W_MAXUNITS = 26,0,16,0 %;     ! MAXIMUM UNITS THAT CAN BE CONNECTED 
macro DPT$W_VERSION = 28,0,16,0 %;      ! DRIVER PROLOGUE VERSION NUMBER 
macro DPT$W_DEFUNITS = 30,0,16,0 %;     ! DEFAULT NUMBER OF UNITS 
macro DPT$W_DELIVER = 32,0,16,0 %;      ! OFFSET TO DRIVER UNIT DELIVERY ROUTINE 
macro DPT$W_VECTOR = 34,0,16,0 %;       ! OFFSET TO VECTOR TABLE (IN TTDRIVER) 
macro DPT$T_NAME = 36,0,0,0 %;
literal DPT$S_NAME = 12;                ! DRIVER NAME (COUNTED STRING) 
macro DPT$Q_LINKTIME = 48,0,0,0 %;
literal DPT$S_LINKTIME = 8;             ! LINK DATE AND TIME FROM IMAGE HEADER 
macro DPT$L_ECOLEVEL = 56,0,32,0 %;     ! ECO LEVEL FROM IMAGE HEADER 
macro DPT$L_UCODE = 60,0,32,0 %;        ! ASSOCIATED MICROCODE IMAGE
macro DPT$Q_LMF_1 = 64,0,0,0 %;
literal DPT$S_LMF_1 = 8;                ! RESERVED SPACE FOR LMF 
macro DPT$Q_LMF_2 = 72,0,0,0 %;
literal DPT$S_LMF_2 = 8;                ! RESERVED SPACE FOR LMF 
macro DPT$Q_LMF_3 = 80,0,0,0 %;
literal DPT$S_LMF_3 = 8;                ! RESERVED SPACE FOR LMF 
macro DPT$Q_LMF_4 = 88,0,0,0 %;
literal DPT$S_LMF_4 = 8;                ! RESERVED SPACE FOR LMF 
macro DPT$Q_LMF_5 = 96,0,0,0 %;
literal DPT$S_LMF_5 = 8;                ! RESERVED SPACE FOR LMF 
macro DPT$Q_LMF_6 = 104,0,0,0 %;
literal DPT$S_LMF_6 = 8;                ! RESERVED SPACE FOR LMF 
macro DPT$Q_LMF_7 = 112,0,0,0 %;
literal DPT$S_LMF_7 = 8;                ! RESERVED SPACE FOR LMF 
macro DPT$Q_LMF_8 = 120,0,0,0 %;
literal DPT$S_LMF_8 = 8;                ! RESERVED SPACE FOR LMF 
macro DPT$W_DECW_SNAME = 128,0,16,0 %;  ! OFFSET TO COUNTED ASCII STRING
!   The following definitions apply to the structure type
!   field produced by the DPT_STORE macro.
literal DPT$M_STRUC_NO = 15;
literal DPT$K_STRUC_ORB = 1;            ! 	ORB
literal DPT$K_STRUC_UCB = 2;            ! 	UCB
literal DPT$K_STRUC_IDB = 3;            ! 	IDB
literal DPT$K_STRUC_DDB = 4;            ! 	DDB
literal DPT$K_STRUC_CRB = 5;            ! 	CRB
literal DPT$M_STRUC_WRD = 128;
literal DPT$S_DPTSTORE = 1;
macro DPT$B_STR_STRUC = 0,0,8,0 %;      ! Basic structure byte field
macro DPT$V_STRUC_NO = 0,0,4,0 %;
literal DPT$S_STRUC_NO = 4;             !   Structure number field
macro DPT$V_STRUC_WRD = 0,7,1,0 %;      !   Structure word offset flag
 
!*** MODULE $DSRVDEF ***
! +
!  DSRV  ( )  Definitions
! 
! 	This module defines the main data structure of the MSCP
! 	server. This structure contains the values specified in
! 	the start up qualifiers when the server was loaded, the 
! 	UQB vector table, and statistics that are kept for server
! 	performance measurements.
! 
!  <<== !NOTICE! ==>>
! 
! 	DO NOT change offsets of the top part of the data structure.
!  	If new fields have to be added please make them below the 
! 	forward and backward links to the UQB.
! -
literal DSRV$M_LOG_ENABLD = 1;
literal DSRV$M_LOG_PRESENT = 2;
literal DSRV$M_PKT_LOGGED = 4;
literal DSRV$M_PKT_LOST = 8;
literal DSRV$M_LBSTEP1 = 16;
literal DSRV$M_LBSTEP2 = 32;
literal DSRV$M_LBEVENT = 64;
literal DSRV$M_HULB_DEL = 128;
literal DSRV$M_MON_ACTIVE = 256;
literal DSRV$M_LB_REQ = 512;
literal DSRV$M_CONFIG_WAIT = 1024;
literal DSRV$C_LENGTH = 1940;
literal DSRV$K_LENGTH = 1940;
literal DSRV$K_AR_ADD = 2;              !  Action routine code
literal DSRV$S_DSRVDEF = 1940;
macro DSRV$L_FLINK = 0,0,32,0 %;        !  Field maintained for 
macro DSRV$L_BLINK = 4,0,32,0 %;        !   compatability
macro DSRV$W_SIZE = 8,0,16,0 %;         !  Structure size in bytes
macro DSRV$B_TYPE = 10,0,8,0 %;         !  MSCP type structure
macro DSRV$B_SUBTYPE = 11,0,8,0 %;      !   with a DSRV subtype      (1)
macro DSRV$W_STATE = 12,0,16,0 %;       !  Current state of the server
macro DSRV$V_LOG_ENABLD = 12,0,1,0 %;   !  Logging is enabled
macro DSRV$V_LOG_PRESENT = 12,1,1,0 %;  !  Logging code is present
macro DSRV$V_PKT_LOGGED = 12,2,1,0 %;   !  A packet has been logged
macro DSRV$V_PKT_LOST = 12,3,1,0 %;     !  One or more packets over-
!   written since last read
macro DSRV$V_LBSTEP1 = 12,4,1,0 %;      !  Load balancing step1 active
macro DSRV$V_LBSTEP2 = 12,5,1,0 %;      !  Load balancing step2 active
macro DSRV$V_LBEVENT = 12,6,1,0 %;      !  An event of interest to LB has
!   occured while STEP1 was active
macro DSRV$V_HULB_DEL = 12,7,1,0 %;     !  One or more HULBs to be deleted
macro DSRV$V_MON_ACTIVE = 12,8,1,0 %;   !  The load monitor thread is active
macro DSRV$V_LB_REQ = 12,9,1,0 %;       !  A load balance request has been sent
macro DSRV$V_CONFIG_WAIT = 12,10,1,0 %; !  Waiting for STACONFIG to complete
macro DSRV$W_BUFWAIT = 14,0,16,0 %;     ! I/Os that had to wait
macro DSRV$L_LOG_BUF_START = 16,0,32,0 %; !  Address of start of buffer
macro DSRV$L_LOG_BUF_END = 20,0,32,0 %; !  Address of end of buffer
macro DSRV$L_NEXT_READ = 24,0,32,0 %;   !  Adrs of next packet to read
macro DSRV$L_NEXT_WRITE = 28,0,32,0 %;  !  Adrs of next packet to write
macro DSRV$W_INC_LOLIM = 32,0,16,0 %;   !  Low unit number to log
macro DSRV$W_INC_HILIM = 34,0,16,0 %;   !  High unit number to log
macro DSRV$W_EXC_LOLIM = 36,0,16,0 %;   !  Low unit number not to log
macro DSRV$W_EXC_HILIM = 38,0,16,0 %;   !  High unit number not to log
macro DSRV$L_SRVBUF = 40,0,32,0 %;      !  Address of preallocated pool
macro DSRV$L_FREE_LIST = 44,0,32,0 %;   !  Pointer to head of free pool
macro DSRV$L_AVAIL = 48,0,32,0 %;       !  Sum of bytes available in buffer
macro DSRV$L_BUFFER_MIN = 52,0,32,0 %;  !  Min xfer size based on buffer
macro DSRV$L_SPLITXFER = 56,0,32,0 %;   !  Fragmented I/O count
macro DSRV$W_VERSION = 60,0,16,0 %;     !  Server software version
macro DSRV$W_CFLAGS = 62,0,16,0 %;      !  Controller flags
macro DSRV$W_CTIMO = 64,0,16,0 %;       !  Controller timeout
macro DSRV$Q_CTRL_ID = 68,0,0,0 %;
literal DSRV$S_CTRL_ID = 8;             !  Unique MSCP device identifier
macro DSRV$L_MEMW_TOT = 76,0,32,0 %;    !  Number of I/Os that had to wait
macro DSRV$W_MEMW_CNT = 80,0,16,0 %;    !  Requests in memory wait queue
macro DSRV$W_MEMW_MAX = 82,0,16,0 %;    !  Most requests ever in MEMWAIT
macro DSRV$L_MEMW_FL = 84,0,32,0 %;     !  Queue listhead for requests
macro DSRV$L_MEMW_BL = 88,0,32,0 %;     !   in memory wait state
macro DSRV$W_NUM_HOST = 92,0,16,0 %;    !  Count of hosts being served
macro DSRV$W_NUM_UNIT = 94,0,16,0 %;    !  Count of disks being served
macro DSRV$L_HQB_FL = 96,0,32,0 %;      !  Host queue block list head
macro DSRV$L_HQB_BL = 100,0,32,0 %;     ! 
macro DSRV$L_UQB_FL = 104,0,32,0 %;     !  Unit queue block list head
macro DSRV$L_UQB_BL = 108,0,32,0 %;     ! 
! 
!  new fields should be added here, after the UQB linkages
! 
! 
! 	Server Load Balancing fields
! 
! 	The following fields containing working information and statistics
! 	for the server load balancing function. Load balancing status bits
! 	are defined in DSRV$STATE above. Time fields are in EXE$GL_ABSTIM
! 	format.
! 
macro DSRV$W_LOAD_AVAIL = 112,0,16,0 %; !  Current load available
macro DSRV$W_LOAD_CAPACITY = 114,0,16,0 %; !  Server load capacity
macro DSRV$W_LBLOAD = 116,0,16,0 %;     !  Target load for LB request
macro DSRV$W_LBRESP = 118,0,16,0 %;     !  Load available from other server
macro DSRV$W_LM_LOAD1 = 120,0,16,0 %;   !  previous interval load 1
macro DSRV$W_LM_LOAD2 = 122,0,16,0 %;   !  previous interval load 2
macro DSRV$W_LM_LOAD3 = 124,0,16,0 %;   !  previous interval load 3
macro DSRV$W_LM_LOAD4 = 126,0,16,0 %;   !  previous interval load 4
macro DSRV$W_LBINIT_CNT = 128,0,16,0 %; !  Count of LB requests we have sent
macro DSRV$W_LBFAIL_CNT = 130,0,16,0 %; !  Count of LB requests that failed
macro DSRV$W_LBREQ_CNT = 132,0,16,0 %;  !  Count of LB requests from other servers
macro DSRV$W_LBRESP_CNT = 134,0,16,0 %; !  Count of LB requests we to which we responded
macro DSRV$L_LBREQ_TIME = 136,0,32,0 %; !  Time last LB request was sent
macro DSRV$L_LBMON_TIME = 140,0,32,0 %; !  Time of last LB monitor pass
macro DSRV$L_LM_FKB = 144,0,32,0 %;     !  Address of load monitor thread FKB
macro DSRV$L_LB_FKB = 148,0,32,0 %;     !  Address of load balance thread FKB
macro DSRV$W_LM_INTERVAL = 152,0,16,0 %; !  Load monitoring interval
macro DSRV$B_LB_COUNT1 = 154,0,8,0 %;   !  Counter for load balancing thread
macro DSRV$B_LB_COUNT2 = 155,0,8,0 %;   !  Counter for load balancing thread
macro DSRV$L_HULB_FL = 156,0,32,0 %;    !  HULB queue listhead
macro DSRV$L_HULB_BL = 160,0,32,0 %;    ! 
! 
macro DSRV$B_HOSTS = 164,0,0,0 %;
literal DSRV$S_HOSTS = 32;              !  Bit array of hosts served
macro DSRV$L_UNITS = 196,0,0,0 %;
literal DSRV$S_UNITS = 1024;            !  Table of UQB addresses
! 
! 	Statistics gathering fields
! 
! 	Two tables are maintained below. The first table is made up of the 
! 	frequency count for each of the opcodes received since the server
! 	was loaded. The opcode is used as an index into the table to its own
! 	frequency count (the zeroeth element contains a total count). The 
! 	second table is made up of the frequency counters for all the
! 	different sized block transfers. For this table, the size of the 
! 	transfer is the index into the table.
! 
macro DSRV$L_OPCOUNT = 1220,0,32,0 %;   !  Total operations count
macro DSRV$L_ABORT_CNT = 1224,0,32,0 %; !    - 1 -
macro DSRV$L_GET_CMD_CNT = 1228,0,32,0 %; !    - 2 -
macro DSRV$L_GET_UNT_CNT = 1232,0,32,0 %; !    - 3 -
macro DSRV$L_SET_CON_CNT = 1236,0,32,0 %; !    - 4 -
macro DSRV$L_AVAIL_CNT = 1252,0,32,0 %; !    - 8 -
macro DSRV$L_ONLIN_CNT = 1256,0,32,0 %; !    - 9 -
macro DSRV$L_SET_UNT_CNT = 1260,0,32,0 %; !    - 10 -
macro DSRV$L_DET_ACC_CNT = 1264,0,32,0 %; !    - 11 -
macro DSRV$L_ACCES_CNT = 1284,0,32,0 %; !    - 16 -
macro DSRV$L_CMP_CON_CNT = 1288,0,32,0 %; !    - 17 -
macro DSRV$L_ERASE_CNT = 1292,0,32,0 %; !    - 18 -
macro DSRV$L_FLUSH_CNT = 1296,0,32,0 %; !    - 19 -
macro DSRV$L_REPLC_CNT = 1300,0,32,0 %; !    - 20 -
macro DSRV$L_CMP_HST_CNT = 1348,0,32,0 %; !    - 32 -
macro DSRV$L_READ_CNT = 1352,0,32,0 %;  !    - 33 -
macro DSRV$L_WRITE_CNT = 1356,0,32,0 %; !    - 34 -
macro DSRV$L_TERCO_CNT = 1412,0,32,0 %; !    - 48 -
macro DSRV$L_VCFAIL_CNT = 1420,0,32,0 %; !  Count of VC failures
macro DSRV$L_BLKCOUNT = 1424,0,0,0 %;
literal DSRV$S_BLKCOUNT = 516;          !  Counters for block xfer reqs
 
!*** MODULE $DTSSDEF ***
! +
! 
!  Bit definitions for EXE$GL_DTSSFLAGS - flags for Distributed Time Service
! 
! -
literal DTSS$M_ACTIVE = 1;
literal DTSS$S_DTSSDEF = 1;
macro DTSS$V_ACTIVE = 0,0,1,0 %;        !  Time service active
 
!*** MODULE $DYNDEF ***
! +
!  DATA STRUCTURE TYPE DEFINITIONS
! 
!  EACH DATA STRUCTURE THAT IS ALLOCATED FROM THE DYNAMIC MEMORY
!  POOL SHOULD HAVE A VALID TYPE IN ITS 11TH BYTE.
! -
! BASE AND OFFSET OF 1 
literal DYN$C_ADP = 1;                  ! UNIBUS ADAPTER CONTROL BLOCK 
literal DYN$C_ACB = 2;                  ! AST CONTROL BLOCK 
literal DYN$C_AQB = 3;                  ! ACP QUEUE BLOCK 
literal DYN$C_CEB = 4;                  ! COMMON EVENT BLOCK 
literal DYN$C_CRB = 5;                  ! CHANNEL REQUEST BLOCK 
literal DYN$C_DDB = 6;                  ! DEVICE DESCRIPTOR BLOCK 
literal DYN$C_FCB = 7;                  ! FILE CONTROL BLOCK 
literal DYN$C_FRK = 8;                  ! FORK BLOCK 
literal DYN$C_IDB = 9;                  ! INTERRUPT DISPATCH BLOCK 
literal DYN$C_IRP = 10;                 ! I/O REQUEST PACKET 
literal DYN$C_LOG = 11;                 ! LOGICAL NAME BLOCK 
literal DYN$C_PCB = 12;                 ! PROCESS CONTROL BLOCK 
literal DYN$C_PQB = 13;                 ! PROCESS QUOTA BLOCK 
literal DYN$C_RVT = 14;                 ! RELATIVE VOLUME TABLE 
literal DYN$C_TQE = 15;                 ! TIMER QUEUE ENTRY 
literal DYN$C_UCB = 16;                 ! UNIT CONTROL BLOCK 
literal DYN$C_VCB = 17;                 ! VOLUME CONTROL BLOCK 
literal DYN$C_WCB = 18;                 ! WINDOW CONTROL BLOCK 
literal DYN$C_BUFIO = 19;               ! BUFFERED I/O BLOCK 
literal DYN$C_TYPAHD = 20;              ! TERMINAL TYPEAHEAD BUFFER 
literal DYN$C_GSD = 21;                 ! GLOBAL SECTION DESCRIPTOR BLOCK 
literal DYN$C_MVL = 22;                 ! MAGNETIC TAPE VOLUME LIST 
literal DYN$C_NET = 23;                 ! NETWORK MESSAGE BLOCK 
literal DYN$C_KFE = 24;                 ! KNOWN FILE ENTRY 
literal DYN$C_MTL = 25;                 ! MOUNTED VOLUME LIST ENTRY 
literal DYN$C_BRDCST = 26;              ! BROADCAST MESSAGE BLOCK 
literal DYN$C_CXB = 27;                 ! COMPLEX CHAINED BUFFER 
literal DYN$C_NDB = 28;                 !  NETWORK NODE DESCRIPTOR BLOCK 
literal DYN$C_SSB = 29;                 !  LOGICAL LINK SUBCHANNEL STATUS BLOCK 
literal DYN$C_DPT = 30;                 !  DRIVER PROLOGUE TABLE 
literal DYN$C_JPB = 31;                 !  JOB PARAMETER BLOCK 
literal DYN$C_PBH = 32;                 !  PERFORMANCE BUFFER HEADER 
literal DYN$C_PDB = 33;                 !  PERFORMANCE DATA BLOCK 
literal DYN$C_PIB = 34;                 !  PERFORMANCE INFORMATION BLOCK 
literal DYN$C_PFL = 35;                 !  PAGE FILE CONTROL BLOCK 
literal DYN$C_PFLMAP = 36;              !  Page file mapping window
literal DYN$C_PTR = 37;                 !  POINTER CONTROL BLOCK 
literal DYN$C_KFRH = 38;                !  KNOWN FILE IMAGE HEADER 
literal DYN$C_DCCB = 39;                !  Data Cache Control Block
literal DYN$C_EXTGSD = 40;              ! EXTENDED GLOBAL SECTION DESCRIPTOR 
literal DYN$C_SHMGSD = 41;              ! SHARED MEMORY GLOBAL SECTION DESCRIPTOR 
literal DYN$C_SHB = 42;                 ! SHARED MEMORY CONTROL BLOCK 
literal DYN$C_MBX = 43;                 ! MAILBOX CONTROL BLOCK 
literal DYN$C_IRPE = 44;                ! I/O REQUEST PACKET EXTENSION 
literal DYN$C_SLAVCEB = 45;             ! SLAVE COMMON EVENT BLOCK 
literal DYN$C_SHMCEB = 46;              ! SHARED MEMORY MASTER COMMON EVENT BLOCK 
literal DYN$C_JIB = 47;                 ! JOB INFORMATION BLOCK 
literal DYN$C_TWP = 48;                 !  Terminal driver write packet 
literal DYN$C_RBM = 49;                 !  Realtime SPT bit map 
literal DYN$C_VCA = 50;                 !  Disk volume cache block 
literal DYN$C_CDB = 51;                 ! X25 LES CHANNEL DATA BLOCK 
literal DYN$C_LPD = 52;                 ! X25 LES PROCESS DESCRIPTOR 
literal DYN$C_LKB = 53;                 ! LOCK BLOCK 
literal DYN$C_RSB = 54;                 ! RESOURCE BLOCK 
literal DYN$C_LKID = 55;                ! LOCK ID TABLE 
literal DYN$C_RSHT = 56;                ! RESOURCE HASH TABLE 
literal DYN$C_CDRP = 57;                ! CLASS DRIVER REQUEST PACKET 
literal DYN$C_ERP = 58;                 !  ERRORLOG PACKET 
literal DYN$C_CIDG = 59;                ! DATAGRAM BUFFER FOR CI PORT 
literal DYN$C_CIMSG = 60;               ! MESSAGE BUFFER FOR CI PORT 
literal DYN$C_XWB = 61;                 ! DECNET LOGICAL LINK CONTEXT BLOCK 
!    (REPLACES "NDB" BLOCK)
literal DYN$C_WQE = 62;                 ! DECNET WORK QUEUE BLOCK 
!    (REPLACES "NET" BLOCK)
literal DYN$C_ACL = 63;                 ! ACCESS CONTROL LIST QUEUE ENTRY 
literal DYN$C_LNM = 64;                 ! LOGICAL NAME BLOCK 
literal DYN$C_FLK = 65;                 !  Fork Lock Request Block
literal DYN$C_RIGHTSLIST = 66;          ! RIGHTS LIST
literal DYN$C_KFD = 67;                 !  Known File Device Directory block
literal DYN$C_KFPB = 68;                !  Known File list Pointer Block
literal DYN$C_CIA = 69;                 !  Compound Intrusion Analysis block
literal DYN$C_PMB = 70;                 !  Page Fault Monitor Control Block
literal DYN$C_PFB = 71;                 !  Page Fault Monitor Buffer
literal DYN$C_CHIP = 72;                !  Internal CHKPRO block
literal DYN$C_ORB = 73;                 !  Objects Rights Block
literal DYN$C_QVAST = 74;               !  QVSS AST block
literal DYN$C_MVWB = 75;                !  Mount Verification work buffer
literal DYN$C_UNC = 76;                 !  Universal Context Block
literal DYN$C_DCB = 77;                 !  DCB, for DECnet chained I/O
literal DYN$C_VCRP = 78;                !  VAX Communication Request Packet
literal DYN$C_SPL = 79;                 !  Spinlock control block
literal DYN$C_ARB = 80;                 !  Access Rights Block
literal DYN$C_LCKCTX = 81;              !  Lock context block
literal DYN$C_BOD = 82;                 !  Buffer object descriptor
literal DYN$C_FTRD = 83;                !  FTDRIVER read request packet
literal DYN$C_DDTM_EVENT = 84;          !  DDTM Event Notification block
literal DYN$C_DFLB = 85;                !  Dump File Locator Block
literal DYN$C_PTC = 86;                 !  Posix Terminal Control
literal DYN$C_OCB = 87;                 !  Object Class Block (Security)
literal DYN$C_CPCB = 88;                !  Common Process Control Block 
literal DYN$C_HWPCB = 89;               !  Hardware Process Control Block 
literal DYN$C_GCB = 90;                 !  Glyph Control Block
literal DYN$C_RDPB = 91;                !  Resource Domain Pointer Block
literal DYN$C_RDDB = 92;                !  Resource Domain Data Block
! 
!  THE FOLLOWING CODES ARE SUBTYPABLE, THAT IS EACH CODE REFERS TO A GENERIC
!  FUNCTION AND WITHIN THAT FUNCTION THERE MAY BE MANY DIFFERENT SUB-TYPES
!  OF BLOCKS.  THIS SCHEME WAS ADOPTED TO PRESERVE TYPES.  THE SUB-TYPE IS
!  IN THE 12TH BYTE.
! 
literal DYN$C_SUBTYPE = 96;             !  START OF SUBTYPABLES 
literal DYN$C_SCS = 96;                 !  SYSTEM COMMUNICATION SERVICES 
literal DYN$C_SCS_CDL = 1;              !  CONNECT DISPATCH LIST 
literal DYN$C_SCS_CDT = 2;              !  CONNECT DISPATCH TABLE 
literal DYN$C_SCS_DIR = 3;              !  DIRECTORY BLOCK 
literal DYN$C_SCS_PB = 4;               !  PATH BLOCK 
literal DYN$C_SCS_PDT = 5;              !  PORT DESCRIPTOR TABLE 
literal DYN$C_SCS_RDT = 6;              !  REQUEST DESCRIPTOR TABLE 
literal DYN$C_SCS_SB = 7;               !  SYSTEM BLOCK 
literal DYN$C_SCS_SPPB = 8;             !  SCA POLLER PROCESS BLOCK
literal DYN$C_SCS_SPNB = 9;             !  SCA POLLER NAME BLOCK
literal DYN$C_SCS_SBNB = 10;            !  SCS LOAD SHARE NAME BLOCK
literal DYN$C_SCS_PLVEC = 11;           !  SCS PORT LOAD VECTOR
literal DYN$C_SCS_PDTLIST = 12;         !  (TYC 14-Feb-89) SCS PDT LIST
literal DYN$C_CI = 97;                  !  CI PORT SPECIFIC 
literal DYN$C_CI_BDT = 1;               !  BUFFER DESCRIPTOR TABLE 
literal DYN$C_CI_FQDT = 2;              !  FREE QUE DESCRIPTOR TABLE 
literal DYN$C_LOADCODE = 98;            !  LOADABLE CODE 
literal DYN$C_NON_PAGED = 1;            !  NON PAGED CODE
literal DYN$C_PAGED = 2;                !  PAGED CODE
literal DYN$C_LC_MP = 3;                !  MULTIPROCESSOR CODE 
literal DYN$C_LC_SCS = 4;               !  SCS CODE 
literal DYN$C_LC_CLS = 5;               !  CLUSTER CODE
literal DYN$C_LC_CHREML = 6;            !  CHAR/DECIMAL INS EMUL 
literal DYN$C_LC_FPEMUL = 7;            !  FLOAT PNT EMULATOR
literal DYN$C_LC_MSCP = 8;              !  MSCP SERVER
literal DYN$C_LC_SYSL = 9;              !  SYSLOA
literal DYN$C_INIT = 99;                !  STRUCTURES SET UP BY INIT 
literal DYN$C_PCBVEC = 1;               !  PROCESS CONTROL BLOCK VECTOR 
literal DYN$C_PHVEC = 2;                !  PROCESS HEADER VECTOR 
literal DYN$C_SWPMAP = 3;               !  SWAPPER MAP 
literal DYN$C_MPWMAP = 4;               !  MODIFIED PAGE WRITER MAP 
literal DYN$C_PRCMAP = 5;               !  PROCESS BITMAP 
literal DYN$C_BOOTCB = 6;               !  BOOT CONTROL BLOCK 
literal DYN$C_CONF = 7;                 !  CONFIGURATION ARRAYS 
literal DYN$C_CST = 8;                  !  CLUSTER SYSTEM TABLE
literal DYN$C_CLASSDRV = 100;           !  CLASS DRIVER MAJOR STRUCTURE TYPE CODE 
literal DYN$C_CD_CDDB = 1;              !  CLASS DRIVER DATA BLOCK 
literal DYN$C_CD_BBRPG = 2;             !  BAD BLOCK REPLACEMENT PAGE 
literal DYN$C_CD_SHDW_WRK = 3;          !  SHADOW SET WORK BUFFER
literal DYN$C_CLU = 101;                !  CLUSTER MAJOR STRUCTURE TYPE CODE
literal DYN$C_CLU_CSB = 1;              !  CONNECTION STATUS BLOCK
literal DYN$C_CLU_CLUVEC = 2;           !  CLUSTER SYSTEM VECTOR
literal DYN$C_CLU_CLUB = 3;             !  CLUSTER BLOCK
literal DYN$C_CLU_BTX = 4;              !  CLUSTER BLOCK TRANSFER EXTENSION
literal DYN$C_CLU_CLUDCB = 5;           !  CLUSTER DISK QUORUM CONTROL BLOCK
literal DYN$C_CLU_CLUOPT = 6;           !  CLUSTER OPTIMAL RECONFIGURATION CONTEXT BLOCK
literal DYN$C_CLU_LCKDIR = 7;           !  LOCK MANAGER DISTRIBUTED DIRECTORY VECTOR
literal DYN$C_CLU_ICB = 8;              !  INCARNATION FILE CONTROL BLOCK
literal DYN$C_CLU_CLURCB = 9;           !  REMASTER CONTROL BLOCK
literal DYN$C_CLU_NTE = 10;             !  NOTIFICATION TABLE ENTRY
literal DYN$C_CLU_CSDT = 11;            !  SERVER DISPATCH TABLE
literal DYN$C_PGD = 102;                !  PAGED DYNAMIC MEMORY
literal DYN$C_PGD_F11BC = 1;            !  F11BXQP BUFFER CACHE.
literal DYN$C_DECW = 103;               !  DECWINDOWS
literal DYN$C_DECW_GPB = 1;             !  GPX Packet Buffer
literal DYN$C_DECW_GPD = 2;             !  GPX Physical Data
literal DYN$C_DECW_INB = 3;             !  Input Buffer descriptor
literal DYN$C_DECW_DVI = 4;             !  Device Info block
literal DYN$C_VWS = 104;                !  UIS Structure
!  UIS subtypes
literal DYN$C_UIS_ARD = 1;              !  Allocation region 
literal DYN$C_UIS_VDB = 2;              !  Virtual display control block
literal DYN$C_UIS_WDB = 3;              !  Display window control block
literal DYN$C_UIS_SEG = 4;              !  Segment control block
literal DYN$C_UIS_ATB = 5;              !  Attribute block
literal DYN$C_UIS_OTP = 6;              !  Output primitive
literal DYN$C_UIS_APD = 7;              !  Application-specific data
literal DYN$C_UIS_SEGEND = 8;           !  Segment "end" marker (really part of SEG)
literal DYN$C_UIS_URG = 9;              !  User region AST request block
literal DYN$C_UIS_VDT = 10;             !  Display transformation
literal DYN$C_UIS_MENU = 11;            !  Window options menu or menu items
literal DYN$C_UIS_KBB = 12;             !  Virtual keyboard control block
literal DYN$C_UIS_RES = 13;             !  Resize/rescale information block
literal DYN$C_UIS_VCMD = 14;            !  Virtual color map descriptor
literal DYN$C_UIS_VCMS = 15;            !  Virtual color map section
literal DYN$C_UIS_CMSD = 16;            !  Color map segment descriptor
literal DYN$C_UIS_CMSB = 17;            !  Color map segment allocation control block
literal DYN$C_UIS_CMS = 18;             !  Color map segment
literal DYN$C_UIS_FNT = 19;             !  Font block
literal DYN$C_UIS_FNTH = 20;            !  Font header -- extra memory at head of a font
literal DYN$C_UIS_VPD = 21;             !  Viewport descriptor block
literal DYN$C_UIS_VRD = 22;             !  Viewport region descriptor
literal DYN$C_UIS_BMD = 23;             !  
literal DYN$C_UIS_OFF_MEM = 24;         !  Offscreen memory descriptor
literal DYN$C_UIS_USB = 25;             !  UIS system-wide storage
literal DYN$C_UIS_QBE = 26;             !  QVSS block extension
literal DYN$C_UIS_MEM = 27;             !  Video scanline allocation block
literal DYN$C_UIS_VSL_MEM = 28;         !  VAX scanline storage
literal DYN$C_UIS_SL_TEMP = 29;         !  Scanline temporary storage
literal DYN$C_UIS_ERROR = 30;           !  Error handler "spare" memory
!  VPS subtypes
literal DYN$C_VPS_FM = 86;              ! 
literal DYN$C_VPS_CTX = 87;             !  
literal DYN$C_VPS_PPD = 88;             !  Per-process data structure
literal DYN$C_VPS_SDB = 89;             !  Scan descriptor block
literal DYN$C_VPS_BTD = 90;             !  Bitmap descriptor
!  VWS subtypes
literal DYN$C_VWS_REGIS = 170;          !  ReGIS buffer
literal DYN$C_VWS_VT200 = 171;          !  VT200 emulator buffer
literal DYN$C_VWS_CHR_ARR = 172;        !  Character array
literal DYN$C_VWS_CLIP = 173;           !  Clipping region desc
literal DYN$C_VWS_CUR = 174;            ! 
literal DYN$C_VWS_FNTD = 175;           !  Font descriptor
literal DYN$C_VWS_SCR = 176;            ! 
literal DYN$C_VWS_UPD = 177;            ! 
literal DYN$C_VWS_UPDE = 178;           !  UPD extension
literal DYN$C_VWS_VIEW = 179;           !  Driver Viewport control block
literal DYN$C_VWS_DOP = 180;            !  Device output primative packet
literal DYN$C_VWS_GLYB = 181;           !  Glyph storage block
literal DYN$C_DSRV = 105;               !  Disk Server structure type
!  Server subtypes
literal DYN$C_DSRV_DSRV = 1;            !  Disk server structure
literal DYN$C_DSRV_HQB = 2;             !  Host Queue Block
literal DYN$C_DSRV_HRB = 3;             !  Host Request Block
literal DYN$C_DSRV_IOBUF = 4;           !  Server local I/O Buffer
literal DYN$C_DSRV_UQB = 5;             !  Unit Queue Block
literal DYN$C_DSRV_HULB = 6;            !  Host-Unit Load Block
literal DYN$C_MP = 106;                 !  MP related structure
!  MP subtypes
literal DYN$C_MP_MPB = 1;               !  Logical Console Block
literal DYN$C_MP_CPU = 2;               !  Per-CPU database
literal DYN$C_NSA = 107;                !  Non-discretionary Security Audit
literal DYN$C_NSA_EVENT = 1;            !  Event enable vectors
literal DYN$C_NSA_FAILURE = 2;          !  Failure mode vectors
literal DYN$C_NSA_ALARM = 3;            !  Security alarm packet list
literal DYN$C_CWPS = 108;               !  Cluster-Wide Process Services
!  CWPS subtypes for process control service codes
literal DYN$C_CWPS_CANWAK = 1;          !  $CANWAK service
literal DYN$C_CWPS_DELPRC = 2;          !  $DELPRC service
literal DYN$C_CWPS_FORCEX = 3;          !  $FORCEX service
literal DYN$C_CWPS_RESUME = 4;          !  $RESUME service
literal DYN$C_CWPS_SCHDWK = 5;          !  $SCHDWK service
literal DYN$C_CWPS_SETPRI = 6;          !  $SETPRI service
literal DYN$C_CWPS_SUSPND = 7;          !  $SUSPND service
literal DYN$C_CWPS_WAKE = 8;            !  $WAKE service
!  CWPS subtypes for other services
literal DYN$C_CWPS_GETJPI = 20;         !  $GETJPI service
literal DYN$C_CWPS_CREPRC = 21;         !  $CREPRC service
literal DYN$C_CWPS_TERMIN = 22;         !  process termination message
!  CWPS subtypes for security service codes
literal DYN$C_CWPS_GRANTID = 28;        !  $GRANTID service
literal DYN$C_CWPS_REVOKID = 29;        !  $WAKE service
!  CWPS subtypes for miscellaneous structures
literal DYN$C_CWPSACB = 64;             !  CWPSACB$ structure
literal DYN$C_CWPSNODI = 65;            !  CWPSNODI$ structure
literal DYN$C_CWPSSQH = 66;             !  CWPSSQH$ structure
literal DYN$C_PSCANBUF = 67;            !  PSCAN JPI buffer
literal DYN$C_PSCANCTX = 68;            !  PSCAN context
literal DYN$C_PSCANITM = 69;            !  PSCAN JPI itemlist
literal DYN$C_VP = 109;                 !  Vector processing support
!  Vector processing subtypes
literal DYN$C_VP_VCTX = 1;              !  Vector context block
literal DYN$C_VP_VEXC = 2;              !  Vector saved exception block
literal DYN$C_SHAD = 110;               !  Volume Shadowing structure type
literal DYN$C_VCC = 111;                !  VAXcluster cache
!  VCC subtypes
literal DYN$C_VCC_CL = 1;               !  Cache Line
literal DYN$C_VCC_CPT = 2;              !  Cache Page Table
literal DYN$C_VCC_HT = 3;               !  Hash Table
!  for VCC_CFCB SUBTYPE and RMOD overlap so force correct RMOD bits
literal DYN$C_VCC_CFCB = 32;            !  Cache FCB
literal DYN$C_ENS = 112;                !  Event Notification Services
!  ENS subtypes
literal DYN$C_ENS_ADB = 1;              !  AST Data Block
literal DYN$C_ENS_ECB = 2;              !  Cancelation Request Block
literal DYN$C_ENS_EDB = 3;              !  Event Declaration Block
literal DYN$C_ENS_EFD = 4;              !  Event Facility Descriptor
literal DYN$C_ENS_ENB = 5;              !  Notification Request Block
literal DYN$C_ENS_END = 6;              !  Event Notification Database Block
literal DYN$C_ENS_ENS = 7;              !  Server Base Block
literal DYN$C_ENS_EPB = 8;              !  Event Parameter Block
literal DYN$C_ENS_ETB = 9;              !  Event Tracking Block
literal DYN$C_ENS_NAB = 10;             !  NAme Block
literal DYN$C_ENS_SIG = 11;             !  Signature List Block
literal DYN$C_DDTM = 113;               !  Digital Distributed Transaction Mgr
!  DDTM subtypes
literal DYN$C_DDTM_XCB = 1;             !  Transaction Control Block
literal DYN$C_DDTM_XSCB = 2;            !  Transaction Segment Control Block
literal DYN$C_DDTM_XPCB = 3;            !  Transaction Participant Control Block
literal DYN$C_DDTM_CDCB = 4;            !  Commit Domain Control Block
literal DYN$C_DDTM_CMDB = 5;            !  Communication Manager Definition Block
literal DYN$C_DDTM_CMCB = 6;            !  Communication Manager Control Block
literal DYN$C_DDTM_RMCB = 7;            !  Resource Manager Control Block
literal DYN$C_DDTM_NDCB = 8;            !  V1 DDTM Communication Manager Block
literal DYN$C_DDTM_DGCB = 9;            !  TPCom Dialogue Control Block
literal DYN$C_DDTM_LGCB = 10;           !  Log Control Block
literal DYN$C_SMI = 114;                !  System Management Integrator 
!  SMI subtypes
literal DYN$C_SMI_CSCB = 1;             !  Cluster/System Communications Block
literal DYN$C_SMI_CTX = 2;              !  Internal context block
literal DYN$C_SMI_SUPB = 3;             !  Server User Profile Block
literal DYN$C_SMI_RTTB = 4;             !  RouTine Table Block
literal DYN$C_TSRV = 115;               !  Tape Server structure type
!  Server subtypes
literal DYN$C_TSRV_TSRV = 1;            !  Tape server structure
literal DYN$C_TSRV_HQB = 2;             !  Host Queue Block
literal DYN$C_TSRV_HRB = 3;             !  Host Request Block
literal DYN$C_TSRV_UQB = 4;             !  Unit Queue Block
literal DYN$C_TSRV_TBUFF = 5;           !  Tape local Buffer
literal DYN$C_LAVC = 116;               !  Local Area VAX Cluster structures.
!  LAVC subtypes
literal DYN$C_LAVC_ROOT = 1;            !  ROOT block data structure.
literal DYN$C_LAVC_PORT = 2;            !  PORT block data structure.
literal DYN$C_LAVC_VC = 3;              !  Virtual Circuit data structure.
literal DYN$C_LAVC_CH = 4;              !  Channel Block data structure.
literal DYN$C_LAVC_BUS = 5;             !  BUS block data structure.
literal DYN$C_LAVC_COMP = 6;            !  Network component description data structure.
literal DYN$C_LAVC_CLST = 7;            !  Network component list data structure.
literal DYN$C_LAVC_ID_TABLE = 8;        !  Network component ID table structure.
literal DYN$C_DECNET = 117;             !  DECNET structures
! 
!   DECNET subtype definitions.  Each component gets a multiple of 8
!   entries; except the first (which gets 7 because we wanted 0 to be
!   the unknown entry).
! 
literal DYN$C_NET_UNK = 0;              !  Unknown subtype of zero
! 
!   Base image vectors (2-8)
! 	   
literal DYN$C_NET_NBI_NDVEC = 2;        !  Network Data Vectors
literal DYN$C_NET_NBI_NBIRV = 3;        !  Global Routine Vectors
literal DYN$C_NET_NBI_GRVH = 4;         !  Global routine init vector header
literal DYN$C_NET_NBI_GRVE = 5;         !  Global routine init vector entry
! 
!   Common trace support data structures (9-16)
! 	   
literal DYN$C_NET_CTF_TB = 9;           !  Trace block
literal DYN$C_NET_CTF_TR = 10;          !  Trace record
literal DYN$C_NET_CTF_MH = 11;          !  Module header
literal DYN$C_NET_CTF_REQ = 12;         !  Trace requests
! 
!   EMAA support structures (17-24)
! 
literal DYN$C_NET_EMAA_MRCP = 17;       !  Management request control packet
literal DYN$C_NET_EMAA_IVK = 18;        !  Invoke block
literal DYN$C_NET_EMAA_EMAA = 19;       !  Misc dynamic EMAA structures
literal DYN$C_NET_EMAA_EIB = 20;        !  Entity information block
literal DYN$C_NET_EMAA_EISDB = 21;      !  Entity semantic block
literal DYN$C_NET_EMAA_EAB = 22;        !  Entity access block
literal DYN$C_NET_EMAA_IVKIDTBL = 23;   !  Invoke Block ID Table
literal DYN$C_NET_EMAA_ERTTBL = 24;     !  Entity Registration Table
! 
!   Loader support data structures (25-32)
! 	   
literal DYN$C_NET_LDR_LIE = 25;         !  Loaded Image Entry block
! 
!   Task support data structures (33-40)
! 	   
literal DYN$C_NET_TSK_NTK = 33;         !  Network task scheduler database
literal DYN$C_NET_TSK_TCX = 34;         !  Task context block
literal DYN$C_NET_TSK_TPB = 35;         !  Task parameter block
literal DYN$C_NET_TSK_SQX = 36;         !  Scheduler queue block
literal DYN$C_NET_TSK_SCX = 37;         !  Scheduler control block
! 
!   Timer support data structures (41-48)
! 	   
literal DYN$C_NET_TIM_NTM = 41;         !  Network timer database
literal DYN$C_NET_TIM_TEB = 42;         !  Timer element block
! 
!   VCI support data structures (49-56)
! 	   
literal DYN$C_NET_VCI_VRT = 49;         !  VCI Registration Table
literal DYN$C_NET_VCI_VID = 50;         !  VCI Identification Table
literal DYN$C_NET_VCI_VCIB = 51;        !  VCI Communication Info Block
! 
!   EVL support data structures (57-64)
! 	   
literal DYN$C_NET_EVL_EVT = 57;         !  EVL Event Report
! 
! 	Itemlist support structure (65-72)
! 
literal DYN$C_NET_ITEM = 65;            !  Network Itemlist
! 
! 	Session control support structure (73-88 = 16 entries)
! 
literal DYN$C_NET_SCL_SESSID = 73;      !  Session Connection Id Table
literal DYN$C_NET_SCL_SPB = 74;         !  Session Port Block
literal DYN$C_NET_SCL_SCLSVP = 75;      !  Session VCI Port data block
literal DYN$C_NET_SCL_SCLATTR = 76;     !  Session VCI port attribute block
literal DYN$C_NET_SCL_BUFFER = 77;      !  Generic session buffer
literal DYN$C_NET_SCL_CRPROC = 78;      !  Create process block
literal DYN$C_NET_SCL_CRPROCNCB = 79;   !  Create process NCB block
literal DYN$C_NET_SCL_USER_CRPROC = 80; !  Create process usermode block
! 
!   NSP support data structures (89-96)
! 	   
literal DYN$C_NET_NSP_ATB = 89;         !  NSP Association Table
literal DYN$C_NET_NSP_TCTB = 90;        !  NSP Transport Connection Table
literal DYN$C_NET_NSP_NSP = 91;         !  NSP service blk subtype
literal DYN$C_NET_NSP_LSP = 92;         !  LSP service blk subtype
literal DYN$C_NET_NSP_RSP = 93;         !  RSP service blk subtype
literal DYN$C_NET_NSP_PORT = 94;        !  PORT service blk subtype
! 
!   LAN support data structures (97-104)
! 	   
literal DYN$C_NET_LAN_LAN = 97;         !  LAN LAN Entity Block
literal DYN$C_NET_LAN_LSB = 98;         !  LAN Station Block
literal DYN$C_NET_LAN_LPB = 99;         !  LAN Port Block
! 
!   Thread support data structures (105-112)
! 	   
literal DYN$C_NET_THREAD = 105;         !  Thread Block
! 
! 	Network Routing Layer data structures (113-144 = 32 entries)
! 
literal DYN$C_NET_NRL_NRD = 113;        !  Global database
literal DYN$C_NET_NRL_HTB = 114;        !  Hash table header
literal DYN$C_NET_NRL_CKT = 115;        !  Circuit database entry
literal DYN$C_NET_NRL_ADJ = 116;        !  Adjacency database entry
literal DYN$C_NET_NRL_PSB = 117;        !  Protocol service block
literal DYN$C_NET_NRL_TP = 118;         !  Transport database entry
literal DYN$C_NET_NRL_CKTEVT = 119;     !  Circuit event block
! 
!   Node agent data structures (145-152)
! 
literal DYN$C_NET_NODE_IDS = 145;       !  ID table header
literal DYN$C_NET_NODE_DATABASE = 146;  !  Permanent database
! 
!   OSITP support data structures (153-168 = 16 Entries)
!    
literal DYN$C_NET_OSITP_ATB = 153;      !  OSI Association Table
literal DYN$C_NET_OSITP_TCTB = 154;     !  OSI Transport Connection Table
literal DYN$C_NET_OSITP_NCCB = 155;     !  OSI Transport 
!  Network Connection Block
literal DYN$C_NET_OSITP_ILB = 156;      !  OSI Transport 
!  Itemlist Block
literal DYN$C_NET_OSITP_TLB = 157;      !  OSI Transport 
!  Timer List Block
literal DYN$C_NET_OSITP_TMP = 158;      !  OSI Transport 
!  Template Name Block
literal DYN$C_NET_OSITP_OSI = 159;      !  OSI Transport 
!  OSI Block
literal DYN$C_NET_OSITP_PORT = 160;     !  OSI Transport 
!  port Block
literal DYN$C_NET_OSITP_LSP = 161;      !  OSI Transport 
!  LSP Block
literal DYN$C_NET_OSITP_RSP = 162;      !  OSI Transport 
!  RSP Block
! 
!   QIO data structures (169-176)
!    
literal DYN$C_NET_QIO_DAB = 169;        !  Declared Application Block
literal DYN$C_NET_QIO_QLB = 170;        !  QIO Link Block
! 
!   MOP data structures (177-192)
!    
literal DYN$C_NET_MOP_MRCPIN = 177;     !  MRCP Inbound from management
literal DYN$C_NET_MOP_MRCPOUT = 178;    !  MRCP Outbound to management
literal DYN$C_NET_MOP_MANAGEMENTABORT = 179; !  Management Abort Block
literal DYN$C_NET_MOP_CPRPIN = 180;     !  Create Port Request Packet Inbound
literal DYN$C_NET_MOP_CPRPOUT = 181;    !  Create Port Request Packet Outbound
literal DYN$C_NET_MOP_DPRPIN = 182;     !  Delete Port Request Packet Inbound
literal DYN$C_NET_MOP_DPRPOUT = 183;    !  Delete Port Request Packet Outbound
literal DYN$C_NET_MOP_VCRPIN = 184;     !  VCRP Inbound from Datalink
literal DYN$C_NET_MOP_VCRPOUT = 185;    !  VCRP Outbound to Datalink
literal DYN$C_NET_MOP_ENPIN = 186;      !  Event Notification Packet Inbound
literal DYN$C_NET_MOP_ENPOUT = 187;     !  Event Notification Packet Outbound
literal DYN$C_NET_MOP_PDUOUT = 188;     !  PDU Outbound to Datalink
literal DYN$C_NET_MOP_SUBPDU = 189;     !  Sub PDU
literal DYN$C_NET_MOP_CPB = 190;        !  Console Carrier Connect Parameter Block
literal DYN$C_NET_MOP_WORK = 191;       !  Thread Work BLock
! 
!  End of DECNET subtype definitions
! 
literal DYN$C_PSX = 118;                !  Generic type code for Posix structures
literal DYN$C_PSX_XCTX = 1;             !  System Service Context Area
literal DYN$C_PSX_XPCB = 2;             !  Extended PCB
literal DYN$C_PSX_XSIG = 3;             !  Signal Block
literal DYN$C_PSX_PXSB = 4;             !  Session Block
literal DYN$C_PSX_PXPG = 5;             !  Process Group Block
literal DYN$C_PSX_SHSH = 6;             !  Semaphore hash table
literal DYN$C_PSX_SIDT = 7;             !  Semaphore Id table
literal DYN$C_PSX_SOB = 8;              !  semaphore Operation block
literal DYN$C_PSX_SMB = 9;              !  semaphore block
literal DYN$C_PSX_FCCB = 10;            !  fork_callbacks control block
literal DYN$C_PSX_FCDB = 11;            !  fork_callbacks dispatch block
literal DYN$C_QMAN = 119;               !  Generic type code for Queue Manager structures
literal DYN$C_QMAN_QDB = 1;             !  Queue Data block
literal DYN$C_QMAN_QMANMSG = 2;         !  Queue manager message header
literal DYN$C_QMAN_GQC = 3;             !  Queue manager GETQUI context block
literal DYN$C_SM = 120;                 !  Storage Management Subtypes
literal DYN$C_SM_MMECB = 1;             !  MME control block
literal DYN$C_SM_MCB = 2;               !  Mount context block
literal DYN$C_MISC = 121;               !  Miscellaneous types
!  Miscellaneous data structures
literal DYN$C_CRAM = 1;                 !  Controller Register Access Mailbox
literal DYN$C_CRAMH = 2;                !  Page header for CRAM
! 
!  SPECIAL DYNAMIC MEMORY TYPES.  THESE ARE HANDLED SPECIALLY BY
!  EXE$DALONONPAGED.
! 
literal DYN$C_SPECIAL = 128;            !  START OF SPECIAL TYPES 
!  BASE OF 128 AND OFFSET OF 1 
literal DYN$C_SHRBUFIO = 128;           !  SHARED MEMORY BUFFERED I/O 
 
!*** MODULE $ECBDEF ***
! +
! 
!  Generalized Event Notification Definitions
! 
!  Event Cancelation Block
! 
!  This block is used by the $CANEVTAST system service to
!  cancel a cluster-wide notification request.
! 
! -
literal ECB$M_LOCAL = 1;
literal ECB$M_RSVD = 2;
literal ECB$M_IMAGE = 4;
literal ECB$M_RSVD2 = 24;
literal ECB$M_WILDCARD = 32;
literal ECB$K_LENGTH = 68;              !  LENGTH OF BLOCK
literal ECB$C_LENGTH = 68;              !  LENGTH OF BLOCK
literal ECB$S_ECBDEF = 68;
macro ECB$L_QFL = 0,0,32,0 %;           !  QUEUE FORWARD LINK     
macro ECB$L_QBL = 4,0,32,0 %;           !  QUEUE BACKWARD LINK    
macro ECB$W_SIZE = 8,0,16,0 %;          !  STRUCTURE SIZE IN BYTES
macro ECB$B_TYPE = 10,0,8,0 %;          !  STRUCTURE TYPE CODE    
macro ECB$B_SUBTYPE = 11,0,8,0 %;       !  STRUCTURE SUBTYPE CODE
macro ECB$L_FLAGS = 12,0,32,0 %;        !  FLAGS
macro ECB$V_LOCAL = 12,0,1,0 %;         !  LOCAL NODE
macro ECB$V_IMAGE = 12,2,1,0 %;         !  IMAGE
macro ECB$V_WILDCARD = 12,5,1,0 %;      !  WILDCARDED EVENT NAME
macro ECB$T_EVENT_NAME = 16,0,0,0 %;
literal ECB$S_EVENT_NAME = 32;          !  EVENT NAME
macro ECB$L_CSID = 48,0,32,0 %;         !  CLUSTER SYSTEM ID
macro ECB$L_EPID = 52,0,32,0 %;         !  PROCESS' EXTENDED PID
macro ECB$B_ACMODE = 56,0,8,0 %;        !  ACCESS MODE
macro ECB$W_EVTFAC = 58,0,16,0 %;       !  FACILITY CODE
macro ECB$L_UNIQID = 60,0,32,0 %;       !  GENERATED REQUEST ID
macro ECB$L_REQID = 64,0,32,0 %;        !  USER DEFINED REQUEST ID
 
!*** MODULE $EDBDEF ***
! +
! 
!  Generalized Event Notification Definitions
! 
!  Event Declaration Block
! 
!  This block is used by the $DCLEVT system service
!  to declare an event.
! 
! -
literal EDB$M_LOCAL = 1;
literal EDB$M_RSVD = 6;
literal EDB$M_FLOST = 8;
literal EDB$M_RSVD2 = 48;
literal EDB$K_LENGTH = 216;             !  LENGTH OF BLOCK
literal EDB$C_LENGTH = 216;             !  LENGTH OF BLOCK
literal EDB$S_EDBDEF = 216;
macro EDB$L_QFL = 0,0,32,0 %;           !  QUEUE FORWARD LINK 
macro EDB$L_QBL = 4,0,32,0 %;           !  QUEUE BACKWARD LINK
macro EDB$W_SIZE = 8,0,16,0 %;          !  STRUCTURE SIZE IN BYTES
macro EDB$B_TYPE = 10,0,8,0 %;          !  STRUCTURE TYPE CODE
macro EDB$B_SUBTYPE = 11,0,8,0 %;       !  STRUCTURE SUBTYPE CODE
! 
!  Start of $GETEVI data.  For efficiency, this must agree with EVIDEF.
! 
macro EDB$L_FLAGS = 12,0,32,0 %;        !  FLAGS
macro EDB$V_LOCAL = 12,0,1,0 %;         !   LOCAL NODE
macro EDB$V_FLOST = 12,3,1,0 %;         !   FLOST
macro EDB$L_CSID = 16,0,32,0 %;         !  CLUSTER SYSTEM ID
macro EDB$L_EPID = 20,0,32,0 %;         !  PROCESS'S EXTENDED PID
macro EDB$B_ACMODE = 24,0,8,0 %;        !  ACCESS MODE
macro EDB$W_EVTFAC = 26,0,16,0 %;       !  FACILITY CODE
macro EDB$W_ULE_COUNT = 28,0,16,0 %;    !  FORK LOST EVENT COUNT
macro EDB$W_FLE_COUNT = 30,0,16,0 %;    !  USER LOST EVENT COUNT
macro EDB$Q_EVENT_TIME = 32,0,0,0 %;
literal EDB$S_EVENT_TIME = 16;          !  EVENT TIME 
macro EDB$T_EVENT_NAME = 48,0,0,0 %;
literal EDB$S_EVENT_NAME = 32;          !  EVENT NAME
macro EDB$T_EVENT_DATA = 80,0,0,0 %;
literal EDB$S_EVENT_DATA = 128;         !  OPTIONAL EVENT DATA
! 
!  End of GETEVI data
! 
macro EDB$L_IDENTIFIER = 208,0,32,0 %;  !  IDENTIFIER OF DECLARING PROCESS
macro EDB$L_ORB = 212,0,32,0 %;         !  POINTER TO EVENT FACILITY ORB
 
!*** MODULE $EFADEF ***
! +
!  DEFINE FLAGS VIELDS
! -
literal EFA$M_DISABLE_PRIMARY_CACHE = 1;
literal EFA$M_DISABLE_BACKUP_CACHE = 2;
literal EFA$M_DISABLE_VIC = 4;
literal EFA$M_SPARE1 = 8;
literal EFA$M_SPARE2 = 16;
literal EFA$M_SPARE3 = 32;
literal EFA$S_EFADEF = 1;
macro EFA$V_DISABLE_PRIMARY_CACHE = 0,0,1,0 %; !  Disable primary cache
macro EFA$V_DISABLE_BACKUP_CACHE = 0,1,1,0 %; !  Disable backup cache
macro EFA$V_DISABLE_VIC = 0,2,1,0 %;    !  Disable virtual instruction cache
macro EFA$V_SPARE1 = 0,3,1,0 %;         !  Spare bit definition
macro EFA$V_SPARE2 = 0,4,1,0 %;         !  Spare bit definition
macro EFA$V_SPARE3 = 0,5,1,0 %;         !  Spare bit definition
 
!*** MODULE $EFDDEF ***
! +
! 
!  Event Facility Descriptor block definitions
! 
!  Event facility descriptor blocks contain a built-in ORB with an
!  event facility code to identify the block.
! 
! -
literal EFD$M_PROT_16 = 1;
literal EFD$M_ACL_QUEUE = 2;
literal EFD$M_MODE_VECTOR = 4;
literal EFD$M_NOACL = 8;
literal EFD$M_CLASS_PROT = 16;
literal EFD$K_LENGTH = 100;             !  Length of block.
literal EFD$C_LENGTH = 100;             !  Length of block. 
literal EFD$S_EFDDEF = 100;
macro EFD$L_EFDQFL = 0,0,32,0 %;        !  EFD forward link 
macro EFD$L_EFDQBL = 4,0,32,0 %;        !  EFD backward link 
macro EFD$W_SIZE = 8,0,16,0 %;          !  Structure size in bytes
macro EFD$B_TYPE = 10,0,8,0 %;          !  Structure type code 
macro EFD$B_SUBTYPE = 11,0,8,0 %;       !  Structure subtype code
! 
!  Start of built-in ORB
! 
macro EFD$L_OWNER = 12,0,32,0 %;        !  Object's owner
macro EFD$W_UICMEMBER = 12,0,16,0 %;    !  Member number
macro EFD$W_UICGROUP = 14,0,16,0 %;     !  Group number
macro EFD$L_ACL_MUTEX = 16,0,32,0 %;    !  Mutex for this ACL
macro EFD$W_ORB_SIZE = 20,0,16,0 %;     !  Size of the ORB in bytes
macro EFD$B_ORB_TYPE = 22,0,8,0 %;      !  Structure type
macro EFD$B_FLAGS = 23,0,8,0 %;         !  Field modifiers
macro EFD$V_PROT_16 = 23,0,1,0 %;       !  Use word not vector protection
macro EFD$V_ACL_QUEUE = 23,1,1,0 %;     !  Use ACL queue not descriptor list
macro EFD$V_MODE_VECTOR = 23,2,1,0 %;   !  Use vector not byte mode protection
macro EFD$V_NOACL = 23,3,1,0 %;         !  Object cannot have an ACL
macro EFD$V_CLASS_PROT = 23,4,1,0 %;    !  Security classification is valid
macro EFD$W_FACILITY_CODE = 24,0,16,0 %; !  Event facility code
macro EFD$W_REFCOUNT = 26,0,16,0 %;     !  Reference count
macro EFD$Q_MODE_PROT = 28,0,0,0 %;
literal EFD$S_MODE_PROT = 8;            !  Mode protection vector
macro EFD$L_MODE_PROTL = 28,0,32,0 %;   !  Low longword of vector
macro EFD$L_MODE_PROTH = 32,0,32,0 %;   !  High longword of vector
macro EFD$B_MODE = 28,0,8,0 %;          !  Simple access mode
macro EFD$L_SYS_PROT = 36,0,32,0 %;     !  System protection field
macro EFD$W_PROT = 36,0,16,0 %;         !  Standard SOGW protection
macro EFD$L_OWN_PROT = 40,0,32,0 %;     !  Owner protection field
macro EFD$L_GRP_PROT = 44,0,32,0 %;     !  Group protection field
macro EFD$L_WOR_PROT = 48,0,32,0 %;     !  World protection field
macro EFD$L_ACLFL = 52,0,32,0 %;        !  ACL queue forward link
macro EFD$L_ACL_COUNT = 52,0,32,0 %;    !  Count of ACL segments
macro EFD$L_ACLBL = 56,0,32,0 %;        !  ACL queue backward link
macro EFD$L_ACL_DESC = 56,0,32,0 %;     !  Address of ACL segment descriptor list
macro EFD$R_MIN_CLASS = 60,0,0,0 %;
literal EFD$S_MIN_CLASS = 20;
macro EFD$R_MAX_CLASS = 80,0,0,0 %;
literal EFD$S_MAX_CLASS = 20;
 
!*** MODULE $EMBHDDEF ***
! 
!  ERROR MESSAGE BUFFER HEADER
! 
!                 ******        CAUTION  ******
! 
!         ALL OF THE EMBxxDEF STRUCTURES ASSUME THAT THE HEADER IS
!         EXACTLY ONE LONGWORD IN LENGTH.  IF THIS FIELD CHANGES,
!         IF EFFECTS ALL OF THE OTHER STRUCTURES.
!         ALL MESSAGES HAVE TYPE, TIME, SYSTEM ID, AND ERROR SEQUENCE IN THE
!         SAME RELATIVE LOCATIONS.
! 
!  HDR REVISIONS
literal EMB$K_HD_REV_V50 = 2;
literal EMB$K_HD_REV_V51 = 3;
literal EMB$K_HD_REV_HICKORY = 4;
!  HDR REVISIONS
literal EMB$C_HD_REV_V50 = 2;
literal EMB$C_HD_REV_V51 = 3;
literal EMB$C_HD_REV_HICKORY = 4;
!  OS ID's
literal EMB$C_OS_RESERVED = 0;
literal EMB$C_OS_VAXVMS = 1;
literal EMB$C_OS_VAXELN = 2;
!  OS ID's
literal EMB$K_OS_RESERVED = 0;
literal EMB$K_OS_VAXVMS = 1;
literal EMB$K_OS_VAXELN = 2;
!  This determines the SCS node name  buffer size
literal EMB$C_SCS_NAME_LENGTH = 16;     !  Buffer size for SCS name
literal EMB$K_SCS_NAME_LENGTH = 16;     !  Buffer size for SCS name
literal EMB$K_LENGTH = 12;              ! LENGTH OF FIXED PART OF MESSAGE HEADER 
literal EMB$K_HD_LENGTH = 64;           ! LENGTH OF PART COMMON TO ALL MESSAGES 
literal EMB$C_HD_LENGTH = 64;           ! LENGTH OF PART COMMON TO ALL MESSAGES 
literal EMB$S_EMBHDDEF = 76;
macro EMB$W_SIZE = -12,0,16,0 %;        ! SIZE OF ERROR MESSAGE IN BYTES 
macro EMB$W_BUFIND = -10,0,16,0 %;      ! ALLOCATION BUFFER INDICATOR
macro EMB$L_CHKSUM = -8,0,32,0 %;       !  HEADER CHECKSUM
macro EMB$B_VALID = -4,0,8,0 %;         ! ERROR MESSAGE VALID INDICATOR 
macro EMB$B_SPARE1 = -3,0,8,0 %;        !  SPARE
macro EMB$B_SPARE2 = -2,0,8,0 %;        !  SPARE
macro EMB$B_SPARE3 = -1,0,8,0 %;        !  SPARE
! 
!  Changes to offsets starting with HD_SID, the origin of this aggregate,
!  require the Header Revision to be increased. Each error message is
!  logged to the error log file in an RMS record that contains the
!  error packet, starting from offset HD_SID. The remainder of the packet
!  format is known to ERF and must be kept in synch with ERF via the
!  revision level.
! 
macro EMB$L_HD_SID = 0,0,32,0 %;        !  SYSTEM ID
macro EMB$W_HD_HDR_REV = 4,0,16,0 %;    !  HEADER REVISION (IN 1's COMPLEMENT)
macro EMB$L_HD_SYSTYPE = 6,0,32,0 %;    !  SYSTEM TYPE REGISTER
macro EMB$W_HD_XSID_RSV = 6,0,16,0 %;   !  RESERVED FOR TYPE-DEPENDENT INFO
macro EMB$B_HD_XSID_REV = 8,0,8,0 %;    !  REVISION LEVEL OF CPU
macro EMB$B_HD_XSID_TYP = 9,0,8,0 %;    !  SYS_TYPE, CPU TYPE
macro EMB$L_CPUID = 10,0,32,0 %;        !  UNIQUE CPU ID
macro EMB$B_DEV_CLASS = 14,0,8,0 %;     !  DEVICE CLASS
macro EMB$B_DEV_TYPE = 15,0,8,0 %;      !  DEVICE TYPE
macro EMB$T_SCS_NAME = 16,0,0,0 %;
literal EMB$S_SCS_NAME = 16;            !  SCS Node name ASCIC
macro EMB$W_FLAGS = 32,0,16,0 %;        !  MISC. FLAGS
macro EMB$B_OS_ID = 34,0,8,0 %;         !  LOGGING OP SYS ID
macro EMB$B_HDRSZ = 35,0,8,0 %;         !  SIZE OF HEADER
macro EMB$W_HD_ENTRY = 36,0,16,0 %;     ! ERROR MESSAGE ENTRY TYPE 
macro EMB$B_DEVTYP = 36,0,8,0 %;        ! DEVICE TYPE 
macro EMB$B_DEVCLS = 37,0,8,0 %;        ! DEVICE CLASS 
macro EMB$Q_HD_TIME = 38,0,0,0 %;
literal EMB$S_HD_TIME = 8;              ! TIME OF MESSAGE ENTRY 
macro EMB$W_HD_ERRSEQ = 46,0,16,0 %;    ! ERROR SEQUENCE FOR MESSAGE 
macro EMB$Q_HD_SWVERS = 48,0,0,0 %;
literal EMB$S_HD_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_HD_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_HD_ABSTIM = 60,0,32,0 %;    !  LOGGED CONTENTS OF EXE$GL_ABSTIM
literal EMB$M_EM_BUS = 1;
literal EMB$M_EM_CPU = 2;
literal EMB$M_EM_MEMORY = 4;
literal EMB$M_EM_ADAPTER = 8;
literal EMB$M_EM_CACHE = 16;
literal EMB$M_EM_VECTOR = 32;
literal EMB$M_RSRVD1 = 64;
literal EMB$S_fill_210 = 4;
macro EMB$V_EM_BUS = 0,0,1,0 %;         !  bus error
macro EMB$V_EM_CPU = 0,1,1,0 %;         !  cpu error
macro EMB$V_EM_MEMORY = 0,2,1,0 %;      !  memory error
macro EMB$V_EM_ADAPTER = 0,3,1,0 %;     !  adapter error
macro EMB$V_EM_CACHE = 0,4,1,0 %;       !  cache error
macro EMB$V_EM_VECTOR = 0,5,1,0 %;      !  VECTOR error
macro EMB$V_RSRVD1 = 0,6,1,0 %;         !  Reserved
 
!*** MODULE $EMBINFODEF ***
! 
!  INFORMATIONAL MESSAGE BUFFER FORMAT 
! 
literal EMB$S_EMBINFODEF = 69;
macro EMB$L_INFO_MSG_TYPE = 64,0,32,0 %; !  Informational msg type
macro EMB$B_INFO_MSG_DATA = 68,0,8,0 %; !  Device dependent data
 
!*** MODULE $EMBBCDEF ***
! 
!  BUGCHECK ERROR MESSAGE BUFFER FORMAT (SYSTEM AND USER)
! 
literal EMB$K_BC_LENGTH = 176;          ! SIZE OF FIXED PART OF BUGCHECK MESSAGE 
literal EMB$C_BC_LENGTH = 176;          ! SIZE OF FIXED PART OF BUGCHECK MESSAGE 
literal EMB$S_EMBBCDEF = 176;
macro EMB$L_BC_SID = 0,0,32,0 %;        ! SYSTEM ID 
macro EMB$W_BC_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_BC_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_BC_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_BC_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_BC_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$T_BC_SCS_NAME = 16,0,0,0 %;
literal EMB$S_BC_SCS_NAME = 16;         !  SCS node name ASCIC
macro EMB$W_BC_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_BC_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_BC_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_BC_ENTRY = 36,0,16,0 %;     ! ENTRY TYPE 
macro EMB$Q_BC_TIME = 38,0,0,0 %;
literal EMB$S_BC_TIME = 8;              ! TIME IN 64 BITS 
macro EMB$W_BC_ERRSEQ = 46,0,16,0 %;    ! ERROR SEQUENCE NUMBER 
macro EMB$Q_BC_SWVERS = 48,0,0,0 %;
literal EMB$S_BC_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_BC_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_BC_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$L_BC_KSP = 64,0,32,0 %;       ! KERNEL STACK POINTER 
macro EMB$L_BC_ESP = 68,0,32,0 %;       ! EXECUTIVE STACK POINTER 
macro EMB$L_BC_SSP = 72,0,32,0 %;       ! SUPERVISOR STACK POINTER 
macro EMB$L_BC_USP = 76,0,32,0 %;       ! USER STACK POINTER 
macro EMB$L_BC_ISP = 80,0,32,0 %;       ! INTERRUPT STACK POINTER 
macro EMB$L_BC_R0 = 84,0,32,0 %;        ! REGISTER R0 
macro EMB$L_BC_R1 = 88,0,32,0 %;        ! REGISTER R1 
macro EMB$L_BC_R2 = 92,0,32,0 %;        ! REGISTER R2 
macro EMB$L_BC_R3 = 96,0,32,0 %;        ! REGISTER R3 
macro EMB$L_BC_R4 = 100,0,32,0 %;       ! REGISTER R4 
macro EMB$L_BC_R5 = 104,0,32,0 %;       ! REGISTER R5 
macro EMB$L_BC_R6 = 108,0,32,0 %;       ! REGISTER R6 
macro EMB$L_BC_R7 = 112,0,32,0 %;       ! REGISTER R7 
macro EMB$L_BC_R8 = 116,0,32,0 %;       ! REGISTER R8 
macro EMB$L_BC_R9 = 120,0,32,0 %;       ! REGISTER R9 
macro EMB$L_BC_R10 = 124,0,32,0 %;      ! REGISTER R10 
macro EMB$L_BC_R11 = 128,0,32,0 %;      ! REGISTER R11 
macro EMB$L_BC_AP = 132,0,32,0 %;       ! ARGUMENT POINTER 
macro EMB$L_BC_FP = 136,0,32,0 %;       ! FRAME POINTER 
macro EMB$L_BC_SP = 140,0,32,0 %;       ! CURRENT STACK POINTER 
macro EMB$L_BC_PC = 144,0,32,0 %;       ! PROGRAM COUNTER 
macro EMB$L_BC_PSL = 148,0,32,0 %;      ! PROCESSOR STATUS 
macro EMB$L_BC_CODE = 152,0,32,0 %;     ! BUGCHECK CODE 
macro EMB$L_BC_PID = 156,0,32,0 %;      ! CURRENT PROCESS ID 
macro EMB$T_BC_LNAME = 160,0,0,0 %;
literal EMB$S_BC_LNAME = 16;            ! CURRENT PROCESS NAME 
 
!*** MODULE $EMBCRDEF ***
! 
!  CRASH-RESTART ERROR MESSAGE BUFFER FORMAT
! 
literal EMB$K_CR_LENGTH = 196;
literal EMB$C_CR_LENGTH = 196;
literal EMB$S_EMBCRDEF = 200;
macro EMB$L_CR_SID = 0,0,32,0 %;        ! SYSTEM ID 
macro EMB$W_CR_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_CR_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_CR_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_CR_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_CR_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$B_CR_SCS_NAME = 16,0,0,1 %;
literal EMB$S_CR_SCS_NAME = 16;         !  SCS node name in ASCIC
macro EMB$W_CR_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_CR_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_CR_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_CR_ENTRY = 36,0,16,0 %;     ! ENTRY TYPE 
macro EMB$Q_CR_TIME = 38,0,0,0 %;
literal EMB$S_CR_TIME = 8;              ! TIME IN 64 BITS 
macro EMB$W_CR_ERRSEQ = 46,0,16,0 %;    ! ERROR SEQUENCE NUMBER 
macro EMB$Q_CR_SWVERS = 48,0,0,0 %;
literal EMB$S_CR_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_CR_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_CR_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$L_CR_KSP = 64,0,32,0 %;       ! KERNEL STACK POINTER 
macro EMB$L_CR_ESP = 68,0,32,0 %;       ! EXECUTIVE STACK POINTER 
macro EMB$L_CR_SSP = 72,0,32,0 %;       ! SUPERVISOR STACK POINTER 
macro EMB$L_CR_USP = 76,0,32,0 %;       ! USER STACK POINTER 
macro EMB$L_CR_ISP = 80,0,32,0 %;       ! INTERRUPT STACK POINTER 
macro EMB$L_CR_R0 = 84,0,32,0 %;        ! REGISTER R0 
macro EMB$L_CR_R1 = 88,0,32,0 %;        ! REGISTER R1 
macro EMB$L_CR_R2 = 92,0,32,0 %;        ! REGISTER R2 
macro EMB$L_CR_R3 = 96,0,32,0 %;        ! REGISTER R3 
macro EMB$L_CR_R4 = 100,0,32,0 %;       ! REGISTER R4 
macro EMB$L_CR_R5 = 104,0,32,0 %;       ! REGISTER R5 
macro EMB$L_CR_R6 = 108,0,32,0 %;       ! REGISTER R6 
macro EMB$L_CR_R7 = 112,0,32,0 %;       ! REGISTER R7 
macro EMB$L_CR_R8 = 116,0,32,0 %;       ! REGISTER R8 
macro EMB$L_CR_R9 = 120,0,32,0 %;       ! REGISTER R9 
macro EMB$L_CR_R10 = 124,0,32,0 %;      ! REGISTER R10 
macro EMB$L_CR_R11 = 128,0,32,0 %;      ! REGISTER R11 
macro EMB$L_CR_AP = 132,0,32,0 %;       ! ARGUMENT POINTER 
macro EMB$L_CR_FP = 136,0,32,0 %;       ! FRAME POINTER 
macro EMB$L_CR_SP = 140,0,32,0 %;       ! CURRENT STACK POINTER 
macro EMB$L_CR_PC = 144,0,32,0 %;       ! PROGRAM COUNTER 
macro EMB$L_CR_PSL = 148,0,32,0 %;      ! PROCESSOR STATUS 
macro EMB$L_CR_P0BR = 152,0,32,0 %;     ! PROGRAM REGION BASE REGISTER 
macro EMB$L_CR_P0LR = 156,0,32,0 %;     ! PROGRAM REGION LIMIT REGISTER 
macro EMB$L_CR_P1BR = 160,0,32,0 %;     ! CONTROL REGION BASE REGISTER 
macro EMB$L_CR_P1LR = 164,0,32,0 %;     ! CONTROL REGION LIMIT REGISTER 
macro EMB$L_CR_SBR = 168,0,32,0 %;      ! SYSTEM BASE REGISTER 
macro EMB$L_CR_SLR = 172,0,32,0 %;      ! SYSTEM LIMIT REGISTER 
macro EMB$L_CR_PCBB = 176,0,32,0 %;     ! PROCESS CONTROL BLOCK BASE REGISTER 
macro EMB$L_CR_SCBB = 180,0,32,0 %;     ! SYSTEM CONTROL BLOCK BASE REGISTER 
macro EMB$L_CR_ASTLVL = 184,0,32,0 %;   ! AST DELIVERY LEVEL REGISTER 
macro EMB$L_CR_SISR = 188,0,32,0 %;     ! SOFTWARE INTERRUPT SUMMARY REGISTER 
macro EMB$L_CR_ICCS = 192,0,32,0 %;     ! INTERVAL TIMER CONTROL STATUS REGISTER 
!  Remember start of CPU-dependent info
macro EMB$L_CR_CPUREG = 196,0,32,0 %;   ! START OF CPU-SPECIFIC IPR'S 
!  CPU-specific registers for the 11/780:
literal EMB$K_CR1_LENGTH = 292;
literal EMB$C_CR1_LENGTH = 292;
literal EMB$S_EMBCRDEF1 = 292;
macro EMB$L_CR_ICR = 196,0,32,0 %;      ! INTERVAL COUNT REGISTER 
macro EMB$L_CR_TODR = 200,0,32,0 %;     ! TIME OF DAY REGISTER 
macro EMB$L_CR_ACCS = 204,0,32,0 %;     ! ACCELERATOR CONTROL REGISTER 
macro EMB$L_CR_SBIFS = 208,0,32,0 %;    !  SBI FAULT STATUS 
macro EMB$L_CR_SBISC = 212,0,32,0 %;    !  SBI COMPARATOR REGISTER 
macro EMB$L_CR_SBIMT = 216,0,32,0 %;    !  SBI MAINT REGISTER 
macro EMB$L_CR_SBIER = 220,0,32,0 %;    !  SBI ERROR REGISTER 
macro EMB$L_CR_SBITA = 224,0,32,0 %;    !  SBI TIMEOUT ADDR REGISTER 
macro EMB$L_CR_SBIS = 228,0,0,0 %;
literal EMB$S_CR_SBIS = 64;             !  SBI SILO 
!  CPU-specific registers for the 11/750:
literal EMB$K_CR2_LENGTH = 228;
literal EMB$C_CR2_LENGTH = 228;
literal EMB$S_EMBCRDEF2 = 228;
macro EMB$L_CR_TBDR = 208,0,32,0 %;     !  TB DISABLE REGISTER 
macro EMB$L_CR_CADR = 212,0,32,0 %;     !  CACHE DISABLE REGISTER 
macro EMB$L_CR_MCESR = 216,0,32,0 %;    !  MACHINE CHECK ERROR SUMMARY 
macro EMB$L_CR_CAER = 220,0,32,0 %;     !  CACHE ERROR REGISTER 
macro EMB$L_CR_CMIERR = 224,0,32,0 %;   !  CMI ERROR SUMMARY REGISTER 
!  16 UNUSED LONGWDS IN EMB
literal EMB$K_CR3_LENGTH = 316;         ! SIZE OF FIXED PART OF BUGCHECK MESSAGE 
literal EMB$C_CR3_LENGTH = 316;         ! SIZE OF FIXED PART OF BUGCHECK MESSAGE 
literal EMB$S_EMBCRDEF3 = 316;
macro EMB$L_CR_CODE = 292,0,32,0 %;     ! BUGCHECK/CRASH CODE 
macro EMB$L_CR_PID = 296,0,32,0 %;      ! CURRENT PROCESS ID 
macro EMB$T_CR_LNAME = 300,0,0,0 %;
literal EMB$S_CR_LNAME = 16;            ! CURRENT PROCESS NAME 
 
!*** MODULE $EMBDVDEF ***
! 
!  DEVICE ERROR MESSAGE BUFFER FORMAT (ERROR AND TIMEOUT)
! 
literal EMB$K_DV_LENGTH = 146;
literal EMB$C_DV_LENGTH = 146;
literal EMB$S_EMBDVDEF = 146;
macro EMB$L_DV_SID = 0,0,32,0 %;        ! SYSTEM ID 
macro EMB$W_DV_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_DV_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_DV_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_DV_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_DV_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$B_DV_SCS_NAME = 16,0,0,1 %;
literal EMB$S_DV_SCS_NAME = 16;         !  SCS node name in ASCIC
macro EMB$W_DV_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_DV_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_DV_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_DV_ENTRY = 36,0,16,0 %;     ! ENTRY TYPE (1=ERROR, 96=TIMEOUT) 
macro EMB$Q_DV_TIME = 38,0,0,0 %;
literal EMB$S_DV_TIME = 8;              ! TIME OF ERROR 
macro EMB$W_DV_ERRSEQ = 46,0,16,0 %;    ! ERROR SEQUENCE NUMBER 
macro EMB$Q_DV_SWVERS = 48,0,0,0 %;
literal EMB$S_DV_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_DV_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_DV_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$B_DV_ERTCNT = 64,0,8,0 %;     ! REMAINING NUMBER OF ERROR RETRIES 
macro EMB$B_DV_ERTMAX = 65,0,8,0 %;     ! MAXIMUM NUMBER OF ERROR RETRIES 
macro EMB$Q_DV_IOSB = 66,0,0,0 %;
literal EMB$S_DV_IOSB = 8;              ! FINAL I/O STATUS 
macro EMB$W_DV_STS = 74,0,16,0 %;       ! FINAL DEVICE STATUS 
macro EMB$B_DV_CLASS = 76,0,8,0 %;      ! DEVICE CLASS 
macro EMB$B_DV_TYPE = 77,0,8,0 %;       ! DEVICE TYPE 
macro EMB$L_DV_RQPID = 78,0,32,0 %;     ! REQUESTER PROCESS ID 
macro EMB$W_DV_BOFF = 82,0,16,0 %;      ! BYTE OFFSET IN PAGE 
macro EMB$W_DV_BCNT = 84,0,16,0 %;      ! TRANSFER BYTE COUNT 
macro EMB$L_DV_MEDIA = 86,0,32,0 %;     ! STARTING MEDIA ADDRESS 
macro EMB$W_DV_UNIT = 90,0,16,0 %;      ! PHYSICAL UNIT NUMBER 
macro EMB$W_DV_ERRCNT = 92,0,16,0 %;    ! UNIT ERROR COUNT 
macro EMB$L_DV_OPCNT = 94,0,32,0 %;     ! UNIT OPERATION COUNT 
macro EMB$L_DV_OWNUIC = 98,0,32,0 %;    ! VOLUME OWNER UIC 
macro EMB$L_DV_CHAR = 102,0,32,0 %;     ! DEVICE CHARACTERISTICS 
macro EMB$B_DV_SLAVE = 106,0,8,0 %;     ! SLAVE CONTROLLER NUMBER 
macro EMB$W_DV_FUNC = 108,0,16,0 %;     ! I/O FUNCTION VALUE 
macro EMB$T_DV_NAME = 110,0,0,0 %;
literal EMB$S_DV_NAME = 32;             ! DEVICE NAME 
macro EMB$L_DV_REGSAV = 142,0,32,0 %;   ! START OF REGISTER SAVE AREA 
 
!*** MODULE $EMBTSDEF ***
! 
!  TIME STAMP MSG FORMAT
! 
literal EMB$K_TS_LENGTH = 64;           ! LENGTH OF TIME STAMP MSG 
literal EMB$C_TS_LENGTH = 64;           ! LENGTH OF TIME STAMP MSG 
literal EMB$S_EMBTSDEF = 64;
macro EMB$L_TS_SID = 0,0,32,0 %;        ! SYSTEM ID 
macro EMB$W_TS_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_TS_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_TS_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_TS_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_TS_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$B_TS_SCS_NAME = 16,0,0,1 %;
literal EMB$S_TS_SCS_NAME = 16;         !  SCS node name in ASCIC
macro EMB$W_TS_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_TS_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_TS_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_TS_ENTRY = 36,0,16,0 %;     ! ENTRY TYPE 
macro EMB$Q_TS_TIME = 38,0,0,0 %;
literal EMB$S_TS_TIME = 8;              ! TIME IN 64 BITS 
macro EMB$W_TS_ERRSEQ = 46,0,16,0 %;    ! ERROR SEQ ! 
macro EMB$Q_TS_SWVERS = 48,0,0,0 %;
literal EMB$S_TS_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_TS_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_TS_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
 
!*** MODULE $EMBSSDEF ***
! 
!  SYSTEM SERVICE MESSAGE
! 
!         NOTE:        SYSTEM SERVICE MESSAGE COVERS:
! 
!                 1) THE MESSAGES FROM THE SERVICE
!                 2) OPERATOR MESSAGES
!                 3) NETWORK MESSAGES
! 
!         ONLY THE TYPE FIELD IS DIFERENT
! 
literal EMB$K_SS_LENGTH = 66;           ! LENGTH OF CONSTANT PART 
literal EMB$C_SS_LENGTH = 66;           ! LENGTH OF CONSTANT PART 
literal EMB$S_EMBSSDEF = 67;
macro EMB$L_SS_SID = 0,0,32,0 %;        ! SYSTEM ID 
macro EMB$W_SS_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_SS_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_SS_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_SS_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_SS_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$B_SS_SCS_NAME = 16,0,0,1 %;
literal EMB$S_SS_SCS_NAME = 16;         !  SCS node name in ASCIC
macro EMB$W_SS_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_SS_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_SS_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_SS_ENTRY = 36,0,16,0 %;     ! ENTRY TYPE 
macro EMB$Q_SS_TIME = 38,0,0,0 %;
literal EMB$S_SS_TIME = 8;              ! TIME IN 64 BITS 
macro EMB$W_SS_ERRSEQ = 46,0,16,0 %;    ! ERROR SEQUENCE NUMBER 
macro EMB$Q_SS_SWVERS = 48,0,0,0 %;
literal EMB$S_SS_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_SS_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_SS_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$W_SS_MSGSZ = 64,0,16,0 %;     ! MESSAGE TEXT SIZE IN BYTES 
macro EMB$B_SS_MSGTXT = 66,0,8,0 %;     ! FIRST BYTE OF MESSAGE TEXT 
 
!*** MODULE $EMBVMDEF ***
! 
!  VOLUME MOUNT/DISMOUNT MESSAGE TYPE
! 
literal EMB$K_VM_LENGTH = 126;          ! LENGTH OF BUFFER 
literal EMB$C_VM_LENGTH = 126;          ! LENGTH OF BUFFER 
literal EMB$S_EMBVMDEF = 126;
macro EMB$L_VM_SID = 0,0,32,0 %;        ! SYSTEM ID 
macro EMB$W_VM_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_VM_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_VM_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_VM_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_VM_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$B_VM_SCS_NAME = 16,0,0,1 %;
literal EMB$S_VM_SCS_NAME = 16;         !  SCS node name in ASCIC
macro EMB$W_VM_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_VM_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_VM_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_VM_ENTRY = 36,0,16,0 %;     ! ENTRY TYPE = EMB$K_VM OR EMB$K_VD 
macro EMB$Q_VM_TIME = 38,0,0,0 %;
literal EMB$S_VM_TIME = 8;              ! TIME IN 64 BIT FORMAT 
macro EMB$W_VM_ERRSEQ = 46,0,16,0 %;    ! ERROR SEQUENCE NUMBER 
macro EMB$Q_VM_SWVERS = 48,0,0,0 %;
literal EMB$S_VM_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_VM_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_VM_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$L_VM_OWNUIC = 64,0,32,0 %;    ! OWNER UIC OF THE VOLUME 
macro EMB$L_VM_ERRCNT = 68,0,32,0 %;    ! UNIT ERROR COUNT FROM UCB 
macro EMB$L_VM_OPRCNT = 72,0,32,0 %;    ! UNIT OPERATION COUNT FROM UCB 
macro EMB$W_VM_UNIT = 76,0,16,0 %;      ! DEVICE UNIT NUMBER 
macro EMB$B_VM_NAMLNG = 78,0,8,0 %;     ! LENGTH OF DEVICE GENERIC NAME 
macro EMB$T_VM_NAMTXT = 79,0,0,0 %;
literal EMB$S_VM_NAMTXT = 31;           ! DEVICE GENERIC NAME 
macro EMB$W_VM_VOLNUM = 110,0,16,0 %;   ! VOLUME NUMBER WITHIN SET 
macro EMB$W_VM_NUMSET = 112,0,16,0 %;   ! NUMBER OF VOLUMES WITHIN SET 
macro EMB$T_VM_LABEL = 114,0,0,0 %;
literal EMB$S_VM_LABEL = 12;            ! VOLUME LABEL 
 
!*** MODULE $EMBSUDEF ***
! 
!  SYSTEM STARTUP MESSAGE
! 
literal EMB$K_SU_LENGTH = 68;           ! LENGTH OF MESSAGE 
literal EMB$C_SU_LENGTH = 68;           ! LENGTH OF MESSAGE 
literal EMB$S_EMBSUDEF = 68;
macro EMB$L_SU_SID = 0,0,32,0 %;        ! SYSTEM ID 
macro EMB$W_SU_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_SU_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_SU_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_SU_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_SU_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$B_SU_SCS_NAME = 16,0,0,1 %;
literal EMB$S_SU_SCS_NAME = 16;         !  SCS node name in ASCIC
macro EMB$W_SU_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_SU_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_SU_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_SU_ENTRY = 36,0,16,0 %;     ! ENTRY TYPE (IE: BOOT OR POWER RECOVERY) 
macro EMB$Q_SU_TIME = 38,0,0,0 %;
literal EMB$S_SU_TIME = 8;              ! CONTENTS OF SYSTEM TIME QUADWORD 
macro EMB$W_SU_ERRSEQ = 46,0,16,0 %;    ! ERROR SEQUENCE NUMBER 
macro EMB$Q_SU_SWVERS = 48,0,0,0 %;
literal EMB$S_SU_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_SU_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_SU_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$L_SU_DAYTIM = 64,0,32,0 %;    ! CONTENTS OF TIME OF DAY CLOCK 
 
!*** MODULE $EMBMCDEF ***
! 
!  MACHINE CHECK LOG BUFFER FORMAT
! 
literal EMB$K_MC_LENGTH = 112;          ! LENGTH OF MACHINE CHECK FRAME 
literal EMB$C_MC_LENGTH = 112;          ! LENGTH OF MACHINE CHECK FRAME 
literal EMB$S_EMBMCDEF = 112;
macro EMB$L_MC_SID = 0,0,32,0 %;        ! SYSTEM ID 
macro EMB$W_MC_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_MC_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_MC_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_MC_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_MC_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$B_MC_SCS_NAME = 16,0,0,1 %;
literal EMB$S_MC_SCS_NAME = 16;         !  SCS node name in ASCIC
macro EMB$W_MC_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_MC_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_MC_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_MC_ENTRY = 36,0,16,0 %;     ! ENTRY TYPE 
macro EMB$Q_MC_TIME = 38,0,0,0 %;
literal EMB$S_MC_TIME = 8;              ! TIME IN 64 BITS 
macro EMB$W_MC_ERRSEQ = 46,0,16,0 %;    ! ERROR SEQUENCE NUMBER 
macro EMB$Q_MC_SWVERS = 48,0,0,0 %;
literal EMB$S_MC_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_MC_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_MC_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$B_MC_SUMCOD = 64,0,8,0 %;     ! SUMMARY CODE 
macro EMB$B_MC_TOPF = 65,0,8,0 %;       ! TIME OUT PENDING FLAG 
macro EMB$B_MC_OPCODE = 66,0,8,0 %;     ! OPCODE OF INSTRUCTION CAUSING CHECK 
macro EMB$B_MC_CACHEF = 67,0,8,0 %;     ! CACHE DISABLE FLAG, 1=GROUP 0, 2=G 1 
macro EMB$L_MC_CES = 68,0,32,0 %;       ! CPU ERROR STATUS 
macro EMB$L_MC_UPC = 72,0,32,0 %;       ! MICRO-PC AT FAULT TIME 
macro EMB$L_MC_VA = 76,0,32,0 %;        ! VIRTUAL ADDRESS AT FAULT TIME 
macro EMB$L_MC_D = 80,0,32,0 %;         ! CPU D REGISTER AT FAULT TIME 
macro EMB$L_MC_TBER0 = 84,0,32,0 %;     ! TRANSLATION BUFFER STATUS REG 0 
macro EMB$L_MC_TBER1 = 88,0,32,0 %;     ! TRANSLATION BUFFER STATUS REG 1 
macro EMB$L_MC_TIMOAD = 92,0,32,0 %;    ! PHYSICAL ADDRESS CAUSING SBI TIMEOUT 
macro EMB$L_MC_PARITY = 96,0,32,0 %;    ! CACHE STATUS REGISTER 
macro EMB$L_MC_SBIERR = 100,0,32,0 %;   ! SBI ERROR REGISTER 
macro EMB$L_MC_PC = 104,0,32,0 %;       ! PC OF INSTRUCTION CAUSING CHECK 
macro EMB$L_MC_PSL = 108,0,32,0 %;      ! PSL OF MACHINE AT FAULT TIME 
 
!*** MODULE $EMBSEDEF ***
! 
!  SOFT ECC DETECTED ERRORS AND SBI ALERT BUFFER FORMAT
! 
literal EMB$K_SE_LENGTH = 68;           ! LENGTH OF FIXED PART OF MSG 
literal EMB$C_SE_LENGTH = 68;           ! LENGTH OF FIXED PART OF MSG 
literal EMB$S_EMBSEDEF = 92;
macro EMB$L_SE_SID = 0,0,32,0 %;        ! SYSTEM ID 
macro EMB$W_SE_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_SE_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_SE_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_SE_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_SE_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$B_SE_SCS_NAME = 16,0,0,1 %;
literal EMB$S_SE_SCS_NAME = 16;         !  SCS node name in ASCIC
macro EMB$W_SE_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_SE_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_SE_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_SE_ENTRY = 36,0,16,0 %;     ! ENTRY TYPE 
macro EMB$Q_SE_TIME = 38,0,0,0 %;
literal EMB$S_SE_TIME = 8;              ! TIME IN 64 BITS 
macro EMB$W_SE_ERRSEQ = 46,0,16,0 %;    ! ERROR SEQUENCE NUMBER 
macro EMB$Q_SE_SWVERS = 48,0,0,0 %;
literal EMB$S_SE_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_SE_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_SE_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$L_SE_NUMCON = 64,0,32,0 %;    ! NUMBER OF MEMORY CONTROLLERS 
macro EMB$L_SE_TR = 68,0,32,0 %;        ! ADAPTOR TR NUMBER 
macro EMB$L_SE_A = 72,0,32,0 %;         ! MEMORY REGISTER A 
macro EMB$L_SE_B = 76,0,32,0 %;         ! MEMORY REGISTER B 
macro EMB$L_SE_C = 80,0,32,0 %;         ! MEMORY REGISTER C 
macro EMB$L_SE_PC = 84,0,32,0 %;        ! PC OF INSTRUCTION AT FAULT TIME 
macro EMB$L_SE_PSL = 88,0,32,0 %;       ! PSL OF MACHINE AT FAULT TIME 
 
!*** MODULE $EMBSBDEF ***
! 
!  SBI FAULT BUFFER FORMAT AND ASYNCHRONOUS WRITE ERROR FORMAT
! 
literal EMB$K_SB_LENGTH = 220;          ! LENGTH OF SBI ERROR BUFFER 
literal EMB$C_SB_LENGTH = 220;          ! LENGTH OF SBI ERROR BUFFER 
literal EMB$S_EMBSBDEF = 220;
macro EMB$L_SB_SID = 0,0,32,0 %;        ! SYSTEM ID 
macro EMB$W_SB_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_SB_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_SB_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_SB_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_SB_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$B_SB_SCS_NAME = 16,0,0,1 %;
literal EMB$S_SB_SCS_NAME = 16;         !  SCS node name in ASCIC
macro EMB$W_SB_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_SB_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_SB_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_SB_ENTRY = 36,0,16,0 %;     ! ENTRY TYPE 
macro EMB$Q_SB_TIME = 38,0,0,0 %;
literal EMB$S_SB_TIME = 8;              ! TIME IN 64 BITS 
macro EMB$W_SB_ERRSEQ = 46,0,16,0 %;    ! ERROR SEQUENCE NUMBER 
macro EMB$Q_SB_SWVERS = 48,0,0,0 %;
literal EMB$S_SB_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_SB_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_SB_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$L_SB_FAULT = 64,0,32,0 %;     ! SBI FAULT/STATUS REGISTER 
macro EMB$L_SB_SILCMP = 68,0,32,0 %;    ! SBI SILO COMPARATOR 
macro EMB$L_SB_MAINT = 72,0,32,0 %;     ! SBI MAINTENANCE 
macro EMB$L_SB_ERROR = 76,0,32,0 %;     ! SBI ERROR REG 
macro EMB$L_SB_TIMOUT = 80,0,32,0 %;    ! SBI TIMEOUT REG 
macro EMB$L_SB_SILO = 84,0,0,0 %;
literal EMB$S_SB_SILO = 64;             ! SBI SILO REG 
macro EMB$L_SB_SBIRGS = 148,0,0,0 %;
literal EMB$S_SB_SBIRGS = 64;           ! REGISTER A'S ON BUS (OR 0) 
macro EMB$L_SB_PC = 212,0,32,0 %;       ! PC OF INSTRUCTION AT FAULT TIME 
macro EMB$L_SB_PSL = 216,0,32,0 %;      ! PSL OF MACHINE AT FAULT TIME 
 
!*** MODULE $EMBUIDEF ***
! 
!  UNDEFINED ADAPTER INTERRUPT BUFFER FORMAT
! 
literal EMB$K_UI_LENGTH = 72;           ! LENGTH OF MESSAGE 
literal EMB$C_UI_LENGTH = 72;           ! LENGTH OF MESSAGE 
literal EMB$S_EMBUIDEF = 72;
macro EMB$L_UI_SID = 0,0,32,0 %;        ! SYSTEM ID 
macro EMB$W_UI_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_UI_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_UI_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_UI_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_UI_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$B_UI_SCS_NAME = 16,0,0,1 %;
literal EMB$S_UI_SCS_NAME = 16;         !  SCS node name in ASCIC
macro EMB$W_UI_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_UI_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_UI_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_UI_ENTRY = 36,0,16,0 %;     ! ENTRY TYPE 
macro EMB$Q_UI_TIME = 38,0,0,0 %;
literal EMB$S_UI_TIME = 8;              ! TIME IN 64 BITS 
macro EMB$W_UI_ERRSEQ = 46,0,16,0 %;    ! ERROR SEQUENCE NUMBER 
macro EMB$Q_UI_SWVERS = 48,0,0,0 %;
literal EMB$S_UI_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_UI_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_UI_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$L_UI_TR = 64,0,32,0 %;        ! ADAPTER TR NUMBER 
macro EMB$L_UI_CSR = 68,0,32,0 %;       ! ADAPTER CONGIGURATION STATUS REGISTER 
 
!*** MODULE $EMBUEDEF ***
! 
!  ERROR BUFFER FORMAT FOR UNIBUS ERROR SUMMARY REGISTER
!         ***** USED ONLY BY 11/730 ****
! 
literal EMB$K_UE_LENGTH = 68;           ! LENGTH OF MESSAGE 
literal EMB$C_UE_LENGTH = 68;           ! LENGTH OF MESSAGE 
literal EMB$S_EMBUEDEF = 68;
macro EMB$L_UE_SID = 0,0,32,0 %;        ! SYSTEM ID 
macro EMB$W_UE_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_UE_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_UE_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_UE_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_UE_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$B_UE_SCS_NAME = 16,0,0,1 %;
literal EMB$S_UE_SCS_NAME = 16;         !  SCS node name in ASCIC
macro EMB$W_UE_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_UE_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_UE_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_UE_ENTRY = 36,0,16,0 %;     ! ENTRY TYPE 
macro EMB$Q_UE_TIME = 38,0,0,0 %;
literal EMB$S_UE_TIME = 8;              ! TIME IN 64 BITS 
macro EMB$W_UE_ERRSEQ = 46,0,16,0 %;    ! ERROR SEQUENCE NUMBER 
macro EMB$Q_UE_SWVERS = 48,0,0,0 %;
literal EMB$S_UE_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_UE_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_UE_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$L_UE_UBERR = 64,0,32,0 %;     ! UNIBUS ERROR REGISTER 
 
!*** MODULE $EMBSPDEF ***
! 
!  ERROR BUFFER FORMAT FOR SAVING SOFTWARE PARAMETERS FOR CLASS DRIVER THAT
!         CORRESPOND TO A LOGGED MESSAGE (SEE EMBLMDEF BELOW) ORIGINATING
!         IN AN INTELLIGENT MASS STORAGE CONTROLLER.
! 
literal EMB$K_SP_LENGTH = 144;
literal EMB$C_SP_LENGTH = 144;
literal EMB$S_EMBSPDEF = 144;
macro EMB$L_SP_SID = 0,0,32,0 %;        !  System ID 
macro EMB$W_SP_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_SP_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_SP_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_SP_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_SP_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$B_SP_SCS_NAME = 16,0,0,1 %;
literal EMB$S_SP_SCS_NAME = 16;         !  SCS node name in ASCIC
macro EMB$W_SP_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_SP_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_SP_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_SP_ENTRY = 36,0,16,0 %;     !  Entry type (of this errorlog buffer) 
macro EMB$Q_SP_TIME = 38,0,0,0 %;
literal EMB$S_SP_TIME = 8;              !  Time this entry created 
macro EMB$W_SP_ERRSEQ = 46,0,16,0 %;    !  Error Sequence Number 
macro EMB$Q_SP_SWVERS = 48,0,0,0 %;
literal EMB$S_SP_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_SP_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_SP_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$B_SP_CLASS = 64,0,8,0 %;      !  Device Class 
macro EMB$B_SP_TYPE = 65,0,8,0 %;       !  Device Type 
macro EMB$W_SP_BOFF = 66,0,16,0 %;      !  Byte OFFset of data transfer 
macro EMB$L_SP_BCNT = 68,0,32,0 %;      !  Byte Count of data transfer 
macro EMB$L_SP_MEDIA = 72,0,32,0 %;     !  Media address (LBN) of data transfer 
macro EMB$L_SP_RQPID = 76,0,32,0 %;     !  Requesting PID 
macro EMB$Q_SP_IOSB = 80,0,0,0 %;
literal EMB$S_SP_IOSB = 8;              !  Final I/O status 
macro EMB$W_SP_FUNC = 88,0,16,0 %;      !  I/O function code 
macro EMB$W_SP_UNIT = 90,0,16,0 %;      !  Unit number of drive 
macro EMB$L_SP_OPCNT = 92,0,32,0 %;     !  Cummulative operation count this unit 
macro EMB$W_SP_ERRCNT = 96,0,16,0 %;    !  Cummulative error count for this unit 
macro EMB$W_SP_UCBSTS = 98,0,16,0 %;    !  Copy of UCB$W_STS field 
macro EMB$L_SP_OWNUIC = 100,0,32,0 %;   !  Unit's owner's UIC 
macro EMB$L_SP_CHAR = 104,0,32,0 %;     !  Device Characteristics 
macro EMB$L_SP_CMDREF = 108,0,32,0 %;   !  Command Reference number (RSPID) 
macro EMB$T_SP_DEVNAM = 112,0,0,0 %;
literal EMB$S_SP_DEVNAM = 32;           !  Device name 
 
!*** MODULE $EMBLMDEF ***
! 
!  LOGGED MESSAGE (DEVICE DEPENDENT CONTENTS).  DRIVER LOGS MESSAGE
!         WHICH MAY COME DIRECT FROM INTELLIGENT MASS STORAGE CONTROLLER.
! 
literal EMB$K_LM_LENGTH = 102;
literal EMB$C_LM_LENGTH = 102;
literal EMB$S_EMBLMDEF = 102;
macro EMB$L_LM_SID = 0,0,32,0 %;        !  System ID 
macro EMB$W_LM_HDR_REV = 4,0,16,0 %;    !  HEADER REV LEVEL
macro EMB$L_LM_XSID = 6,0,32,0 %;       !  SYS_TYPE REGISTER
macro EMB$L_LM_CPUID = 10,0,32,0 %;     !  UNIQUE CPU ID
macro EMB$B_LM_DEV_CLASS = 14,0,8,0 %;  !  DEVICE CLASS
macro EMB$B_LM_DEV_TYPE = 15,0,8,0 %;   !  DEVICE TYPE
macro EMB$B_LM_SCS_NAME = 16,0,0,1 %;
literal EMB$S_LM_SCS_NAME = 16;         !  SCS node name in ASCIC
macro EMB$W_LM_FLAGS = 32,0,16,0 %;     !  MISC. FLAGS
macro EMB$B_LM_OS_ID = 34,0,8,0 %;      !  LOGGING OS ID
macro EMB$B_LM_HDRSZ = 35,0,8,0 %;      !  HEADER SIZE
macro EMB$W_LM_ENTRY = 36,0,16,0 %;     !  Entry type (i.e. Logged Message) 
macro EMB$Q_LM_TIME = 38,0,0,0 %;
literal EMB$S_LM_TIME = 8;              !  Time this entry created 
macro EMB$W_LM_ERRSEQ = 46,0,16,0 %;    !  Error sequence number 
macro EMB$Q_LM_SWVERS = 48,0,0,0 %;
literal EMB$S_LM_SWVERS = 8;            !  SOFTWARE VERSION
macro EMB$L_LM_ERRMSK = 56,0,32,0 %;    !  ERROR MASK
macro EMB$L_LM_ABSTIM = 60,0,32,0 %;    !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$B_LM_CLASS = 64,0,8,0 %;      !  Device Class 
macro EMB$B_LM_TYPE = 65,0,8,0 %;       !  Device Type 
macro EMB$W_LM_UNIT = 66,0,16,0 %;      !  Device unit number 
macro EMB$T_LM_DEVNAM = 68,0,0,0 %;
literal EMB$S_LM_DEVNAM = 32;           !  Device name 
macro EMB$W_LM_MSGTYP = 100,0,16,0 %;   !  Type of logged message 
 
!*** MODULE $EMBLTDEF ***
! 
!  LOGGED MESSAGE MESSAGE TYPES
! 
literal EMB$C_DM = 1;                   !  Disk MSCP message 
literal EMB$K_DM = 1;                   !  Disk MSCP message 
literal EMB$C_TM = 2;                   !  Tape MSCP message 
literal EMB$K_TM = 2;                   !  Tape MSCP message 
literal EMB$C_PM = 3;                   !  Port (CI) message 
literal EMB$K_PM = 3;                   !  Port (CI) message 
literal EMB$C_UM = 4;                   !  Port (UDA) message 
literal EMB$K_UM = 4;                   !  Port (UDA) message 
literal EMB$C_AVATN = 5;                !  Available Attention Message 
literal EMB$K_AVATN = 5;                !  Available Attention Message 
literal EMB$C_DUPUN = 6;                !  Duplicate Unit ! Attention Message 
literal EMB$K_DUPUN = 6;                !  Duplicate Unit ! Attention Message 
literal EMB$C_IVCMD = 7;                !  Invalid Command Log message. 
literal EMB$K_IVCMD = 7;                !  Invalid Command Log message. 
literal EMB$C_ACPTH = 8;                !  Access Path Attention Message 
literal EMB$K_ACPTH = 8;                !  Access Path Attention Message 
literal EMB$C_INVSTS = 9;               !  Invalid Status in End Message
literal EMB$K_INVSTS = 9;               !  Invalid Status in End Message
literal EMB$C_INVATT = 10;              !  Invalid Attention Message
literal EMB$K_INVATT = 10;              !  Invalid Attention Message
literal EMB$C_NOUNIT_DG = 11;           !  No unit in Datagram
literal EMB$K_NOUNIT_DG = 11;           !  No unit in Datagram
literal EMB$C_SSTFAIL = 12;             !  Self test failed.
literal EMB$K_SSTFAIL = 12;             !  Self test failed.
literal EMB$C_KDB50 = 13;               !  KDB50 error detected.
literal EMB$K_KDB50 = 13;               !  KDB50 error detected.
! 
!  The CTLRES_x fields below indicate that an MSCP controller was
!  told to reset itself by a class driver because the controller
!  is broken or confused.  (To an HSC, this will cause a reboot.)
!  The first three (INIT, INVMSG and IMTMO) do not have an MSCP end
!  message logged with them.
! 
literal EMB$C_CTLRES_INIT = 14;         !  An error occurred during or the connection vanished before completing
literal EMB$K_CTLRES_INIT = 14;         !    the initial handshake with the class driver.
literal EMB$C_CTLRES_INVMSG = 15;       !  An invalid message was received from the controller.  The offending
literal EMB$K_CTLRES_INVMSG = 15;       !    message has been previously logged as INVATT or INVSTS.
literal EMB$C_CTLRES_IMTMO = 16;        !  An immediate mode command has failed to complete within the timeout
literal EMB$K_CTLRES_IMTMO = 16;        !    period, indicating a broken or wedged controller.
literal EMB$C_CTLRES_TMO = 17;          !  No progress was made on a command during the timeout period.  The MSCP
literal EMB$K_CTLRES_TMO = 17;          !    GET COMMAND STATUS end message which determined this is included.
! 
literal EMB$C_BADRSPID = 18;            !  A message with an invalid RSPID was received by the class driver.
literal EMB$K_BADRSPID = 18;            !    The offending MSCP message is included.
! 
literal EMB$C_BVPSSP = 19;              !  Port message for BVP Storage Systems Port
literal EMB$K_BVPSSP = 19;              !  Port message for BVP Storage Systems Port
literal EMB$C_NIPM = 20;                !  Port (NI) message 
literal EMB$K_NIPM = 20;                !  Port (NI) message 
literal EMB$C_LDR_ERR = 21;             !  Media Loader error message
literal EMB$K_LDR_ERR = 21;             !  Media Loader error message
 
!*** MODULE $EMBETDEF ***
! 
!  ERROR MESSAGE ENTRY TYPE DEFINITIONS
! 
literal EMB$C_DE = 1;                   ! DEVICE ERROR 
literal EMB$K_DE = 1;                   ! DEVICE ERROR 
literal EMB$C_MC = 2;                   ! MACHINE CHECK 
literal EMB$K_MC = 2;                   ! MACHINE CHECK 
literal EMB$C_SYNERR = 3;               ! Syndrome Error
literal EMB$K_SYNERR = 3;               ! Syndrome Error
literal EMB$C_BE = 4;                   ! BUS ERROR 
literal EMB$K_BE = 4;                   ! BUS ERROR 
literal EMB$C_SA = 5;                   ! SBI ALERT 
literal EMB$K_SA = 5;                   ! SBI ALERT 
literal EMB$C_SE = 6;                   ! SOFT ECC ERROR 
literal EMB$K_SE = 6;                   ! SOFT ECC ERROR 
literal EMB$C_AW = 7;                   ! ASYNCHRONOUS WRITE ERROR 
literal EMB$K_AW = 7;                   ! ASYNCHRONOUS WRITE ERROR 
literal EMB$C_HE = 8;                   ! HARD ECC ERROR 
literal EMB$K_HE = 8;                   ! HARD ECC ERROR 
literal EMB$C_UBA = 9;                  !  11/780 Unibus Adapter error 
literal EMB$K_UBA = 9;                  !  11/780 Unibus Adapter error 
literal EMB$C_SI = 10;                  !  11/750 Fault through SBI vector 
literal EMB$K_SI = 10;                  !  11/750 Fault through SBI vector 
literal EMB$C_UE = 11;                  !  11/730 Unibus Error 
literal EMB$K_UE = 11;                  !  11/730 Unibus Error 
literal EMB$C_MBA = 12;                 !  11/780 Massbus Adapter Error 
literal EMB$K_MBA = 12;                 !  11/780 Massbus Adapter Error 
literal EMB$C_SBIA = 13;                !  11/790 SBIA error
literal EMB$K_SBIA = 13;                !  11/790 SBIA error
literal EMB$C_CRD = 14;                 !  11/790 CRD log
literal EMB$K_CRD = 14;                 !  11/790 CRD log
literal EMB$C_EMM = 15;                 !  11/790 Environmental MOnitor
literal EMB$K_EMM = 15;                 !  11/790 Environmental MOnitor
literal EMB$C_HLT = 16;                 !  11/790 Processor Error Halt
literal EMB$K_HLT = 16;                 !  11/790 Processor Error Halt
literal EMB$C_CRBT = 17;                !  11/790 Console Reboot
literal EMB$K_CRBT = 17;                !  11/790 Console Reboot
literal EMB$C_BIADPERR = 18;            !  BI ADAPTER ERROR
literal EMB$K_BIADPERR = 18;            !  BI ADAPTER ERROR
literal EMB$C_BIBUSERR = 19;            !  BI BUS ERROR
literal EMB$K_BIBUSERR = 19;            !  BI BUS ERROR
literal EMB$C_NMIFLT = 20;              !  NMI FAULT 
literal EMB$K_NMIFLT = 20;              !  NMI FAULT 
literal EMB$C_CTO = 21;                 !  Console Timeout
literal EMB$K_CTO = 21;                 !  Console Timeout
literal EMB$C_NBW = 22;                 !  NBW
literal EMB$K_NBW = 22;                 !  NBW
literal EMB$C_CACHERR = 23;             !  CACHE ERROR
literal EMB$K_CACHERR = 23;             !  CACHE ERROR
literal EMB$C_CVAX_CB = 24;             !  CVAX CACHE/BUS ERROR
literal EMB$K_CVAX_CB = 24;             !  CVAX CACHE/BUS ERROR
literal EMB$C_MEMSCAN = 25;             !  Calypso memory error found by scanning
literal EMB$K_MEMSCAN = 25;             !  Calypso memory error found by scanning
literal EMB$C_INT54 = 26;               !  Calypso SCB 54 error
literal EMB$K_INT54 = 26;               !  Calypso SCB 54 error
literal EMB$C_INT60 = 27;               !  Calypso SCB 60 error
literal EMB$K_INT60 = 27;               !  Calypso SCB 60 error
literal EMB$C_ADPERR = 28;              !  adapter error
literal EMB$K_ADPERR = 28;              !  adapter error
literal EMB$C_LASTFAIL = 29;            !  Calypso lastfail
literal EMB$K_LASTFAIL = 29;            !  Calypso lastfail
literal EMB$C_CONSOLE = 30;             !  Console entry
literal EMB$K_CONSOLE = 30;             !  Console entry
literal EMB$C_INFO = 31;                !  Informational entry
literal EMB$K_INFO = 31;                !  Informational entry
literal EMB$C_CS = 32;                  ! COLD START (IE: SYSTEM BOOT) 
literal EMB$K_CS = 32;                  ! COLD START (IE: SYSTEM BOOT) 
literal EMB$C_CLKERR = 33;              !  Clock module error
literal EMB$K_CLKERR = 33;              !  Clock module error
literal EMB$C_SCAN = 34;                !  SCAN error (eg. Aquarius)
literal EMB$K_SCAN = 34;                !  SCAN error (eg. Aquarius)
literal EMB$K_NF = 35;                  ! NEW FILE CREATED 
literal EMB$C_NF = 35;                  ! NEW FILE CREATED 
literal EMB$C_WS = 36;                  ! WARM START (IE: SYSTEM POWER RECOVERY) 
literal EMB$K_WS = 36;                  ! WARM START (IE: SYSTEM POWER RECOVERY) 
literal EMB$C_CR = 37;                  ! CRASH RE-START 
literal EMB$K_CR = 37;                  ! CRASH RE-START 
literal EMB$C_TS = 38;                  ! TIME STAMP ENTRY 
literal EMB$K_TS = 38;                  ! TIME STAMP ENTRY 
literal EMB$C_SS = 39;                  ! SYSTEM SERVICE MESSAGE 
literal EMB$K_SS = 39;                  ! SYSTEM SERVICE MESSAGE 
literal EMB$C_SBC = 40;                 ! SYSTEM BUGCHECK 
literal EMB$K_SBC = 40;                 ! SYSTEM BUGCHECK 
literal EMB$C_OM = 41;                  ! OPERATOR MESSAGE 
literal EMB$K_OM = 41;                  ! OPERATOR MESSAGE 
literal EMB$C_NM = 42;                  ! NETWORK MESSAGE 
literal EMB$K_NM = 42;                  ! NETWORK MESSAGE 
literal EMB$C_CONFIG = 43;              ! CONFIGURATION entry
literal EMB$K_CONFIG = 43;              ! CONFIGURATION entry
literal EMB$C_POLL_ERR = 44;            ! Polled error entry
literal EMB$K_POLL_ERR = 44;            ! Polled error entry
literal EMB$C_SNAP = 45;                ! SNAP/TRACE ENTRY
literal EMB$K_SNAP = 45;                ! snap/trace entry
literal EMB$C_VM = 64;                  ! VOLUME MOUNT 
literal EMB$K_VM = 64;                  ! VOLUME MOUNT 
literal EMB$C_VD = 65;                  ! VOLUME DISMOUNT 
literal EMB$K_VD = 65;                  ! VOLUME DISMOUNT 
literal EMB$C_DT = 96;                  ! DEVICE TIMEOUT 
literal EMB$K_DT = 96;                  ! DEVICE TIMEOUT 
literal EMB$C_UI = 97;                  ! UNDEFINED INTERRUPT 
literal EMB$K_UI = 97;                  ! UNDEFINED INTERRUPT 
literal EMB$C_DA = 98;                  !  Asynchronous Device Attention 
literal EMB$K_DA = 98;                  !  Asynchronous Device Attention 
literal EMB$C_SP = 99;                  !  Software Parameters 
literal EMB$K_SP = 99;                  !  Software Parameters 
literal EMB$C_LM = 100;                 !  Logged Message 
literal EMB$K_LM = 100;                 !  Logged Message 
literal EMB$C_LOGMSCP = 101;            !  Logged MSCP Message
literal EMB$K_LOGMSCP = 101;            !  Logged MSCP Message 
literal EMB$C_PWR = 102;                !  Laser power event
literal EMB$K_PWR = 102;                !  Laser power event
literal EMB$C_UBC = 112;                ! USER BUGCHECK 
literal EMB$K_UBC = 112;                ! USER BUGCHECK 
 
!*** MODULE $EMBPWRDEF ***
! 
!  Power event message
! 
literal EMB$K_PWR_LENGTH = 242;         !  Length of power event message
literal EMB$C_PWR_LENGTH = 242;         !  Length of power event message
literal EMB$S_EMBPWRDEF = 242;
macro EMB$L_PWR_SID = 0,0,32,0 %;       ! SYSTEM ID
macro EMB$W_PWR_HDR_REV = 4,0,16,0 %;   !  HEADER REV LEVEL
macro EMB$L_PWR_XSID = 6,0,32,0 %;      !  SYS_TYPE REGISTER
macro EMB$L_PWR_CPUID = 10,0,32,0 %;    !  UNIQUE CPU ID
macro EMB$B_PWR_DEV_CLASS = 14,0,8,0 %; !  DEVICE CLASS
macro EMB$B_PWR_DEV_TYPE = 15,0,8,0 %;  !  DEVICE TYPE
macro EMB$B_PWR_SCS_NAME = 16,0,0,1 %;
literal EMB$S_PWR_SCS_NAME = 16;        !  SCS node name in ASCIC
macro EMB$W_PWR_FLAGS = 32,0,16,0 %;    !  MISC. FLAGS
macro EMB$B_PWR_OS_ID = 34,0,8,0 %;     !  LOGGING OS ID
macro EMB$B_PWR_HDRSZ = 35,0,8,0 %;     !  HEADER SIZE
macro EMB$W_PWR_ENTRY = 36,0,16,0 %;    !  ENTRY TYPE
macro EMB$Q_PWR_TIME = 38,0,0,0 %;
literal EMB$S_PWR_TIME = 8;             !  TIME IN 64 BITS
macro EMB$W_PWR_ERRSEQ = 46,0,16,0 %;   !  ERROR SEQ !
macro EMB$Q_PWR_SWVERS = 48,0,0,0 %;
literal EMB$S_PWR_SWVERS = 8;           !  SOFTWARE VERSION
macro EMB$L_PWR_ERRMSK = 56,0,32,0 %;   !  ERROR MASK
macro EMB$L_PWR_ABSTIM = 60,0,32,0 %;   !  CONTENTS OF EXE$GL_ABSTIM
macro EMB$Q_PWR_VERSION = 64,0,0,0 %;
literal EMB$S_PWR_VERSION = 8;          !  The version of laser_power.bli
macro EMB$L_PWR_TYPE = 72,0,32,0 %;     !  Type of power event
macro EMB$Q_PWR_TIME_A = 76,0,0,0 %;
literal EMB$S_PWR_TIME_A = 8;           !  Timestamp for last regulator A responce
! 
!  NOTE: There is a problem here with PWR_HISTORY_A.  In order to avoid 
!  overlaying the WHOLE entire rest of the file, we brute forced the name of 
!  the PWR_HISTORY_A T and S fields.  What would have been most desirable here 
!  is to overlay PWR_HISTORY_A without making the TIME_OVERLAY length be 
!  PWR_HISTORY's length of 54 bytes (or to have force PWR_HISTORY_A to start at
!  76.
! 
macro EMB$T_PWR_HISTORY_A = 76,0,8,0 %; !  Regulator A history buffer
macro EMB$L_PWR_BAD_REGULATOR = 76,0,32,0 %; !  Regulator the event is about
macro EMB$R_BAD_TYPE = 76,0,0,0 %;
literal EMB$S_BAD_TYPE = 8;
macro EMB$L_BAD_TYPE_FILL = 76,0,32,0 %;
macro EMB$L_PWR_BAD_TYPE = 80,0,32,0 %; !  Type of problem with regulator
macro EMB$Q_PWR_TIME_B = 84,0,0,0 %;
literal EMB$S_PWR_TIME_B = 8;           !  Timestamp for last regulator B responce
macro EMB$Q_PWR_TIME_C = 92,0,0,0 %;
literal EMB$S_PWR_TIME_C = 8;           !  Timestamp for last regulator C responce
macro EMB$T_PWR_BRIEF_A = 100,0,0,0 %;
literal EMB$S_PWR_BRIEF_A = 9;          !  Regulator B last responce
macro EMB$T_PWR_BRIEF_A_PAD = 109,0,24,0 %;
literal EMB$S_PWR_BRIEF_A_PAD = 3;      !  Pad for Lwd alignment
macro EMB$T_PWR_BRIEF_B = 112,0,0,0 %;
literal EMB$S_PWR_BRIEF_B = 9;          !  Regulator B last responce
macro EMB$T_PWR_BRIEF_B_PAD = 121,0,24,0 %;
literal EMB$S_PWR_BRIEF_B_PAD = 3;      !  Pad for Lwd alignment
macro EMB$T_PWR_BRIEF_C = 124,0,0,0 %;
literal EMB$S_PWR_BRIEF_C = 9;          !  Regulator C last responce
macro EMB$R_HISTORY = 124,0,0,0 %;
literal EMB$S_HISTORY = 62;
macro EMB$T_PWR_HISTORY_B_FILL = 124,0,0,0 %;
literal EMB$S_PWR_HISTORY_B_FILL = 8;   !  Regulator B history buffer fill
macro EMB$T_PWR_HISTORY_B = 132,0,0,0 %;
literal EMB$S_PWR_HISTORY_B = 54;       !  Regulator B history buffer
macro EMB$T_PWR_HISTORY_C_FILL = 186,0,16,0 %;
literal EMB$S_PWR_HISTORY_C_FILL = 2;   !  FILL
macro EMB$T_PWR_HISTORY_C = 188,0,0,0 %;
literal EMB$S_PWR_HISTORY_C = 54;       !  Regulator C history buffer
! 
!  Values in PWR_TYPE.
!  
literal EMB$K_PWR_state_event = 1;      !  State change event
literal EMB$K_PWR_history_event = 2;    !  Initial history event
literal EMB$K_PWR_bad_event = 3;        !  Bad checksum or no ans
literal EMB$S_PWR_HISTORY_A = 54;       !  Regulator A history length
 
!*** MODULE $ENBDEF ***
! +
! 
!  Generalized Event Notification Definitions
! 
!  Event Notification request Block
! 
!  This block is used by the $SETEVTAST system service
!  to request event notification cluster-wide.
! 
! -
literal ENB$M_LOCAL = 1;
literal ENB$M_RSVD = 2;
literal ENB$M_IMAGE = 4;
literal ENB$M_RSVD2 = 24;
literal ENB$M_WILDCARD = 32;
literal ENB$K_LENGTH = 76;              !  LENGTH OF BLOCK
literal ENB$C_LENGTH = 76;              !  LENGTH OF BLOCK
literal ENB$S_ENBDEF = 76;
macro ENB$L_QFL = 0,0,32,0 %;           !  QUEUE FORWARD LINK     
macro ENB$L_QBL = 4,0,32,0 %;           !  QUEUE BACKWARD LINK    
macro ENB$W_SIZE = 8,0,16,0 %;          !  STRUCTURE SIZE IN BYTES
macro ENB$B_TYPE = 10,0,8,0 %;          !  STRUCTURE TYPE CODE    
macro ENB$B_SUBTYPE = 11,0,8,0 %;       !  STRUCTURE SUBTYPE CODE
macro ENB$L_FLAGS = 12,0,32,0 %;        !  FLAGS
macro ENB$V_LOCAL = 12,0,1,0 %;         !   LOCAL NODE
macro ENB$V_IMAGE = 12,2,1,0 %;         !   IMAGE
macro ENB$V_WILDCARD = 12,5,1,0 %;
macro ENB$T_EVENT_NAME = 16,0,0,0 %;
literal ENB$S_EVENT_NAME = 32;          !  EVENT NAME
macro ENB$L_CSID = 48,0,32,0 %;         !  CLUSTER SYSTEM ID
macro ENB$L_EPID = 52,0,32,0 %;         !  PROCESS EXTENDED ID
macro ENB$B_EVT_ACMODE = 56,0,8,0 %;    !  EVENT AST ROUTINE ACCESS MODE
macro ENB$B_AST_ACMODE = 57,0,8,0 %;    !  COMPLETION AST ROUTINE ACCESS MODE
macro ENB$W_EVTFAC = 58,0,16,0 %;       !  FACILITY CODE
macro ENB$L_EFN = 60,0,32,0 %;          !  COMPLETION EFN
macro ENB$L_IOSB = 64,0,32,0 %;         !  COMPLETION IOSB
macro ENB$L_ASTADR = 68,0,32,0 %;       !  COMPLETION AST ROUTINE ADDRESS
macro ENB$L_ASTPRM = 72,0,32,0 %;       !  COMPLETION AST ROUTINE PARAMETER
 
!*** MODULE $ENDDEF ***
! +
! 
!  Generalized Event Notification Definitions
! 
!  Event Notification Database Block
! 
!  This block is the first level structure of the event
!  notification database.  It contains arrays of Signature
!  List Block (SLB) array pointers.
! 
! -
literal END$C_FIXED = 32;
literal END$C_WILD = 32;
literal END$C_FC_WILD = 32;
literal END$K_LENGTH = 428;             !  LENGTH OF BLOCK
literal END$C_LENGTH = 428;             !  LENGTH OF BLOCK
literal END$S_ENDDEF = 428;
macro END$L_QFL = 0,0,32,0 %;           !  QUEUE FORWARD LINK 
macro END$L_QBL = 4,0,32,0 %;           !  QUEUE BACKWARD LINK
macro END$W_SIZE = 8,0,16,0 %;          !  STRUCTURE SIZE IN BYTES
macro END$B_TYPE = 10,0,8,0 %;          !  STRUCTURE TYPE CODE
macro END$B_SUBTYPE = 11,0,8,0 %;       !  STRUCTURE SUBTYPE CODE
macro END$L_FIXED = 12,0,0,0 %;
literal END$S_FIXED = 128;              !  FIXED LENGTH STRING SIGNATURE POINTERS
macro END$L_WILD = 140,0,0,0 %;
literal END$S_WILD = 128;               !  WILD CARD STRING SIGNATURE POINTERS
macro END$L_FC_WILD = 268,0,0,0 %;
literal END$S_FC_WILD = 128;            !  FIRST CHARACTER WILD SIGNATURE PNTRS
!  LISTHEADS FOR REQUESTING ALL EVENTS
macro END$Q_ALL_KERNEL = 396,0,0,0 %;
literal END$S_ALL_KERNEL = 8;           !  ... IN KERNEL MODE
macro END$Q_ALL_EXEC = 404,0,0,0 %;
literal END$S_ALL_EXEC = 8;             !  ... IN EXECUTIVE MODE
macro END$Q_ALL_SUPER = 412,0,0,0 %;
literal END$S_ALL_SUPER = 8;            !  ... IN SUPERVISOR MODE
macro END$Q_ALL_USER = 420,0,0,0 %;
literal END$S_ALL_USER = 8;             !  ... IN USER MODE
 
!*** MODULE $EO1DEF ***
! +
!  EOF1 ANSI MAGNETIC TAPE LABEL
!  THIS IS THE FIRST LABEL IN FILE TRAILER LABEL SET.  IT IS EQUIVALENT TO
!  HDR1 EXCEPT FOR THE FOLLOWING FIELDS.
! -
literal EO1$S_EO1DEF = 60;
macro EO1$L_EO1LID = 0,0,32,0 %;        ! LABEL IDENTIFIER AND NUMBER 'EOF1' 
macro EO1$T_BLOCKCNT = 54,0,0,0 %;
literal EO1$S_BLOCKCNT = 6;             ! BLOCK COUNT 
 
!*** MODULE $EO2DEF ***
! +
!  EOF2 ANSI MAGNETIC TAPE LABEL
!  THIS IS THE SECOND LABEL IN THE FILE TRAILER LABEL SET.  IT IS EQUIVALENT
!  TO HDR2 EXCEPT FOR THE FOLLOWING FIELDS.
! -
literal EO2$S_EO2DEF = 4;
macro EO2$L_EO2LID = 0,0,32,0 %;        ! LABEL IDENTIFIER AND NUMBER 'EOF2' 
 
!*** MODULE $EO3DEF ***
! +
!  EOF3 ANSI MAGNETIC TAPE LABEL
!  THIS IS THE THIRD LABEL IN THE FILE TRAILER LABEL SET.  IT IS EQUIVALENT
!  TO HDR3 EXCEPT FOR THE FOLLOWING FIELDS.
! -
literal EO3$S_EO3DEF = 4;
macro EO3$L_EO3LID = 0,0,32,0 %;        ! LABEL IDENTIFIER AND NUMBER 'EOF3' 
 
!*** MODULE $EO4DEF ***
! +
!  EOF4 ANSI MAGNETIC TAPE LABEL
!  THIS IS THE FOURTH LABEL IN THE FILE TRAILER LABEL SET.  IT IS EQUIVALENT
!  TO HDR4 EXCEPT FOR THE FOLLOWING FIELDS.
! -
literal EO4$S_EO4DEF = 4;
macro EO4$L_EO4LID = 0,0,32,0 %;        ! LABEL IDENTIFIER AND NUMBER 'EOF4' 
 
!*** MODULE $ERBDEF ***
! 
!  ERROR LOGGING MESSAGE RECOVERY BLOCK
! 
literal ERB$C_HDR_LENGTH = 24;          !  0th BUFF. STARTS HERE
literal ERB$K_HDR_LENGTH = 24;          !  0th BUFF. STARTS HERE
literal ERB$S_ERBDEF = 24;
macro ERB$L_FILLER0 = 0,0,32,0 %;       !  POSSIBLE FLNK
macro ERB$L_FILLER4 = 4,0,32,0 %;       !  POSSIBLE BLNK
macro ERB$W_BLOCK_SIZE = 8,0,16,0 %;    !  RETURNED BY ALLOCATION
macro ERB$B_BUFPAGES = 10,0,8,0 %;      !  V5.1 and + : PAGES / BUFFER
macro ERB$B_FILLERB = 11,0,8,0 %;       !  UNUSED
macro ERB$L_ALLOCATED = 12,0,32,0 %;    !  BYTES ALLOC'D FOR THIS BLOCK
macro ERB$L_BUFCNT = 16,0,32,0 %;       !  # BUFFERS, NOT INCL CRASH BUF
macro ERB$W_HEAD = 20,0,16,0 %;         !  RING HEAD INDEX AT CRASH
macro ERB$W_TAIL = 22,0,16,0 %;         !  RING TAIL AT CRASH
 
!*** MODULE $ERLDEF ***
! 
!  ERROR LOG ALLOCATION BUFFER HEADER
! 
literal ERL$K_LENGTH = 12;              ! LENGTH OF ALLOCATION BUFFER HEADER 
literal ERL$C_LENGTH = 12;              ! LENGTH OF ALLOCATION BUFFER HEADER 
literal ERL$M_LOCK = 1;
literal ERL$M_TIMER = 2;
literal ERL$S_ERLDEF = 12;
macro ERL$B_BUSY = 0,0,8,0 %;           ! NUMBER OF BUSY MESSAGES IN BUFFER 
macro ERL$B_MSGCNT = 1,0,8,0 %;         ! NUMBER OF COMPLETED MESSAGES IN BUFFER 
macro ERL$B_BUFIND = 2,0,8,0 %;         ! BUFFER INDICATOR OF RESPECTIVE BUFFER 
macro ERL$B_FLAGS = 3,0,8,0 %;          ! BUFFER CONTROL FLAGS 
macro ERL$L_NEXT = 4,0,32,0 %;          ! ADDRESS OF NEXT AVAILABLE SPACE IN BUFFER 
macro ERL$L_END = 8,0,32,0 %;           ! ADDRESS OF END OF BUFFER + 1 
macro ERL$V_LOCK = 8,0,1,0 %;           ! BUFFER ALLOCATION INTERLOCK 
macro ERL$V_TIMER = 8,1,1,0 %;          ! TIMER ACTIVE 
 
!*** MODULE $ERLMBXDEF ***
! 
!  ERROR LOG MAILBOX SYSTEM DATA CELL STRUCTURE AND MAILBOX COUNT
! 
literal ERL$K_MAILBOX_COUNT = 5;        !  NUMBER OF MAILBOXES
literal ERL$C_MAILBOX_COUNT = 5;        !  NUMBER OF MAILBOXES
literal ERL$K_MBX_LENGTH = 8;           !  LENGTH OF STRUCTURE
literal ERL$C_MBX_LENGTH = 8;           !  LENGTH OF STRUCTURE
literal ERL$S_ERLMBX = 8;
macro ERL$W_MBX_UNIT = 0,0,16,0 %;      !  MAILBOX UNIT NUMBER
macro ERL$W_MBX_FILLER_0 = 2,0,16,0 %;
macro ERL$L_MBX_PID = 4,0,32,0 %;       !  MBX OWNER PID
 
!*** MODULE $ERFMBXDEF ***
! 
!  COMPLEMENTARY STRUCTURES FOR ERRFMT DIAGNOSTIC MAILBOX CONTROL
! 
literal ERF$K_MBX_LENGTH = 6;           !  LENGTH OF STRUCTURE
literal ERF$C_MBX_LENGTH = 6;           !  LENGTH OF STRUCTURE
literal ERF$S_ERFMBX = 6;
macro ERF$W_MBX_CHANNEL = 0,0,16,0 %;   !  MBX CHANNEL NUMBER
macro ERF$W_MBX_SIZE = 2,0,16,0 %;      !  MBX SIZE
macro ERF$W_MBX_UNIT = 4,0,16,0 %;      !  MBX UNIT NUMBER
 
!*** MODULE $EVTDEF ***
! 
!  EVENT CODE DEFINITIONS
! 
literal EVT$_AST = 0;
literal EVT$_EVENT = 1;
literal EVT$_CEF = 2;
literal EVT$_LEFO = 3;
literal EVT$_FPGA = 4;
literal EVT$_WAKE = 5;
literal EVT$_RESUME = 6;
literal EVT$_PFCOM = 7;
literal EVT$_SETPRI = 8;
literal EVT$_SWPOUT = 9;
literal EVT$_SWPOUTE = 10;
literal EVT$_MAXEVT = 11;
literal EVT$_COLPGA = 0;
 
!*** MODULE $EWDATADEF ***
! +
!  $EWDATADEF - Symbolic offsets within the exec-writable page
! 
!  An exec-writable page is allocated when the system is bootstrapped.
!  The fields within this page are being defined below. These data cells
!  were originally defined in the system (i.e. in SYS.EXE) with the form:
! 
! 	PMS$xL_cellname. 
! 
!  Now that this cell resides in a seperate exec-writable page that is 
!  pointed by a cell in the system's base image, the symbolic offset from 
!  the base of the exec-writable page to this cell has the form:
! 
! 	EW_PMS$xL_cellname.
! 
! 
!  NOTE: The PMS Arrays (COUNT, MCNT, WRITE, CACHE, CPU, PFA) must immediately
!  follow FCP and FCP2 fields.
! 
! -
literal EW$K_LENGTH = 378;
literal EW$C_LENGTH = 378;
literal EW$S_EWDATADEF = 378;
macro EW$R_PMSEWDATA = 0,0,0,0 %;
literal EW_PMS$S_PMSEWDATA = 376;
macro EW_PMS$GL_FCP = 0,0,0,0 %;        !  start of the FCP counters
macro EW_PMS$GL_FCP2 = 0,0,0,0 %;       !  start of the FCP2 counters
macro EW_PMS$AL_COUNT = 0,0,0,0 %;
literal EW_PMS$S_COUNT = 40;            !  number of operations
macro EW_PMS$AL_MCNT = 40,0,0,0 %;
literal EW_PMS$S_MCNT = 40;             !  number of modifiers
macro EW_PMS$AL_READ = 80,0,0,0 %;
literal EW_PMS$S_READ = 40;             !  number of disk reads
macro EW_PMS$AL_WRITE = 120,0,0,0 %;
literal EW_PMS$S_WRITE = 40;            !  number of disk writes
macro EW_PMS$AL_CACHE = 160,0,0,0 %;
literal EW_PMS$S_CACHE = 40;            !  number of cache hits
macro EW_PMS$AL_CPU = 200,0,0,0 %;
literal EW_PMS$S_CPU = 40;              !  accumulated cpu times
macro EW_PMS$AL_PFA = 240,0,0,0 %;
literal EW_PMS$S_PFA = 40;              !  accumulated page faults
macro EW_PMS$GL_TURN = 280,0,32,0 %;    !  number of window turns
macro EW_PMS$GL_DIRHIT = 284,0,32,0 %;  !  count of directory LRU hits
macro EW_PMS$GL_DIRMISS = 288,0,32,0 %; !  count of directory LRU misses
macro EW_PMS$GL_QUOHIT = 292,0,32,0 %;  !  count of quota cache hits
macro EW_PMS$GL_QUOMISS = 296,0,32,0 %; !  count of quota cache misses
macro EW_PMS$GL_FIDHIT = 300,0,32,0 %;  !  count of file ID cache hits
macro EW_PMS$GL_FIDMISS = 304,0,32,0 %; !  count of file ID cache misses
macro EW_PMS$GL_EXTHIT = 308,0,32,0 %;  !  count of extent cache hits
macro EW_PMS$GL_EXTMISS = 312,0,32,0 %; !  count of extent cache misses
macro EW_PMS$GL_FILHDR_HIT = 316,0,32,0 %; !  count of file header cache hits
macro EW_PMS$GL_FILHDR_MISS = 320,0,32,0 %; !  count of file header cache misses
macro EW_PMS$GL_DIRDATA_HIT = 324,0,32,0 %; !  count of directory data block hits
macro EW_PMS$GL_DIRDATA_MISS = 328,0,32,0 %; !  count of directory data block misses
macro EW_PMS$GL_STORAGMAP_HIT = 332,0,32,0 %; !  count of storage bit map cache hits
macro EW_PMS$GL_STORAGMAP_MISS = 336,0,32,0 %; !  count of storage bit map cache misses
macro EW_PMS$GL_OPEN = 340,0,32,0 %;    !  number of currently open files
macro EW_PMS$GL_OPENS = 344,0,32,0 %;   !  total count of opens
macro EW_PMS$GL_ERASEIO = 348,0,32,0 %; !  total count of erase QIO's issued
macro EW_PMS$GL_VOLLCK = 352,0,32,0 %;  !  count of XQP volume synch locks
macro EW_PMS$GL_VOLWAIT = 356,0,32,0 %; !  # of times XQP had to wait for a 
!  volume synch lock
macro EW_PMS$GL_SYNCHLCK = 360,0,32,0 %; !  count of XQP directory and 
!  file synch locks
macro EW_PMS$GL_SYNCHWAIT = 364,0,32,0 %; !  # of times XQP had to wait for a 
!  directory or file synch lock
macro EW_PMS$GL_ACCLCK = 368,0,32,0 %;  !  count of XQP access locks
macro EW_PMS$GL_XQPCACHEWAIT = 372,0,32,0 %; !  # of times XQP had to wait for free
!  space in a cache
macro EW$R_RMSEWDATA = 376,0,16,0 %;
literal EW_RMS$S_RMSEWDATA = 2;
macro EW_RMS$GW_GBLBUFQUO = 376,0,16,0 %; !  current global buffer quota remaining
 
!*** MODULE $F11BDEF ***
! +
!  F11B - System wide F11BXQP structures.
! 
!  This structure is actually part of the XQP impure area and
!  is pointed to by CTL$GL_F11BXQP.  That cell is initialized
!  during process creation by the XQP initialization code.
! 
! -
literal F11B$S_F11BDEF = 32;
macro F11B$Q_XQPQUEUE = 0,0,0,0 %;
literal F11B$S_XQPQUEUE = 8;            !  XQP per-process queue.
macro F11B$L_DISPATCH = 8,0,32,0 %;     !  Address of XQP dispatch routine.
macro F11B$L_CODESIZE = 12,0,32,0 %;    !  Size of XQP code in bytes.
macro F11B$L_CODEBASE = 16,0,32,0 %;    !  Base address of XQP code.
macro F11B$L_IMPSIZE = 20,0,32,0 %;     !  Size of impure area in bytes.
macro F11B$L_IMPBASE = 24,0,32,0 %;     !  Base address of XQP impure area.
macro F11B$L_PREV_XQP = 28,0,32,0 %;    !  Pointer to previous replaced XQP
 
!*** MODULE $F11BCDEF ***
! +
!  F11BC - Files 11 Block Cache
! 
!  Header area which describes block cache used by F11BXQP.
! 
! -
literal F11BC$K_NUM_POOLS = 4;          !  Number of buffer pools.
literal F11BC$S_F11BCDEF = 208;
macro F11BC$L_BUFBASE = 0,0,32,0 %;     !  Base address of buffer area.
macro F11BC$L_BUFSIZE = 4,0,32,0 %;     !  Size of buffer area in bytes.
macro F11BC$W_SIZE = 8,0,16,0 %;        !  Standard size field.
macro F11BC$B_TYPE = 10,0,8,0 %;        !  Standard type field.
macro F11BC$B_SUBTYPE = 11,0,8,0 %;     !  Standard subtype field.
macro F11BC$L_REALSIZE = 12,0,32,0 %;   !  Structure size as a longword.
macro F11BC$L_LBNHSHBAS = 16,0,32,0 %;  !  Base of LBN hash table.
macro F11BC$W_LBNHSHCNT = 20,0,16,0 %;  !  Count of entries in LBN hash tbl.
macro F11BC$W_BFRCNT = 22,0,16,0 %;     !  Total buffer count.
macro F11BC$L_BFRDBAS = 24,0,32,0 %;    !  Buffer descriptor base address.
macro F11BC$L_BFRLDBAS = 28,0,32,0 %;   !  Buffer lock descriptor base addr.
macro F11BC$L_BLHSHBAS = 32,0,32,0 %;   !  Base addr of buffer lock hash tbl.
macro F11BC$W_BLHSHCNT = 36,0,16,0 %;   !  Num entries in buff lock hash tbl.
macro F11BC$W_FREEBFRL = 38,0,16,0 %;   !  First free buffer lock block.
macro F11BC$Q_POOL_LRU = 40,0,0,0 %;
literal F11BC$S_POOL_LRU = 32;          !  Per pool LRU listhead.
macro F11BC$Q_POOL_WAITQ = 72,0,0,0 %;
literal F11BC$S_POOL_WAITQ = 32;        !  Per pool cache wait listhead.
macro F11BC$W_WAITCNT = 104,0,0,1 %;
literal F11BC$S_WAITCNT = 8;            !  Count of waiters per pool.
macro F11BC$L_POOLAVAIL = 112,0,0,1 %;
literal F11BC$S_POOLAVAIL = 16;         !  Available buffers per pool.
macro F11BC$W_POOLCNT = 128,0,0,1 %;
literal F11BC$S_POOLCNT = 8;            !  Count of buffers per pool.
macro F11BC$L_AMBIGQFL = 136,0,32,0 %;  !  Ambiguity queue forward link.
macro F11BC$L_AMBIGQBL = 140,0,32,0 %;  !  Ambiguity queue back link.
! 
!  Cache performance counters.
! 
macro F11BC$L_PROCESS_HITS = 144,0,32,0 %; !  In-process buffer hits.
macro F11BC$L_VALID_HITS = 148,0,32,0 %; !  Valid buffer cache hits.
macro F11BC$L_INVALID_HITS = 152,0,32,0 %; !  Buffer found but invalid contents.
macro F11BC$L_MISSES = 156,0,32,0 %;    !  Buffer not in cache at all.
macro F11BC$L_DISK_READS = 160,0,32,0 %; !  Buffer reads from disk.
macro F11BC$L_DISK_WRITES = 164,0,32,0 %; !  Buffer writes to disk.
macro F11BC$L_CACHE_SERIAL = 168,0,32,0 %; !  Cache serialization calls.
macro F11BC$L_CACHE_STALLS = 172,0,32,0 %; !  Cache serialization stalls.
macro F11BC$L_BUFFER_STALLS = 176,0,32,0 %; !  Stalls for lack of buffers.
macro F11BC$T_CACHENAME = 180,0,0,0 %;
literal F11BC$S_CACHENAME = 24;         !  Name of this cache (display only).
macro F11BC$L_LOG_BUFFER = 204,0,32,0 %; !  Pointer to activity log buffer
! 
!  Buffer descriptors.
! 
literal BFRD$M_DIRTY = 4;
literal BFRD$M_VALID = 8;
literal BFRD$S_BFRDDEF = 36;
macro BFRD$L_QFL = 0,0,32,0 %;          !  Queue forward link.
macro BFRD$L_QBL = 4,0,32,0 %;          !  Queue back link.
macro BFRD$L_LBN = 8,0,32,0 %;          !  LBN of buffer.
macro BFRD$L_UCB = 12,0,32,0 %;         !  UCB of buffer.
macro BFRD$L_LOCKBASIS = 16,0,32,0 %;   !  Unique file identifier.
macro BFRD$L_SEQNUM = 20,0,32,0 %;      !  Buffer validation sequence number.
macro BFRD$B_FLAGS = 24,0,8,0 %;        !  Status flags.
macro BFRD$V_POOL = 24,0,2,0 %;
literal BFRD$S_POOL = 2;                !  Pool number of this buffer.
macro BFRD$V_DIRTY = 24,2,1,0 %;        !  Buffer has been modified.
macro BFRD$V_VALID = 24,3,1,0 %;        !  Buffer has been read from disk.
macro BFRD$B_BTYPE = 25,0,8,0 %;        !  Buffer type.
macro BFRD$W_CURPID = 26,0,16,0 %;      !  Index of current process.
macro BFRD$W_NXTBFRD = 28,0,16,0 %;     !  Index of next BFRD (hash chain).
macro BFRD$W_BFRL = 30,0,16,0 %;        !  Index to buffer lock.
macro BFRD$W_SAME_BFRL = 32,0,16,0 %;   !  Index to next BFRD under same BFRL
! 
!  Buffer lock descriptor blocks.
! 
literal BFRL$S_BFRLDEF = 20;
macro BFRL$W_NXTBFRL = 0,0,16,0 %;      !  Index to next BFRL in list.
macro BFRL$W_BFRD = 2,0,16,0 %;         !  Index to first BFRD
macro BFRL$W_REFCNT = 4,0,16,0 %;       !  Number of buffers backed by this lock.
macro BFRL$L_LKID = 8,0,32,0 %;         !  Lock ID of buffer lock.
macro BFRL$L_LCKBASIS = 12,0,32,0 %;    !  Unique file identifier.
macro BFRL$L_PARLKID = 16,0,32,0 %;     !  Unique volume set identifier.
 
!*** MODULE $FBICDEF ***
! ++
! 	Define FBIC offsets and registers for Firefox systems
! --
literal FBIC$L_MODTYPE = 508;           ! Module type
literal FBIC$L_BUSCSR = 504;            ! MBUS error status
literal FBIC$L_BUSCTL = 500;            ! MBUS error control signal log
literal FBIC$L_BUSADR = 496;            ! MBUS error address signal log
literal FBIC$L_BUSDAT = 492;            ! MBUS error data signal log
literal FBIC$L_FBICSR = 488;            ! FBIC CSR
literal FBIC$L_RANGE = 484;             ! I/O Space range deco=e
literal FBIC$L_IPDVINT = 480;           ! IP/Device interrupt
literal FBIC$L_WHAMI = 476;             ! Unique software ID
literal FBIC$L_CPUID = 472;             ! Unique hardware ID
literal FBIC$L_IADR1 = 468;             ! Interlock 1 address
literal FBIC$L_IADR2 = 464;             ! Interlock 2 address
literal FBIC$L_SAVGPR = 452;            ! Scratch register
literal FMDC$L_FMDCSR = 488;            ! FMDC CSR
literal FMDC$L_BASEADDR = 484;          ! Memory space base address
literal FMDC$L_ECCADDR0 = 480;          ! ECC error address (QW0)
literal FMDC$L_ECCADDR1 = 476;          ! ECC error address (QW1)
literal FMDC$L_ECCSYND0 = 472;          ! ECC error status (QW0)
literal FMDC$L_ECCSYND1 = 468;          ! ECC error status (QW1)
literal FMDC$L_MSECTERR = 464;          ! Memory section
literal FMDC$L_MBUSSIG = 460;           ! MBUS control signature
literal FMDC$L_DRAMSIG = 456;           ! DRAM control signature
literal FMDC$L_SELFSIG = 452;           ! Self test signature
literal FMDC$L_LEDLATCH = 448;          ! Diagnostic LED latch
literal FBIC$S_MODTYPE = 4;
macro FBIC$V_MODTYPE_CLASS = 0,0,8,0 %;
literal FBIC$S_MODTYPE_CLASS = 8;       !  Class of module
macro FBIC$V_MODTYPE_SUBCLASS = 0,8,8,0 %;
literal FBIC$S_MODTYPE_SUBCLASS = 8;    !  Low bit echoes TYPDUAL
macro FBIC$V_MODTYPE_INTERFACE = 0,16,8,0 %;
literal FBIC$S_MODTYPE_INTERFACE = 8;   !  FBIC interface  == 1
macro FBIC$V_MODTYPE_REVISION = 0,24,8,0 %;
literal FBIC$S_MODTYPE_REVISION = 8;    !  FBIC hardware revision
literal KA60$K_MODTYPE_FBIC = 1;        !  1 FBIC interface
literal KA60$K_MODTYPE_FMDC = 2;        !  2 FMDC interface
literal KA60$K_MODTYPE_FMCM = 254;
literal FBIC$M_BUSCSR_DBLE = 65536;
literal FBIC$M_BUSCSR_SERR = 131072;
literal FBIC$M_BUSCSR_CTPE = 262144;
literal FBIC$M_BUSCSR_CDPE = 524288;
literal FBIC$M_BUSCSR_CTO = 1048576;
literal FBIC$M_BUSCSR_NOS = 2097152;
literal FBIC$M_BUSCSR_MTO = 4194304;
literal FBIC$M_BUSCSR_ILCK = 8388608;
literal FBIC$M_BUSCSR_MCPE = 16777216;
literal FBIC$M_BUSCSR_MSPE = 33554432;
literal FBIC$M_BUSCSR_MDPE = 67108864;
literal FBIC$M_BUSCSR_MTPE = 134217728;
literal FBIC$M_BUSCSR_IDAT = 268435456;
literal FBIC$M_BUSCSR_ICMD = 536870912;
literal FBIC$M_BUSCSR_ARB = 1073741824;
literal FBIC$M_BUSCSR_FRZN = -2147483648;
literal FBIC$S_BUSCSR = 4;
macro FBIC$V_BUSCSR_DBLE = 0,16,1,0 %;  ! MBUS double error bit
macro FBIC$V_BUSCSR_SERR = 0,17,1,0 %;  ! SERR
macro FBIC$V_BUSCSR_CTPE = 0,18,1,0 %;  ! CDAL tag store parity error
macro FBIC$V_BUSCSR_CDPE = 0,19,1,0 %;  ! CDAL parity error
macro FBIC$V_BUSCSR_CTO = 0,20,1,0 %;   ! CDAL timeout
macro FBIC$V_BUSCSR_NOS = 0,21,1,0 %;   ! MBUS no slave response
macro FBIC$V_BUSCSR_MTO = 0,22,1,0 %;   ! MBUS slave timeout
macro FBIC$V_BUSCSR_ILCK = 0,23,1,0 %;  ! MBUS interlock violation
macro FBIC$V_BUSCSR_MCPE = 0,24,1,0 %;  ! MBUS MCMD parity error
macro FBIC$V_BUSCSR_MSPE = 0,25,1,0 %;  ! MBUS MSTATUS parity error
macro FBIC$V_BUSCSR_MDPE = 0,26,1,0 %;  ! MBUS MDAL parity error
macro FBIC$V_BUSCSR_MTPE = 0,27,1,0 %;  ! MBUS tag parity error
macro FBIC$V_BUSCSR_IDAT = 0,28,1,0 %;  ! MBUS invalid data supplied
macro FBIC$V_BUSCSR_ICMD = 0,29,1,0 %;  ! MBUS invalid MCMD encoding
macro FBIC$V_BUSCSR_ARB = 0,30,1,0 %;   ! MBUS arbitration error
macro FBIC$V_BUSCSR_FRZN = 0,31,1,0 %;  ! MBUS error logging frozen
literal FBIC$M_BUSCTL_MBRM = 127;
literal FBIC$M_BUSCTL_MBRP = 128;
literal FBIC$M_BUSCTL_MBRQ = 256;
literal FBIC$M_BUSCTL_MCMD = 7680;
literal FBIC$M_BUSCTL_MCPAR = 8192;
literal FBIC$M_BUSCTL_MSTATUS = 49152;
literal FBIC$M_BUSCTL_MSPAR = 65536;
literal FBIC$M_BUSCTL_MDPAR = 131072;
literal FBIC$M_BUSCTL_MBUSY = 262144;
literal FBIC$M_BUSCTL_MSHARED = 524288;
literal FBIC$M_BUSCTL_MDATINV = 1048576;
literal FBIC$M_BUSCTL_MABORT = 2097152;
literal FBIC$M_BUSCTL_MHALT = 4194304;
literal FBIC$M_BUSCTL_PHASE = 58720256;
literal FBIC$M_BUSCTL_SLAVE = 67108864;
literal FBIC$M_BUSCTL_MASTER = 134217728;
literal FBIC$M_BUSCTL_SVDMCMD = -268435456;
literal FBIC$S_BUSCTL = 4;
macro FBIC$V_BUSCTL_MBRM = 0,0,7,0 %;
literal FBIC$S_BUSCTL_MBRM = 7;         !  MBRM signals
macro FBIC$V_BUSCTL_MBRP = 0,7,1,0 %;   !  MBRP signal
macro FBIC$V_BUSCTL_MBRQ = 0,8,1,0 %;   !  MBRQ signal
macro FBIC$V_BUSCTL_MCMD = 0,9,4,0 %;
literal FBIC$S_BUSCTL_MCMD = 4;         !  MCMD signals
macro FBIC$V_BUSCTL_MCPAR = 0,13,1,0 %; !  MCPAR signal
macro FBIC$V_BUSCTL_MSTATUS = 0,14,2,0 %;
literal FBIC$S_BUSCTL_MSTATUS = 2;      !  MSTATUS signal
macro FBIC$V_BUSCTL_MSPAR = 0,16,1,0 %; !  MSPAR
macro FBIC$V_BUSCTL_MDPAR = 0,17,1,0 %; !  MDPAR
macro FBIC$V_BUSCTL_MBUSY = 0,18,1,0 %; !  MBUSY
macro FBIC$V_BUSCTL_MSHARED = 0,19,1,0 %; !  MSHARED
macro FBIC$V_BUSCTL_MDATINV = 0,20,1,0 %; !  MDATINV
macro FBIC$V_BUSCTL_MABORT = 0,21,1,0 %; !  MABORT
macro FBIC$V_BUSCTL_MHALT = 0,22,1,0 %; !  MHALT
macro FBIC$V_BUSCTL_PHASE = 0,23,3,0 %;
literal FBIC$S_BUSCTL_PHASE = 3;        !  BUS PHASE
macro FBIC$V_BUSCTL_SLAVE = 0,26,1,0 %; !  SLAVE
macro FBIC$V_BUSCTL_MASTER = 0,27,1,0 %; !  MASTER
macro FBIC$V_BUSCTL_SVDMCMD = 0,28,4,0 %;
literal FBIC$S_BUSCTL_SVDMCMD = 4;      !  MCMD signal
literal FBIC$M_FBICSR_CDPE = 1;
literal FBIC$M_FBICSR_TSTFNC = 62;
literal FBIC$M_FBICSR_HALTEN = 128;
literal FBIC$M_FBICSR_LEDS = 16128;
literal FBIC$M_FBICSR_IRQC2M = 983040;
literal FBIC$M_FBICSR_IRQEN = 15728640;
literal FBIC$M_FBICSR_RESET = 16777216;
literal FBIC$M_FBICSR_HALTCPU = 33554432;
literal FBIC$M_FBICSR_EXCAEN = 67108864;
literal FBIC$M_FBICSR_CMISS = 134217728;
literal FBIC$M_FBICSR_MFMD = -1073741824;
literal FBIC$S_FBICSR = 4;
macro FBIC$V_FBICSR_CDPE = 0,0,1,0 %;   ! CBUS parity check enable
macro FBIC$V_FBICSR_TSTFNC = 0,1,5,0 %;
literal FBIC$S_FBICSR_TSTFNC = 5;       ! Diagnostic test function
macro FBIC$V_FBICSR_HALTEN = 0,7,1,0 %; ! Enable CPU halts
macro FBIC$V_FBICSR_LEDS = 0,8,6,0 %;
literal FBIC$S_FBICSR_LEDS = 6;         ! FBIC LED output
macro FBIC$V_FBICSR_IRQC2M = 0,16,4,0 %;
literal FBIC$S_FBICSR_IRQC2M = 4;       ! Interrupt request direction
macro FBIC$V_FBICSR_IRQEN = 0,20,4,0 %;
literal FBIC$S_FBICSR_IRQEN = 4;        ! Interrupt request enable
macro FBIC$V_FBICSR_RESET = 0,24,1,0 %; ! CBUS RESET
macro FBIC$V_FBICSR_HALTCPU = 0,25,1,0 %; ! CBUS halt control
macro FBIC$V_FBICSR_EXCAEN = 0,26,1,0 %; ! External cache enable
macro FBIC$V_FBICSR_CMISS = 0,27,1,0 %; ! CBUS cache miss occurred
macro FBIC$V_FBICSR_MFMD = 0,30,2,0 %;
literal FBIC$S_FBICSR_MFMD = 2;         ! Manufacturing mode
literal FBIC$M_RANGE_MASK = 32767;
literal FBIC$M_RANGE_ENABLE = 32768;
literal FBIC$M_RANGE_MATCH = -65536;
literal FBIC$S_RANGE = 4;
macro FBIC$V_RANGE_MASK = 0,0,15,0 %;
literal FBIC$S_RANGE_MASK = 15;         ! I/O space address range mask
macro FBIC$V_RANGE_ENABLE = 0,15,1,0 %; ! I/O space address range enable
macro FBIC$V_RANGE_MATCH = 0,16,16,0 %;
literal FBIC$S_RANGE_MATCH = 16;        ! I/O space address range match
literal FBIC$M_IPDVINT_VECTOR = 65535;
literal FBIC$M_IPDVINT_DEVUNIT = 65536;
literal FBIC$M_IPDVINT_IPUNIT = 131072;
literal FBIC$M_IPDVINT_IPL14 = 16777216;
literal FBIC$M_IPDVINT_IPL15 = 33554432;
literal FBIC$M_IPDVINT_IPL16 = 67108864;
literal FBIC$M_IPDVINT_IPL17 = 134217728;
literal FBIC$S_IPDVINT = 4;
macro FBIC$V_IPDVINT_VECTOR = 0,0,16,0 %;
literal FBIC$S_IPDVINT_VECTOR = 16;     ! Interrupt vector
macro FBIC$V_IPDVINT_DEVUNIT = 0,16,1,0 %; ! Device interrupt unit
macro FBIC$V_IPDVINT_IPUNIT = 0,17,1,0 %; ! I/P interrupt unit
macro FBIC$V_IPDVINT_IPL14 = 0,24,1,0 %; ! Generate IPL 14 interrupt
macro FBIC$V_IPDVINT_IPL15 = 0,25,1,0 %; ! Generate IPL 15 interrupt
macro FBIC$V_IPDVINT_IPL16 = 0,26,1,0 %; ! Generate IPL 16 interrupt
macro FBIC$V_IPDVINT_IPL17 = 0,27,1,0 %; ! Generate IPL 17 interrupt
literal FBIC$M_CPUID_PROC = 3;
literal FBIC$M_CPUID_MID = 12;
literal FBIC$S_CPUID = 1;
macro FBIC$V_CPUID_PROC = 0,0,2,0 %;
literal FBIC$S_CPUID_PROC = 2;          ! Processor identifier
macro FBIC$V_CPUID_MID = 0,2,2,0 %;
literal FBIC$S_CPUID_MID = 2;           ! Module slot identifier
literal FMDC$M_FMDCSR_RAS_CNT = 255;
literal FMDC$M_FMDCSR_ST_START = 256;
literal FMDC$M_FMDCSR_ST_DONE = 512;
literal FMDC$M_FMDCSR_DTCB = 1024;
literal FMDC$M_FMDCSR_DIS_REFRESH = 4096;
literal FMDC$M_FMDCSR_RPS = 8192;
literal FMDC$M_FMDCSR_DRS = 16384;
literal FMDC$M_FMDCSR_EDM = 98304;
literal FMDC$M_FMDCSR_FESC = 393216;
literal FMDC$M_FMDCSR_FEC = 3670016;
literal FMDC$M_FMDCSR_ISR = 4194304;
literal FMDC$M_FMDCSR_ISML = 8388608;
literal FMDC$M_FMDCSR_MOL = 1073741824;
literal FMDC$M_FMDCSR_EFS = -2147483648;
literal FMDC$S_FMDCSR = 4;
macro FMDC$V_FMDCSR_RAS_CNT = 0,0,8,0 %;
literal FMDC$S_FMDCSR_RAS_CNT = 8;      !  Refresh counter
macro FMDC$V_FMDCSR_ST_START = 0,8,1,0 %; !  Self test start
macro FMDC$V_FMDCSR_ST_DONE = 0,9,1,0 %; !  Self test complete
macro FMDC$V_FMDCSR_DTCB = 0,10,1,0 %;  !  Data to check bits
macro FMDC$V_FMDCSR_DIS_REFRESH = 0,12,1,0 %; !  Disable refresh
macro FMDC$V_FMDCSR_RPS = 0,13,1,0 %;   !  Refresh period select
macro FMDC$V_FMDCSR_DRS = 0,14,1,0 %;   !  Diagnostic refresh start
macro FMDC$V_FMDCSR_EDM = 0,15,2,0 %;
literal FMDC$S_FMDCSR_EDM = 2;          !  ECC diagnostic mode
macro FMDC$V_FMDCSR_FESC = 0,17,2,0 %;
literal FMDC$S_FMDCSR_FESC = 2;         !  Force error sub category
macro FMDC$V_FMDCSR_FEC = 0,19,3,0 %;
literal FMDC$S_FMDCSR_FEC = 3;          !  Force error category
macro FMDC$V_FMDCSR_ISR = 0,22,1,0 %;   !  Inhibit SBE reporting
macro FMDC$V_FMDCSR_ISML = 0,23,1,0 %;  !  Inhibit SBE MSECTERR log
macro FMDC$V_FMDCSR_MOL = 0,30,1,0 %;   !  Module on-line
macro FMDC$V_FMDCSR_EFS = 0,31,1,0 %;   !  Error flag summary
literal FMDC$M_BASEADDR_STARTADDR = 2146435072;
literal FMDC$M_BASEADDR_MEMSPEN = -2147483648;
literal FMDC$S_BASEADDR = 4;
macro FMDC$V_BASEADDR_STARTADDR = 0,20,11,0 %;
literal FMDC$S_BASEADDR_STARTADDR = 11; !  Starting memory address
macro FMDC$V_BASEADDR_MEMSPEN = 0,31,1,0 %; !  Memory space enable
literal FMDC$M_ECCADDR_RAMERRADDR0 = 134217712;
literal FMDC$S_ECCADDR = 4;
macro FMDC$V_ECCADDR_RAMERRADDR0 = 0,4,23,0 %;
literal FMDC$S_ECCADDR_RAMERRADDR0 = 23; !  ECC Error address
literal FMDC$M_ECCSYND_SYND0 = 255;
literal FMDC$M_ECCSYND_SBE = 256;
literal FMDC$M_ECCSYND_MBE = 512;
literal FMDC$M_ECCSYND_ERROVFL = 7168;
literal FMDC$M_ECCSYND_SUBCB = 16711680;
literal FMDC$M_ECCSYND_READCB = -16777216;
literal FMDC$S_ECCSYND = 4;
macro FMDC$V_ECCSYND_SYND0 = 0,0,8,0 %;
literal FMDC$S_ECCSYND_SYND0 = 8;       !  ECC syndronme
macro FMDC$V_ECCSYND_SBE = 0,8,1,0 %;   !  Single bit error
macro FMDC$V_ECCSYND_MBE = 0,9,1,0 %;   !  Multiple bit error
macro FMDC$V_ECCSYND_ERROVFL = 0,10,3,0 %;
literal FMDC$S_ECCSYND_ERROVFL = 3;     !  Error overflow field
macro FMDC$V_ECCSYND_SUBCB = 0,16,8,0 %;
literal FMDC$S_ECCSYND_SUBCB = 8;       !  Substitute check bits
macro FMDC$V_ECCSYND_READCB = 0,24,8,0 %;
literal FMDC$S_ECCSYND_READCB = 8;      !  Read check bits
 
!*** MODULE $FCBDEF ***
! +
!  FCB - FILE CONTROL BLOCK
! 
!  THERE IS ONE FILE CONTROL BLOCK FOR EACH UNIQUELY ACCESSED FILE ON A
!  VOLUME. THE FILE CONTROL BLOCK PROVIDES THE VEHICLE WHEREBY SHARED
!  ACCESS TO A FILE MAY BE CONTROLLED.
! -
literal FCB$K_LENGTH = 204;             !  LENGTH OF STANDARD FCB 
literal FCB$C_LENGTH = 204;             !  LENGTH OF STANDARD FCB 
literal FCB$S_FCBDEF = 204;
macro FCB$L_FCBFL = 0,0,32,0 %;         !  FCB LIST FORWARD LINK 
macro FCB$L_FCBBL = 4,0,32,0 %;         !  FCB LIST BACKWARD LINK 
macro FCB$W_SIZE = 8,0,16,0 %;          !  SIZE OF FCB IN BYTES 
macro FCB$B_TYPE = 10,0,8,0 %;          !  STRUCTURE TYPE OF FCB 
macro FCB$B_ACCLKMODE = 11,0,8,0 %;     !  Access lock mode.
macro FCB$L_EXFCB = 12,0,32,0 %;        !  ADDRESS OF EXTENSION FCB 
macro FCB$L_WLFL = 16,0,32,0 %;         !  WINDOW LISTHEAD FORWARD LINK 
macro FCB$L_WLBL = 20,0,32,0 %;         !  WINDOW LISTHEAD BACKWARD LINK 
macro FCB$W_REFCNT = 24,0,16,0 %;       !  Total references to this FCB.
macro FCB$W_ACNT = 26,0,16,0 %;         !  FILE ACCESS COUNT 
macro FCB$W_WCNT = 28,0,16,0 %;         !  FILE WRITER COUNT 
macro FCB$W_LCNT = 30,0,16,0 %;         !  FILE LOCK COUNT 
macro FCB$W_TCNT = 32,0,16,0 %;         !  COUNT OF TRUNCATE LOCKS 
macro FCB$W_STATUS = 34,0,16,0 %;       !  FILE STATUS 
macro FCB$V_DIR = 34,0,1,0 %;           !  FCB IS A DIRECTORY LRU ENTRY 
macro FCB$V_MARKDEL = 34,1,1,0 %;       !  FILE IS MARKED FOR DELETE 
macro FCB$V_BADBLK = 34,2,1,0 %;        !  BAD BLOCK ENCOUNTERED IN FILE 
macro FCB$V_EXCL = 34,3,1,0 %;          !  FILE IS EXCLUSIVELY ACCESSED 
macro FCB$V_SPOOL = 34,4,1,0 %;         !  FILE IS AN INTERMEDIATE SPOOL FILE 
macro FCB$V_RMSLOCK = 34,5,1,0 %;       !  FILE IS OPEN WITH RMS RECORD LOCKING 
macro FCB$V_ERASE = 34,6,1,0 %;         !  ERASE DATA WHEN BLOCKS REMOVED FROM FILE
macro FCB$V_BADACL = 34,7,1,0 %;        !  ACL IS CORRUPT
macro FCB$V_STALE = 34,8,1,0 %;         !  Reconstruct FCB from header.
macro FCB$V_DELAYTRNC = 34,9,1,0 %;     !  Delay truncation.
macro FCB$V_LIMBO = 34,10,1,0 %;        !  FCB is linked into the LIMBO queue
macro FCB$V_ISDIR = 34,11,1,0 %;        !  This FCB is a directory FCB
macro FCB$V_NOMOVE = 34,12,1,0 %;       !  This file is NOT to be MOVEFILE'ed
macro FCB$W_FID = 36,0,0,0 %;
literal FCB$S_FID = 6;                  !  FILE IDENTIFICATION 
macro FCB$W_FID_NUM = 36,0,16,0 %;      !  FILE NUMBER 
macro FCB$W_FID_SEQ = 38,0,16,0 %;      !  FILE SEQUENCE NUMBER 
macro FCB$W_FID_RVN = 40,0,16,0 %;      !  RELATIVE VOLUME NUMBER 
macro FCB$B_FID_RVN = 40,0,8,0 %;       !  SHORT FORM RVN 
macro FCB$B_FID_NMX = 41,0,8,0 %;       !  EXTENDED FILE NUMBER 
macro FCB$W_SEGN = 42,0,16,0 %;         !  FILE SEGMENT NUMBER 
macro FCB$L_STVBN = 44,0,32,0 %;        !  STARTING VIRTUAL BLOCK NUMBER 
macro FCB$L_STLBN = 48,0,32,0 %;        !  STARTING LOGICAL BLOCK NUMBER 
macro FCB$L_HDLBN = 52,0,32,0 %;        !  LBN OF FILE HEADER 
macro FCB$L_FILESIZE = 56,0,32,0 %;     !  FILE SIZE IN BLOCKS 
macro FCB$L_EFBLK = 60,0,32,0 %;        !  END OF FILE VBN 
macro FCB$W_VERSIONS = 64,0,16,0 %;     !  MAXIMUM NUMBER OF VERSIONS IN DIRECTORY 
macro FCB$L_DIRINDX = 66,0,32,0 %;      !  Directory index pointer
macro FCB$W_DIRSEQ = 70,0,16,0 %;       !  DIRECTORY USE SEQUENCE NUMBER 
macro FCB$L_ACCLKID = 72,0,32,0 %;      !  Access lock ID.
macro FCB$L_LOCKBASIS = 76,0,32,0 %;    !  Lock basis for this FCB.
macro FCB$L_TRUNCVBN = 80,0,32,0 %;     !  VBN for delayed truncation.
macro FCB$L_CACHELKID = 84,0,32,0 %;    !  Cache interlock lock ID
macro FCB$L_HIGHWATER = 88,0,32,0 %;    !  HIGH WATER MARK IN FILE
macro FCB$L_NEWHIGHWATER = 92,0,32,0 %; !  Highwater mark of pending writes
macro FCB$W_HWM_UPDATE = 96,0,16,0 %;   !  Count of writes past highwater mark
macro FCB$W_HWM_ERASE = 98,0,16,0 %;    !  Count of writes starting past highwater mark
macro FCB$W_HWM_PARTIAL = 100,0,16,0 %; !  Count of partially validated erase operations
macro FCB$Q_HWMQHD = 104,0,0,0 %;
literal FCB$S_HWMQHD = 8;               !  High water mark queue header
macro FCB$L_HWM_WAITFL = 104,0,32,0 %;  !  Highwater mark update queue
macro FCB$L_HWM_WAITBL = 108,0,32,0 %;  !  Highwater mark update queue
macro FCB$Q_LIMBOQHD = 104,0,0,0 %;
literal FCB$S_LIMBOQHD = 8;             !  LIMBO queue header
macro FCB$L_LIMBOFL = 104,0,32,0 %;     !  Highwater mark update queue
macro FCB$L_LIMBOBL = 108,0,32,0 %;     !  Highwater mark update queue
macro FCB$R_ORB = 112,0,0,0 %;
literal FCB$S_ORB = 88;                 !  Object's Rights Block
macro FCB$L_FILEOWNER = 112,0,32,0 %;   !  FILE OWNER UIC 
macro FCB$W_UICMEMBER = 112,0,16,0 %;   !  MEMBER NUMBER 
macro FCB$W_UICGROUP = 114,0,16,0 %;    !  GROUP NUMBER 
macro FCB$Q_ACMODE = 128,0,0,0 %;
literal FCB$S_ACMODE = 8;               !  Access mode protection vector
macro FCB$L_SYS_PROT = 136,0,32,0 %;    !  Protection word/vector
macro FCB$W_FILEPROT = 136,0,16,0 %;    !  FILE PROTECTION MASK 
macro FCB$L_OWN_PROT = 140,0,32,0 %;    !  Owner protection
macro FCB$L_GRP_PROT = 144,0,32,0 %;    !  Group protection
macro FCB$L_WOR_PROT = 148,0,32,0 %;    !  World protection
macro FCB$L_ACLFL = 152,0,32,0 %;       !  ACCESS CONTROL LIST FORWARD LINK 
macro FCB$L_ACLBL = 156,0,32,0 %;       !  ACCESS CONTROL LIST BACKWARD LINK 
macro FCB$R_MIN_CLASS_PROT = 160,0,0,0 %;
literal FCB$S_MIN_CLASS_PROT = 20;      !  Minimum security classification mask
macro FCB$R_MAX_CLASS_PROT = 180,0,0,0 %;
literal FCB$S_MAX_CLASS_PROT = 20;      !  Maximum security classification mask
macro FCB$L_CFCB = 200,0,32,0 %;        !  VBN Cache pointer
 
!*** MODULE $FFIDEF ***
! +
!  FFI - Ethernet Fast Interface.  This interface is owned by the DECnet-VAX
!        group.  It is for internal (VMS) use only.  This interface will
!        change between baselevels and versions of VMS without notice.
!        DO NOT USE THIS INTERFACE UNLESS YOU HAVE PERMISSION FROM DECNET-VAX.
! -
literal FFI$L_CTRL = 36;                ! DATALINK CONTROL ENTRY POINT
literal FFI$L_CTRL_DONE = 40;           ! CALLER'S CONTROL DONE ENTRY POINT
literal FFI$W_ACCESS_CODE = 44;         ! CALLER'S ACCESS CODE
literal FFI$G_CTX_USER = 62;            ! CALLER'S CONTEXT BLOCK
literal FFI$K_LENGTH = 62;              ! LENGTH OF A STANDARD FFI
literal FFI$C_LENGTH = 62;              ! LENGTH OF A STANDARD FFI
!  Define the FFI control function codes. 
literal FFI$C_START = 0;                !  Start the protocol
literal FFI$C_STOP = 1;                 !  Stop the protocol
literal FFI$C_CHANGE = 2;               !  Change the protocol parameters
literal FFI$C_READ_PRM = 3;             !  Read protocol parameters
literal FFI$C_READ_CTRS = 4;            !  Read counters (unsupported in V1)
literal FFI$C_READ_CLR_CTRS = 5;        !  Read and clear counters (unsupported in V1)
!  Define the FFI working version number.
literal FFI$C_VERSION = 50;             !  FFI version number
literal FFI$S_FFIDEF = 62;
macro FFI$L_FL = 0,0,32,0 %;            ! FORWARD QUEUE LINK 
macro FFI$L_BL = 4,0,32,0 %;            ! BACKWARD QUEUE LINK 
macro FFI$W_SIZE = 8,0,16,0 %;          ! BLOCK SIZE 
macro FFI$B_TYPE = 10,0,8,0 %;          ! BLOCK TYPE 
macro FFI$B_VERSION = 11,0,8,0 %;       ! VERSION OF FFI
macro FFI$L_CTX_DL = 12,0,32,0 %;       ! DATALINK CONTEXT AREA
macro FFI$L_XMIT = 16,0,32,0 %;         ! DATALINK TRANSMIT ROUTINE ADDRESS
macro FFI$L_XMIT_DONE = 20,0,32,0 %;    ! CALLER'S TRANSMIT DONE ROUTINE ADDRESS
macro FFI$L_RECV_DONE = 24,0,32,0 %;    ! CALLER'S RECEIVE DONE ROUTINE ADDRESS
macro FFI$L_ERROR = 28,0,32,0 %;        ! CALLER'S ERROR HANDLER
macro FFI$L_SHUT_DONE = 32,0,32,0 %;    ! CALLER'S SHUTDOWN COMPLETE ROUTINE ADDRESS
macro FFI$L_SPARE0 = 36,0,32,0 %;       !    spare
macro FFI$L_SPARE1 = 40,0,32,0 %;       !    spare
macro FFI$L_SPARE2 = 44,0,32,0 %;       !    spare
macro FFI$L_SPARE3 = 48,0,32,0 %;       !    spare
macro FFI$L_DL_UCB = 52,0,32,0 %;       ! DATALINK UCB ADDRESS
macro FFI$L_PID = 56,0,32,0 %;          ! CALLER'S PID (or zero)
macro FFI$W_CHAN = 60,0,16,0 %;         ! CALLER'S CHAN (or zero)
 
!*** MODULE $FKBDEF ***
! +
!  FKB - FORK BLOCK
! 
!  A FORK BLOCK DESCRIBES THE CONTEXT OF A FORK PROCESS. EACH UNIT CONTROL
!  BLOCK CONTAINS A FORK BLOCK AS ITS FIRST SIX LONGWORDS.
! -
literal FKB$K_LENGTH = 24;              ! STANDARD LENGTH OF FKB 
literal FKB$C_LENGTH = 24;              ! STANDARD LENGTH OF FKB 
literal FKB$S_FKBDEF = 24;
macro FKB$L_FQFL = 0,0,32,0 %;          ! FORK QUEUE FORWARD LINK 
macro FKB$L_FQBL = 4,0,32,0 %;          ! FORK QUEUE BACKWARD LINK 
macro FKB$W_SIZE = 8,0,16,0 %;          ! SIZE OF FKB IN BYTES 
macro FKB$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE OF FKB 
macro FKB$B_FLCK = 11,0,8,0 %;          ! FORK LOCK NUMBER
macro FKB$B_FIPL = 11,0,8,0 %;          ! FORK IPL
macro FKB$L_FPC = 12,0,32,0 %;          ! FORK PC 
macro FKB$L_FR3 = 16,0,32,0 %;          ! FORK R3 
macro FKB$L_FR4 = 20,0,32,0 %;          ! FORK R4 
 
!*** MODULE $FQAMDEF ***
! ++
! 	Define FQAM CSR offsets and registers for Firefox systems
! --
literal FQAM$L_CSR = 0;                 ! FQAM II CSR
literal FQAM$M_CSR_QBUSARB = 1;
literal FQAM$M_CSR_DUMPERROR = 2;
literal FQAM$M_CSR_TESTMODE = 4;
literal FQAM$S_CSR = 4;
macro FQAM$V_CSR_QBUSARB = 0,0,1,0 %;   ! QBUS arbitration enable
macro FQAM$V_CSR_DUMPERROR = 0,1,1,0 %; ! Dump error
macro FQAM$V_CSR_TESTMODE = 0,2,1,0 %;  ! Test mode enable diags
 
!*** MODULE $FTRDDEF ***
! +
! 
!  FTRD - Read request packet for FTDRIVER
! 
!  The FTRD packet is very similar to an IRP but much smaller.  It has an 
!  ACB at the front, the EFN, and some information about the read buffer.
! 
! -
literal FTRD$K_LENGTH = 40;             !  Size of read packet
literal FTRD$C_LENGTH = 40;             ! 
literal FTRD$S_FTRDDEF = 40;
macro FTRD$L_ASTQFL = 0,0,32,0 %;       !  Read and AST queue forward link
macro FTRD$L_ASTQBL = 4,0,32,0 %;       !  Read and AST queue backward link
macro FTRD$W_SIZE = 8,0,16,0 %;         !  Size of structure
macro FTRD$B_TYPE = 10,0,8,0 %;         !  Type of structure
macro FTRD$B_RMOD = 11,0,8,0 %;         !  RMOD bits used by AST delivery code
macro FTRD$L_PID = 12,0,32,0 %;         !  Internal PID of process to receive AST
macro FTRD$L_AST = 16,0,32,0 %;         !  AST routine address
macro FTRD$L_ASTPRM = 20,0,32,0 %;      !  AST parameter
macro FTRD$B_EFN = 24,0,8,0 %;          !  EFN to be set
macro FTRD$B_UNUSED = 25,0,8,0 %;       !  Spare byte
macro FTRD$W_READ_SIZE = 26,0,16,0 %;   !  Size of read request in bytes
macro FTRD$L_BUFF_ADDR = 28,0,32,0 %;   !  Address of I/O buffer
macro FTRD$L_CHAR_ADDR = 32,0,32,0 %;   !  Address of next character 
macro FTRD$L_CHARS_READ = 36,0,32,0 %;  !  Number of characters in read buffer
 
!*** MODULE $GABDEF ***
! +
!  Generalized event notification AST control Block
! 
!  The block is used to queue an event notification request to a
!  process.  It contains an ACB which has been extended to include
!  data from the notification request's AST Data Block (ADB) and
!  the Event Declaration block (EDB).
! 
! -
literal GAB$K_LENGTH = 240;             !  Length of block. 
literal GAB$C_LENGTH = 240;             !  Length of block. 
literal GAB$S_GABDEF = 240;
macro GAB$L_ASTQFL = 0,0,32,0 %;        !  AST QUEUE FORWARD LINK 
macro GAB$L_ASTQBL = 4,0,32,0 %;        !  AST QUEUE BACKWARD LINK 
macro GAB$W_SIZE = 8,0,16,0 %;          !  STRUCTURE SIZE IN BYTES 
macro GAB$B_TYPE = 10,0,8,0 %;          !  STRUCTURE TYPE CODE 
macro GAB$B_RMOD = 11,0,8,0 %;          !  REQUEST ACCESS MODE 
macro GAB$L_PID = 12,0,32,0 %;          !  PROCESS ID OF REQUEST 
macro GAB$L_AST = 16,0,32,0 %;          !  AST ROUTINE ADDRESS 
macro GAB$L_ASTPRM = 20,0,32,0 %;       !  AST PARAMETER 
macro GAB$L_KAST = 24,0,32,0 %;         !  INTERNAL KERNEL MODE XFER ADDRESS 
macro GAB$L_UNIQID = 28,0,32,0 %;       !  GENERATED ID
macro GAB$L_ADB = 32,0,32,0 %;          !  ADDRESS OF REQUESTOR'S ADB
! 
!  Start of $GETEVI data.  For efficiency, this must agree with EVIDEF.
! 
macro GAB$L_FLAGS = 36,0,32,0 %;        !  FLAGS
macro GAB$L_CSID = 40,0,32,0 %;         !  CLUSTER SYSTEM ID
macro GAB$L_EPID = 44,0,32,0 %;         !  PROCESS'S EXTENDED PID
macro GAB$B_ACMODE = 48,0,8,0 %;        !  ACCESS MODE
macro GAB$W_EVTFAC = 50,0,16,0 %;       !  FACILITY CODE
macro GAB$W_ULE_COUNT = 52,0,16,0 %;    !  FORK LOST EVENT COUNT
macro GAB$W_FLE_COUNT = 54,0,16,0 %;    !  USER LOST EVENT COUNT
macro GAB$Q_EVENT_TIME = 56,0,0,0 %;
literal GAB$S_EVENT_TIME = 16;          !  EVENT TIME 
macro GAB$T_EVENT_NAME = 72,0,0,0 %;
literal GAB$S_EVENT_NAME = 32;          !  EVENT NAME
macro GAB$T_EVENT_DATA = 104,0,0,0 %;
literal GAB$S_EVENT_DATA = 128;         !  OPTIONAL EVENT DATA
! 
!  End of GETEVI data
! 
macro GAB$L_IDENTIFIER = 232,0,32,0 %;  !  IDENTIFIER OF DECLARING PROCESS
macro GAB$L_ORB = 236,0,32,0 %;         !  POINTER TO EVENT FACILITY ORB
 
!*** MODULE $gddef ***
literal gd$m_dma_cmd = 1;
literal gd$k_cmd_read = 0;
literal gd$k_cmd_write = 1;
literal gd$m_dma_keep_edc = 2;
literal gd$k_edc_noedc = 0;
literal gd$k_edc_ccitt_ones = 1;
literal gd$k_edc_ccitt_zero = 2;
literal gd$k_edc_crc16_ones = 3;
literal gd$k_edc_crc16_zero = 4;
literal gd$k_edc_autodin2 = 5;
literal gd$k_edc_swift16 = 6;
literal gd$m_dma_edc_cont = 32;
literal gd$m_dma_retry_inh = 32768;
literal gd$w_last_opt = -10;
literal gd$S_gditem = 12;
macro gd$w_dma_blen = 0,0,16,1 %;
macro gd$v_dma_cmd = 2,0,1,0 %;
macro gd$v_dma_keep_edc = 2,1,1,0 %;
macro gd$v_dma_edc_code = 2,2,3,0 %;
literal gd$s_dma_edc_code = 3;
macro gd$v_dma_edc_cont = 2,5,1,0 %;
macro gd$v_mbz_1 = 2,6,9,0 %;
literal gd$s_mbz_1 = 9;
macro gd$v_dma_retry_inh = 2,15,1,0 %;
macro gd$v_aggcmd = 2,0,5,0 %;
literal gd$s_aggcmd = 5;
macro gd$w_dma_item_opts = 2,0,16,1 %;
macro gd$a_dma_badr = 4,0,32,0 %;
macro gd$a_dma_ioadr = 8,0,32,0 %;
 
!*** MODULE $GSDDEF ***
! +
!  GLOBAL SECTION DESCRIPTOR BLOCK
! -
literal GSD$M_VALID = 1;
literal GSD$M_LOCKED = 2;
literal GSD$M_DELPEND = 4;
literal GSD$M_INITFAIL = 8;
literal GSD$M_DUPGSD = 16;
literal GSD$K_LENGTH = 39;              ! LENGTH OF LOCAL MEMORY GSD 
literal GSD$C_LENGTH = 39;              ! LENGTH OF LOCAL MEMORY GSD 
literal GSD$K_EXTGSDLNG = 53;           ! MINIMUM EXTENDED GSD LENGTH 
literal GSD$C_EXTGSDLNG = 53;           ! MINIMUM EXTENDED GSD LENGTH 
! 
literal GSD$S_GSDDEF = 53;
macro GSD$L_GSDFL = 0,0,32,0 %;         ! POINTER TO NEXT GSD 
macro GSD$V_VALID = 0,0,1,0 %;          ! SH MEM GSD FLAG, SET IF VALID ENTRY 
macro GSD$V_LOCKED = 0,1,1,0 %;         ! SH MEM GSD FLAG, SET IF ENTRY LOCKED 
macro GSD$V_DELPEND = 0,2,1,0 %;        ! SH MEM GSD FLAG, GS MARKED FOR DELETE 
macro GSD$V_INITFAIL = 0,3,1,0 %;       ! SH MEM GSD FLAG, SET WHEN GS INIT FAILS 
macro GSD$V_DUPGSD = 0,4,1,0 %;         ! SH MEM GSD FLAG, DUPLICATE GSD FOUND 
macro GSD$L_GSDBL = 4,0,32,0 %;         ! POINTER TO PREVIOUS GSD 
macro GSD$W_SIZE = 8,0,16,0 %;          ! SIZE OF GSD IN BYTES 
macro GSD$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE CODE FOR GSD 
macro GSD$B_HASH = 11,0,8,0 %;          ! HASH FOR GSD NAME
macro GSD$L_PCBUIC = 12,0,32,0 %;       ! UIC OF CREATOR OF SECTION, FROM HIS PCB 
macro GSD$W_PCBGRP = 14,0,16,0 %;       ! GROUP OF CREATOR OF SECTION, FROM PCB 
macro GSD$L_FILUIC = 16,0,32,0 %;       ! OWNER OF FILE, UIC FROM FCB 
macro GSD$W_PROT = 20,0,16,0 %;         ! PROTECTION MASK 
macro GSD$W_GSTX = 22,0,16,0 %;         ! GLOBAL SECTION TABLE INDEX 
macro GSD$L_IDENT = 24,0,32,0 %;        ! IDENTIFICATION OF GLOBAL SECTION 
macro GSD$L_ORB = 28,0,32,0 %;          ! OBJECT RIGHTS BLOCK LOCATOR
macro GSD$L_IPID = 32,0,32,0 %;         ! IPID of nominal owner -- only defined while GSD is being deleted 
macro GSD$W_FLAGS = 36,0,16,0 %;        ! SECTION FLAGS 
macro GSD$T_GSDNAM = 38,0,8,0 %;        ! LOCAL MEMORY AND SHARED MEMORY SECTION NAME
! 
!  THE FOLLOWING FIELDS ARE ONLY FOUND IN EXTENDED GSD'S.  THESE ARE USED
!  WHENEVER A GSD IS NEEDED WITHOUT A SECTION TABLE ENTRY, I.E., FOR SHARED
!  MEMORY AND FOR PAGES MAPPED BY PFN.
! 
macro GSD$L_BASEPFN = 40,0,32,0 %;      ! FIRST RELATIVE BASE PFN 
macro GSD$L_PAGES = 44,0,32,0 %;        ! COUNT OF PAGES AT FIRST BASE PFN 
macro GSD$L_REFCNT = 48,0,32,0 %;       ! FIRST PROCESSOR PTE REF COUNT 
macro GSD$T_PFNGSDNAM = 52,0,8,0 %;     ! PFN-MAPPED SECTION NAME
!  THE FOLLOWING FIELDS ARE CONTAINED ONLY IN SHARED MEMORY GSD'S.  THE LENGTH,
!  GSD$C_SHMGSDLNG, IS ONLY THE CONSTANT SIZE OF THE GSD.  IN ADDITION, THERE IS
!  ONE LONGWORD FOR EACH PROCESSOR AND TWO LONGWORDS FOR EACH BASE PFN-SIZE PAIR.
! 
literal GSD$C_PFNBASMAX = 4;            ! MAXIMUM ! OF PFN BASES ALLOWED 
literal GSD$K_SHMGSDLNG = 120;          ! LENGTH OF CONSTANT PART OF SHM GSD 
literal GSD$C_SHMGSDLNG = 120;          ! LENGTH OF CONSTANT PART OF SHM GSD 
literal GSD$S_GSDDEF1 = 124;
macro GSD$B_LOCK = 84,0,8,0 %;          ! INTERPROCESSOR LOCK FOR GSD 
macro GSD$B_PROCCNT = 85,0,8,0 %;       ! NUMBER OF PROCESSOR REF. COUNTS IN GSD 
macro GSD$B_CREATPORT = 86,0,8,0 %;     ! PORT ! FOR CREATOR PROCESSOR 
macro GSD$B_DELETPORT = 87,0,8,0 %;     ! PORT ! FOR DELETOR PROCESSOR 
macro GSD$L_BASPFN1 = 88,0,32,0 %;      ! FIRST BASE PFN FOR SECTION PAGES 
macro GSD$L_BASCNT1 = 92,0,32,0 %;      ! CNT OF SECTION PAGES AT FIRST BASE PFN 
! FIRST PFN/PAGE COUNT PAIR
macro GSD$L_PTECNT1 = 120,0,32,0 %;     ! PTE COUNT FOR FIRST PROCESSOR 
 
!*** MODULE $GXPBDEF ***
! +
!  Define Generic XMI Parameter Block area for passing block data
!  between SYSLOA and SYSGEN modules.
! -
literal GXPB$K_LEN = 20;                !  Length of the GXPB parameter block
literal GXPB$S_GXPBDEF = 20;
macro GXPB$L_SCB_PAGE = 0,0,32,1 %;     !  SCB page offset for this XMI bus
macro GXPB$L_NODE = 4,0,32,1 %;         !  System Node ID of this device
macro GXPB$L_IDR = 8,0,32,1 %;          !  Mask - valid nodes for interrupt dest
macro GXPB$L_NODESP = 12,0,32,1 %;      !  Physical address of nodespace
macro GXPB$L_IOBASE = 16,0,32,1 %;      !  Physical I/O base address
 
!*** MODULE $HD1DEF ***
! +
!  HDR1 ANDSI MAGNETIC TAPE LABEL
!  THIS IS THE FIRST LABEL IN THE FILE LABEL HEADER SET.  IF IDENTIFIES THE FILE.
! -
literal HD1$S_HD1DEF = 80;
macro HD1$L_HD1LID = 0,0,32,0 %;        ! LABEL IDENTIFIER AND NUMBER 'HDR1' 
macro HD1$T_FILEID = 4,0,0,0 %;
literal HD1$S_FILEID = 17;              ! FILE IDENTIFIER 
macro HD1$T_FILESETID = 21,0,0,0 %;
literal HD1$S_FILESETID = 6;            ! FILE SET IDENTIFIER 
macro HD1$T_FILESECNO = 27,0,32,0 %;
literal HD1$S_FILESECNO = 4;            ! FILE SECTION NUMBER 
macro HD1$T_FILESEQNO = 31,0,32,0 %;
literal HD1$S_FILESEQNO = 4;            ! FILE SEQUENCE NUMBER 
macro HD1$T_GENNO = 35,0,32,0 %;
literal HD1$S_GENNO = 4;                ! FILE GENERATION NUMBER 
macro HD1$T_GENVER = 39,0,16,0 %;
literal HD1$S_GENVER = 2;               ! FILE GENERATION VERSION NUMBER 
macro HD1$T_CREATEDT = 41,0,0,0 %;
literal HD1$S_CREATEDT = 6;             ! CREATION DATE ( YYDDD) 
macro HD1$T_EXPIREDT = 47,0,0,0 %;
literal HD1$S_EXPIREDT = 6;             ! EXPIRATION DATE 
macro HD1$B_FILACCESS = 53,0,8,0 %;     ! FILE ACCESS 
macro HD1$T_BLOCKCNT = 54,0,0,0 %;
literal HD1$S_BLOCKCNT = 6;             ! BLOCK COUNT 
macro HD1$T_SYSCODE = 60,0,0,0 %;
literal HD1$S_SYSCODE = 13;             ! SYSTEM CODE 
 
!*** MODULE $HD2DEF ***
! +
!  HDR2 ANSI MAGNETIC TAPE LABEL
!  THIS IS THE SECOND LABEL IN FILE LABEL HEADER SET.
!  THE FILE ATTRIBUTES HAVE BEEN REMOVED FROM HDR2, AND PLACED IN HDR3.
!  THE FIELDS REMAIN IN THE DEFINITION TO SUPPORT OLD TAPES.
! -
literal HD2$S_HD2DEF = 72;
macro HD2$L_HD2LID = 0,0,32,0 %;        ! LABEL IDENTIFIER AND NUMBER 'HDR2' 
macro HD2$B_RECFORMAT = 4,0,8,0 %;      ! RECORD FORMAT 
macro HD2$T_BLOCKLEN = 5,0,0,0 %;
literal HD2$S_BLOCKLEN = 5;             ! BLOCK LENGTH 
macro HD2$T_RECLEN = 10,0,0,0 %;
literal HD2$S_RECLEN = 5;               ! RECORD LENGTH 
macro HD2$T_RECATR1 = 15,0,0,0 %;
literal HD2$S_RECATR1 = 20;             ! FIRST 20 BYTES OF FILES-11 RECORD ATTRIBUTES 
macro HD2$B_FORMCNTRL = 36,0,8,0 %;     ! FORMS CONTROL 
macro HD2$T_RECATR2 = 37,0,0,0 %;
literal HD2$S_RECATR2 = 12;             ! LAST 12 BYTES OF FILES-11 RECORD ATTRIBUTES 
macro HD2$T_BUFOFF = 50,0,16,0 %;
literal HD2$S_BUFOFF = 2;               ! BUFFER OFFSET 
 
!*** MODULE $HD3DEF ***
! +
!  HDR3 ANSI MAGNETIC TAPE LABEL
!  THIS IS THE THIRD LABEL IN FILE LABEL HEADER SET.
!  IT IDENTIFIES THE FILE ATTRIBUTES.
! -
literal HD3$S_HD3DEF = 80;
macro HD3$L_HD3LID = 0,0,32,0 %;        ! LABEL IDENTIFIES AND NUMBER 'HDR3' 
macro HD3$T_RECATR = 4,0,0,0 %;
literal HD3$S_RECATR = 64;              ! 64 BYTES OF FILES-11 RECORD ATTRIBUTES 
 
!*** MODULE $HD4DEF ***
! +
!  HDR4 ANSI MAGNETIC TAPE LABEL
!  THIS IS THE FOURTH LABEL IN FILE LABEL HEADER SET.
!  IT CONTAINS THE LONG FILENAME EXTENSION TO THE HDR1 FILE IDENTIFIER
!  FOR VMS LONG FILE NAMES
! -
literal HD4$S_HD4DEF = 82;
macro HD4$L_HD4LID = 0,0,32,0 %;        ! LABEL IDENTIFIER AND NUMBER 'HDR4' 
macro HD4$B_FILEID_EXT_SIZE = 4,0,8,0 %; ! SIZE OF FILE ID EXT FOR ANSI 4 VOLUMES
macro HD4$T_FILEID_EXT = 5,0,0,0 %;
literal HD4$S_FILEID_EXT = 62;          ! EXTENSION OF HDR1 FILEID
macro HD4$T_FILEID_EXT_V3 = 67,0,16,0 %;
literal HD4$S_FILEID_EXT_V3 = 2;        ! SIZE OF FILE ID EXT FOR ANSI 3 VOLUMES
 
!*** MODULE $HQBDEF ***
! +
!  HQB  (Host Queue Block)  Definitions
! 
! 	This data structure contains information pertaining
! 	to a host that has established a connection to the 
! 	server.
! -
literal HQB$M_VC_FAILED = 1;
literal HQB$M_DISCON_INIT = 2;
literal HQB$M_PATHMOVE = 4;
literal HQB$M_UNIT_ONLINE = 1;
literal HQB$M_V5CL = 2;
literal HQB$S_GENERIC_HQBDEF = 50;
macro HQB$L_FLINK = 0,0,32,0 %;         !  Used to link together all
macro HQB$L_BLINK = 4,0,32,0 %;         !    host HQBs using the server
macro HQB$W_SIZE = 8,0,16,0 %;          !  Structure size in bytes
macro HQB$B_TYPE = 10,0,8,0 %;          !  MSCP type structure
macro HQB$B_SUBTYPE = 11,0,8,0 %;       !   with a HQB subtype 	     (2)
macro HQB$B_HOSTNO = 12,0,8,0 %;        !  Assigned host number
macro HQB$B_STATE = 13,0,8,0 %;         !  State of this host
macro HQB$V_VC_FAILED = 13,0,1,0 %;     !   The VC to this host has failed
macro HQB$V_DISCON_INIT = 13,1,1,0 %;   !   Disconnect being processed
macro HQB$V_PATHMOVE = 13,2,1,0 %;      !   Closing connection for port load balancing
macro HQB$W_CNT_FLGS = 14,0,16,0 %;     !  Host settable controller flags
macro HQB$W_HTIMO = 16,0,16,0 %;        !  Host access timeout interval
macro HQB$W_FLAGS = 18,0,16,0 %;
macro HQB$V_UNIT_ONLINE = 18,0,1,0 %;   !  This host had units online
macro HQB$V_V5CL = 18,1,1,0 %;          !  This is the V5 class driver
!   when the link was broken
macro HQB$Q_TIME = 20,0,0,0 %;
literal HQB$S_TIME = 8;                 !  Time host issued set-ctrl-chr
macro HQB$W_NUM_QUE = 28,0,16,0 %;      !  Requests outstanding
macro HQB$W_MAX_QUE = 30,0,16,0 %;      !  Most requests ever out
macro HQB$L_HRB_FL = 32,0,32,0 %;       !  HRB queue listhead for 
macro HQB$L_HRB_BL = 36,0,32,0 %;       !   this host
macro HQB$L_CDT = 40,0,32,0 %;          !  Connection Desc Table addr
macro HQB$B_SYSTEMID = 44,0,0,0 %;
literal HQB$S_SYSTEMID = 6;             !  SCS system ID of host
!  End of Generic HQB
literal HQB$S_DSRV_OVERLAY = 62;
macro HQB$L_DSRV = 50,0,32,0 %;         !  DSRV address
macro HQB$L_HULB_VECTOR = 54,0,32,0 %;  !  HULB vector address
macro HQB$W_MAX_HULB = 58,0,16,0 %;     !  Size of HULB vector
macro HQB$w_reserved = 60,0,16,0 %;     !  fill out
literal HQB$S_TSRV_OVERLAY = 62;
macro HQB$L_TSRV = 50,0,32,0 %;         !  TSRV address
macro HQB$L_ACK_TIME = 54,0,32,0 %;     !  Time stamp form last remote request
macro HQB$L_ARR_TIME = 58,0,32,0 %;     !  Round trip time from server to host
!  and back again
literal HQB$K_LENGTH = 62;
 
!*** MODULE $HRBDEF ***
! +
!  HRB  (Host Request Block)  Definitions
! 
! 	These definitions describe the format of a data structure
! 	that is used in the MSCP server to represent the context
! 	of a request from one of the served hosts.
! -
literal HRB$M_STATE_INVALID = 32768;
literal HRB$M_ABORT = 1;
literal HRB$M_ABORTWS = 2;
literal HRB$M_DEQUEUED = 4;
literal HRB$M_ENDMSG = 8;
literal HRB$M_MAP = 16;
literal HRB$M_UNBLOCK = 32;
literal HRB$M_VCFAILED = 64;
literal HRB$M_OLDBUF = 128;
literal HRB$M_WBC_IMMED = 256;
literal HRB$M_FIRST = 512;
literal HRB$M_FLUSH = 1024;
literal HRB$K_LENGTH = 132;
!  request state definitions
literal HRB$K_ST_MSG_WAIT = 1;          !  Atn msg buffer/credit wait
literal HRB$K_ST_SEQ_WAIT = 2;          !  Waiting for sequential cmd
literal HRB$K_ST_BUF_WAIT = 3;          !  Waiting for server buffer
literal HRB$K_ST_SNDAT_WAIT = 4;        !  Sending or receiving data
literal HRB$K_ST_DRV_WAIT = 5;          !  Driver queue
literal HRB$K_ST_MAP_WAIT = 6;          !  Mapping a data buffer
literal HRB$K_ST_UNMAP_WAIT = 7;        !  Returning mapping resources
literal HRB$K_ST_SNDMS_WAIT = 8;        !  Sending message
literal HRB$K_ST_MEM_WAIT = 9;          !  Local buffer wait
literal HRB$K_ST_FLUSHED = 10;          !  Flushed from cache
literal HRB$K_ST_CACHED = 11;           !  In local host cache
literal HRB$K_ST_SUC_STALL = 12;        !  Owns FKB, SUC in progress
literal HRB$S_HRBDEF = 132;
macro HRB$L_FLINK = 0,0,32,0 %;         !  Used to link this request
macro HRB$L_BLINK = 4,0,32,0 %;         !   into the HQB data styructure
macro HRB$W_SIZE = 8,0,16,0 %;          !  Data structure size in bytes
macro HRB$B_TYPE = 10,0,8,0 %;          !  This is an MSCP type struct
macro HRB$B_SUBTYPE = 11,0,8,0 %;       !   with a HRB subtype       (3)
macro HRB$L_RESPC = 12,0,32,0 %;        !  PC to resume on restart
macro HRB$L_SAVD_RTN = 16,0,32,0 %;     !  Saved address of caller
macro HRB$W_STATE = 20,0,16,0 %;        !  State of the request
macro HRB$V_STATE_INVALID = 20,15,1,0 %; !  State is current but previous
!   state was (bits 0-15)
macro HRB$W_FLAGS = 22,0,16,0 %;        !  Status flags
macro HRB$V_ABORT = 22,0,1,0 %;         !  Abort
macro HRB$V_ABORTWS = 22,1,1,0 %;       !  Abort with status
macro HRB$V_DEQUEUED = 22,2,1,0 %;      !  Removed from resource queues
macro HRB$V_ENDMSG = 22,3,1,0 %;        !  End message needs to be sent
macro HRB$V_MAP = 22,4,1,0 %;           !  Map resources allocated
macro HRB$V_UNBLOCK = 22,5,1,0 %;       !  Unblock needs to be called
macro HRB$V_VCFAILED = 22,6,1,0 %;      !  The VC for this host failed
macro HRB$V_OLDBUF = 22,7,1,0 %;        !  The buffer allocated for this
macro HRB$V_WBC_IMMED = 22,8,1,0 %;     !  Write-back caching command
macro HRB$V_FIRST = 22,9,1,0 %;         !  First in burst sequence for tapes
macro HRB$V_FLUSH = 22,10,1,0 %;        !  This is a flush type command
!   rqst is out of the old buffer
macro HRB$L_MSGBUF = 24,0,32,0 %;       !  Addr of MSCP request packet
macro HRB$L_IRP_CDRP = 28,0,32,0 %;     !  CDRP for I/O requests
macro HRB$B_LBUFF = 32,0,0,0 %;
literal HRB$S_LBUFF = 12;               !  Local buffer descriptor
macro HRB$L_BUFLEN = 44,0,32,0 %;       !  Length of buffer allocated
macro HRB$L_BUFADR = 48,0,32,0 %;       !  Buffer starting address
macro HRB$L_LBN = 52,0,32,0 %;          !  LBN place holder for xfr
macro HRB$L_OBCNT = 56,0,32,0 %;        !  Original request byte count
macro HRB$L_ABCNT = 60,0,32,0 %;        !  Number of bytes already sent
macro HRB$L_SVAPTE = 64,0,32,0 %;       !  Page table entry for lcl bufr
macro HRB$W_BOFF = 68,0,16,0 %;         !  Offset within page of sob
macro HRB$L_BCNT = 70,0,32,0 %;         !  Temp storage for current xfr
macro HRB$L_WAIT_FL = 76,0,32,0 %;      !  Pointers to link HRB into
macro HRB$L_WAIT_BL = 80,0,32,0 %;      !   wait queues in UQB
macro HRB$L_HQB = 84,0,32,0 %;          !  Host Queue Block address
macro HRB$L_UQB = 88,0,32,0 %;          !  Unit Queue Block address
macro HRB$L_PDT = 92,0,32,0 %;          !  Port Desc Table for requestor
macro HRB$L_CMD_STS = 96,0,32,0 %;      !  Measure of work to be done
macro HRB$L_OBJECT_SKIP = 100,0,32,0 %; !  Objects requested for skipfile
macro HRB$L_CURRENT_SKIP = 104,0,32,0 %; !  Placemarker during REPOS
macro HRB$L_IO_TIME = 108,0,32,0 %;     !  Time for I/O to go from
!   server to tape and back
macro HRB$L_CACHE_FL = 112,0,32,0 %;    !  Cache queue
macro HRB$L_CACHE_BL = 116,0,32,0 %;    ! 
macro HRB$L_MEMW_FL = 120,0,32,0 %;     !  Waiting on more memory
macro HRB$L_MEMW_BL = 124,0,32,0 %;     ! 
macro HRB$L_RECORD = 128,0,32,0 %;      !  Record position on tape
 
!*** MODULE $HULBDEF ***
! +
!  HULB  (Host/Unit Load Block) Definitions
! 
! 	These definitions describe the format of a data structure
! 	that is used in the MSCP server to record traffic and status
! 	information used by server load balancing. Time fields are in
! 	EXE$GL_ABSTIM format.
! -
literal HULB$M_LB_REQ = 1;
literal HULB$M_DELETE = 2;
literal HULB$M_LB_DISABLED = 4;
literal HULB$K_LENGTH = 26;
literal HULB$K_VECLEN = 256;
literal HULB$S_HULBDEF = 26;
macro HULB$L_FLINK = 0,0,32,0 %;        !  Used to link this request
macro HULB$L_BLINK = 4,0,32,0 %;        !   into the DSRV data styructure
macro HULB$W_SIZE = 8,0,16,0 %;         !  Data structure size in bytes
macro HULB$B_TYPE = 10,0,8,0 %;         !  This is an MSCP type struct
macro HULB$B_SUBTYPE = 11,0,8,0 %;      !   with a HULB subtype (4)
macro HULB$W_HOSTNO = 12,0,16,0 %;      !  Assigned host number
macro HULB$W_UNITNO = 14,0,16,0 %;      !  Assigned unit number
macro HULB$W_OPCOUNT = 16,0,16,0 %;     !  Current operation count
macro HULB$W_PREV_OPC = 18,0,16,0 %;    !  Operation count for prev interval
macro HULB$L_TIME = 20,0,32,0 %;        !  Time of last LB request
macro HULB$W_STATUS = 24,0,16,0 %;      !  LB status bits
macro HULB$V_LB_REQ = 24,0,1,0 %;       !  This unit has been asked to LB
macro HULB$V_DELETE = 24,1,1,0 %;       !  This unit is offline and the HULB can be deleted
macro HULB$V_LB_DISABLED = 24,2,1,0 %;  !  This unit is not available for load balancing
 
!*** MODULE $HWRPBDEF ***
literal EXE$K_SECBOOT = 0;              !  Address of secondary boot
literal EXE$K_HWRPB = 268435456;        !  Address of HWRPB = 256Mb
literal EXE$K_PRIMBOOT = 536870912;     !  Address of primary bootstrap
literal EXE$K_NETBOOT = 805306368;      !  Address of network bootstrap
literal EXE$K_DEBUGBOOT = 939524096;    !  Address of debug bootstrap
literal EXE$K_BOOTPT = 1073741824;      !  Fixed addr. of page tbl =1Gb 
literal HWRPB_SYSTYPE$K_ADU = 1;        !  Alpha Demonstation Unit-proto
literal HWRPB_SYSTYPE$K_COBRA = 2;      !  Similar to MicroVAX
literal HWRPB_SYSTYPE$K_LASER = 3;      !  Similar to Calypso
literal HWRPB_SYSTYPE$K_FLAMINGO = 4;   !  Similar to PV2 workstation
literal HWRPB_SYSTYPE$K_MANNEQUIN = 5;  !  Manniquin simulator
literal HWRPB_SYSTYPE$K_MAX_SYSTYPE = 5;
literal HWRPB$M_MPCAP = 1;
literal HWRPB$M_CNSLE = 2;
literal HWRPB$M_PWRFL = 32;
literal HWRPB$C_LENGTH = 312;           !  Length of HWRPB
literal HWRPB$K_LENGTH = 312;           !  Length of HWRPB
literal HWRPB$S_HWRPBDEF = 312;
macro HWRPB$Q_BASE = 0,0,0,0 %;
literal HWRPB$S_BASE = 8;               !  Physical address of HWRPB
macro HWRPB$L_BASE_L = 0,0,32,0 %;
macro HWRPB$L_BASE_H = 4,0,32,1 %;
macro HWRPB$Q_IDENT = 8,0,0,0 %;
literal HWRPB$S_IDENT = 8;              !  Contains ASCIZ "HWRPB"
macro HWRPB$L_IDENT_L = 8,0,32,0 %;
macro HWRPB$L_IDENT_H = 12,0,32,0 %;
macro HWRPB$Q_REVISION = 16,0,0,0 %;
literal HWRPB$S_REVISION = 8;           !  HWRPB revision number
macro HWRPB$L_REVISION_L = 16,0,32,0 %;
macro HWRPB$L_REVISION_H = 20,0,32,0 %;
macro HWRPB$Q_SIZE = 24,0,0,0 %;
literal HWRPB$S_SIZE = 8;               !  HWRPB Size
macro HWRPB$L_SIZE_L = 24,0,32,0 %;
macro HWRPB$L_SIZE_H = 28,0,32,0 %;
macro HWRPB$Q_PRIMARY = 32,0,0,0 %;
literal HWRPB$S_PRIMARY = 8;            !  Primary CPU ID
macro HWRPB$L_PRIMARY_L = 32,0,32,0 %;
macro HWRPB$L_PRIMARY_H = 36,0,32,0 %;
macro HWRPB$Q_PAGESIZE = 40,0,0,0 %;
literal HWRPB$S_PAGESIZE = 8;           !  Page size in bytes
macro HWRPB$L_PAGESIZE_L = 40,0,32,0 %;
macro HWRPB$L_PAGESIZE_H = 44,0,32,0 %;
macro HWRPB$Q_PA_SIZE = 48,0,0,0 %;
literal HWRPB$S_PA_SIZE = 8;            !  Number of Phys. addr. bits
macro HWRPB$L_PA_SIZE_L = 48,0,32,0 %;
macro HWRPB$L_PA_SIZE_H = 52,0,32,0 %;
macro HWRPB$Q_ASN_MAX = 56,0,0,0 %;
literal HWRPB$S_ASN_MAX = 8;            !  Maximum ASN
macro HWRPB$L_ASN_MAX_L = 56,0,32,0 %;
macro HWRPB$L_ASN_MAX_H = 60,0,32,0 %;
! ** Revision info still TBD by the FMA
macro HWRPB$B_SYS_SERIALNUM = 64,0,0,0 %;
literal HWRPB$S_SYS_SERIALNUM = 16;     !  System Serial number
macro HWRPB$Q_SYSTYPE = 80,0,0,0 %;
literal HWRPB$S_SYSTYPE = 8;            !  System type
macro HWRPB$L_SYSTYPE_L = 80,0,32,0 %;
macro HWRPB$L_SYSTYPE_H = 84,0,32,0 %;
macro HWRPB$Q_SYSVAR = 88,0,0,0 %;
literal HWRPB$S_SYSVAR = 8;             !  System variation
macro HWRPB$L_SYSVAR_L = 88,0,32,0 %;
macro HWRPB$V_MPCAP = 88,0,1,0 %;       !  Capable of Multi-Processors
macro HWRPB$V_CNSLE = 88,1,1,0 %;
literal HWRPB$S_CNSLE = 4;              !  Console Type
macro HWRPB$V_PWRFL = 88,5,1,0 %;
literal HWRPB$S_PWRFL = 3;              !  Powerfail Type
macro HWRPB$L_SYSVAR_H = 92,0,32,0 %;
macro HWRPB$Q_SYSREV = 96,0,0,0 %;
literal HWRPB$S_SYSREV = 8;             !  System revision
macro HWRPB$L_SYSREV_L = 96,0,32,0 %;
macro HWRPB$L_SYSREV_H = 100,0,32,0 %;
macro HWRPB$Q_CLOCK_INT_FREQ = 104,0,0,0 %;
literal HWRPB$S_CLOCK_INT_FREQ = 8;     !  Clock interrupt frequency
macro HWRPB$L_CLOCK_INT_FREQ_L = 104,0,32,0 %;
macro HWRPB$L_CLOCK_INT_FREQ_H = 108,0,32,0 %;
macro HWRPB$Q_CYCLE_COUNT_FREQ = 112,0,0,0 %;
literal HWRPB$S_CYCLE_COUNT_FREQ = 8;   !  Cycle counter frequency
macro HWRPB$L_CYCLE_COUNT_FREQ_L = 112,0,32,0 %;
macro HWRPB$L_CYCLE_COUNT_FREQ_H = 116,0,32,0 %;
macro HWRPB$Q_NPROC = 144,0,0,0 %;
literal HWRPB$S_NPROC = 8;              !  Number of Per-CPU slots
macro HWRPB$L_NPROC_L = 144,0,32,0 %;
macro HWRPB$L_NPROC_H = 148,0,32,0 %;
macro HWRPB$Q_SLOT_SIZE = 152,0,0,0 %;
literal HWRPB$S_SLOT_SIZE = 8;          !  Size of Per-CPU slots
macro HWRPB$L_SLOT_SIZE_L = 152,0,32,0 %;
macro HWRPB$L_SLOT_SIZE_H = 156,0,32,0 %;
macro HWRPB$Q_SLOT_OFFSET = 160,0,0,0 %;
literal HWRPB$S_SLOT_OFFSET = 8;        !  Offset to Per-CPU slots
macro HWRPB$L_SLOT_OFFSET_L = 160,0,32,0 %;
macro HWRPB$L_SLOT_OFFSET_H = 164,0,32,0 %;
macro HWRPB$Q_CTB_QUANTITY = 168,0,0,0 %;
literal HWRPB$S_CTB_QUANTITY = 8;       !  Number of CTB's
macro HWRPB$L_CTB_QUANTITY_L = 168,0,32,0 %;
macro HWRPB$L_CTB_QUANTITY_H = 172,0,32,0 %;
macro HWRPB$Q_CTB_SIZE = 176,0,0,0 %;
literal HWRPB$S_CTB_SIZE = 8;           !  Size of CTB
macro HWRPB$L_CTB_SIZE_L = 176,0,32,0 %;
macro HWRPB$L_CTB_SIZE_H = 180,0,32,0 %;
macro HWRPB$Q_CTB_OFFSET = 184,0,0,0 %;
literal HWRPB$S_CTB_OFFSET = 8;         !  Offset to Console Term. Blk
macro HWRPB$L_CTB_OFFSET_L = 184,0,32,0 %;
macro HWRPB$L_CTB_OFFSET_H = 188,0,32,0 %;
macro HWRPB$Q_CRB_OFFSET = 192,0,0,0 %;
literal HWRPB$S_CRB_OFFSET = 8;         !  Offset to Console routine blk
macro HWRPB$L_CRB_OFFSET_L = 192,0,32,0 %;
macro HWRPB$L_CRB_OFFSET_H = 196,0,32,0 %;
macro HWRPB$Q_MEM_OFFSET = 200,0,0,0 %;
literal HWRPB$S_MEM_OFFSET = 8;         !  Offset to memory descriptor
macro HWRPB$L_MEM_OFFSET_L = 200,0,32,0 %;
macro HWRPB$L_MEM_OFFSET_H = 204,0,32,0 %;
macro HWRPB$Q_CDB_OFFSET = 208,0,0,0 %;
literal HWRPB$S_CDB_OFFSET = 8;         !  Offset to Config Data Block
macro HWRPB$L_CDB_OFFSET_L = 208,0,32,0 %;
macro HWRPB$L_CDB_OFFSET_H = 212,0,32,0 %;
macro HWRPB$Q_FRU_OFFSET = 216,0,0,0 %;
literal HWRPB$S_FRU_OFFSET = 8;         !  Offset to FRU table
macro HWRPB$L_FRU_OFFSET_L = 216,0,32,0 %;
macro HWRPB$L_FRU_OFFSET_H = 220,0,32,0 %;
macro HWRPB$Q_SAVE_TERM = 224,0,0,0 %;
literal HWRPB$S_SAVE_TERM = 8;          !  VA of term save state routine 
macro HWRPB$L_SAVE_TERM_L = 224,0,32,0 %;
macro HWRPB$L_SAVE_TERM_H = 228,0,32,0 %;
macro HWRPB$Q_SAVE_PD = 232,0,0,0 %;
literal HWRPB$S_SAVE_PD = 8;            !  Proc. value of save state rout.
macro HWRPB$L_SAVE_PD_L = 232,0,32,0 %;
macro HWRPB$L_SAVE_PD_H = 236,0,32,0 %;
macro HWRPB$Q_RESTORE_TERM = 240,0,0,0 %;
literal HWRPB$S_RESTORE_TERM = 8;       !  VA of term restore state routine 
macro HWRPB$L_RESTORE_TERM_L = 240,0,32,0 %;
macro HWRPB$L_RESTORE_TERM_H = 244,0,32,0 %;
macro HWRPB$Q_RESTORE_PD = 248,0,0,0 %;
literal HWRPB$S_RESTORE_PD = 8;         !  Proc. value of restore state rout.
macro HWRPB$L_RESTORE_PD_L = 248,0,32,0 %;
macro HWRPB$L_RESTORE_PD_H = 252,0,32,0 %;
macro HWRPB$Q_RESTART = 256,0,0,0 %;
literal HWRPB$S_RESTART = 8;            !  VA of restart routine code
macro HWRPB$L_RESTART_L = 256,0,32,0 %;
macro HWRPB$L_RESTART_H = 260,0,32,0 %;
macro HWRPB$Q_RESTART_PD = 264,0,0,0 %;
literal HWRPB$S_RESTART_PD = 8;         !  Restart Procedure Descriptor
macro HWRPB$L_RESTART_PD_L = 264,0,32,0 %;
macro HWRPB$L_RESTART_PD_H = 268,0,32,0 %;
macro HWRPB$Q_SWRPB = 272,0,0,0 %;
literal HWRPB$S_SWRPB = 8;              !  VA of Software RPB
macro HWRPB$L_SWRPB_L = 272,0,32,0 %;
macro HWRPB$L_SWRPB_H = 276,0,32,1 %;
macro HWRPB$Q_HARDWARE1 = 280,0,0,0 %;
literal HWRPB$S_HARDWARE1 = 8;          !  Resevered for hardware
macro HWRPB$L_HARDWARE1_L = 280,0,32,0 %;
macro HWRPB$L_HARDWARE1_H = 284,0,32,0 %;
macro HWRPB$Q_CHKSUM = 288,0,0,0 %;
literal HWRPB$S_CHKSUM = 8;             !  Checksum of HWRPB
macro HWRPB$L_CHKSUM_L = 288,0,32,0 %;
macro HWRPB$L_CHKSUM_H = 292,0,32,0 %;
macro HWRPB$Q_RXRDY = 296,0,0,0 %;
literal HWRPB$S_RXRDY = 8;              !  Offset to RXRDY bitmask
macro HWRPB$L_RXRDY_L = 296,0,32,0 %;
macro HWRPB$L_RXRDY_H = 300,0,32,0 %;
macro HWRPB$Q_TXRDY = 304,0,0,0 %;
literal HWRPB$S_TXRDY = 8;              !  Offset to TXRDY bitmask
macro HWRPB$L_TXRDY_L = 304,0,32,0 %;
macro HWRPB$L_TXRDY_H = 308,0,32,0 %;
!  Per-CPU slot definitions
literal SLOT$M_BIP = 1;
literal SLOT$M_RC = 2;
literal SLOT$M_PA = 4;
literal SLOT$M_PP = 8;
literal SLOT$M_OH = 16;
literal SLOT$M_CV = 32;
literal SLOT$M_PV = 64;
literal SLOT$M_PMV = 128;
literal SLOT$M_PL = 256;
literal SLOT$M_HLTREQ = 65536;
literal HWRPB_HALT$K_NO_ACTION = 0;     !  Just Halt
literal HWRPB_HALT$K_SAVE_RESTORE_TERM = 1; !  Save or restore term
literal HWRPB_HALT$K_COLD_REBOOT = 2;   !  Cold bootstrap request
literal HWRPB_HALT$K_WARM_REBOOT = 3;   !  Warm bootstrap request
literal HWRPB_HALT$K_REMAIN_HALTED = 4; !  Don't restart
literal HWRPB_PAL_REV$K_STANDARD = 0;   !  Standard PAL code
literal HWRPB_PAL_REV$K_ULTRIX = 1;     !  ULTRIX varient of PAL code
literal HWRPB_CPU_TYPE$K_EV3 = 1;       !  Reduced functionality EVAX
literal HWRPB_CPU_TYPE$K_EV4 = 2;       !  First fully functional EVAX
literal HWRPB_CPU_TYPE$K_MANNEQUIN = 3; !  Mannequin simulator
literal HWRPB_CPU_TYPE$K_MAX_CPU_TYPE = 3;
literal SLOT$M_VAX_FP = 1;
literal SLOT$M_IEEE_FP = 2;
literal SLOT$M_PE = 4;
literal HWRPB$K_RESTART = 0;            !  Btstrap,procr strt, or pwrfl.
literal HWRPB$K_CRASH_CMD = 1;          !  Crash via cosole request
literal HWRPB$K_HALT_CMD = 2;           !  Halt via console HALT command
literal HWRPB$K_NOT_USED1 = 3;
literal HWRPB$K_ERR_INTSTK = 4;         !  Interrupt stack not valid
literal HWRPB$K_ERR_DOUBLE = 5;         !  Machine check during exception processing
literal HWRPB$K_ERR_HLTINS = 6;         !  Halt instruction in kernel mode
literal HWRPB$K_ERR_ILLVEC = 7;         !  Illegal SCB vector
literal HWRPB$K_ERR_WCSVEC = 8;         !  WCS SCB vector
literal SLOT$K_HWRPB$K_ERR_CHMFI = 10;  !  CHMx on interrupt stack
literal HWRPB$K_ERR_IE0 = 16;           !  ACV/TNV during machine check processing
literal HWRPB$K_ERR_IE1 = 17;           !  ACV/TNV during kernel-stack-not-valid processing
literal HWRPB$K_ERR_IE2 = 18;           !  Machine check during machine check processing
literal HWRPB$K_ERR_IE3 = 19;           !  Machine check during kernel-stack-not-valid processing
literal HWRPB$K_ERR_IE_PSL_26_24_101 = 25; !  PSL<26:24> = 101 during interrupt or exception
literal HWRPB$K_ERR_IE_PSL_26_24_110 = 26; !  PSL<26:24> = 110 during interrupt or exception
literal HWRPB$K_ERR_IE_PSL_26_24_111 = 27; !  PSL<26:24> = 111 during interrupt or exception
literal HWRPB$K_NOT_USED2 = 28;
literal HWRPB$K_ERR_REI_PSL_26_24_101 = 29; !  PSL<26:24> = 101 during REI
literal HWRPB$K_ERR_REI_PSL_26_24_110 = 30; !  PSL<26:24> = 110 during REI
literal HWRPB$K_ERR_REI_PSL_26_24_111 = 31; !  PSL<26:24> = 111 during REI
literal HWRPB$K_ERR_SELFTEST_FAILED = 63; !  Microcoded powerup selftest failed
literal SLOT$C_LENGTH = 512;
literal SLOT$K_LENGTH = 512;
literal SLOT$S_SLOTDEF = 512;
macro SLOT$IQ_HWPCB = 0,0,0,0 %;
literal SLOT$S_HWPCB = 128;             !  Restart/Boot HWPCB
macro SLOT$Q_STATE = 128,0,0,0 %;
literal SLOT$S_STATE = 8;               !  Per-CPU state bits
macro SLOT$L_STATE = 128,0,32,0 %;
macro SLOT$V_BIP = 128,0,1,0 %;         !  Bootstrap in progress
macro SLOT$V_RC = 128,1,1,0 %;          !  Restart capable
macro SLOT$V_PA = 128,2,1,0 %;          !  Processor available
macro SLOT$V_PP = 128,3,1,0 %;          !  Processor present
macro SLOT$V_OH = 128,4,1,0 %;          !  Operator halted
macro SLOT$V_CV = 128,5,1,0 %;          !  Context valid
macro SLOT$V_PV = 128,6,1,0 %;          !  PAL code valid
macro SLOT$V_PMV = 128,7,1,0 %;         !  PAL code memory valid
macro SLOT$V_PL = 128,8,1,0 %;          !  PAL code loaded
macro SLOT$V_HLTREQ = 128,16,1,0 %;
literal SLOT$S_HLTREQ = 8;
macro SLOT$L_STATE_H = 132,0,32,0 %;
macro SLOT$Q_PAL_MEM_LEN = 136,0,0,0 %;
literal SLOT$S_PAL_MEM_LEN = 8;         !  PAL code length
macro SLOT$L_PAL_MEM_LEN_L = 136,0,32,0 %;
macro SLOT$L_PAL_MEM_LEN_H = 140,0,32,0 %;
macro SLOT$Q_PAL_SCR_LEN = 144,0,0,0 %;
literal SLOT$S_PAL_SCR_LEN = 8;         !  PAL scratch memory length
macro SLOT$L_PAL_SCR_LEN_L = 144,0,32,0 %;
macro SLOT$L_PAL_SCR_LEN_H = 148,0,32,0 %;
macro SLOT$Q_PAL_MEM_PA = 152,0,0,0 %;
literal SLOT$S_PAL_MEM_PA = 8;          !  Phy addr of PAL code
macro SLOT$L_PAL_MEM_PA_L = 152,0,32,0 %;
macro SLOT$L_PAL_MEM_PA_H = 156,0,32,0 %;
macro SLOT$Q_PAL_SCR_ADR = 160,0,0,0 %;
literal SLOT$S_PAL_SCR_ADR = 8;         !  Phys addr of PAL scratch mem
macro SLOT$L_PAL_SCR_ADR_L = 160,0,32,0 %;
macro SLOT$L_PAL_SCR_ADR_H = 164,0,32,0 %;
macro SLOT$Q_PAL_REV = 168,0,0,0 %;
literal SLOT$S_PAL_REV = 8;             !  Revision of PAL code required
macro SLOT$L_PAL_REV_L = 168,0,32,0 %;
macro SLOT$B_REV_LETTER = 168,0,8,0 %;  !  Revision letter 'A' - 'Z'
macro SLOT$B_PAL_VAR = 169,0,8,0 %;     !  PAL code variation
macro SLOT$L_PAL_REV_H = 168,0,32,0 %;
macro SLOT$B_MAX_SHARE = 168,0,8,0 %;   !  Max number CPUs to share PAL
macro SLOT$Q_CPU_TYPE = 176,0,0,0 %;
literal SLOT$S_CPU_TYPE = 8;            !  Processor type
macro SLOT$L_CPU_TYPE_L = 176,0,32,0 %;
macro SLOT$L_CPU_TYPE_H = 180,0,32,0 %;
macro SLOT$Q_CPU_VAR = 184,0,0,0 %;
literal SLOT$S_CPU_VAR = 8;             !  Processor variation
macro SLOT$L_CPU_VAR_L = 184,0,32,0 %;
macro SLOT$V_VAX_FP = 184,0,1,0 %;      !  VAX  floating point
macro SLOT$V_IEEE_FP = 184,1,1,0 %;     !  IEEE floating point
macro SLOT$V_PE = 184,2,1,0 %;          !  Processor Eligibility
macro SLOT$L_CPU_VAR_H = 188,0,32,0 %;
macro SLOT$Q_CPU_REV = 192,0,0,0 %;
literal SLOT$S_CPU_REV = 8;             !  Processor revision
macro SLOT$L_CPU_REV_L = 192,0,32,0 %;
macro SLOT$L_CPU_REV_H = 196,0,32,0 %;
macro SLOT$B_CPU_SERIALNUM = 200,0,0,0 %;
literal SLOT$S_CPU_SERIALNUM = 16;      !  CPU Serial number
macro SLOT$Q_LOGOUT_PA = 216,0,0,0 %;
literal SLOT$S_LOGOUT_PA = 8;           !  Physical Addr of logout area
macro SLOT$L_LOGOUT_PA_L = 216,0,32,0 %;
macro SLOT$L_LOGOUT_PA_H = 220,0,32,0 %;
macro SLOT$Q_LOGOUT_LEN = 224,0,0,0 %;
literal SLOT$S_LOGOUT_LEN = 8;          !  Size of logout area
macro SLOT$L_LOGOUT_LEN_L = 224,0,32,0 %;
macro SLOT$L_LOGOUT_LEN_H = 228,0,32,0 %;
macro SLOT$Q_HALT_PCBB = 232,0,0,0 %;
literal SLOT$S_HALT_PCBB = 8;           !  Halt PCBB
macro SLOT$L_HALT_PCBB_L = 232,0,32,0 %;
macro SLOT$L_HALT_PCBB_H = 236,0,32,0 %;
macro SLOT$Q_HALT_PC = 240,0,0,0 %;
literal SLOT$S_HALT_PC = 8;             !  Halt PC
macro SLOT$L_HALT_PC_L = 240,0,32,0 %;
macro SLOT$L_HALT_PC_H = 244,0,32,0 %;
macro SLOT$Q_HALT_PS = 248,0,0,0 %;
literal SLOT$S_HALT_PS = 8;             !  Halt PS
macro SLOT$L_HALT_PS_L = 248,0,32,0 %;
macro SLOT$L_HALT_PS_H = 252,0,32,0 %;
macro SLOT$Q_HALT_ARG = 256,0,0,0 %;
literal SLOT$S_HALT_ARG = 8;            !  Halt Argument List
macro SLOT$L_HALT_ARG_L = 256,0,32,0 %;
macro SLOT$L_HALT_ARG_H = 260,0,32,0 %;
macro SLOT$Q_HALT_RET = 264,0,0,0 %;
literal SLOT$S_HALT_RET = 8;            !  Halt Return Address
macro SLOT$L_HALT_RET_L = 264,0,32,0 %;
macro SLOT$L_HALT_RET_H = 268,0,32,0 %;
macro SLOT$Q_HALT_PV = 272,0,0,0 %;
literal SLOT$S_HALT_PV = 8;             !  Halt PV
macro SLOT$L_HALT_PV_L = 272,0,32,0 %;
macro SLOT$L_HALT_PV_H = 276,0,32,0 %;
macro SLOT$Q_HALTCODE = 280,0,0,0 %;
literal SLOT$S_HALTCODE = 8;            !  Halt code
macro SLOT$L_HALTCODE_L = 280,0,32,0 %;
macro SLOT$L_HALTCODE_H = 284,0,32,0 %;
macro SLOT$Q_SOFT_FLAGS = 288,0,0,0 %;
literal SLOT$S_SOFT_FLAGS = 8;          !  Reserved to software
macro SLOT$L_SOFT_FLAGS_L = 288,0,32,0 %;
macro SLOT$L_SOFT_FLAGS_H = 292,0,32,0 %;
macro SLOT$B_INCON_BUF_AREA = 296,0,0,0 %;
literal SLOT$S_INCON_BUF_AREA = 168;    !  SMP Console Buf Area
macro SLOT$L_RXLEN = 296,0,32,0 %;
macro SLOT$L_TXLEN = 300,0,32,0 %;
macro SLOT$B_RXBUFFER = 304,0,0,0 %;
literal SLOT$S_RXBUFFER = 80;
macro SLOT$B_TXBUFFER = 384,0,0,0 %;
literal SLOT$S_TXBUFFER = 80;
!  The remaining area is reserved to the inter-console communication area
!  buffer, whose format is still TBD.
!  Length of SLOT$ is defined to be rounded to nearest 128 bytes
!  HWPCB structure in Per-CPU slot definitions - zero relative
literal HWPCB$M_ASTEN = 15;
literal HWPCB$M_ASTSR = 240;
literal HWPCB$M_ASTEN_KEN = 1;
literal HWPCB$M_ASTEN_EEN = 2;
literal HWPCB$M_ASTEN_SEN = 4;
literal HWPCB$M_ASTEN_UEN = 8;
literal HWPCB$M_ASTSR_KPD = 16;
literal HWPCB$M_ASTSR_EPD = 32;
literal HWPCB$M_ASTSR_SPD = 64;
literal HWPCB$M_ASTSR_UPD = 128;
literal HWPCB$M_FEN = 1;
literal HWPCB$C_LENGTH = 128;           !  Length of HWPCB$
literal HWPCB$K_LENGTH = 128;           !  Length of HWPCB$
literal HWPCB$S_HWPCBDEF = 128;
macro HWPCB$Q_HWPCB = 0,0,0,0 %;
literal HWPCB$S_HWPCB = 8;              !  Base of HWPCB
macro HWPCB$Q_KSP = 0,0,0,0 %;
literal HWPCB$S_KSP = 8;                !  Kernel stack pointer
macro HWPCB$L_KSP_L = 0,0,32,0 %;
macro HWPCB$L_KSP_H = 4,0,32,0 %;
macro HWPCB$Q_ESP = 8,0,0,0 %;
literal HWPCB$S_ESP = 8;                !  Executive stack pointer
macro HWPCB$L_ESP_L = 8,0,32,0 %;
macro HWPCB$L_ESP_H = 12,0,32,0 %;
macro HWPCB$Q_SSP = 16,0,0,0 %;
literal HWPCB$S_SSP = 8;                !  Supervisor stack pointer
macro HWPCB$L_SSP_L = 16,0,32,0 %;
macro HWPCB$L_SSP_H = 20,0,32,0 %;
macro HWPCB$Q_USP = 24,0,0,0 %;
literal HWPCB$S_USP = 8;                !  User stack pointer
macro HWPCB$L_USP_L = 24,0,32,0 %;
macro HWPCB$L_USP_H = 28,0,32,0 %;
macro HWPCB$Q_PTBR = 32,0,0,0 %;
literal HWPCB$S_PTBR = 8;               !  Page Table Base Register
macro HWPCB$L_PTBR_L = 32,0,32,0 %;
macro HWPCB$L_PTBR_H = 36,0,32,0 %;
macro HWPCB$Q_ASN = 40,0,0,0 %;
literal HWPCB$S_ASN = 8;                !  Address space number
macro HWPCB$L_ASN_L = 40,0,32,0 %;
macro HWPCB$L_ASN_H = 44,0,32,0 %;
macro HWPCB$Q_ASTSR_ASTEN = 48,0,0,0 %;
literal HWPCB$S_ASTSR_ASTEN = 8;        !  ASTSR / ASTEN quadword
macro HWPCB$L_AST_L = 48,0,32,0 %;
macro HWPCB$L_AST_H = 52,0,32,0 %;
macro HWPCB$V_ASTEN = 48,0,4,0 %;
literal HWPCB$S_ASTEN = 4;              !  AST Enable Register
macro HWPCB$V_ASTSR = 48,4,4,0 %;
literal HWPCB$S_ASTSR = 4;              !  AST Pending Summary Register
macro HWPCB$V_ASTEN_KEN = 48,0,1,0 %;   !  Kernel AST Enable = 1
macro HWPCB$V_ASTEN_EEN = 48,1,1,0 %;   !  Executive AST Enable = 1
macro HWPCB$V_ASTEN_SEN = 48,2,1,0 %;   !  Supervisor AST Enable = 1
macro HWPCB$V_ASTEN_UEN = 48,3,1,0 %;   !  User AST Enable = 1
macro HWPCB$V_ASTSR_KPD = 48,4,1,0 %;   !  Kernel AST Pending = 1
macro HWPCB$V_ASTSR_EPD = 48,5,1,0 %;   !  Executive AST Pending = 1
macro HWPCB$V_ASTSR_SPD = 48,6,1,0 %;   !  Supervisor AST Pending = 1
macro HWPCB$V_ASTSR_UPD = 48,7,1,0 %;   !  User AST Pending = 1
macro HWPCB$Q_FEN = 56,0,0,0 %;
literal HWPCB$S_FEN = 8;                !  Floating Point Enable
macro HWPCB$L_FEN_L = 56,0,32,0 %;
macro HWPCB$L_FEN_H = 60,0,32,0 %;
macro HWPCB$V_FEN = 56,0,1,0 %;         !  Floating Point Enable = 1
macro HWPCB$Q_CC = 64,0,0,0 %;
literal HWPCB$S_CC = 8;                 !  Cycle Counter
macro HWPCB$L_CC_L = 64,0,32,0 %;
macro HWPCB$L_CC_H = 68,0,32,0 %;
macro HWPCB$Q_UNQ = 72,0,0,0 %;
literal HWPCB$S_UNQ = 8;                !  Process Unique Value
macro HWPCB$L_UNQ_L = 72,0,32,0 %;
macro HWPCB$L_UNQ_H = 76,0,32,0 %;
macro HWPCB$Q_PT_VA = 80,0,0,0 %;
literal HWPCB$S_PT_VA = 8;              !  Page Table VA
macro HWPCB$L_PT_VA_L = 80,0,32,0 %;
macro HWPCB$L_PT_VA_H = 84,0,32,0 %;
macro HWPCB$IQ_PAL_RSVD = 88,0,0,0 %;
literal HWPCB$S_PAL_RSVD = 40;          !  Reserved for PAL scratch
macro HWPCB$L_PAL_RSVD_L = 88,0,32,0 %;
macro HWPCB$L_PAL_RSVD_H = 92,0,32,0 %;
!  Physical memory descriptor
literal HWRPB_PMD$C_LENGTH = 24;        !  Length of HWRPB_PMD$
literal HWRPB_PMD$K_LENGTH = 24;        !  Length of HWRPB_PMD$
!  For system with PHYSICALLY DIS-CONTIGUOUS memory, PMR points to 
literal HWRPB_PMD$S_PMDDEF = 136;
macro HWRPB_PMD$Q_CHKSUM = 0,0,0,0 %;
literal HWRPB_PMD$S_CHKSUM = 8;         !  Checksum of PMD+8 to PMD+end
macro HWRPB_PMD$L_CHKSUM_L = 0,0,32,0 %;
macro HWRPB_PMD$L_CHKSUM_H = 4,0,32,0 %;
macro HWRPB_PMD$Q_OPT_DATA = 8,0,0,0 %;
literal HWRPB_PMD$S_OPT_DATA = 8;       !  Optional data
macro HWRPB_PMD$L_OPT_DATA_L = 8,0,32,0 %;
macro HWRPB_PMD$L_OPT_DATA_H = 12,0,32,0 %;
macro HWRPB_PMD$Q_CLUSTER_COUNT = 16,0,0,0 %;
literal HWRPB_PMD$S_CLUSTER_COUNT = 8;  !  Count of clusters present
macro HWRPB_PMD$L_CLUSTER_COUNT_L = 16,0,32,0 %;
macro HWRPB_PMD$L_CLUSTER_COUNT_H = 20,0,32,0 %;
!  an array of Physical Memory Regions (PMR). 
macro HWRPB_PMD$Q_PMR = 24,0,0,0 %;
literal HWRPB_PMD$S_PMR = 8;            !  Start of first region
macro HWRPB_PMD$L_PMR_L = 24,0,32,0 %;
macro HWRPB_PMD$L_PMR_H = 28,0,32,0 %;
!  For system with PHYSICALLY CONTIGUOUS memory, there are only two regions
!  defined.  The first region describes memory in use by the console, and the
!  second region describes memory for use by the system.
macro HWRPB_PMD$Q_CN_PFN_START = 24,0,0,0 %;
literal HWRPB_PMD$S_CN_PFN_START = 8;   !  Start PFN of console region
macro HWRPB_PMD$L_CN_PFN_START_L = 24,0,32,0 %;
macro HWRPB_PMD$L_CN_PFN_START_H = 28,0,32,0 %;
macro HWRPB_PMD$Q_CN_PFN_COUNT = 32,0,0,0 %;
literal HWRPB_PMD$S_CN_PFN_COUNT = 8;   !  Number of PFNs in region
macro HWRPB_PMD$L_CN_PFN_COUNT_L = 32,0,32,0 %;
macro HWRPB_PMD$L_CN_PFN_COUNT_H = 36,0,32,0 %;
macro HWRPB_PMD$Q_CN_TEST_COUNT = 40,0,0,0 %;
literal HWRPB_PMD$S_CN_TEST_COUNT = 8;  !  Num. of tested PFNs in region
macro HWRPB_PMD$L_CN_TEST_COUNT_L = 40,0,32,0 %;
macro HWRPB_PMD$L_CN_TEST_COUNT_H = 44,0,32,0 %;
macro HWRPB_PMD$Q_CN_BITMAP_VA = 48,0,0,0 %;
literal HWRPB_PMD$S_CN_BITMAP_VA = 8;   !  VA of bitmap
macro HWRPB_PMD$L_CN_BITMAP_VA_L = 48,0,32,0 %;
macro HWRPB_PMD$L_CN_BITMAP_VA_H = 52,0,32,0 %;
macro HWRPB_PMD$Q_CN_BITMAP_PA = 56,0,0,0 %;
literal HWRPB_PMD$S_CN_BITMAP_PA = 8;   !  PA of bitmap
macro HWRPB_PMD$L_CN_BITMAP_PA_L = 56,0,32,0 %;
macro HWRPB_PMD$L_CN_BITMAP_PA_H = 60,0,32,0 %;
macro HWRPB_PMD$Q_CN_BITMAP_CHKSUM = 64,0,0,0 %;
literal HWRPB_PMD$S_CN_BITMAP_CHKSUM = 8; !  Checksum of bitmap
macro HWRPB_PMD$L_CN_BITMAP_CHKSUM_L = 64,0,32,0 %;
macro HWRPB_PMD$L_CN_BITMAP_CHKSUM_H = 68,0,32,0 %;
macro HWRPB_PMD$Q_CN_USAGE = 72,0,0,0 %;
literal HWRPB_PMD$S_CN_USAGE = 8;       !  Cluster usage flags
macro HWRPB_PMD$L_CN_USAGE_L = 72,0,32,0 %;
macro HWRPB_PMD$L_CN_USAGE_H = 76,0,32,0 %;
macro HWRPB_PMD$Q_SY_PFN_START = 80,0,0,0 %;
literal HWRPB_PMD$S_SY_PFN_START = 8;   !  Start PFN of system region
macro HWRPB_PMD$L_SY_PFN_START_L = 80,0,32,0 %;
macro HWRPB_PMD$L_SY_PFN_START_H = 84,0,32,0 %;
macro HWRPB_PMD$Q_SY_PFN_COUNT = 88,0,0,0 %;
literal HWRPB_PMD$S_SY_PFN_COUNT = 8;   !  Number of PFNs in region
macro HWRPB_PMD$L_SY_PFN_COUNT_L = 88,0,32,0 %;
macro HWRPB_PMD$L_SY_PFN_COUNT_H = 92,0,32,0 %;
macro HWRPB_PMD$Q_SY_TEST_COUNT = 96,0,0,0 %;
literal HWRPB_PMD$S_SY_TEST_COUNT = 8;  !  Num. of tested PFNs in region
macro HWRPB_PMD$L_SY_TEST_COUNT_L = 96,0,32,0 %;
macro HWRPB_PMD$L_SY_TEST_COUNT_H = 100,0,32,0 %;
macro HWRPB_PMD$Q_SY_BITMAP_VA = 104,0,0,0 %;
literal HWRPB_PMD$S_SY_BITMAP_VA = 8;   !  VA of bitmap
macro HWRPB_PMD$L_SY_BITMAP_VA_L = 104,0,32,0 %;
macro HWRPB_PMD$L_SY_BITMAP_VA_H = 108,0,32,0 %;
macro HWRPB_PMD$Q_SY_BITMAP_PA = 112,0,0,0 %;
literal HWRPB_PMD$S_SY_BITMAP_PA = 8;   !  PA of bitmap
macro HWRPB_PMD$L_SY_BITMAP_PA_L = 112,0,32,0 %;
macro HWRPB_PMD$L_SY_BITMAP_PA_H = 116,0,32,0 %;
macro HWRPB_PMD$Q_SY_BITMAP_CHKSUM = 120,0,0,0 %;
literal HWRPB_PMD$S_SY_BITMAP_CHKSUM = 8; !  Checksum of bitmap
macro HWRPB_PMD$L_SY_BITMAP_CHKSUM_L = 120,0,32,0 %;
macro HWRPB_PMD$L_SY_BITMAP_CHKSUM_H = 124,0,32,0 %;
macro HWRPB_PMD$Q_SY_USAGE = 128,0,0,0 %;
literal HWRPB_PMD$S_SY_USAGE = 8;       !  Cluster usage flags
macro HWRPB_PMD$L_SY_USAGE_L = 128,0,32,0 %;
macro HWRPB_PMD$L_SY_USAGE_H = 132,0,32,0 %;
!  Physical memory region descriptor
literal HWRPB_PMR$M_CONSOLE = 1;
literal HWRPB_PMR$C_LENGTH = 56;        !  Size of region entry
literal HWRPB_PMR$K_LENGTH = 56;        !  Size of region entry
literal HWRPB_PMR$S_PMREGDEF = 56;
macro HWRPB_PMR$Q_PFN_START = 0,0,0,0 %;
literal HWRPB_PMR$S_PFN_START = 8;      !  Starting PFN in region
macro HWRPB_PMR$L_PFN_START_L = 0,0,32,0 %;
macro HWRPB_PMR$L_PFN_START_H = 4,0,32,0 %;
macro HWRPB_PMR$Q_PFN_COUNT = 8,0,0,0 %;
literal HWRPB_PMR$S_PFN_COUNT = 8;      !  Number of PFNs in region
macro HWRPB_PMR$L_PFN_COUNT_L = 8,0,32,0 %;
macro HWRPB_PMR$L_PFN_COUNT_H = 12,0,32,0 %;
macro HWRPB_PMR$Q_TEST_COUNT = 16,0,0,0 %;
literal HWRPB_PMR$S_TEST_COUNT = 8;     !  Num. of tested PFNs in region
macro HWRPB_PMR$L_TEST_COUNT_L = 16,0,32,0 %;
macro HWRPB_PMR$L_TEST_COUNT_H = 20,0,32,0 %;
macro HWRPB_PMR$Q_BITMAP_VA = 24,0,0,0 %;
literal HWRPB_PMR$S_BITMAP_VA = 8;      !  VA of bitmap
macro HWRPB_PMR$PL_BITMAP_VA_L = 24,0,32,0 %;
macro HWRPB_PMR$L_BITMAP_VA_H = 28,0,32,0 %;
macro HWRPB_PMR$Q_BITMAP_PA = 32,0,0,0 %;
literal HWRPB_PMR$S_BITMAP_PA = 8;      !  PA of bitmap
macro HWRPB_PMR$PL_BITMAP_PA_L = 32,0,32,0 %;
macro HWRPB_PMR$L_BITMAP_PA_H = 36,0,32,0 %;
macro HWRPB_PMR$Q_BITMAP_CHKSUM = 40,0,0,0 %;
literal HWRPB_PMR$S_BITMAP_CHKSUM = 8;  !  Checksum of bitmap
macro HWRPB_PMR$L_BITMAP_CHKSUM_L = 40,0,32,0 %;
macro HWRPB_PMR$L_BITMAP_CHKSUM_H = 44,0,32,0 %;
macro HWRPB_PMR$Q_USAGE = 48,0,0,0 %;
literal HWRPB_PMR$S_USAGE = 8;          !  Cluster usage flags
macro HWRPB_PMR$L_USAGE_L = 48,0,32,0 %;
macro HWRPB_PMR$V_CONSOLE = 48,0,1,0 %; !  Cluster reserved by console
macro HWRPB_PMR$L_USAGE_H = 52,0,32,0 %;
!  Console languages
literal HWRPB_LANG$k_UNKNOWN = 0;
literal HWRPB_LANG$k_DANISH = 48;
literal HWRPB_LANG$k_GERMAN = 50;
literal HWRPB_LANG$k_SWISS = 52;
literal HWRPB_LANG$k_AMERICAN = 54;
literal HWRPB_LANG$k_BRITISH = 56;
literal HWRPB_LANG$k_SPANISH = 58;
literal HWRPB_LANG$k_FRENCH = 60;
literal HWRPB_LANG$k_CANADIAN = 62;
literal HWRPB_LANG$k_ROMANDE = 64;
literal HWRPB_LANG$k_ITALIAN = 66;
literal HWRPB_LANG$k_NETHERLANDS = 68;
literal HWRPB_LANG$k_NORSK = 70;
literal HWRPB_LANG$k_PORTUGUESE = 72;
literal HWRPB_LANG$k_SUOMI = 74;
literal HWRPB_LANG$k_SWEDISH = 76;
literal HWRPB_LANG$k_VLAAMS = 78;
! 
!  Console Routine Block
! 
literal HWRPB_CRB$C_LENGTH = 48;        !  Length of CRB
literal HWRPB_CRB$K_LENGTH = 48;        !  Length of CRB
literal HWRPB_CRB$S_CRBDEF = 56;
macro HWRPB_CRB$Q_VA_DISPATCH_PD = 0,0,0,0 %;
literal HWRPB_CRB$S_VA_DISPATCH_PD = 8; !  Virt. Addr of Procedure Desc.
macro HWRPB_CRB$L_VA_DISPATCH_PD_L = 0,0,32,0 %;
macro HWRPB_CRB$L_VA_DISPATCH_PD_H = 4,0,32,0 %;
macro HWRPB_CRB$Q_PA_DISPATCH_PD = 8,0,0,0 %;
literal HWRPB_CRB$S_PA_DISPATCH_PD = 8; !  Phy. Addr of Procedure Desc.
macro HWRPB_CRB$L_PA_DISPATCH_PD_L = 8,0,32,0 %;
macro HWRPB_CRB$L_PA_DISPATCH_PD_H = 12,0,32,0 %;
macro HWRPB_CRB$Q_VA_FIXUP_PD = 16,0,0,0 %;
literal HWRPB_CRB$S_VA_FIXUP_PD = 8;    !  Virt. Addr of Procedure Desc.
macro HWRPB_CRB$L_VA_FIXUP_PD_L = 16,0,32,0 %;
macro HWRPB_CRB$L_VA_FIXUP_PD_H = 20,0,32,0 %;
macro HWRPB_CRB$Q_PA_FIXUP_PD = 24,0,0,0 %;
literal HWRPB_CRB$S_PA_FIXUP_PD = 8;    !  Phy. Addr of Procedure Desc.
macro HWRPB_CRB$L_PA_FIXUP_PD_L = 24,0,32,0 %;
macro HWRPB_CRB$L_PA_FIXUP_PD_H = 28,0,32,0 %;
macro HWRPB_CRB$Q_MAP_COUNT = 32,0,0,0 %;
literal HWRPB_CRB$S_MAP_COUNT = 8;      !  Num. of entries in VA/PA map
macro HWRPB_CRB$L_MAP_COUNT_L = 32,0,32,0 %;
macro HWRPB_CRB$L_MAP_COUNT_H = 36,0,32,0 %;
macro HWRPB_CRB$Q_PAGE_COUNT = 40,0,0,0 %;
literal HWRPB_CRB$S_PAGE_COUNT = 8;     !  Num. of pages to be map
macro HWRPB_CRB$L_PAGE_COUNT_L = 40,0,32,0 %;
macro HWRPB_CRB$L_PAGE_COUNT_H = 44,0,32,0 %;
macro HWRPB_CRB$Q_VAPA_MAP = 48,0,0,0 %;
literal HWRPB_CRB$S_VAPA_MAP = 8;       !  Console VA/PA map
macro HWRPB_CRB$L_VAPA_MAP_L = 48,0,32,0 %;
macro HWRPB_CRB$L_VAPA_MAP_H = 52,0,32,0 %;
literal HWRPB_VAPAMAP$C_ENTRY_SIZE = 24; !  Length of CRB entries
literal HWRPB_VAPAMAP$S_VAPAMAPDEF = 24;
macro HWRPB_VAPAMAP$Q_VA = 0,0,0,0 %;
literal HWRPB_VAPAMAP$S_VA = 8;         !  Console VA
macro HWRPB_VAPAMAP$L_VA_L = 0,0,32,0 %;
macro HWRPB_VAPAMAP$L_VA_H = 4,0,32,0 %;
macro HWRPB_VAPAMAP$Q_PA = 8,0,0,0 %;
literal HWRPB_VAPAMAP$S_PA = 8;         !  Console PA
macro HWRPB_VAPAMAP$L_PA_L = 8,0,32,0 %;
macro HWRPB_VAPAMAP$L_PA_H = 12,0,32,0 %;
macro HWRPB_VAPAMAP$Q_PAGE_COUNT = 16,0,0,0 %;
literal HWRPB_VAPAMAP$S_PAGE_COUNT = 8; !  Page count of entry
macro HWRPB_VAPAMAP$L_PAGE_COUNT_L = 16,0,32,0 %;
macro HWRPB_VAPAMAP$L_PAGE_COUNT_H = 20,0,32,0 %;
!  Console terminal routines
literal HWRPB_CRB$K_GETC = 1;           !  Get a character from console
literal HWRPB_CRB$K_PUTS = 2;           !  Put a string to console term
literal HWRPB_CRB$K_RESET_TERM = 3;     !  Reset console terminal
literal HWRPB_CRB$K_SET_TERM_INTR = 4;  !  Set console terminal int.
literal HWRPB_CRB$K_SET_TERM_CTL = 5;   !  Set console terminal controls
literal HWRPB_CRB$K_PROCESS_KEYCODE = 6; !  Process and translate keycode
!  Console Generic IO routines
literal HWRPB_CRB$k_OPEN = 16;          !  Open access to I/O device
literal HWRPB_CRB$k_CLOSE = 17;         !  Close access to I/O device
literal HWRPB_CRB$k_IOCTRL = 18;        !  Perform device-specific op.
literal HWRPB_CRB$k_READ = 19;          !  Perform read operation
literal HWRPB_CRB$k_WRITE = 20;         !  Perform write operation
!  Console Env. Variable Routines 	
literal HWRPB_CRB$k_SET_ENV = 32;       !  Set an environment varible
literal HWRPB_CRB$k_RESET_ENV = 33;     !  Reset an environment variable
literal HWRPB_CRB$k_GET_ENV = 34;       !  Fetch an environment varible
literal HWRPB_CRB$k_SAVE_ENV = 35;      !  Save  an environment varible
!  Required Environment Variables
literal HWRPB_CRB$k_AUTO_ACTION = 1;
literal HWRPB_CRB$k_BOOT_DEV = 2;
literal HWRPB_CRB$k_BOOTCMD_DEV = 3;
literal HWRPB_CRB$k_BOOTED_DEV = 4;
literal HWRPB_CRB$k_BOOT_FILE = 5;
literal HWRPB_CRB$k_BOOTED_FILE = 6;
literal HWRPB_CRB$k_BOOT_OSFLAGS = 7;
literal HWRPB_CRB$k_BOOTED_OSFLAGS = 8;
literal HWRPB_CRB$k_BOOT_RESET = 9;
literal HWRPB_CRB$k_DUMP_DEV = 10;
literal HWRPB_CRB$k_ENABLE_AUDIT = 11;
literal HWRPB_CRB$k_LICENSE = 12;
literal HWRPB_CRB$k_CHAR_SET = 13;
literal HWRPB_CRB$k_LANGUAGE = 14;
literal HWRPB_CRB$k_TTY_DEV = 15;
literal HWRPB_CRB$k_PSWITCH = 48;
! 
!  Console Terminal Block
! 
literal HWRPB_CTBG$K_LENGTH = 216;
literal HWRPB_CTBG$C_LENGTH = 216;
literal HWRPB_CTBT$K_LENGTH = 144;
literal HWRPB_CTBT$C_LENGTH = 144;
literal HWRPB_CTB$K_LENGTH = 216;
literal HWRPB_CTB$C_LENGTH = 216;
literal HWRPB_CTB$S_CTBDEF = 216;
! 
!   CTB - Common Section                                          
! 
macro HWRPB_CTB$Q_TYPE = 0,0,0,0 %;
literal HWRPB_CTB$S_TYPE = 8;           !  Console Type
macro HWRPB_CTB$L_TYPE_L = 0,0,32,0 %;
macro HWRPB_CTB$L_TYPE_H = 4,0,32,0 %;
macro HWRPB_CTB$Q_UNIT = 8,0,0,0 %;
literal HWRPB_CTB$S_UNIT = 8;           !  DZ Unit number for keyboard
macro HWRPB_CTB$L_UNIT_L = 8,0,32,0 %;
macro HWRPB_CTB$L_UNIT_H = 12,0,32,0 %;
macro HWRPB_CTB$Q_DEV_DEP = 24,0,0,0 %;
literal HWRPB_CTB$S_DEV_DEP = 8;        !  Len of dev dependent portion
macro HWRPB_CTB$L_DEV_DEP_L = 24,0,32,0 %;
macro HWRPB_CTB$L_DEV_DEP_H = 28,0,32,0 %;
! 
!   CTB - Device dependent section
! 
!      - Graphics device portion
! 
macro HWRPB_CTB$R_DEV_DEPEND = 32,0,0,0 %;
literal HWRPB_CTB$S_DEV_DEPEND = 184;
macro HWRPB_CTB$Q_CTBGDEF = 32,0,0,0 %;
literal HWRPB_CTBG$S_CTBGDEF = 184;
macro HWRPB_CTBG$Q_ROW = 32,0,0,0 %;
literal HWRPB_CTBG$S_ROW = 8;           !  Current Row
macro HWRPB_CTBG$L_ROW_L = 32,0,32,0 %;
macro HWRPB_CTBG$L_ROW_H = 36,0,32,0 %;
macro HWRPB_CTBG$Q_COLUMN = 40,0,0,0 %;
literal HWRPB_CTBG$S_COLUMN = 8;        !  Current Column
macro HWRPB_CTBG$L_COLUMN_L = 40,0,32,0 %;
macro HWRPB_CTBG$L_COLUMN_H = 44,0,32,0 %;
macro HWRPB_CTBG$Q_MAX_ROW = 48,0,0,0 %;
literal HWRPB_CTBG$S_MAX_ROW = 8;       !  Maximum Row
macro HWRPB_CTBG$L_MAX_ROW_L = 48,0,32,0 %;
macro HWRPB_CTBG$L_MAX_ROW_H = 52,0,32,0 %;
macro HWRPB_CTBG$Q_CHAR_HEIGHT = 56,0,0,0 %;
literal HWRPB_CTBG$S_CHAR_HEIGHT = 8;   !  Character Cell Height
macro HWRPB_CTBG$L_CHAR_HEIGHT_L = 56,0,32,0 %;
macro HWRPB_CTBG$L_CHAR_HEIGHT_H = 60,0,32,0 %;
macro HWRPB_CTBG$Q_CHAR_WIDTH = 64,0,0,0 %;
literal HWRPB_CTBG$S_CHAR_WIDTH = 8;    !  Character Cell Width
macro HWRPB_CTBG$L_CHAR_WIDTH_L = 64,0,32,0 %;
macro HWRPB_CTBG$L_CHAR_WIDTH_H = 68,0,32,0 %;
macro HWRPB_CTBG$Q_DISPLAY_CSR = 72,0,0,0 %;
literal HWRPB_CTBG$S_DISPLAY_CSR = 8;   !  CSR addr. of Display
macro HWRPB_CTBG$L_DISPLAY_CSR_L = 72,0,32,0 %;
macro HWRPB_CTBG$L_DISPLAY_CSR_H = 76,0,32,0 %;
macro HWRPB_CTBG$Q_KEYB_CSR = 80,0,0,0 %;
literal HWRPB_CTBG$S_KEYB_CSR = 8;      !  CSR addr. of keyboard
macro HWRPB_CTBG$L_KEYB_CSR_L = 80,0,32,0 %;
macro HWRPB_CTBG$L_KEYB_CSR_H = 84,0,32,0 %;
macro HWRPB_CTBG$Q_KEYB_VECTOR = 88,0,0,0 %;
literal HWRPB_CTBG$S_KEYB_VECTOR = 8;   !  SCB vec of keyboard int
macro HWRPB_CTBG$L_KEYB_VECTOR_L = 88,0,32,0 %;
macro HWRPB_CTBG$L_KEYB_VECTOR_H = 92,0,32,0 %;
macro HWRPB_CTBG$Q_KEYB_STATE = 96,0,0,0 %;
literal HWRPB_CTBG$S_KEYB_STATE = 8;    !  Keyboard state
macro HWRPB_CTBG$L_KEYB_STATE_L = 96,0,32,0 %;
macro HWRPB_CTBG$L_KEYB_STATE_H = 100,0,32,0 %;
macro HWRPB_CTBG$Q_KEYC_BUFFER = 104,0,0,0 %;
literal HWRPB_CTBG$S_KEYC_BUFFER = 8;   !  IPL/IE of interrupts
macro HWRPB_CTBG$L_KEYC_BUFFER_L = 104,0,32,0 %;
macro HWRPB_CTBG$L_KEYC_BUFFER_H = 108,0,32,0 %;
! 
!      - Terminal device portion
! 
macro HWRPB_CTB$R_CTBTDEF = 32,0,0,0 %;
literal HWRPB_CTBT$S_CTBTDEF = 112;
macro HWRPB_CTBT$Q_CSR_ADDR = 32,0,0,0 %;
literal HWRPB_CTBT$S_CSR_ADDR = 8;      !  CSR address
macro HWRPB_CTBT$L_CSR_ADDR_L = 32,0,32,0 %;
macro HWRPB_CTBT$L_CSR_ADDR_H = 36,0,32,0 %;
macro HWRPB_CTBT$Q_XMIT_VECTOR = 40,0,0,0 %;
literal HWRPB_CTBT$S_XMIT_VECTOR = 8;   !  SCB vec of Xmit interrupts
macro HWRPB_CTBT$L_XMIT_VECTOR_L = 40,0,32,0 %;
macro HWRPB_CTBT$L_XMIT_VECTOR_H = 44,0,32,0 %;
macro HWRPB_CTBT$Q_RCV_VECTOR = 48,0,0,0 %;
literal HWRPB_CTBT$S_RCV_VECTOR = 8;    !  SCB vec of Receive interrupts
macro HWRPB_CTBT$L_RCV_VECTOR_L = 48,0,32,0 %;
macro HWRPB_CTBT$L_RCV_VECTOR_H = 52,0,32,0 %;
macro HWRPB_CTBT$Q_BAUD = 56,0,0,0 %;
literal HWRPB_CTBT$S_BAUD = 8;          !  Terminal Baud Rate in decimal
macro HWRPB_CTBT$L_BAUD_L = 56,0,32,0 %;
macro HWRPB_CTBT$L_BAUD_H = 60,0,32,0 %;
macro HWRPB_CTBT$Q_PUTS_STATUS = 64,0,0,0 %;
literal HWRPB_CTBT$S_PUTS_STATUS = 8;   !  Extended Error status on last PUTS
macro HWRPB_CTBT$L_PUTS_STATUS_L = 64,0,32,0 %;
macro HWRPB_CTBT$L_PUTS_STATUS_H = 68,0,32,0 %;
macro HWRPB_CTBT$Q_GETC_STATUS = 72,0,0,0 %;
literal HWRPB_CTBT$S_GETC_STATUS = 8;   !  Extended Error status on last GETC
macro HWRPB_CTBT$L_GETC_STATUS_L = 72,0,32,0 %;
macro HWRPB_CTBT$L_GETC_STATUS_H = 76,0,32,0 %;
!  Console types
literal HWRPB_CTB$K_NO_CONSOLE = 0;     !  No console is present
literal HWRPB_CTB$K_SERVICE_CPU = 1;    !  Service processor
literal HWRPB_CTB$K_TERMINAL = 2;       !  Dedicated terminal port
literal HWRPB_CTB$K_GRAPHIC = 3;        !  Graphic processor
literal HWRPB_CTB$K_MAXTYPE = 3;
 
!*** MODULE $IAFDEF ***
! +
!  IAF - IMAGE ACTIVATOR FIXUP SECTION
! 
!  THE IMAGE ACTIVATOR FIXUP SECTION IS AN IMAGE SECTION THAT IS CREATED
!  BY THE LINKER AND USED BY THE IMAGE ACTIVATOR TO MODIFY THE IMAGE AS
!  IT IS ACTIVATED.  THIS IS DONE TO MAINTAIN THE POSITION INDEPENDENCE
!  OF EXTERNAL REFERENCES.
! -
literal IAF$K_LENGTH = 64;              !  Length of fixed area 
literal IAF$C_LENGTH = 64;              !  Length of fixed area 
literal IAF$S_IAFDEF = 64;
macro IAF$L_IAFLINK = 0,0,32,0 %;       !  Link for image activator use 
macro IAF$L_FIXUPLNK = 4,0,32,0 %;      !  Link for shareable image fixups 
macro IAF$W_SIZE = 8,0,16,0 %;          !  Size of fixed part of IAF 
macro IAF$W_FLAGS = 10,0,16,0 %;        !  Flags 
macro IAF$V_SHR = 10,0,1,0 %;           !  This is in a shareable image 
macro IAF$L_G_FIXOFF = 12,0,32,0 %;     !  Offset to g^ address data 
macro IAF$L_DOTADROFF = 16,0,32,0 %;    !  Offset to .address fixup data 
macro IAF$L_CHGPRTOFF = 20,0,32,0 %;    !  Offset to isect change prot. data 
macro IAF$L_SHLSTOFF = 24,0,32,0 %;     !  Offset to shareable image list 
macro IAF$L_SHRIMGCNT = 28,0,32,0 %;    !  Number of shareable images in shlst 
macro IAF$L_SHLEXTRA = 32,0,32,0 %;     !  Number of extra shareable images allowed 
macro IAF$L_PERMCTX = 36,0,32,0 %;      !  Permanent sharable image context 
 
!*** MODULE $ICPDEF ***
! +
!  ICP - CHANGE IMAGE SECTION PROTECTION DATA
! 
!  THIS STRUCTURE IS USED IN THE IMAGE FIXUP SECTION BY THE LINKER
!  TO INFORM THE IMAGE ACTIVATOR OF THE IMAGE SECTIONS THAT NEED
!  THEIR PROTECTION CHANGED.
! -
literal ICP$K_LENGTH = 8;               !  size of one section's data 
literal ICP$C_LENGTH = 8;               !  size of one section's data 
literal ICP$S_ICPDEF = 8;
macro ICP$L_BASEVA = 0,0,32,0 %;        !  virtual address of start of section 
macro ICP$W_NPAGES = 4,0,16,0 %;        !  number of pages to change protection on 
macro ICP$W_NEWPRT = 6,0,16,0 %;        !  new protection 
 
!*** MODULE $IDBDEF ***
! +
!  IDB - INTERRUPT DISPATCH BLOCK
! 
!  AN INTERRUPT DISPATCH BLOCK PROVIDES THE INFORMATION NECESSARY FOR A
!  UNIT INDEPENDENT, BUT CONTROLLER SPECIFIC, INTERRUPT DISPATCHER TO
!  DISPATCH INTERRUPTS TO THE PROPER DRIVER TO HANDLE AN INTERRUPT ON
!  A DEVICE UNIT.
! -
literal IDB$M_NO_CSR = 1;
literal IDB$K_LENGTH = 60;              ! LENGTH OF STANDARD IDB 
literal IDB$C_LENGTH = 60;              ! LENGTH OF STANDARD IDB 
literal IDB$S_IDBDEF = 60;
macro IDB$L_CSR = 0,0,32,0 %;           ! CONTROLLER CSR ADDRESS 
macro IDB$L_OWNER = 4,0,32,0 %;         ! OWNER UCB ADDRESS 
macro IDB$W_SIZE = 8,0,16,0 %;          ! SIZE OF IDB IN BYTES 
macro IDB$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE OF IDB 
macro IDB$B_VECTOR = 11,0,8,0 %;        ! CONTROLLER VECTOR OFFSET
macro IDB$W_UNITS = 12,0,16,0 %;        ! NUMBER OF UNITS (SIZE OF UCBLST) 
macro IDB$B_TT_ENABLE = 14,0,8,0 %;     !  DZ32 line enable field
macro IDB$B_COMBO_CSR_OFFSET = 15,0,8,1 %; ! OFFSET TO START OF COMBO DEVICE STYLE CSRS
macro IDB$B_COMBO_VECTOR_OFFSET = 16,0,8,1 %; ! OFFSET TO START OF COMBO STYLE DEVICE VECTORS
macro IDB$B_FLAGS = 17,0,8,0 %;         !  IDB flags
macro IDB$V_NO_CSR = 17,0,1,0 %;        !  Set if CSR test fails. CSR for UNIBUS/QBUS is non-existent
macro IDB$W_SPARE1 = 18,0,16,1 %;       ! A SPARE WORD
macro IDB$L_SPL = 20,0,32,0 %;          ! ADDRESS OF DEVICE SPINLOCK
macro IDB$L_ADP = 24,0,32,0 %;          ! ADDRESS OF UBA ADAPTER CONTROL BLOCK 
macro IDB$L_UCBLST = 28,0,0,0 %;
literal IDB$S_UCBLST = 32;              ! UCB OR SECONDARY IDB ADDRESSES 
! (DEFAULT OF 8)
 
!*** MODULE $IFDDEF ***
! +
!  IMAGE FILE DESCRIPTOR BLOCK - RETURNED BY IMAGE ACTIVATOR
! -
literal IFD$M_EXEONLY = 1;
literal IFD$M_PRIV = 2;
literal IFD$M_SETVECTOR = 4;
literal IFD$K_LENGTH = 28;              ! LENGTH OF FIXED AREA OF IFD 
literal IFD$C_LENGTH = 28;              ! LENGTH OF FIXED AREA OF IFD 
literal IFD$S_IFDDEF = 28;
macro IFD$W_SIZE = 0,0,16,0 %;          ! SIZE IN BYTES OF IMAGE FILE DESCRIPTOR 
macro IFD$W_FILNAMOFF = 2,0,16,0 %;     ! OFFSET TO RESULTANT FILE NAME STRING 
macro IFD$W_CHAN = 8,0,16,0 %;          ! CHANNEL ON WHICH IMAGE FILE IS OPEN 
macro IFD$W_CMCHAN = 10,0,16,0 %;       ! COMPATIBILITY MODE CHANNEL 
macro IFD$L_CMKFIADR = 12,0,32,0 %;     ! COMPATIBILITY MODE IMAGE 
! KNOWN FILE ENTRY ADDRESS OR 0
macro IFD$W_FLAGS = 16,0,16,0 %;        ! IMAGE FILE DESCRIPTOR FLAGS 
macro IFD$V_EXEONLY = 16,0,1,0 %;       ! EXECUTE ONLY FILE 
macro IFD$V_PRIV = 16,1,1,0 %;          ! IMAGE INSTALLED WITH ENHANCED PRIVILEGE 
macro IFD$V_SETVECTOR = 16,2,1,0 %;     ! PRIVILEGED VECTORS TO BE INSTALLED 
macro IFD$Q_CURPROG = 20,0,0,0 %;
literal IFD$S_CURPROG = 8;              ! STRING DESCRIPTOR FOR CURRENTLY 
! RUNNING PROGRAM NAME
 
!*** MODULE $IHDDEF ***
! +
!  IMAGE HEADER RECORD DEFINITIONS - FIRST RECORD OF IMAGE HEADER
! -
literal IHD$K_MAJORID = 12848;          !  Major id value 
literal IHD$K_MINORID = 13616;          !  Minor id value 
literal IHD$K_EXE = 1;                  !  Executable image 
literal IHD$K_LIM = 2;                  !  Linkable image 
literal IHD$M_LNKDEBUG = 1;
literal IHD$M_LNKNOTFR = 2;
literal IHD$M_NOP0BUFS = 4;
literal IHD$M_PICIMG = 8;
literal IHD$M_P0IMAGE = 16;
literal IHD$M_DBGDMT = 32;
literal IHD$M_INISHR = 64;
literal IHD$M_IHSLONG = 128;
literal IHD$M_MATCHCTL = 117440512;
literal IHD$K_LENGTH = 48;              !  Length of fixed area 
literal IHD$C_LENGTH = 48;              !  Length of fixed area 
literal IHD$C_MINCODE = -1;             !  Low bound of ALIAS values
literal IHD$C_NATIVE = -1;              !  Native mode image
literal IHD$C_RSX = 0;                  !  RSX image produced by TKB
literal IHD$C_BPA = 1;                  !  BASIC plus analog
literal IHD$C_ALIAS = 2;                !  Last 126 bytes contains ASCIC of image to activate
literal IHD$C_CLI = 3;                  !  Image is a CLI, run LOGINOUT
literal IHD$C_PMAX = 4;                 !  PMAX system image
literal IHD$C_MAXCODE = 4;              !  High bound of ALIAS values
! 
literal IHD$C_GEN_XLNKR = 1;            !  Cross linker
literal IHD$C_GEN_NATIVE = 2;           !  First native mode image header.
!   does not have LNKFLAGS, SYSVER and IAFVA fields
literal IHD$C_GEN_LNKFLG = 3;           !  Native with LNKFLAGS longword added
!   does not have SYSVER and IAFVA fields
literal IHD$C_GEN_SYSVER = 4;           !  Native with LNKFLAGS and SYSVER added
!   does not have IAFVA field
literal IHD$C_GEN_FIXUP = 5;            !  Version III image
!   contains LNKFLAGS, SYSVER, and IAFVA fields
literal IHD$C_GEN_NEWISD = 6;           !  ISD size field is a byte
literal IHD$S_IHDDEF = 512;
macro IHD$W_SIZE = 0,0,16,0 %;          !  Size in bytes of Image Header record 
macro IHD$W_ACTIVOFF = 2,0,16,0 %;      !  Byte offset to activation data 
macro IHD$W_SYMDBGOFF = 4,0,16,0 %;     !  Byte offset to symbol table and debug data 
macro IHD$W_IMGIDOFF = 6,0,16,0 %;      !  Byte offset to image ident data 
macro IHD$W_PATCHOFF = 8,0,16,0 %;      !  Byte offset to patch data 
macro IHD$W_VERSION_ARRAY_OFF = 10,0,16,0 %; !  Byte offset to version number array
macro IHD$W_MAJORID = 12,0,16,0 %;      !  Major id 
macro IHD$W_MINORID = 14,0,16,0 %;      !  Minor id 
macro IHD$B_HDRBLKCNT = 16,0,8,0 %;     !  Count of header blocks 
macro IHD$B_IMGTYPE = 17,0,8,0 %;       !  Image type 
! 
!  IMAGE TYPE CODES
! 
macro IHD$Q_PRIVREQS = 20,0,0,0 %;
literal IHD$S_PRIVREQS = 8;             !  Requested privilege mask 
macro IHD$W_IOCHANCNT = 28,0,16,0 %;    ! ! of channels requested 
! 0 if default
macro IHD$W_IMGIOCNT = 30,0,16,0 %;     ! ! of pages of image i/o section requested 
! 0 if default
macro IHD$R_LNKFLAGS_OVERLAY = 32,0,32,0 %;
macro IHD$L_LNKFLAGS = 32,0,32,0 %;     !  Linker produced image flags 
macro IHD$R_LNKFLAGS_BITS = 32,0,32,0 %;
macro IHD$V_LNKDEBUG = 32,0,1,0 %;      !  Full debugging requested 
macro IHD$V_LNKNOTFR = 32,1,1,0 %;      !  First transfer address missing 
macro IHD$V_NOP0BUFS = 32,2,1,0 %;      !  RMS use of P0 for image i/o disabled 
macro IHD$V_PICIMG = 32,3,1,0 %;        !  Image is position independent 
macro IHD$V_P0IMAGE = 32,4,1,0 %;       !  Image is in P0 space only 
macro IHD$V_DBGDMT = 32,5,1,0 %;        !  Image header has dmt fields
macro IHD$V_INISHR = 32,6,1,0 %;        !  Transfer array contains valid IHA$L_INISHR
macro IHD$V_IHSLONG = 32,7,1,0 %;       !  Longword DSTBLKS and GSTRECS valid in IHS$
macro IHD$V_MATCHCTL = 32,24,3,0 %;
literal IHD$S_MATCHCTL = 3;             !  Match control for linkable image 
macro IHD$L_IDENT = 36,0,32,0 %;        !  GBL SEC ident value for linkable image 
macro IHD$L_SYSVER = 40,0,32,0 %;       !  SYS$K_VERSION or 0 if not linked with exec 
macro IHD$L_IAFVA = 44,0,32,0 %;        !  Relative virtual address of fixup info 
macro IHD$T_SKIP = 48,0,0,0 %;
literal IHD$S_SKIP = 462;               !  ALIAS should be last word in 512 byte block
macro IHD$W_ALIAS = 510,0,16,0 %;       !  Code to use secondary image name
! *****************************************
! 
!   Define legal range of ALIAS constants. MINCODE must be equal to the
! 	lowest value and MAXCODE must be equal to the highest value.
! 
! ******************************************
! 
! 	Generation number returned by IMGSHR IMG$GET_IHD to SYSIMGACT.
! 	These do not appear in the image header but are inferred from the 
! 	contents of the image header
! 
 
!*** MODULE $IHADEF ***
! +
!  IMAGE HEADER ACTIVATION SECTION OFFSETS
! -
literal IHA$K_LENGTH = 20;              ! SIZE OF ACTIVATION SECTION 
literal IHA$C_LENGTH = 20;              ! SIZE OF ACTIVATION SECTION 
literal IHA$S_IHADEF = 20;
macro IHA$L_TFRADR1 = 0,0,32,0 %;       ! FIRST TRANSFER ADDRESS 
macro IHA$L_TFRADR2 = 4,0,32,0 %;       ! SECOND TRANSFER ADDRESS 
macro IHA$L_TFRADR3 = 8,0,32,0 %;       ! THIRD TRANSFER ADDRESS 
macro IHA$L_INISHR = 16,0,32,0 %;       ! SHARED IMAGE INITIALIZATION
! (valid if IHD$V_INISHR set)
 
!*** MODULE $IHPDEF ***
! +
!  IMAGE HEADER PATCH SECTION OFFSETS
! -
literal IHP$K_LENGTH = 44;              ! LENGTH OF PATCH HEADER SECTION 
literal IHP$C_LENGTH = 44;              ! LENGTH OF PATCH HEADER SECTION 
literal IHP$S_IHPDEF = 44;
macro IHP$L_ECO1 = 0,0,32,0 %;          ! DEC ECO LEVELS 1-32 
macro IHP$L_ECO2 = 4,0,32,0 %;          ! DEC ECO LEVELS 33-64 
macro IHP$L_ECO3 = 8,0,32,0 %;          ! DEC ECO LEVELS 65-98 
macro IHP$L_ECO4 = 12,0,32,0 %;         ! USER ECO LEVELS 99-132 
macro IHP$L_RW_PATSIZ = 16,0,32,0 %;    ! SIZE OF FREE RW PATCH AREA 
macro IHP$L_RW_PATADR = 20,0,32,0 %;    ! VIR ADDR OF NEXT FREE RW PATCH AREA 
macro IHP$L_RO_PATSIZ = 24,0,32,0 %;    ! SIZE OF FREE RO PATCH AREA 
macro IHP$L_RO_PATADR = 28,0,32,0 %;    ! VIR ADDR OF NEXT FREE RO PATCH AREA 
macro IHP$L_PATCOMTXT = 32,0,32,0 %;    ! PATCH COMMAND TEXT VIRTUAL BLOCK NUMBER 
macro IHP$Q_PATDATE = 36,0,0,0 %;
literal IHP$S_PATDATE = 8;              ! DATE OF MOST RECENT PATCH 
 
!*** MODULE $IHSDEF ***
! +
!  IMAGE HEADER SYMBOL TABLE AND DEBUG SECTION OFFSETS
! -
literal IHS$K_LENGTH = 28;              ! LENGTH OF SYMBOL TABLE SECTION 
literal IHS$C_LENGTH = 28;              ! LENGTH OF SYMBOL TABLE SECTION 
literal IHS$S_IHSDEF = 28;
macro IHS$L_DSTVBN = 0,0,32,0 %;        ! DEBUG SYMBOL TABLE VIRTUAL BLOCK NUMBER 
macro IHS$L_GSTVBN = 4,0,32,0 %;        ! GLOBAL SYMBOL TABLE VIRTUAL BLOCK NUMBER 
macro IHS$W_DSTBLKS = 8,0,16,0 %;       ! DEBUG SYMBOL TABLE BLOCK COUNT 
macro IHS$W_GSTRECS = 10,0,16,0 %;      ! GLOBAL SYMBOL TABLE RECORD COUNT 
macro IHS$L_DMTVBN = 12,0,32,0 %;       ! VBN OF DMT INFORMATION
macro IHS$L_DMTBYTES = 16,0,32,0 %;     ! LENGTH OF DMT INFO
macro IHS$L_DSTBLKS = 20,0,32,1 %;      ! Debug symbol table block count -- LONGWORD
macro IHS$L_GSTRECS = 24,0,32,1 %;      ! Global symbol table record count -- LONGWORD
 
!*** MODULE $IHIDEF ***
! +
!  IMAGE HEADER IDENTIFICATION SECTION OFFSETS
! -
literal IHI$K_LENGTH = 80;              ! LENGTH OF IMAGE HEADER IDENT SECTION 
literal IHI$C_LENGTH = 80;              ! LENGTH OF IMAGE HEADER IDENT SECTION 
literal IHI$S_IHIDEF = 80;
macro IHI$T_IMGNAM = 0,0,0,0 %;
literal IHI$S_IMGNAM = 40;              ! IMAGE NAME STRING 
macro IHI$T_IMGID = 40,0,0,0 %;
literal IHI$S_IMGID = 16;               ! IMAGE IDENT STRING 
macro IHI$Q_LINKTIME = 56,0,0,0 %;
literal IHI$S_LINKTIME = 8;             ! DATE AND TIME THIS IMAGE WAS LINKED 
! STANDARD SYSTEM QUADWORD FORMAT
macro IHI$T_LINKID = 64,0,0,0 %;
literal IHI$S_LINKID = 16;              ! LINKER IDENT STRING 
 
!*** MODULE $IHVNDEF ***
literal IHVN$M_SUBVERSION_MINOR_ID = 65535;
literal IHVN$M_SUBVERSION_MAJOR_ID = -65536;
literal IHVN$S_VERSION_ARRAY = 8;
macro IHVN$L_SUBSYSTEM_MASK = 0,0,32,0 %; !  Bit mask of nonzero version numbers
macro IHVN$L_SUBVERSION_ARRAY = 4,0,32,0 %; !  First array element
macro IHVN$V_SUBVERSION_MINOR_ID = 4,0,16,0 %;
literal IHVN$S_SUBVERSION_MINOR_ID = 16; !  Minor ID for each component
macro IHVN$V_SUBVERSION_MAJOR_ID = 4,16,16,0 %;
literal IHVN$S_SUBVERSION_MAJOR_ID = 16; !  Major ID for each component
literal IHVN$M_VERSION_MINOR_ID = 16777215;
literal IHVN$M_VERSION_MAJOR_ID = -16777216;
literal IHVN$S_OVERALL_VERSION = 4;
macro IHVN$V_VERSION_MINOR_ID = 0,0,24,0 %;
literal IHVN$S_VERSION_MINOR_ID = 24;   !  Minor ID of SYS.STB
macro IHVN$V_VERSION_MAJOR_ID = 0,24,8,0 %;
literal IHVN$S_VERSION_MAJOR_ID = 8;    !  Major ID of SYS.STB
literal IHVN$K_LENGTH = 132;
literal IHVN$C_LENGTH = 132;
 
!*** MODULE $IHXDEF ***
! +
!  IMAGE HEADER RECORD DEFINITIONS - CROSS LINKER - MAJORID = "01"
!          1ST RECORD OF IMAGE HEADER BLOCK
! -
literal IHX$K_MAJORID = 12592;          ! ^A/01/ MAJOR ID VALUE FOR CROSS LINKER 
literal IHX$K_MINORID = 12592;          ! ^A/01/ MINOR ID VALUE FOR CROSS LINKER 
literal IHX$K_MINORID1 = 12592;         ! ^A/01/ MINOR ID VALUE FOR CROSS LINKER WITH 
! SYMBOL TABLE AND 3RD TRANSFER ADR
literal IHX$K_LENGTH = 56;              ! LENGTH OF CROSS LINKER HEADER 
literal IHX$C_LENGTH = 56;              ! LENGTH OF CROSS LINKER HEADER 
literal IHX$S_IHXDEF = 56;
macro IHX$W_SIZE = 0,0,16,0 %;          ! SIZE IN BYTE OF IMAGE HEADER RECORD 
macro IHX$B_HDRBLKCNT = 2,0,8,0 %;      ! COUNT OF BLOCKS IN IMAGE HEADER 
macro IHX$Q_STARTADR = 4,0,0,0 %;
literal IHX$S_STARTADR = 8;             ! START ADDRESS 
macro IHX$W_MAJORID = 12,0,16,0 %;      ! MAJOR ID OF IMAGE HEADER 
macro IHX$W_MINORID = 14,0,16,0 %;      ! MINOR ID OF IMAGE HEADER 
macro IHX$T_IMGNAM = 16,0,0,0 %;
literal IHX$S_IMGNAM = 24;              ! IMAGE NAME 
! 
!  THE FOLLOWING FIELDS ARE PRESENT FOR MINOR ID'S GREATER OR EQUAL TO "03"
! 
macro IHX$L_DSTVBN = 40,0,32,0 %;       ! DEBUG SYMBOL TABLE VBN 
macro IHX$L_GSTVBN = 44,0,32,0 %;       ! GLOBAL SYMBOL TABLE VBN 
macro IHX$W_DSTBLKS = 48,0,16,0 %;      ! DEBUG SYMBOL TABLE BLOCKS 
macro IHX$W_GSTRECS = 50,0,16,0 %;      ! GLOBAL SYMBOL TABLE RECORD COUNT 
macro IHX$L_TFRADR3 = 52,0,32,0 %;      ! THIRD TRANSFER ADDRESS 
 
!*** MODULE $IMPDEF ***
! +
!         RMS32 IMPURE AREA OFFSET DEFINITIONS
! 
! -
literal IMP$C_ASYEFN = 30;              !  EFN FOR ASYNC WAITS 
literal IMP$C_IOREFN = 30;              !  EFN FOR IO RUNDOWN SYNCHRONIZATION 
literal IMP$C_ASYQIOEFN = 31;           !  EFN FOR ASYNC QIOS 
literal IMP$C_SYNCEFN = 27;             !  BASE EFN FOR SYNCHRONOUS QIO'S 
!  (28, 29 ALSO USED)
literal IMP$C_MBXEFN = 26;              !  EFN FOR QIOS TO NETWORK MAILBOXES 
! 
literal IMP$C_NPIOFILES = 63;           !  ! OF PIO SEGMENT FILES 
literal IMP$C_ENTPERSEG = 15;           !  ! OF IIO SEGMENT SLOTS 
!  PER INDEX TABLE SEGMENT
literal IMP$S_IMPDEF = 104;
macro IMP$W_RMSSTATUS = 0,0,16,0 %;     !  RMS OVERALL STATUS 
macro IMP$V_IIOS = 0,0,1,0 %;           !  SET IF THIS IS THE IMAGE 
!  I.O SEGMENT
macro IMP$V_AST = 0,1,1,0 %;            !  SET IF RUNNING AT EXEC AST LEVEL 
macro IMP$V_TEMP1 = 0,2,1,0 %;          !  TEMPORARY FLAG 
macro IMP$V_TEMP2 = 0,3,1,0 %;          !  " 
macro IMP$V_IORUNDOWN = 0,4,1,0 %;      !  SET IF IO RUNDOWN IN PROGRESS 
macro IMP$V_NOP0BUFS = 0,5,1,0 %;       !  SET IF RMS USE OF P0 FOR IMAGE I/O DISABLED 
macro IMP$V_RUH = 0,6,1,0 %;            !  Set if within RMS RU Handler 
macro IMP$V_RECOVERY = 0,7,1,0 %;       !  SET IF RECOVERY IN PROGRESS
macro IMP$V_RUH_SYNCH = 0,8,1,0 %;      !  SET IF RMS IO MUST SYNCH
!  WITH THE RU HANDLER
! 
macro IMP$B_PROT = 2,0,8,0 %;           !  PROTECTION FOR I/O BUFFER PAGES 
macro IMP$L_IOSEGADDR = 4,0,32,0 %;     !  ADDRESS OF FIRST FREE PAGE 
!  IN THIS (IMAGE OR PROCESS)
!  I/O SEGMENT
macro IMP$L_IOSEGLEN = 8,0,32,0 %;      !  ! OF FREE BYTES AT ABOVE ADDR 
macro IMP$L_FREEPGLH = 12,0,0,0 %;
literal IMP$S_FREEPGLH = 8;             !  FREE PAGE LIST HEAD 
macro IMP$L_SAVED_SP = 20,0,32,0 %;     !  SAVED VALUE OF SP AT ENTRY 
macro IMP$L_IFABTBL = 24,0,32,0 %;      !  IFAB TABLE ADDR 
macro IMP$L_IRABTBL = 28,0,32,0 %;      !  IRAB TABLE ADDR 
macro IMP$W_ENTPERSEG = 32,0,16,0 %;    !  ! OF SLOTS PER TABLE SEGMENT 
macro IMP$W_NUM_IFABS = 34,0,16,0 %;    !  NUMBER OF IFABS & IRABS CURRENTLY ALLOCATED 
macro IMP$L_IFBTBLINK = 36,0,32,0 %;    !  START OF IFAB TABLE (LINK TO NEXT SEGMENT) 
macro IMP$L_IRBTBLINK = 100,0,32,0 %;   !  START OF IRAB TABLE (LINK TO NEXT SEGMENT) 
 
!*** MODULE $IOCDEF ***
! +
! 
!  $IOCDEF - flag bits used in I/O database search routines.
! 
! -
literal IOC$M_PHY = 1;
literal IOC$M_TYPE = 2;
literal IOC$M_CLASS = 4;
literal IOC$M_LOCAL = 8;
literal IOC$M_EXISTS = 16;
literal IOC$M_2P = 32;
literal IOC$M_ANY = 64;
literal IOC$M_MOUNT = 128;
literal IOC$M_ALT = 256;
literal IOC$M_NO_TRANS = 512;
literal IOC$M_ALLOC = 1024;
literal IOC$S_IOCDEF = 2;
!  IOC$V_PHY must be bit 0!!
macro IOC$V_PHY = 0,0,1,0 %;            !  physical device specified
macro IOC$V_TYPE = 0,1,1,0 %;           !  device type name specified
macro IOC$V_CLASS = 0,2,1,0 %;          !  allocation class present
macro IOC$V_LOCAL = 0,3,1,0 %;          !  search local devices only
macro IOC$V_EXISTS = 0,4,1,0 %;         !  device exists
macro IOC$V_2P = 0,5,1,0 %;             !  device is on UCB secondary path
macro IOC$V_ANY = 0,6,1,0 %;            !  find any matching device
macro IOC$V_MOUNT = 0,7,1,0 %;          !  find only mountable devices
macro IOC$V_ALT = 0,8,1,0 %;            !  alternate UCB found
macro IOC$V_NO_TRANS = 0,9,1,0 %;       !  caller translated logical name
macro IOC$V_ALLOC = 0,10,1,0 %;         !  allocate mountable device
 
!*** MODULE $IO780DEF ***
! +
!  I/O SPACE LAYOUT FOR 11/780 CPU
! -
! DEFINE CONSTANT ADDRESSES 
literal IO780$AL_IOBASE = 536870912;    ! START OF I/O SPACE 
literal IO780$AL_PERNEX = 8192;         ! ! BYTES OR REGISTER SPACE/NEXUS 
literal IO780$AL_NNEX = 16;             ! ! OF NEXUSES 
literal IO780$AL_UB0SP = 537919488;     ! ADDR OF UB 0 SPACE 
literal IO780$AL_UB1SP = 538181632;     ! ADDR OF UB 1 SPACE 
literal IO780$AL_UB2SP = 538443776;     ! ADDR OF UB 2 SPACE 
literal IO780$AL_UB3SP = 538705920;     ! ADDR OF UB 3 SPACE 
 
!*** MODULE $IO750DEF ***
! +
!  I/O SPACE LAYOUT FOR 11/750 CPU
! -
! DEFINE CONSTANT ADDRESSES 
literal IO750$AL_IOBASE = 15859712;     ! START OF I/O SPACE FOR SLOT 16 
literal IO750$AL_PERNEX = 8192;         ! ! BYTES OF REGISTER SPACE/NEXUS 
literal IO750$AL_UBBASE = 15925248;     ! START OF UB 0 SPACE 
literal IO750$AL_MBBASE = 15892480;     ! START OF MB0 REGISTER SPACE 
literal IO750$AL_FLOAT = 15941632;      ! START OF FLOATING ADAPTER SPACE 
literal IO750$AL_NNEX = 16;             ! ! CONFIGURABLE NEXUSES 
literal IO750$AL_UB0SP = 16515072;      ! ADDR OF UB0 SPACE 
literal IO750$AL_UB1SP = 16252928;      ! ADDR OF UB1 SPACE 
! FIXED ADAPTER ASSIGNMENTS FOR 
!  SLOTS 0-9:
literal IO750$C_SL_MEM0 = 0;            !  MEMORY CONTROLLER 
literal IO750$C_SL_MPM0 = 1;            !  MULTIPORT MEMORIES... 
literal IO750$C_SL_MPM1 = 2;            !  
literal IO750$C_SL_MPM2 = 3;            !  
literal IO750$C_SL_MB0 = 4;             !  MASSBUS ADAPTERS... 
literal IO750$C_SL_MB1 = 5;             !  
literal IO750$C_SL_MB2 = 6;             !  
literal IO750$C_SL_MB3 = 7;             !  
literal IO750$C_SL_UB0 = 8;             !  UNIBUS 0 
literal IO750$C_SL_UB1 = 9;             !  UNIBUS 1 
 
!*** MODULE $IO730DEF ***
! ++
!  I/O SPACE LAYOUT FOR 11/730 CPU
! --
literal IO730$AL_IOBASE = 15859712;     !  START OF I/O SPACE 
literal IO730$AL_PERNEX = 8192;         !  ! BYTES OF REGISTER SPACE/NEXUS 
literal IO730$AL_NNEX = 16;             !  ! OF NEXUSES 
literal IO730$AL_UB0SP = 16515072;      !  ADDR OF UB0 SPACE 
 
!*** MODULE $IO790DEF ***
! ++
!  I/O SPACE LAYOUT FOR 11/790 CPU
! --
literal IO790$AL_IOA0 = 536870912;      ! START OF I/O SPACE FOR ABUS ADAPTER 0 
literal IO790$AL_IOA1 = 570425344;      ! START OF I/O SPACE FOR ABUS ADAPTER 1 
literal IO790$AL_IOA2 = 603979776;      ! START OF I/O SPACE FOR ABUS ADAPTER 2 
literal IO790$AL_IOA3 = 637534208;      ! START OF I/O SPACE FOR ABUS ADAPTER 3 
literal IO790$AL_PERNEX = 8192;         ! ! OF BYTES OF REGISTER SPACE/NEXUS 
literal IO790$AL_NNEX = 16;             ! NUMBER OF NEXUS PER SBIA 
literal IO790$AL_UB0SP = 1048576;       !  OFFSET OF UB 0 SPACE FROM BASE OF SBIA 
literal IO790$AL_IOACR = 524288;        !  OFFSET OF IO ADAPTER CR FROM BASE OF SBIA 
literal IO790$AL_PERABS = 33554432;     !  ADDRESS SPACE FOR EACH ABUS ADAPTER
literal IO790$K_SBIA = 1;               !  TYPE CODE FOR SBIA ADAPTER
literal IO790$C_SBIA = 1;               !  TYPE CODE FOR SBIA ADAPTER
 
!*** MODULE $IOUV1DEF ***
! ++
!  I/O SPACE LAYOUT FOR MicroVAX I CPU
! --
literal IOUV1$AL_QB0SP = 536870912;     !  ADDR OF QBUS SPACE 
 
!*** MODULE $IOUV2DEF ***
! ++
!  I/O SPACE LAYOUT FOR MicroVAX II CPU
! --
literal IOUV2$AL_QB0SP = 536870912;     !  ADDR OF QBUS SPACE 
literal IOUV2$AW_INTPR0 = 536878912;    !  INTERPROC COMMUN REG
!    (ICR) FOR ARBITER
literal IOUV2$AW_INTPR1 = 536878914;    !  ICR FOR AUXIL 1
literal IOUV2$AW_INTPR2 = 536878916;    !  ICR FOR AUXIL 2
literal IOUV2$AW_INTPR3 = 536878918;    !  ICR FOR AUXIL 3
literal IOUV2$AL_SIDEX = 537133060;     !  SYS ID EXTENSION REG
literal IOUV2$AW_BTDIAG = 537395200;    !  BOOT & DIAG REG
literal IOUV2$AL_MEMERR = 537395204;    !  MEM SYSTEM ERR REG
literal IOUV2$AL_CPUERR = 537395208;    !  CPU ERROR ADDR REG
literal IOUV2$AL_DMAERR = 537395212;    !  DMA ERROR ADDR REG
literal IOUV2$AL_QMAPS = 537427968;     !  FIRST QBUS MAP REG
literal IOUV2$AL_QMAPE = 537460732;     !  LAST QBUS MAP REG
literal IOUV2$AW_TODSEC = 537624576;    !  TODR SECOND
literal IOUV2$AW_TODSAL = 537624578;    !  TODR SECOND ALARM
literal IOUV2$AW_TODMIN = 537624580;    !  TODR MINUTE
literal IOUV2$AW_TODMAL = 537624582;    !  TODR MINUTE ALARM
literal IOUV2$AW_TODHR = 537624584;     !  TODR HOUR
literal IOUV2$AW_TODDWK = 537624588;    !  TODR DAY OF WEEK
literal IOUV2$AW_TODDAY = 537624590;    !  TODR DAY OF MONTH
literal IOUV2$AW_TODMON = 537624592;    !  TODR MONTH
literal IOUV2$AW_TODYR = 537624594;     !  TODR YEARR
literal IOUV2$AW_CPMBX = 537624604;     !  CONSOLE PROG MAILBOX
literal IOUV2$AW_CPMBX2 = 537624606;    !  CONSOLE PROG MAILBOX2
literal IOUV2$AL_QB0MEM = 805306368;    !  ADDR OF QBUS MEMORY
 
!*** MODULE $IO410DEF ***
! ++
!  I/O SPACE LAYOUT FOR VAXstation 2000/MicroVAX 2000 CPU
! --
literal IO410$AB_CFGTST = 537001984;    !  CONFIG AND TEST REG
literal IO410$AL_SIDEX = 537133060;     !  SYS ID EXTENSION REG
literal IO410$AL_HLTCOD = 537395200;    !  HALT CODE REGISTER
literal IO410$AL_MSER = 537395204;      !  MEM SYSTEM ERR REG
literal IO410$AL_MEAR = 537395208;      !  MEM ERROR ADDR REG
literal IO410$AB_INTMSK = 537395212;    !  INTERRUPT MASK REG
literal IO410$AB_VDCORG = 537395213;    !  VIDEO DISPLAY ORIGIN REG
literal IO410$AB_VDCSEL = 537395214;    !  VIDEO CTLR SELECT REG
literal IO410$AB_INTREQ = 537395215;    !  INTERRUPT REQ REG
literal IO410$AB_INTCLR = 537395215;    !  INTERRUPT CLEAR REG
literal IO410$AB_NIADRS = 537460736;    !  NETWORK ADDRESS ROM START
literal IO410$AB_NIADRE = 537460863;    !  NETWORK ADDRESS ROM END
literal IO410$AW_SERCSR = 537526272;    !  SERIAL LINE CSR
literal IO410$AW_SERRBF = 537526276;    !   " " RECEIVE BUFFER
literal IO410$AW_SERLPR = 537526276;    !   " " LINE PARAM REG
literal IO410$AW_SERTCR = 537526280;    !   " " TRANSMIT CONTROL REG
literal IO410$AW_SERMSR = 537526284;    !   " " MODEM STATUS REG
literal IO410$AW_SERTDR = 537526284;    !   " " TRANSMIT DATA REG
literal IO410$AL_TODSEC = 537591808;    !  TODR SECOND
literal IO410$AL_TODSAL = 537591812;    !  TODR SECOND ALARM
literal IO410$AL_TODMIN = 537591816;    !  TODR MINUTE
literal IO410$AL_TODMAL = 537591820;    !  TODR MINUTE ALARM
literal IO410$AL_TODHR = 537591824;     !  TODR HOUR
literal IO410$AL_TODHAL = 537591828;    !  TODR HOUR ALARM
literal IO410$AL_TODDWK = 537591832;    !  TODR DAY OF WEEK
literal IO410$AL_TODDAY = 537591836;    !  TODR DAY OF MONTH
literal IO410$AL_TODMON = 537591840;    !  TODR MONTH
literal IO410$AL_TODYR = 537591844;     !  TODR YEAR
literal IO410$AL_TODCSA = 537591848;    !  TODR CSR A
literal IO410$AL_TODCSB = 537591852;    !  TODR CSR B
literal IO410$AL_TODCSC = 537591856;    !  TODR CSR C
literal IO410$AL_TODCSD = 537591860;    !  TODR CSR D
literal IO410$AB_RAMST = 537591864;     !  TODR 1ST BYTE RAM
literal IO410$AB_CPMBX = 537591864;     !  CONSOLE MAILBOX
literal IO410$AB_CPFLG = 537591868;     !  CONSOLE FLAGS
literal IO410$AB_LK201 = 537591872;     !  KEYBOARD VARIATION
literal IO410$AB_CONID = 537591876;     !  CONSOLE DEV TYPE
literal IO410$AL_SCRPTR = 537591880;    !  CP SCRATCH RAM ADDR
literal IO410$AL_BATCHK = 537591944;    !  BATTERY CHECK DATA
literal IO410$AL_BOODEV = 537591960;    !  DEFAULT BOOT DEVICE
literal IO410$AL_BOOFLG = 537591976;    !  DEFAULT R5 FLAGS
literal IO410$AB_SCRLEN = 537591992;    !  SIZE OF CP SCR RAM
literal IO410$AB_RAMEND = 537592060;    !  TODR LAST BYTE RAM
literal IO410$AB_DKCREG = 537657344;    !  DISK REG DATA ACCESS
literal IO410$AB_DKCCMD = 537657348;    !  DISK CONTROLLER COMMAND
literal IO410$AW_DKSTAT = 537657348;    !  DISK INTERRUPT STATUS
literal IO410$AB_SCTLS = 537657472;     !  TAPE CTLR CHIP START
literal IO410$AB_SCTLE = 537657503;     !  TAPE CTLR CHIP END
literal IO410$AB_SCDADR = 537657504;    !  TAPE DMA ADR REG
literal IO410$AW_SCDCNT = 537657536;    !  TAPE DMA BYTCNT REG
literal IO410$AB_SCDDIR = 537657540;    !  TAPE DMA XFER DIRECTION  REG
literal IO410$AB_DKBUFS = 537722880;    !  DISK 16KB BUFFER START
literal IO410$AB_DKBUFE = 537739263;    !  DISK 16KB BUFFER END
literal IO410$AW_NIRDP = 537788416;     !  NI REG DATA PORT
literal IO410$AW_NIRAP = 537788420;     !  NI REG ADR PORT
literal IO410$AW_VCCMD = 537853952;     !  VIDEO CURSOR COMMAND REG
literal IO410$AL_VCXPOS = 537853956;    !  VIDEO CURSOR X POSITION
literal IO410$AL_VCYPOS = 537853960;    !  VIDEO CURSOR Y POSITION
literal IO410$AL_VCXMN1 = 537853964;    !  VIDEO CURSOR REGION 1 LEFT EDGE
literal IO410$AL_VCXMX1 = 537853968;    !  VIDEO CURSOR REGION 1 RIGHT EDGE
literal IO410$AL_VCYMN1 = 537853972;    !  VIDEO CURSOR REGION 1 TOP EDGE
literal IO410$AL_VCYMX1 = 537853976;    !  VIDEO CURSOR REGION 1 BOTTOM EDGE
literal IO410$AL_VCXMN2 = 537853996;    !  VIDEO CURSOR REGION 2 LEFT EDGE
literal IO410$AL_VCXMX2 = 537854000;    !  VIDEO CURSOR REGION 2 RIGHT EDGE
literal IO410$AL_VCYMN2 = 537854004;    !  VIDEO CURSOR REGION 2 TOP EDGE
literal IO410$AL_VCYMX2 = 537854008;    !  VIDEO CURSOR REGION 2 BOTTOM EDGE
literal IO410$AL_VCLOAD = 537854012;    !  VIDEO CURSOR SPRITE PATTERN LOAD
literal IO410$AB_NIROMS = 537919488;    !  NI OPTION ROM START
literal IO410$AB_NIROME = 538181631;    !  NI OPTION ROM END
literal IO410$AB_VDROMS = 538181632;    !  VIDEO OPTION ROM START
literal IO410$AB_VDROME = 538443775;    !  VIDEO OPTION ROM END
literal IO410$AB_PCROMS = 538443776;    !  PC-DOS COPROCESSOR ROM START
literal IO410$AB_PCROME = 538705919;    !  PC-DOS COPROCESSOR ROM END
literal IO410$AB_XROMS = 538705920;     !  FUTURE ROM START
literal IO410$AB_XROME = 538968063;     !  FUTURE ROM END
literal IO410$AB_PCCSR = 570425344;     !  START OF PC-DOS REGISTERS
literal IO410$AB_XCSR = 603979776;      !  REGISTERS FOR FUTURE OPTION
literal IO410$AB_VMEMS = 805306368;     !  VIDEO MEMORY START
literal IO410$AB_VMEME = 805437439;     !  VIDEO MEMORY END
literal IO410$AB_VDMEMS = 939524096;    !  VIDEO OPTION MEMORY START
literal IO410$AB_VDMEME = 1073741823;   !  VIDEO OPTION MEMORY END
literal IO410$AB_VDCSR1 = 939524096;    !  CSRS FOR OPTION IN VIDEO SLOT
literal IO410$AB_VDCSR2 = 1006632960;   !  CSRS FOR COLOR VIDEO
 
!*** MODULE $IO420DEF ***
literal IO420$AB_CACH2DS = 268435456;   !  2ND LEVEL CACHE DATA START
literal IO420$AB_CACH2DE = 268468223;   !  2ND LEVEL CACHE DATA END
literal IO420$AB_CACH2TS = 268500992;   !  2ND LEVEL CACHE TAG START
literal IO420$AB_CACH2TE = 268533759;   !  2ND LEVEL CACHE TAG END
literal IO420$AW_CFGTST = 537001984;    !  CONFIG AND TEST REG READ ONLY
literal IO420$AB_IORESET = 537001984;   !  IO RESET REG. WRITE ONLY
literal IO420$AL_SIDEX = 537133060;     !  SYS ID EXTENSION REG
literal IO420$AL_HLTCOD = 537395200;    !  HALT CODE REGISTER
literal IO420$AB_INTMSK = 537395212;    !  INTERRUPT MASK REG
literal IO420$AB_VDCORG = 537395213;    !  VIDEO DISPLAY ORIGIN REG
literal IO420$AB_VDCSEL = 537395214;    !  VIDEO CTLR SELECT REG
literal IO420$AB_INTREQ = 537395215;    !  INTERRUPT REQ REG READ ONLY
literal IO420$AB_INTCLR = 537395215;    !  INTERRUPT CLEAR REG WRITE ONLY
literal IO420$AW_DIAGDISP = 537395216;  !  DIAGNOSTIC DISPLAY REG WRITE ONLY
literal IO420$AL_PARCTL = 537395220;    !  PARITY CONTROL REG
literal IO420$AW_DIAGTIME = 537395230;  !  DIAGNOSTIC TIME REG
literal IO420$AL_CACR = 537411584;      !  SECONDARY CACHE CONTROL REG
literal IO420$AB_NIADRS = 537460736;    !  NETWORK ADDRESS ROM START
literal IO420$AB_NIADRE = 537460863;    !  NETWORK ADDRESS ROM END
literal IO420$AW_SERCSR = 537526272;    !  SERIAL LINE CSR
literal IO420$AW_SERBUF = 537526276;    !   " " RECEIVE BUFFER READ ONLY
literal IO420$AW_SERLPR = 537526276;    !   " " LINE PARAM REG WRITE ONLY
literal IO420$AW_SERTCR = 537526280;    !   " " TRANSMIT CONTROL REG
literal IO420$AW_SERMSR = 537526284;    !   " " MODEM STATUS REG READ ONLY 
literal IO420$AW_SERTDR = 537526284;    !   " " TRANSMIT DATA REG WRITE ONLY
literal IO420$AL_TODSEC = 537591808;    !  TOYC SECOND
literal IO420$AL_TODSAL = 537591812;    !  TOYC SECOND ALARM
literal IO420$AL_TODMIN = 537591816;    !  TOYC MINUTE
literal IO420$AL_TODMAL = 537591820;    !  TOYC MINUTE ALARM
literal IO420$AL_TODHR = 537591824;     !  TOYC HOUR
literal IO420$AL_TODHAL = 537591828;    !  TOYC HOUR ALARM
literal IO420$AL_TODDWK = 537591832;    !  TOYC DAY OF WEEK
literal IO420$AL_TODDAY = 537591836;    !  TOYC DAY OF MONTH
literal IO420$AL_TODMON = 537591840;    !  TOYC MONTH
literal IO420$AL_TODYR = 537591844;     !  TOYC YEAR
literal IO420$AL_TODCSA = 537591848;    !  TIME BASE DIVISOR
literal IO420$AL_TODCSB = 537591852;    !  DATE MODE AND FORMAT
literal IO420$AL_TODCSC = 537591856;    !  INTERRUPT FLAGS (NOT USED)
literal IO420$AL_TODCSD = 537591860;    !  VALID RAM AND TIME FLAG
literal IO420$AB_RAMST = 537591864;     !  RAM START
literal IO420$AB_CPMBX = 537591864;     !  CONSOLE MAILBOX
literal IO420$AB_CPFLG = 537591868;     !  CONSOLE FLAGS
literal IO420$AB_LK201 = 537591872;     !  KEYBOARD VARIATION
literal IO420$AB_CONID = 537591876;     !  CONSOLE DEV TYPE
literal IO420$AL_SCRPTR = 537591880;    !  CP SCRATCH RAM ADDR
literal IO420$AL_BATCHK = 537591944;    !  BATTERY CHECK DATA
literal IO420$AL_PASSWORD = 537591960;  !  ETHERNET TRIGGER PASSWORD CODE
literal IO420$AL_BOOFLG = 537591976;    !  DEFAULT R5 FLAGS
literal IO420$AB_SCRLEN = 537591992;    !  SIZE OF CP SCR RAM
literal IO420$AB_SCSI = 537591996;      !  CPU SCSI ID fields
literal IO420$AB_BOODEV_LEN = 537592000; !  DEFAULT BOOT DEVICE NAME LENGTH
literal IO420$AB_BOODEV = 537592004;    !  DEFAULT BOOT DEVICE
literal IO420$AB_RAMEND = 537592060;    !  RAM END
literal IO420$AB_DKCREG = 537657344;    !  DISK REG DATA ACCESS
literal IO420$AB_DKCCMD = 537657348;    !  DISK CONTROLLER COMMAND WRITE ONLY
literal IO420$AW_DKSTAT = 537657348;    !  DISK INTERRUPT STATUS READ ONLY
literal IO420$AB_SCSOUTDAT = 537657472; !  SCSI OUTPUT DATA REG WRITE ONLY
literal IO420$AB_SCSCURDAT = 537657472; !  SCSI CURRENT DATA REG READ ONLY
literal IO420$AB_SCSINICMD = 537657476; !  SCSI INITIATOR COMMAND REG
literal IO420$AB_SCSMODE = 537657480;   !  SCSI MODE REG
literal IO420$AB_SCSTARCMD = 537657484; !  SCSI TARGET COMMAND REG
literal IO420$AB_SCSSELENA = 537657488; !  SCSI SELECT ENABLE REG WRITE ONLY
literal IO420$AB_SCSCURSTA = 537657488; !  SCSI CURRENT BUS STATUS REG READ ONLY
literal IO420$AB_SCSDMASND = 537657492; !  SCSI START DMA SEND WRITE ONLY
literal IO420$AB_SCSSTATUS = 537657492; !  SCSI BUS AND STATUS REG READ ONLY
literal IO420$AB_SCSDMATRC = 537657496; !  SCSI START DMA TARGET RECEIVE WRITE ONLY
literal IO420$AB_SCSINDATA = 537657496; !  SCSI INPUT DATA REG READ ONLY
literal IO420$AB_SCSDMAIRC = 537657500; !  SCSI START DMA INITIATOR RECEIVE WRITE ONLY
literal IO420$AB_SCSRESET = 537657500;  !  SCSI RESET INTERRUPT/ERROR READ ONLY
literal IO420$AL_SCDADR = 537657504;    !  SCSI DMA ADDRESS REG
literal IO420$AL_SCDCNT = 537657536;    !  SCSI DMA BYTE COUNT REG
literal IO420$AB_SCDDIR = 537657540;    !  SCSI DMA TRANSFER DIRECTION
literal IO420$AB_STCMODE = 537657568;   !  STORAGE CONTROLLER MODE
literal IO420$AB_D16BUFS = 537722880;   !  DATA BUFFER (16KB COMPATIBILITY RANGE) START
literal IO420$AB_D16BUFE = 537739263;   !  DATA BUFFER (16KB COMPATIBILITY RANGE) END
literal IO420$AB_D128BUFS = 539820032;  !  DATA BUFFER (128KB FULL RANGE) START
literal IO420$AB_D128BUFE = 539951103;  !  DATA BUFFER (128KB FULL RANGE) END
literal IO420$AW_NIRDP = 537788416;     !  NI REG DATA PORT
literal IO420$AW_NIRAP = 537788420;     !  NI REG ADR PORT
literal IO420$AW_VCCMD = 537853952;     !  VIDEO CURSOR COMMAND REG
literal IO420$AW_VCXPOS = 537853956;    !  VIDEO CURSOR X POSITION
literal IO420$AW_VCYPOS = 537853960;    !  VIDEO CURSOR Y POSITION
literal IO420$AW_VCXMN1 = 537853964;    !  VIDEO CURSOR REGION 1 LEFT EDGE
literal IO420$AW_VCXMX1 = 537853968;    !  VIDEO CURSOR REGION 1 RIGHT EDGE
literal IO420$AW_VCYMN1 = 537853972;    !  VIDEO CURSOR REGION 1 TOP EDGE
literal IO420$AW_VCYMX1 = 537853976;    !  VIDEO CURSOR REGION 1 BOTTOM EDGE
literal IO420$AW_VCXMN2 = 537853996;    !  VIDEO CURSOR REGION 2 LEFT EDGE
literal IO420$AW_VCXMX2 = 537854000;    !  VIDEO CURSOR REGION 2 RIGHT EDGE
literal IO420$AW_VCYMN2 = 537854004;    !  VIDEO CURSOR REGION 2 TOP EDGE
literal IO420$AW_VCYMX2 = 537854008;    !  VIDEO CURSOR REGION 2 BOTTOM EDGE
literal IO420$AW_VCLOAD = 537854012;    !  VIDEO CURSOR SPRITE PATTERN LOAD
literal IO420$AB_SCFWROMS = 537919488;  !  STORAGE CONTROLLER OPTION FIRMWARE ROM START
literal IO420$AB_SCFWROME = 538050559;  !  STORAGE CONTROLLER OPTION FIRMWARE ROM END
literal IO420$AB_VDROMS = 538181632;    !  VIDEO OPTION ROM START
literal IO420$AB_VDROME = 538443775;    !  VIDEO OPTION ROM END
literal IO420$AB_X1ROMS = 538443776;    !  ADDITIONAL OPTION 1 ROM START
literal IO420$AB_X1ROME = 538705919;    !  ADDITIONAL OPTION 1 ROM END
literal IO420$AB_X2ROMS = 538705920;    !  ADDITIONAL OPTION 2 ROM START
literal IO420$AB_X2ROME = 538968063;    !  ADDITIONAL OPTION 2 ROM END
literal IO420$AB_X1CSRS = 570425344;    !  ADDITIONAL OPTION 1 CSR'S START
literal IO420$AB_X1CSRE = 603979775;    !  ADDITIONAL OPTION 1 CSR'S END
literal IO420$AB_X2CSRS = 603979776;    !  ADDITIONAL OPTION 2 CSR'S START
literal IO420$AB_X2CSRE = 637534207;    !  ADDITIONAL OPTION 2 CSR'S END
literal IO420$AB_VMEMS = 805306368;     !  VIDEO MEMORY START
literal IO420$AB_VMEME = 805568511;     !  VIDEO MEMORY END
literal IO420$AB_VD32MEMS = 939524096;  !  VIDEO OPTION MEMORY (32 BIT PATH) START
literal IO420$AB_VD32MEME = 1006632959; !  VIDEO OPTION MEMORY (32 BIT PATH) END
literal IO420$AB_VD16MEMS = 1006632960; !  VIDEO OPTION MEMORY (16 BIT PATH) START
literal IO420$AB_VD16MEME = 1006698495; !  VIDEO OPTION MEMORY (16 BIT PATH) END
literal IO420$AB_CVFWROMS = 538181632;  !  COLOR VIDEO OPTION FIRMWARE ROM START
literal IO420$AB_CVFWROME = 538312703;  !  COLOR VIDEO OPTION FIRMWARE ROM END
literal IO420$AB_CVADDER = 1006632960;  !  COLOR VIDEO OPTION ADDER REGS START
literal IO420$AB_CVFIFO = 1006633472;   !  COLOR VIDEO OPTION FIFO COMPRESSION REGS START
literal IO420$AB_CVVDAC = 1006633728;   !  COLOR VIDEO OPTION VIDEO DAC REGS START
literal IO420$AB_CVCURS = 1006633984;   !  COLOR VIDEO OPTION CURSOR REGS START
literal IO420$AW_CVVRDBK = 1006634240;  !  COLOR VIDEO OPTION VIDEO READBACK REG 
literal IO420$AB_CVMEMS = 1006665728;   !  COLOR VIDEO OPTION FIFO/TEMPLATE RAM START
literal IO420$AB_CVMEME = 1006698495;   !  COLOR VIDEO OPTION FIFO/TEMPLATE RAM END
literal IO420$AB_ASFWROMS = 538181632;  !  ASYNC SERIAL LINE OPTION FIRMWARE ROM START
literal IO420$AB_ASFWROME = 538312703;  !  ASYNC SERIAL LINE OPTION FIRMWARE ROM END
literal IO420$AB_ASCONSTA = 939524096;  !  ASYNC SERIAL LINE OPTION CONTROL AND STATUS REGS START
 
!*** MODULE $IO43DEF ***
literal IO43$AB_CACH2DS = 268435456;
literal IO43$AB_CACH2DE = 536870911;
literal IO43$AL_CFGTST = 537001984;
literal IO43$AB_IORESET = 537001984;
literal IO43$AL_SYSTYPE = 537133060;
literal IO43$AB_CPGETCHR = 537133124;
literal IO43$AB_CPMSGOUT = 537133132;
literal IO43$AB_CPPUTCHR = 537133144;
literal IO43$AL_ROMVERS = 537133176;
literal IO43$AB_ROMDIAG = 537133180;
literal IO43$AL_HLTCOD = 537395200;
literal IO43$AB_INTMSK = 537395212;
literal IO43$AB_VDCORG = 537395213;
literal IO43$AB_VDCSEL = 537395214;
literal IO43$AB_INTREQ = 537395215;
literal IO43$AB_INTCLR = 537395215;
literal IO43$AW_DIAGDISP = 537395216;
literal IO43$AL_PARCTL = 537395220;
literal IO43$AW_DIAGTIME = 537395230;
literal IO43$AB_NIADRS = 537460736;
literal IO43$AB_NIADRE = 537460863;
literal IO43$AW_SERCSR = 537526272;
literal IO43$AW_SERBUF = 537526276;
literal IO43$AW_SERLPR = 537526276;
literal IO43$AW_SERTCR = 537526280;
literal IO43$AW_SERMSR = 537526284;
literal IO43$AW_SERTDR = 537526284;
literal IO43$AL_TODSEC = 537591808;
literal IO43$AL_TODSAL = 537591812;
literal IO43$AL_TODMIN = 537591816;
literal IO43$AL_TODMAL = 537591820;
literal IO43$AL_TODHR = 537591824;
literal IO43$AL_TODHAL = 537591828;
literal IO43$AL_TODDWK = 537591832;
literal IO43$AL_TODDAY = 537591836;
literal IO43$AL_TODMON = 537591840;
literal IO43$AL_TODYR = 537591844;
literal IO43$AL_TODCSA = 537591848;
literal IO43$AL_TODCSB = 537591852;
literal IO43$AL_TODCSC = 537591856;
literal IO43$AL_TODCSD = 537591860;
literal IO43$AB_RAMST = 537591864;
literal IO43$AB_CPMBX = 537591864;
literal IO43$AB_CPFLG = 537591868;
literal IO43$AB_LK201 = 537591872;
literal IO43$AB_CONID = 537591876;
literal IO43$AL_SCRPTR = 537591880;
literal IO43$AL_BATCHK = 537591944;
literal IO43$AL_PASSWORD = 537591960;
literal IO43$AL_BOOFLG = 537591976;
literal IO43$AB_SCRLEN = 537591992;
literal IO43$AB_SCSI = 537591996;
literal IO43$AB_BOODEVLEN = 537592000;
literal IO43$AB_BOODEV = 537592004;
literal IO43$AB_RAMEND = 537592060;
literal IO43$AB_SCSOUTDAT = 537657472;
literal IO43$AB_SCSCURDAT = 537657472;
literal IO43$AB_SCSINICMD = 537657476;
literal IO43$AB_SCSMODE = 537657480;
literal IO43$AB_SCSTARCMD = 537657484;
literal IO43$AB_SCSSELENA = 537657488;
literal IO43$AB_SCSCURSTA = 537657488;
literal IO43$AB_SCSDMASND = 537657492;
literal IO43$AB_SCSSTATUS = 537657492;
literal IO43$AB_SCSDMATRC = 537657496;
literal IO43$AB_SCSINDATA = 537657496;
literal IO43$AB_SCSDMAIRC = 537657500;
literal IO43$AB_SCSRESET = 537657500;
literal IO43$AL_SCDADR = 537657504;
literal IO43$AL_SCDCNT = 537657536;
literal IO43$AB_SCDDIR = 537657540;
literal IO43$AB_SCSBOUTDAT = 537657728;
literal IO43$AB_SCSBCURDAT = 537657728;
literal IO43$AB_SCSBINICMD = 537657732;
literal IO43$AB_SCSBMODE = 537657736;
literal IO43$AB_SCSBTARCMD = 537657740;
literal IO43$AB_SCSBSELENA = 537657744;
literal IO43$AB_SCSBCURSTA = 537657744;
literal IO43$AB_SCSBDMASND = 537657748;
literal IO43$AB_SCSBSTATUS = 537657748;
literal IO43$AB_SCSBDMATRC = 537657752;
literal IO43$AB_SCSBINDATA = 537657752;
literal IO43$AB_SCSBDMAIRC = 537657756;
literal IO43$AB_SCSBRESET = 537657756;
literal IO43$AL_SCDBADR = 537657760;
literal IO43$AL_SCDBCNT = 537657792;
literal IO43$AB_SCDBDIR = 537657796;
literal IO43$AW_NIRDP = 537788416;
literal IO43$AW_NIRAP = 537788420;
literal IO43$AW_VCCMD = 537853952;
literal IO43$AW_VCXPOS = 537853956;
literal IO43$AW_VCYPOS = 537853960;
literal IO43$AW_VCXMN1 = 537853964;
literal IO43$AW_VCXMX1 = 537853968;
literal IO43$AW_VCYMN1 = 537853972;
literal IO43$AW_VCYMX1 = 537853976;
literal IO43$AW_VCXMN2 = 537853996;
literal IO43$AW_VCXMX2 = 537854000;
literal IO43$AW_VCYMN2 = 537854004;
literal IO43$AW_VCYMX2 = 537854008;
literal IO43$AW_VCLOAD = 537854012;
literal IO43$AB_CVFWROMS = 538181632;
literal IO43$AB_CVFWROME = 538312703;
literal IO43$AB_VDROMS = 538181632;
literal IO43$AB_VDROME = 538443775;
literal IO43$AB_X1ROMS = 538443776;
literal IO43$AB_X1ROME = 538705919;
literal IO43$AB_X2ROMS = 538705920;
literal IO43$AB_X2ROME = 538968063;
literal IO43$AB_D128BUFS = 539820032;
literal IO43$AB_D128BUFE = 539951103;
literal IO43$AB_CACH2TS = 553648128;
literal IO43$AB_CACH2TE = 553779199;
literal IO43$AL_SESR = 554696704;
literal IO43$AB_X1CSRS = 570425344;
literal IO43$AB_X1CSRE = 603979775;
literal IO43$AB_X2CSRS = 603979776;
literal IO43$AB_X2CSRE = 637534207;
literal IO43$AB_MEMDIAGS = 671088640;
literal IO43$AB_MEMDIAGE = 704643071;
literal IO43$AB_VMEMS = 805306368;
literal IO43$AB_VMEME = 805568511;
literal IO43$AB_VD32MEMS = 939524096;
literal IO43$AB_VD32MEME = 1006632959;
literal IO43$AB_VD16MEMS = 1006632960;
literal IO43$AB_VD16MEME = 1006698495;
literal IO43$AB_CVADDER = 1006632960;
literal IO43$AB_CVFIFO = 1006633472;
literal IO43$AB_CVVDAC = 1006633728;
literal IO43$AB_CVCURS = 1006633984;
literal IO43$AW_CVVRDBK = 1006634240;
literal IO43$AB_CVMEMS = 1006665728;
literal IO43$AB_CVMEME = 1006698495;
 
!*** MODULE $IO440DEF ***
literal IO440$AL_DMAPS = 536870912;
literal IO440$AL_DMAPE = 537001983;
literal IO440$AW_CFGTST = 537001984;
literal IO440$AB_IORESET = 537001984;
literal IO440$AL_SYSTYPE = 537133060;
literal IO440$AB_CPGETCHR = 537133124;
literal IO440$AB_CPMSGOUT = 537133132;
literal IO440$AB_CPPUTCHR = 537133144;
literal IO440$AL_ROMVERS = 537133176;
literal IO440$AB_ROMDIAG = 537133180;
literal IO440$AL_HLTCOD1 = 537395200;
literal IO440$AL_HLTCOD2 = 537395204;
literal IO440$AL_MAPBASE = 537395208;
literal IO440$AB_INTMSK = 537395212;
literal IO440$AB_INTREQ = 537395215;
literal IO440$AB_INTCLR = 537395215;
literal IO440$AW_DIAGDISP = 537395216;
literal IO440$AL_PARCTL = 537395220;
literal IO440$AW_DIAGTIMU = 537395228;
literal IO440$AW_DIAGTIMM = 537395230;
literal IO440$AB_NIADRS = 537460736;
literal IO440$AB_NIADRE = 537460863;
literal IO440$AW_SERCSR = 537526272;
literal IO440$AW_SERBUF = 537526276;
literal IO440$AW_SERLPR = 537526276;
literal IO440$AW_SERTCR = 537526280;
literal IO440$AW_SERMSR = 537526284;
literal IO440$AW_SERTDR = 537526284;
literal IO440$AW_DZLPR0 = 537526288;
literal IO440$AW_DZLPR1 = 537526292;
literal IO440$AW_DZLPR2 = 537526296;
literal IO440$AW_DZLPR3 = 537526300;
literal IO440$AL_TODSEC = 537591808;
literal IO440$AL_TODSAL = 537591812;
literal IO440$AL_TODMIN = 537591816;
literal IO440$AL_TODMAL = 537591820;
literal IO440$AL_TODHR = 537591824;
literal IO440$AL_TODHAL = 537591828;
literal IO440$AL_TODDWK = 537591832;
literal IO440$AL_TODDAY = 537591836;
literal IO440$AL_TODMON = 537591840;
literal IO440$AL_TODYR = 537591844;
literal IO440$AL_TODCSA = 537591848;
literal IO440$AL_TODCSB = 537591852;
literal IO440$AL_TODCSC = 537591856;
literal IO440$AL_TODCSD = 537591860;
literal IO440$AB_RAMST = 537591864;
literal IO440$AB_CPMBX = 537591864;
literal IO440$AB_CPFLG = 537591868;
literal IO440$AB_LK201 = 537591872;
literal IO440$AB_CONID = 537591876;
literal IO440$AL_SCRPTR = 537591880;
literal IO440$AL_BATCHK = 537591944;
literal IO440$AL_TRGPSW = 537591960;
literal IO440$AL_BOOFLG = 537591976;
literal IO440$AB_SCRLEN = 537591992;
literal IO440$AB_SCSI = 537591996;
literal IO440$AL_BOOLEN = 537592000;
literal IO440$AL_BOODEV = 537592004;
literal IO440$AB_RAMEND = 537592060;
literal IO440$AL_SCDADR = 537657344;
literal IO440$AB_SCDDIR = 537657356;
literal IO440$AL_SCSIS = 537657472;
literal IO440$AL_SCSIE = 537657535;
literal IO440$AB_SNDPS = 537722880;
literal IO440$AB_SNDPE = 537722887;
literal IO440$AW_NIRDP = 537788416;
literal IO440$AW_NIRAP = 537788420;
literal IO440$AL_LCGREGS = 537919488;
literal IO440$AL_LCGREGE = 538181631;
literal IO440$AL_INVSING = 537926144;
literal IO440$AL_INVALL = 537926152;
literal IO440$AL_INVSTAT = 537926160;
literal IO440$AL_MEMCNFG = 537925632;
literal IO440$AL_MEMSTAT = 537925636;
literal IO440$AL_MEMCUR = 537925640;
literal IO440$AL_MEMERR = 537925644;
literal IO440$AL_SOCCTS = 538247168;
literal IO440$AL_SOCCTE = 538248191;
literal IO440$AL_SOCCDS = 538248192;
literal IO440$AL_SOCCDE = 538249215;
literal IO440$AL_BEHR = 538249216;
literal IO440$AB_LCGROMS = 538181632;
literal IO440$AB_LCGROME = 538443775;
literal IO440$AL_LCGFIFS = 538443776;
literal IO440$AL_LCGFIFE = 538968063;
literal IO440$AL_INVFLS = 538968064;
literal IO440$AL_INVFLE = 538984447;
literal IO440$AL_FRMBUFS = 553648128;
literal IO440$AL_FRMBUFE = 570425343;
literal IO440$AL_OPTADS = 738197504;
literal IO440$AL_OPTADE = 754974719;
literal IO440$AB_SYNCROMS = 739246080;
literal IO440$AB_SYNCROME = 739508223;
literal IO440$AL_SYNCRST = 754974716;
literal IO440$AL_BUSADP = 805306368;
literal IO440$AL_ASYNCSR = 1040187392;
literal IO440$AB_ASYNCROMS = 1040252928;
literal IO440$AB_ASYNCROME = 1040383999;
literal IO440$AL_WCFGREG = 1040449536;
 
!*** MODULE $IO46DEF ***
literal IO46$AL_CACH2DS = 134217728;
literal IO46$AL_CACH2DE = 134479871;
literal IO46$AL_DMAPS = 536870912;
literal IO46$AL_DMAPE = 537001983;
literal IO46$AW_CFGTST = 537001984;
literal IO46$AB_IORESET = 537001984;
literal IO46$AL_SYSTYPE = 537133060;
literal IO46$AB_CPGETCHR = 537133124;
literal IO46$AB_CPMSGOUT = 537133132;
literal IO46$AB_CPPUTCHR = 537133144;
literal IO46$AL_ROMVERS = 537133176;
literal IO46$AB_ROMDIAG = 537133180;
literal IO46$AL_HLTCOD1 = 537395200;
literal IO46$AL_HLTCOD2 = 537395204;
literal IO46$AL_MAPBASE = 537395208;
literal IO46$AB_INTMSK = 537395212;
literal IO46$AB_INTREQ = 537395215;
literal IO46$AB_INTCLR = 537395215;
literal IO46$AW_DIAGDISP = 537395216;
literal IO46$AL_PARCTL = 537395220;
literal IO46$AW_DIAGTIMU = 537395228;
literal IO46$AW_DIAGTIMM = 537395230;
literal IO46$AB_NIADRS = 537460736;
literal IO46$AB_NIADRE = 537460863;
literal IO46$AW_SERCSR = 537526272;
literal IO46$AW_SERBUF = 537526276;
literal IO46$AW_SERLPR = 537526276;
literal IO46$AW_SERTCR = 537526280;
literal IO46$AW_SERMSR = 537526284;
literal IO46$AW_SERTDR = 537526284;
literal IO46$AW_DZLPR0 = 537526288;
literal IO46$AW_DZLPR1 = 537526292;
literal IO46$AW_DZLPR2 = 537526296;
literal IO46$AW_DZLPR3 = 537526300;
literal IO46$AL_TODSEC = 537591808;
literal IO46$AL_TODSAL = 537591812;
literal IO46$AL_TODMIN = 537591816;
literal IO46$AL_TODMAL = 537591820;
literal IO46$AL_TODHR = 537591824;
literal IO46$AL_TODHAL = 537591828;
literal IO46$AL_TODDWK = 537591832;
literal IO46$AL_TODDAY = 537591836;
literal IO46$AL_TODMON = 537591840;
literal IO46$AL_TODYR = 537591844;
literal IO46$AL_TODCSA = 537591848;
literal IO46$AL_TODCSB = 537591852;
literal IO46$AL_TODCSC = 537591856;
literal IO46$AL_TODCSD = 537591860;
literal IO46$AB_RAMST = 537591864;
literal IO46$AB_CPMBX = 537591864;
literal IO46$AB_CPFLG = 537591868;
literal IO46$AB_LK201 = 537591872;
literal IO46$AB_CONID = 537591876;
literal IO46$AL_SCRPTR = 537591880;
literal IO46$AL_BATCHK = 537591944;
literal IO46$AL_TRGPSW = 537591960;
literal IO46$AL_BOOFLG = 537591976;
literal IO46$AB_SCRLEN = 537591992;
literal IO46$AB_SCSI = 537591996;
literal IO46$AL_BOOLEN = 537592000;
literal IO46$AL_BOODEV = 537592004;
literal IO46$AB_RAMEND = 537592060;
literal IO46$AL_SCDADR = 537657344;
literal IO46$AB_SCDDIR = 537657356;
literal IO46$AL_SCSIS = 537657472;
literal IO46$AL_SCSIE = 537657535;
literal IO46$AB_SNDPS = 537722880;
literal IO46$AB_SNDPE = 537722887;
literal IO46$AW_NIRDP = 537788416;
literal IO46$AW_NIRAP = 537788420;
literal IO46$AL_LCGREGS = 537919488;
literal IO46$AL_LCGREGE = 538181631;
literal IO46$AL_INVSING = 537926144;
literal IO46$AL_INVALL = 537926152;
literal IO46$AL_INVSTAT = 537926160;
literal IO46$AL_MEMCNFG = 537925632;
literal IO46$AL_MEMSTAT = 537925636;
literal IO46$AL_MEMCUR = 537925640;
literal IO46$AL_MEMERR = 537925644;
literal IO46$AB_LCGROMS = 538181632;
literal IO46$AB_LCGROME = 538443775;
literal IO46$AL_LCGFIFS = 538443776;
literal IO46$AL_LCGFIFE = 538968063;
literal IO46$AL_INVFLS = 538968064;
literal IO46$AL_INVFLE = 539099135;
literal IO46$AL_FRMBUFS = 553648128;
literal IO46$AL_FRMBUFE = 570425343;
literal IO46$AL_CACH2TS = 754974720;
literal IO46$AL_CACH2TE = 755236863;
literal IO46$AL_SCCR = 587202560;
literal IO46$AL_MEMALTS = 603979776;
literal IO46$AL_MEMALTE = 612368383;
literal IO46$AL_OPTADS = 738197504;
literal IO46$AL_OPTADE = 754974719;
literal IO46$AB_SYNCROMS = 739246080;
literal IO46$AB_SYNCROME = 739508223;
literal IO46$AL_SYNCRST = 754974716;
literal IO46$AL_BUSADP = 805306368;
literal IO46$AL_TURBO = 805306368;
literal IO46$AL_TURBOMAPS = 897581056;
literal IO46$AL_TURBOCSR = 914358272;
literal IO46$AL_ASYNCSR = 1040187392;
literal IO46$AB_ASYNCROMS = 1040252928;
literal IO46$AB_ASYNCROME = 1040383999;
literal IO46$AL_WCFGREG = 1040449536;
 
!*** MODULE $IO49DEF ***
literal IO49$AL_SGEC = 536903680;
literal IO49$AB_ROM = 537133056;
literal IO49$S_ROM = 524288;
literal IO49$AL_SIDEX = 537133060;
literal IO49$AL_GETCHAR = 537133064;
literal IO49$AL_OUTMSG = 537133068;
literal IO49$AL_SYSTYPE = 537133060;
literal IO49$AB_CPGETCHR = 537133124;
literal IO49$AB_CPMSGOUT = 537133132;
literal IO49$AB_CPPUTCHR = 537133144;
literal IO49$AL_ROMVERS = 537133176;
literal IO49$AB_ROMDIAG = 537133180;
literal IO49$AL_SPXDIAG = 538181632;
literal IO49$S_SPXDIAG = 262144;
literal IO49$AL_MODR = 553713664;
literal IO49$S_MODR = 32768;
literal IO49$AL_MEMCON = 553746432;
literal IO49$AL_MEMSIG = 553746464;
literal IO49$AL_MEAR = 553746496;
literal IO49$AL_MESR = 553746500;
literal IO49$AL_MMCDSR = 553746504;
literal IO49$AL_MOAMR = 553746508;
literal IO49$AL_CESR = 553779200;
literal IO49$AL_CMCDSR = 553779204;
literal IO49$AL_CSEAR1 = 553779208;
literal IO49$AL_CSEAR2 = 553779212;
literal IO49$AL_CIOEAR1 = 553779216;
literal IO49$AL_CIOEAR2 = 553779220;
literal IO49$AL_CNEAR = 553779224;
literal IO49$AB_SYNCOMM = 603979776;
literal IO49$S_SYNCOMM = 16777216;
literal IO49$AB_SYNCROMS = 605028352;
literal IO49$AB_SYNCROME = 605290495;
literal IO49$AL_SYNCRST = 620756988;
literal IO49$AW_SER_CSR = 620756992;
literal IO49$AW_SER_RBUF = 620756996;
literal IO49$AW_SER_LPR = 620756996;
literal IO49$AW_SER_TCR = 620757000;
literal IO49$AW_SER_MSR = 620757004;
literal IO49$AW_SER_TDR = 620757004;
literal IO49$AW_WAT_SEC = 624951296;
literal IO49$AW_WAT_ALMS = 624951300;
literal IO49$AW_WAT_MIN = 624951304;
literal IO49$AW_WAT_ALMM = 624951308;
literal IO49$AW_WAT_HOUR = 624951312;
literal IO49$AW_WAT_ALMH = 624951316;
literal IO49$AW_WAT_DOW = 624951320;
literal IO49$AW_WAT_DAY = 624951324;
literal IO49$AW_WAT_MON = 624951328;
literal IO49$AW_WAT_YEAR = 624951332;
literal IO49$AW_WAT_CSRA = 624951336;
literal IO49$AW_WAT_CSRB = 624951340;
literal IO49$AW_WAT_CSRC = 624951344;
literal IO49$AW_WAT_CSRD = 624951348;
literal IO49$AW_RAMST = 624951352;
literal IO49$AB_CPMBX = 624951352;
literal IO49$AB_CPFLG = 624951356;
literal IO49$AB_LK201 = 624951360;
literal IO49$AB_CONID = 624951364;
literal IO49$AL_SCRPTR = 624951368;
literal IO49$AL_BATCHK = 624951432;
literal IO49$AL_TRGPSW = 624951448;
literal IO49$AL_BOOFLG = 624951464;
literal IO49$AB_SCRLEN = 624951480;
literal IO49$AB_SCSI = 624951484;
literal IO49$AL_BOOLEN = 624951488;
literal IO49$AL_BOODEV = 624951492;
literal IO49$AB_RAMEND = 624951548;
literal IO49$AW_CFG = 629145600;
literal IO49$AW_DIAGDISP = 629145604;
literal IO49$AL_SCDADR = 633339904;
literal IO49$AL_SCDDIR = 633339908;
literal IO49$AB_INTMSK = 633339912;
literal IO49$AB_INTREQ = 633339916;
literal IO49$AB_INTCLR = 633339916;
literal IO49$AB_IORESET = 633339920;
literal IO49$AB_SCSICSR = 637534336;
literal IO49$AB_SNDPS = 645922816;
literal IO49$AB_SNDPE = 645922823;
literal IO49$AL_SCSIMAPS = 654311424;
literal IO49$S_SCSIMAP = 32768;
literal IO49$AB_NISAROM = 662700032;
literal IO49$AL_SPXJCHIP = 671088640;
literal IO49$S_SPXJCHIP = 33554432;
literal IO49$AL_SPXBRK = 704643072;
literal IO49$AB_SPXROM = 705691648;
literal IO49$S_SPXROM = 524288;
literal IO49$AL_BUSADAP = 805306368;
literal IO49$S_BUSADAP = 134217728;
literal IO49$AL_SPXMOD = 939524096;
literal IO49$S_SPXMOD = 29360128;
literal IO49$AB_TURBOROMS = 905969664;
literal IO49$AB_TURBOROME = 914358271;
literal IO49$AL_TURBO = 805306368;
literal IO49$AL_TURBOMAPS = 897581056;
literal IO49$AL_TURBOCSR = 914358272;
 
!*** MODULE $IO520DEF ***
!  MISC.
literal IO520$AL_CPUEEPROM = 536870912; !  CPU EEPROM
literal IO520$AL_SIDEX = 537133060;     !  Extended SID
literal IO520$AL_CPUSCRP = 553648128;   !  CPU scratch pad (8kb)
literal IO520$AL_RSTPAG = 553655808;    !  Reset page
literal IO520$AL_RSTPC = 553656308;     !  Reset PC
literal IO520$AL_RSTCOM = 553656312;    !  Reset complement of flags
literal IO520$AL_RSTFLAG = 553656316;   !  Reset flag
!  MEMORY CONTROLLER	
literal IO520$AL_MEMCTL = 562036736;    !  Control and status
literal IO520$AL_MEMDIAG = 562036740;   !  Diagnostic error
literal IO520$AL_SYSFLT = 562036744;    !  System fault error
literal IO520$AL_BUSTIM = 562036748;    !  Bus timeout - NSC
literal IO520$AL_CACHE = 562036752;     !  Cache - NSC
literal IO520$AL_NVUPD = 562036756;     !  NVRAM update register - NSC
literal IO520$AL_SYSADR = 562036760;    !  System fault error address
literal IO520$AL_SOFRST = 566231040;    !  Soft Reset register
literal IO520$AL_MEMCTLW = 564133888;   !  Control and status wait
literal IO520$AL_MEMDIAGW = 564133892;  !  Diagnostic error wait
literal IO520$AL_SYSFLTW = 564133896;   !  System fault error wait
literal IO520$AL_BUSTIMW = 564133900;   !  Bus timeout - NSC wait
literal IO520$AL_CACHEW = 564133904;    !  Cache - NSC wait
literal IO520$AL_NVUPDW = 564133908;    !  NVRAM update register - NSC wait
literal IO520$AL_SYSADRW = 564133912;   !  System fault error
literal IO520$AL_BLKHOLE = 568328192;   !  Black hole register
!  DMA registers	
literal IO520$AL_DMASTL = 570425344;    !  Memory subtransfer length
literal IO520$AL_DMACTL = 570490880;    !  DMA control
literal IO520$AL_DMASTA = 570556416;    !  DMA status
literal IO520$AL_DMAMBCD = 570621952;   !  Memory byte count and direction
literal IO520$AL_DMAMBCDA = 579010560;  !  Memory byte count and direction Zone A
literal IO520$AL_DMAMBCDB = 713228288;  !  Memory byte count and direction Zone B
literal IO520$AL_DMADIAG = 570687488;   !  Diagnostic
literal IO520$AL_DMAQAP = 570753024;    !  Queue address pointer
literal IO520$AL_DMAMMA = 570818560;    !  Main Memory address
literal IO520$AL_DMAMMAA = 579207168;   !  Main Memory address Zone A
literal IO520$AL_DMAMMAB = 713424896;   !  Main Memory address Zone B
literal IO520$AL_DMAQEP = 570884096;    !  Queue entry pointer
literal IO520$AL_DMAID = 570949632;     !  ID
literal IO520$AL_DMAEOQ = 571015168;    !  End of queue
literal IO520$AL_DMAARB = 571080704;    !  Arbiter control
literal IO520$AL_DMAECC = 571146240;    !  ECC
literal IO520$AL_DMAREF = 571211776;    !  Refresh
!  CLINK
literal IO520$AL_INTVEC0 = 587202560;   !  Interrupt Vector 0
literal IO520$AL_INTVEC1 = 587202564;   !  Interrupt Vector 1
literal IO520$AL_INTVEC2 = 587202568;   !  Interrupt Vector 2
literal IO520$AL_INTVEC3 = 587202572;   !  Interrupt Vector 3
literal IO520$AL_WINVEC = 587202588;    !  Winning Vector
literal IO520$AL_IRQ = 587202592;       !  IRQ for vectors 0-3
literal IO520$AL_IMR = 587202596;       !  Interrupt mask 
literal IO520$AL_CLIERR = 587268096;    !  Error register
literal IO520$AL_TIMINT = 587333632;    !  Timer interval - NSC
literal IO520$AL_SERREQ = 587399168;    !  Serial request
literal IO520$AL_SERREP = 587464704;    !  Serial reply
literal IO520$AL_SERQUE = 587530240;    !  Serial queue
literal IO520$AL_SERCSR = 587595776;    !  Serial CSR
literal IO520$AL_TIMCTL = 587661312;    !  Timer control - NSC
literal IO520$AL_TIMNXT = 587792384;    !  Timer next interval - NSC
literal IO520$AL_PROGDIV = 587857920;   !  Programable divider _ NSC
literal IO520$AL_PARCOMM = 587923456;   !  Parallel communications
!  write only.	
literal IO520$AL_RESET = 588185600;     !  CPU/zone hard reset
literal IO520$AL_SICSA = 595591168;     !  System Interupt Control Register
!  Zone A 
literal IO520$AL_SICSB = 729808896;     !  System Interupt Control Register
!  Zone B 
literal IO520$AL_PCOMMA = 596312064;    !  Parallel comm register Zone a 
literal IO520$AL_PCOMMB = 730529792;    !  Parallel comm register zone b
literal IO520$AL_PCSRA = 596377600;     !  Parallel CSR register Zone a 
literal IO520$AL_PCSRB = 730595328;     !  Parallel CSR register zone b
literal IO520$AL_IORSTA = 596508672;    !  IO hard reset zone A
literal IO520$AL_IORSTB = 730726400;    !  IO hard reset zone B
literal IO520$AL_SYNCHR = 600637440;    !  Synch Reset
literal IO520$AL_CLIERRW = 600768512;   !  Error register- world address
!  Memory Module
literal IO520$AL_MEMMOD4 = 603979776;   !  Memory Module slot 4 
literal IO520$AL_MEMMOD5 = 620756992;   !  Memory Module slot 5
literal IO520$AL_MEMMOD6 = 637534208;   !  Memory Module slot 6
literal IO520$AL_MEMMOD7 = 654311424;   !  Memory Module slot 7
literal IO550$AL_TAG = 538247168;       !  Cache Tag Store
literal IO550$S_TAG = 1024;             !  Size of Cache Tag Store
literal IO550$AL_DATA = 538248192;      !  Cache Data Store
literal IO550$S_DATA = 1024;            !  Size of Cache Data Store
literal IO550$AL_BEHR = 538249216;      !  Bank Enable/Hit Register
 
!*** MODULE $IO8NNDEF ***
! +
!  I/O SPACE LAYOUT FOR 8NNN CPU
! -
!  NBIA Type code found in NAC field
literal IO8NN$K_NBIA = 16;              !  NBIA type
literal IO8NN$C_NBIA = 16;              !  NBIA type
literal IO8NN$AL_IOBASE = 536870912;    !  Start of I/O space
literal IO8NN$AL_NBIA_0 = 536870912;    !  I/O space for first NBIA
literal IO8NN$AL_NBIB_0 = 536870912;    !  I/O space 1st BI
literal IO8NN$AL_NBIB_1 = 570425344;    !  I/O space 2nd BI
literal IO8NN$AL_NBIA_1 = 603979776;    !  I/O space for second NBIA
literal IO8NN$AL_NBIB_2 = 603979776;    !  I/O space 3rd BI
literal IO8NN$AL_NBIB_3 = 637534208;    !  I/O space 4th BI
literal IO8NN$AL_NMI_MEM = 1040187392;  !  Nautilus Memory
literal IO8NN$AL_NMI_CSR0 = 524288;     !  offset to NMI CSR0
literal IO8NN$AL_PERNMI = 67108864;     !  I/O space per NMI nexus
literal IO8NN$AL_PERNBIA = 262144;      !  offset to next NBIA
literal IO8NN$AL_PERNBIB = 131072;      !  offset to next NBIB
literal IO8NN$AL_PERNEX = 8192;         !  # bytes of register space/nexus 
literal IO8NN$AL_NNEX = 16;             !  # of Nexuses per BI
literal IO8NN$AL_UB0SP = 1048576;       !  First unibus space
!  Define BI address space offsets and lengths
literal IO8NN$AL_BRDCST = 131072;       !  offset to broadcast space
literal IO8NN$AL_BTROM = 262144;        !  offset to boot rom space
literal IO8NN$AL_NODESP = 4194304;      !  offset to BI node window 0
literal IO8NN$AL_NDSPER = 262144;       !  size of BI node window
 
!*** MODULE $IO8PSDEF ***
! +
!  I/O SPACE LAYOUT FOR 8PS CPU
!  
!  Note: These are only the definitions that are different or additional for
! 	 8PS support. Most references to 8PS I/O space are doen with 8NN
! 	 symbols.
! -
literal IO8PS$AL_NBIA_2 = 671088640;    !  I/O space for third NBIA 
literal IO8PS$AL_NBIB_4 = 671088640;    !  I/O space 5th BI
literal IO8PS$AL_NBIB_5 = 704643072;    !  I/O space 6th BI
! 
!  STAR NBW CSR ADDRESSES
! 
literal IO8PS$AL_SCSR0 = 939524096;     !  STAR NBW CSR0
literal IO8PS$AL_SCSR1 = 939524104;     !  STAR NBW CSR1
literal IO8PS$AL_SCSR2 = 939526144;     !  STAR NBW CSR2
literal IO8PS$AL_SCSR3 = 939526152;     !  STAR NBW CSR3
literal IO8PS$AL_SCSR4 = 940048384;     !  STAR NBW CSR4
literal IO8PS$AL_SCSR7 = 940050440;     !  STAR NBW CSR7
! 
!  NEMO NBW CSR ADDRESSES
! 
literal IO8PS$AL_NCSR0 = 973078528;     !  NEMO NBW CSR0
literal IO8PS$AL_NCSR1 = 973078536;     !  NEMO NBW CSR1
literal IO8PS$AL_NCSR2 = 973080576;     !  NEMO NBW CSR2
literal IO8PS$AL_NCSR3 = 973080584;     !  NEMO NBW CSR3
literal IO8PS$AL_NCSR6 = 973604864;     !  NEMO NBW CSR6
literal IO8PS$AL_NCSR7 = 973604872;     !  NEMO NBW CSR7
 
!*** MODULE $IO8SSDEF ***
! +
!  I/O SPACE LAYOUT FOR 11/8SS CPU
! -
!  Define constant addresses 
literal IO8SS$AL_IOBASE = 536870912;    !  Base of I/O space
literal IO8SS$AL_PERNEX = 8192;         !  Size of Register Space/Node
literal IO8SS$AL_NNEX = 16;             !  # of Nodes
literal IO8SS$AL_BRDCST = 537001984;    !  Base of Broadcast Space
literal IO8SS$AL_BTROM = 537133056;     !  Base of Bootrom Space
literal IO8SS$AL_NDPRIV = 537395200;    !  Base of Node Private Space
literal IO8SS$AL_PCNTL = 537427968;     !  Pcntl CSR in Node Private Space
literal IO8SS$AL_NIBUF = 537460736;     !  NI Packet Buffer in Node Private Space
literal IO8SS$AL_EEPROM = 537493504;    !  EEPROM in Node Private Space
literal IO8SS$AL_NIDATA = 537526272;    !  NI Data Register in Node Private Space
literal IO8SS$AL_NIADDR = 537559040;    !  NI ADDR Register in Node Private Space
literal IO8SS$AL_RCX50 = 537591808;     !  RX50 Registers in Node Private Space
literal IO8SS$AL_WATCH = 537624576;     !  Watch Chip in Node Private Space
literal IO8SS$AL_NODESP = 541065216;    !  Node 0 Window Space
literal IO8SS$AL_NDSPER = 262144;       !  Size of Window Space
 
!*** MODULE $IO009DEF ***
! ++
!  I/O SPACE LAYOUT FOR PROCESSOR 009.
! --
!  DEFINE CONSTANT ADDRESSES 
literal IO009$AL_IOBASE = 67108864;     !  START PHYSICAL ADDRESS OF I/O SPACE 
literal IO009$AL_PERNEX = 0;            !  ! BYTES OF REGISTER SPACE/NEXUS 
literal IO009$AL_NNEX = 1;              !  ! NUMBER OF NEXUSES 
 
!*** MODULE $IO60DEF ***
literal IO60$AL_IOBASE = 805306368;     ! Base of I/O space
literal IO60$K_PERNEX = 33554432;       ! Size of Register Space/Node
literal IO60$K_NNEX = 8;                ! Number of Nodes
literal IO60$L_FBIC_BASE = 33553920;    ! Offset to FBIC registers
literal IO60$AL_SYSTYPE = 537133060;    !  System Type
literal IO60$AL_SSC_BASE = 538181632;   !  SSC base address register
literal IO60$AL_SSCCR = 538181648;      !  SSC configuration register
literal IO60$AL_TODR = 538181740;       !  TOY clock
literal IO60$AL_TCR0 = 538181888;       !  Timer 0 Control Register
literal IO60$AL_TIR0 = 538181892;       !  Timer 0 Interval Register
literal IO60$AL_TNIR0 = 538181896;      !  Timer 0 Next Interval Register
literal IO60$AL_TIVR0 = 538181900;      !  Timer 0 Interrupt Vector Register
literal IO60$AL_TCR1 = 538181904;       !  Timer 1 Control Register
literal IO60$AL_TIR1 = 538181908;       !  Timer 1 Interval Register
literal IO60$AL_TNIR1 = 538181912;      !  Timer 1 Next Interval Register
literal IO60$AL_TIVR1 = 538181916;      !  Timer 1 Interrupt Vector Register
literal IO60$AB_NVRS = 538182656;       !  Start of RAM
literal IO60$AB_NVR0 = 538182656;       !  NVRx fields
literal IO60$AB_NVR1 = 538182657;       !   (see $KA60DEF
literal IO60$AB_NVR2 = 538182658;       !    for detail)
literal IO60$AB_SCSI_HOST_ID = 538182848; !  SCSI host ID
literal IO60$AL_CCAPTR = 538182928;     !  Location of CCA pointer
literal IO60$AL_CTSIAPTR = 538182932;   !  Location of CTSIA pointer
literal IO60$AB_CONSOLE_NODE = 538182986;
literal IO60$AB_NVRE = 538183679;       !  End of NVR
literal IO60$AL_INT_BASE = 256;         ! Interrupt base
literal IO60$K_PERINT = 32;             ! Space per slot
literal IO60$AL_QB0SP = 536870912;      !  QBUS I/O space
literal IO60$AL_INTPR0 = 536878912;     !  Arbiter doorbell
literal IO60$AL_INTPR1 = 536878914;     !  Arbiter doorbell #1
literal IO60$AL_INTPR2 = 536878916;     !  Arbiter doorbell #2
literal IO60$AL_INTPR3 = 536878918;     !  Arbiter doorbell #3
literal IO60$AL_INTPR4 = 536878920;     !  Arbiter doorbell #4
literal IO60$AL_INTPR5 = 536878922;     !  Arbiter doorbell #5
literal IO60$AL_INTPR6 = 536878924;     !  Arbiter doorbell #6
literal IO60$AL_INTPR7 = 536878926;     !  Arbiter doorbell #7
literal IO60$AL_SCR = 537395200;        !  System config reg
literal IO60$AL_DSER = 537395204;       !  DMA system error reg
literal IO60$AL_MEAR = 537395208;       !  DMA master error reg
literal IO60$AL_MSER = 537395212;       !  DMA slave error reg
literal IO60$AL_QBMBR = 537395216;      !  QBUS map base address register
literal IO60$AL_QMAPS = 537427968;      !  First QBUS map reg
literal IO60$AL_QMAPE = 537460732;      !  Last QBUS map reg
literal IO60$AL_QB0MEM = 805306368;     !  Start of QBUS memory
literal IO60$AL_FQAMCSR = 811597824;    !  FQAM CSR
literal IO60$L_CACHE_TAG = 15728640;    ! Offset to tag store
literal IO60$L_MODULE_ROM = 14680064;   ! Offset to ROM
literal IO60$L_CPU_FBIC_OFFSET = 16777216; ! Offset to CPU FBICs
literal IO60$L_SII_BASE = 0;            ! SII registers
literal IO60$L_NI_RDP = 2097152;        ! LANCE RDP
literal IO60$L_NI_RAP = 2097156;        ! LANCE RAP
literal IO60$B_SII_RAMS = 4194304;      ! SII RAM start
literal IO60$B_SII_RAME = 4325375;      ! SII RAM end
literal IO60$L_DZ_CSR = 6291456;        ! DZ CSR
literal IO60$L_DZ_RBUF = 6291460;       ! DZ RBUF
literal IO60$L_DZ_LPR = 6291460;        ! DZ LPR
literal IO60$L_DZ_TCR = 6291464;        ! DZ TCR
literal IO60$L_DZ_MSR = 6291468;        ! DZ MSR
literal IO60$L_DZ_TDR = 6291468;        ! DZ TDR
literal IO60$L_IOCSR = 8388608;         ! IOCSR register
literal IO60$B_NI_RAMS = 10485760;      ! LANCE RAM start
literal IO60$B_NI_RAME = 10616831;      ! LANCE RAM end
literal IO60$B_GFX_ROM = 0;             ! Diagnostic/boot ROM
literal IO60$B_GFX_DRAM_WEITEK = 4554752; !  DRAM Weitek output buffer
literal IO60$B_GFX_DRAM_SCB = 4947968;  !  DRAM SCB area
literal IO60$B_GFX_DRAM_SVX = 5237760;  !  DRAM SVX area
literal IO60$B_GFX_IMODE_VRAM = 8388608; ! I mode VRAM
literal IO60$B_GFX_XMODE_VRAM = 25165824; ! X mod VRAM
literal IO60$B_GFX_PATTMEM = 26214400;  ! Pattern memory
literal IO60$B_GFX_TCHIP = 27262976;    ! T chip
literal IO60$B_GFX_DCHIP = 28311552;    ! D chip
literal IO60$B_GFX_ACHIP = 29360128;    ! A chip
literal IO60$C_CVAXMINREV = 3;
literal IO60$K_CVAXMINREV = 3;
literal IO60$C_FBICMINREV = 1;
literal IO60$K_FBICMINREV = 1;
literal IO60$C_UBDELAY = 4;
literal IO60$C_TENUSEC = 3;
 
!*** MODULE $IO650DEF ***
! ++
!  I/O SPACE LAYOUT FOR MAYFAIR CPU
! --
literal IO650$AB_CACH2 = 268435456;     !  2NDARY CACHE
literal IO650$AL_QB0SP = 536870912;     !  ADDR OF QBUS SPACE 
literal IO650$AW_INTPR0 = 536878912;    !  INTERPROC COMMUN REG
!    (ICR) FOR ARBITER
literal IO650$AW_INTPR1 = 536878914;    !  ICR FOR AUXIL 1
literal IO650$AW_INTPR2 = 536878916;    !  ICR FOR AUXIL 2
literal IO650$AW_INTPR3 = 536878918;    !  ICR FOR AUXIL 3
literal IO650$AL_SIDEX = 537133060;     !  SYS ID EXTENSION REG
literal IO650$AL_GETCHAR = 537133064;   !  Console get_character routine
literal IO650$AL_OUTMSG = 537133068;    !  Console output_message routine
literal IO650$AL_CACR = 537411584;      !  Cache Control Register
literal IO650$AL_BDR = 537411588;       !  Boot and Diagnostic Register
literal IO650$AL_QMAPS = 537427968;     !  FIRST QBUS MAP REG
literal IO650$AL_QMAPE = 537460732;     !  LAST QBUS MAP REG
literal IO650$AL_SCR = 537395200;       !  SYSTEM CONFIGURATION REGISTER
literal IO650$AL_DSER = 537395204;      !  DMA SYSTEM ERROR REGISTER
literal IO650$AL_MEAR = 537395208;      !  MASTERERROR ADDRESS REG
literal IO650$AL_SEAR = 537395212;      !  SLAVE ERROR ADDR REG
literal IO650$AL_QBMBR = 537395216;     !  Q-22 BUS MAP BASE ADDRESS REGISTER
literal IO650$AL_MEM0 = 537395456;      !  Main Memory Register 0
literal IO650$AL_MEM16 = 537395520;     !  Main Memory Register 16
literal IO650$AL_MEM17 = 537395524;     !  Main Memory Register 17
literal IO650$AL_SSCBR = 538181632;     !  SSC BASE ADDRESS REGISTER
literal IO650$AL_SSCCR = 538181648;     !  SSC CONFIGURATION REGISTER
literal IO650$AL_CBTCR = 538181664;     !  CDAL BUS TIMEOUT  CONTROL REGISTSER
literal IO650$AL_DLEDR = 538181680;     !  DIAGNOSTIC LED REGISTER
literal IO650$AL_TCR0 = 538181888;      !  Timer 0 Control Register
literal IO650$AL_TIR0 = 538181892;      !  Timer 0 Interval Register
literal IO650$AL_TNIR0 = 538181896;     !  Timer 0 Next Interval Register
literal IO650$AL_TIVR0 = 538181900;     !  Timer 0 Interrupt Vector Register
literal IO650$AL_TCR1 = 538181904;      !  Timer 1 Control Register
literal IO650$AL_TIR1 = 538181908;      !  Timer 1 Interval Register
literal IO650$AL_TNIR1 = 538181912;     !  Timer 1 Next Interval Register
literal IO650$AL_TIVR1 = 538181916;     !  Timer 1 Interrupt Vector Register
literal IO650$AB_NVR = 538182656;       !  PUBLIC NONVOLATIVE RAM AREA
literal IO650$AL_CONSPAGE = 538182672;  !  Pointer to console I/O Vector
literal IO650$AB_NVRE = 538214399;      !  END OF NVR
literal IO650$AL_QB0MEM = 805306368;    !  ADDR OF QBUS MEMORY
 
!*** MODULE $IO640DEF ***
literal IO640$AL_QB0SP = 536870912;     !  ADDR OF QBUS SPACE 
literal IO640$AW_INTPR0 = 536878912;    !  INTERPROC COMMUN REG
!    (ICR) FOR ARBITER
literal IO640$AW_INTPR1 = 536878914;    !  ICR FOR AUXIL 1
literal IO640$AW_INTPR2 = 536878916;    !  ICR FOR AUXIL 2
literal IO640$AW_INTPR3 = 536878918;    !  ICR FOR AUXIL 3
literal IO640$AL_SIDEX = 537133060;     !  SYS ID EXTENSION REG
literal IO640$AL_GETCHAR = 537133064;   !  Console get_character routine
literal IO640$AL_OUTMSG = 537133068;    !  Console output_message routine
literal IO640$AL_SCR = 537395200;       !  SYSTEM CONFIGURATION REGISTER
literal IO640$AL_DSER = 537395204;      !  DMA SYSTEM ERROR REGISTER
literal IO640$AL_MEAR = 537395208;      !  MASTERERROR ADDRESS REG
literal IO640$AL_SEAR = 537395212;      !  SLAVE ERROR ADDR REG
literal IO640$AL_QBMBR = 537395216;     !  Q-22 BUS MAP BASE ADDRESS REGISTER
literal IO640$AL_MEM0 = 537395456;      !  Main Memory Register 0
literal IO640$AL_MEM16 = 537395520;     !  Main Memory Register 16
literal IO640$AL_MEM17 = 537395524;     !  Main Memory Register 17
literal IO640$AL_BDR = 537411588;       !  Boot and Diagnostic Register
literal IO640$AL_NISA = 537412096;      !  NI Station Address ROM
literal IO640$AL_NIRDP = 537412608;     !  NI Register Data Port
literal IO640$AL_NIRAP = 537412612;     !  NI Register Address Port
literal IO640$AL_SII = 537413120;       !  SII registers
literal IO640$AL_QMAPS = 537427968;     !  FIRST QBUS MAP REG
literal IO640$AL_QMAPE = 537460732;     !  LAST QBUS MAP REG
literal IO640$AB_SII_RAM = 537919488;   !  SII RAM BUFFER
literal IO640$AB_SII_RAME = 538050559;  !  END OF SII RAM BUFFER
literal IO640$AB_NI_RAM = 538050560;    !  NI RAM BUFFER
literal IO640$AB_NI_RAME = 538181631;   !  END OF NI RAM BUFFER
literal IO640$AL_SSCBR = 538181632;     !  SSC BASE ADDRESS REGISTER
literal IO640$AL_SSCCR = 538181648;     !  SSC CONFIGURATION REGISTER
literal IO640$AL_CBTCR = 538181664;     !  CDAL BUS TIMEOUT  CONTROL REGISTSER
literal IO640$AL_DLEDR = 538181680;     !  DIAGNOSTIC LED REGISTER
literal IO640$AL_TCR0 = 538181888;      !  Timer 0 Control Register
literal IO640$AL_TIR0 = 538181892;      !  Timer 0 Interval Register
literal IO640$AL_TNIR0 = 538181896;     !  Timer 0 Next Interval Register
literal IO640$AL_TIVR0 = 538181900;     !  Timer 0 Interrupt Vector Register
literal IO640$AL_TCR1 = 538181904;      !  Timer 1 Control Register
literal IO640$AL_TIR1 = 538181908;      !  Timer 1 Interval Register
literal IO640$AL_TNIR1 = 538181912;     !  Timer 1 Next Interval Register
literal IO640$AL_TIVR1 = 538181916;     !  Timer 1 Interrupt Vector Register
literal IO640$AB_NVR = 538182656;       !  PUBLIC NONVOLATIVE RAM AREA
literal IO640$AL_CONSPAGE = 538182672;  !  Pointer to console I/O Vector
literal IO640$AB_NVRE = 538214399;      !  END OF NVR
literal IO640$AL_QB0MEM = 805306368;    !  ADDR OF QBUS MEMORY
 
!*** MODULE $IO660DEF ***
literal IO660$AL_QB0SP = 536870912;
literal IO660$AW_QDSS = 536878848;
literal IO660$AW_IPCR0 = 536878912;
literal IO660$AW_IPCR1 = 536878914;
literal IO660$AW_IPCR2 = 536878916;
literal IO660$AW_IPCR3 = 536878918;
literal IO660$AL_SHAC = 536887808;
literal IO660$AL_SGEC = 536903680;
literal IO660$AB_ROM = 537133056;
literal IO660$S_ROM = 262144;
literal IO660$AL_SIDEX = 537133060;
literal IO660$AL_GETCHAR = 537133064;
literal IO660$AL_OUTMSG = 537133068;
literal IO660$AL_SSHMA = 537133096;
literal IO660$AL_SCR = 537395200;
literal IO660$AL_DSER = 537395204;
literal IO660$AL_QBEAR = 537395208;
literal IO660$AL_DEAR = 537395212;
literal IO660$AL_QBMBR = 537395216;
literal IO660$AL_MEMCON = 537395456;
literal IO660$AL_MMESR = 537395520;
literal IO660$AL_MMCDSR = 537395524;
literal IO660$AL_BDR = 537411584;
literal IO660$AL_QMAP = 537427968;
literal IO660$S_QMAP = 32768;
literal IO660$AL_SSCBR = 538181632;
literal IO660$AL_SSCCR = 538181648;
literal IO660$AL_CBTCR = 538181664;
literal IO660$AL_DLEDR = 538181680;
literal IO660$AL_TCR0 = 538181888;
literal IO660$AL_TIR0 = 538181892;
literal IO660$AL_TNIR0 = 538181896;
literal IO660$AL_TIVR0 = 538181900;
literal IO660$AL_TCR1 = 538181904;
literal IO660$AL_TIR1 = 538181908;
literal IO660$AL_TNIR1 = 538181912;
literal IO660$AL_TIVR1 = 538181916;
literal IO660$AB_NVR = 538182656;
literal IO660$S_NVR = 1024;
literal IO660$AL_CONSPAGE = 538182672;
literal IO660$AL_TAG = 538247168;
literal IO660$S_TAG = 1024;
literal IO660$AL_DATA = 538248192;
literal IO660$S_DATA = 1024;
literal IO660$AL_BEHR = 538249216;
literal IO660$AL_QB0MEM = 805306368;
 
!*** MODULE $IO670DEF ***
literal IO670$AL_QB0SP = 536870912;
literal IO670$AW_QDSS = 536878848;
literal IO670$AW_IPCR0 = 536878912;
literal IO670$AW_IPCR1 = 536878914;
literal IO670$AW_IPCR2 = 536878916;
literal IO670$AW_IPCR3 = 536878918;
literal IO670$AL_SHAC1 = 536887296;
literal IO670$AL_SHAC2 = 536887808;
literal IO670$AL_SGEC = 536903680;
literal IO670$AB_ROM = 537133056;
literal IO670$S_ROM = 262144;
literal IO670$AL_SIDEX = 537133060;
literal IO670$AL_GETCHAR = 537133064;
literal IO670$AL_OUTMSG = 537133068;
literal IO670$AL_SSHMA = 537133096;
literal IO670$AL_SCR = 537395200;
literal IO670$AL_DSER = 537395204;
literal IO670$AL_QBEAR = 537395208;
literal IO670$AL_DEAR = 537395212;
literal IO670$AL_QBMBR = 537395216;
literal IO670$AL_MEMCON = 537395456;
literal IO670$AL_MEMSIG = 537395520;
literal IO670$AL_RMESR = 537395584;
literal IO670$AL_RMEAR = 537395588;
literal IO670$AL_RIOEAR = 537395592;
literal IO670$AL_CEAR = 537395596;
literal IO670$AL_MCDSR = 537395600;
literal IO670$AL_BDR = 537411584;
literal IO670$AL_QMAP = 537427968;
literal IO670$S_QMAP = 32768;
literal IO670$AL_SSCBR = 538181632;
literal IO670$AL_SSCCR = 538181648;
literal IO670$AL_CBTCR = 538181664;
literal IO670$AL_DLEDR = 538181680;
literal IO670$AL_TCR0 = 538181888;
literal IO670$AL_TIR0 = 538181892;
literal IO670$AL_TNIR0 = 538181896;
literal IO670$AL_TIVR0 = 538181900;
literal IO670$AL_TCR1 = 538181904;
literal IO670$AL_TIR1 = 538181908;
literal IO670$AL_TNIR1 = 538181912;
literal IO670$AL_TIVR1 = 538181916;
literal IO670$AB_NVR = 538182656;
literal IO670$S_NVR = 1024;
literal IO670$AL_CONSPAGE = 538182672;
literal IO670$AL_QB0MEM = 805306368;
 
!*** MODULE $IO690DEF ***
literal IO690$AL_QB0SP = 536870912;
literal IO690$AW_QDSS = 536878848;
literal IO690$AW_IPCR0 = 536878912;
literal IO690$AW_IPCR1 = 536878914;
literal IO690$AW_IPCR2 = 536878916;
literal IO690$AW_IPCR3 = 536878918;
literal IO690$AL_SHAC1 = 536887296;
literal IO690$AL_SHAC2 = 536887808;
literal IO690$AL_SGEC = 536903680;
literal IO690$AB_ROM = 537133056;
literal IO690$S_ROM = 262144;
literal IO690$AL_SIDEX = 537133060;
literal IO690$AL_GETCHAR = 537133064;
literal IO690$AL_OUTMSG = 537133068;
literal IO690$AL_SSHMA = 537133096;
literal IO690$AL_SCR = 537395200;
literal IO690$AL_DSER = 537395204;
literal IO690$AL_QBEAR = 537395208;
literal IO690$AL_DEAR = 537395212;
literal IO690$AL_QBMBR = 537395216;
literal IO690$AL_BDR = 537411584;
literal IO690$AL_QMAP = 537427968;
literal IO690$S_QMAP = 32768;
literal IO690$AL_SSCBR = 538181632;
literal IO690$AL_SSCCR = 538181648;
literal IO690$AL_CBTCR = 538181664;
literal IO690$AL_DLEDR = 538181680;
literal IO690$AL_TCR0 = 538181888;
literal IO690$AL_TIR0 = 538181892;
literal IO690$AL_TNIR0 = 538181896;
literal IO690$AL_TIVR0 = 538181900;
literal IO690$AL_TCR1 = 538181904;
literal IO690$AL_TIR1 = 538181908;
literal IO690$AL_TNIR1 = 538181912;
literal IO690$AL_TIVR1 = 538181916;
literal IO690$AB_NVR = 538182656;
literal IO690$S_NVR = 1024;
literal IO690$AL_CONSPAGE = 538182672;
literal IO690$AL_MODR = 553713664;
literal IO690$S_MODR = 32768;
literal IO690$AL_MEMCON = 553746432;
literal IO690$AL_MEMSIG = 553746464;
literal IO690$AL_MEAR = 553746496;
literal IO690$AL_MESR = 553746500;
literal IO690$AL_MMCDSR = 553746504;
literal IO690$AL_MOAMR = 553746508;
literal IO690$AL_CESR = 553779200;
literal IO690$AL_CMCDSR = 553779204;
literal IO690$AL_CSEAR1 = 553779208;
literal IO690$AL_CSEAR2 = 553779212;
literal IO690$AL_CIOEAR1 = 553779216;
literal IO690$AL_CIOEAR2 = 553779220;
literal IO690$AL_CNEAR = 553779224;
literal IO690$AL_QB0MEM = 805306368;
 
!*** MODULE $IO9AQDEF ***
! +
!  I/O SPACE LAYOUT FOR 9AQ CPU
! -
!  ***Note SDL has problems with larger than 32 bit integers***
! 	In this definition, it might be convenient to express several
! 	34 bit addresses.  However instead of doing that, we rather
! 	define the 25 bit PFNs associated with these addresses.  The
! 	natural way that one might define these would be to equate
! 	the symbol to the 34 bit (or more precisely, the nine digit hex
! 	number with the two high order bits zero) quantity divided by 200
! 	hex.  However due to SDL's difficulty with these quantities, we
! 	instead express the value as a 7 digit (28 bits) hex number divided
! 	by 2.  That is, one will see values such as +%x3E00000/%x2, which
! 	really mean +%x3E0000000/%x200.
!  Define constant addresses 
!  Base of I/O space - first the true PFN for the 34 bit address then 30 bit address used
!  during VMB time when we arre running unmapped.
literal IO9AQ$AL_IOBASE_PFN = 32505856; !  34 bit address PFN
literal IO9AQ$AL_IOBASE_30 = 536870912; !  30 bit address
!  XMI0 Node Space base - region of 16 512KB node spaces for the upto 16 XMI
!  devices that can possibly be addressed on XMI number 0.  First we have the
!  true 34 bit address followed by the 30 bit address.
literal IO9AQ$AL_XMI0_NODESP_PFN = 32505856; !  34 bit address PFN
literal IO9AQ$AL_XMI0_NODESP_30 = 536870912; !  30 bit address
!  Likewise for XMI1, XMI2 and XMI3
literal IO9AQ$AL_XMI1_NODESP_PFN = 32522240; !  34 bit address PFN
literal IO9AQ$AL_XMI1_NODESP_30 = 545259520; !  30 bit address
literal IO9AQ$AL_XMI2_NODESP_PFN = 32538624; !  34 bit address PFN
literal IO9AQ$AL_XMI2_NODESP_30 = 553648128; !  30 bit address
literal IO9AQ$AL_XMI3_NODESP_PFN = 32555008; !  34 bit address PFN
literal IO9AQ$AL_XMI3_NODESP_30 = 562036736; !  30 bit address
!  Size of each of the upto 64 possible XMI node spaces - This could be used with
!  XMI0_NODESP to index into the proper node space.  Also the maximum number
!  of XMI nodes supported by the hardware architecture
literal IO9AQ$C_XMI_NODESP_SIZ = 524288; !  Size of XMI nodespace
literal IO9AQ$C_N_XMI_NEX = 64;         !  # of Nodes
!  Beginning of the upto 14 XBI Window Spaces.
literal IO9AQ$AL_XBI0_WINDSP_PFN = 32571392; !  34 bit address PFN
literal IO9AQ$AL_XBI0_WINDSP_30 = 570425344; !  30 bit address
!  Other 13 XBI Window Spaces
literal IO9AQ$AL_XBI1_WINDSP_PFN = 32636928; !  34 bit address PFN
literal IO9AQ$AL_XBI1_WINDSP_30 = 603979776; !  30 bit address
literal IO9AQ$AL_XBI2_WINDSP_PFN = 32702464; !  34 bit address PFN
literal IO9AQ$AL_XBI2_WINDSP_30 = 637534208; !  30 bit address
literal IO9AQ$AL_XBI3_WINDSP_PFN = 32768000; !  34 bit address PFN
literal IO9AQ$AL_XBI3_WINDSP_30 = 671088640; !  30 bit address
literal IO9AQ$AL_XBI4_WINDSP_PFN = 32833536; !  34 bit address PFN
literal IO9AQ$AL_XBI4_WINDSP_30 = 704643072; !  30 bit address
literal IO9AQ$AL_XBI5_WINDSP_PFN = 32899072; !  34 bit address PFN
literal IO9AQ$AL_XBI5_WINDSP_30 = 738197504; !  30 bit address
literal IO9AQ$AL_XBI6_WINDSP_PFN = 32964608; !  34 bit address PFN
literal IO9AQ$AL_XBI6_WINDSP_30 = 771751936; !  30 bit address
literal IO9AQ$AL_XBI7_WINDSP_PFN = 33030144; !  34 bit address PFN
literal IO9AQ$AL_XBI7_WINDSP_30 = 805306368; !  30 bit address
literal IO9AQ$AL_XBI8_WINDSP_PFN = 33095680; !  34 bit address PFN
literal IO9AQ$AL_XBI8_WINDSP_30 = 570425344; !  30 bit address
literal IO9AQ$AL_XBI9_WINDSP_PFN = 33161216; !  34 bit address PFN
literal IO9AQ$AL_XBI9_WINDSP_30 = 872415232; !  30 bit address
literal IO9AQ$AL_XBIA_WINDSP_PFN = 33226752; !  34 bit address PFN
literal IO9AQ$AL_XBIA_WINDSP_30 = 905969664; !  30 bit address
literal IO9AQ$AL_XBIB_WINDSP_PFN = 33292288; !  34 bit address PFN
literal IO9AQ$AL_XBIB_WINDSP_30 = 939524096; !  30 bit address
literal IO9AQ$AL_XBIC_WINDSP_PFN = 33357824; !  34 bit address PFN
literal IO9AQ$AL_XBIC_WINDSP_30 = 973078528; !  30 bit address
literal IO9AQ$AL_XBID_WINDSP_PFN = 33423360; !  34 bit address PFN
literal IO9AQ$AL_XBID_WINDSP_30 = 1006632960; !  30 bit address
!  Size of each XBI Window and the maximum number of XBI nodes supported by hardware
literal IO9AQ$C_XBI_WIND_SIZ = 33554432; !  Size of I/O adap space
literal IO9AQ$C_XBINEX = 14;            !  Max # of XBI Nodes
!  Define BI address space offsets and lengths
literal IO9AQ$C_BINODSIZ = 8192;        !  size of BI node space
literal IO9AQ$C_BIWINDOW = 4194304;     !  offset to BI node window 0
literal IO9AQ$C_BIWSIZ = 262144;        !  size of BI node window
literal IO9AQ$C_BINODNUM = 16;          !  Max # of BI Nodes per BI
!  Define the 4 XJA private spaces
literal IO9AQ$AL_XJA0_PRIVSP_PFN = 33488896; !  34 bit address PFN
literal IO9AQ$AL_XJA0_PRIVSP_30 = 1040187392; !  30 bit address
literal IO9AQ$AL_XJA1_PRIVSP_PFN = 33489920; !  34 bit address PFN
literal IO9AQ$AL_XJA1_PRIVSP_30 = 1040711680; !  30 bit address
literal IO9AQ$AL_XJA2_PRIVSP_PFN = 33490944; !  34 bit address PFN
literal IO9AQ$AL_XJA2_PRIVSP_30 = 1041235968; !  30 bit address
literal IO9AQ$AL_XJA3_PRIVSP_PFN = 33491968; !  34 bit address PFN
literal IO9AQ$AL_XJA3_PRIVSP_30 = 1041760256; !  30 bit address
literal IO9AQ$C_XJA_PRIVSP_SIZ = 524288; !  Size of each
!   XJA private space
!  JBOX/SPU Register Space
literal IO9AQ$AL_JBOX_REGSP_PFN = 33492992; !  34 bit address PFN
literal IO9AQ$AL_JBOX_REGSP_30 = 1042284544; !  30 bit address
 
!*** MODULE $IO9CCDEF ***
! +
!  I/O SPACE LAYOUT FOR 11/9CC CPU
! -
!  Define constant addresses 
literal IO9CC$AL_IOBASE = 536870912;    !  Base of I/O space
literal IO9CC$AL_XMI_PRIV = 536870912;  !  XMI Private space
literal IO9CC$AL_SYSTYPE = 537133060;   !  MicroVAX system type
!  register
literal IO9CC$AL_SSCBASE = 538181632;   !  SSC base register
literal IO9CC$AL_CONSEL = 538181680;    !  SSC CONSEL register
literal IO9CC$AL_TIMERS = 538181888;    !  Programmable Timers
literal IO9CC$L_CSR1ADMR = 308;         !  CSR1 ADMR
literal IO9CC$AL_IP_IVINTR = 553713664; !  Interprocessor Interrupts
literal IO9CC$AL_WE_IVINTR = 553779200; !  Write Error IP
literal IO9CC$AL_NODESP = 562036736;    !  Base of XMI node space
literal IO9CC$C_PERNEX = 524288;        !  Size of XMI nodespace
literal IO9CC$C_PERXBI = 33554432;      !  Size of I/O adap space
literal IO9CC$C_NNEX = 16;              !  # of Nodes
literal IO9CC$C_XNEX = 14;              !  # of XMI Nodes
literal IO9CC$AL_IOADAP1 = 570425344;   !  I/O adap1 addr. space
!  Define BI address space offsets and lengths
literal IO9CC$C_BINODSIZ = 8192;        !  size of BI node space
literal IO9CC$C_BIWINDOW = 4194304;     !  offset to BI node window 0
literal IO9CC$C_BIWSIZ = 262144;        !  size of BI node window
 
!*** MODULE $IO9RRDEF ***
! +
!  I/O Space layout for 9RR CPU
! -
literal IO9RR$AL_CREGWE = 536870912;    !  CREG write enable
literal IO9RR$AL_IOBASE = 536870912;    !  Base of I/O space
literal IO9RR$AL_XMI_PRIV = 536870912;  !  XMI Private space
literal IO9RR$AL_SYSTYPE = 537133060;   !  MicroVAX system type register
literal IO9RR$AB_ROM = 537133056;       !  Console ROM halt protected region
literal IO9RR$AB_ROM_HLTENA = 537657344; !  Console ROM halt enabled region
literal IO9RR$K_ROM = 262144;           !  Console ROM size in bytes
literal IO9RR$AB_EEPROM = 537395200;    !  Console EEPROM halt protected region
literal IO9RR$AB_EEPROM_HLTENA = 537919488; !  Console EEPROM halt enabled region
literal IO9RR$K_EEPROM = 32768;         !  Console EEPROM size in bytes
literal IO9RR$AL_SSCBAR = 538181632;    !  SSC Base Address Register
literal IO9RR$AL_SSCCNR = 538181648;    !  SSC Configuration Register
literal IO9RR$AL_SSCCNF = 538181648;    !  SSC Configuration Register (old name)
literal IO9RR$AL_SSCBTR = 538181664;    !  SSC Bus Timeout Control
literal IO9RR$AL_OPORT = 538181680;     !  SSC Output Port
literal IO9RR$AL_SSCOPRT = 538181680;   !  SSC Output Port (old name)
literal IO9RR$AL_IPORT = 538181696;     !  SSC Input Port
literal IO9RR$AL_SSCIPRT = 538181696;   !  SSC Input Port (old name)
literal IO9RR$AL_CRBADR = 538181936;    !  CREG base address register
literal IO9RR$AL_CRADMR = 538181940;    !  CREG address decode mask register
literal IO9RR$AL_EEBADR = 538181952;    !  EEPROM base address register
literal IO9RR$AL_EEADMR = 538181956;    !  EEPROM address decode mask register
literal IO9RR$AL_TIMERS = 538181984;    !  Programmable Timers
literal IO9RR$AL_TCR0 = 538181984;      !  Programmable Timer 0
literal IO9RR$AL_TIR0 = 538181988;      !  Programmable Timer 0
literal IO9RR$AL_TNIR0 = 538181992;     !  Programmable Timer 0
literal IO9RR$AL_TIVR0 = 538181996;     !  Programmable Timer 0
literal IO9RR$AL_TCR1 = 538182000;      !  Programmable Timer 1
literal IO9RR$AL_TIR1 = 538182004;      !  Programmable Timer 1
literal IO9RR$AL_TNIR1 = 538182008;     !  Programmable Timer 1
literal IO9RR$AL_TIVR1 = 538182012;     !  Programmable Timer 1
literal IO9RR$AL_INTTIM = 538182136;    !  Interval timer counter register (diagnostic use only)
literal IO9RR$AB_RAM = 538182656;       !  RSSC RAM base address
literal IO9RR$K_RAM = 1024;             !  RSSC RAM size in bytes
literal IO9RR$AB_IPINTR = 553713664;    !  Interprocessor Interrupts
literal IO9RR$AL_IP_IVINTR = 553713664; !  Interprocessor Interrupts (old name)
literal IO9RR$K_IPINTR = 65536;         !  Interprocessor Interrupts region size
literal IO9RR$AB_WEINTR = 553779200;    !  Write Error IP
literal IO9RR$AL_WE_IVINTR = 553779200; !  Write Error IP (old name)
literal IO9RR$K_WEINTR = 65536;         !  Write Error IP region size
literal IO9RR$AB_NODESPACE = 562036736; !  Base of XMI node space
literal IO9RR$AL_NODESP = 562036736;    !  Base of XMI node space (old name)
literal IO9RR$K_NODESPACE = 524288;     !  Size of XMI node space
literal IO9RR$C_PERNEX = 524288;        !  Size of XMI nodespace
literal IO9RR$C_PERXBI = 33554432;      !  Size of I/O adap space
literal IO9RR$C_NNEX = 16;              !  # of Nodes
literal IO9RR$C_XNEX = 14;              !  # of XMI Nodes
literal IO9RR$AL_IOADAP1 = 570425344;   !  I/O adap1 addr. space
!  Define BI address space offsets and lengths
literal IO9RR$C_BINODSIZ = 8192;        !  size of BI node space
literal IO9RR$C_BIWINDOW = 4194304;     !  offset to BI node window 0
literal IO9RR$C_BIWSIZ = 262144;        !  size of BI node window
 
!*** MODULE $IO1202DEF ***
! +
!  I/O Space layout for 1202 CPU
! 
!  Note:  All definition assume 32-bit mode, but will function in both 30-bit and 32-bit mode.
! -
literal IO1202$AL_IOBASE = -536870912;  !  Base of I/O space
literal IO1202$AL_XMI_PRIV = -536870912; !  XMI Private space
literal IO1202$AL_CREGWE = -536870912;  !  CREG write enable
literal IO1202$AL_CREG0 = -536870912;   !  CREG0 (if mapped by SSCOPRT)
literal IO1202$AL_CREG1 = -536870912;   !  CREG1 (if mapped by SSCOPRT)
literal IO1202$AL_SYSTYPE = -536608764; !  System type register
literal IO1202$AB_ROM = -536608768;     !  Console ROM halt protected region
literal IO1202$AB_ROM_HLTENA = -535691264; !  Console ROM halt enabled region
literal IO1202$K_ROM = 393216;          !  Console ROM size in bytes
literal IO1202$AB_RAM_BBU = -535559168; !  Console RAM preserved by BBU
literal IO1202$K_RAM_BBU = 1024;        !  Console RAM size preserved by BBU
literal IO1202$AB_EEPROM = -536215552;  !  Console EEPROM halt protected region
literal IO1202$AB_EEPROM_HLTENA = -535822336; !  Console EEPROM halt enabled region
literal IO1202$K_EEPROM = 32768;        !  Console EEPROM size in bytes
literal IO1202$AL_MSSC = -535560192;    !  Start of SSC registers
literal IO1202$AL_SSCBAR = -535560192;  !  SSC Base Address Register
literal IO1202$AL_SSCCNR = -535560176;  !  SSC Configuration Register
literal IO1202$AL_SSCBTR = -535560160;  !  SSC Bus Timeout Control
literal IO1202$AL_OPORT = -535560144;   !  SSC Output Port
literal IO1202$AL_IPORT = -535560128;   !  SSC Input Port
literal IO1202$AL_CRBADR = -535559888;  !  CREG base address register
literal IO1202$AL_CRADMR = -535559884;  !  CREG address decode mask register
literal IO1202$AL_EEBADR = -535559872;  !  EEPROM base address register
literal IO1202$AL_EEADMR = -535559868;  !  EEPROM address decode mask register
literal IO1202$AL_TIMERS = -535559840;  !  Programmable Timers
literal IO1202$AL_TCR0 = -535559840;    !  Programmable Timer 0
literal IO1202$AL_TIR0 = -535559836;    !  Programmable Timer 0
literal IO1202$AL_TNIR0 = -535559832;   !  Programmable Timer 0  
literal IO1202$AL_TIVR0 = -535559828;   !  Programmable Timer 0
literal IO1202$AL_TCR1 = -535559824;    !  Programmable Timer 1
literal IO1202$AL_TIR1 = -535559820;    !  Programmable Timer 1
literal IO1202$AL_TNIR1 = -535559816;   !  Programmable Timer 1
literal IO1202$AL_TIVR1 = -535559812;   !  Programmable Timer 1
literal IO1202$AL_SSCICR = -535559688;  !  Interval timer counter register (diagnostic use only)
literal IO1202$AB_MSSC_RAM = -535559168; !  MSSC RAM base address
literal IO1202$K_MSSC_RAM = 1024;       !  MSSC RAM size in bytes
literal IO1202$AB_MAXMI_RAM = -520060928; !  Start of MAXMI RAM
literal IO1202$K_MAXMI_RAM = 8192;      !  Size of MAXMI RAM
literal IO1202$AB_MAXMI = -520093696;   !  MAXMI private space register
literal IO1202$AB_DCSR = -520093696;    !  DAL diagnostic register
literal IO1202$AB_FDAL0 = -520093664;   !  Failing DAL register 0
literal IO1202$AB_FDAL1 = -520093656;   !  Failing DAL register 1
literal IO1202$AB_FDAL2 = -520093648;   !  Failing DAL register 2
literal IO1202$AB_FDAL3 = -520093656;   !  Failing DAL register 3
literal IO1202$AB_IPINTR = -520028160;  !  Interprocessor Interrupts
literal IO1202$K_IPINTR = 65536;        !  Interprocessor Interrupts region size
literal IO1202$AB_WEINTR = -519962624;  !  Write Error IP
literal IO1202$K_WEINTR = 65536;        !  Write Error IP region size
literal IO1202$AB_NODESPACE = -511705088; !  Base of XMI node space
literal IO1202$K_NODESPACE = 524288;    !  Size of XMI node space
literal IO1202$C_PERNEX = 524288;       !  Size of XMI nodespace
literal IO1202$C_PERXBI = 33554432;     !  Size of I/O adap space
literal IO1202$C_NNEX = 16;             !  # of Nodes
literal IO1202$C_XNEX = 14;             !  # of XMI Nodes
literal IO1202$AL_IOADAP1 = -503316480; !  I/O adap1 addr. space
!  Define BI address space offsets and lengths
literal IO1202$C_BINODSIZ = 8192;       !  size of BI node space
literal IO1202$C_BIWINDOW = 4194304;    !  offset to BI node window 0
literal IO1202$C_BIWSIZ = 262144;       !  size of BI node window
 
!*** MODULE $IO1302DEF ***
! +
!  I/O Space layout for 1302 CPU
! 
!  Note:  All definition assume 32-bit mode, but will function in both 30-bit and 32-bit mode.
! -
literal IO1302$AL_IOBASE = -536870912;  !  Base of I/O space
literal IO1302$AL_XMI_PRIV = -536870912; !  XMI Private space
literal IO1302$AL_SYSTYPE = -536608764; !  System type register
literal IO1302$AB_ROM = -536608768;     !  Console ROM halt protected region
literal IO1302$AB_ROM_HLTENA = -535953408; !  Console ROM halt enabled region
literal IO1302$K_ROM = 393216;          !  Console ROM size in bytes
literal IO1302$AB_EEPROM = -536084480;  !  Console EEPROM halt protected region
literal IO1302$AB_EEPROM_HLTENA = -535429120; !  Console EEPROM halt enabled region
literal IO1302$K_EEPROM = 32768;        !  Console EEPROM size in bytes
literal IO1302$AB_NEXMI_RAM = -535298048; !  Start of NEXMI RAM
literal IO1302$K_NEXMI_RAM = 8192;      !  Size of NEXMI RAM
literal IO1302$AB_RAM_BBU = -535285746; !  Watch chip RAM preserved by BBU
literal IO1302$K_RAM_BBU = 50;          !  Watch chip RAM size in bytes preserved by BBU
literal IO1302$AB_WATCH_BASE = -535285760; !  Watch chip 'base'
literal IO1302$AB_WATCH_SECONDS = -535285760; !  Watch chip SECONDS register
literal IO1302$AB_WATCH_MINUTES = -535285758; !  Watch chip MINUTES register
literal IO1302$AB_WATCH_HOURS = -535285756; !  Watch chip HOURS register
literal IO1302$AB_WATCH_DAY = -535285753; !  Watch chip DAY register
literal IO1302$AB_WATCH_MONTH = -535285752; !  Watch chip MONTH register
literal IO1302$AB_WATCH_YEAR = -535285751; !  Watch chip YEAR register
literal IO1302$AB_WATCH_CSRA = -535285750; !  Watch chip CSRA register
literal IO1302$AB_WATCH_CSRB = -535285749; !  Watch chip CSRB register
literal IO1302$AB_WATCH_CSRD = -535285747; !  Watch chip CSRD register
literal IO1302$AB_WATCH_RAM = -535285746; !  Watch chip RAM_BBU 
literal IO1302$AL_IPORT = -535281664;   !  NEXMI Input Port
literal IO1302$AL_OPORT0 = -535277568;  !  NEXMI Output Port0
literal IO1302$AL_OPORT1 = -535273472;  !  NEXMI Output Port1
literal IO1302$AB_NEXMI = -536870912;   !  NEXMI private space 
literal IO1302$AL_NCSR = -536870912;    !  NEXMI private space register, NDAL CSR
literal IO1302$AB_IPINTR = -520028160;  !  Interprocessor Interrupts
literal IO1302$K_IPINTR = 65536;        !  Interprocessor Interrupts region size
literal IO1302$AB_WEINTR = -519962624;  !  Write Error IP
literal IO1302$K_WEINTR = 65536;        !  Write Error IP region size
literal IO1302$AB_NODESPACE = -511705088; !  Base of XMI node space
literal IO1302$K_NODESPACE = 524288;    !  Size of XMI node space
literal IO1302$C_PERNEX = 524288;       !  Size of XMI nodespace
literal IO1302$C_PERXBI = 33554432;     !  Size of I/O adap space
literal IO1302$C_NNEX = 16;             !  # of Nodes
literal IO1302$C_XNEX = 14;             !  # of XMI Nodes
literal IO1302$AL_IOADAP1 = -503316480; !  I/O adap1 addr. space
!  Define BI address space offsets and lengths
literal IO1302$C_BINODSIZ = 8192;       !  size of BI node space
literal IO1302$C_BIWINDOW = 4194304;    !  offset to BI node window 0
literal IO1302$C_BIWSIZ = 262144;       !  size of BI node window
 
!*** MODULE $IO1303DEF ***
literal IO1303$AL_QB0SP = 536870912;
literal IO1303$AW_QDSS = 536878848;
literal IO1303$AW_IPCR0 = 536878912;
literal IO1303$AW_IPCR1 = 536878914;
literal IO1303$AW_IPCR2 = 536878916;
literal IO1303$AW_IPCR3 = 536878918;
literal IO1303$AL_SHAC1 = 536887808;
literal IO1303$AL_SGEC = 536903680;
literal IO1303$AB_ROM = 537133056;
literal IO1303$S_ROM = 524288;
literal IO1303$AL_SIDEX = 537133060;
literal IO1303$AL_GETCHAR = 537133064;
literal IO1303$AL_OUTMSG = 537133068;
literal IO1303$AL_SSHMA = 537133096;
literal IO1303$AL_SCR = 537395200;
literal IO1303$AL_DSER = 537395204;
literal IO1303$AL_QBEAR = 537395208;
literal IO1303$AL_DEAR = 537395212;
literal IO1303$AL_QBMBR = 537395216;
literal IO1303$AL_BDR = 537411584;
literal IO1303$AL_QMAP = 537427968;
literal IO1303$S_QMAP = 32768;
literal IO1303$AL_SSCBR = 538181632;
literal IO1303$AL_SSCCR = 538181648;
literal IO1303$AL_CBTCR = 538181664;
literal IO1303$AL_DLEDR = 538181680;
literal IO1303$AL_TCR0 = 538181888;
literal IO1303$AL_TIR0 = 538181892;
literal IO1303$AL_TNIR0 = 538181896;
literal IO1303$AL_TIVR0 = 538181900;
literal IO1303$AL_TCR1 = 538181904;
literal IO1303$AL_TIR1 = 538181908;
literal IO1303$AL_TNIR1 = 538181912;
literal IO1303$AL_TIVR1 = 538181916;
literal IO1303$AB_NVR = 538182656;
literal IO1303$S_NVR = 1024;
literal IO1303$AL_CONSPAGE = 538182672;
literal IO1303$AL_MODR = 553713664;
literal IO1303$S_MODR = 32768;
literal IO1303$AL_MEMCON = 553746432;
literal IO1303$AL_MEMSIG = 553746464;
literal IO1303$AL_MEAR = 553746496;
literal IO1303$AL_MESR = 553746500;
literal IO1303$AL_MMCDSR = 553746504;
literal IO1303$AL_MOAMR = 553746508;
literal IO1303$AL_CESR = 553779200;
literal IO1303$AL_CMCDSR = 553779204;
literal IO1303$AL_CSEAR1 = 553779208;
literal IO1303$AL_CSEAR2 = 553779212;
literal IO1303$AL_CIOEAR1 = 553779216;
literal IO1303$AL_CIOEAR2 = 553779220;
literal IO1303$AL_CNEAR = 553779224;
literal IO1303$AL_QB0MEM = 805306368;
literal IO1303$S_QB0MEM = 4194304;
literal IO1303$AB_SYNCOMM = 603979776;
literal IO1303$S_SYNCOMM = 16777216;
literal IO1303$AB_SYNCROMS = 605028352;
literal IO1303$AB_SYNCROME = 605290495;
literal IO1303$AL_SYNCRST = 620756988;
literal IO1303$AW_SER_CSR = 620756992;
literal IO1303$AW_SER_RBUF = 620756996;
literal IO1303$AW_SER_LPR = 620756996;
literal IO1303$AW_SER_TCR = 620757000;
literal IO1303$AW_SER_MSR = 620757004;
literal IO1303$AW_SER_TDR = 620757004;
literal IO1303$AW_CFG = 629145600;
literal IO1303$AW_DIAGDISP = 629145604;
literal IO1303$AL_SCDADR = 633339904;
literal IO1303$AL_SCDDIR = 633339908;
literal IO1303$AB_INTMSK = 633339912;
literal IO1303$AB_INTREQ = 633339916;
literal IO1303$AB_INTCLR = 633339916;
literal IO1303$AB_IORESET = 633339920;
literal IO1303$AB_SCSICSR = 637534208;
literal IO1303$AL_SCSIMAP = 654311424;
literal IO1303$S_SCSIMAP = 32768;
literal IO1303$AB_NISAROM = 662700032;
literal IO1303$AL_ASYNCSR = 1040187392;
literal IO1303$AB_ASYNCROM = 1040252928;
 
!*** MODULE $IO1701DEF ***
! +
!  I/O SPACE LAYOUT FOR 1701 CPU
! -
!  Laser System Bus I/O Space definitions ("local" I/O space)
literal IO1701$AL_LSB_PRIVSP = -268435456; !  Base of LSB Private Space
literal IO1701$AL_UART0 = -201326592;   !  Base of UART0 CSRs
literal IO1701$AL_UART1 = -192937984;   !  Base of UART1 CSRs
literal IO1701$AL_UART2 = -184549376;   !  Base of UART2 CSRs
literal IO1701$AL_WATCH = -167772160;   !  Base of Watch Chip CSRs
literal IO1701$AL_GBUS = -150994944;    !  Base of GBUS CSRs
literal IO1701$AL_LSB_BASE = -134217728; !  Base of LSB I/O Space
literal IO1701$C_LSB_NODESP_SIZ = 4194304; !  Size of each 64 Kb nodespace
literal IO1701$C_LSB_NODES = 8;         !  Number of LSB nodes (excludes IOP)
literal IO1701$AL_IOP_BASE = -100663296; !  Base of I/O Processor CSRs
literal IO1701$AL_BSB_BASE = -33554432; !  Base of Broadcast Space
literal IO1701$C_IOP_HOSES = 4;         !  Number of hoses on IOP
 
!*** MODULE $IPLDEF ***
! +
!  TEMPORARY PROCESSOR PRIORITY LEVEL DEFINITIONS
! -
!  
literal IPL$_HWCLK = 24;                ! HARDWARE CLOCK LEVEL 
literal IPL$_HWCLKLO = 22;              ! HARDWARE CLOCK LO LEVEL
literal IPL$_PERFMON = 15;              ! PERFORMANCE MONITORING SYNCH LEVEL 
literal IPL$_IOPOST = 4;                ! I/O POST PROCESSING LEVEL 
literal IPL$_MAILBOX = 11;              ! WRITE MAILBOX INTERLOCK LEVEL 
literal IPL$_POWER = 31;                ! POWERFAIL INTERLOCK LEVEL 
literal IPL$_QUEUEAST = 6;              ! QUEUE AST LEVEL 
literal IPL$_RESCHED = 3;               ! SCHEDULER LEVEL 
literal IPL$_SYNCH = 8;                 ! SYSTEM DATA BASE SYNCHRONIZATION LEVEL 
literal IPL$_TIMER = 8;                 ! TIME QUEUE PROCESSING LEVEL 
literal IPL$_TIMERFORK = 7;             ! TIMER FORK INTERRUPT LEVEL
literal IPL$_ASTDEL = 2;                ! AST DELIVERY INTERRUPT 
literal IPL$_SCS = 8;                   ! SCS SYNCHRONIZATION IPL 
literal IPL$_IPINTR = 22;               ! IP INTERRUPT SYNCHRONIZATION IPL 
literal IPL$_SCHED = 8;                 ! SCHEDULING DATABASE IPL
literal IPL$_JIB = 8;                   ! JIB RESERVED SPINLOCK IPL
literal IPL$_MMG = 8;                   ! MMG DATABASE IPL
literal IPL$_FILSYS = 8;                ! FILSYS DATABASE IPL
literal IPL$_IOLOCK8 = 8;               ! IOLOCK8 DATABASE IPL
literal IPL$_PR_LK8 = 8;                ! PR_LK8 DATABASE IPL
literal IPL$_IOLOCK9 = 9;               ! IOLOCK9 DATABASE IPL
literal IPL$_PR_LK9 = 9;                ! PR_LK9 DATABASE IPL
literal IPL$_IOLOCK10 = 10;             ! IOLOCK10 DATABASE IPL
literal IPL$_PR_LK10 = 10;              ! PR_LK10 DATABASE IPL
literal IPL$_IOLOCK11 = 11;             ! IOLOCK11 DATABASE IPL
literal IPL$_PR_LK11 = 11;              ! PR_LK11 DATABASE IPL
literal IPL$_POOL = 11;                 ! POOL DATABASE IPL
literal IPL$_INVALIDATE = 19;           ! INVALIDATE DATABASE IPL
literal IPL$_VIRTCONS = 20;             ! VIRTCONS DATABASE IPL
literal IPL$_EMB = 31;                  ! EMB DATABASE IPL
literal IPL$_MCHECK = 31;               ! MACHINE CHECK IPL
literal IPL$_MEGA = 31;                 ! IPL FOR KITCHEN SINK LOCK
 
!*** MODULE $IRPDEF ***
! +
!  IRP - I/O REQUEST PACKET
! 
!  I/O REQUEST PACKETS ARE CONSTRUCTED BY THE QUEUE I/O REQUEST SYSTEM
!  SERVICE. THE CONTENT OF AN I/O REQUEST PACKET DESCRIBES A FUNCTION TO
!  BE PERFORMED ON A DEVICE UNIT.
! 
!  NOTE: SEVERAL FIELDS OF THE IRP MUST BE AT THE SAME OFFSETS AS THEIR
!  CORRESPONDING FIELDS IN THE IRPE (SEE NEXT PAGE).
! 
! -
literal IRP$M_FCODE = 63;
literal IRP$M_CLN_READY = 1;
literal IRP$M_CLN_DONE = 2;
literal IRP$M_CPY_FINI = 4;
literal IRP$M_WLE_REUSE = 8;
literal IRP$M_WLE_SUPWL = 16;
literal IRP$M_BUFIO = 1;
literal IRP$M_FUNC = 2;
literal IRP$M_PAGIO = 4;
literal IRP$M_COMPLX = 8;
literal IRP$M_VIRTUAL = 16;
literal IRP$M_CHAINED = 32;
literal IRP$M_SWAPIO = 64;
literal IRP$M_DIAGBUF = 128;
literal IRP$M_PHYSIO = 256;
literal IRP$M_TERMIO = 512;
literal IRP$M_MBXIO = 1024;
literal IRP$M_EXTEND = 2048;
literal IRP$M_FILACP = 4096;
literal IRP$M_MVIRP = 8192;
literal IRP$M_SRVIO = 16384;
literal IRP$M_KEY = 32768;
literal IRP$M_START_PAST_HWM = 1;
literal IRP$M_END_PAST_HWM = 2;
literal IRP$M_ERASE = 4;
literal IRP$M_PART_HWM = 8;
literal IRP$M_LCKIO = 16;
literal IRP$M_SHDIO = 32;
literal IRP$M_CACHEIO = 64;
literal IRP$M_WLE = 128;
literal IRP$M_CACHE_SAFE = 256;
literal IRP$M_NOCACHE = 512;
literal IRP$K_CDRP = 96;                !  Offset to the CDRP within the IRP 
literal IRP$C_CDRP = 96;                !  Offset to the CDRP within the IRP
literal IRP$M_PIO_ERROR = 1;
literal IRP$M_PIO_FANOUT = 2;
literal IRP$M_PIO_NOQUE = 4;
literal IRP$M_PIO_CANCEL = 8;
literal IRP$M_PIO_CTHRDOK = 16;
literal IRP$M_PIO_PHASEII = 32;
literal IRP$K_BT_LEN = 160;
literal IRP$C_BT_LEN = 160;
literal IRP$K_CD_LEN = 168;
literal IRP$C_CD_LEN = 168;
literal IRP$K_LENGTH = 168;             !  LENGTH OF STANDARD IRP 
literal IRP$C_LENGTH = 168;             !  LENGTH OF STANDARD IRP 
literal IRP$S_IRPDEF = 168;
macro IRP$L_IOQFL = 0,0,32,0 %;         ! I/O QUEUE FORWARD LINK 
macro IRP$L_IOQBL = 4,0,32,0 %;         ! I/O QUEUE BACKWARD LINK 
macro IRP$W_SIZE = 8,0,16,0 %;          ! SIZE OF IRP IN BYTES 
macro IRP$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE FOR IRP 
macro IRP$B_RMOD = 11,0,8,0 %;          ! ACCESS MODE OF REQUEST 
macro IRP$V_MODE = 11,0,2,0 %;
literal IRP$S_MODE = 2;                 !  MODE SUBFIELD 
macro IRP$L_PID = 12,0,32,0 %;          ! PROCESS ID OF REQUESTING PROCESS 
macro IRP$L_AST = 16,0,32,0 %;          ! ADDRESS OF AST ROUTINE 
macro IRP$L_SHD_IOFL = 16,0,32,0 %;     ! LINK TO CLONE IRPS
macro IRP$L_ASTPRM = 20,0,32,0 %;       ! AST PARAMETER 
macro IRP$L_SHAD = 20,0,32,0 %;         ! SHAD ADDRESS
macro IRP$L_HRB = 20,0,32,0 %;          ! HRB ADDRESS 
macro IRP$L_WIND = 24,0,32,0 %;         ! ADDRESS OF WINDOW BLOCK 
macro IRP$L_MIRP = 24,0,32,0 %;         ! LINK TO MASTER IRP
macro IRP$L_UCB = 28,0,32,0 %;          ! ADDRESS OF DEVICE UCB 
macro IRP$W_FUNC = 32,0,16,0 %;         ! I/O FUNCTION CODE AND MODIFIERS 
macro IRP$V_FCODE = 32,0,6,0 %;
literal IRP$S_FCODE = 6;                !  FUNCTION CODE FIELD 
macro IRP$V_FMOD = 32,6,10,0 %;
literal IRP$S_FMOD = 10;                !  FUNCTION MODIFIER FIELD 
macro IRP$B_EFN = 34,0,8,0 %;           ! EVENT FLAG NUMBER AND EVENT GROUP 
macro IRP$B_CLN_INDX = 34,0,8,0 %;      ! Shadow Clone membership index
macro IRP$B_PRI = 35,0,8,0 %;           ! BASE PRIORITY OF REQUESTING PROCESS 
macro IRP$B_SHD_FLAGS = 35,0,8,0 %;     !  Shadow Clone Flags
macro IRP$V_CLN_READY = 35,0,1,0 %;     !  Clone is ready for I/O
macro IRP$V_CLN_DONE = 35,1,1,0 %;      !  Clone has done I/O
macro IRP$V_CPY_FINI = 35,2,1,0 %;      !  Copy is complete.
macro IRP$V_WLE_REUSE = 35,3,1,0 %;     !  Reuse writelog entry
macro IRP$V_WLE_SUPWL = 35,4,1,0 %;     !  Supplementary writelog
! 
! 
macro IRP$L_IOSB = 36,0,32,0 %;         ! ADDRESS OF I/O STATUS DOUBLE LONGWORD 
macro IRP$L_CLN_WLE = 36,0,32,0 %;      ! Write log entry
macro IRP$W_CHAN = 40,0,16,0 %;         ! PROCESS I/O CHANNEL NUMBER 
macro IRP$W_STS = 42,0,16,0 %;          ! REQUEST STATUS 
macro IRP$V_BUFIO = 42,0,1,0 %;         !  BUFFERED I/O FLAG ;THESE BITS 
macro IRP$V_FUNC = 42,1,1,0 %;          !  1=>READ FUNCTION ;MUST BE ADJACENT 
macro IRP$V_PAGIO = 42,2,1,0 %;         !  PAGING I/O FLAG ;AND IN ORDER 
macro IRP$V_COMPLX = 42,3,1,0 %;        !  COMPLEX BUFFERED I/O 
macro IRP$V_VIRTUAL = 42,4,1,0 %;       !  VIRTUAL I/O FUNCTION 
macro IRP$V_CHAINED = 42,5,1,0 %;       !  CHAINED BUFFERED I/O OPERATION 
macro IRP$V_SWAPIO = 42,6,1,0 %;        !  SWAP I/O OPERATION 
macro IRP$V_DIAGBUF = 42,7,1,0 %;       !  DIAGNOSTIC BUFFER ALLOCATED 
macro IRP$V_PHYSIO = 42,8,1,0 %;        !  PHYSICAL I/O 
macro IRP$V_TERMIO = 42,9,1,0 %;        !  TERMINAL I/O (FOR SELECTING PRIORITY INC) 
macro IRP$V_MBXIO = 42,10,1,0 %;        !  MAILBOX BUFFERED READ 
macro IRP$V_EXTEND = 42,11,1,0 %;       !  AN IRPE IS LINKED TO THIS IRP 
macro IRP$V_FILACP = 42,12,1,0 %;       !  FILE ACP I/O (BOTH DIOCNT AND BIOCNT) 
macro IRP$V_MVIRP = 42,13,1,0 %;        !  MOUNT VERIFICATION IRP 
macro IRP$V_SRVIO = 42,14,1,0 %;        !  SERVER TYPE I/O (TRIGGER MOUNTVER ON ERROR BUT DON'T STALL)
macro IRP$V_KEY = 42,15,1,0 %;          !  KEY FOR ENCRYPTION
macro IRP$L_SVAPTE = 44,0,32,0 %;       ! SYSTEM VIRTUAL ADDRESS OF FIRST PTE 
macro IRP$W_BOFF = 48,0,16,0 %;         ! BYTE OFFSET IN FIRST PAGE 
macro IRP$L_BCNT = 50,0,32,0 %;         ! BYTE COUNT OF TRANSFER 
macro IRP$W_BCNT = 50,0,16,0 %;         !  OLD WORD DEFINITION FOR COMPATIBILITY 
macro IRP$L_DCD_BLK_COUNT = 50,0,32,0 %; ! DISK COPY DATA TRANSFER BLOCK COUNT
macro IRP$W_STS2 = 54,0,16,1 %;         !  EXTENSION OF STATUS WORD
macro IRP$V_START_PAST_HWM = 54,0,1,0 %; !  I/O STARTS PAST HIGHWATER MARK
macro IRP$V_END_PAST_HWM = 54,1,1,0 %;  !  I/O ENDS PAST HIGHWATER MARK
macro IRP$V_ERASE = 54,2,1,0 %;         !  ERASE I/O FUNCTION
macro IRP$V_PART_HWM = 54,3,1,0 %;      !  PARTIAL HIGHWATER MARK UPDATE
macro IRP$V_LCKIO = 54,4,1,0 %;         !  Locked I/O request (DECnet)
macro IRP$V_SHDIO = 54,5,1,0 %;         !  This is a shadowing IRP
macro IRP$V_CACHEIO = 54,6,1,0 %;       !  uses VBN cache buffers
macro IRP$V_WLE = 54,7,1,0 %;           !  I/O USES A WRITE LOG ENTRY
macro IRP$V_CACHE_SAFE = 54,8,1,0 %;    !  this indicates that
!  the request has been
!  checked as regards
!  caching.
macro IRP$V_NOCACHE = 54,9,1,0 %;       !  IO$M_NOVCACHE was
!  set in QIO function 
macro IRP$L_IOST1 = 56,0,32,0 %;        ! FIRST I/O STATUS LONGWORD (FOR I/O POST) 
macro IRP$L_MEDIA = 56,0,32,0 %;        ! MEDIA ADDRESS 
macro IRP$L_IOST2 = 60,0,32,0 %;        ! SECOND I/O STATUS LONGWORD 
macro IRP$L_TT_TERM = 60,0,32,0 %;      ! ADDRESS OF READ TERMINATORS MASK 
macro IRP$B_CARCON = 60,0,8,0 %;        ! CARRIAGE CONTROL 
macro IRP$Q_NT_PRVMSK = 64,0,0,0 %;
literal IRP$S_NT_PRVMSK = 8;            !  PRIVILEGE MASK FOR DECNET 
macro IRP$Q_STATION = 64,0,0,0 %;
literal IRP$S_STATION = 8;              !  STATION FIELD FOR DECNET DRIVERS
macro IRP$Q_TT_STATE = 64,0,0,0 %;
literal IRP$S_TT_STATE = 8;             !  TERMINAL STATE DEFINITIONS 
macro IRP$L_ABCNT = 64,0,32,0 %;        !  ACCUMULATED BYTES TRANSFERED 
macro IRP$W_ABCNT = 64,0,16,0 %;        !  OLD WORD DEFINITION FOR COMPATIBILITY 
macro IRP$L_OBCNT = 68,0,32,0 %;        !  ORIGINAL TRANSFER BYTE COUNT 
macro IRP$W_OBCNT = 68,0,16,0 %;        !  OLD WORD DEFINITION FOR COMPATIBILITY 
macro IRP$L_SEGVBN = 72,0,32,0 %;       !  VIRTUAL BLOCK NUMBER OF CURRENT SEGMENT 
macro IRP$L_DIAGBUF = 76,0,32,0 %;      !  DIAGNOSTIC BUFFER ADDRESS 
macro IRP$L_SCB_BUF = 76,0,32,0 %;      !  SCB BUFFER ADDRESS
macro IRP$W_TT_PRMPT = 76,0,16,0 %;     !  PROMPT SIZE 
macro IRP$L_SEQNUM = 80,0,32,0 %;       !  SEQUENCE NUMBER 
macro IRP$L_DCD_SRC_UCB = 80,0,32,0 %;  !  DISK COPY DATA SOURCE UCB
macro IRP$L_EXTEND = 84,0,32,0 %;       !  ADDRESS OF IRPE 
macro IRP$L_ARB = 88,0,32,0 %;          !  ACCESS RIGHTS BLOCK ADDRESS 
macro IRP$L_SHDSPC = 88,0,32,0 %;       !  Shadowing return PC
macro IRP$L_KEYDESC = 92,0,32,0 %;      !  ADDRESS OF ENCRYPTION DESCRIPTOR
macro IRP$L_WLE_PTR = 92,0,32,0 %;      !  Clone Write log index
macro IRP$B_CPY_MODE = 92,0,8,0 %;      !  Copy mode identifier
!  Standard IRP must contain space for Class Driver CDRP fields.
macro IRP$L_FQFL = 96,0,32,0 %;         !  Fork Queue FLINK 
macro IRP$L_FQBL = 100,0,32,0 %;        !  Fork Queue Blink 
macro IRP$W_CDRPSIZE = 104,0,16,0 %;    !  Size field for positive section only 
macro IRP$B_CD_TYPE = 106,0,8,0 %;      !  Type, always of interest 
macro IRP$B_FLCK = 107,0,8,0 %;         ! FORK LOCK NUMBER
macro IRP$B_FIPL = 107,0,8,0 %;         ! FORK IPL
macro IRP$L_FPC = 108,0,32,0 %;         !  Fork PC 
macro IRP$L_FR3 = 112,0,32,0 %;         !  Fork R3 
macro IRP$L_FR4 = 116,0,32,0 %;         !  Fork R4 
macro IRP$L_SAVD_RTN = 120,0,32,0 %;    !  Saved return address from level 1 JSB 
macro IRP$L_MSG_BUF = 124,0,32,0 %;     !  Address of allocated MSCP buffer 
macro IRP$L_SHD_LOCK_FR4 = 124,0,32,0 %; !  Lock fork R4
macro IRP$L_RSPID = 128,0,32,0 %;       !  Allocated Request ID 
macro IRP$L_SHD_LOCK_FR5 = 128,0,32,0 %; !  Lock fork R5
macro IRP$L_CDT = 132,0,32,0 %;         !  Address of Connection Descriptor Table 
macro IRP$L_SHD_LOCK_FR0 = 132,0,32,0 %; !  R0 = lock mode
macro IRP$L_RWCPTR = 136,0,32,0 %;      !  RWAITCNT pointer 
! 	Extensions to the CDRP within the IRP
!  Host-Based Shadowing Extension
macro IRP$L_SHD_PIO_LNK = 140,0,32,0 %; !  Link to clone IRP(s)
macro IRP$B_SHD_PIO_CNT = 144,0,8,0 %;  !  Tot num phys IRPs assoc.
macro IRP$B_SHD_PIO_ACT = 145,0,8,0 %;  !  Tot num phys IRPs active.
!  Note Keep SHD_PIO_FLAGS, SHD_PIO_ERRCNT,  contiguous.
macro IRP$B_SHD_PIO_FLAGS = 146,0,8,0 %; !  Master Flags Byte
macro IRP$V_PIO_ERROR = 146,0,1,0 %;    !  Errant clone in Chain
macro IRP$V_PIO_FANOUT = 146,1,1,0 %;   !  Chained Clones.
macro IRP$V_PIO_NOQUE = 146,2,1,0 %;    !  Don't queue to server
macro IRP$V_PIO_CANCEL = 146,3,1,0 %;   !  This master cancelled
macro IRP$V_PIO_CTHRDOK = 146,4,1,0 %;  !  Copy thread validated.
macro IRP$V_PIO_PHASEII = 146,5,1,0 %;  !  Bi-phasic Phase II write
macro IRP$B_SHD_PIO_ERRCNT = 147,0,8,0 %; !  Number of errors in chain
macro IRP$L_SHD_PIO_ERROR = 148,0,32,0 %; !  BCNT and Error Status (SS$_)
macro IRP$B_SHD_PIO_ERRINDEX = 152,0,8,0 %; !  Index of erring device
macro IRP$B_SHD_PIO_ERRSEV = 153,0,8,0 %; !  Relative error severity
macro IRP$L_SHD_LOCK_FPC = 156,0,32,0 %; !  Lock fork PC
macro IRP$L_SHD_LOCK_FR1 = 160,0,32,0 %; !  Lock fork R1
macro IRP$L_SHD_LOCK_FR2 = 164,0,32,0 %; !  Lock fork R2
! 	Block Transfer Extension
macro IRP$L_LBUFH_AD = 140,0,32,0 %;    !  Local BUFfer Handle ADress 
macro IRP$L_LBOFF = 144,0,32,0 %;       !  Local Byte OFFset 
macro IRP$L_RBUFH_AD = 148,0,32,0 %;    !  Remote BUFfer Handle ADress 
macro IRP$L_CDRPFL = 148,0,32,0 %;
macro IRP$L_RBOFF = 152,0,32,0 %;       !  Remote Byte OFFset 
macro IRP$L_XCT_LEN = 156,0,32,0 %;     !  Transfer length in bytes 
! 	Class Driver Extension
macro IRP$T_LBUFHNDL = 144,0,0,0 %;
literal IRP$S_LBUFHNDL = 12;            !  Local buffer handle 
macro IRP$L_UBARSRCE = 156,0,32,0 %;    !  UNIBUS mapping resources allocated 
macro IRP$L_DUTUFLAGS = 160,0,32,0 %;   !  Class driver status flags:
macro IRP$W_DUTUCNTR = 164,0,16,0 %;    !  General purpose counter
macro IRP$W_ENDMSGSIZ = 166,0,16,0 %;   !  Size of most recent MSCP end message
! 	Disk Copy Data Extension
macro IRP$B_SUBCMD_STS = 144,0,0,0 %;
literal IRP$S_SUBCMD_STS = 12;          !  Subcommand status
!  File system extensions
macro IRP$L_ERASE_VBN = 140,0,32,0 %;   !  VBN to start HWM erase
! 
!  This is commented out pending Richard Bishop's resolution
!  of CDRP/IRP issue.			- Ed Barth 8/30/89
! 
!     FUNC_OVERLAY2 union fill;
!         FUNC2 longword unsigned;			/*I/O FUNCTION CODE AND MODIFIERS 
! 	FUNC_BITS2 structure fill;
!             FCODE2 bitfield mask length 6;		/* FUNCTION CODE FIELD 
!             FMOD2 bitfield length 32-6;			/* FUNCTION MODIFIER FIELD 
! 	end FUNC_BITS2;
!     end FUNC_OVERLAY2;
 
!*** MODULE $IRPEDEF ***
! +
!  IRPE - I/O REQUEST PACKET EXTENSION
! 
!  I/O REQUEST PACKET EXTENSIONS ARE USED TO HOLD ADDITIONAL INFORMATION
!  ABOUT I/O REQUESTS FOR DEVICES THAT REQUIRE MORE CONTEXT THAN CAN FIT INTO
!  THE STANDARD IRP.  IRPE'S ARE BUILT AND LINKED ONTO IRP'S BY DEVICE
!  DRIVER FDT ROUTINES.  ANY FIELDS THAT ARE NOT DEFINED IN THIS STRUCTURE
!  MAY BE USED TO HOLD DRIVER DEPENDENT DATA.
! 
!  THE CURRENTLY DEFINED FIELDS IN THE IRPE WERE POSITIONED SO THAT THE
!  PACKET COULD BE USED AS A FORK BLOCK.  THIS SHOULD BE KEPT IN MIND IF
!  AND WHEN NEW FIELDS ARE DEFINED.
! 
!  THE FIELDS DEFINED HERE MUST BE AT THE SAME OFFSETS AS THEIR CORRESPONDING
!  FIELDS IN THE IRP (SEE PREVIOUS PAGE).
! 
! -
literal IRPE$M_EXTEND = 2048;
literal IRPE$K_LENGTH = 88;             !  LENGTH OF IRPE 
literal IRPE$C_LENGTH = 88;             !  LENGTH OF IRPE 
literal IRPE$S_IRPEDEF = 88;
macro IRPE$W_SIZE = 8,0,16,0 %;         !  SIZE OF IRPE IN BYTES 
macro IRPE$B_TYPE = 10,0,8,0 %;         !  STRUCTURE TYPE FOR IRPE 
macro IRPE$W_STS = 42,0,16,0 %;         !  STATUS 
macro IRPE$V_EXTEND = 42,11,1,0 %;      !  ANOTHER IRPE IS LINKED TO THIS ONE 
macro IRPE$L_SVAPTE1 = 44,0,32,0 %;     !  SYSTEM VIR. ADDR. OF PTE FOR REGION 1 
macro IRPE$W_BOFF1 = 48,0,16,0 %;       !  BYTE OFFSET FOR REGION 1 
macro IRPE$L_BCNT1 = 52,0,32,0 %;       !  BYTE COUNT FOR REGION 1 
macro IRPE$L_SVAPTE2 = 56,0,32,0 %;     !  SYSTEM VIR. ADDR. OF PTE FOR REGION 2 
macro IRPE$W_BOFF2 = 60,0,16,0 %;       !  BYTE OFFSET FOR REGION 2 
macro IRPE$L_BCNT2 = 64,0,32,0 %;       !  BYTE COUNT FOR REGION 2 
macro IRPE$L_EXTEND = 84,0,32,0 %;      !  ADDRESS OF NEXT IRPE 
 
!*** MODULE $ISDDEF ***
! +
!  IMAGE SECTION DESCRIPTOR DEFINITIONS
! -
literal ISD$K_LENDZRO = 12;             ! LENGTH OF DEMAND ZERO ISD 
literal ISD$C_LENDZRO = 12;             ! LENGTH OF DEMAND ZERO ISD 
literal ISD$M_GBL = 1;
literal ISD$M_CRF = 2;
literal ISD$M_DZRO = 4;
literal ISD$M_WRT = 8;
literal ISD$M_MATCHCTL = 112;
literal ISD$M_LASTCLU = 128;
literal ISD$M_INITALCODE = 256;
literal ISD$M_BASED = 512;
literal ISD$M_FIXUPVEC = 1024;
literal ISD$M_RESIDENT = 2048;
literal ISD$M_VECTOR = 131072;
literal ISD$M_PROTECT = 262144;
literal ISD$S_FLAGSIZ = 24;             !  NUMBER OF FLAG BITS, ISD TYPE EXCLUDED 
literal ISD$K_LENPRIV = 16;             ! LENGTH OF PRIVATE ISD 
literal ISD$C_LENPRIV = 16;             ! LENGTH OF PRIVATE ISD 
literal ISD$K_LENGLBL = 36;             ! LENGTH OF OLD GLOBAL ISD 
literal ISD$C_LENGLBL = 36;             ! LENGTH OF OLD GLOBAL ISD 
literal ISD$K_MAXLENGLBL = 64;          ! MAX LENGTH OF NEW GLOBAL ISD 
literal ISD$C_MAXLENGLBL = 64;          ! MAX LENGTH OF NEW GLOBAL ISD 
! +
literal ISD$K_MATALL = 0;               ! MATCH ALWAYS, USE GLOBAL SECTION 
literal ISD$K_MATEQU = 1;               ! MATCH IF ISD$L_IDENT EQU GBL ID 
literal ISD$K_MATLEQ = 2;               ! MATCH IF ISD$L_IDENT LEQ GBL ID 
literal ISD$K_MATNEV = 3;               ! MATCH NEVER, USE PRIVATE COPY 
! +
literal ISD$K_NORMAL = 0;               ! NORMAL PROGRAM IMAGE SECTION 
! NO SPECIAL ACTION REQUIRED
literal ISD$K_SHRFXD = 1;               ! SHAREABLE FIXED SECTION 
literal ISD$K_PRVFXD = 2;               ! PRIVATE FIXED SECTION 
literal ISD$K_SHRPIC = 3;               ! SHAREABLE PIC SECTION 
literal ISD$K_PRVPIC = 4;               ! PRIVATE PIC SECTION 
literal ISD$K_USRSTACK = 253;           ! USER STACK SECTION 
literal ISD$S_ISDDEF = 64;
macro ISD$W_SIZE = 0,0,16,0 %;          ! SIZE IN BYTES OF THIS ISD 
macro ISD$W_PAGCNT = 2,0,16,0 %;        ! ! OF PAGES DESCRIBED BY THIS ISD 
macro ISD$L_VPNPFC = 4,0,32,0 %;        ! VPN & PFC VIELDS 
macro ISD$V_VPN = 4,0,21,0 %;
literal ISD$S_VPN = 21;                 !  STARTING VIRTUAL PAGE NUMBER 
macro ISD$V_P1 = 4,21,1,0 %;            !  P1 SPACE 
macro ISD$V_SYSTEM = 4,22,1,0 %;        !  SYSTEM SPACE 
macro ISD$V_PFC = 4,24,8,0 %;
literal ISD$S_PFC = 8;                  !  PAGE FAULT CLUSTER 
macro ISD$V_VPG = 4,0,23,0 %;
literal ISD$S_VPG = 23;                 !  VIRTUAL PAGE INCLUDING P1 & S 
macro ISD$B_PFC = 7,0,8,0 %;            ! PAGE FAULT CLUSTER 
macro ISD$L_FLAGS = 8,0,32,0 %;         ! FLAGS AND ISD TYPE 
macro ISD$V_GBL = 8,0,1,0 %;            !  GLOBAL 
macro ISD$V_CRF = 8,1,1,0 %;            !  COPY ON REFERENCE 
macro ISD$V_DZRO = 8,2,1,0 %;           !  DEMAND ZERO PAGE 
macro ISD$V_WRT = 8,3,1,0 %;            !  WRITABLE 
macro ISD$V_MATCHCTL = 8,4,3,0 %;
literal ISD$S_MATCHCTL = 3;             !  IDENT MATCH CONTROL FIELD 
macro ISD$V_LASTCLU = 8,7,1,0 %;        !  ISD IS PART OF LAST P0 SPACE CLUSTER 
macro ISD$V_INITALCODE = 8,8,1,0 %;     !  ISD IS PART OF INITIALIZATION CODE
macro ISD$V_BASED = 8,9,1,0 %;          !  ISECT IS BASED 
macro ISD$V_FIXUPVEC = 8,10,1,0 %;      !  ISECT IS FIXUP SECTION 
macro ISD$V_RESIDENT = 8,11,1,0 %;      !  ISECT IS MEMORY-RESIDENT
macro ISD$V_VECTOR = 8,17,1,0 %;        !  VECTOR CONTAINED IN IMAGE SECTION 
macro ISD$V_PROTECT = 8,18,1,0 %;       !  IMAGE SECTION IS PROTECTED 
macro ISD$B_TYPE = 11,0,8,0 %;          ! ISD TYPE CODE 
macro ISD$L_VBN = 12,0,32,0 %;          ! BASE VIRTUAL BLOCK NUMBER 
macro ISD$L_IDENT = 16,0,32,0 %;        ! IDENT FOR GLOBAL SECTION 
macro ISD$T_GBLNAM = 20,0,0,0 %;
literal ISD$S_GBLNAM = 44;              ! GLOBAL NAME COUNTED STRING 
!  MATCH CONTROL VIELD VALUES
! -
! BASE OF ZERO , INCR 1 
!  ISD TYPE FIELD DEFINITIONS
! -
 
!*** MODULE ISDOLDDEF ***
! +
!  OLD IMAGE SECTION DESCRIPTOR DEFINITIONS
! -
literal ISD_K_LENDZRO = 12;             ! LENGTH OF DEMAND ZERO ISD 
literal ISD_C_LENDZRO = 12;             ! LENGTH OF DEMAND ZERO ISD 
literal ISD_M_GBL = 1;
literal ISD_M_CRF = 2;
literal ISD_M_DZRO = 4;
literal ISD_M_WRT = 8;
literal ISD_M_MATCHCTL = 112;
literal ISD_M_LASTCLU = 128;
literal ISD_M_COPYALWAY = 256;
literal ISD_M_BASED = 512;
literal ISD_M_FIXUPVEC = 1024;
literal ISD_M_VECTOR = 131072;
literal ISD_M_PROTECT = 262144;
literal ISD_S_FLAGSIZ = 24;             !  NUMBER OF FLAG BITS, ISD TYPE EXCLUDED 
literal ISD_K_LENPRIV = 16;             ! LENGTH OF PRIVATE ISD 
literal ISD_C_LENPRIV = 16;             ! LENGTH OF PRIVATE ISD 
literal ISD_K_LENGLBL = 36;             ! LENGTH OF GLOBAL ISD 
literal ISD_C_LENGLBL = 36;             ! LENGTH OF GLOBAL ISD 
! +
literal ISD_K_MATALL = 0;               ! MATCH ALWAYS, USE GLOBAL SECTION 
literal ISD_K_MATEQU = 1;               ! MATCH IF ISD_L_IDENT EQU GBL ID 
literal ISD_K_MATLEQ = 2;               ! MATCH IF ISD_L_IDENT LEQ GBL ID 
literal ISD_K_MATNEV = 3;               ! MATCH NEVER, USE PRIVATE COPY 
! +
literal ISD_K_NORMAL = 0;               ! NORMAL PROGRAM IMAGE SECTION 
! NO SPECIAL ACTION REQUIRED
literal ISD_K_SHRFXD = 1;               ! SHAREABLE FIXED SECTION 
literal ISD_K_PRVFXD = 2;               ! PRIVATE FIXED SECTION 
literal ISD_K_SHRPIC = 3;               ! SHAREABLE PIC SECTION 
literal ISD_K_PRVPIC = 4;               ! PRIVATE PIC SECTION 
literal ISD_K_USRSTACK = 253;           ! USER STACK SECTION 
literal ISD_S_ISDOLDDEF = 36;
macro ISD_W_SIZE = 0,0,16,0 %;          ! SIZE IN BYTES OF THIS ISD 
macro ISD_W_PAGCNT = 2,0,16,0 %;        ! ! OF PAGES DESCRIBED BY THIS ISD 
macro ISD_R_VPNPFC_OVERLAY = 4,0,32,0 %;
macro ISD_L_VPNPFC = 4,0,32,0 %;        ! VPN & PFC VIELDS 
macro ISD_R_VPNPFC_BITS0 = 4,0,32,0 %;
macro ISD_V_VPN = 4,0,21,0 %;
literal ISD_S_VPN = 21;                 !  STARTING VIRTUAL PAGE NUMBER 
macro ISD_V_P1 = 4,21,1,0 %;            !  P1 SPACE 
macro ISD_V_SYSTEM = 4,22,1,0 %;        !  SYSTEM SPACE 
macro ISD_V_PFC = 4,24,8,0 %;
literal ISD_S_PFC = 8;                  !  PAGE FAULT CLUSTER 
macro ISD_R_VPNPFC_BITS1 = 4,0,24,0 %;
macro ISD_V_VPG = 4,0,23,0 %;
literal ISD_S_VPG = 23;                 !  VIRTUAL PAGE INCLUDING P1 & S 
macro ISD_R_VPNPFC_FIELDS2 = 4,0,32,0 %;
macro ISD_B_PFC = 7,0,8,0 %;            ! PAGE FAULT CLUSTER 
macro ISD_R_FLAGS_OVERLAY = 8,0,32,0 %;
macro ISD_L_FLAGS = 8,0,32,0 %;         ! FLAGS AND ISD TYPE 
macro ISD_R_FLAGS_BITS = 8,0,24,0 %;
macro ISD_V_GBL = 8,0,1,0 %;            !  GLOBAL 
macro ISD_V_CRF = 8,1,1,0 %;            !  COPY ON REFERENCE 
macro ISD_V_DZRO = 8,2,1,0 %;           !  DEMAND ZERO PAGE 
macro ISD_V_WRT = 8,3,1,0 %;            !  WRITABLE 
macro ISD_V_MATCHCTL = 8,4,3,0 %;
literal ISD_S_MATCHCTL = 3;             !  IDENT MATCH CONTROL FIELD 
macro ISD_V_LASTCLU = 8,7,1,0 %;        !  ISD IS PART OF LAST P0 SPACE CLUSTER 
macro ISD_V_COPYALWAY = 8,8,1,0 %;      !  COPY ALWAYS FROM USER IMAGE 
macro ISD_V_BASED = 8,9,1,0 %;          !  ISECT IS BASED 
macro ISD_V_FIXUPVEC = 8,10,1,0 %;      !  ISECT IS FIXUP SECTION 
macro ISD_V_VECTOR = 8,17,1,0 %;        !  VECTOR CONTAINED IN IMAGE SECTION 
macro ISD_V_PROTECT = 8,18,1,0 %;       !  IMAGE SECTION IS PROTECTED 
macro ISD_R_FLAGS_FIELDS = 8,0,32,0 %;
macro ISD_B_TYPE = 11,0,8,0 %;          ! ISD TYPE CODE 
macro ISD_L_VBN = 12,0,32,0 %;          ! BASE VIRTUAL BLOCK NUMBER 
macro ISD_L_IDENT = 16,0,32,0 %;        ! IDENT FOR GLOBAL SECTION 
macro ISD_T_GBLNAM = 20,0,0,0 %;
literal ISD_S_GBLNAM = 16;              ! GLOBAL NAME COUNTED STRING 
!  MATCH CONTROL VIELD VALUES
! -
! BASE OF ZERO , INCR 1 
!  ISD TYPE FIELD DEFINITIONS
! -
 
!*** MODULE $ITEMLDEF IDENT X-1 ***
! 
! 	Structure used by DECnet-VAX internally used itemlists
! 
literal ITEML$K_LENGTH = 12;            !  Length of ItemList Header
literal ITEML$S_ITEM_ALLOC = 12;
macro ITEML$L_ACTLEN = 0,0,32,0 %;      !  Actual length of itemlist
macro ITEML$A_POINTER = 4,0,32,0 %;     !  Pointer to the start of the list
macro ITEML$W_SIZE = 8,0,16,0 %;        !  Allocated size of the structure
macro ITEML$B_TYPE = 10,0,8,0 %;        !  DYN$C_NET
macro ITEML$B_SUBTYPE = 11,0,8,0 %;     !  DYN$C_NET_ITEM
macro ITEML$T_ITEMLIST = 12,0,0,0 %;    !  Start of the itemlist
 
!*** MODULE $JIBDEF ***
! +
!  Job Information Block - Structure containing common context for a set
!                           of related processes.
! 
!  Note: The Executive module SYSCREPRC assumes that the job mount list head
!  preceeds the username field in the JIB.
! 
!  JIB Synchronization:
! 
! 	The JIB is a shared structure across a subprocess tree.  Synchronization
! 	is complex because many of the quota and limit fields have no functional
! 	relationship whatsoever.  So a number of methods of synchronization are
! 	used, based on exactly what is being manipulated.  Below is a list of
! 	fields with their methods of synch.
! 	
! 	Field		   Synchronization Method
! 	-----		   ----------------------
! 	BYTCNT/BYTLM	   JIB spinlock.  Should never be manually taken or released:
! 			      use the EXE$DEBIT/CREDIT routines in the EXSUBROUT module.
! 
! 	TQCNT/TQLM	   ADAWI.  When waiting because of a lack of TQCNT, the JIB FLAGS
! 			      bit TQCNT_WAITERS must be set; the JIB address is the EFWM
! 			      and the process should be placed in the MWAIT queue.  When
! 			      TQCNT is incremented, the TQCNT_WAITERS bit must be 
! 			      interrogated.  If it is set, then waiting process should
! 			      be made executable via a call to EXE$JIB_AVAIL or similar 
! 			      inline code.
! 
! 	PGFLCNT/PGFLQUOTA  MMG spinlock.
! 
! 	MTLFL/MTLBL	   SCH$IOLOCK/UNLOCK.
! 
! 	FILCNT/FILLM,	   ADAWI.  These fields are never increased or decreased by more
! 	  ENQCNT/ENQLM,       than 1 at a time, and are never waited on.
!         PRCCNT/PRCLM
! -
literal JIB$C_DETACHED = 0;
literal JIB$C_NETWORK = 1;
literal JIB$C_BATCH = 2;
literal JIB$C_LOCAL = 3;
literal JIB$C_DIALUP = 4;
literal JIB$C_REMOTE = 5;
literal JIB$M_BYTCNT_WAITERS = 1;
literal JIB$M_TQCNT_WAITERS = 2;
literal JIB$K_LENGTH = 148;             !  Structure length 
literal JIB$C_LENGTH = 148;             !  Structure length 
literal JIB$S_JIBDEF = 148;
macro JIB$L_MTLFL = 0,0,32,0 %;         !  Job mount list head forward link
macro JIB$L_MTLBL = 4,0,32,0 %;         !  Job mount list head back link
macro JIB$W_SIZE = 8,0,16,0 %;          !  Size of structure in bytes 
macro JIB$B_TYPE = 10,0,8,0 %;          !  Structure type code 
macro JIB$B_DAYTYPES = 11,0,8,0 %;      !  Set bits 0-6 flag non-prime days of week 
macro JIB$T_USERNAME = 12,0,0,0 %;
literal JIB$S_USERNAME = 12;            !  User name for easy access 
macro JIB$T_ACCOUNT = 24,0,0,0 %;
literal JIB$S_ACCOUNT = 8;              !  Account name for resident access 
macro JIB$L_BYTCNT = 32,0,32,0 %;       !  Buffered I/O byte count avail 
macro JIB$L_BYTLM = 36,0,32,0 %;        !  Original value for Byte count 
macro JIB$L_PBYTCNT = 40,0,32,0 %;      !  Paged pool byte count remaining 
macro JIB$L_PBYTLIM = 44,0,32,0 %;      !  Paged pool byte limit 
macro JIB$W_FILCNT = 48,0,16,0 %;       !  Open File count remaining 
macro JIB$W_FILLM = 50,0,16,0 %;        !  Open file limit 
macro JIB$W_TQCNT = 52,0,16,0 %;        !  Timer queue entry count remaining 
macro JIB$W_TQLM = 54,0,16,0 %;         !  Timer queue entry limit 
macro JIB$L_PGFLQUOTA = 56,0,32,0 %;    !  Paging file quota 
macro JIB$L_PGFLCNT = 60,0,32,0 %;      !  Paging file limit 
macro JIB$L_CPULIM = 64,0,32,0 %;       !  CPU time quota remaining 
macro JIB$W_PRCCNT = 68,0,16,0 %;       !  Count of subprocesses existing 
macro JIB$W_PRCLIM = 70,0,16,0 %;       !  Limit on number of subprocesses 
macro JIB$W_SHRFCNT = 72,0,16,0 %;      !  Shared file block count remaing 
macro JIB$W_SHRFLIM = 74,0,16,0 %;      !  Shared file count limit 
macro JIB$W_ENQCNT = 76,0,16,0 %;       !  Enqueue count avail 
macro JIB$W_ENQLM = 78,0,16,0 %;        !  Enqueue limit 
macro JIB$W_MAXJOBS = 80,0,16,0 %;      !  Max jobs limit on user
macro JIB$W_MAXDETACH = 82,0,16,0 %;    !  Max detached processes for user
macro JIB$L_MPID = 84,0,32,0 %;         !  PID of master process 
macro JIB$L_JLNAMFL = 88,0,32,0 %;      !  Forward link for job-wide logical names 
macro JIB$L_JLNAMBL = 92,0,32,0 %;      !  Back link for job-wide logical names 
macro JIB$L_PDAYHOURS = 96,0,32,0 %;    !  Field describing primary day access 
macro JIB$L_ODAYHOURS = 100,0,32,0 %;   !  Field describing off day access 
macro JIB$B_JOBTYPE = 104,0,8,0 %;      !  Job origin type
macro JIB$B_FLAGS = 105,0,8,0 %;        !  FLAG bits
macro JIB$V_BYTCNT_WAITERS = 105,0,1,0 %; !  Processes are waiting on BYTCNT
macro JIB$V_TQCNT_WAITERS = 105,1,1,0 %; !  Processes are waiting on TQCNT
macro JIB$L_ORG_BYTLM = 108,0,32,0 %;   !  Original BYTLM
macro JIB$L_ORG_PBYTLM = 112,0,32,0 %;  !  Original PBYTLM
macro JIB$L_SPARE = 116,0,32,0 %;       !  ...spare...
macro JIB$L_CWPS_TIME = 120,0,32,0 %;   !  Temp for CWPS
macro JIB$L_CWPS_COUNT = 124,0,32,0 %;  !  Temp for CWPS
macro JIB$Q_CWPS_Q1 = 128,0,0,0 %;
literal JIB$S_CWPS_Q1 = 8;              !  Temp for CWPS
macro JIB$L_CWPS_L1 = 136,0,32,0 %;     !  Temp for CWPS
macro JIB$L_CWPS_L2 = 140,0,32,0 %;     !  Temp for CWPS
macro JIB$L_JTQUOTA = 144,0,32,0 %;     !  Job table quota
 
!*** MODULE $KA410DEF ***
! ++
!  VIRTUAL ADDRESS SPACE LAYOUT FOR VAXstation 2000 CPU NODE SPECIFIC REGION
!  POINTED TO BY EXE$GL_CPUNODSP
! --
literal KA410$B_CFGTST = 0;             !  CONFIG AND TEST REG
literal KA410$L_SIDEX = 516;            !  SYS ID EXTENSION REG
literal KA410$L_HLTCOD = 1024;          !  HALT CODE REGISTER
literal KA410$L_MSER = 1028;            !  MEM SYSTEM ERR REG
literal KA410$L_MEAR = 1032;            !  MEM ERROR ADDR REG
literal KA410$B_INTMSK = 1036;          !  INTERRUPT MASK REG
literal KA410$B_VDCORG = 1037;          !  VIDEO DISPLAY ORIGIN REG
literal KA410$B_VDCSEL = 1038;          !  VIDEO CTLR SELECT REG
literal KA410$B_INTREQ = 1039;          !  INTERRUPT REQ REG
literal KA410$B_INTCLR = 1039;          !  INTERRUPT CLEAR REG
literal KA410$B_NIADRS = 1536;          !  NETWORK ADDRESS ROM START
literal KA410$B_NIADRE = 1663;          !  NETWORK ADDRESS ROM END
literal KA410$W_SERCSR = 2048;          !  SERIAL LINE CSR
literal KA410$W_SERRBF = 2052;          !   " " RECEIVE BUFFER
literal KA410$W_SERLPR = 2052;          !   " " LINE PARAM REG
literal KA410$W_SERTCR = 2056;          !   " " TRANSMIT CONTROL REG
literal KA410$W_SERMSR = 2060;          !   " " MODEM STATUS REG
literal KA410$W_SERTDR = 2060;          !   " " TRANSMIT DATA REG
literal KA410$L_TODSEC = 2560;          !  TODR SECOND
literal KA410$L_TODSAL = 2564;          !  TODR SECOND ALARM
literal KA410$L_TODMIN = 2568;          !  TODR MINUTE
literal KA410$L_TODMAL = 2572;          !  TODR MINUTE ALARM
literal KA410$L_TODHR = 2576;           !  TODR HOUR
literal KA410$L_TODHAL = 2580;          !  TODR HOUR ALARM
literal KA410$L_TODDWK = 2584;          !  TODR DAY OF WEEK
literal KA410$L_TODDAY = 2588;          !  TODR DAY OF MONTH
literal KA410$L_TODMON = 2592;          !  TODR MONTH
literal KA410$L_TODYR = 2596;           !  TODR YEAR
literal KA410$L_TODCSA = 2600;          !  TODR CSR A
literal KA410$L_TODCSB = 2604;          !  TODR CSR B
literal KA410$L_TODCSC = 2608;          !  TODR CSR C
literal KA410$L_TODCSD = 2612;          !  TODR CSR D
literal KA410$B_RAMST = 2616;           !  TODR 1ST BYTE RAM
literal KA410$B_CPMBX = 2616;           !  CONSOLE MAILBOX
literal KA410$B_CPFLG = 2620;           !  CONSOLE FLAGS
literal KA410$B_LK201 = 2624;           !  KEYBOARD VARIATION
literal KA410$B_CONID = 2628;           !  CONSOLE DEV TYPE
literal KA410$L_SCRPTR = 2632;          !  CP SCRATCH RAM ADDR
literal KA410$L_BATCHK = 2696;          !  BATTERY CHECK DATA
literal KA410$L_BOODEV = 2712;          !  DEFAULT BOOT DEVICE
literal KA410$L_BOOFLG = 2728;          !  DEFAULT R5 FLAGS
literal KA410$B_SCRLEN = 2744;          !  SIZE OF CP SCR RAM
literal KA410$B_RAMEND = 2812;          !  TODR LAST BYTE RAM
literal KA410$B_DKCREG = 3072;          !  DISK REG DATA ACCESS
literal KA410$B_DKCCMD = 3076;          !  DISK CONTROLLER COMMAND
literal KA410$W_DKSTAT = 3076;          !  DISK INTERRUPT STATUS
literal KA410$B_SCTLS = 3200;           !  TAPE CTLR CHIP START
literal KA410$B_SCTLE = 3231;           !  TAPE CTLR CHIP END
literal KA410$B_SCDADR = 3232;          !  TAPE DMA ADR REG
literal KA410$W_SCDCNT = 3264;          !  TAPE DMA BYTCNT REG
literal KA410$B_SCDDIR = 3268;          !  TAPE DMA XFER DIRECTION  REG
literal KA410$B_DKBUFS = 3584;          !  DISK 16KB BUFFER START
literal KA410$B_DKBUFE = 19967;         !  DISK 16KB BUFFER END
literal KA410$W_NIRDP = 19968;          !  NI REG DATA PORT
literal KA410$W_NIRAP = 19972;          !  NI REG ADR PORT
literal KA410$W_VCCMD = 20480;          !  VIDEO CURSOR COMMAND REG
literal KA410$L_VCXPOS = 20484;         !  VIDEO CURSOR X POSITION
literal KA410$L_VCYPOS = 20488;         !  VIDEO CURSOR Y POSITION
literal KA410$L_VCXMN1 = 20492;         !  VIDEO CURSOR REGION 1 LEFT EDGE
literal KA410$L_VCXMX1 = 20496;         !  VIDEO CURSOR REGION 1 RIGHT EDGE
literal KA410$L_VCYMN1 = 20500;         !  VIDEO CURSOR REGION 1 TOP EDGE
literal KA410$L_VCYMX1 = 20504;         !  VIDEO CURSOR REGION 1 BOTTOM EDGE
literal KA410$L_VCXMN2 = 20524;         !  VIDEO CURSOR REGION 2 LEFT EDGE
literal KA410$L_VCXMX2 = 20528;         !  VIDEO CURSOR REGION 2 RIGHT EDGE
literal KA410$L_VCYMN2 = 20532;         !  VIDEO CURSOR REGION 2 TOP EDGE
literal KA410$L_VCYMX2 = 20536;         !  VIDEO CURSOR REGION 2 BOTTOM EDGE
literal KA410$L_VCLOAD = 20540;         !  VIDEO CURSOR SPRITE PATTERN LOAD
literal KA410$B_NIROMS = 20992;         !  START OF NETWORK OPTION ROM
literal KA410$B_NIROME = 22015;         !  END OF MAPPED PORTION OF ROM
literal KA410$B_VDROMS = 22016;         !  START OF VIDEO OPTION ROM
literal KA410$B_VDROME = 23039;         !  END OF MAPPED PORTION OF ROM
literal KA410$B_SCRAMS = 23040;         !  BEGIN OF CONSOLE PROG SCRATCH RAM
literal KA410$A_MCT = 23040;            !  PHY ADDR OF MAIN CONFIG TABLE 
literal KA410$A_OP1RAM = 23044;         !  PHY ADDR OF OPTION 1 RAM
literal KA410$A_OP2RAM = 23048;         !  PHY ADDR OF OPTION 2 RAM 
literal KA410$A_GOOD64 = 23052;         !  PHY ADDR OF 64KB GOOD MEMORY
literal KA410$A_BMAP = 23056;           !  PHY ADDR OF MEMORY BITMAP
literal KA410$L_BMAPL = 23060;          !  LENGTH IN BYTES OF BITMAP
literal KA410$L_KBGOOD = 23064;         !  LK201 KEYBOARD STATUS
literal KA410$L_MSGOOD = 23068;         !  MOUSE/TABLE STATUS
literal KA410$A_INIOUT = 23072;         !  PA OF ROUTINE TO INIT OUTPUT
literal KA410$A_RSTOUT = 23076;         !  PA OF ROUTINE TO RESET OUTPUT
literal KA410$A_INIINP = 23080;         !  PA OF ROUTINE TO INIT INPUT
literal KA410$A_RSTINP = 23084;         !  PA OF ROUTINE TO RESET INPUT
literal KA410$A_GETCHR = 23088;         !  PA OF ROUTINE TO GET CHAR
literal KA410$A_PUTCHR = 23092;         !  PA OF ROUTINE TO PUT CHAR
literal KA410$A_FBEEP = 23096;          !  PA OF ROUTINE TO PUT BELL
literal KA410$L_CURBOT = 23100;         !  MAX CURSOR ROW
literal KA410$L_CURCOL = 23104;         !  CURRENT CURSOR COLUMN
literal KA410$L_CURROW = 23108;         !  CURRENT CURSOR ROW
literal KA410$A_SAVCON = 23112;         !  PA OF SAVE CONSOLE ROUTINE
literal KA410$A_RSTCON = 23116;         !  PA OF RESET CONSOLE ROUTINE
literal KA410$L_STFLAG = 23120;         !  SELFTEST FLAGS
literal KA410$A_STLOOP = 23124;         !  SELFTEST LOOP ADDRESS
literal KA410$L_VMB_VERSION = 23504;    !  VMB VERSION NUMBER
literal KA410$L_CELL_HGHT = 23524;      !  CELL HEIGHT FOR CHARACTER IN ROM
literal KA410$L_SELFTEST_VERSION = 23508; !  SELFTEST VERSION
literal KA410$L_CONSOLE_VERSION = 23512; !  CONSOLE VERSION
literal KA410$B_DISKMASK = 23516;       !  DISK UNITS MASK
literal KA410$B_DISKCTRL = 23517;       !  DISK CONTROLLER MASK
literal KA410$B_TAPEMASK = 23520;       !  TAPE UNITS MASK
literal KA410$B_TAPECTRL = 23521;       !  TAPE CONTROLLER MASK
literal KA410$L_QD_MEM = 23544;         !  COLOR MEMORY
literal KA410$L_MAXCOL = 23548;         !  MAXIMUM COLUMN ON SCREEN
literal KA410$B_SCRAME = 23551;         !  END OF CONSOLE PROG SCRATCH RAM
literal KA410$B_PCROMS = 23552;         !  PC-DOS COPROCESSOR ROM START
literal KA410$B_PCROME = 24575;         !  PC-DOS COPROCESSOR ROM END
literal KA410$B_XROMS = 24576;          !  FUTURE ROM START
literal KA410$B_XROME = 25599;          !  FUTURE ROM END
literal KA410$B_PCCSR = 25600;          !  START OF PC-DOS REGISTERS
literal KA410$B_XCSR = 26112;           !  REGISTERS FOR FUTURE OPTION
literal KA410$B_VDCSR1 = 26624;         !  CSRS FOR OPTION IN VIDEO SLOT
literal KA410$B_VDCSR2 = 27136;         !  CSRS FOR COLOR VIDEO (3 pages)
literal KA410$S_KA410DEF = 28672;       !  SIZE MAPPED BY $KA410DEF
!  Configuration and Test Register
literal KA410$M_CFGTST_MTYPE = 3;
literal KA410$M_CFGTST_NETOPT = 4;
literal KA410$M_CFGTST_VIDOPT = 8;
literal KA410$M_CFGTST_CURTST = 16;
literal KA410$M_CFGTST_L3CON = 32;
literal KA410$S_CFGTST = 1;
macro KA410$V_CFGTST_MTYPE = 0,0,2,0 %;
literal KA410$S_CFGTST_MTYPE = 2;       ! MEMORY OPTION BOARD PRESENT
!   00 = NO MEM BOARD
!   01 = 1024KB
!   10 = 4096KB
!   11 = 8192KB
macro KA410$V_CFGTST_NETOPT = 0,2,1,0 %; ! NETWORK OPTION PRESENT
macro KA410$V_CFGTST_VIDOPT = 0,3,1,0 %; ! VIDEO OPTION PRESENT
macro KA410$V_CFGTST_CURTST = 0,4,1,0 %; ! CURSOR TEST
macro KA410$V_CFGTST_L3CON = 0,5,1,0 %; ! LINE 3 CONSOLE
macro KA410$V_CFGTST_FILL1 = 0,6,1,0 %; ! UNUSED
!  System ID Extension Longword
literal KA410$S_SIDEX = 4;
macro KA410$W_SIDEX_FILL1 = 0,0,16,0 %; ! RESERVED
macro KA410$B_SIDEX_ROMVER = 2,0,8,0 %; ! BOOT ROM VERSION
macro KA410$B_SIDEX_SYSCODE = 3,0,8,0 %; ! SYSTEM CODE. 4=VAXstar
!  Memory System Error Register (MSER)
literal KA410$M_MSER_PEN = 1;
literal KA410$M_MSER_WRW = 2;
literal KA410$M_MSER_PER = 64;
literal KA410$M_MSER_CD0 = 256;
literal KA410$S_MSER = 4;
macro KA410$V_MSER_PEN = 0,0,1,0 %;     ! PARITY ENABLE
macro KA410$V_MSER_WRW = 0,1,1,0 %;     ! WRITE WRONG PARITY
macro KA410$V_MSER_FILL1 = 0,2,4,0 %;
literal KA410$S_MSER_FILL1 = 4;         ! UNUSED
macro KA410$V_MSER_PER = 0,6,1,0 %;     ! PARITY ERROR
macro KA410$V_MSER_FILL2 = 0,7,1,0 %;   ! UNUSED
macro KA410$V_MSER_CD0 = 0,8,1,0 %;     ! MEMORY CODE (SAME AS PER)
macro KA410$V_MSER_FILL3 = 0,9,23,0 %;
literal KA410$S_MSER_FILL3 = 23;        ! UNUSED
!  Memory Error Address Register (MEAR)
literal KA410$M_MEAR_ADR = 32767;
literal KA410$M_MEAR_FILL1 = -32768;
literal KA410$S_MEAR = 4;
macro KA410$V_MEAR_ADR = 0,0,15,0 %;
literal KA410$S_MEAR_ADR = 15;          ! FAILING ADR BITS 23:09
macro KA410$V_MEAR_FILL1 = 0,15,17,0 %;
literal KA410$S_MEAR_FILL1 = 17;        ! UNUSED, READ AS 0
!  Interrupt Mask Register (INTMSK)
literal KA410$M_INTMSK_DC = 1;
literal KA410$M_INTMSK_SC = 2;
literal KA410$M_INTMSK_VS = 4;
literal KA410$M_INTMSK_VF = 8;
literal KA410$M_INTMSK_NS = 16;
literal KA410$M_INTMSK_NP = 32;
literal KA410$M_INTMSK_ST = 64;
literal KA410$M_INTMSK_SR = 128;
literal KA410$S_INTMSK = 1;
macro KA410$V_INTMSK_DC = 0,0,1,0 %;    ! Disk controller
macro KA410$V_INTMSK_SC = 0,1,1,0 %;    ! Tape controller
macro KA410$V_INTMSK_VS = 0,2,1,0 %;    ! Video secondary
macro KA410$V_INTMSK_VF = 0,3,1,0 %;    ! Video end of frame
macro KA410$V_INTMSK_NS = 0,4,1,0 %;    ! Network ctlr 2ndary
macro KA410$V_INTMSK_NP = 0,5,1,0 %;    ! Network ctlr primary
macro KA410$V_INTMSK_ST = 0,6,1,0 %;    ! Serial line transmitter done
macro KA410$V_INTMSK_SR = 0,7,1,0 %;    ! Serial line receiver or silo full
!  Interrupt Mask Register (INTREQ)
literal KA410$M_INTREQ_DC = 1;
literal KA410$M_INTREQ_SC = 2;
literal KA410$M_INTREQ_VS = 4;
literal KA410$M_INTREQ_VF = 8;
literal KA410$M_INTREQ_NS = 16;
literal KA410$M_INTREQ_NP = 32;
literal KA410$M_INTREQ_ST = 64;
literal KA410$M_INTREQ_SR = 128;
literal KA410$S_INTREQ = 1;
macro KA410$V_INTREQ_DC = 0,0,1,0 %;    ! Disk controller
macro KA410$V_INTREQ_SC = 0,1,1,0 %;    ! Tape controller
macro KA410$V_INTREQ_VS = 0,2,1,0 %;    ! Video secondary
macro KA410$V_INTREQ_VF = 0,3,1,0 %;    ! Video end of frame
macro KA410$V_INTREQ_NS = 0,4,1,0 %;    ! Network ctlr 2ndary
macro KA410$V_INTREQ_NP = 0,5,1,0 %;    ! Network ctlr primary
macro KA410$V_INTREQ_ST = 0,6,1,0 %;    ! Serial line transmitter done
macro KA410$V_INTREQ_SR = 0,7,1,0 %;    ! Serial line receiver or silo full
!  Interrupt Mask Register (INTCLR)
literal KA410$M_INTCLR_DC = 1;
literal KA410$M_INTCLR_SC = 2;
literal KA410$M_INTCLR_VS = 4;
literal KA410$M_INTCLR_VF = 8;
literal KA410$M_INTCLR_NS = 16;
literal KA410$M_INTCLR_NP = 32;
literal KA410$M_INTCLR_ST = 64;
literal KA410$M_INTCLR_SR = 128;
literal KA410$S_INTCLR = 1;
macro KA410$V_INTCLR_DC = 0,0,1,0 %;    ! Disk controller
macro KA410$V_INTCLR_SC = 0,1,1,0 %;    ! Tape controller
macro KA410$V_INTCLR_VS = 0,2,1,0 %;    ! Video secondary
macro KA410$V_INTCLR_VF = 0,3,1,0 %;    ! Video end of frame
macro KA410$V_INTCLR_NS = 0,4,1,0 %;    ! Network ctlr 2ndary
macro KA410$V_INTCLR_NP = 0,5,1,0 %;    ! Network ctlr primary
macro KA410$V_INTCLR_ST = 0,6,1,0 %;    ! Serial line transmitter done
macro KA410$V_INTCLR_SR = 0,7,1,0 %;    ! Serial line receiver or silo full
!  Console mailbox register (CPMBX) - located in non-volatile RAM
literal KA410$M_CPMBX_HLT = 3;
literal KA410$M_CPMBX_BIP = 4;
literal KA410$M_CPMBX_RIP = 8;
literal KA410$S_CPMBX = 1;
macro KA410$V_CPMBX_HLT = 0,0,2,0 %;
literal KA410$S_CPMBX_HLT = 2;          ! Halt action 
!  00 = restart
!  01 = restart
!  02 = boot 
!  03 = halt 
macro KA410$V_CPMBX_BIP = 0,2,1,0 %;    ! Boot in Progress 
macro KA410$V_CPMBX_RIP = 0,3,1,0 %;    ! Restart in Progress 
!  Disk unit presence mask
literal KA410$M_DISKMASK_DUA0 = 1;
literal KA410$M_DISKMASK_DUA1 = 2;
literal KA410$M_DISKMASK_DUA2 = 4;
literal KA410$S_DISKMASK = 1;
macro KA410$V_DISKMASK_DUA0 = 0,0,1,0 %; !  Unit 0 exists
macro KA410$V_DISKMASK_DUA1 = 0,1,1,0 %; !  Unit 1 exists
macro KA410$V_DISKMASK_DUA2 = 0,2,1,0 %; !  Unit 2 exists
!  Disk controller mask
literal KA410$M_DISKCTRL_CTRL = 1;
literal KA410$M_DISKCTRL_BUFFER = 2;
literal KA410$S_DISKCTRL = 1;
macro KA410$V_DISKCTRL_CTRL = 0,0,1,0 %; !  Disk controller exists
macro KA410$V_DISKCTRL_BUFFER = 0,1,1,0 %; !  Disk buffer exists
!  Tape unit presence mask
literal KA410$M_TAPEMASK_SCSI_0 = 1;
literal KA410$M_TAPEMASK_SCSI_1 = 2;
literal KA410$S_TAPEMASK = 1;
macro KA410$V_TAPEMASK_SCSI_0 = 0,0,1,0 %; !  Unit 0 exists (system)
macro KA410$V_TAPEMASK_SCSI_1 = 0,1,1,0 %; !  Unit 1 exists (drive)
!  Tape controller mask
literal KA410$M_TAPECTRL_CTRL = 1;
literal KA410$M_TAPECTRL_BUFFER = 2;
literal KA410$S_TAPECTRL = 1;
macro KA410$V_TAPECTRL_CTRL = 0,0,1,0 %; !  Tape controller exists
macro KA410$V_TAPECTRL_BUFFER = 0,1,1,0 %; !  Tape buffer exists
 
!*** MODULE $KA420DEF ***
! ++
!  VIRTUAL ADDRESS SPACE LAYOUT FOR VAXSTATION 3100 CPU NODE SPECIFIC REGION
!  POINTED TO BY EXE$GL_CPUNODSP
! --
literal KA420$W_CFGTST = 0;             !  CONFIG AND TEST REG 
literal KA420$B_IORESET = 0;            !  IORESET REG
literal KA420$L_SIDEX = 516;            !  SYS ID EXTENSION REG
literal KA420$L_HLTCOD = 1024;          !  HALT CODE REGISTER
literal KA420$L_MSER = 1028;            !  MEM SYSTEM ERR REG
literal KA420$L_MEAR = 1032;            !  MEM ERROR ADDR REG
literal KA420$B_INTMSK = 1036;          !  INTERRUPT MASK REG
literal KA420$B_VDCORG = 1037;          !  VIDEO DISPLAY ORIGIN REG
literal KA420$B_VDCSEL = 1038;          !  VIDEO CTLR SELECT REG
literal KA420$B_INTREQ = 1039;          !  INTERRUPT REQ REG
literal KA420$B_INTCLR = 1039;          !  INTERRUPT CLEAR REG
literal KA420$W_DIAGDISP = 1040;        !  DIAGNOSTIC DISPLAY REG
literal KA420$L_PAR_CTL = 1044;         !  PARITY CONTROL REG
literal KA420$W_DIAGTIME = 1054;        !  DIANOSTIC TIME REG
literal KA420$B_NIADRS = 1536;          !  NETWORK ADDRESS ROM START
literal KA420$B_NIADRE = 1663;          !  NETWORK ADDRESS ROM END
literal KA420$W_SERCSR = 2048;          !  SERIAL LINE CSR
literal KA420$W_SERRBF = 2052;          !   " " RECEIVE BUFFER
literal KA420$W_SERLPR = 2052;          !   " " LINE PARAM REG
literal KA420$W_SERTCR = 2056;          !   " " TRANSMIT CONTROL REG
literal KA420$W_SERMSR = 2060;          !   " " MODEM STATUS REG
literal KA420$W_SERTDR = 2060;          !   " " TRANSMIT DATA REG
literal KA420$L_TODSEC = 2560;          !  TODC SECOND
literal KA420$L_TODSAL = 2564;          !  TODC SECOND ALARM
literal KA420$L_TODMIN = 2568;          !  TODC MINUTE
literal KA420$L_TODMAL = 2572;          !  TODC MINUTE ALARM
literal KA420$L_TODHR = 2576;           !  TODC HOUR
literal KA420$L_TODHAL = 2580;          !  TODC HOUR ALARM
literal KA420$L_TODDWK = 2584;          !  TODC DAY OF WEEK
literal KA420$L_TODDAY = 2588;          !  TODC DAY OF MONTH
literal KA420$L_TODMON = 2592;          !  TODC MONTH
literal KA420$L_TODYR = 2596;           !  TODC YEAR
literal KA420$L_TODCSA = 2600;          !  TODC CSR A
literal KA420$L_TODCSB = 2604;          !  TODC CSR B
literal KA420$L_TODCSC = 2608;          !  TODC CSR C
literal KA420$L_TODCSD = 2612;          !  TODC CSR D
literal KA420$B_RAMST = 2616;           !  TODC 1ST BYTE RAM
literal KA420$B_CPMBX = 2616;           !  CONSOLE MAILBOX
literal KA420$B_CPFLG = 2620;           !  CONSOLE FLAGS
literal KA420$B_LK201 = 2624;           !  KEYBOARD VARIATION
literal KA420$B_CONID = 2628;           !  CONSOLE DEV TYPE
literal KA420$L_SCRPTR = 2632;          !  CP SCRATCH RAM ADDR
literal KA420$L_BATCHK = 2696;          !  BATTERY CHECK DATA
literal KA420$L_PASSWORD = 2712;        !  ETHERNET TRIGGER PASSWORD CODE
literal KA420$L_BOOFLG = 2728;          !  DEFAULT R5 FLAGS
literal KA420$B_SCRLEN = 2744;          !  SIZE OF CP SCR RAM
literal KA420$B_SCSI = 2748;            !  CPU ID location
literal KA420$B_BOODEV_LEN = 2752;      !  DEFAULT BOOT DEVICE NAME LENGTH
literal KA420$B_BOODEV = 2756;          !  DEFAULT BOOT DEVICE
literal KA420$B_RAMEND = 2812;          !  TODR LAST BYTE RAM
literal KA420$B_DKCREG = 3072;          !  DISK REG DATA ACCESS
literal KA420$B_DKCCMD = 3076;          !  DISK CONTROLLER COMMAND
literal KA420$W_DKSTAT = 3076;          !  DISK INTERRUPT STATUS
literal KA420$B_ASCSICSR = 3200;        !  SCSI CONTROLLER A
literal KA420$B_BSCSICSR = 3456;        !  SCSI CONTROLLER B
literal KA420$B_BSCINICMD = 3460;       !  B SCSI INITIATOR COMMAND REG
literal KA420$B_SCTLS = 3200;           !  TAPE CTLR CHIP START
literal KA420$B_SCTLE = 3231;           !  TAPE CTLR CHIP END
literal KA420$B_SCSOUTDAT = 3200;       !  SCSI OUTPUT DATA REG 
literal KA420$B_SCSCURDAT = 3200;       !  SCSI CURRENT DATA REG 
literal KA420$B_SCSINICMD = 3204;       !  SCSI INITIATOR COMMAND REG
literal KA420$B_SCSMODE = 3208;         !  SCSI MODE REG
literal KA420$B_SCSTARCMD = 3212;       !  SCSI TARGET COMMAND REG
literal KA420$B_SCSSELENA = 3216;       !  SCSI SELECT ENABLE REG 
literal KA420$B_SCSCURSTA = 3216;       !  SCSI CURRENT BUS STATUS REG 
literal KA420$B_SCSDMASND = 3220;       !  SCSI START DMA SEND 
literal KA420$B_SCSSTATUS = 3220;       !  SCSI BUS AND STATUS REG 
literal KA420$B_SCSDMATRC = 3224;       !  SCSI START DMA TARGET RECEIVE 
literal KA420$B_SCSINDATA = 3224;       !  SCSI INPUT DATA REG 
literal KA420$B_SCSDMAIRC = 3228;       !  SCSI START DMA INITIATOR RECEIVE
literal KA420$B_SCSRESET = 3228;        !  SCSI RESET INTERRUPT/ERROR 
literal KA420$B_SCDADR = 3232;          !  SCSI DMA ADR REG
literal KA420$W_SCDCNT = 3264;          !  SCSI DMA BYTCNT REG
literal KA420$B_SCDDIR = 3268;          !  SCSI DMA XFER DIRECTION  
literal KA420$B_STCMODE = 3296;         !  STORAGE CONTROLLER MODE
literal KA420$B_D16BUFS = 3584;         !  DISK 16KB BUFFER START
literal KA420$B_D16BUFE = 19967;        !  DISK 16KB BUFFER END
literal KA420$W_NIRDP = 19968;          !  NI REG DATA PORT
literal KA420$W_NIRAP = 19972;          !  NI REG ADR PORT
literal KA420$W_VCCMD = 20480;          !  VIDEO CURSOR COMMAND REG
literal KA420$W_VCXPOS = 20484;         !  VIDEO CURSOR X POSITION
literal KA420$W_VCYPOS = 20488;         !  VIDEO CURSOR Y POSITION
literal KA420$W_VCXMN1 = 20492;         !  VIDEO CURSOR REGION 1 LEFT EDGE
literal KA420$W_VCXMX1 = 20496;         !  VIDEO CURSOR REGION 1 RIGHT EDGE
literal KA420$W_VCYMN1 = 20500;         !  VIDEO CURSOR REGION 1 TOP EDGE
literal KA420$W_VCYMX1 = 20504;         !  VIDEO CURSOR REGION 1 BOTTOM EDGE
literal KA420$W_VCXMN2 = 20524;         !  VIDEO CURSOR REGION 2 LEFT EDGE
literal KA420$W_VCXMX2 = 20528;         !  VIDEO CURSOR REGION 2 RIGHT EDGE
literal KA420$W_VCYMN2 = 20532;         !  VIDEO CURSOR REGION 2 TOP EDGE
literal KA420$W_VCYMX2 = 20536;         !  VIDEO CURSOR REGION 2 BOTTOM EDGE
literal KA420$W_VCLOAD = 20540;         !  VIDEO CURSOR SPRITE PATTERN LOAD
literal KA420$L_CACR = 20992;           !  SECONDARY CACHE CONTROL REG
literal KA420$B_VDROMS = 22016;         !  START OF VIDEO OPTION ROM
literal KA420$B_VDROME = 23039;         !  END OF MAPPED PORTION OF ROM
literal KA420$B_SCRAMS = 23040;         !  BEGIN OF CONSOLE PROG SCRATCH RAM
literal KA420$A_MCT = 23040;            !  PHY ADDR OF MAIN CONFIG TABLE 
literal KA420$A_OP1RAM = 23044;         !  PHY ADDR OF OPTION 1 RAM
literal KA420$A_OP2RAM = 23048;         !  PHY ADDR OF OPTION 2 RAM 
literal KA420$A_GOOD64 = 23052;         !  PHY ADDR OF 64KB GOOD MEMORY
literal KA420$A_BMAP = 23056;           !  PHY ADDR OF MEMORY BITMAP
literal KA420$L_BMAPL = 23060;          !  LENGTH IN BYTES OF BITMAP
literal KA420$L_KBGOOD = 23064;         !  LK201 KEYBOARD STATUS
literal KA420$L_MSGOOD = 23068;         !  MOUSE/TABLE STATUS
literal KA420$A_INIOUT = 23072;         !  PA OF ROUTINE TO INIT OUTPUT
literal KA420$A_RSTOUT = 23076;         !  PA OF ROUTINE TO RESET OUTPUT
literal KA420$A_INIINP = 23080;         !  PA OF ROUTINE TO INIT INPUT
literal KA420$A_RSTINP = 23084;         !  PA OF ROUTINE TO RESET INPUT
literal KA420$A_GETCHR = 23088;         !  PA OF ROUTINE TO GET CHAR
literal KA420$A_PUTCHR = 23092;         !  PA OF ROUTINE TO PUT CHAR
literal KA420$A_FBEEP = 23096;          !  PA OF ROUTINE TO PUT BELL
literal KA420$L_CURBOT = 23100;         !  MAX CURSOR ROW
literal KA420$L_CURCOL = 23104;         !  CURRENT CURSOR COLUMN
literal KA420$L_CURROW = 23108;         !  CURRENT CURSOR ROW
literal KA420$A_SAVCON = 23112;         !  PA OF SAVE CONSOLE ROUTINE
literal KA420$A_RSTCON = 23116;         !  PA OF RESET CONSOLE ROUTINE
literal KA420$L_STFLAG = 23120;         !  SELFTEST FLAGS
literal KA420$A_STLOOP = 23124;         !  SELFTEST LOOP ADDRESS
literal KA420$L_VMB_VERSION = 23504;    !  VMB VERSION NUMBER
literal KA420$L_SELFTEST_VERSION = 23508; !  SELFTEST VERSION
literal KA420$L_CONSOLE_VERSION = 23512; !  CONSOLE VERSION
literal KA420$B_DISKMASK = 23516;       !  DISK UNITS MASK
literal KA420$B_DISKCTRL = 23517;       !  DISK CONTROLLER MASK
literal KA420$B_TAPEMASK = 23520;       !  TAPE UNITS MASK
literal KA420$B_TAPECTRL = 23521;       !  TAPE CONTROLLER MASK
literal KA420$L_CELL_HGHT = 23524;      !  CELL HEIGHT FOR CHARACTER IN ROM
literal KA420$L_QD_MEM = 23544;         !  COLOR MEMORY
literal KA420$L_MAXCOL = 23548;         !  MAXIMUM COLUMN ON SCREEN
literal KA420$B_SCRAME = 23551;         !  END OF CONSOLE PROG SCRATCH RAM
literal KA420$B_X1ROMS = 23552;         !  ADDITIONAL OPTION 1 ROM START
literal KA420$B_X1ROME = 24575;         !  ADDITIONAL OPTION 1 ROM END
literal KA420$B_X2ROMS = 24576;         !  ADDITIONAL OPTION 2 ROM START
literal KA420$B_X2ROME = 25599;         !  ADDITIONAL OPTION 2 ROM END
literal KA420$B_X1CSRS = 25600;         !  ADDIITONAL OPTION 1 CSR'S START
literal KA420$B_X2CSRS = 26112;         !  ADDITIONAL OPTION 2 CSR'S START
literal KA420$B_ASCONSTA = 26624;       !  ASYNCH SERIAL LINE OPTION CONTROL AND STATUS REGS START
literal KA420$B_VDCSR1 = 26624;         !  CSRS FOR OPTION IN VIDEO SLOT
literal KA420$B_CVADDER = 27136;        !  COLOR VIDEO OPTION ADDER REGS START
literal KA420$B_CVFIFO = 27648;         !  COLOR VIDEO OPTION FIFO COMPRESSION REGS START
literal KA420$B_CVVDAC = 27904;         !  COLOR VIDEO OPTION VIDEO DAC REGS START
literal KA420$B_CVCURS = 28160;         !  COLOR VIDEO OPTION CURSOR REGS START
literal KA420$W_CVVRDBK = 28416;        !  COLOR VIDEO OPTION VIDEO READBACK REG 
literal KA420$B_D128BUFS = 28672;       !  DATA BUFFER 128K FULL RANGE START
literal KA420$B_D128BUFE = 159743;      !  DATA BUFFER 128K FULL RANGE START
literal KA420$B_CACH2DS = 159744;       !  2ND CACHE DATA START
literal KA420$B_CACH2DE = 192511;       !  2ND CACHE DATA START
! **********************************************************************************
!                                                                                  *
!   NOTE:  The second page of the console program scratch RAM is being mapped      *
! 	   here to maintain compatibility with the offsets in $KA410DEF.	   *
! 	   Therefore the first and second page of scratch RAM are NOT virtually    *
! 	   contiguous, and <KA420$B_NIRAM-KA420$B_SCRAMS> will not correctly	   *
! 	   give the offset into scratch RAM for fields in the second page.	   *
! 	   Instead <KA420$B_NIRAM-KA420$B_SCRAM2S+^X200> should be used.	   *
!                                                                                  *
! **********************************************************************************
literal KA420$B_SCRAM2S = 192512;       !  BEGIN OF 2ND PAGE OF CONSOLE SCRATCH RAM
literal KA420$L_NICSR = 192640;         !  LOC TO WRITE NI DEVICE CSR - FOR LISTENER
literal KA420$A_NIRAM = 192644;         !  PTR TO 64KB LANCE RAM BUFFER
literal KA420$A_NIPKT = 192648;         !  LOC TO WRITE PTR TO NI PACKET DESC - FOR LISTENER
literal KA420$B_SCRAM2E = 193023;       !  END OF 2ND PAGE OF CONSOLE SCRATCH RAM
literal KA420$B_SCFWROMS = 193024;      !  STORAGE CONTROLLER OPTION FIRMWARE ROM START
literal KA420$B_SCFWROME = 194047;      !  STORAGE CONTROLLER OPTION FIRMWARE ROM END
literal KA420$S_KA420DEF = 194048;      !  SIZE MAPPED BY $KA420DEF
!  Configuration and Test Register
literal KA420$M_CFGTST_MTYPE = 7;
literal KA420$M_CFGTST_VIDOPT = 8;
literal KA420$M_CFGTST_CURTST = 16;
literal KA420$M_CFGTST_L3CON = 32;
literal KA420$M_CFGTST_CACHPR = 64;
literal KA420$M_CFGTST_VIDPR = 128;
literal KA420$M_CFGTST_DRV0PR = 256;
literal KA420$M_CFGTST_DRV1PR = 512;
literal KA420$M_CFGTST_DRV2PR = 1024;
literal KA420$M_CFGTST_DRV3PR = 2048;
literal KA420$M_CFGTST_SCSIPR = 4096;
literal KA420$M_CFGTST_STCOPT = 49152;
literal KA420$S_CFGTST = 2;
macro KA420$V_CFGTST_MTYPE = 0,0,3,0 %;
literal KA420$S_CFGTST_MTYPE = 3;       ! MEMORY OPTION BOARD PRESENT
!   000 = NO MEM BOARD  100 = 6144KB
!   001 = 1024KB        101 = 8192KB
!   010 = 2048KB        110 = 12288KB
!   011 = 4096KB        111 = 14336
macro KA420$V_CFGTST_VIDOPT = 0,3,1,0 %; ! VIDEO OPTION PRESENT
macro KA420$V_CFGTST_CURTST = 0,4,1,0 %; ! CURSOR TEST
macro KA420$V_CFGTST_L3CON = 0,5,1,0 %; ! LINE 3 CONSOLE
macro KA420$V_CFGTST_CACHPR = 0,6,1,0 %; ! CACHE PRESENT
macro KA420$V_CFGTST_VIDPR = 0,7,1,0 %; ! VIDEO CONTROLLER PRESENT
macro KA420$V_CFGTST_DRV0PR = 0,8,1,0 %; ! 1ST HARD DISK DRIVE PRESENT
macro KA420$V_CFGTST_DRV1PR = 0,9,1,0 %; ! 2ND HARD DISK DRIVE PRESENT
macro KA420$V_CFGTST_DRV2PR = 0,10,1,0 %; ! DISKETTE DIRVE PRESENT
macro KA420$V_CFGTST_DRV3PR = 0,11,1,0 %; ! 3RD HARD DISK DRIVE PRESENT
macro KA420$V_CFGTST_SCSIPR = 0,12,1,0 %; ! SCSI DEVICE PRESENT
macro KA420$V_CFGTST_FILL1 = 0,13,1,0 %; ! RESERVED
macro KA420$V_CFGTST_STCOPT = 0,14,2,0 %;
literal KA420$S_CFGTST_STCOPT = 2;      ! STORAGE CONTROLLER OPTION TYPE
!  00 = VS42X-RT CONTROLLER
!  01 = RESERVED
!  10 = RESERVED
!  11 = NO STORAGE CONTROLLER
!  System ID Extension Longword
literal KA420$S_SIDEX = 4;
macro KA420$W_SIDEX_FILL1 = 0,0,16,0 %; ! RESERVED
macro KA420$B_SIDEX_ROMVER = 2,0,8,0 %; ! BOOT ROM VERSION
macro KA420$B_SIDEX_SYSCODE = 3,0,8,0 %; ! SYSTEM CODE. 4=VAXstar
!  Interrupt Mask Register (INTMSK)
literal KA420$M_INTMSK_DC = 1;
literal KA420$M_INTMSK_SC = 2;
literal KA420$M_INTMSK_VS = 4;
literal KA420$M_INTMSK_VF = 8;
literal KA420$M_INTMSK_NS = 16;
literal KA420$M_INTMSK_NP = 32;
literal KA420$M_INTMSK_ST = 64;
literal KA420$M_INTMSK_SR = 128;
literal KA420$S_INTMSK = 1;
macro KA420$V_INTMSK_DC = 0,0,1,0 %;    ! Disk controller
macro KA420$V_INTMSK_SC = 0,1,1,0 %;    ! SCSI controller
macro KA420$V_INTMSK_VS = 0,2,1,0 %;    ! Video secondary
macro KA420$V_INTMSK_VF = 0,3,1,0 %;    ! Video end of frame
macro KA420$V_INTMSK_NS = 0,4,1,0 %;    ! Network ctlr 2ndary
macro KA420$V_INTMSK_NP = 0,5,1,0 %;    ! Network ctlr primary
macro KA420$V_INTMSK_ST = 0,6,1,0 %;    ! Serial line transmitter done
macro KA420$V_INTMSK_SR = 0,7,1,0 %;    ! Serial line receiver or silo full
!  Interrupt Mask Register (INTREQ)
literal KA420$M_INTREQ_DC = 1;
literal KA420$M_INTREQ_SC = 2;
literal KA420$M_INTREQ_VS = 4;
literal KA420$M_INTREQ_VF = 8;
literal KA420$M_INTREQ_NS = 16;
literal KA420$M_INTREQ_NP = 32;
literal KA420$M_INTREQ_ST = 64;
literal KA420$M_INTREQ_SR = 128;
literal KA420$S_INTREQ = 1;
macro KA420$V_INTREQ_DC = 0,0,1,0 %;    ! Disk controller
macro KA420$V_INTREQ_SC = 0,1,1,0 %;    ! SCSI controller
macro KA420$V_INTREQ_VS = 0,2,1,0 %;    ! Video secondary
macro KA420$V_INTREQ_VF = 0,3,1,0 %;    ! Video end of frame
macro KA420$V_INTREQ_NS = 0,4,1,0 %;    ! Network ctlr 2ndary
macro KA420$V_INTREQ_NP = 0,5,1,0 %;    ! Network ctlr primary
macro KA420$V_INTREQ_ST = 0,6,1,0 %;    ! Serial line transmitter done
macro KA420$V_INTREQ_SR = 0,7,1,0 %;    ! Serial line receiver or silo full
!  Interrupt Mask Register (INTCLR)
literal KA420$M_INTCLR_DC = 1;
literal KA420$M_INTCLR_SC = 2;
literal KA420$M_INTCLR_VS = 4;
literal KA420$M_INTCLR_VF = 8;
literal KA420$M_INTCLR_NS = 16;
literal KA420$M_INTCLR_NP = 32;
literal KA420$M_INTCLR_ST = 64;
literal KA420$M_INTCLR_SR = 128;
literal KA420$S_INTCLR = 1;
macro KA420$V_INTCLR_DC = 0,0,1,0 %;    ! Disk controller
macro KA420$V_INTCLR_SC = 0,1,1,0 %;    ! SCSI controller
macro KA420$V_INTCLR_VS = 0,2,1,0 %;    ! Video secondary
macro KA420$V_INTCLR_VF = 0,3,1,0 %;    ! Video end of frame
macro KA420$V_INTCLR_NS = 0,4,1,0 %;    ! Network ctlr 2ndary
macro KA420$V_INTCLR_NP = 0,5,1,0 %;    ! Network ctlr primary
macro KA420$V_INTCLR_ST = 0,6,1,0 %;    ! Serial line transmitter done
macro KA420$V_INTCLR_SR = 0,7,1,0 %;    ! Serial line receiver or silo full
!  Console mailbox register (CPMBX) - located in non-volatile RAM
literal KA420$M_CPMBX_HLT = 3;
literal KA420$M_CPMBX_BIP = 4;
literal KA420$M_CPMBX_RIP = 8;
literal KA420$S_CPMBX = 1;
macro KA420$V_CPMBX_HLT = 0,0,2,0 %;
literal KA420$S_CPMBX_HLT = 2;          ! Halt action 
!  00 = restart
!  01 = restart
!  02 = boot 
!  03 = halt 
macro KA420$V_CPMBX_BIP = 0,2,1,0 %;    ! Boot in Progress 
macro KA420$V_CPMBX_RIP = 0,3,1,0 %;    ! Restart in Progress 
!  Disk unit presence mask
literal KA420$M_DISKMASK_DUA0 = 1;
literal KA420$M_DISKMASK_DUA1 = 2;
literal KA420$M_DISKMASK_DUA2 = 4;
literal KA420$M_DISKMASK_DUA3 = 8;
literal KA420$S_DISKMASK = 1;
macro KA420$V_DISKMASK_DUA0 = 0,0,1,0 %; !  Unit 0 exists
macro KA420$V_DISKMASK_DUA1 = 0,1,1,0 %; !  Unit 1 exists
macro KA420$V_DISKMASK_DUA2 = 0,2,1,0 %; !  Unit 2 exists
macro KA420$V_DISKMASK_DUA3 = 0,3,1,0 %; !  Unit 3 exists
!  Disk controller mask
literal KA420$M_DISKCTRL_CTRL = 1;
literal KA420$M_DISKCTRL_BUFFER = 2;
literal KA420$S_DISKCTRL = 1;
macro KA420$V_DISKCTRL_CTRL = 0,0,1,0 %; !  Disk controller exists
macro KA420$V_DISKCTRL_BUFFER = 0,1,1,0 %; !  Disk buffer exists
!  Tape unit presence mask
literal KA420$M_TAPEMASK_SCSI_0 = 1;
literal KA420$M_TAPEMASK_SCSI_1 = 2;
literal KA420$S_TAPEMASK = 1;
macro KA420$V_TAPEMASK_SCSI_0 = 0,0,1,0 %; !  Unit 0 exists (system)
macro KA420$V_TAPEMASK_SCSI_1 = 0,1,1,0 %; !  Unit 1 exists (drive)
!  Tape controller mask
literal KA420$M_TAPECTRL_CTRL = 1;
literal KA420$M_TAPECTRL_BUFFER = 2;
literal KA420$S_TAPECTRL = 1;
macro KA420$V_TAPECTRL_CTRL = 0,0,1,0 %; !  Tape controller exists
macro KA420$V_TAPECTRL_BUFFER = 0,1,1,0 %; !  Tape buffer exists
!  Parity control register
literal KA420$M_PAR_CTL_DPEN = 1;
literal KA420$M_PAR_CTL_CPEN = 2;
literal KA420$M_PAR_CTL_DMA = 16777216;
literal KA420$S_PAR_CTL = 4;
macro KA420$V_PAR_CTL_DPEN = 0,0,1,0 %; ! DMA parity enable
macro KA420$V_PAR_CTL_CPEN = 0,1,1,0 %; ! CPU parity enable
macro KA420$V_PAR_CTL_FILL = 0,2,22,0 %;
literal KA420$S_PAR_CTL_FILL = 22;      ! RESERVED
macro KA420$V_PAR_CTL_DMA = 0,24,1,0 %; ! Lance DMA control
!  Cache Control Register
literal KA420$M_CACR_DIA = 1;
literal KA420$M_CACR_WWP = 2;
literal KA420$M_CACR_CEN = 16;
literal KA420$M_CACR_TPE = 32;
literal KA420$M_CACR_CSP = 192;
literal KA420$M_CACR_TAG = 261888;
literal KA420$M_CACR_TGV = 524288;
literal KA420$M_CACR_TGP = 1048576;
literal KA420$M_CACR_TPP = 2097152;
literal KA420$M_CACR_BMS = 268435456;
literal KA420$M_CACR_CP = -536870912;
literal KA420$S_CACR = 4;
macro KA420$V_CACR_DIA = 0,0,1,0 %;     ! DIAGNOSTIC MODE
macro KA420$V_CACR_WWP = 0,1,1,0 %;     ! WRITE WRONG PARITY
macro KA420$V_CACR_FILL1 = 0,2,2,0 %;
literal KA420$S_CACR_FILL1 = 2;         ! RESERVED
macro KA420$V_CACR_CEN = 0,4,1,0 %;     ! CACHE ENABLE
macro KA420$V_CACR_TPE = 0,5,1,0 %;     ! TAG PARITY ERROR
macro KA420$V_CACR_CSP = 0,6,2,0 %;
literal KA420$S_CACR_CSP = 2;           ! CVAX CLOCK SPEED
!  00 = RESERVED
!  01 = RESERVED
!  10 = 80 NANOSECONDS
!  11 = 100 NANOSECONDS
macro KA420$V_CACR_TAG = 0,8,10,0 %;
literal KA420$S_CACR_TAG = 10;          ! TAG
macro KA420$V_CACR_FILL2 = 0,18,1,0 %;  ! RESERVED
macro KA420$V_CACR_TGV = 0,19,1,0 %;    ! VALID FLAG
macro KA420$V_CACR_TGP = 0,20,1,0 %;    ! TAG PARITY
macro KA420$V_CACR_TPP = 0,21,1,0 %;    ! TAG PREDICTED PARITY
macro KA420$V_CACR_FILL3 = 0,22,6,0 %;
literal KA420$S_CACR_FILL3 = 6;         ! RESERVED
macro KA420$V_CACR_BMS = 0,28,1,0 %;    ! BASE MEMORY MODULE SIZE
macro KA420$V_CACR_CP = 0,29,3,0 %;
literal KA420$S_CACR_CP = 3;            ! PARITY FROM LAST NON-IO READ ON DAL BUS
 
!*** MODULE $KA43DEF ***
literal KA43$L_CFGTST = 0;
literal KA43$B_IORESET = 0;
literal KA43$L_SYSTYPE = 516;
literal KA43$L_HLTCOD = 1024;
literal KA43$B_INTMSK = 1036;
literal KA43$B_VDCORG = 1037;
literal KA43$B_VDCSEL = 1038;
literal KA43$B_INTREQ = 1039;
literal KA43$B_INTCLR = 1039;
literal KA43$W_DIAGDISP = 1040;
literal KA43$L_PARCTL = 1044;
literal KA43$W_DIAGTIME = 1054;
literal KA43$B_NIADRS = 1536;
literal KA43$B_NIADRE = 1663;
literal KA43$W_SERCSR = 2048;
literal KA43$W_SERRBF = 2052;
literal KA43$W_SERLPR = 2052;
literal KA43$W_SERTCR = 2056;
literal KA43$W_SERMSR = 2060;
literal KA43$W_SERTDR = 2060;
literal KA43$L_TODSEC = 2560;
literal KA43$L_TODSAL = 2564;
literal KA43$L_TODMIN = 2568;
literal KA43$L_TODMAL = 2572;
literal KA43$L_TODHR = 2576;
literal KA43$L_TODHAL = 2580;
literal KA43$L_TODDWK = 2584;
literal KA43$L_TODDAY = 2588;
literal KA43$L_TODMON = 2592;
literal KA43$L_TODYR = 2596;
literal KA43$L_TODCSA = 2600;
literal KA43$L_TODCSB = 2604;
literal KA43$L_TODCSC = 2608;
literal KA43$L_TODCSD = 2612;
literal KA43$B_RAMST = 2616;
literal KA43$B_CPMBX = 2616;
literal KA43$B_CPFLG = 2620;
literal KA43$B_LK201 = 2624;
literal KA43$B_CONID = 2628;
literal KA43$L_SCRPTR = 2632;
literal KA43$L_BATCHK = 2696;
literal KA43$L_PASSWORD = 2712;
literal KA43$L_BOOFLG = 2728;
literal KA43$B_SCRLEN = 2744;
literal KA43$B_SCSI = 2748;
literal KA43$B_BOODEVLEN = 2752;
literal KA43$B_BOODEV = 2756;
literal KA43$B_RAMEND = 2812;
literal KA43$B_ASCSICSR = 3200;
literal KA43$B_SCTLS = 3200;
literal KA43$B_SCTLE = 3231;
literal KA43$B_SCSOUTDAT = 3200;
literal KA43$B_SCSCURDAT = 3200;
literal KA43$B_SCSINICMD = 3204;
literal KA43$B_SCSMODE = 3208;
literal KA43$B_SCSTARCMD = 3212;
literal KA43$B_SCSSELENA = 3216;
literal KA43$B_SCSCURSTA = 3216;
literal KA43$B_SCSDMASND = 3220;
literal KA43$B_SCSSTATUS = 3220;
literal KA43$B_SCSDMATRC = 3224;
literal KA43$B_SCSINDATA = 3224;
literal KA43$B_SCSDMAIRC = 3228;
literal KA43$B_SCSRESET = 3228;
literal KA43$B_SCDADR = 3232;
literal KA43$W_SCDCNT = 3264;
literal KA43$B_SCDDIR = 3268;
literal KA43$B_STCMODE = 3296;
literal KA43$B_BSCSICSR = 3456;
literal KA43$B_BSCSOUTDAT = 3456;
literal KA43$B_BSCSCURDAT = 3456;
literal KA43$B_BSCSINICMD = 3460;
literal KA43$B_BSCSMODE = 3464;
literal KA43$B_BSCSTARCMD = 3468;
literal KA43$B_BSCSSELENA = 3472;
literal KA43$B_BSCSCURSTA = 3472;
literal KA43$B_BSCSDMASND = 3476;
literal KA43$B_BSCSSTATUS = 3476;
literal KA43$B_BSCSDMATRC = 3480;
literal KA43$B_BSCSINDATA = 3480;
literal KA43$B_BSCSDMAIRC = 3484;
literal KA43$B_BSCSRESET = 3484;
literal KA43$B_BSCDADR = 3488;
literal KA43$W_BSCDCNT = 3520;
literal KA43$B_BSCDDIR = 3524;
literal KA43$B_FILL16KBS = 3584;
literal KA43$B_FILL16KBE = 19967;
literal KA43$W_NIRDP = 19968;
literal KA43$W_NIRAP = 19972;
literal KA43$W_VCCMD = 20480;
literal KA43$W_VCXPOS = 20484;
literal KA43$W_VCYPOS = 20504;
literal KA43$W_VCXMN1 = 20492;
literal KA43$W_VCXMX1 = 20496;
literal KA43$W_VCYMN1 = 20500;
literal KA43$W_VCYMX1 = 20504;
literal KA43$W_VCXMN2 = 20524;
literal KA43$W_VCXMX2 = 20528;
literal KA43$W_VCYMN2 = 20532;
literal KA43$W_VCYMX2 = 20536;
literal KA43$W_VCLOAD = 20540;
literal KA43$L_SESR = 20992;
literal KA43$B_FILLPG1 = 21504;
literal KA43$B_VDROMS = 22016;
literal KA43$B_VDROME = 23039;
literal KA43$B_SCRAMS = 23040;
literal KA43$A_MCT = 23040;
literal KA43$A_OP1RAM = 23044;
literal KA43$A_OP2RAM = 23048;
literal KA43$A_GOOD64 = 23052;
literal KA43$A_BMAP = 23056;
literal KA43$L_BMAPL = 23060;
literal KA43$L_KBGOOD = 23064;
literal KA43$L_MSGOOD = 23068;
literal KA43$A_INIOUT = 23072;
literal KA43$A_RSTOUT = 23076;
literal KA43$A_INIINP = 23080;
literal KA43$A_RSTINP = 23084;
literal KA43$A_GETCHR = 23088;
literal KA43$A_PUTCHR = 23092;
literal KA43$A_FBEEP = 23096;
literal KA43$L_CURBOT = 23100;
literal KA43$L_CURCOL = 23104;
literal KA43$L_CURROW = 23108;
literal KA43$A_SAVCON = 23112;
literal KA43$A_RSTCON = 23116;
literal KA43$L_STFLAG = 23120;
literal KA43$A_STLOOP = 23124;
literal KA43$L_VMB_VERSION = 23504;
literal KA43$L_SELFTEST_VERSION = 23508;
literal KA43$L_CONSOLE_VERSION = 23512;
literal KA43$B_DISKMASK = 23516;
literal KA43$B_DISKCTRL = 23517;
literal KA43$B_TAPEMASK = 23520;
literal KA43$B_TAPECTRL = 23521;
literal KA43$L_CELL_HGHT = 23524;
literal KA43$L_CELL_WIDTH = 23528;
literal KA43$L_QD_MEM = 23544;
literal KA43$L_MAXCOL = 23548;
literal KA43$L_ROMREV = 23624;
literal KA43$L_NICSR = 23680;
literal KA43$A_NIRAM = 23684;
literal KA43$A_NIPKT = 23688;
literal KA43$B_SCRAME = 24063;
literal KA43$B_X1ROMS = 23808;
literal KA43$B_X1ROME = 24831;
literal KA43$B_X2ROMS = 25088;
literal KA43$B_X2ROME = 26111;
literal KA43$B_X1CSRS = 26112;
literal KA43$B_X2CSRS = 26624;
literal KA43$B_CVADDER = 27136;
literal KA43$B_CVFIFO = 27648;
literal KA43$B_CVVDAC = 27904;
literal KA43$B_CVCURS = 28160;
literal KA43$W_CVVRDBK = 28416;
literal KA43$B_D128BUFS = 28672;
literal KA43$B_D128BUFE = 159743;
literal KA43$B_CACH2TS = 159744;
literal KA43$B_CACH2TE = 290815;
literal KA43$S_KA43DEF = 290816;
literal KA43$M_CFGTST_VIDOPT = 8;
literal KA43$M_CFGTST_CURTST = 16;
literal KA43$M_CFGTST_L3CON = 32;
literal KA43$M_CFGTST_SIMM = 16711680;
literal KA43$S_KA43_CFGTST = 4;
macro KA43$V_CFGTST_VIDOPT = 0,3,1,0 %;
macro KA43$V_CFGTST_CURTST = 0,4,1,0 %;
macro KA43$V_CFGTST_L3CON = 0,5,1,0 %;
macro KA43$V_CFGTST_SIMM = 0,16,8,0 %;
literal KA43$S_CFGTST_SIMM = 8;
literal KA43$S_KA43_SYSTYPE = 4;
macro KA43$B_SYSTYPE_NUMUSER = 0,0,8,0 %;
macro KA43$B_SYSTYPE_SUBTYPE = 1,0,8,0 %;
macro KA43$B_SYSTYPE_ROMVERS = 2,0,8,0 %;
macro KA43$B_SYSTYPE_SYSCODE = 3,0,8,0 %;
literal KA43$M_INTMSK_SC_B = 1;
literal KA43$M_INTMSK_SC_A = 2;
literal KA43$M_INTMSK_VS = 4;
literal KA43$M_INTMSK_VF = 8;
literal KA43$M_INTMSK_NS = 16;
literal KA43$M_INTMSK_NI = 32;
literal KA43$M_INTMSK_ST = 64;
literal KA43$M_INTMSK_SR = 128;
literal KA43$S_KA43_INTMSK = 1;
macro KA43$V_INTMSK_SC_B = 0,0,1,0 %;
macro KA43$V_INTMSK_SC_A = 0,1,1,0 %;
macro KA43$V_INTMSK_VS = 0,2,1,0 %;
macro KA43$V_INTMSK_VF = 0,3,1,0 %;
macro KA43$V_INTMSK_NS = 0,4,1,0 %;
macro KA43$V_INTMSK_NI = 0,5,1,0 %;
macro KA43$V_INTMSK_ST = 0,6,1,0 %;
macro KA43$V_INTMSK_SR = 0,7,1,0 %;
literal KA43$M_INTREQ_SC_B = 1;
literal KA43$M_INTREQ_SC_A = 2;
literal KA43$M_INTREQ_VS = 4;
literal KA43$M_INTREQ_VF = 8;
literal KA43$M_INTREQ_NS = 16;
literal KA43$M_INTREQ_NI = 32;
literal KA43$M_INTREQ_ST = 64;
literal KA43$M_INTREQ_SR = 128;
literal KA43$S_KA43_INTREQ = 1;
macro KA43$V_INTREQ_SC_B = 0,0,1,0 %;
macro KA43$V_INTREQ_SC_A = 0,1,1,0 %;
macro KA43$V_INTREQ_VS = 0,2,1,0 %;
macro KA43$V_INTREQ_VF = 0,3,1,0 %;
macro KA43$V_INTREQ_NS = 0,4,1,0 %;
macro KA43$V_INTREQ_NI = 0,5,1,0 %;
macro KA43$V_INTREQ_ST = 0,6,1,0 %;
macro KA43$V_INTREQ_SR = 0,7,1,0 %;
literal KA43$M_INTCLR_SC_B = 1;
literal KA43$M_INTCLR_SC_A = 2;
literal KA43$M_INTCLR_VS = 4;
literal KA43$M_INTCLR_VF = 8;
literal KA43$M_INTCLR_NS = 16;
literal KA43$M_INTCLR_NI = 32;
literal KA43$M_INTCLR_ST = 64;
literal KA43$M_INTCLR_SR = 128;
literal KA43$S_KA43_INTCLR = 1;
macro KA43$V_INTCLR_SC_B = 0,0,1,0 %;
macro KA43$V_INTCLR_SC_A = 0,1,1,0 %;
macro KA43$V_INTCLR_VS = 0,2,1,0 %;
macro KA43$V_INTCLR_VF = 0,3,1,0 %;
macro KA43$V_INTCLR_NS = 0,4,1,0 %;
macro KA43$V_INTCLR_NI = 0,5,1,0 %;
macro KA43$V_INTCLR_ST = 0,6,1,0 %;
macro KA43$V_INTCLR_SR = 0,7,1,0 %;
literal KA43$M_PARCTL_DPEN = 1;
literal KA43$M_PARCTL_CPEN = 2;
literal KA43$M_PARCTL_DMA = 16777216;
literal KA43$S_KA43_PARCTL = 4;
macro KA43$V_PARCTL_DPEN = 0,0,1,0 %;
macro KA43$V_PARCTL_CPEN = 0,1,1,0 %;
macro KA43$V_PARCTL_FILL1 = 0,2,22,0 %;
literal KA43$S_PARCTL_FILL1 = 22;
macro KA43$V_PARCTL_DMA = 0,24,1,0 %;
macro KA43$V_PARCTL_FILL2 = 0,25,7,0 %;
literal KA43$S_PARCTL_FILL2 = 7;
literal KA43$M_SESR_CENB = 1;
literal KA43$M_SESR_SUNERR = 2;
literal KA43$M_SESR_LSTERR = 4;
literal KA43$M_SESR_CERR = 8;
literal KA43$M_SESR_DIRTY = 16;
literal KA43$M_SESR_MISS = 32;
literal KA43$M_SESR_DPE = 64;
literal KA43$M_SESR_TPE = 128;
literal KA43$M_SESR_WSB = 65536;
literal KA43$M_SESR_CIEA = -262144;
literal KA43$S_KA43_SESR = 4;
macro KA43$V_SESR_CENB = 0,0,1,0 %;
macro KA43$V_SESR_SUNERR = 0,1,1,0 %;
macro KA43$V_SESR_LSTERR = 0,2,1,0 %;
macro KA43$V_SESR_CERR = 0,3,1,0 %;
macro KA43$V_SESR_DIRTY = 0,4,1,0 %;
macro KA43$V_SESR_MISS = 0,5,1,0 %;
macro KA43$V_SESR_DPE = 0,6,1,0 %;
macro KA43$V_SESR_TPE = 0,7,1,0 %;
macro KA43$V_SESR_WSB = 0,16,1,0 %;
macro KA43$V_SESR_CIEA = 0,18,14,0 %;
literal KA43$S_SESR_CIEA = 14;
literal KA43$M_CPMBX_HLTACT = 3;
literal KA43$M_CPMBX_BIP = 4;
literal KA43$M_CPMBX_RIP = 8;
literal KA43$M_CPMBX_HLTSWX = 48;
literal KA43$M_CPMBX_MOP = 64;
literal KA43$M_CPMBX_TRIG = 128;
literal KA43$S_CPMBX = 1;
macro KA43$V_CPMBX_HLTACT = 0,0,2,0 %;
literal KA43$S_CPMBX_HLTACT = 2;
macro KA43$V_CPMBX_BIP = 0,2,1,0 %;
macro KA43$V_CPMBX_RIP = 0,3,1,0 %;
macro KA43$V_CPMBX_HLTSWX = 0,4,2,0 %;
literal KA43$S_CPMBX_HLTSWX = 2;
macro KA43$V_CPMBX_MOP = 0,6,1,0 %;
macro KA43$V_CPMBX_TRIG = 0,7,1,0 %;
literal KA43$K_RS_RB_HLT = 0;
literal KA43$K_RS_HLT = 1;
literal KA43$K_RB_HLT = 2;
literal KA43$K_HLT = 3;
literal KA43$M_CPFLG_GUARD = 1;
literal KA43$M_CPFLG_CRT = 2;
literal KA43$M_CPFLG_MCS = 4;
literal KA43$M_CPFLG_REENTER = 8;
literal KA43$M_CPFLG_CORRUPT = 16;
literal KA43$M_CPFLG_VIDEO = 32;
literal KA43$M_CPFLG_LK201 = 64;
literal KA43$M_CPFLG_PFILE = 128;
literal KA43$S_CPFLG = 1;
macro KA43$V_CPFLG_GUARD = 0,0,1,0 %;
macro KA43$V_CPFLG_CRT = 0,1,1,0 %;
macro KA43$V_CPFLG_MCS = 0,2,1,0 %;
macro KA43$V_CPFLG_REENTER = 0,3,1,0 %;
macro KA43$V_CPFLG_CORRUPT = 0,4,1,0 %;
macro KA43$V_CPFLG_VIDEO = 0,5,1,0 %;
macro KA43$V_CPFLG_LK201 = 0,6,1,0 %;
macro KA43$V_CPFLG_PFILE = 0,7,1,0 %;
 
!*** MODULE $KA440DEF ***
literal KA440$L_CFGTST = 0;
literal KA440$B_IORESET = 0;
literal KA440$L_SYSTYPE = 516;
literal KA440$L_HLTCOD1 = 1024;
literal KA440$L_HLTCOD2 = 1028;
literal KA440$L_MAPBASE = 1032;
literal KA440$B_INTMSK = 1036;
literal KA440$B_INTREQ = 1039;
literal KA440$B_INTCLR = 1039;
literal KA440$W_DIAGDISP = 1040;
literal KA440$L_PAR_CTL = 1044;
literal KA440$W_DIAGTIMU = 1052;
literal KA440$W_DIAGTIMM = 1054;
literal KA440$B_NIADRS = 1536;
literal KA440$B_NIADRE = 1663;
literal KA440$W_SERCSR = 2048;
literal KA440$W_SERRBF = 2052;
literal KA440$W_SERLPR = 2052;
literal KA440$W_SERTCR = 2056;
literal KA440$W_SERMSR = 2060;
literal KA440$W_SERTDR = 2060;
literal KA440$W_DZLPR0 = 2064;
literal KA440$W_DZLPR1 = 2068;
literal KA440$W_DZLPR2 = 2072;
literal KA440$W_DZLPR3 = 2076;
literal KA440$L_TODSEC = 2560;
literal KA440$L_TODSAL = 2564;
literal KA440$L_TODMIN = 2568;
literal KA440$L_TODMAL = 2572;
literal KA440$L_TODHR = 2576;
literal KA440$L_TODHAL = 2580;
literal KA440$L_TODDWK = 2584;
literal KA440$L_TODDAY = 2588;
literal KA440$L_TODMON = 2592;
literal KA440$L_TODYR = 2596;
literal KA440$L_TODCSA = 2600;
literal KA440$L_TODCSB = 2604;
literal KA440$L_TODCSC = 2608;
literal KA440$L_TODCSD = 2612;
literal KA440$B_RAMST = 2616;
literal KA440$B_CPMBX = 2616;
literal KA440$B_CPFLG = 2620;
literal KA440$B_LK201 = 2624;
literal KA440$B_CONID = 2628;
literal KA440$L_SCRPTR = 2632;
literal KA440$L_BATCHK = 2696;
literal KA440$L_TRGPSW = 2712;
literal KA440$L_BOOFLG = 2728;
literal KA440$B_SCRLEN = 2744;
literal KA440$B_SCSI = 2748;
literal KA440$L_BOOLEN = 2752;
literal KA440$L_BOODEV = 2756;
literal KA440$B_RAMEND = 2812;
literal KA440$L_SCDADR = 3072;
literal KA440$B_SCDDIR = 3084;
literal KA440$L_SCSIS = 3200;
literal KA440$L_SCSIE = 3504;
literal KA440$B_SNDPS = 3584;
literal KA440$B_SNDPE = 3591;
literal KA440$L_ASYNCSR = 4096;
literal KA440$B_ASYNCROMS = 4608;
literal KA440$L_WCFGREG = 5120;
literal KA440$L_INVSING = 5632;
literal KA440$L_INVALL = 5640;
literal KA440$L_INVSTAT = 5648;
literal KA440$L_FILL1S = 6144;
literal KA440$L_FILL1E = 8191;
literal KA440$L_BEHR = 8192;
literal KA440$B_SYNCROMS = 8704;
literal KA440$B_SYNCROME = 9727;
literal KA440$L_SYNCRST = 9728;
literal KA440$W_NIRDP = 10240;
literal KA440$W_NIRAP = 10244;
literal KA440$L_MEMCNFG = 12288;
literal KA440$L_MEMSTAT = 12292;
literal KA440$L_MEMCUR = 12296;
literal KA440$L_MEMERR = 12300;
literal KA440$B_LCGROMS = 12800;
literal KA440$B_LCGROME = 13823;
literal KA440$B_SCRAMS = 13312;
literal KA440$A_MCT = 13312;
literal KA440$A_SCIA = 13316;
literal KA440$A_CCDATA = 13320;
literal KA440$A_GOOD256 = 13324;
literal KA440$A_BMAP = 13328;
literal KA440$L_BMAPL = 13332;
literal KA440$L_BMAPCHK = 13336;
literal KA440$A_PERM_MEM = 13340;
literal KA440$L_TEMP_SIZ = 13344;
literal KA440$A_TEMP_MEM = 13348;
literal KA440$L_SAVCON = 13352;
literal KA440$L_RSTCON = 13356;
literal KA440$A_ABMAP = 13360;
literal KA440$A_SVSTAT = 13364;
literal KA440$L_TOTMEM = 13368;
literal KA440$L_MAXROW = 13372;
literal KA440$L_CURCOL = 13376;
literal KA440$L_CURROW = 13380;
literal KA440$L_CCFNCT = 13384;
literal KA440$L_CSP = 13424;
literal KA440$A_USFONT = 13428;
literal KA440$A_MCS_FONT = 13432;
literal KA440$L_CELL_WIDTH = 13436;
literal KA440$L_CELL_HGHT = 13440;
literal KA440$A_NIRAM = 13444;
literal KA440$A_LANCE = 13448;
literal KA440$L_ROM_VERSION = 13452;
literal KA440$L_VMB_VERSION = 13456;
literal KA440$L_CONS_REVISION = 13460;
literal KA440$L_SFTST_REV = 13464;
literal KA440$A_GFX_PAGE = 13876;
literal KA440$B_SCRAME = 14335;
literal KA440$L_DMAPS = 14336;
literal KA440$L_DMAPE = 145407;
literal KA440$L_INVFLS = 145408;
literal KA440$L_INVFLE = 161791;
literal KA440$L_SOCCTS = 161792;
literal KA440$L_SOCCTE = 162815;
literal KA440$L_SOCCDS = 162816;
literal KA440$L_SOCCDE = 163839;
literal KA440$S_KA440DEF = 163840;
literal KA440$M_CFGTST_MTYPE = 63;
literal KA440$M_CFGTST_VIDOPT = 192;
literal KA440$M_CFGTST_L3CON = 256;
literal KA440$S_KA440_CFGTST = 2;
macro KA440$V_CFGTST_MTYPE = 0,0,6,0 %;
literal KA440$S_CFGTST_MTYPE = 6;
macro KA440$V_CFGTST_VIDOPT = 0,6,2,0 %;
literal KA440$S_CFGTST_VIDOPT = 2;
macro KA440$V_CFGTST_L3CON = 0,8,1,0 %;
literal KA440$S_KA440_SYSTYPE = 4;
macro KA440$B_SYSTYPE_NUMUSER = 0,0,8,0 %;
macro KA440$B_SYSTYPE_SUBTYPE = 1,0,8,0 %;
macro KA440$B_SYSTYPE_ROMVERS = 2,0,8,0 %;
macro KA440$B_SYSTYPE_SYSCODE = 3,0,8,0 %;
literal KA440$M_INTMSK_SC = 1;
literal KA440$M_INTMSK_NI = 2;
literal KA440$M_INTMSK_G0 = 4;
literal KA440$M_INTMSK_G1 = 8;
literal KA440$M_INTMSK_AT = 16;
literal KA440$M_INTMSK_AR = 32;
literal KA440$M_INTMSK_SP = 64;
literal KA440$M_INTMSK_CO = 128;
literal KA440$S_KA440_INTMSK = 1;
macro KA440$V_INTMSK_SC = 0,0,1,0 %;
macro KA440$V_INTMSK_NI = 0,1,1,0 %;
macro KA440$V_INTMSK_G0 = 0,2,1,0 %;
macro KA440$V_INTMSK_G1 = 0,3,1,0 %;
macro KA440$V_INTMSK_AT = 0,4,1,0 %;
macro KA440$V_INTMSK_AR = 0,5,1,0 %;
macro KA440$V_INTMSK_SP = 0,6,1,0 %;
macro KA440$V_INTMSK_CO = 0,7,1,0 %;
literal KA440$M_INTREQ_SC = 1;
literal KA440$M_INTREQ_NI = 2;
literal KA440$M_INTREQ_G0 = 4;
literal KA440$M_INTREQ_G1 = 8;
literal KA440$M_INTREQ_AT = 16;
literal KA440$M_INTREQ_AR = 32;
literal KA440$M_INTREQ_SP = 64;
literal KA440$M_INTREQ_CO = 128;
literal KA440$S_KA440_INTREQ = 1;
macro KA440$V_INTREQ_SC = 0,0,1,0 %;
macro KA440$V_INTREQ_NI = 0,1,1,0 %;
macro KA440$V_INTREQ_G0 = 0,2,1,0 %;
macro KA440$V_INTREQ_G1 = 0,3,1,0 %;
macro KA440$V_INTREQ_AT = 0,4,1,0 %;
macro KA440$V_INTREQ_AR = 0,5,1,0 %;
macro KA440$V_INTREQ_SP = 0,6,1,0 %;
macro KA440$V_INTREQ_CO = 0,7,1,0 %;
literal KA440$M_INTCLR_SC = 1;
literal KA440$M_INTCLR_NI = 2;
literal KA440$M_INTCLR_G0 = 4;
literal KA440$M_INTCLR_G1 = 8;
literal KA440$M_INTCLR_AT = 16;
literal KA440$M_INTCLR_AR = 32;
literal KA440$M_INTCLR_SP = 64;
literal KA440$M_INTCLR_CO = 128;
literal KA440$S_KA440_INTCLR = 1;
macro KA440$V_INTCLR_SC = 0,0,1,0 %;
macro KA440$V_INTCLR_NI = 0,1,1,0 %;
macro KA440$V_INTCLR_G0 = 0,2,1,0 %;
macro KA440$V_INTCLR_G1 = 0,3,1,0 %;
macro KA440$V_INTCLR_AT = 0,4,1,0 %;
macro KA440$V_INTCLR_AR = 0,5,1,0 %;
macro KA440$V_INTCLR_SP = 0,6,1,0 %;
macro KA440$V_INTCLR_CO = 0,7,1,0 %;
literal KA440$M_CPMBX_HLT = 3;
literal KA440$M_CPMBX_BIP = 4;
literal KA440$M_CPMBX_RIP = 8;
literal KA440$S_KA440_CPMBX = 1;
macro KA440$V_CPMBX_HLT = 0,0,2,0 %;
literal KA440$S_CPMBX_HLT = 2;
macro KA440$V_CPMBX_BIP = 0,2,1,0 %;
macro KA440$V_CPMBX_RIP = 0,3,1,0 %;
literal KA440$K_RS_RB_HLT = 0;
literal KA440$K_RS_HLT = 1;
literal KA440$K_RB_HLT = 2;
literal KA440$K_HLT = 3;
literal KA440$M_PAR_CTL_CPEN = 1;
literal KA440$M_PAR_CTL_FILL1 = 14;
literal KA440$M_PAR_CTL_REV = 240;
literal KA440$M_PAR_CTL_NPEN = 256;
literal KA440$M_PAR_CTL_NPERR = 512;
literal KA440$M_PAR_CTL_NMAP = 1024;
literal KA440$M_PAR_CTL_FILL2 = 63488;
literal KA440$M_PAR_CTL_SPEN = 65536;
literal KA440$M_PAR_CTL_SPERR = 131072;
literal KA440$M_PAR_CTL_SMAP = 262144;
literal KA440$M_PAR_CTL_FILL3 = 16252928;
literal KA440$M_PAR_CTL_INVENA = 16777216;
literal KA440$M_PAR_CTL_AGS = 33554432;
literal KA440$M_PAR_CTL_FILL4 = 2080374784;
literal KA440$M_PAR_CTL_ADP = -2147483648;
literal KA440$S_KA440_PAR_CTL = 4;
macro KA440$V_PAR_CTL_CPEN = 0,0,1,0 %;
macro KA440$V_PAR_CTL_FILL1 = 0,1,3,0 %;
literal KA440$S_PAR_CTL_FILL1 = 3;
macro KA440$V_PAR_CTL_REV = 0,4,4,0 %;
literal KA440$S_PAR_CTL_REV = 4;
macro KA440$V_PAR_CTL_NPEN = 0,8,1,0 %;
macro KA440$V_PAR_CTL_NPERR = 0,9,1,0 %;
macro KA440$V_PAR_CTL_NMAP = 0,10,1,0 %;
macro KA440$V_PAR_CTL_FILL2 = 0,11,5,0 %;
literal KA440$S_PAR_CTL_FILL2 = 5;
macro KA440$V_PAR_CTL_SPEN = 0,16,1,0 %;
macro KA440$V_PAR_CTL_SPERR = 0,17,1,0 %;
macro KA440$V_PAR_CTL_SMAP = 0,18,1,0 %;
macro KA440$V_PAR_CTL_FILL3 = 0,19,5,0 %;
literal KA440$S_PAR_CTL_FILL3 = 5;
macro KA440$V_PAR_CTL_INVENA = 0,24,1,0 %;
macro KA440$V_PAR_CTL_AGS = 0,25,1,0 %;
macro KA440$V_PAR_CTL_FILL4 = 0,26,5,0 %;
literal KA440$S_PAR_CTL_FILL4 = 5;
macro KA440$V_PAR_CTL_ADP = 0,31,1,0 %;
literal KA440$M_BEHR_ENBNK = 255;
literal KA440$M_BEHR_BHM = 65280;
literal KA440$S_KA440_BEHR = 2;
macro KA440$V_BEHR_ENBNK = 0,0,8,0 %;
literal KA440$S_BEHR_ENBNK = 8;
macro KA440$V_BEHR_BHM = 0,8,8,0 %;
literal KA440$S_BEHR_BHM = 8;
literal KA440$M_MEMCNFG_SIMTYP = 7;
literal KA440$M_MEMCNFG_VIDRAM = 24;
literal KA440$M_MEMCNFG_SLOCYC = 480;
literal KA440$M_MEMCNFG_COLOR = 512;
literal KA440$M_MEMCNFG_DWT = 1024;
literal KA440$M_MEMCNFG_VIDMSK = 30720;
literal KA440$M_MEMCNFG_UNUSED1 = 32768;
literal KA440$M_MEMCNFG_STALL_ON_WRITE = 65536;
literal KA440$M_MEMCNFG_WR_RD_PRECHARGE = 131072;
literal KA440$S_KA440_MEMCNFG = 3;
macro KA440$V_MEMCNFG_SIMTYP = 0,0,3,0 %;
literal KA440$S_MEMCNFG_SIMTYP = 3;
macro KA440$V_MEMCNFG_VIDRAM = 0,3,2,0 %;
literal KA440$S_MEMCNFG_VIDRAM = 2;
macro KA440$V_MEMCNFG_SLOCYC = 0,5,4,0 %;
literal KA440$S_MEMCNFG_SLOCYC = 4;
macro KA440$V_MEMCNFG_COLOR = 0,9,1,0 %;
macro KA440$V_MEMCNFG_DWT = 0,10,1,0 %;
macro KA440$V_MEMCNFG_VIDMSK = 0,11,4,0 %;
literal KA440$S_MEMCNFG_VIDMSK = 4;
macro KA440$V_MEMCNFG_UNUSED1 = 0,15,1,0 %;
macro KA440$V_MEMCNFG_STALL_ON_WRITE = 0,16,1,0 %;
macro KA440$V_MEMCNFG_WR_RD_PRECHARGE = 0,17,1,0 %;
literal KA440$M_MEMERR_EPC = 1;
literal KA440$M_MEMERR_FILL1 = 2;
literal KA440$M_MEMERR_ERRADD = 67108860;
literal KA440$M_MEMERR_PER = 1073741824;
literal KA440$S_KA440_MEMERR = 4;
macro KA440$V_MEMERR_EPC = 0,0,1,0 %;
macro KA440$V_MEMERR_FILL1 = 0,1,1,0 %;
macro KA440$V_MEMERR_ERRADD = 0,2,24,0 %;
literal KA440$S_MEMERR_ERRADD = 24;
macro KA440$V_MEMERR_FILL2 = 0,26,4,0 %;
literal KA440$S_MEMERR_FILL2 = 4;
macro KA440$V_MEMERR_PER = 0,30,1,0 %;
 
!*** MODULE $KA46DEF ***
literal KA46$L_CFGTST = 0;
literal KA46$B_IORESET = 0;
literal KA46$L_SYSTYPE = 516;
literal KA46$L_HLTCOD1 = 1024;
literal KA46$L_HLTCOD2 = 1028;
literal KA46$L_MAPBASE = 1032;
literal KA46$B_INTMSK = 1036;
literal KA46$B_INTREQ = 1039;
literal KA46$B_INTCLR = 1039;
literal KA46$W_DIAGDISP = 1040;
literal KA46$L_PAR_CTL = 1044;
literal KA46$W_DIAGTIMU = 1052;
literal KA46$W_DIAGTIMM = 1054;
literal KA46$B_NIADRS = 1536;
literal KA46$B_NIADRE = 1663;
literal KA46$W_SERCSR = 2048;
literal KA46$W_SERRBF = 2052;
literal KA46$W_SERLPR = 2052;
literal KA46$W_SERTCR = 2056;
literal KA46$W_SERMSR = 2060;
literal KA46$W_SERTDR = 2060;
literal KA46$W_DZLPR0 = 2064;
literal KA46$W_DZLPR1 = 2068;
literal KA46$W_DZLPR2 = 2072;
literal KA46$W_DZLPR3 = 2076;
literal KA46$L_TODSEC = 2560;
literal KA46$L_TODSAL = 2564;
literal KA46$L_TODMIN = 2568;
literal KA46$L_TODMAL = 2572;
literal KA46$L_TODHAL = 2580;
literal KA46$L_TODDWK = 2584;
literal KA46$L_TODDAY = 2588;
literal KA46$L_TODMON = 2592;
literal KA46$L_TODYR = 2596;
literal KA46$L_TODCSA = 2600;
literal KA46$L_TODCSB = 2604;
literal KA46$L_TODCSC = 2608;
literal KA46$L_TODCSD = 2612;
literal KA46$B_RAMST = 2616;
literal KA46$B_CPMBX = 2616;
literal KA46$B_CPFLG = 2620;
literal KA46$B_LK201 = 2624;
literal KA46$B_CONID = 2628;
literal KA46$L_SCRPTR = 2632;
literal KA46$L_BATCHK = 2696;
literal KA46$L_TRGPSW = 2712;
literal KA46$L_BOOFLG = 2728;
literal KA46$B_SCRLEN = 2744;
literal KA46$B_SCSI = 2748;
literal KA46$L_BOOLEN = 2752;
literal KA46$L_BOODEV = 2756;
literal KA46$B_RAMEND = 2812;
literal KA46$L_SCDADR = 3072;
literal KA46$B_SCDDIR = 3084;
literal KA46$L_SCSIS = 3200;
literal KA46$L_SCSIE = 3504;
literal KA46$B_SNDPS = 3584;
literal KA46$B_SNDPE = 3591;
literal KA46$L_ASYNCSR = 4096;
literal KA46$B_ASYNCROMS = 4608;
literal KA46$L_WCFGREG = 5120;
literal KA46$L_INVSING = 5632;
literal KA46$L_INVALL = 5640;
literal KA46$L_INVSTAT = 5648;
literal KA46$B_FILL1S = 6144;
literal KA46$B_FILL1E = 8191;
literal KA46$B_SYNCROMS = 8704;
literal KA46$B_SYNCROME = 9727;
literal KA46$L_SYNCRST = 9728;
literal KA46$W_NIRDP = 10240;
literal KA46$W_NIRAP = 10244;
literal KA46$L_MEMCNFG = 12288;
literal KA46$L_MEMSTAT = 12292;
literal KA46$L_MEMCUR = 12296;
literal KA46$L_MEMERR = 12300;
literal KA46$B_LCGROMS = 12800;
literal KA46$B_LCGROME = 13823;
literal KA46$B_SCRAMS = 13312;
literal KA46$A_MCT = 13312;
literal KA46$A_SCIA = 13316;
literal KA46$A_CCDATA = 13320;
literal KA46$A_GOOD256 = 13324;
literal KA46$A_BMAP = 13328;
literal KA46$L_BMAPL = 13332;
literal KA46$L_BMAPCHK = 13336;
literal KA46$A_PERM_MEM = 13340;
literal KA46$L_TEMP_SIZ = 13344;
literal KA46$A_TEMP_MEM = 13348;
literal KA46$L_SAVCON = 13352;
literal KA46$L_RSTCON = 13356;
literal KA46$A_ABMAP = 13360;
literal KA46$A_SVSTAT = 13364;
literal KA46$L_TOTMEM = 13368;
literal KA46$L_MAXROW = 13372;
literal KA46$L_CURCOL = 13376;
literal KA46$L_CURROW = 13380;
literal KA46$L_CCFNCT = 13384;
literal KA46$L_CSP = 13424;
literal KA46$A_USFONT = 13428;
literal KA46$A_MCS_FONT = 13432;
literal KA46$L_CELL_WIDTH = 13436;
literal KA46$L_CELL_HGHT = 13440;
literal KA46$A_NIRAM = 13444;
literal KA46$A_LANCE = 13448;
literal KA46$L_ROM_VERSION = 13452;
literal KA46$L_VMB_VERSION = 13456;
literal KA46$L_CONS_REVISION = 13460;
literal KA46$L_SFTST_REV = 13464;
literal KA46$A_GFX_PAGE = 13876;
literal KA46$B_SCRAME = 14335;
literal KA46$L_DMAPS = 14336;
literal KA46$L_DMAPE = 145407;
literal KA46$L_CACH2TS = 145408;
literal KA46$L_CACH2TE = 407551;
literal KA46$L_INVFLS = 407552;
literal KA46$L_INVFLE = 538623;
literal KA46$L_SCCR = 538624;
literal KA46$L_CACH2DS = 539136;
literal KA46$L_CACH2DE = 801279;
literal KA46$L_TURBOMAPREGS = 801280;
literal KA46$L_TURBOMAPREGE = 834048;
literal KA46$L_TURBOCSR = 834560;
literal KA46$S_KA46DEF = 835071;
literal KA46$M_CFGTST_MTYPE = 63;
literal KA46$M_CFGTST_VIDOPT = 192;
literal KA46$M_CFGTST_L3CON = 256;
literal KA46$M_CFGTST_SIMTYP = 32256;
literal KA46$S_KA46_CFGTST = 2;
macro KA46$V_CFGTST_MTYPE = 0,0,6,0 %;
literal KA46$S_CFGTST_MTYPE = 6;
macro KA46$V_CFGTST_VIDOPT = 0,6,2,0 %;
literal KA46$S_CFGTST_VIDOPT = 2;
macro KA46$V_CFGTST_L3CON = 0,8,1,0 %;
macro KA46$V_CFGTST_SIMTYP = 0,9,6,0 %;
literal KA46$S_CFGTST_SIMTYP = 6;
literal KA46$S_KA46_SYSTYPE = 4;
macro KA46$B_SYSTYPE_NUMUSER = 0,0,8,0 %;
macro KA46$B_SYSTYPE_SUBTYPE = 1,0,8,0 %;
macro KA46$B_SYSTYPE_ROMVERS = 2,0,8,0 %;
macro KA46$B_SYSTYPE_SYSCODE = 3,0,8,0 %;
literal KA46$M_INTMSK_SC = 1;
literal KA46$M_INTMSK_NI = 2;
literal KA46$M_INTMSK_G0 = 4;
literal KA46$M_INTMSK_G1 = 8;
literal KA46$M_INTMSK_AT = 16;
literal KA46$M_INTMSK_AR = 32;
literal KA46$M_INTMSK_SP = 64;
literal KA46$M_INTMSK_CO = 128;
literal KA46$S_KA46_INTMSK = 1;
macro KA46$V_INTMSK_SC = 0,0,1,0 %;
macro KA46$V_INTMSK_NI = 0,1,1,0 %;
macro KA46$V_INTMSK_G0 = 0,2,1,0 %;
macro KA46$V_INTMSK_G1 = 0,3,1,0 %;
macro KA46$V_INTMSK_AT = 0,4,1,0 %;
macro KA46$V_INTMSK_AR = 0,5,1,0 %;
macro KA46$V_INTMSK_SP = 0,6,1,0 %;
macro KA46$V_INTMSK_CO = 0,7,1,0 %;
literal KA46$M_INTREQ_SC = 1;
literal KA46$M_INTREQ_NI = 2;
literal KA46$M_INTREQ_G0 = 4;
literal KA46$M_INTREQ_G1 = 8;
literal KA46$M_INTREQ_AT = 16;
literal KA46$M_INTREQ_AR = 32;
literal KA46$M_INTREQ_SP = 64;
literal KA46$M_INTREQ_CO = 128;
literal KA46$S_KA46_INTREQ = 1;
macro KA46$V_INTREQ_SC = 0,0,1,0 %;
macro KA46$V_INTREQ_NI = 0,1,1,0 %;
macro KA46$V_INTREQ_G0 = 0,2,1,0 %;
macro KA46$V_INTREQ_G1 = 0,3,1,0 %;
macro KA46$V_INTREQ_AT = 0,4,1,0 %;
macro KA46$V_INTREQ_AR = 0,5,1,0 %;
macro KA46$V_INTREQ_SP = 0,6,1,0 %;
macro KA46$V_INTREQ_CO = 0,7,1,0 %;
literal KA46$M_INTCLR_SC = 1;
literal KA46$M_INTCLR_NI = 2;
literal KA46$M_INTCLR_G0 = 4;
literal KA46$M_INTCLR_G1 = 8;
literal KA46$M_INTCLR_AT = 16;
literal KA46$M_INTCLR_AR = 32;
literal KA46$M_INTCLR_SP = 64;
literal KA46$M_INTCLR_CO = 128;
literal KA46$S_KA46_INTCLR = 1;
macro KA46$V_INTCLR_SC = 0,0,1,0 %;
macro KA46$V_INTCLR_NI = 0,1,1,0 %;
macro KA46$V_INTCLR_G0 = 0,2,1,0 %;
macro KA46$V_INTCLR_G1 = 0,3,1,0 %;
macro KA46$V_INTCLR_AT = 0,4,1,0 %;
macro KA46$V_INTCLR_AR = 0,5,1,0 %;
macro KA46$V_INTCLR_SP = 0,6,1,0 %;
macro KA46$V_INTCLR_CO = 0,7,1,0 %;
literal KA46$M_CPMBX_HLT = 3;
literal KA46$M_CPMBX_BIP = 4;
literal KA46$M_CPMBX_RIP = 8;
literal KA46$S_KA46_CPMBX = 1;
macro KA46$V_CPMBX_HLT = 0,0,2,0 %;
literal KA46$S_CPMBX_HLT = 2;
macro KA46$V_CPMBX_BIP = 0,2,1,0 %;
macro KA46$V_CPMBX_RIP = 0,3,1,0 %;
literal KA46$K_RS_RB_HLT = 0;
literal KA46$K_RS_HLT = 1;
literal KA46$K_RB_HLT = 2;
literal KA46$K_HLT = 3;
literal KA46$M_PAR_CTL_CPEN = 1;
literal KA46$M_PAR_CTL_FILL1 = 14;
literal KA46$M_PAR_CTL_REV = 240;
literal KA46$M_PAR_CTL_NPEN = 256;
literal KA46$M_PAR_CTL_NPERR = 512;
literal KA46$M_PAR_CTL_NMAP = 1024;
literal KA46$M_PAR_CTL_FILL2 = 63488;
literal KA46$M_PAR_CTL_SPEN = 65536;
literal KA46$M_PAR_CTL_SPERR = 131072;
literal KA46$M_PAR_CTL_SMAP = 262144;
literal KA46$M_PAR_CTL_FILL3 = 16252928;
literal KA46$M_PAR_CTL_INVENA = 16777216;
literal KA46$M_PAR_CTL_AGS = 33554432;
literal KA46$M_PAR_CTL_FILL4 = 2080374784;
literal KA46$M_PAR_CTL_ADP = -2147483648;
literal KA46$S_KA46_PAR_CTL = 4;
macro KA46$V_PAR_CTL_CPEN = 0,0,1,0 %;
macro KA46$V_PAR_CTL_FILL1 = 0,1,3,0 %;
literal KA46$S_PAR_CTL_FILL1 = 3;
macro KA46$V_PAR_CTL_REV = 0,4,4,0 %;
literal KA46$S_PAR_CTL_REV = 4;
macro KA46$V_PAR_CTL_NPEN = 0,8,1,0 %;
macro KA46$V_PAR_CTL_NPERR = 0,9,1,0 %;
macro KA46$V_PAR_CTL_NMAP = 0,10,1,0 %;
macro KA46$V_PAR_CTL_FILL2 = 0,11,5,0 %;
literal KA46$S_PAR_CTL_FILL2 = 5;
macro KA46$V_PAR_CTL_SPEN = 0,16,1,0 %;
macro KA46$V_PAR_CTL_SPERR = 0,17,1,0 %;
macro KA46$V_PAR_CTL_SMAP = 0,18,1,0 %;
macro KA46$V_PAR_CTL_FILL3 = 0,19,5,0 %;
literal KA46$S_PAR_CTL_FILL3 = 5;
macro KA46$V_PAR_CTL_INVENA = 0,24,1,0 %;
macro KA46$V_PAR_CTL_AGS = 0,25,1,0 %;
macro KA46$V_PAR_CTL_FILL4 = 0,26,5,0 %;
literal KA46$S_PAR_CTL_FILL4 = 5;
macro KA46$V_PAR_CTL_ADP = 0,31,1,0 %;
literal KA46$M_SCCR_CENA = 1;
literal KA46$M_SCCR_TERR = 2;
literal KA46$M_SCCR_FILL1 = 124;
literal KA46$M_SCCR_WBMODE = 128;
literal KA46$M_SCCR_SPECIO = 256;
literal KA46$M_SCCR_FONFUL = 512;
literal KA46$M_SCCR_REV = 1024;
literal KA46$S_KA46_SCCR = 2;
macro KA46$V_SCCR_CENA = 0,0,1,0 %;
macro KA46$V_SCCR_TERR = 0,1,1,0 %;
macro KA46$V_SCCR_FILL1 = 0,2,5,0 %;
literal KA46$S_SCCR_FILL1 = 5;
macro KA46$V_SCCR_WBMODE = 0,7,1,0 %;
macro KA46$V_SCCR_SPECIO = 0,8,1,0 %;
macro KA46$V_SCCR_FONFUL = 0,9,1,0 %;
macro KA46$V_SCCR_REV = 0,10,1,0 %;
literal KA46$M_MEMCNFG_SIMTYP = 7;
literal KA46$M_MEMCNFG_VIDRAM = 24;
literal KA46$M_MEMCNFG_SLOCYC = 480;
literal KA46$M_MEMCNFG_COLOR = 512;
literal KA46$M_MEMCNFG_DWT = 1024;
literal KA46$M_MEMCNFG_VIDMSK = 30720;
literal KA46$M_MEMCNFG_UNUSED1 = 32768;
literal KA46$M_MEMCNFG_STALL_ON_WRITE = 65536;
literal KA46$M_MEMCNFG_WR_RD_PRECHARGE = 131072;
literal KA46$S_KA46_MEMCNFG = 3;
macro KA46$V_MEMCNFG_SIMTYP = 0,0,3,0 %;
literal KA46$S_MEMCNFG_SIMTYP = 3;
macro KA46$V_MEMCNFG_VIDRAM = 0,3,2,0 %;
literal KA46$S_MEMCNFG_VIDRAM = 2;
macro KA46$V_MEMCNFG_SLOCYC = 0,5,4,0 %;
literal KA46$S_MEMCNFG_SLOCYC = 4;
macro KA46$V_MEMCNFG_COLOR = 0,9,1,0 %;
macro KA46$V_MEMCNFG_DWT = 0,10,1,0 %;
macro KA46$V_MEMCNFG_VIDMSK = 0,11,4,0 %;
literal KA46$S_MEMCNFG_VIDMSK = 4;
macro KA46$V_MEMCNFG_UNUSED1 = 0,15,1,0 %;
macro KA46$V_MEMCNFG_STALL_ON_WRITE = 0,16,1,0 %;
macro KA46$V_MEMCNFG_WR_RD_PRECHARGE = 0,17,1,0 %;
literal KA46$M_MEMERR_EPC = 1;
literal KA46$M_MEMERR_FILL1 = 2;
literal KA46$M_MEMERR_ERRADD = 134217724;
literal KA46$M_MEMERR_PER = -2147483648;
literal KA46$S_KA46_MEMERR = 4;
macro KA46$V_MEMERR_EPC = 0,0,1,0 %;
macro KA46$V_MEMERR_FILL1 = 0,1,1,0 %;
macro KA46$V_MEMERR_ERRADD = 0,2,25,0 %;
literal KA46$S_MEMERR_ERRADD = 25;
macro KA46$V_MEMERR_FILL2 = 0,27,4,0 %;
literal KA46$S_MEMERR_FILL2 = 4;
macro KA46$V_MEMERR_PER = 0,31,1,0 %;
 
!*** MODULE $KA49DEF ***
literal KA49$L_MEMCON = 0;
literal KA49$L_MEMSIG = 32;
literal KA49$L_MEAR = 64;
literal KA49$L_MESR = 68;
literal KA49$L_MMCDSR = 72;
literal KA49$L_MOAMR = 76;
literal KA49$L_CESR = 512;
literal KA49$L_CMCDSR = 516;
literal KA49$L_CSEAR1 = 520;
literal KA49$L_CSEAR2 = 524;
literal KA49$L_CIOEAR1 = 528;
literal KA49$L_CIOEAR2 = 532;
literal KA49$L_CNEAR = 536;
literal KA49$L_SCDADR = 1024;
literal KA49$L_SCDDIR = 1028;
literal KA49$B_INTMSK = 1032;
literal KA49$B_INTREQ = 1036;
literal KA49$B_INTCLR = 1036;
literal KA49$B_IORESET = 1040;
literal KA49$B_ROM = 1536;
literal KA49$L_SIDEX = 1540;
literal KA49$L_GETCHAR = 1544;
literal KA49$L_OUTMSG = 1548;
literal KA49$L_SYSTYPE = 1540;
literal KA49$B_CPGETCHR = 1604;
literal KA49$B_CPMSGOUT = 1612;
literal KA49$B_CPPUTCHR = 1624;
literal KA49$L_ROMVERS = 1656;
literal KA49$B_ROMDIAG = 1660;
literal KA49$W_SER_CSR = 2048;
literal KA49$W_SER_RBUF = 2052;
literal KA49$W_SER_LPR = 2052;
literal KA49$W_SER_TCR = 2056;
literal KA49$W_SER_MSR = 2060;
literal KA49$W_SER_TDR = 2060;
literal KA49$B_SCSICSR = 2688;
literal KA49$B_NISAROM = 3072;
literal KA49$B_SNDPS = 3584;
literal KA49$L_SPXBRK = 4096;
literal KA49$B_SPXROM = 4608;
literal KA49$L_BUSADAP = 5120;
literal KA49$L_SPXMOD = 5632;
literal KA49$L_SPXDIAG = 6144;
literal KA49$L_SPXJCHIP = 6656;
literal KA49$W_CFG = 7168;
literal KA49$W_DIAGDISP = 7172;
literal KA49$L_SGEC = 7680;
literal KA49$W_WAT_SEC = 8192;
literal KA49$W_WAT_ALMS = 8196;
literal KA49$W_WAT_MIN = 8200;
literal KA49$W_WAT_ALMM = 8204;
literal KA49$W_WAT_HOUR = 8208;
literal KA49$W_WAT_ALMH = 8212;
literal KA49$W_WAT_DOW = 8216;
literal KA49$W_WAT_DAY = 8220;
literal KA49$W_WAT_MON = 8224;
literal KA49$W_WAT_YEAR = 8228;
literal KA49$W_WAT_CSRA = 8232;
literal KA49$W_WAT_CSRB = 8236;
literal KA49$W_WAT_CSRC = 8240;
literal KA49$W_WAT_CSRD = 8244;
literal KA49$W_RAMST = 8248;
literal KA49$B_CPMBX = 8248;
literal KA49$B_CPFLG = 8252;
literal KA49$B_LK201 = 8256;
literal KA49$B_CONID = 8260;
literal KA49$L_SCRPTR = 8264;
literal KA49$L_BATCHK = 8328;
literal KA49$L_TRGPSW = 8344;
literal KA49$L_BOOFLG = 8360;
literal KA49$B_SCRLEN = 8376;
literal KA49$B_SCSI = 8380;
literal KA49$L_BOOLEN = 8384;
literal KA49$L_BOODEV = 8388;
literal KA49$B_RAMEND = 8444;
literal KA49$B_SYNCROMS = 8704;
literal KA49$L_SYNCRST = 9728;
literal KA49$L_SCSIMAPS = 10240;
literal KA49$L_SCSIMAPE = 43007;
literal KA49$L_MODR = 43008;
literal KA49$B_SCRAMS = 75776;
literal KA49$A_MCT = 75776;
literal KA49$A_SCIA = 75780;
literal KA49$A_CCDATA = 75784;
literal KA49$A_GOOD256 = 75788;
literal KA49$A_BMAP = 75792;
literal KA49$L_BMAPL = 75796;
literal KA49$L_BMAPCHK = 75800;
literal KA49$A_PERM_MEM = 75804;
literal KA49$L_TEMP_SIZ = 75808;
literal KA49$A_TEMP_MEM = 75812;
literal KA49$L_SAVCON = 75816;
literal KA49$L_RSTCON = 75820;
literal KA49$A_ABMAP = 75824;
literal KA49$A_SVSTAT = 75828;
literal KA49$L_TOTMEM = 75832;
literal KA49$L_MAXROW = 75836;
literal KA49$L_CURCOL = 75840;
literal KA49$L_CURROW = 75844;
literal KA49$L_CCFNCT = 75848;
literal KA49$L_CSP = 75888;
literal KA49$A_USFONT = 75892;
literal KA49$A_MCS_FONT = 75896;
literal KA49$L_CELL_WIDTH = 75900;
literal KA49$L_CELL_HGHT = 75904;
literal KA49$A_NIRAM = 75908;
literal KA49$A_LANCE = 75912;
literal KA49$L_ROM_VERSION = 75916;
literal KA49$L_VMB_VERSION = 75920;
literal KA49$L_CONS_REVISION = 75924;
literal KA49$L_SFTST_REV = 75928;
literal KA49$A_GFX_PAGE = 76340;
literal KA49$B_SCRAME = 76799;
literal KA49$L_TURBOMAPREGS = 76800;
literal KA49$L_TURBOMAPREGE = 109568;
literal KA49$L_TURBOCSR = 109568;
literal KA49$B_TURBOROMS = 110080;
literal KA49$S_KA49DEF = 110592;
literal KA49$_SGEC_MODE = 24;
literal KA49$_SGEC_M_RESET = -2147483648;
literal KA49$M_CFG_BA = 1;
literal KA49$M_CFG_SPX = 2;
literal KA49$M_CFG_SPARE = 4;
literal KA49$M_CFG_ALCON = 8;
literal KA49$M_CFG_SPXG = 16;
literal KA49$M_CFG_SYNC = 32;
literal KA49$M_CFG_BNK0P = 64;
literal KA49$M_CFG_BNK0S = 128;
literal KA49$M_CFG_BNK2P = 256;
literal KA49$M_CFG_BNK2S = 512;
literal KA49$M_CFG_MEMERR = 64512;
literal KA49$S_KA49_CFG = 2;
macro KA49$V_CFG_BA = 0,0,1,0 %;
macro KA49$V_CFG_SPX = 0,1,1,0 %;
macro KA49$V_CFG_SPARE = 0,2,1,0 %;
macro KA49$V_CFG_ALCON = 0,3,1,0 %;
macro KA49$V_CFG_SPXG = 0,4,1,0 %;
macro KA49$V_CFG_SYNC = 0,5,1,0 %;
macro KA49$V_CFG_BNK0P = 0,6,1,0 %;
macro KA49$V_CFG_BNK0S = 0,7,1,0 %;
macro KA49$V_CFG_BNK2P = 0,8,1,0 %;
macro KA49$V_CFG_BNK2S = 0,9,1,0 %;
macro KA49$V_CFG_MEMERR = 0,10,6,0 %;
literal KA49$S_CFG_MEMERR = 6;
literal KA49$S_KA49_SIDEX = 4;
macro KA49$B_SIDEX_NUM_USER = 0,0,8,0 %;
macro KA49$B_SIDEX_SUB_TYPE = 1,0,8,0 %;
macro KA49$B_SIDEX_ROM_VERS = 2,0,8,0 %;
macro KA49$B_SIDEX_SYS_CODE = 3,0,8,0 %;
literal KA49$S_KA49_DIAGDISP = 1;
macro KA49$B_DIAG_DISP_LED = 0,0,8,0 %;
literal KA49$M_MEMCON_MODE64 = 1;
literal KA49$K_MEMCON_1MB = 1;
literal KA49$K_MEMCON_4MB = 2;
literal KA49$M_MEMCON_SIG = 6;
literal KA49$M_MEMCON_BASE = 520093696;
literal KA49$M_MEMCON_VALID = -2147483648;
literal KA49$S_KA49_MEMCON = 4;
macro KA49$V_MEMCON_MODE64 = 0,0,1,0 %;
macro KA49$V_MEMCON_SIG = 0,1,2,0 %;
literal KA49$S_MEMCON_SIG = 2;
macro KA49$V_MEMCON_BASE = 0,24,5,0 %;
literal KA49$S_MEMCON_BASE = 5;
macro KA49$V_MEMCON_VALID = 0,31,1,0 %;
literal KA49$M_MEAR_HWADDR = 268435448;
literal KA49$M_MEAR_ID = 1879048192;
literal KA49$S_KA49_MEAR = 4;
macro KA49$V_MEAR_HWADDR = 0,3,25,0 %;
literal KA49$S_MEAR_HWADDR = 25;
macro KA49$V_MEAR_ID = 0,28,3,0 %;
literal KA49$S_MEAR_ID = 3;
literal KA49$M_MESR_LMSE = 4;
literal KA49$M_MESR_OFE = 8;
literal KA49$M_MESR_OSE = 16;
literal KA49$M_MESR_OSYND = 480;
literal KA49$M_MESR_LMHE = 512;
literal KA49$M_MESR_MSE = 1024;
literal KA49$M_MESR_MHE = 2048;
literal KA49$M_MESR_SYND = 1044480;
literal KA49$M_MESR_NXM = 1048576;
literal KA49$M_MESR_NDPE = 4194304;
literal KA49$M_MESR_NIWC = 8388608;
literal KA49$M_MESR_PTTO = 16777216;
literal KA49$M_MESR_DU = 33554432;
literal KA49$M_MESR_NAE = 67108864;
literal KA49$M_MESR_BNE = 134217728;
literal KA49$M_MESR_RC = 268435456;
literal KA49$M_MESR_LNSE = 536870912;
literal KA49$M_MESR_LNHE = 1073741824;
literal KA49$M_MESR_ERROR = -2147483648;
literal KA49$S_KA49_MESR = 4;
macro KA49$V_MESR_LMSE = 0,2,1,0 %;
macro KA49$V_MESR_OFE = 0,3,1,0 %;
macro KA49$V_MESR_OSE = 0,4,1,0 %;
macro KA49$V_MESR_OSYND = 0,5,4,0 %;
literal KA49$S_MESR_OSYND = 4;
macro KA49$V_MESR_LMHE = 0,9,1,0 %;
macro KA49$V_MESR_MSE = 0,10,1,0 %;
macro KA49$V_MESR_MHE = 0,11,1,0 %;
macro KA49$V_MESR_SYND = 0,12,8,0 %;
literal KA49$S_MESR_SYND = 8;
macro KA49$V_MESR_NXM = 0,20,1,0 %;
macro KA49$V_MESR_NDPE = 0,22,1,0 %;
macro KA49$V_MESR_NIWC = 0,23,1,0 %;
macro KA49$V_MESR_PTTO = 0,24,1,0 %;
macro KA49$V_MESR_DU = 0,25,1,0 %;
macro KA49$V_MESR_NAE = 0,26,1,0 %;
macro KA49$V_MESR_BNE = 0,27,1,0 %;
macro KA49$V_MESR_RC = 0,28,1,0 %;
macro KA49$V_MESR_LNSE = 0,29,1,0 %;
macro KA49$V_MESR_LNHE = 0,30,1,0 %;
macro KA49$V_MESR_ERROR = 0,31,1,0 %;
literal KA49$M_MMCDSR_FRR = 1;
literal KA49$M_MMCDSR_DR = 2;
literal KA49$M_MMCDSR_FWPDI = 4;
literal KA49$M_MMCDSR_FWPAI = 8;
literal KA49$M_MMCDSR_FWPO = 16;
literal KA49$M_MMCDSR_RIS = 32;
literal KA49$M_MMCDSR_DMED = 64;
literal KA49$K_MMCDSR_2600 = 0;
literal KA49$K_MMCDSR_1600 = 1;
literal KA49$K_MMCDSR_800 = 2;
literal KA49$K_MMCDSR_400 = 3;
literal KA49$M_MMCDSR_TOS = 384;
literal KA49$M_MMCDSR_MCB = 130560;
literal KA49$M_MMCDSR_MDCB = 33423360;
literal KA49$M_MMCDSR_IOM = 33554432;
literal KA49$M_MMCDSR_BFM = 67108864;
literal KA49$M_MMCDSR_ESEL = 134217728;
literal KA49$M_MMCDSR_QOIO1 = 268435456;
literal KA49$M_MMCDSR_DCBM = 536870912;
literal KA49$M_MMCDSR_FDM = -2147483648;
literal KA49$S_KA49_MMCDSR = 4;
macro KA49$V_MMCDSR_FRR = 0,0,1,0 %;
macro KA49$V_MMCDSR_DR = 0,1,1,0 %;
macro KA49$V_MMCDSR_FWPDI = 0,2,1,0 %;
macro KA49$V_MMCDSR_FWPAI = 0,3,1,0 %;
macro KA49$V_MMCDSR_FWPO = 0,4,1,0 %;
macro KA49$V_MMCDSR_RIS = 0,5,1,0 %;
macro KA49$V_MMCDSR_DMED = 0,6,1,0 %;
macro KA49$V_MMCDSR_TOS = 0,7,2,0 %;
literal KA49$S_MMCDSR_TOS = 2;
macro KA49$V_MMCDSR_MCB = 0,9,8,0 %;
literal KA49$S_MMCDSR_MCB = 8;
macro KA49$V_MMCDSR_MDCB = 0,17,8,0 %;
literal KA49$S_MMCDSR_MDCB = 8;
macro KA49$V_MMCDSR_IOM = 0,25,1,0 %;
macro KA49$V_MMCDSR_BFM = 0,26,1,0 %;
macro KA49$V_MMCDSR_ESEL = 0,27,1,0 %;
macro KA49$V_MMCDSR_QOIO1 = 0,28,1,0 %;
macro KA49$V_MMCDSR_DCBM = 0,29,1,0 %;
macro KA49$V_MMCDSR_FDM = 0,31,1,0 %;
literal KA49$K_MOAMR_RECON = 0;
literal KA49$K_MOAMR_MEM = 2;
literal KA49$K_MOAMR_FAST_MEM = 3;
literal KA49$K_MOAMR_MEM_FCB = 6;
literal KA49$K_MOAMR_FAST_MEM_FCB = 7;
literal KA49$M_MOAMR_MODE = 7;
literal KA49$M_MOAMR_MASK = 56;
literal KA49$M_MOAMR_SEGMENT = 32704;
literal KA49$S_KA49_MOAMR = 4;
macro KA49$V_MOAMR_MODE = 0,0,3,0 %;
literal KA49$S_MOAMR_MODE = 3;
macro KA49$V_MOAMR_MASK = 0,3,3,0 %;
literal KA49$S_MOAMR_MASK = 3;
macro KA49$V_MOAMR_SEGMENT = 0,6,9,0 %;
literal KA49$S_MOAMR_SEGMENT = 9;
literal KA49$M_CESR_NXIOE1 = 1;
literal KA49$M_CESR_IOE1 = 2;
literal KA49$M_CESR_IORPE1 = 4;
literal KA49$M_CESR_BE1 = 8;
literal KA49$M_CESR_DPE1 = 16;
literal KA49$M_CESR_IOLE1 = 32;
literal KA49$M_CESR_DLE1 = 64;
literal KA49$M_CESR_MTTO1 = 128;
literal KA49$M_CESR_NXIOE2 = 256;
literal KA49$M_CESR_IOE2 = 512;
literal KA49$M_CESR_IORPE2 = 1024;
literal KA49$M_CESR_BE2 = 2048;
literal KA49$M_CESR_DPE2 = 4096;
literal KA49$M_CESR_IOLE2 = 8192;
literal KA49$M_CESR_DLE2 = 16384;
literal KA49$M_CESR_MTTO2 = 32768;
literal KA49$M_CESR_PREL1 = 65536;
literal KA49$M_CESR_PREL2 = 131072;
literal KA49$M_CESR_PREL = 262144;
literal KA49$M_CESR_PE = 1048576;
literal KA49$M_CESR_NAE = 2097152;
literal KA49$M_CESR_TOE1 = 4194304;
literal KA49$M_CESR_TOE2 = 8388608;
literal KA49$M_CESR_IL = 16777216;
literal KA49$M_CESR_RC = 33554432;
literal KA49$M_CESR_LE = 67108864;
literal KA49$M_CESR_RDRNAE = 134217728;
literal KA49$M_CESR_ERROR = -2147483648;
literal KA49$S_KA49_CESR = 4;
macro KA49$V_CESR_NXIOE1 = 0,0,1,0 %;
macro KA49$V_CESR_IOE1 = 0,1,1,0 %;
macro KA49$V_CESR_IORPE1 = 0,2,1,0 %;
macro KA49$V_CESR_BE1 = 0,3,1,0 %;
macro KA49$V_CESR_DPE1 = 0,4,1,0 %;
macro KA49$V_CESR_IOLE1 = 0,5,1,0 %;
macro KA49$V_CESR_DLE1 = 0,6,1,0 %;
macro KA49$V_CESR_MTTO1 = 0,7,1,0 %;
macro KA49$V_CESR_NXIOE2 = 0,8,1,0 %;
macro KA49$V_CESR_IOE2 = 0,9,1,0 %;
macro KA49$V_CESR_IORPE2 = 0,10,1,0 %;
macro KA49$V_CESR_BE2 = 0,11,1,0 %;
macro KA49$V_CESR_DPE2 = 0,12,1,0 %;
macro KA49$V_CESR_IOLE2 = 0,13,1,0 %;
macro KA49$V_CESR_DLE2 = 0,14,1,0 %;
macro KA49$V_CESR_MTTO2 = 0,15,1,0 %;
macro KA49$V_CESR_PREL1 = 0,16,1,0 %;
macro KA49$V_CESR_PREL2 = 0,17,1,0 %;
macro KA49$V_CESR_PREL = 0,18,1,0 %;
macro KA49$V_CESR_PE = 0,20,1,0 %;
macro KA49$V_CESR_NAE = 0,21,1,0 %;
macro KA49$V_CESR_TOE1 = 0,22,1,0 %;
macro KA49$V_CESR_TOE2 = 0,23,1,0 %;
macro KA49$V_CESR_IL = 0,24,1,0 %;
macro KA49$V_CESR_RC = 0,25,1,0 %;
macro KA49$V_CESR_LE = 0,26,1,0 %;
macro KA49$V_CESR_RDRNAE = 0,27,1,0 %;
macro KA49$V_CESR_ERROR = 0,31,1,0 %;
literal KA49$M_CMCDSR_FBO1 = 1;
literal KA49$M_CMCDSR_FBO2 = 2;
literal KA49$M_CMCDSR_FWBH = 4;
literal KA49$M_CMCDSR_EP = 8;
literal KA49$M_CMCDSR_FWSP = 16;
literal KA49$M_CMCDSR_FWMP = 32;
literal KA49$M_CMCDSR_FWP1 = 64;
literal KA49$M_CMCDSR_FWP2 = 128;
literal KA49$M_CMCDSR_ENAIO2 = 256;
literal KA49$M_CMCDSR_CQBIC = 512;
literal KA49$K_CMCDSR_3200 = 0;
literal KA49$K_CMCDSR_2000 = 1;
literal KA49$K_CMCDSR_1000 = 2;
literal KA49$K_CMCDSR_500 = 3;
literal KA49$M_CMCDSR_TOP = 3072;
literal KA49$K_CMCDSR_144 = 0;
literal KA49$K_CMCDSR_1440 = 1;
literal KA49$K_CMCDSR_14400 = 2;
literal KA49$K_CMCDSR_144000 = 3;
literal KA49$M_CMCDSR_MTTOP1 = 12288;
literal KA49$M_CMCDSR_MTTOP2 = 49152;
literal KA49$M_CMCDSR_PI1 = 983040;
literal KA49$M_CMCDSR_PI2 = 15728640;
literal KA49$S_KA49_CMCDSR = 4;
macro KA49$V_CMCDSR_FBO1 = 0,0,1,0 %;
macro KA49$V_CMCDSR_FBO2 = 0,1,1,0 %;
macro KA49$V_CMCDSR_FWBH = 0,2,1,0 %;
macro KA49$V_CMCDSR_EP = 0,3,1,0 %;
macro KA49$V_CMCDSR_FWSP = 0,4,1,0 %;
macro KA49$V_CMCDSR_FWMP = 0,5,1,0 %;
macro KA49$V_CMCDSR_FWP1 = 0,6,1,0 %;
macro KA49$V_CMCDSR_FWP2 = 0,7,1,0 %;
macro KA49$V_CMCDSR_ENAIO2 = 0,8,1,0 %;
macro KA49$V_CMCDSR_CQBIC = 0,9,1,0 %;
macro KA49$V_CMCDSR_TOP = 0,10,2,0 %;
literal KA49$S_CMCDSR_TOP = 2;
macro KA49$V_CMCDSR_MTTOP1 = 0,12,2,0 %;
literal KA49$S_CMCDSR_MTTOP1 = 2;
macro KA49$V_CMCDSR_MTTOP2 = 0,14,2,0 %;
literal KA49$S_CMCDSR_MTTOP2 = 2;
macro KA49$V_CMCDSR_PI1 = 0,16,4,0 %;
literal KA49$S_CMCDSR_PI1 = 4;
macro KA49$V_CMCDSR_PI2 = 0,20,4,0 %;
literal KA49$S_CMCDSR_PI2 = 4;
literal KA49$M_CSEAR_OWADDR = 1073741808;
literal KA49$S_KA49_CSEAR = 4;
macro KA49$V_CSEAR_OWADDR = 0,4,26,0 %;
literal KA49$S_CSEAR_OWADDR = 26;
literal KA49$M_CIOEAR_ADDR = 536870911;
literal KA49$M_CIOEAR_ID = -536870912;
literal KA49$S_KA49_CIOEAR = 4;
macro KA49$V_CIOEAR_ADDR = 0,0,29,0 %;
literal KA49$S_CIOEAR_ADDR = 29;
macro KA49$V_CIOEAR_ID = 0,29,3,0 %;
literal KA49$S_CIOEAR_ID = 3;
literal KA49$M_CNEAR_ADDR = 536870911;
literal KA49$M_CNEAR_ID = -536870912;
literal KA49$S_KA49_CNEAR = 4;
macro KA49$V_CNEAR_ADDR = 0,0,29,0 %;
literal KA49$S_CNEAR_ADDR = 29;
macro KA49$V_CNEAR_ID = 0,29,3,0 %;
literal KA49$S_CNEAR_ID = 3;
literal KA49$M_INTMSK_BA = 1;
literal KA49$M_INTMSK_SC = 2;
literal KA49$M_INTMSK_GR = 4;
literal KA49$M_INTMSK_QU = 8;
literal KA49$M_INTMSK_SO = 16;
literal KA49$M_INTMSK_SY = 32;
literal KA49$S_KA49_INTMSK = 1;
macro KA49$V_INTMSK_BA = 0,0,1,0 %;
macro KA49$V_INTMSK_SC = 0,1,1,0 %;
macro KA49$V_INTMSK_GR = 0,2,1,0 %;
macro KA49$V_INTMSK_QU = 0,3,1,0 %;
macro KA49$V_INTMSK_SO = 0,4,1,0 %;
macro KA49$V_INTMSK_SY = 0,5,1,0 %;
literal KA49$M_INTREQ_BA = 1;
literal KA49$M_INTREQ_SC = 2;
literal KA49$M_INTREQ_GR = 4;
literal KA49$M_INTREQ_QU = 8;
literal KA49$M_INTREQ_SO = 16;
literal KA49$M_INTREQ_SY = 32;
literal KA49$M_INTREQ_SC_CP_ERR = 64;
literal KA49$M_INTREQ_MAP_ERR = 128;
literal KA49$S_KA49_INTREQ = 1;
macro KA49$V_INTREQ_BA = 0,0,1,0 %;
macro KA49$V_INTREQ_SC = 0,1,1,0 %;
macro KA49$V_INTREQ_GR = 0,2,1,0 %;
macro KA49$V_INTREQ_QU = 0,3,1,0 %;
macro KA49$V_INTREQ_SO = 0,4,1,0 %;
macro KA49$V_INTREQ_SY = 0,5,1,0 %;
macro KA49$V_INTREQ_SC_CP_ERR = 0,6,1,0 %;
macro KA49$V_INTREQ_MAP_ERR = 0,7,1,0 %;
literal KA49$M_INTCLR_BA = 1;
literal KA49$M_INTCLR_SC = 2;
literal KA49$M_INTCLR_GR = 4;
literal KA49$M_INTCLR_QU = 8;
literal KA49$M_INTCLR_SO = 16;
literal KA49$M_INTCLR_SY = 32;
literal KA49$M_INTCLR_SC_CP_ERR = 64;
literal KA49$M_INTCLR_MAP_ERR = 128;
literal KA49$S_KA49_INTCLR = 1;
macro KA49$V_INTCLR_BA = 0,0,1,0 %;
macro KA49$V_INTCLR_SC = 0,1,1,0 %;
macro KA49$V_INTCLR_GR = 0,2,1,0 %;
macro KA49$V_INTCLR_QU = 0,3,1,0 %;
macro KA49$V_INTCLR_SO = 0,4,1,0 %;
macro KA49$V_INTCLR_SY = 0,5,1,0 %;
macro KA49$V_INTCLR_SC_CP_ERR = 0,6,1,0 %;
macro KA49$V_INTCLR_MAP_ERR = 0,7,1,0 %;
literal KA49$M_WAT_CSRA_MBZ = 3;
literal KA49$M_WAT_CSRA_RSX = 60;
literal KA49$M_WAT_CSRA_DVX = 448;
literal KA49$M_WAT_CSRA_UIP = 512;
literal KA49$S_KA49_WAT_CSRA = 2;
macro KA49$V_WAT_CSRA_MBZ = 0,0,2,0 %;
literal KA49$S_WAT_CSRA_MBZ = 2;
macro KA49$V_WAT_CSRA_RSX = 0,2,4,0 %;
literal KA49$S_WAT_CSRA_RSX = 4;
macro KA49$V_WAT_CSRA_DVX = 0,6,3,0 %;
literal KA49$S_WAT_CSRA_DVX = 3;
macro KA49$V_WAT_CSRA_UIP = 0,9,1,0 %;
literal KA49$M_WAT_CSRB_MBZ = 3;
literal KA49$M_WAT_CSRB_DSE = 4;
literal KA49$M_WAT_CSRB_HF = 8;
literal KA49$M_WAT_CSRB_DM = 16;
literal KA49$M_WAT_CSRB_SQWE = 32;
literal KA49$M_WAT_CSRB_UIE = 64;
literal KA49$M_WAT_CSRB_AIE = 128;
literal KA49$M_WAT_CSRB_PIE = 256;
literal KA49$M_WAT_CSRB_SET = 512;
literal KA49$S_KA49_WAT_CSRB = 2;
macro KA49$V_WAT_CSRB_MBZ = 0,0,2,0 %;
literal KA49$S_WAT_CSRB_MBZ = 2;
macro KA49$V_WAT_CSRB_DSE = 0,2,1,0 %;
macro KA49$V_WAT_CSRB_HF = 0,3,1,0 %;
macro KA49$V_WAT_CSRB_DM = 0,4,1,0 %;
macro KA49$V_WAT_CSRB_SQWE = 0,5,1,0 %;
macro KA49$V_WAT_CSRB_UIE = 0,6,1,0 %;
macro KA49$V_WAT_CSRB_AIE = 0,7,1,0 %;
macro KA49$V_WAT_CSRB_PIE = 0,8,1,0 %;
macro KA49$V_WAT_CSRB_SET = 0,9,1,0 %;
literal KA49$M_WAT_CSRD_MBZ = 511;
literal KA49$M_WAT_CSRD_VRT = 512;
literal KA49$S_KA49_WAT_CSRD = 2;
macro KA49$V_WAT_CSRD_MBZ = 0,0,9,0 %;
literal KA49$S_WAT_CSRD_MBZ = 9;
macro KA49$V_WAT_CSRD_VRT = 0,9,1,0 %;
literal KA49$M_WAT_REG_MBZ = 3;
literal KA49$S_KA49_WAT_REG = 2;
macro KA49$V_WAT_REG_MBZ = 0,0,2,0 %;
literal KA49$S_WAT_REG_MBZ = 2;
macro KA49$B_WAT_REG_DATA = 1,0,8,0 %;
literal KA49$M_CPMBX_HLT = 3;
literal KA49$M_CPMBX_BIP = 4;
literal KA49$M_CPMBX_RIP = 8;
literal KA49$S_KA49_CPMBX = 1;
macro KA49$V_CPMBX_HLT = 0,0,2,0 %;
literal KA49$S_CPMBX_HLT = 2;
macro KA49$V_CPMBX_BIP = 0,2,1,0 %;
macro KA49$V_CPMBX_RIP = 0,3,1,0 %;
literal KA49$K_RS_RB_HLT = 0;
literal KA49$K_RS_HLT = 1;
literal KA49$K_RB_HLT = 2;
literal KA49$K_HLT = 3;
 
!*** MODULE $KA520DEF ***
literal KA520$L_CPUSCRP = 0;            !  CPU scratch pad
literal KA520$L_RSTPAG = 7680;          !  Reset page
literal KA520$L_RSTPC = 8180;           !  Reset PC
literal KA520$L_RSTCOM = 8184;          !  Reset complement 
literal KA520$L_RSTFLAG = 8188;         !  Reset flag
!  MEMORY CONTROLLER	
literal KA520$L_MEMCTL = 8192;          !  Control and status
literal KA520$L_MEMDIAG = 8196;         !  Diagnostic error
literal KA520$L_SYSFLT = 8200;          !  System fault error
literal KA520$L_BUSTIM = 8204;          !  Bus timeout - NSC
literal KA520$L_CACHE = 8208;           !  Cache - NSC
literal KA520$L_NVUPD = 8212;           !  NVRAM update register - NSC
literal KA520$L_SYSADR = 8216;          !  System fault error address
literal KA520$L_MEMCTLW = 8704;         !  Control and status wait
literal KA520$L_MEMDIAGW = 8708;        !  Diag error wait
literal KA520$L_SYSFLTW = 8712;         !  System fault wait
literal KA520$L_SYSADRW = 8728;         !  System fault address wait
literal KA520$L_SOFRST = 9216;          !  Soft Reset
!  DMA registers	
literal KA520$L_DMASTL = 9728;          !  Memory subtransfer length
literal KA520$L_DMACTL = 10240;         !  DMA control
literal KA520$L_DMASTA = 10752;         !  DMA status
literal KA520$L_DMAMBCD = 11264;        !  Memory byte count and direction
literal KA520$L_DMADIAG = 11776;        !  Diagnostic
literal KA520$L_DMAQAP = 12288;         !  Queue address pointer
literal KA520$L_DMAMMA = 12800;         !  Main Memory address
literal KA520$L_DMAQEP = 13312;         !  Queue entry pointer
literal KA520$L_DMAID = 13824;          !  ID
literal KA520$L_DMAEOQ = 14336;         !  End of queue
literal KA520$L_DMAARB = 14848;         !  Arbiter control
literal KA520$L_DMAECC = 15360;         !  ECC
literal KA520$L_DMAREF = 15872;         !  Refresh
!  CLINK
literal KA520$L_INTVEC0 = 16384;        !  Interrupt Vector 0
literal KA520$L_INTVEC1 = 16388;        !  Interrupt Vector 1
literal KA520$L_INTVEC2 = 16392;        !  Interrupt Vector 2
literal KA520$L_INTVEC3 = 16396;        !  Interrupt Vector 3
literal KA520$L_WINVEC = 16412;         !  Winning Vector
literal KA520$L_IRQ = 16416;            !  IRQ for vectors 0-3
literal KA520$L_IMR = 16420;            !  Interrupt mask 
literal KA520$L_CLIERR = 16896;         !  Error register
literal KA520$L_TIMINT = 17408;         !  Timer interval - NSC
literal KA520$L_SERREQ = 17920;         !  Serial request
literal KA520$L_SERREP = 18432;         !  Serial reply
literal KA520$L_SERQUE = 18944;         !  Serial queue
literal KA520$L_SERCSR = 19456;         !  Serial CSR
literal KA520$L_TIMCTL = 19968;         !  Timer control - NSC
literal KA520$L_TIMNXT = 20480;         !  Timer next interval - NSC
literal KA520$L_PROGDIV = 20992;        !  Programable divider _ NSC
literal KA520$L_PARCOMM = 21504;        !  Parrallel communications
literal KA520$L_RESET = 22016;          !  CPU/zone hard reset
literal KA520$L_SICSA = 22528;          !  System Interupt Control Register
!  Zone A 
literal KA520$L_SICSB = 23040;          !  System Interupt Control Register
!  Zone B 
literal KA520$L_PCOMMA = 23552;         !  Parallel comm register Zone a 
literal KA520$L_PCOMMB = 24064;         !  Parallel comm register zone b
literal KA520$l_PCSRA = 24576;          !  Parallel CSR zone Q
literal KA520$l_PCSRB = 25088;          !  Parallel CSR zone B
literal KA520$l_IORSTA = 25600;         !  IO Hard reset zone a
literal KA520$l_IORSTB = 26112;         !  IO Hard reset zone b
literal KA520$L_SYNCHR = 26624;         !  Synch Reset
literal KA520$L_CLIERRW = 27136;        !  Error register - world address
!  Cirrus vector page
literal KA520$L_CIRVEC = 27648;         !  Start of vector table
literal KA520$L_DMA_OP = 27648;         !  DMA driver service
literal KA520$L_TRARAMSTS = 27652;      !  Trace RAM status table
literal KA520$L_RECONFIG = 27656;       !  IO Reconfiguration Service
literal KA520$L_EF_ONLINE = 27660;      !  EFDRIVER port online entry point
literal KA520$L_PRIM_CIO = 27664;       !  Pointer to Primary CIO adapters
literal KA520$L_GD_ADP = 27668;         !  Pointer to the GD_ADP_TABLE
literal KA520$L_GD_ADP_TABLE = 27672;   !  List of ADP indexed by physical address
literal KA520$L_EEPROM_WRITE_LOCK = 27728; !  Set to Prevent EEPROM Write
literal KA520$L_MODEL_INFO = 27732;     !  Model information
literal KA550$L_TAG = 28672;            !  Cache Tag Store
literal KA550$L_DATA = 29696;           !  Cache Data Store
literal KA550$L_BEHR = 30720;           !  Bank Enable/Hit Register
literal KA520$M_MEMCTL_DISCOR = 1024;
literal KA520$M_MEMCTL_DISREP = 2048;
literal KA520$M_MEMCTL_ENAMIR = 4096;
literal KA520$M_MEMCTL_FADDR = 8192;
literal KA520$M_MEMCTL_FRTRYEN = 16384;
literal KA520$M_MEMCTL_LONGDMA = 32768;
literal KA520$M_MEMCTL_ENASR = 1048576;
literal KA520$M_MEMCTL_EBTO = 33554432;
literal KA520$S_MEMCTL = 4;
macro KA520$V_MEMCTL_ARBSEL = 0,0,3,0 %;
literal KA520$S_MEMCTL_ARBSEL = 3;      !  Arbitration select
macro KA520$V_MEMCTL_FECC = 0,3,7,0 %;
literal KA520$S_MEMCTL_FECC = 7;        !  Force ECC
macro KA520$V_MEMCTL_DISCOR = 0,10,1,0 %; !  Disable correction
macro KA520$V_MEMCTL_DISREP = 0,11,1,0 %; !  Disable reporting
macro KA520$V_MEMCTL_ENAMIR = 0,12,1,0 %; !  Enable mirror
macro KA520$V_MEMCTL_FADDR = 0,13,1,0 %; !  Force address patern
macro KA520$V_MEMCTL_FRTRYEN = 0,14,1,0 %; !  Forced retry enable
macro KA520$V_MEMCTL_LONGDMA = 0,15,1,0 %; !  Long DMA RAS
macro KA520$V_MEMCTL_MEMSIZ = 0,16,4,0 %;
literal KA520$S_MEMCTL_MEMSIZ = 4;      !  Memory size field #1
macro KA520$V_MEMCTL_ENASR = 0,20,1,0 %; !  Enable send/receive errors
macro KA520$V_MEMCTL_MEMSIZ2 = 0,21,4,0 %;
literal KA520$S_MEMCTL_MEMSIZ2 = 4;     !  Memory size field #2
macro KA520$V_MEMCTL_EBTO = 0,25,1,0 %; !  Enable BTO test mode
!  Bits 26-31 must be zero
literal KA520$M_MEMDIAG_WRTECC = 1;
literal KA520$M_MEMDIAG_RDECC = 2;
literal KA520$M_MEMDIAG_ADRCTL = 4;
literal KA520$M_MEMDIAG_BUSCMP = 8;
literal KA520$M_MEMDIAG_DBLBIT = 16;
literal KA520$M_MEMDIAG_ECCERR = 32;
literal KA520$M_MEMDIAG_SNDERR = 64;
literal KA520$M_MEMDIAG_RCVERR = 128;
literal KA520$M_MEMDIAG_UEXRTY = 256;
literal KA520$M_MEMDIAG_RAIERR = 512;
literal KA520$M_MEMDIAG_PIPERR = 1024;
literal KA520$M_MEMDIAG_BUSTIM = 2048;
literal KA520$M_MEMDIAG_RASTIM = 4096;
literal KA520$M_MEMDIAG_MEMSTK = 8192;
literal KA520$M_MEMDIAG_DMAERR = 16384;
literal KA520$M_MEMDIAG_CLRERR = 32768;
literal KA520$M_MEMDIAG_CPMFLT = 65536;
literal KA520$M_MEMDIAG_NXM = 131072;
literal KA520$M_MEMDIAG_PRENXM = 262144;
literal KA520$M_MEMDIAG_MLTERR = 524288;
literal KA520$M_MEMDIAG_MXPR = 1048576;
literal KA520$M_MEMDIAG_IODVRG = 2097152;
literal KA520$M_MEMDIAG_DMAMOST = 4194304;
literal KA520$M_MEMDIAG_RABORT = 8388608;
literal KA520$M_MEMDIAG_DMAFS = 16777216;
literal KA520$M_FILL_1 = 33554432;
literal KA520$M_MEMDIAG_ICYCLA = 67108864;
literal KA520$M_MEMDIAG_BURNIN = 134217728;
literal KA520$M_MEMDIAG_RSYNCS = 268435456;
literal KA520$M_MEMDIAG_RSYNCM = 536870912;
literal KA520$M_MEMDIAG_MIRRAI = 1073741824;
literal KA520$M_MEMDIAG_ZONEID = -2147483648;
literal KA520$S_MEMDIAG = 4;
macro KA520$V_MEMDIAG_WRTECC = 0,0,1,0 %; !  Write ECC error
macro KA520$V_MEMDIAG_RDECC = 0,1,1,0 %; !  Read ECC error
macro KA520$V_MEMDIAG_ADRCTL = 0,2,1,0 %; !  Address/control error
macro KA520$V_MEMDIAG_BUSCMP = 0,3,1,0 %; !  Bus compare error
macro KA520$V_MEMDIAG_DBLBIT = 0,4,1,0 %; !  Double bit error
macro KA520$V_MEMDIAG_ECCERR = 0,5,1,0 %; !  Any ECC error
macro KA520$V_MEMDIAG_SNDERR = 0,6,1,0 %; !  Send error
macro KA520$V_MEMDIAG_RCVERR = 0,7,1,0 %; !  Recieve error
macro KA520$V_MEMDIAG_UEXRTY = 0,8,1,0 %; !  Unexpected retry
macro KA520$V_MEMDIAG_RAIERR = 0,9,1,0 %; !  Rail error
macro KA520$V_MEMDIAG_PIPERR = 0,10,1,0 %; !  Pipe error
macro KA520$V_MEMDIAG_BUSTIM = 0,11,1,0 %; !  Bus timeout
macro KA520$V_MEMDIAG_RASTIM = 0,12,1,0 %; !  RAS timeout
macro KA520$V_MEMDIAG_MEMSTK = 0,13,1,0 %; !  Memeory arrary stuck ECC
macro KA520$V_MEMDIAG_DMAERR = 0,14,1,0 %; !  DMA error
macro KA520$V_MEMDIAG_CLRERR = 0,15,1,0 %; !  Clear errors
macro KA520$V_MEMDIAG_CPMFLT = 0,16,1,0 %; !  CPU/MEM error
macro KA520$V_MEMDIAG_NXM = 0,17,1,0 %; !  Non-existant memory
macro KA520$V_MEMDIAG_PRENXM = 0,18,1,0 %; !  Predetermined NXM
macro KA520$V_MEMDIAG_MLTERR = 0,19,1,0 %; !  Multiple errors
macro KA520$V_MEMDIAG_MXPR = 0,20,1,0 %; !  External process register
macro KA520$V_MEMDIAG_IODVRG = 0,21,1,0 %; !  IO divergence detected
macro KA520$V_MEMDIAG_DMAMOST = 0,22,1,0 %; !  DMA Most error
macro KA520$V_MEMDIAG_RABORT = 0,23,1,0 %; !  Resync abort
macro KA520$V_MEMDIAG_DMAFS = 0,24,1,0 %; !  DMA false start
macro KA520$V_FILL_1 = 0,25,1,0 %;      !  MBZ
macro KA520$V_MEMDIAG_ICYCLA = 0,26,1,0 %; !  Interlock cycle active
macro KA520$V_MEMDIAG_BURNIN = 0,27,1,0 %; !  Burn-in mode
macro KA520$V_MEMDIAG_RSYNCS = 0,28,1,0 %; !  Resync slave mode
macro KA520$V_MEMDIAG_RSYNCM = 0,29,1,0 %; !  Resync master mode
macro KA520$V_MEMDIAG_MIRRAI = 0,30,1,0 %; !  Mirror rail - rail ID
macro KA520$V_MEMDIAG_ZONEID = 0,31,1,0 %; !  Zone ID
!   System Fault Error Status Register - Memory Controller register
literal KA520$M_SYSFLT_TRN = 1;
literal KA520$M_SYSFLT_SOL = 2;
literal KA520$M_SYSFLT_NXM = 4;
literal KA520$M_SYSFLT_NIO = 8;
literal KA520$M_SYSFLT_MXPR = 16;
literal KA520$M_SYSFLT_IACK = 32;
literal KA520$M_SYSFLT_FMEMFLT = 64;
literal KA520$M_SYSFLT_CLRERR = 32768;
literal KA520$S_SYSFLT = 2;
macro KA520$V_SYSFLT_TRN = 0,0,1,0 %;   !  Transient error
macro KA520$V_SYSFLT_SOL = 0,1,1,0 %;   !  Solid error
macro KA520$V_SYSFLT_NXM = 0,2,1,0 %;   !  Non existent memory
macro KA520$V_SYSFLT_NIO = 0,3,1,0 %;   !  Non existent IO
macro KA520$V_SYSFLT_MXPR = 0,4,1,0 %;  !  Illegal MxPR insturction
macro KA520$V_SYSFLT_IACK = 0,5,1,0 %;  !  Interrupt acknowledge
macro KA520$V_SYSFLT_FMEMFLT = 0,6,1,0 %; !  Force CPU/MEM fault
macro KA520$V_FILL2 = 0,7,8,0 %;
literal KA520$S_FILL2 = 8;              !  MBZ
macro KA520$V_SYSFLT_CLRERR = 0,15,1,0 %; !  Clear error
!  Cache Control register (CACHE)
literal KA520$M_CACHE_FMIS = 1;
literal KA520$M_CACHE_FHIT = 2;
literal KA520$M_CACHE_INVD = 4;
literal KA520$M_TPE = 256;
literal KA520$S_CACHE = 2;
macro KA520$V_CACHE_FMIS = 0,0,1,0 %;   !  Force miss (i.e. disable)
macro KA520$V_CACHE_FHIT = 0,1,1,0 %;   !  Force hit (diag.)
macro KA520$V_CACHE_INVD = 0,2,1,0 %;   !  Invalidate cache
macro KA520$V_FILL_2 = 0,3,5,0 %;
literal KA520$S_FILL_2 = 5;             !  fill
macro KA520$V_TPE = 0,8,1,0 %;          !  Tag Parity Error
!  Other bits are diagnostic or unused
!  DMA status register */
literal KA520$M_DMASTA_DME = 1;
literal KA520$M_DMASTA_TIM = 2;
literal KA520$M_DMASTA_DON = 4;
literal KA520$M_DMASTA_DFM = 8;
literal KA520$M_DMASTA_DCE = 16;
literal KA520$M_DMASTA_NXM = 32;
literal KA520$M_DMASTA_CFM = 64;
literal KA520$S_DMASTA = 1;
macro KA520$V_DMASTA_DME = 0,0,1,0 %;   !  DMA mega error
macro KA520$V_DMASTA_TIM = 0,1,1,0 %;   !  Timeout error
macro KA520$V_DMASTA_DON = 0,2,1,0 %;   !  DMA done
macro KA520$V_DMASTA_DFM = 0,3,1,0 %;   !  DMA firewall miscompare
macro KA520$V_DMASTA_DCE = 0,4,1,0 %;   !  DMA crc error
macro KA520$V_DMASTA_NXM = 0,5,1,0 %;   !  Non-existant memory
macro KA520$V_DMASTA_CFM = 0,6,1,0 %;   !  CVAX firewall miscompare
!  DMA control register */
literal KA520$M_DMACTL_GO = 1;
literal KA520$M_DMACTL_STO = 2;
literal KA520$S_DMACTL = 1;
macro KA520$V_DMACTL_GO = 0,0,1,0 %;    !  DMA go bit
macro KA520$V_DMACTL_STO = 0,1,1,0 %;   !  DMA stop bit
!  Clink error and status register - CLINK
literal KA520$M_CLIERR_ZB = 7;
literal KA520$K_CLIERR_NOERR = 0;
literal KA520$K_CLIERR_DMA = 1;
literal KA520$K_CLIERR_CVAXIO = 2;
literal KA520$K_CLIERR_MEMFLT = 3;
literal KA520$K_CLIERR_CTLP = 4;
literal KA520$K_CLIERR_CLOCK = 5;
literal KA520$M_CLIERR_ZA = 56;
literal KA520$M_CLIERR_MEMERR = 64;
literal KA520$M_CLIERR_TFRZ = 128;
literal KA520$M_CLIERR_PUP = 256;
literal KA520$M_CLIERR_DSYNC = 512;
literal KA520$M_CLIERR_MODE = 3072;
literal KA520$K_CLIERR_OFF = 0;
literal KA520$K_CLIERR_SLAVE = 1;
literal KA520$K_CLIERR_MASTER = 2;
literal KA520$K_CLIERR_DUPLEX = 3;
literal KA520$S_CLIERR = 2;
macro KA520$V_CLIERR_ZB = 0,0,3,0 %;
literal KA520$S_CLIERR_ZB = 3;          !  Zone B error codes
macro KA520$V_CLIERR_ZA = 0,3,3,0 %;
literal KA520$S_CLIERR_ZA = 3;          !  Zone A error codes
macro KA520$V_CLIERR_MEMERR = 0,6,1,0 %; !  MEMERR
macro KA520$V_CLIERR_TFRZ = 0,7,1,0 %;  !  Trace freeze
macro KA520$V_CLIERR_PUP = 0,8,1,0 %;   !  Power up
macro KA520$V_CLIERR_DSYNC = 0,9,1,0 %; !  Duplex resync
macro KA520$V_CLIERR_MODE = 0,10,2,0 %;
literal KA520$S_CLIERR_MODE = 2;        !  Clink mode
!  Clink Serial CSR register (SERSCR)
literal KA520$M_SERCSR_XLMODE = 3;
literal KA520$K_SERCSR_CLINK_OFF = 0;
literal KA520$K_SERCSR_CLINK_SLAVE = 1;
literal KA520$K_SERCSR_CLINK_MASTER = 2;
literal KA520$K_SERCSR_CLINK_DUPLEX = 3;
literal KA520$M_SERCSR_DIAG = 4;
literal KA520$M_SERCSR_STATEN = 8;
literal KA520$M_SERCSR_SYNCMOD = 48;
literal KA520$K_SERCSR_SYNC_SLAVE = 1;
literal KA520$K_SERCSR_SYNC_MASTER = 2;
literal KA520$K_SERCSR_SYNC_DUPLEX = 3;
literal KA520$M_SERCSR_SYNCMODEN = 64;
literal KA520$M_SERCSR_CMD = 384;
literal KA520$K_SERCSR_CMD_LOOP = 0;
literal KA520$K_SERCSR_CMD_STAT = 1;
literal KA520$K_SERCSR_CMD_QUERY = 3;
literal KA520$M_SERCSR_CMDEN = 512;
literal KA520$M_SERCSR_INTLPB = 1024;
literal KA520$M_SERCSR_ENQUEINT = 2048;
literal KA520$M_SERCSR_ENREPINT = 4096;
literal KA520$M_SERCSR_ENREQINT = 8192;
literal KA520$M_SERCSR_PXLPBEN = 16384;
literal KA520$M_SERCSR_RSYNCDIS = 32768;
literal KA520$M_SERCSR_FRAMERR = 65536;
literal KA520$M_SERCSR_REQINT = 131072;
literal KA520$M_SERCSR_QUEFULL = 262144;
literal KA520$M_SERCSR_QUEOVF = 524288;
literal KA520$M_SERCSR_REPFULL = 1048576;
literal KA520$M_SERCSR_REPOVF = 2097152;
literal KA520$M_SERCSR_REQFULL = 4194304;
literal KA520$M_SERCSR_MAGINEN = 8388608;
literal KA520$M_SERCSR_MAGINSET = 16777216;
literal KA520$M_SERCSR_XMITBSY = 33554432;
literal KA520$M_SERCSR_OSRUN = 67108864;
literal KA520$M_SERCSR_CLKFLTEN = 134217728;
literal KA520$M_SERCSR_SYSFLT = 268435456;
literal KA520$M_SERCSR_CLKPHERR = 536870912;
literal KA520$M_SERCSR_CLKSEL = 1073741824;
literal KA520$M_SERCSR_ZONEID = -2147483648;
literal KA520$S_SERCSR = 4;
macro KA520$V_SERCSR_XLMODE = 0,0,2,0 %;
literal KA520$S_SERCSR_XLMODE = 2;      !  Clink mode
macro KA520$V_SERCSR_DIAG = 0,2,1,0 %;  !  Diagnostic bit
macro KA520$V_SERCSR_STATEN = 0,3,1,0 %; !  State enable
macro KA520$V_SERCSR_SYNCMOD = 0,4,2,0 %;
literal KA520$S_SERCSR_SYNCMOD = 2;     !  Resynch mode
macro KA520$V_SERCSR_SYNCMODEN = 0,6,1,0 %; !  Resynch mode enable
macro KA520$V_SERCSR_CMD = 0,7,2,0 %;
literal KA520$S_SERCSR_CMD = 2;         !  Command
macro KA520$V_SERCSR_CMDEN = 0,9,1,0 %; !  Command enable
macro KA520$V_SERCSR_INTLPB = 0,10,1,0 %; !  Internal loopback
macro KA520$V_SERCSR_ENQUEINT = 0,11,1,0 %; !  Enable query int.
macro KA520$V_SERCSR_ENREPINT = 0,12,1,0 %; !  Enable reply int.
macro KA520$V_SERCSR_ENREQINT = 0,13,1,0 %; !  Enable request int.
macro KA520$V_SERCSR_PXLPBEN = 0,14,1,0 %; !  Par. loopback enable
macro KA520$V_SERCSR_RSYNCDIS = 0,15,1,0 %; !  Rail synch disable
macro KA520$V_SERCSR_FRAMERR = 0,16,1,0 %; !  Framing error
macro KA520$V_SERCSR_REQINT = 0,17,1,0 %; !  Request interrupt
macro KA520$V_SERCSR_QUEFULL = 0,18,1,0 %; !  Query full
macro KA520$V_SERCSR_QUEOVF = 0,19,1,0 %; !  Query overflow
macro KA520$V_SERCSR_REPFULL = 0,20,1,0 %; !  Reply full
macro KA520$V_SERCSR_REPOVF = 0,21,1,0 %; !  Reply overflow
macro KA520$V_SERCSR_REQFULL = 0,22,1,0 %; !  Request full
macro KA520$V_SERCSR_MAGINEN = 0,23,1,0 %; !  Mag. indicator enable
macro KA520$V_SERCSR_MAGINSET = 0,24,1,0 %; !  Mag. indicator set
macro KA520$V_SERCSR_XMITBSY = 0,25,1,0 %; !  Transmit busy
macro KA520$V_SERCSR_OSRUN = 0,26,1,0 %; !  Os running
macro KA520$V_SERCSR_CLKFLTEN = 0,27,1,0 %; !  Clock fault enable
macro KA520$V_SERCSR_SYSFLT = 0,28,1,0 %; !  System fault
macro KA520$V_SERCSR_CLKPHERR = 0,29,1,0 %; !  Clock phase error
macro KA520$V_SERCSR_CLKSEL = 0,30,1,0 %; !  Clock select
macro KA520$V_SERCSR_ZONEID = 0,31,1,0 %; !  Zone ID
!  Parallel Control and Status register (PCSRA and PCSRB)
literal KA520$M_PARCSR_XLMODE = 3;
literal KA520$K_PARCSR_CLINK_OFF = 0;
literal KA520$K_PARCSR_CLINK_SLAVE = 1;
literal KA520$K_PARCSR_CLINK_MASTER = 2;
literal KA520$K_PARCSR_CLINK_DUPLEX = 3;
literal KA520$M_PARCSR_PWR = 4;
literal KA520$M_PARCSR_CABLE = 8;
literal KA520$M_PARCSR_BUSMODE = 48;
literal KA520$K_PARCSR_NORMAL = 0;
literal KA520$K_PARCSR_RSYNC_SLAVE = 1;
literal KA520$K_PARCSR_RSYNC_MASTER = 2;
literal KA520$M_PARCSR_OSRUN = 64;
literal KA520$S_PARCSR = 1;
macro KA520$V_PARCSR_XLMODE = 0,0,2,0 %;
literal KA520$S_PARCSR_XLMODE = 2;      !  Clink mode
macro KA520$V_PARCSR_PWR = 0,2,1,0 %;   !  Power bit
macro KA520$V_PARCSR_CABLE = 0,3,1,0 %; !  Cable bit
macro KA520$V_PARCSR_BUSMODE = 0,4,2,0 %;
literal KA520$S_PARCSR_BUSMODE = 2;     !  Bus operation mode
macro KA520$V_PARCSR_OSRUN = 0,6,1,0 %; !  Operating System running
!   Interval Timer Control Register (TIMCTL)
literal KA520$M_TCR_RUN = 1;
literal KA520$M_TCR_STP = 4;
literal KA520$M_TCR_XFR = 16;
literal KA520$M_TCR_SGL = 32;
literal KA520$M_TCR_IE = 64;
literal KA520$M_TCR_INT = 128;
literal KA520$M_TCR_ERR = -2147483648;
literal KA520$S_TCR = 4;
macro KA520$V_TCR_RUN = 0,0,1,0 %;      ! INCREMENT TIR EVERY uSEC
macro KA520$V_TCR_FILL1 = 0,1,1,0 %;    ! UNUSED
macro KA520$V_TCR_STP = 0,2,1,0 %;      ! STOP ON OVERFLOW
macro KA520$V_TCR_FILL2 = 0,3,1,0 %;    ! UNUSED
macro KA520$V_TCR_XFR = 0,4,1,0 %;      ! COPY TNIR TO TIR
macro KA520$V_TCR_SGL = 0,5,1,0 %;      ! INCREMENT TIR (IF RUN = 0)
macro KA520$V_TCR_IE = 0,6,1,0 %;       ! INTERRUPT ENABLE
macro KA520$V_TCR_INT = 0,7,1,0 %;      ! OVERFLOW
macro KA520$V_TCR_FILL3 = 0,8,23,0 %;
literal KA520$S_TCR_FILL3 = 23;         ! UNUSED
macro KA520$V_TCR_ERR = 0,31,1,0 %;     ! ERROR (MISSED OVERFLOW)
!   Model specific information
literal KA520$M_MODINF_NOPCIM = 1;
literal KA520$M_MODINF_NOECACHE = 2;
literal KA520$S_MODINF = 1;
macro KA520$V_MODINF_NOPCIM = 0,0,1,0 %; !  No PCIM on hardware
macro KA520$V_MODINF_NOECACHE = 0,1,1,0 %; !  External cache not used
!  Programmable Divider register */
literal KA520$M_PROGDIV_INTERVAL = 4095;
literal KA520$M_PROGDIV_QUARTER = 4096;
literal KA520$M_PROGDIV_TEST2 = 8192;
literal KA520$M_PROGDIV_TEST1 = 16384;
literal KA520$M_PROGDIV_HALF = 32768;
literal KA520$S_PROGDIV = 2;
macro KA520$V_PROGDIV_INTERVAL = 0,0,12,0 %;
literal KA520$S_PROGDIV_INTERVAL = 12;  !  Interval value
macro KA520$V_PROGDIV_QUARTER = 0,12,1,0 %; !  1/4 divide (Cirrus II)
macro KA520$V_PROGDIV_TEST2 = 0,13,1,0 %; !  Test 2 bit
macro KA520$V_PROGDIV_TEST1 = 0,14,1,0 %; !  Test 1 bit
macro KA520$V_PROGDIV_HALF = 0,15,1,0 %; !  1/2 divide
literal KA550$M_TAG_DP = 15;
literal KA550$M_TAG_TAG = 536869888;
literal KA550$M_TAG_VALID = 1073741824;
literal KA550$M_TAG_PARITY = -2147483648;
literal KA550$S_KA550_TAG = 4;
macro KA550$V_TAG_DP = 0,0,4,0 %;
literal KA550$S_TAG_DP = 4;
macro KA550$V_TAG_TAG = 0,10,19,0 %;
literal KA550$S_TAG_TAG = 19;
macro KA550$V_TAG_VALID = 0,30,1,0 %;
macro KA550$V_TAG_PARITY = 0,31,1,0 %;
literal KA550$M_BEHR_ENABLE = 255;
literal KA550$M_BEHR_HIT = 65280;
literal KA550$S_KA550_BEHR = 4;
macro KA550$V_BEHR_ENABLE = 0,0,8,0 %;
literal KA550$S_BEHR_ENABLE = 8;
macro KA550$V_BEHR_HIT = 0,8,8,0 %;
literal KA550$S_BEHR_HIT = 8;
 
!*** MODULE $KA60DEF ***
literal KA60$L_SSC_BASE = 0;            ! SSC base register
literal KA60$B_NVR0 = 512;              !  NVR0
literal KA60$B_NVR1 = 513;              !  NVR1
literal KA60$B_NVR2 = 514;              !  NVR2
literal KA60$B_SCSI_HOST_ID = 704;      !  SCSI host ID
literal KA60$L_CCAPTR = 784;            !  CCA pointer
literal KA60$L_CTSIAPTR = 788;          !  CTSIA pointer
literal KA60$B_CONSOLE_NODE = 842;      !  Nexus of console
literal KA60$L_IOCSR = 1536;            ! IOCSR register
literal KA60$L_CCA = 2048;              !  CCA area
literal KA60$M_IOCSR_ESAR = 16711680;
literal KA60$M_IOCSR_SDSEL = 67108864;
literal KA60$M_IOCSR_SDEN = 134217728;
literal KA60$M_IOCSR_RSTWS = 268435456;
literal KA60$M_IOCSR_CLKIEN = 536870912;
literal KA60$M_IOCSR_MRUN = 1073741824;
literal KA60$M_IOCSR_CNSL = -2147483648;
literal KA60$S_IOCSR = 4;
macro KA60$V_IOCSR_ESAR = 0,16,8,0 %;
literal KA60$S_IOCSR_ESAR = 8;          ! Station address
macro KA60$V_IOCSR_SDSEL = 0,26,1,0 %;  !  SCSI or DSSI
macro KA60$V_IOCSR_SDEN = 0,27,1,0 %;   !  Serial line disable
macro KA60$V_IOCSR_RSTWS = 0,28,1,0 %;  ! Reset workstation
macro KA60$V_IOCSR_CLKIEN = 0,29,1,0 %; ! Clock enable
macro KA60$V_IOCSR_MRUN = 0,30,1,0 %;   !  MRUN signal
macro KA60$V_IOCSR_CNSL = 0,31,1,0 %;   ! Console enable
literal KA60CPU$L_FBIC_A = 0;           !  CPU A FBIC registers
literal KA60CPU$B_CACHE_A = 512;        !  CPU A cache tags
literal KA60CPU$L_FBIC_B = 66048;       !  CPU B FBIC registers
literal KA60CPU$B_CACHE_B = 66560;      !  CPU A cache tags
literal KA60GFX$L_FBIC = 0;             !  LEGSS FBIC registers
literal KA60GFX$B_COMM = 512;           !  LEGSS commuication area
literal KA60GFX$L_WEITEK = 68096;       !  LEGSS DRAM Weitek output
literal KA60GFX$L_SCB = 166400;         !  LEGSS DRAM SCB area
literal KA60GFX$L_SVX = 168448;         !  LEGSS DRAM SVX area
literal KA60GFX$L_TCHIP = 173568;       !  LEGSS TCHIP
literal KA60GFX$L_DCHIP = 174080;       !  LEGSS DCHIP
literal KA60GFX$L_ACHIP = 176128;       !  LEGSS ACHIP
literal KA60$M_HALT_ACTION = 3;
literal KA60$M_BIP = 4;
literal KA60$M_RIP = 8;
literal KA60$M_LANGUAGE = 240;
literal KA60$S_NVR0 = 1;
macro KA60$V_HALT_ACTION = 0,0,2,0 %;
literal KA60$S_HALT_ACTION = 2;         ! HALT ACTION CODE
macro KA60$V_BIP = 0,2,1,0 %;           ! 1 = BOOT IN PROGRESS
macro KA60$V_RIP = 0,3,1,0 %;           ! 1 = RESTART IN PROGRESS
macro KA60$V_LANGUAGE = 0,4,4,0 %;
literal KA60$S_LANGUAGE = 4;            ! CONSOLE LANGUAGE CODE
literal KA60$M_RESERVED1 = 1;
literal KA60$M_CRT = 2;
literal KA60$M_MCS = 4;
literal KA60$M_RESERVED2 = 24;
literal KA60$M_VIDEO_DEV = 224;
literal KA60$S_NVR1 = 1;
macro KA60$V_RESERVED1 = 0,0,1,0 %;
macro KA60$V_CRT = 0,1,1,0 %;           ! 1 = Is CRT TERMINAL
macro KA60$V_MCS = 0,2,1,0 %;           ! 1 = TERMINAL SPEAKS MCS
macro KA60$V_RESERVED2 = 0,3,2,0 %;
literal KA60$S_RESERVED2 = 2;
macro KA60$V_VIDEO_DEV = 0,5,3,0 %;
literal KA60$S_VIDEO_DEV = 3;           ! VIDEO DEVICE CLASS
literal KA60$S_NVR2 = 1;
macro KA60$B_KEYBOARD = 0,0,8,1 %;      ! KEYBOARD CODE
!  Video device codes that may appear in NVR.VIDEO_DEV
literal KA60$K_TTY = 0;                 !  0
literal KA60$K_QVSS = 1;                !  1
literal KA60$K_QDSS = 2;                !  2
literal KA60$K_LEGSS = 3;               !  3
literal KA60$K_PIXELSTAMP = 4;          !  4
literal KA60$K_LYNX = 5;                !  5
!  Halt action codes that may appear in NVR.HALT_ACTION
literal KA60$K_RS_RB_HLT = 0;           !  0 RESTART, REBOOT, HALT
literal KA60$K_RS_HLT = 1;              !  1 RESTART, HALT
literal KA60$K_RB_HLT = 2;              !  2 REBOOT, HALT
literal KA60$K_HLT = 3;                 !  3 HALT
 
!*** MODULE $KA650DEF ***
! ++
!  VIRTUAL ADDRESS SPACE LAYOUT FOR MAYFAIR CPU NODE SPECIFIC REGION
!  POINTED TO BY EXE$GL_CPUNODSP
! --
literal KA650$W_QVSS_CSR = 128;         !  QVSS CSR (IF EXISTS)
literal KA650$W_QDSS_CSR0 = 256;        !  QDSS CSR ADR (POSSIBLY)
literal KA650$W_QDSS_CSR2 = 258;        !  QDSS CSR ADR (POSSIBLY)
literal KA650$W_QDSS_CSR4 = 260;        !  QDSS CSR ADR (POSSIBLY)
literal KA650$W_QDSS_CSR6 = 262;        !  QDSS CSR ADR (POSSIBLY)
literal KA650$W_QDSS_CSR8 = 264;        !  QDSS CSR ADR (POSSIBLY)
literal KA650$W_QDSS_CSRA = 266;        !  QDSS CSR ADR (POSSIBLY)
literal KA650$W_QDSS_CSRC = 268;        !  QDSS CSR ADR (POSSIBLY)
literal KA650$W_QDSS_CSRE = 270;        !  QDSS CSR ADR (POSSIBLY)
literal KA650$W_INTPR0 = 320;           !  INTERPROC COMMUN REG
!    (ICR) FOR ARBITER
literal KA650$W_INTPR1 = 322;           !  ICR FOR AUXIL 1
literal KA650$W_INTPR2 = 324;           !  ICR FOR AUXIL 2
literal KA650$W_INTPR3 = 326;           !  ICR FOR AUXIL 3
literal KA650$L_SIDEX = 516;            !  SYS ID EXTENSION REG
literal KA650$L_CACR = 1024;            !  CACHE CONTROL REG
literal KA650$L_BDR = 1028;             !  BOOT & DIAGNOSTIC REG
literal KA650$L_QMAPS = 1536;           !  FIRST QBUS MAP REG
literal KA650$L_QMAPE = 34300;          !  LAST QBUS MAP REG
literal KA650$L_SCR = 34304;            !  SYS CONFIG REG
literal KA650$L_DSER = 34308;           !  MEM SYSTEM ERR REG
literal KA650$L_MEAR = 34312;           !  MASTER ERROR ADDR REG
literal KA650$L_SEAR = 34316;           !  SLAVE ERROR ADDR REG
literal KA650$L_QBMBR = 34320;          !  Q BUS MAP BASE ADDR REG
literal KA650$L_MEM0 = 34560;           !  MAIN MEMORY REG 0
literal KA650$L_MEM16 = 34624;          !  MAIN MEMORY REG 16
literal KA650$L_MEM17 = 34628;          !  MAIN MEMORY REG 17
literal KA650$L_SSCBR = 34816;          !  SSC BASE ADDRS REG
literal KA650$L_SSCCR = 34832;          !  SSC CONFIG REG
literal KA650$L_CBTCR = 34848;          !  CDAL BUS TIMEOUT
literal KA650$L_DLEDR = 34864;          !  DIAGNOSTIC LED REG
literal KA650$L_TCR0 = 35072;           !  Timer 0 Control Reg
literal KA650$L_TIR0 = 35076;           !  Timer 0 Interval Reg
literal KA650$L_TNIR0 = 35080;          !  Timer 0 Next Interval Reg
literal KA650$L_TIVR0 = 35084;          !  Timer 0 Interrupt Vector Reg
literal KA650$L_TCR1 = 35088;           !  Timer 1 Control Reg
literal KA650$L_TIR1 = 35092;           !  Timer 1 Interval Reg
literal KA650$L_TNIR1 = 35096;          !  Timer 1 Next Interval Reg
literal KA650$L_TIVR1 = 35100;          !  Timer 1 Interrupt Vector Reg
literal KA650$B_NVR = 35328;            !  PUBLIC NONVOLATILE
!  RAM AREA
literal KA650$B_NVRE = 36351;           !  END OF NVR
literal KA650$B_CACH2 = 36352;          !  2NDARY CACHE
literal KA650$B_CACH2E = 101880;        !  LAST CACHE ENTRY
literal KA650$S_KA650DEF = 36352;       !  Size mapped by
!  KA650DEF
!  System ID Extension Longword
literal KA650$S_SIDEX = 4;
macro KA650$W_SIDEX_FILL1 = 0,0,16,0 %; ! RESERVED
macro KA650$B_SIDEX_ROMVER = 2,0,8,0 %; ! BOOT ROM VERSION
macro KA650$B_SIDEX_SYSCODE = 3,0,8,0 %; ! SYSTEM CODE. 1=uVAX II
!  System Configurataion Register
literal KA650$M_SCR_DOS = 14;
literal KA650$M_SCR_AUX = 1024;
literal KA650$M_SCR_BHE = 16384;
literal KA650$M_SCR_POK = 32768;
literal KA650$S_SCR = 4;
macro KA650$V_SCR_FILL1 = 0,0,1,0 %;    ! UNUSED
macro KA650$V_SCR_DOS = 0,1,3,0 %;
literal KA650$S_SCR_DOS = 3;            ! DOORBELL OFFSET
macro KA650$V_SCR_FILL2 = 0,4,6,0 %;
literal KA650$S_SCR_FILL2 = 6;          ! UNUSED
macro KA650$V_SCR_AUX = 0,10,1,0 %;     ! AUXILIARY OR ARBITER
! MODE
!  0 = ARBITER
!  1 = AUXILIARY	
macro KA650$V_SCR_FILL3 = 0,11,3,0 %;
literal KA650$S_SCR_FILL3 = 3;          ! UNUSED
macro KA650$V_SCR_BHE = 0,14,1,0 %;     ! BHALT ENABLE 
!  1 = HALT CPU
!  0 = NO EFFECT
macro KA650$V_SCR_POK = 0,15,1,0 %;     ! POWER OK
macro KA650$W_SCR_FILL3 = 2,0,16,0 %;   ! UNUSED
!   DMA System Error Register (DSER)
literal KA650$M_DSER_NXM = 1;
literal KA650$M_DSER_NG = 4;
literal KA650$M_DSER_LEB = 8;
literal KA650$M_DSER_MME = 16;
literal KA650$M_DSER_PE = 32;
literal KA650$M_DSER_QNXM = 128;
literal KA650$S_DSER = 4;
macro KA650$V_DSER_NXM = 0,0,1,0 %;     ! DMA TO NONEXISTENT MAIN MEMORY BIT IS SET
macro KA650$V_DSER_FILL1 = 0,1,1,0 %;   ! UNUSED	
macro KA650$V_DSER_NG = 0,2,1,0 %;      ! NO GRANT TIME OUT
macro KA650$V_DSER_LEB = 0,3,1,0 %;     ! LOST ERROR
macro KA650$V_DSER_MME = 0,4,1,0 %;     ! MAIN MEMORY ERROR
macro KA650$V_DSER_PE = 0,5,1,0 %;      ! BUS PARITY ERROR
macro KA650$V_DSER_FILL2 = 0,6,1,0 %;   ! UNUSED
macro KA650$V_DSER_QNXM = 0,7,1,0 %;    ! Q-BUS NON-EXIST MEMORY
macro KA650$V_DSER_FILL3 = 0,8,8,0 %;
literal KA650$S_DSER_FILL3 = 8;         ! UNUSED
macro KA650$W_DSER_FILL4 = 2,0,16,0 %;  ! UNUSED
!  Master Error Address Register (MEAR)
literal KA650$S_MEAR = 4;
macro KA650$W_MEAR_ADR = 0,0,16,0 %;    ! MASTER ERROR ADDRESS REG <12:0>
macro KA650$W_MEAR_FILL1 = 2,0,16,0 %;  ! UNUSED, RETURNS AS 0
!  Slave Error Address Register (SEAR)
literal KA650$S_SEAR = 4;
macro KA650$L_SEAR_ADR = 0,0,32,0 %;    ! SLAVE ERROR ADDRESS REGISTER
!   Main Memory Configuration Registers (MEMSCR0 - MEMSCR15)
literal KA650$M_MEMCR_BU = 3;
literal KA650$M_MEMCR_BS = 4;
literal KA650$M_MEMCR_SRR = 32;
literal KA650$M_MEMCR_BE = -2147483648;
literal KA650$S_MEMCR = 4;
macro KA650$V_MEMCR_BU = 0,0,2,0 %;
literal KA650$S_MEMCR_BU = 2;           ! BANK USAGE
! 00 = NO BANK IN USE
! 01 = NOT USED,ILLEGAL
! 10 = FIRST 2 BANKS IN USE
! 11 = ALL 4 BANKS IN USE
macro KA650$V_MEMCR_BS = 0,2,1,0 %;     ! BANK SIZE
macro KA650$V_MEMCR_BEM = 0,3,2,0 %;
literal KA650$S_MEMCR_BEM = 2;          ! BANK ERROR MODE
macro KA650$V_MEMCR_SRR = 0,5,1,0 %;    ! SIGNATURE READ REQUEST
macro KA650$V_MEMCR_FILL1 = 0,6,16,0 %;
literal KA650$S_MEMCR_FILL1 = 16;       ! UNUSED
macro KA650$V_MEMCR_BN = 0,22,4,0 %;
literal KA650$S_MEMCR_BN = 4;           ! BANK NUMBER
macro KA650$V_MEMCR_FILL2 = 0,26,5,0 %;
literal KA650$S_MEMCR_FILL2 = 5;        ! UNUSED
macro KA650$V_MEMCR_BE = 0,31,1,0 %;    ! BANK ENABLE
!   Main Memory Configuration Register 16 (MEMCSR16)
literal KA650$M_MEM16_SYND = 127;
literal KA650$M_MEM16_CDALERR = 128;
literal KA650$M_MEM16_DMAERR = 256;
literal KA650$M_MEM16_ADDR = 536870400;
literal KA650$M_MEM16_CRDERR = 536870912;
literal KA650$M_MEM16_RDSERRHI = 1073741824;
literal KA650$M_MEM16_RDSERR = -2147483648;
literal KA650$S_MEMCR16 = 4;
macro KA650$V_MEM16_SYND = 0,0,7,0 %;
literal KA650$S_MEM16_SYND = 7;         ! ERROR SYNDROME
macro KA650$V_MEM16_CDALERR = 0,7,1,0 %; ! CDAL BUS ERROR
macro KA650$V_MEM16_DMAERR = 0,8,1,0 %; ! DMA ERROR
macro KA650$V_MEM16_ADDR = 0,9,20,0 %;
literal KA650$S_MEM16_ADDR = 20;        ! PAGE ADDRESS OF ERROR
macro KA650$V_MEM16_CRDERR = 0,29,1,0 %; ! CRD ERROR
macro KA650$V_MEM16_RDSERRHI = 0,30,1,0 %; ! RDS HIGH ERROR RATE
macro KA650$V_MEM16_RDSERR = 0,31,1,0 %; ! RDS ERROR
!   Main Memory Configuration Register 17 (MEMCSR17)
literal KA650$M_MEM17_CHECK = 127;
literal KA650$M_MEM17_DIAGMODE = 128;
literal KA650$M_MEM17_BRDERR = 256;
literal KA650$M_MEM17_DIAGFAST = 512;
literal KA650$M_MEM17_ECCDSB = 1024;
literal KA650$M_MEM17_REFRESH = 2048;
literal KA650$M_MEM17_CRDENB = 4096;
literal KA650$M_MEM17_FASTMEM = 8192;
literal KA650$M_MEM17_DMAMODE = 16384;
literal KA650$S_MEMCR17 = 2;
macro KA650$V_MEM17_CHECK = 0,0,7,0 %;
literal KA650$S_MEM17_CHECK = 7;        ! CHECK BITS
macro KA650$V_MEM17_DIAGMODE = 0,7,1,0 %; ! DIAGNOSTIC CHECK MODE
macro KA650$V_MEM17_BRDERR = 0,8,1,0 %; ! BOARD ERROR
macro KA650$V_MEM17_DIAGFAST = 0,9,1,0 %; ! FAST DIAGNOSTIC TEST
macro KA650$V_MEM17_ECCDSB = 0,10,1,0 %; ! ECC DISABLE
macro KA650$V_MEM17_REFRESH = 0,11,1,0 %; ! FORCE REFRESH
macro KA650$V_MEM17_CRDENB = 0,12,1,0 %; ! CRD INTERRUPT ENABLE
macro KA650$V_MEM17_FASTMEM = 0,13,1,0 %; ! FAST MAIN MEM CYCLE
macro KA650$V_MEM17_DMAMODE = 0,14,1,0 %; ! DMA BUS MODE
!  Cache Control Register
literal KA650$M_CACR_DIA = 1;
literal KA650$M_CACR_WW = 2;
literal KA650$M_CACR_CEN = 16;
literal KA650$M_CACR_CPE = 32;
literal KA650$M_CACR_CSP = 192;
literal KA650$M_CACR_TAG = 261888;
literal KA650$M_CACR_V = 262144;
literal KA650$M_CACR_P = 524288;
literal KA650$M_CACR_MO1 = 1048576;
literal KA650$M_CACR_M02 = 2097152;
literal KA650$M_CACR_PPO = 4194304;
literal KA650$M_CACR_PTO = 8388608;
literal KA650$S_CACR = 4;
macro KA650$V_CACR_DIA = 0,0,1,0 %;     ! DIAGNOSTIC MODE
macro KA650$V_CACR_WW = 0,1,1,0 %;      ! WRITE WRONG PARITY
macro KA650$V_CACR_FILL1 = 0,2,2,0 %;
literal KA650$S_CACR_FILL1 = 2;         ! UNUSED
macro KA650$V_CACR_CEN = 0,4,1,0 %;     ! CASH ENABLE
macro KA650$V_CACR_CPE = 0,5,1,0 %;     ! CASH PARITY ERROR
macro KA650$V_CACR_CSP = 0,6,2,0 %;
literal KA650$S_CACR_CSP = 2;           ! CVAX CYCLE SPEED
!  00 = RESERVED FOR FUTURE
!  01 = 60 NS
!  10 = 80 NS
!  11 = 100 NS
macro KA650$V_CACR_TAG = 0,8,10,0 %;
literal KA650$S_CACR_TAG = 10;          ! TAG
macro KA650$V_CACR_V = 0,18,1,0 %;      ! TAG BLOCK VALUE BIT
macro KA650$V_CACR_P = 0,19,1,0 %;      ! TAG BLOCK PARITY BIT
macro KA650$V_CACR_MO1 = 0,20,1,0 %;    ! MATCH OUTPUT 1
macro KA650$V_CACR_M02 = 0,21,1,0 %;    ! MATCH OUTPUT 2
macro KA650$V_CACR_PPO = 0,22,1,0 %;    ! PREDICTIVE PARITY TREE OUTPUT
macro KA650$V_CACR_PTO = 0,23,1,0 %;    ! PARITY TREE OUTPUT
macro KA650$V_CACR_FILL2 = 0,24,8,0 %;
literal KA650$S_CACR_FILL2 = 8;         ! UNUSED
!  Boot and Diagnostic Configuration Register (BDR)
literal KA650$M_BDR_CD = 3;
literal KA650$M_BRS_CD = 112;
literal KA650$M_HLT_ENB = 128;
literal KA650$S_BDR = 4;
macro KA650$V_BDR_CD = 0,0,2,0 %;
literal KA650$S_BDR_CD = 2;             ! BOOT DISPLAY BITS
macro KA650$V_CPUCD = 0,2,2,0 %;
literal KA650$S_CPUCD = 2;              ! CPU CODE
macro KA650$V_BRS_CD = 0,4,3,0 %;
literal KA650$S_BRS_CD = 3;             ! BAUD RATE SELECT
macro KA650$V_HLT_ENB = 0,7,1,0 %;      ! HAULT ENABLE
macro KA650$V_BDR_FILL1 = 0,8,24,0 %;
literal KA650$S_BDR_FILL1 = 24;         ! UNUSED
!  Diagnostic LED Register (DLEDR)
literal KA650$M_DLEDR_DSPL = 15;
literal KA650$S_DLEDR = 4;
macro KA650$V_DLEDR_DSPL = 0,0,4,0 %;
literal KA650$S_DLEDR_DSPL = 4;         ! DISPLAY <3:0>
macro KA650$V_DLEDR_FILL1 = 0,4,12,0 %;
literal KA650$S_DLEDR_FILL1 = 12;       ! UNUSED
macro KA650$W_DLEDR_FILL2 = 2,0,16,0 %; ! UNUSED
!   Interval Timer Control Regsiters (TCR0, TCR1)
literal KA650$M_TCR_RUN = 1;
literal KA650$M_TCR_STP = 4;
literal KA650$M_TCR_XFR = 16;
literal KA650$M_TCR_SGL = 32;
literal KA650$M_TCR_IE = 64;
literal KA650$M_TCR_INT = 128;
literal KA650$M_TCR_ERR = -2147483648;
literal KA650$S_TCR = 4;
macro KA650$V_TCR_RUN = 0,0,1,0 %;      ! INCREMENT TIR EVERY uSEC
macro KA650$V_TCR_FILL1 = 0,1,1,0 %;    ! UNUSED
macro KA650$V_TCR_STP = 0,2,1,0 %;      ! STOP ON OVERFLOW
macro KA650$V_TCR_FILL2 = 0,3,1,0 %;    ! UNUSED
macro KA650$V_TCR_XFR = 0,4,1,0 %;      ! COPY TNIR TO TIR
macro KA650$V_TCR_SGL = 0,5,1,0 %;      ! INCREMENT TIR (IF RUN = 0)
macro KA650$V_TCR_IE = 0,6,1,0 %;       ! INTERRUPT ENABLE
macro KA650$V_TCR_INT = 0,7,1,0 %;      ! OVERFLOW
macro KA650$V_TCR_FILL3 = 0,8,23,0 %;
literal KA650$S_TCR_FILL3 = 23;         ! UNUSED
macro KA650$V_TCR_ERR = 0,31,1,0 %;     ! ERROR (MISSED OVERFLOW)
!   Interval Timer Interrupt Vector Regsiters (TIVR0, TIVR1)
literal KA650$S_TIVR = 4;
macro KA650$V_TIVR_FILL1 = 0,0,2,0 %;
literal KA650$S_TIVR_FILL1 = 2;         ! UNUSED
macro KA650$V_TIVR_VEC = 0,2,8,0 %;
literal KA650$S_TIVR_VEC = 8;           ! INTERRUPT VECTOR
macro KA650$V_TIVR_FILL2 = 0,10,22,0 %;
literal KA650$S_TIVR_FILL2 = 22;        ! UNUSED
!  Public Nonvolatile RAM area
literal KA650$S_NVR = 3;
macro KA650$V_HALT_ACTION = 0,0,2,0 %;
literal KA650$S_HALT_ACTION = 2;        ! HALT ACTION CODE
macro KA650$V_BIP = 0,2,1,0 %;          ! 1 = BOOT IN PROGRESS
macro KA650$V_RIP = 0,3,1,0 %;          ! 1 = RESTART IN PROGRESS
macro KA650$V_LANGUAGE = 0,4,4,0 %;
literal KA650$S_LANGUAGE = 4;           ! CONSOLE LANGUAGE CODE
macro KA650$V_RESERVED1 = 0,8,1,0 %;
macro KA650$V_CRT = 0,9,1,0 %;          ! 1 = Is CRT TERMINAL
macro KA650$V_MCS = 0,10,1,0 %;         ! 1 = TERMINAL SPEAKS MCS
macro KA650$V_RESERVED2 = 0,11,2,0 %;
literal KA650$S_RESERVED2 = 2;
macro KA650$V_VIDEO_DEV = 0,13,3,0 %;
literal KA650$S_VIDEO_DEV = 3;          ! VIDEO DEVICE CLASS
macro KA650$B_KEYBOARD = 2,0,8,1 %;     ! KEYBOARD CODE
!  Video device codes that may appear in NVR.VIDEO_DEV
literal KA650$K_TTY = 0;                !  0
literal KA650$K_QVSS = 1;               !  1
literal KA650$K_QDSS = 2;               !  2
!  Hault action codes that may appear in NVR.HALT_ACTION
literal KA650$K_RS_RB_HLT = 0;          !  0 RESTART, REBOOT, HALT
literal KA650$K_RS_HLT = 1;             !  1 RESTART, HALT
literal KA650$K_RB_HLT = 2;             !  2 REBOOT, HALT
literal KA650$K_HLT = 3;                !  3 HALT
 
!*** MODULE $KA640DEF ***
literal KA640$L_SCR = 0;                !  SYS CONFIG REG
literal KA640$L_DSER = 4;               !  MEM SYSTEM ERR REG
literal KA640$L_MEAR = 8;               !  MASTER ERROR ADDR REG
literal KA640$L_SEAR = 12;              !  SLAVE ERROR ADDR REG
literal KA640$L_QBMBR = 16;             !  Q BUS MAP BASE ADDR REG
literal KA640$L_MEM0 = 256;             !  MAIN MEMORY REG 0
literal KA640$L_MEM16 = 320;            !  MAIN MEMORY REG 16
literal KA640$L_MEM17 = 324;            !  MAIN MEMORY REG 17
literal KA640$L_SSCBR = 512;            !  SSC BASE ADDRS REG
literal KA640$L_SSCCR = 528;            !  SSC CONFIG REG
literal KA640$L_CBTCR = 544;            !  CDAL BUS TIMEOUT
literal KA640$L_DLEDR = 560;            !  DIAGNOSTIC LED REG
literal KA640$L_TCR0 = 768;             !  Timer 0 Control Reg
literal KA640$L_TIR0 = 772;             !  Timer 0 Interval Reg
literal KA640$L_TNIR0 = 776;            !  Timer 0 Next Interval Reg
literal KA640$L_TIVR0 = 780;            !  Timer 0 Interrupt Vector Reg
literal KA640$L_TCR1 = 784;             !  Timer 1 Control Reg
literal KA640$L_TIR1 = 788;             !  Timer 1 Interval Reg
literal KA640$L_TNIR1 = 792;            !  Timer 1 Next Interval Reg
literal KA640$L_TIVR1 = 796;            !  Timer 1 Interrupt Vector Reg
literal KA640$B_NVR = 1024;             !  PUBLIC NONVOLATILE
!  RAM AREA
literal KA640$B_NVRE = 2047;            !  END OF NVR
literal KA640$W_QVSS_CSR = 2176;        !  QVSS CSR
literal KA640$W_QDSS_CSR0 = 2304;       !  QDSS CSR0
literal KA640$W_QDSS_CSR2 = 2306;       !  QDSS CSR2
literal KA640$W_QDSS_CSR4 = 2308;       !  QDSS CSR4
literal KA640$W_QDSS_CSR6 = 2310;       !  QDSS CSR6
literal KA640$W_QDSS_CSR8 = 2312;       !  QDSS CSR8
literal KA640$W_QDSS_CSRA = 2314;       !  QDSS CSRA
literal KA640$W_QDSS_CSRC = 2316;       !  QDSS CSRC
literal KA640$W_QDSS_CSRE = 2318;       !  QDSS CSRE
literal KA640$W_INTPR0 = 2368;          ! INTERPROC COMM REG
literal KA640$W_INTPR1 = 2370;          !  ICR FOR AUXIL 1
literal KA640$W_INTPR2 = 2372;          !  ICR FOR AUXIL 2
literal KA640$W_INTPR3 = 2374;          !  ICR FOR AUXIL 3
literal KA640$S_KA640DEF = 3072;        !  Size mapped by
!  KA640DEF
!  System ID Extension Longword
literal KA640$S_SIDEX = 4;
macro KA640$B_SIDEX_NU = 0,0,8,0 %;     ! Number of users
macro KA640$B_SIDEX_SUBTYP = 1,0,8,0 %; ! SYSTEM SUBTYPE:
!  1 = MAYFAIR
!  2 = MAYFAIR II
macro KA640$B_SIDEX_ROMVER = 2,0,8,0 %; ! BOOT ROM VERSION
macro KA640$B_SIDEX_SYSCODE = 3,0,8,0 %; ! SYSTEM CODE. 1=MAYFAIR
!  System Configurataion Register
literal KA640$M_SCR_DOS = 14;
literal KA640$M_SCR_AUX = 1024;
literal KA640$M_SCR_BHE = 16384;
literal KA640$M_SCR_POK = 32768;
literal KA640$S_SCR = 4;
macro KA640$V_SCR_FILL1 = 0,0,1,0 %;    ! UNUSED
macro KA640$V_SCR_DOS = 0,1,3,0 %;
literal KA640$S_SCR_DOS = 3;            ! DOORBELL OFFSET
macro KA640$V_SCR_FILL2 = 0,4,6,0 %;
literal KA640$S_SCR_FILL2 = 6;          ! UNUSED
macro KA640$V_SCR_AUX = 0,10,1,0 %;     ! AUXILIARY OR ARBITER
! MODE
!  0 = ARBITER
!  1 = AUXILIARY	
macro KA640$V_SCR_FILL3 = 0,11,3,0 %;
literal KA640$S_SCR_FILL3 = 3;          ! UNUSED
macro KA640$V_SCR_BHE = 0,14,1,0 %;     ! BHALT ENABLE 
!  1 = HALT CPU
!  0 = NO EFFECT
macro KA640$V_SCR_POK = 0,15,1,0 %;     ! POWER OK
macro KA640$W_SCR_FILL3 = 2,0,16,0 %;   ! UNUSED
!   DMA System Error Register (DSER)
literal KA640$M_DSER_NXM = 1;
literal KA640$M_DSER_NG = 4;
literal KA640$M_DSER_LEB = 8;
literal KA640$M_DSER_MME = 16;
literal KA640$M_DSER_PE = 32;
literal KA640$M_DSER_QNXM = 128;
literal KA640$S_DSER = 4;
macro KA640$V_DSER_NXM = 0,0,1,0 %;     ! DMA TO NONEXISTENT MAIN MEMORY BIT IS SET
macro KA640$V_DSER_FILL1 = 0,1,1,0 %;   ! UNUSED	
macro KA640$V_DSER_NG = 0,2,1,0 %;      ! NO GRANT TIME OUT
macro KA640$V_DSER_LEB = 0,3,1,0 %;     ! LOST ERROR
macro KA640$V_DSER_MME = 0,4,1,0 %;     ! MAIN MEMORY ERROR
macro KA640$V_DSER_PE = 0,5,1,0 %;      ! BUS PARITY ERROR
macro KA640$V_DSER_FILL2 = 0,6,1,0 %;   ! UNUSED
macro KA640$V_DSER_QNXM = 0,7,1,0 %;    ! Q-BUS NON-EXIST MEMORY
macro KA640$V_DSER_FILL3 = 0,8,8,0 %;
literal KA640$S_DSER_FILL3 = 8;         ! UNUSED
macro KA640$W_DSER_FILL4 = 2,0,16,0 %;  ! UNUSED
!  Master Error Address Register (MEAR)
literal KA640$S_MEAR = 4;
macro KA640$W_MEAR_ADR = 0,0,16,0 %;    ! MASTER ERROR ADDRESS REG <12:0>
macro KA640$W_MEAR_FILL1 = 2,0,16,0 %;  ! UNUSED, RETURNS AS 0
!  Slave Error Address Register (SEAR)
literal KA640$S_SEAR = 4;
macro KA640$L_SEAR_ADR = 0,0,32,0 %;    ! SLAVE ERROR ADDRESS REGISTER
!   Main Memory Configuration Registers (MEMSCR0 - MEMSCR15)
literal KA640$M_MEMCR_BU = 3;
literal KA640$M_MEMCR_BS = 4;
literal KA640$M_MEMCR_SRR = 32;
literal KA640$M_MEMCR_BE = -2147483648;
literal KA640$S_MEMCR = 4;
macro KA640$V_MEMCR_BU = 0,0,2,0 %;
literal KA640$S_MEMCR_BU = 2;           ! BANK USAGE
! 00 = NO BANK IN USE
! 01 = NOT USED,ILLEGAL
! 10 = FIRST 2 BANKS IN USE
! 11 = ALL 4 BANKS IN USE
macro KA640$V_MEMCR_BS = 0,2,1,0 %;     ! BANK SIZE
macro KA640$V_MEMCR_BEM = 0,3,2,0 %;
literal KA640$S_MEMCR_BEM = 2;          ! BANK ERROR MODE
macro KA640$V_MEMCR_SRR = 0,5,1,0 %;    ! SIGNATURE READ REQUEST
macro KA640$V_MEMCR_FILL1 = 0,6,16,0 %;
literal KA640$S_MEMCR_FILL1 = 16;       ! UNUSED
macro KA640$V_MEMCR_BN = 0,22,4,0 %;
literal KA640$S_MEMCR_BN = 4;           ! BANK NUMBER
macro KA640$V_MEMCR_FILL2 = 0,26,5,0 %;
literal KA640$S_MEMCR_FILL2 = 5;        ! UNUSED
macro KA640$V_MEMCR_BE = 0,31,1,0 %;    ! BANK ENABLE
!   Main Memory Configuration Register 16 (MEMCSR16)
literal KA640$M_MEM16_SYND = 127;
literal KA640$M_MEM16_CDALERR = 128;
literal KA640$M_MEM16_DMAERR = 256;
literal KA640$M_MEM16_ADDR = 536870400;
literal KA640$M_MEM16_CRDERR = 536870912;
literal KA640$M_MEM16_RDSERRHI = 1073741824;
literal KA640$M_MEM16_RDSERR = -2147483648;
literal KA640$S_MEMCR16 = 4;
macro KA640$V_MEM16_SYND = 0,0,7,0 %;
literal KA640$S_MEM16_SYND = 7;         ! ERROR SYNDROME
macro KA640$V_MEM16_CDALERR = 0,7,1,0 %; ! CDAL BUS ERROR
macro KA640$V_MEM16_DMAERR = 0,8,1,0 %; ! DMA ERROR
macro KA640$V_MEM16_ADDR = 0,9,20,0 %;
literal KA640$S_MEM16_ADDR = 20;        ! PAGE ADDRESS OF ERROR
macro KA640$V_MEM16_CRDERR = 0,29,1,0 %; ! CRD ERROR
macro KA640$V_MEM16_RDSERRHI = 0,30,1,0 %; ! RDS HIGH ERROR RATE
macro KA640$V_MEM16_RDSERR = 0,31,1,0 %; ! RDS ERROR
!   Main Memory Configuration Register 17 (MEMCSR17)
literal KA640$M_MEM17_CHECK = 127;
literal KA640$M_MEM17_DIAGMODE = 128;
literal KA640$M_MEM17_BRDERR = 256;
literal KA640$M_MEM17_DIAGFAST = 512;
literal KA640$M_MEM17_ECCDSB = 1024;
literal KA640$M_MEM17_REFRESH = 2048;
literal KA640$M_MEM17_CRDENB = 4096;
literal KA640$M_MEM17_FASTMEM = 8192;
literal KA640$M_MEM17_DMAMODE = 16384;
literal KA640$S_MEMCR17 = 2;
macro KA640$V_MEM17_CHECK = 0,0,7,0 %;
literal KA640$S_MEM17_CHECK = 7;        ! CHECK BITS
macro KA640$V_MEM17_DIAGMODE = 0,7,1,0 %; ! DIAGNOSTIC CHECK MODE
macro KA640$V_MEM17_BRDERR = 0,8,1,0 %; ! BOARD ERROR
macro KA640$V_MEM17_DIAGFAST = 0,9,1,0 %; ! FAST DIAGNOSTIC TEST
macro KA640$V_MEM17_ECCDSB = 0,10,1,0 %; ! ECC DISABLE
macro KA640$V_MEM17_REFRESH = 0,11,1,0 %; ! FORCE REFRESH
macro KA640$V_MEM17_CRDENB = 0,12,1,0 %; ! CRD INTERRUPT ENABLE
macro KA640$V_MEM17_FASTMEM = 0,13,1,0 %; ! FAST MAIN MEM CYCLE
macro KA640$V_MEM17_DMAMODE = 0,14,1,0 %; ! DMA BUS MODE
!  Boot and Diagnostic Configuration Register (BDR)
literal KA640$M_BDR_CD = 3;
literal KA640$M_BRS_CD = 112;
literal KA640$M_HLT_ENB = 128;
literal KA640$S_BDR = 4;
macro KA640$V_BDR_CD = 0,0,2,0 %;
literal KA640$S_BDR_CD = 2;             ! BOOT DISPLAY BITS
macro KA640$V_CPUCD = 0,2,2,0 %;
literal KA640$S_CPUCD = 2;              ! CPU CODE
macro KA640$V_BRS_CD = 0,4,3,0 %;
literal KA640$S_BRS_CD = 3;             ! BAUD RATE SELECT
macro KA640$V_HLT_ENB = 0,7,1,0 %;      ! HAULT ENABLE
macro KA640$V_BDR_FILL1 = 0,8,24,0 %;
literal KA640$S_BDR_FILL1 = 24;         ! UNUSED
!  Diagnostic LED Register (DLEDR)
literal KA640$M_DLEDR_DSPL = 15;
literal KA640$S_DLEDR = 4;
macro KA640$V_DLEDR_DSPL = 0,0,4,0 %;
literal KA640$S_DLEDR_DSPL = 4;         ! DISPLAY <3:0>
macro KA640$V_DLEDR_FILL1 = 0,4,12,0 %;
literal KA640$S_DLEDR_FILL1 = 12;       ! UNUSED
macro KA640$W_DLEDR_FILL2 = 2,0,16,0 %; ! UNUSED
!   Interval Timer Control Regsiters (TCR0, TCR1)
literal KA640$M_TCR_RUN = 1;
literal KA640$M_TCR_STP = 4;
literal KA640$M_TCR_XFR = 16;
literal KA640$M_TCR_SGL = 32;
literal KA640$M_TCR_IE = 64;
literal KA640$M_TCR_INT = 128;
literal KA640$M_TCR_ERR = -2147483648;
literal KA640$S_TCR = 4;
macro KA640$V_TCR_RUN = 0,0,1,0 %;      ! INCREMENT TIR EVERY uSEC
macro KA640$V_TCR_FILL1 = 0,1,1,0 %;    ! UNUSED
macro KA640$V_TCR_STP = 0,2,1,0 %;      ! STOP ON OVERFLOW
macro KA640$V_TCR_FILL2 = 0,3,1,0 %;    ! UNUSED
macro KA640$V_TCR_XFR = 0,4,1,0 %;      ! COPY TNIR TO TIR
macro KA640$V_TCR_SGL = 0,5,1,0 %;      ! INCREMENT TIR (IF RUN = 0)
macro KA640$V_TCR_IE = 0,6,1,0 %;       ! INTERRUPT ENABLE
macro KA640$V_TCR_INT = 0,7,1,0 %;      ! OVERFLOW
macro KA640$V_TCR_FILL3 = 0,8,23,0 %;
literal KA640$S_TCR_FILL3 = 23;         ! UNUSED
macro KA640$V_TCR_ERR = 0,31,1,0 %;     ! ERROR (MISSED OVERFLOW)
!   Interval Timer Interrupt Vector Regsiters (TIVR0, TIVR1)
literal KA640$S_TIVR = 4;
macro KA640$V_TIVR_FILL1 = 0,0,2,0 %;
literal KA640$S_TIVR_FILL1 = 2;         ! UNUSED
macro KA640$V_TIVR_VEC = 0,2,8,0 %;
literal KA640$S_TIVR_VEC = 8;           ! INTERRUPT VECTOR
macro KA640$V_TIVR_FILL2 = 0,10,22,0 %;
literal KA640$S_TIVR_FILL2 = 22;        ! UNUSED
!  Public Nonvolatile RAM area
literal KA640$S_NVR = 3;
macro KA640$V_HALT_ACTION = 0,0,2,0 %;
literal KA640$S_HALT_ACTION = 2;        ! HALT ACTION CODE
macro KA640$V_BIP = 0,2,1,0 %;          ! 1 = BOOT IN PROGRESS
macro KA640$V_RIP = 0,3,1,0 %;          ! 1 = RESTART IN PROGRESS
macro KA640$V_LANGUAGE = 0,4,4,0 %;
literal KA640$S_LANGUAGE = 4;           ! CONSOLE LANGUAGE CODE
macro KA640$V_RESERVED1 = 0,8,1,0 %;
macro KA640$V_CRT = 0,9,1,0 %;          ! 1 = Is CRT TERMINAL
macro KA640$V_MCS = 0,10,1,0 %;         ! 1 = TERMINAL SPEAKS MCS
macro KA640$V_RESERVED2 = 0,11,2,0 %;
literal KA640$S_RESERVED2 = 2;
macro KA640$V_VIDEO_DEV = 0,13,3,0 %;
literal KA640$S_VIDEO_DEV = 3;          ! VIDEO DEVICE CLASS
macro KA640$B_KEYBOARD = 2,0,8,1 %;     ! KEYBOARD CODE
!  Video device codes that may appear in NVR.VIDEO_DEV
literal KA640$K_TTY = 0;                !  0
literal KA640$K_QVSS = 1;               !  1
literal KA640$K_QDSS = 2;               !  2
!  Hault action codes that may appear in NVR.HALT_ACTION
literal KA640$K_RS_RB_HLT = 0;          !  0 RESTART, REBOOT, HALT
literal KA640$K_RS_HLT = 1;             !  1 RESTART, HALT
literal KA640$K_RB_HLT = 2;             !  2 REBOOT, HALT
literal KA640$K_HLT = 3;                !  3 HALT
 
!*** MODULE $KA660DEF ***
literal KA660$W_QDSS = 256;
literal KA660$W_IPCR0 = 320;
literal KA660$W_IPCR1 = 322;
literal KA660$W_IPCR2 = 324;
literal KA660$W_IPCR3 = 326;
literal KA660$L_SCR = 512;
literal KA660$L_DSER = 516;
literal KA660$L_QBEAR = 520;
literal KA660$L_DEAR = 524;
literal KA660$L_QBMBR = 528;
literal KA660$L_MEMCON = 768;
literal KA660$L_MMESR = 832;
literal KA660$L_MMCDSR = 836;
literal KA660$L_BDR = 1024;
literal KA660$L_QMAP = 1536;
literal KA660$L_SSCBR = 34304;
literal KA660$L_SSCCR = 34320;
literal KA660$L_CBTCR = 34336;
literal KA660$L_DLEDR = 34352;
literal KA660$L_TCR0 = 34560;
literal KA660$L_TIR0 = 34564;
literal KA660$L_TNIR0 = 34568;
literal KA660$L_TIVR0 = 34572;
literal KA660$L_TCR1 = 34576;
literal KA660$L_TIR1 = 34580;
literal KA660$L_TNIR1 = 34584;
literal KA660$L_TIVR1 = 34588;
literal KA660$B_NVR = 34816;
literal KA660$L_TAG = 35840;
literal KA660$L_DATA = 36864;
literal KA660$L_BEHR = 37888;
literal KA660$B_ROM = 38400;
literal KA660$L_SSHMA = 38440;
literal KA660$S_KA660DEF = 300544;
literal KA660$_SHAC_PMCSR = 92;
literal KA660$_SHAC_M_MIN = 1;
literal KA660$_SGEC_MODE = 24;
literal KA660$_SGEC_M_RESET = -2147483648;
literal KA660$M_IPCR_DBI_RQ = 1;
literal KA660$M_IPCR_LM_EAE = 32;
literal KA660$M_IPCR_DBI_IE = 64;
literal KA660$M_IPCR_AUX_HLT = 256;
literal KA660$M_IPCR_QMCIA = 16384;
literal KA660$M_IPCR_DMA_QME = 32768;
literal KA660$S_KA660_IPCR = 2;
macro KA660$V_IPCR_DBI_RQ = 0,0,1,0 %;
macro KA660$V_IPCR_LM_EAE = 0,5,1,0 %;
macro KA660$V_IPCR_DBI_IE = 0,6,1,0 %;
macro KA660$V_IPCR_AUX_HLT = 0,8,1,0 %;
macro KA660$V_IPCR_QMCIA = 0,14,1,0 %;
macro KA660$V_IPCR_DMA_QME = 0,15,1,0 %;
literal KA660$S_KA660_SIDEX = 4;
macro KA660$B_SIDEX_NUM_USER = 0,0,8,0 %;
macro KA660$B_SIDEX_SUB_TYPE = 1,0,8,0 %;
macro KA660$B_SIDEX_ROM_VERS = 2,0,8,0 %;
macro KA660$B_SIDEX_SYS_CODE = 3,0,8,0 %;
literal KA660$M_SCR_DOS = 14;
literal KA660$M_SCR_DCOK_HLT = 128;
literal KA660$M_SCR_AUX = 1024;
literal KA660$M_SCR_PPD = 4096;
literal KA660$M_SCR_BHE = 16384;
literal KA660$M_SCR_POK = 32768;
literal KA660$S_KA660_SCR = 4;
macro KA660$V_SCR_DOS = 0,1,3,0 %;
literal KA660$S_SCR_DOS = 3;
macro KA660$V_SCR_DCOK_HLT = 0,7,1,0 %;
macro KA660$V_SCR_AUX = 0,10,1,0 %;
macro KA660$V_SCR_PPD = 0,12,1,0 %;
macro KA660$V_SCR_BHE = 0,14,1,0 %;
macro KA660$V_SCR_POK = 0,15,1,0 %;
literal KA660$M_DSER_NXM = 1;
literal KA660$M_DSER_NG = 4;
literal KA660$M_DSER_LE = 8;
literal KA660$M_DSER_MME = 16;
literal KA660$M_DSER_PE = 32;
literal KA660$M_DSER_QNXM = 128;
literal KA660$M_DSER_DCOK = 16384;
literal KA660$M_DSER_BHALT = 32768;
literal KA660$S_KA660_DSER = 4;
macro KA660$V_DSER_NXM = 0,0,1,0 %;
macro KA660$V_DSER_NG = 0,2,1,0 %;
macro KA660$V_DSER_LE = 0,3,1,0 %;
macro KA660$V_DSER_MME = 0,4,1,0 %;
macro KA660$V_DSER_PE = 0,5,1,0 %;
macro KA660$V_DSER_QNXM = 0,7,1,0 %;
macro KA660$V_DSER_DCOK = 0,14,1,0 %;
macro KA660$V_DSER_BHALT = 0,15,1,0 %;
literal KA660$M_QBEAR_ADDR = 8191;
literal KA660$S_KA660_QBEAR = 4;
macro KA660$V_QBEAR_ADDR = 0,0,13,0 %;
literal KA660$S_QBEAR_ADDR = 13;
literal KA660$M_DEAR_ADDR = 8191;
literal KA660$S_KA660_DEAR = 4;
macro KA660$V_DEAR_ADDR = 0,0,13,0 %;
literal KA660$S_DEAR_ADDR = 13;
literal KA660$K_MEMCON_BU_0 = 0;
literal KA660$K_MEMCON_BU_ILL = 1;
literal KA660$K_MEMCON_BU_2 = 2;
literal KA660$K_MEMCON_BU_4 = 3;
literal KA660$M_MEMCON_BU = 3;
literal KA660$M_MEMCON_BS = 4;
literal KA660$M_MEMCON_BEM = 24;
literal KA660$M_MEMCON_SRR = 32;
literal KA660$M_MEMCON_LOCK = 64;
literal KA660$M_MEMCON_BN = 62914560;
literal KA660$M_MEMCON_BE = -2147483648;
literal KA660$S_KA660_MEMCON = 4;
macro KA660$V_MEMCON_BU = 0,0,2,0 %;
literal KA660$S_MEMCON_BU = 2;
macro KA660$V_MEMCON_BS = 0,2,1,0 %;
macro KA660$V_MEMCON_BEM = 0,3,2,0 %;
literal KA660$S_MEMCON_BEM = 2;
macro KA660$V_MEMCON_SRR = 0,5,1,0 %;
macro KA660$V_MEMCON_LOCK = 0,6,1,0 %;
macro KA660$V_MEMCON_BN = 0,22,4,0 %;
literal KA660$S_MEMCON_BN = 4;
macro KA660$V_MEMCON_BE = 0,31,1,0 %;
literal KA660$M_MMESR_SYND = 127;
literal KA660$M_MMESR_BUSERR = 128;
literal KA660$M_MMESR_DMAERR = 256;
literal KA660$M_MMESR_ADDR = 536870400;
literal KA660$M_MMESR_CRDERR = 536870912;
literal KA660$M_MMESR_RDSHER = 1073741824;
literal KA660$M_MMESR_RDSERR = -2147483648;
literal KA660$S_KA660_MMESR = 4;
macro KA660$V_MMESR_SYND = 0,0,7,0 %;
literal KA660$S_MMESR_SYND = 7;
macro KA660$V_MMESR_BUSERR = 0,7,1,0 %;
macro KA660$V_MMESR_DMAERR = 0,8,1,0 %;
macro KA660$V_MMESR_ADDR = 0,9,20,0 %;
literal KA660$S_MMESR_ADDR = 20;
macro KA660$V_MMESR_CRDERR = 0,29,1,0 %;
macro KA660$V_MMESR_RDSHER = 0,30,1,0 %;
macro KA660$V_MMESR_RDSERR = 0,31,1,0 %;
literal KA660$M_MMCDSR_CHECK = 127;
literal KA660$M_MMCDSR_DCM = 128;
literal KA660$M_MMCDSR_CL = 256;
literal KA660$M_MMCDSR_FDM = 512;
literal KA660$M_MMCDSR_MEDD = 1024;
literal KA660$M_MMCDSR_FRR = 2048;
literal KA660$M_MMCDSR_CRD_IE = 4096;
literal KA660$M_MMCDSR_MMCS = 8192;
literal KA660$M_MMCDSR_EL = 16384;
literal KA660$S_KA660_MMCDSR = 4;
macro KA660$V_MMCDSR_CHECK = 0,0,7,0 %;
literal KA660$S_MMCDSR_CHECK = 7;
macro KA660$V_MMCDSR_DCM = 0,7,1,0 %;
macro KA660$V_MMCDSR_CL = 0,8,1,0 %;
macro KA660$V_MMCDSR_FDM = 0,9,1,0 %;
macro KA660$V_MMCDSR_MEDD = 0,10,1,0 %;
macro KA660$V_MMCDSR_FRR = 0,11,1,0 %;
macro KA660$V_MMCDSR_CRD_IE = 0,12,1,0 %;
macro KA660$V_MMCDSR_MMCS = 0,13,1,0 %;
macro KA660$V_MMCDSR_EL = 0,14,1,0 %;
literal KA660$M_BDR_ETHER_BOOT = 4096;
literal KA660$M_BDR_DSSI = 57344;
literal KA660$M_BDR_BDG_CD = 196608;
literal KA660$M_BDR_CPU = 786432;
literal KA660$M_BDR_BRS_CD = 7340032;
literal KA660$M_BDR_HLT_ENB = 8388608;
literal KA660$M_BDR_SA_ROM = -16777216;
literal KA660$S_KA660_BDR = 4;
macro KA660$V_BDR_ETHER_BOOT = 0,12,1,0 %;
macro KA660$V_BDR_DSSI = 0,13,3,0 %;
literal KA660$S_BDR_DSSI = 3;
macro KA660$V_BDR_BDG_CD = 0,16,2,0 %;
literal KA660$S_BDR_BDG_CD = 2;
macro KA660$V_BDR_CPU = 0,18,2,0 %;
literal KA660$S_BDR_CPU = 2;
macro KA660$V_BDR_BRS_CD = 0,20,3,0 %;
literal KA660$S_BDR_BRS_CD = 3;
macro KA660$V_BDR_HLT_ENB = 0,23,1,0 %;
macro KA660$V_BDR_SA_ROM = 0,24,8,0 %;
literal KA660$S_BDR_SA_ROM = 8;
literal KA660$M_DLEDR_DSPL = 15;
literal KA660$S_KA660_DLEDR = 4;
macro KA660$V_DLEDR_DSPL = 0,0,4,0 %;
literal KA660$S_DLEDR_DSPL = 4;
literal KA660$M_TCR_RUN = 1;
literal KA660$M_TCR_STP = 4;
literal KA660$M_TCR_XFR = 16;
literal KA660$M_TCR_SGL = 32;
literal KA660$M_TCR_IE = 64;
literal KA660$M_TCR_INT = 128;
literal KA660$M_TCR_ERR = -2147483648;
literal KA660$S_KA660_TCR = 4;
macro KA660$V_TCR_RUN = 0,0,1,0 %;
macro KA660$V_TCR_STP = 0,2,1,0 %;
macro KA660$V_TCR_XFR = 0,4,1,0 %;
macro KA660$V_TCR_SGL = 0,5,1,0 %;
macro KA660$V_TCR_IE = 0,6,1,0 %;
macro KA660$V_TCR_INT = 0,7,1,0 %;
macro KA660$V_TCR_ERR = 0,31,1,0 %;
literal KA660$M_TIVR_VEC = 1020;
literal KA660$S_KA660_TIVR = 4;
macro KA660$V_TIVR_VEC = 0,2,8,0 %;
literal KA660$S_TIVR_VEC = 8;
literal KA660$K_RS_RB_HLT = 0;
literal KA660$K_RS_HLT = 1;
literal KA660$K_RB_HLT = 2;
literal KA660$K_HLT = 3;
literal KA660$M_HALT_ACTION = 3;
literal KA660$M_BIP = 4;
literal KA660$M_RIP = 8;
literal KA660$M_LANGUAGE = 240;
literal KA660$M_INSERT = 256;
literal KA660$M_CRT = 512;
literal KA660$M_MCS = 1024;
literal KA660$M_DIP = 2048;
literal KA660$M_MOP_ENB = 4096;
literal KA660$K_TTY = 0;
literal KA660$K_QVSS = 1;
literal KA660$K_QDSS = 2;
literal KA660$M_VIDEO_DEV = 57344;
literal KA660$S_KA660_NVR = 2;
macro KA660$V_HALT_ACTION = 0,0,2,0 %;
literal KA660$S_HALT_ACTION = 2;
macro KA660$V_BIP = 0,2,1,0 %;
macro KA660$V_RIP = 0,3,1,0 %;
macro KA660$V_LANGUAGE = 0,4,4,0 %;
literal KA660$S_LANGUAGE = 4;
macro KA660$V_INSERT = 0,8,1,0 %;
macro KA660$V_CRT = 0,9,1,0 %;
macro KA660$V_MCS = 0,10,1,0 %;
macro KA660$V_DIP = 0,11,1,0 %;
macro KA660$V_MOP_ENB = 0,12,1,0 %;
macro KA660$V_VIDEO_DEV = 0,13,3,0 %;
literal KA660$S_VIDEO_DEV = 3;
literal KA660$M_TAG_DP = 15;
literal KA660$M_TAG_TAG = 536869888;
literal KA660$M_TAG_VALID = 1073741824;
literal KA660$M_TAG_PARITY = -2147483648;
literal KA660$S_KA660_TAG = 4;
macro KA660$V_TAG_DP = 0,0,4,0 %;
literal KA660$S_TAG_DP = 4;
macro KA660$V_TAG_TAG = 0,10,19,0 %;
literal KA660$S_TAG_TAG = 19;
macro KA660$V_TAG_VALID = 0,30,1,0 %;
macro KA660$V_TAG_PARITY = 0,31,1,0 %;
literal KA660$M_BEHR_ENABLE = 255;
literal KA660$M_BEHR_HIT = 65280;
literal KA660$S_KA660_BEHR = 4;
macro KA660$V_BEHR_ENABLE = 0,0,8,0 %;
literal KA660$S_BEHR_ENABLE = 8;
macro KA660$V_BEHR_HIT = 0,8,8,0 %;
literal KA660$S_BEHR_HIT = 8;
 
!*** MODULE $KA670DEF ***
literal KA670$W_QDSS = 256;
literal KA670$W_IPCR0 = 320;
literal KA670$W_IPCR1 = 322;
literal KA670$W_IPCR2 = 324;
literal KA670$W_IPCR3 = 326;
literal KA670$L_SCR = 512;
literal KA670$L_DSER = 516;
literal KA670$L_QBEAR = 520;
literal KA670$L_DEAR = 524;
literal KA670$L_QBMBR = 528;
literal KA670$L_MEMCON = 768;
literal KA670$L_MEMSIG = 832;
literal KA670$L_RMESR = 896;
literal KA670$L_RMEAR = 900;
literal KA670$L_RIOEAR = 904;
literal KA670$L_CEAR = 908;
literal KA670$L_MCDSR = 912;
literal KA670$L_BDR = 1024;
literal KA670$L_QMAP = 1536;
literal KA670$L_SSCBR = 34304;
literal KA670$L_SSCCR = 34320;
literal KA670$L_CBTCR = 34336;
literal KA670$L_DLEDR = 34352;
literal KA670$L_TCR0 = 34560;
literal KA670$L_TIR0 = 34564;
literal KA670$L_TNIR0 = 34568;
literal KA670$L_TIVR0 = 34572;
literal KA670$L_TCR1 = 34576;
literal KA670$L_TIR1 = 34580;
literal KA670$L_TNIR1 = 34584;
literal KA670$L_TIVR1 = 34588;
literal KA670$B_NVR = 34816;
literal KA670$B_ROM = 35840;
literal KA670$L_SSHMA = 35880;
literal KA670$S_KA670DEF = 297984;
literal KA670$_SHAC_PMCSR = 92;
literal KA670$_SHAC_M_MIN = 1;
literal KA670$_SGEC_MODE = 24;
literal KA670$_SGEC_M_RESET = -2147483648;
literal KA670$M_IPCR_DBI_RQ = 1;
literal KA670$M_IPCR_LM_EAE = 32;
literal KA670$M_IPCR_DBI_IE = 64;
literal KA670$M_IPCR_AUX_HLT = 256;
literal KA670$M_IPCR_QMCIA = 16384;
literal KA670$M_IPCR_DMA_QME = 32768;
literal KA670$S_KA670_IPCR = 2;
macro KA670$V_IPCR_DBI_RQ = 0,0,1,0 %;
macro KA670$V_IPCR_LM_EAE = 0,5,1,0 %;
macro KA670$V_IPCR_DBI_IE = 0,6,1,0 %;
macro KA670$V_IPCR_AUX_HLT = 0,8,1,0 %;
macro KA670$V_IPCR_QMCIA = 0,14,1,0 %;
macro KA670$V_IPCR_DMA_QME = 0,15,1,0 %;
literal KA670$S_KA670_SIDEX = 4;
macro KA670$B_SIDEX_NUM_USER = 0,0,8,0 %;
macro KA670$B_SIDEX_SUB_TYPE = 1,0,8,0 %;
macro KA670$B_SIDEX_ROM_VERS = 2,0,8,0 %;
macro KA670$B_SIDEX_SYS_CODE = 3,0,8,0 %;
literal KA670$M_SCR_DOS = 14;
literal KA670$M_SCR_DCOK_HLT = 128;
literal KA670$M_SCR_AUX = 1024;
literal KA670$M_SCR_PPD = 4096;
literal KA670$M_SCR_BHE = 16384;
literal KA670$M_SCR_POK = 32768;
literal KA670$S_KA670_SCR = 4;
macro KA670$V_SCR_DOS = 0,1,3,0 %;
literal KA670$S_SCR_DOS = 3;
macro KA670$V_SCR_DCOK_HLT = 0,7,1,0 %;
macro KA670$V_SCR_AUX = 0,10,1,0 %;
macro KA670$V_SCR_PPD = 0,12,1,0 %;
macro KA670$V_SCR_BHE = 0,14,1,0 %;
macro KA670$V_SCR_POK = 0,15,1,0 %;
literal KA670$M_DSER_NXM = 1;
literal KA670$M_DSER_NG = 4;
literal KA670$M_DSER_LE = 8;
literal KA670$M_DSER_MME = 16;
literal KA670$M_DSER_PE = 32;
literal KA670$M_DSER_QNXM = 128;
literal KA670$M_DSER_DCOK = 16384;
literal KA670$M_DSER_BHALT = 32768;
literal KA670$S_KA670_DSER = 4;
macro KA670$V_DSER_NXM = 0,0,1,0 %;
macro KA670$V_DSER_NG = 0,2,1,0 %;
macro KA670$V_DSER_LE = 0,3,1,0 %;
macro KA670$V_DSER_MME = 0,4,1,0 %;
macro KA670$V_DSER_PE = 0,5,1,0 %;
macro KA670$V_DSER_QNXM = 0,7,1,0 %;
macro KA670$V_DSER_DCOK = 0,14,1,0 %;
macro KA670$V_DSER_BHALT = 0,15,1,0 %;
literal KA670$M_QBEAR_ADDR = 8191;
literal KA670$S_KA670_QBEAR = 4;
macro KA670$V_QBEAR_ADDR = 0,0,13,0 %;
literal KA670$S_QBEAR_ADDR = 13;
literal KA670$M_DEAR_ADDR = 8191;
literal KA670$S_KA670_DEAR = 4;
macro KA670$V_DEAR_ADDR = 0,0,13,0 %;
literal KA670$S_DEAR_ADDR = 13;
literal KA670$K_MEMCON_1MB = 1;
literal KA670$K_MEMCON_4MB = 2;
literal KA670$M_MEMCON_SIG = 6;
literal KA670$M_MEMCON_BASE = 528482304;
literal KA670$M_MEMCON_VALID = -2147483648;
literal KA670$S_KA670_MEMCON = 4;
macro KA670$V_MEMCON_SIG = 0,1,2,0 %;
literal KA670$S_MEMCON_SIG = 2;
macro KA670$V_MEMCON_BASE = 0,23,6,0 %;
literal KA670$S_MEMCON_BASE = 6;
macro KA670$V_MEMCON_VALID = 0,31,1,0 %;
literal KA670$M_RMESR_RSYND = 127;
literal KA670$M_RMESR_RLSME = 128;
literal KA670$M_RMESR_RLHME = 256;
literal KA670$M_RMESR_RSME = 512;
literal KA670$M_RMESR_RHME = 1024;
literal KA670$M_RMESR_RBPE = 2048;
literal KA670$M_RMESR_RNXM = 4096;
literal KA670$M_RMESR_RLIOE = 8192;
literal KA670$M_RMESR_RIOE = 16384;
literal KA670$M_RMESR_RNXIO = 32768;
literal KA670$M_RMESR_CSYND = 8323072;
literal KA670$M_RMESR_CLSME = 8388608;
literal KA670$M_RMESR_CLHME = 16777216;
literal KA670$M_RMESR_CSME = 33554432;
literal KA670$M_RMESR_CHME = 67108864;
literal KA670$M_RMESR_CBPE = 134217728;
literal KA670$M_RMESR_ERROR = -2147483648;
literal KA670$S_KA670_RMESR = 4;
macro KA670$V_RMESR_RSYND = 0,0,7,0 %;
literal KA670$S_RMESR_RSYND = 7;
macro KA670$V_RMESR_RLSME = 0,7,1,0 %;
macro KA670$V_RMESR_RLHME = 0,8,1,0 %;
macro KA670$V_RMESR_RSME = 0,9,1,0 %;
macro KA670$V_RMESR_RHME = 0,10,1,0 %;
macro KA670$V_RMESR_RBPE = 0,11,1,0 %;
macro KA670$V_RMESR_RNXM = 0,12,1,0 %;
macro KA670$V_RMESR_RLIOE = 0,13,1,0 %;
macro KA670$V_RMESR_RIOE = 0,14,1,0 %;
macro KA670$V_RMESR_RNXIO = 0,15,1,0 %;
macro KA670$V_RMESR_CSYND = 0,16,7,0 %;
literal KA670$S_RMESR_CSYND = 7;
macro KA670$V_RMESR_CLSME = 0,23,1,0 %;
macro KA670$V_RMESR_CLHME = 0,24,1,0 %;
macro KA670$V_RMESR_CSME = 0,25,1,0 %;
macro KA670$V_RMESR_CHME = 0,26,1,0 %;
macro KA670$V_RMESR_CBPE = 0,27,1,0 %;
macro KA670$V_RMESR_ERROR = 0,31,1,0 %;
literal KA670$M_MCDSR_FRR = 1;
literal KA670$M_MCDSR_DR = 2;
literal KA670$M_MCDSR_FCO = 4;
literal KA670$M_MCDSR_FWP = 8;
literal KA670$M_MCDSR_FWBH = 16;
literal KA670$M_MCDSR_FWB = 32;
literal KA670$M_MCDSR_DPM = 64;
literal KA670$M_MCDSR_DMED = 128;
literal KA670$M_MCDSR_RR = 256;
literal KA670$K_MCDSR_42US = 0;
literal KA670$K_MCDSR_32US = 1;
literal KA670$K_MCDSR_12US = 2;
literal KA670$K_MCDSR_2US = 3;
literal KA670$M_MCDSR_EPR_TP = 1536;
literal KA670$M_MCDSR_ESEL = 2048;
literal KA670$M_MCDSR_TCS = 4096;
literal KA670$M_MCDSR_CRS = 8192;
literal KA670$M_MCDSR_FSP = 16384;
literal KA670$M_MCDSR_FDTM = 32768;
literal KA670$M_MCDSR_MDCB = 8323072;
literal KA670$M_MCDSR_MCB = 1065353216;
literal KA670$M_MCDSR_DCBM = -2147483648;
literal KA670$S_KA670_MCDSR = 4;
macro KA670$V_MCDSR_FRR = 0,0,1,0 %;
macro KA670$V_MCDSR_DR = 0,1,1,0 %;
macro KA670$V_MCDSR_FCO = 0,2,1,0 %;
macro KA670$V_MCDSR_FWP = 0,3,1,0 %;
macro KA670$V_MCDSR_FWBH = 0,4,1,0 %;
macro KA670$V_MCDSR_FWB = 0,5,1,0 %;
macro KA670$V_MCDSR_DPM = 0,6,1,0 %;
macro KA670$V_MCDSR_DMED = 0,7,1,0 %;
macro KA670$V_MCDSR_RR = 0,8,1,0 %;
macro KA670$V_MCDSR_EPR_TP = 0,9,2,0 %;
literal KA670$S_MCDSR_EPR_TP = 2;
macro KA670$V_MCDSR_ESEL = 0,11,1,0 %;
macro KA670$V_MCDSR_TCS = 0,12,1,0 %;
macro KA670$V_MCDSR_CRS = 0,13,1,0 %;
macro KA670$V_MCDSR_FSP = 0,14,1,0 %;
macro KA670$V_MCDSR_FDTM = 0,15,1,0 %;
macro KA670$V_MCDSR_MDCB = 0,16,7,0 %;
literal KA670$S_MCDSR_MDCB = 7;
macro KA670$V_MCDSR_MCB = 0,23,7,0 %;
literal KA670$S_MCDSR_MCB = 7;
macro KA670$V_MCDSR_DCBM = 0,31,1,0 %;
literal KA670$M_BDR_BDG_CD = 3;
literal KA670$M_BDR_BRS_CD = 112;
literal KA670$M_BDR_HLT_ENB = 128;
literal KA670$M_BDR_SA_ROM = 65280;
literal KA670$M_BDR_DSSI2 = 458752;
literal KA670$M_BDR_FILL2 = 16252928;
literal KA670$M_BDR_DSSI1 = 117440512;
literal KA670$M_BDR_FILL3 = 939524096;
literal KA670$M_BDR_CBL_OK = 1073741824;
literal KA670$M_BDR_ETHER_BOOT = -2147483648;
literal KA670$S_KA670_BDR = 4;
macro KA670$V_BDR_BDG_CD = 0,0,2,0 %;
literal KA670$S_BDR_BDG_CD = 2;
macro KA670$V_BDR_BRS_CD = 0,4,3,0 %;
literal KA670$S_BDR_BRS_CD = 3;
macro KA670$V_BDR_HLT_ENB = 0,7,1,0 %;
macro KA670$V_BDR_SA_ROM = 0,8,8,0 %;
literal KA670$S_BDR_SA_ROM = 8;
macro KA670$V_BDR_DSSI2 = 0,16,3,0 %;
literal KA670$S_BDR_DSSI2 = 3;
macro KA670$V_BDR_FILL2 = 0,19,5,0 %;
literal KA670$S_BDR_FILL2 = 5;
macro KA670$V_BDR_DSSI1 = 0,24,3,0 %;
literal KA670$S_BDR_DSSI1 = 3;
macro KA670$V_BDR_FILL3 = 0,27,3,0 %;
literal KA670$S_BDR_FILL3 = 3;
macro KA670$V_BDR_CBL_OK = 0,30,1,0 %;
macro KA670$V_BDR_ETHER_BOOT = 0,31,1,0 %;
literal KA670$M_DLEDR_DSPL = 15;
literal KA670$S_KA670_DLEDR = 4;
macro KA670$V_DLEDR_DSPL = 0,0,4,0 %;
literal KA670$S_DLEDR_DSPL = 4;
literal KA670$M_TCR_RUN = 1;
literal KA670$M_TCR_STP = 4;
literal KA670$M_TCR_XFR = 16;
literal KA670$M_TCR_SGL = 32;
literal KA670$M_TCR_IE = 64;
literal KA670$M_TCR_INT = 128;
literal KA670$M_TCR_ERR = -2147483648;
literal KA670$S_KA670_TCR = 4;
macro KA670$V_TCR_RUN = 0,0,1,0 %;
macro KA670$V_TCR_STP = 0,2,1,0 %;
macro KA670$V_TCR_XFR = 0,4,1,0 %;
macro KA670$V_TCR_SGL = 0,5,1,0 %;
macro KA670$V_TCR_IE = 0,6,1,0 %;
macro KA670$V_TCR_INT = 0,7,1,0 %;
macro KA670$V_TCR_ERR = 0,31,1,0 %;
literal KA670$M_TIVR_VEC = 1020;
literal KA670$S_KA670_TIVR = 4;
macro KA670$V_TIVR_VEC = 0,2,8,0 %;
literal KA670$S_TIVR_VEC = 8;
literal KA670$K_RS_RB_HLT = 0;
literal KA670$K_RS_HLT = 1;
literal KA670$K_RB_HLT = 2;
literal KA670$K_HLT = 3;
literal KA670$M_HALT_ACTION = 3;
literal KA670$M_BIP = 4;
literal KA670$M_RIP = 8;
literal KA670$M_LANGUAGE = 240;
literal KA670$M_INSERT = 256;
literal KA670$M_CRT = 512;
literal KA670$M_MCS = 1024;
literal KA670$M_DIP = 2048;
literal KA670$M_MOP_ENB = 4096;
literal KA670$K_TTY = 0;
literal KA670$K_QVSS = 1;
literal KA670$K_QDSS = 2;
literal KA670$M_VIDEO_DEV = 57344;
literal KA670$S_KA670_NVR = 2;
macro KA670$V_HALT_ACTION = 0,0,2,0 %;
literal KA670$S_HALT_ACTION = 2;
macro KA670$V_BIP = 0,2,1,0 %;
macro KA670$V_RIP = 0,3,1,0 %;
macro KA670$V_LANGUAGE = 0,4,4,0 %;
literal KA670$S_LANGUAGE = 4;
macro KA670$V_INSERT = 0,8,1,0 %;
macro KA670$V_CRT = 0,9,1,0 %;
macro KA670$V_MCS = 0,10,1,0 %;
macro KA670$V_DIP = 0,11,1,0 %;
macro KA670$V_MOP_ENB = 0,12,1,0 %;
macro KA670$V_VIDEO_DEV = 0,13,3,0 %;
literal KA670$S_VIDEO_DEV = 3;
 
!*** MODULE $KA690DEF ***
literal KA690$W_QDSS = 256;
literal KA690$W_IPCR0 = 320;
literal KA690$W_IPCR1 = 322;
literal KA690$W_IPCR2 = 324;
literal KA690$W_IPCR3 = 326;
literal KA690$L_SCR = 512;
literal KA690$L_DSER = 516;
literal KA690$L_QBEAR = 520;
literal KA690$L_DEAR = 524;
literal KA690$L_QBMBR = 528;
literal KA690$L_BDR = 1024;
literal KA690$L_QMAP = 1536;
literal KA690$L_SSCBR = 34304;
literal KA690$L_SSCCR = 34320;
literal KA690$L_CBTCR = 34336;
literal KA690$L_DLEDR = 34352;
literal KA690$L_TCR0 = 34560;
literal KA690$L_TIR0 = 34564;
literal KA690$L_TNIR0 = 34568;
literal KA690$L_TIVR0 = 34572;
literal KA690$L_TCR1 = 34576;
literal KA690$L_TIR1 = 34580;
literal KA690$L_TNIR1 = 34584;
literal KA690$L_TIVR1 = 34588;
literal KA690$B_NVR = 34816;
literal KA690$L_MODR = 35840;
literal KA690$L_MEMCON = 68608;
literal KA690$L_MEMSIG = 68640;
literal KA690$L_MEAR = 68672;
literal KA690$L_MESR = 68676;
literal KA690$L_MMCDSR = 68680;
literal KA690$L_MOAMR = 68684;
literal KA690$L_CESR = 69120;
literal KA690$L_CMCDSR = 69124;
literal KA690$L_CSEAR1 = 69128;
literal KA690$L_CSEAR2 = 69132;
literal KA690$L_CIOEAR1 = 69136;
literal KA690$L_CIOEAR2 = 69140;
literal KA690$L_CNEAR = 69144;
literal KA690$B_ROM = 69632;
literal KA690$L_SSHMA = 69672;
literal KA690$S_KA690DEF = 331776;
literal KA690$_SHAC_PMCSR = 92;
literal KA690$_SHAC_M_MIN = 1;
literal KA690$_SGEC_MODE = 24;
literal KA690$_SGEC_M_RESET = -2147483648;
literal KA690$M_IPCR_DBI_RQ = 1;
literal KA690$M_IPCR_LM_EAE = 32;
literal KA690$M_IPCR_DBI_IE = 64;
literal KA690$M_IPCR_AUX_HLT = 256;
literal KA690$M_IPCR_QMCIA = 16384;
literal KA690$M_IPCR_DMA_QME = 32768;
literal KA690$S_KA690_IPCR = 2;
macro KA690$V_IPCR_DBI_RQ = 0,0,1,0 %;
macro KA690$V_IPCR_LM_EAE = 0,5,1,0 %;
macro KA690$V_IPCR_DBI_IE = 0,6,1,0 %;
macro KA690$V_IPCR_AUX_HLT = 0,8,1,0 %;
macro KA690$V_IPCR_QMCIA = 0,14,1,0 %;
macro KA690$V_IPCR_DMA_QME = 0,15,1,0 %;
literal KA690$S_KA690_SIDEX = 4;
macro KA690$B_SIDEX_NUM_USER = 0,0,8,0 %;
macro KA690$B_SIDEX_SUB_TYPE = 1,0,8,0 %;
macro KA690$B_SIDEX_ROM_VERS = 2,0,8,0 %;
macro KA690$B_SIDEX_SYS_CODE = 3,0,8,0 %;
literal KA690$M_SCR_DOS = 14;
literal KA690$M_SCR_DCOK_HLT = 128;
literal KA690$M_SCR_AUX = 1024;
literal KA690$M_SCR_PPD = 4096;
literal KA690$M_SCR_BHE = 16384;
literal KA690$M_SCR_POK = 32768;
literal KA690$S_KA690_SCR = 4;
macro KA690$V_SCR_DOS = 0,1,3,0 %;
literal KA690$S_SCR_DOS = 3;
macro KA690$V_SCR_DCOK_HLT = 0,7,1,0 %;
macro KA690$V_SCR_AUX = 0,10,1,0 %;
macro KA690$V_SCR_PPD = 0,12,1,0 %;
macro KA690$V_SCR_BHE = 0,14,1,0 %;
macro KA690$V_SCR_POK = 0,15,1,0 %;
literal KA690$M_DSER_NXM = 1;
literal KA690$M_DSER_NG = 4;
literal KA690$M_DSER_LE = 8;
literal KA690$M_DSER_MME = 16;
literal KA690$M_DSER_PE = 32;
literal KA690$M_DSER_QNXM = 128;
literal KA690$M_DSER_DCOK = 16384;
literal KA690$M_DSER_BHALT = 32768;
literal KA690$S_KA690_DSER = 4;
macro KA690$V_DSER_NXM = 0,0,1,0 %;
macro KA690$V_DSER_NG = 0,2,1,0 %;
macro KA690$V_DSER_LE = 0,3,1,0 %;
macro KA690$V_DSER_MME = 0,4,1,0 %;
macro KA690$V_DSER_PE = 0,5,1,0 %;
macro KA690$V_DSER_QNXM = 0,7,1,0 %;
macro KA690$V_DSER_DCOK = 0,14,1,0 %;
macro KA690$V_DSER_BHALT = 0,15,1,0 %;
literal KA690$M_QBEAR_ADDR = 8191;
literal KA690$S_KA690_QBEAR = 4;
macro KA690$V_QBEAR_ADDR = 0,0,13,0 %;
literal KA690$S_QBEAR_ADDR = 13;
literal KA690$M_DEAR_ADDR = 8191;
literal KA690$S_KA690_DEAR = 4;
macro KA690$V_DEAR_ADDR = 0,0,13,0 %;
literal KA690$S_DEAR_ADDR = 13;
literal KA690$M_BDR_BDG_CD = 3;
literal KA690$M_BDR_BRS_CD = 112;
literal KA690$M_BDR_HLT_ENB = 128;
literal KA690$M_BDR_SA_ROM = 65280;
literal KA690$M_BDR_DSSI2 = 458752;
literal KA690$M_BDR_FILL2 = 16252928;
literal KA690$M_BDR_DSSI1 = 117440512;
literal KA690$M_BDR_FILL3 = 939524096;
literal KA690$M_BDR_CBL_OK = 1073741824;
literal KA690$M_BDR_ETHER_BOOT = -2147483648;
literal KA690$S_KA690_BDR = 4;
macro KA690$V_BDR_BDG_CD = 0,0,2,0 %;
literal KA690$S_BDR_BDG_CD = 2;
macro KA690$V_BDR_BRS_CD = 0,4,3,0 %;
literal KA690$S_BDR_BRS_CD = 3;
macro KA690$V_BDR_HLT_ENB = 0,7,1,0 %;
macro KA690$V_BDR_SA_ROM = 0,8,8,0 %;
literal KA690$S_BDR_SA_ROM = 8;
macro KA690$V_BDR_DSSI2 = 0,16,3,0 %;
literal KA690$S_BDR_DSSI2 = 3;
macro KA690$V_BDR_FILL2 = 0,19,5,0 %;
literal KA690$S_BDR_FILL2 = 5;
macro KA690$V_BDR_DSSI1 = 0,24,3,0 %;
literal KA690$S_BDR_DSSI1 = 3;
macro KA690$V_BDR_FILL3 = 0,27,3,0 %;
literal KA690$S_BDR_FILL3 = 3;
macro KA690$V_BDR_CBL_OK = 0,30,1,0 %;
macro KA690$V_BDR_ETHER_BOOT = 0,31,1,0 %;
literal KA690$M_DLEDR_DSPL = 15;
literal KA690$S_KA690_DLEDR = 4;
macro KA690$V_DLEDR_DSPL = 0,0,4,0 %;
literal KA690$S_DLEDR_DSPL = 4;
literal KA690$M_TCR_RUN = 1;
literal KA690$M_TCR_STP = 4;
literal KA690$M_TCR_XFR = 16;
literal KA690$M_TCR_SGL = 32;
literal KA690$M_TCR_IE = 64;
literal KA690$M_TCR_INT = 128;
literal KA690$M_TCR_ERR = -2147483648;
literal KA690$S_KA690_TCR = 4;
macro KA690$V_TCR_RUN = 0,0,1,0 %;
macro KA690$V_TCR_STP = 0,2,1,0 %;
macro KA690$V_TCR_XFR = 0,4,1,0 %;
macro KA690$V_TCR_SGL = 0,5,1,0 %;
macro KA690$V_TCR_IE = 0,6,1,0 %;
macro KA690$V_TCR_INT = 0,7,1,0 %;
macro KA690$V_TCR_ERR = 0,31,1,0 %;
literal KA690$M_TIVR_VEC = 1020;
literal KA690$S_KA690_TIVR = 4;
macro KA690$V_TIVR_VEC = 0,2,8,0 %;
literal KA690$S_TIVR_VEC = 8;
literal KA690$K_RS_RB_HLT = 0;
literal KA690$K_RS_HLT = 1;
literal KA690$K_RB_HLT = 2;
literal KA690$K_HLT = 3;
literal KA690$M_HALT_ACTION = 3;
literal KA690$M_BIP = 4;
literal KA690$M_RIP = 8;
literal KA690$M_LANGUAGE = 240;
literal KA690$M_INSERT = 256;
literal KA690$M_CRT = 512;
literal KA690$M_MCS = 1024;
literal KA690$M_DIP = 2048;
literal KA690$M_MOP_ENB = 4096;
literal KA690$K_TTY = 0;
literal KA690$K_QVSS = 1;
literal KA690$K_QDSS = 2;
literal KA690$M_VIDEO_DEV = 57344;
literal KA690$S_KA690_NVR = 2;
macro KA690$V_HALT_ACTION = 0,0,2,0 %;
literal KA690$S_HALT_ACTION = 2;
macro KA690$V_BIP = 0,2,1,0 %;
macro KA690$V_RIP = 0,3,1,0 %;
macro KA690$V_LANGUAGE = 0,4,4,0 %;
literal KA690$S_LANGUAGE = 4;
macro KA690$V_INSERT = 0,8,1,0 %;
macro KA690$V_CRT = 0,9,1,0 %;
macro KA690$V_MCS = 0,10,1,0 %;
macro KA690$V_DIP = 0,11,1,0 %;
macro KA690$V_MOP_ENB = 0,12,1,0 %;
macro KA690$V_VIDEO_DEV = 0,13,3,0 %;
literal KA690$S_VIDEO_DEV = 3;
literal KA690$M_MEMCON_MODE64 = 1;
literal KA690$K_MEMCON_1MB = 1;
literal KA690$K_MEMCON_4MB = 2;
literal KA690$M_MEMCON_SIG = 6;
literal KA690$M_MEMCON_BASE = 520093696;
literal KA690$M_MEMCON_VALID = -2147483648;
literal KA690$S_KA690_MEMCON = 4;
macro KA690$V_MEMCON_MODE64 = 0,0,1,0 %;
macro KA690$V_MEMCON_SIG = 0,1,2,0 %;
literal KA690$S_MEMCON_SIG = 2;
macro KA690$V_MEMCON_BASE = 0,24,5,0 %;
literal KA690$S_MEMCON_BASE = 5;
macro KA690$V_MEMCON_VALID = 0,31,1,0 %;
literal KA690$M_MEAR_HWADDR = 268435448;
literal KA690$M_MEAR_ID = 1879048192;
literal KA690$S_KA690_MEAR = 4;
macro KA690$V_MEAR_HWADDR = 0,3,25,0 %;
literal KA690$S_MEAR_HWADDR = 25;
macro KA690$V_MEAR_ID = 0,28,3,0 %;
literal KA690$S_MEAR_ID = 3;
literal KA690$M_MESR_LMSE = 4;
literal KA690$M_MESR_OFE = 8;
literal KA690$M_MESR_OSE = 16;
literal KA690$M_MESR_OSYND = 480;
literal KA690$M_MESR_LMHE = 512;
literal KA690$M_MESR_MSE = 1024;
literal KA690$M_MESR_MHE = 2048;
literal KA690$M_MESR_SYND = 1044480;
literal KA690$M_MESR_NXM = 1048576;
literal KA690$M_MESR_NDPE = 4194304;
literal KA690$M_MESR_NIWC = 8388608;
literal KA690$M_MESR_PTTO = 16777216;
literal KA690$M_MESR_DU = 33554432;
literal KA690$M_MESR_NAE = 67108864;
literal KA690$M_MESR_BNE = 134217728;
literal KA690$M_MESR_RC = 268435456;
literal KA690$M_MESR_LNSE = 536870912;
literal KA690$M_MESR_LNHE = 1073741824;
literal KA690$M_MESR_ERROR = -2147483648;
literal KA690$S_KA690_MESR = 4;
macro KA690$V_MESR_LMSE = 0,2,1,0 %;
macro KA690$V_MESR_OFE = 0,3,1,0 %;
macro KA690$V_MESR_OSE = 0,4,1,0 %;
macro KA690$V_MESR_OSYND = 0,5,4,0 %;
literal KA690$S_MESR_OSYND = 4;
macro KA690$V_MESR_LMHE = 0,9,1,0 %;
macro KA690$V_MESR_MSE = 0,10,1,0 %;
macro KA690$V_MESR_MHE = 0,11,1,0 %;
macro KA690$V_MESR_SYND = 0,12,8,0 %;
literal KA690$S_MESR_SYND = 8;
macro KA690$V_MESR_NXM = 0,20,1,0 %;
macro KA690$V_MESR_NDPE = 0,22,1,0 %;
macro KA690$V_MESR_NIWC = 0,23,1,0 %;
macro KA690$V_MESR_PTTO = 0,24,1,0 %;
macro KA690$V_MESR_DU = 0,25,1,0 %;
macro KA690$V_MESR_NAE = 0,26,1,0 %;
macro KA690$V_MESR_BNE = 0,27,1,0 %;
macro KA690$V_MESR_RC = 0,28,1,0 %;
macro KA690$V_MESR_LNSE = 0,29,1,0 %;
macro KA690$V_MESR_LNHE = 0,30,1,0 %;
macro KA690$V_MESR_ERROR = 0,31,1,0 %;
literal KA690$M_MMCDSR_FRR = 1;
literal KA690$M_MMCDSR_DR = 2;
literal KA690$M_MMCDSR_FWPDI = 4;
literal KA690$M_MMCDSR_FWPAI = 8;
literal KA690$M_MMCDSR_FWPO = 16;
literal KA690$M_MMCDSR_RIS = 32;
literal KA690$M_MMCDSR_DMED = 64;
literal KA690$K_MMCDSR_2600 = 0;
literal KA690$K_MMCDSR_1600 = 1;
literal KA690$K_MMCDSR_800 = 2;
literal KA690$K_MMCDSR_400 = 3;
literal KA690$M_MMCDSR_TOS = 384;
literal KA690$M_MMCDSR_MCB = 130560;
literal KA690$M_MMCDSR_MDCB = 33423360;
literal KA690$M_MMCDSR_IOM = 33554432;
literal KA690$M_MMCDSR_BFM = 67108864;
literal KA690$M_MMCDSR_ESEL = 134217728;
literal KA690$M_MMCDSR_QOIO1 = 268435456;
literal KA690$M_MMCDSR_DCBM = 536870912;
literal KA690$M_MMCDSR_FDM = -2147483648;
literal KA690$S_KA690_MMCDSR = 4;
macro KA690$V_MMCDSR_FRR = 0,0,1,0 %;
macro KA690$V_MMCDSR_DR = 0,1,1,0 %;
macro KA690$V_MMCDSR_FWPDI = 0,2,1,0 %;
macro KA690$V_MMCDSR_FWPAI = 0,3,1,0 %;
macro KA690$V_MMCDSR_FWPO = 0,4,1,0 %;
macro KA690$V_MMCDSR_RIS = 0,5,1,0 %;
macro KA690$V_MMCDSR_DMED = 0,6,1,0 %;
macro KA690$V_MMCDSR_TOS = 0,7,2,0 %;
literal KA690$S_MMCDSR_TOS = 2;
macro KA690$V_MMCDSR_MCB = 0,9,8,0 %;
literal KA690$S_MMCDSR_MCB = 8;
macro KA690$V_MMCDSR_MDCB = 0,17,8,0 %;
literal KA690$S_MMCDSR_MDCB = 8;
macro KA690$V_MMCDSR_IOM = 0,25,1,0 %;
macro KA690$V_MMCDSR_BFM = 0,26,1,0 %;
macro KA690$V_MMCDSR_ESEL = 0,27,1,0 %;
macro KA690$V_MMCDSR_QOIO1 = 0,28,1,0 %;
macro KA690$V_MMCDSR_DCBM = 0,29,1,0 %;
macro KA690$V_MMCDSR_FDM = 0,31,1,0 %;
literal KA690$K_MOAMR_RECON = 0;
literal KA690$K_MOAMR_MEM = 2;
literal KA690$K_MOAMR_FAST_MEM = 3;
literal KA690$K_MOAMR_MEM_FCB = 6;
literal KA690$K_MOAMR_FAST_MEM_FCB = 7;
literal KA690$M_MOAMR_MODE = 7;
literal KA690$M_MOAMR_MASK = 56;
literal KA690$M_MOAMR_SEGMENT = 32704;
literal KA690$S_KA690_MOAMR = 4;
macro KA690$V_MOAMR_MODE = 0,0,3,0 %;
literal KA690$S_MOAMR_MODE = 3;
macro KA690$V_MOAMR_MASK = 0,3,3,0 %;
literal KA690$S_MOAMR_MASK = 3;
macro KA690$V_MOAMR_SEGMENT = 0,6,9,0 %;
literal KA690$S_MOAMR_SEGMENT = 9;
literal KA690$M_CESR_NXIOE1 = 1;
literal KA690$M_CESR_IOE1 = 2;
literal KA690$M_CESR_IORPE1 = 4;
literal KA690$M_CESR_BE1 = 8;
literal KA690$M_CESR_DPE1 = 16;
literal KA690$M_CESR_IOLE1 = 32;
literal KA690$M_CESR_DLE1 = 64;
literal KA690$M_CESR_MTTO1 = 128;
literal KA690$M_CESR_NXIOE2 = 256;
literal KA690$M_CESR_IOE2 = 512;
literal KA690$M_CESR_IORPE2 = 1024;
literal KA690$M_CESR_BE2 = 2048;
literal KA690$M_CESR_DPE2 = 4096;
literal KA690$M_CESR_IOLE2 = 8192;
literal KA690$M_CESR_DLE2 = 16384;
literal KA690$M_CESR_MTTO2 = 32768;
literal KA690$M_CESR_PREL1 = 65536;
literal KA690$M_CESR_PREL2 = 131072;
literal KA690$M_CESR_PREL = 262144;
literal KA690$M_CESR_PE = 1048576;
literal KA690$M_CESR_NAE = 2097152;
literal KA690$M_CESR_TOE1 = 4194304;
literal KA690$M_CESR_TOE2 = 8388608;
literal KA690$M_CESR_IL = 16777216;
literal KA690$M_CESR_RC = 33554432;
literal KA690$M_CESR_LE = 67108864;
literal KA690$M_CESR_RDRNAE = 134217728;
literal KA690$M_CESR_ERROR = -2147483648;
literal KA690$S_KA690_CESR = 4;
macro KA690$V_CESR_NXIOE1 = 0,0,1,0 %;
macro KA690$V_CESR_IOE1 = 0,1,1,0 %;
macro KA690$V_CESR_IORPE1 = 0,2,1,0 %;
macro KA690$V_CESR_BE1 = 0,3,1,0 %;
macro KA690$V_CESR_DPE1 = 0,4,1,0 %;
macro KA690$V_CESR_IOLE1 = 0,5,1,0 %;
macro KA690$V_CESR_DLE1 = 0,6,1,0 %;
macro KA690$V_CESR_MTTO1 = 0,7,1,0 %;
macro KA690$V_CESR_NXIOE2 = 0,8,1,0 %;
macro KA690$V_CESR_IOE2 = 0,9,1,0 %;
macro KA690$V_CESR_IORPE2 = 0,10,1,0 %;
macro KA690$V_CESR_BE2 = 0,11,1,0 %;
macro KA690$V_CESR_DPE2 = 0,12,1,0 %;
macro KA690$V_CESR_IOLE2 = 0,13,1,0 %;
macro KA690$V_CESR_DLE2 = 0,14,1,0 %;
macro KA690$V_CESR_MTTO2 = 0,15,1,0 %;
macro KA690$V_CESR_PREL1 = 0,16,1,0 %;
macro KA690$V_CESR_PREL2 = 0,17,1,0 %;
macro KA690$V_CESR_PREL = 0,18,1,0 %;
macro KA690$V_CESR_PE = 0,20,1,0 %;
macro KA690$V_CESR_NAE = 0,21,1,0 %;
macro KA690$V_CESR_TOE1 = 0,22,1,0 %;
macro KA690$V_CESR_TOE2 = 0,23,1,0 %;
macro KA690$V_CESR_IL = 0,24,1,0 %;
macro KA690$V_CESR_RC = 0,25,1,0 %;
macro KA690$V_CESR_LE = 0,26,1,0 %;
macro KA690$V_CESR_RDRNAE = 0,27,1,0 %;
macro KA690$V_CESR_ERROR = 0,31,1,0 %;
literal KA690$M_CMCDSR_FBO1 = 1;
literal KA690$M_CMCDSR_FBO2 = 2;
literal KA690$M_CMCDSR_FWBH = 4;
literal KA690$M_CMCDSR_EP = 8;
literal KA690$M_CMCDSR_FWSP = 16;
literal KA690$M_CMCDSR_FWMP = 32;
literal KA690$M_CMCDSR_FWP1 = 64;
literal KA690$M_CMCDSR_FWP2 = 128;
literal KA690$M_CMCDSR_ENAIO2 = 256;
literal KA690$M_CMCDSR_CQBIC = 512;
literal KA690$K_CMCDSR_3200 = 0;
literal KA690$K_CMCDSR_2000 = 1;
literal KA690$K_CMCDSR_1000 = 2;
literal KA690$K_CMCDSR_500 = 3;
literal KA690$M_CMCDSR_TOP = 3072;
literal KA690$K_CMCDSR_144 = 0;
literal KA690$K_CMCDSR_1440 = 1;
literal KA690$K_CMCDSR_14400 = 2;
literal KA690$K_CMCDSR_144000 = 3;
literal KA690$M_CMCDSR_MTTOP1 = 12288;
literal KA690$M_CMCDSR_MTTOP2 = 49152;
literal KA690$M_CMCDSR_PI1 = 983040;
literal KA690$M_CMCDSR_PI2 = 15728640;
literal KA690$S_KA690_CMCDSR = 4;
macro KA690$V_CMCDSR_FBO1 = 0,0,1,0 %;
macro KA690$V_CMCDSR_FBO2 = 0,1,1,0 %;
macro KA690$V_CMCDSR_FWBH = 0,2,1,0 %;
macro KA690$V_CMCDSR_EP = 0,3,1,0 %;
macro KA690$V_CMCDSR_FWSP = 0,4,1,0 %;
macro KA690$V_CMCDSR_FWMP = 0,5,1,0 %;
macro KA690$V_CMCDSR_FWP1 = 0,6,1,0 %;
macro KA690$V_CMCDSR_FWP2 = 0,7,1,0 %;
macro KA690$V_CMCDSR_ENAIO2 = 0,8,1,0 %;
macro KA690$V_CMCDSR_CQBIC = 0,9,1,0 %;
macro KA690$V_CMCDSR_TOP = 0,10,2,0 %;
literal KA690$S_CMCDSR_TOP = 2;
macro KA690$V_CMCDSR_MTTOP1 = 0,12,2,0 %;
literal KA690$S_CMCDSR_MTTOP1 = 2;
macro KA690$V_CMCDSR_MTTOP2 = 0,14,2,0 %;
literal KA690$S_CMCDSR_MTTOP2 = 2;
macro KA690$V_CMCDSR_PI1 = 0,16,4,0 %;
literal KA690$S_CMCDSR_PI1 = 4;
macro KA690$V_CMCDSR_PI2 = 0,20,4,0 %;
literal KA690$S_CMCDSR_PI2 = 4;
literal KA690$M_CSEAR_OWADDR = 1073741808;
literal KA690$S_KA690_CSEAR = 4;
macro KA690$V_CSEAR_OWADDR = 0,4,26,0 %;
literal KA690$S_CSEAR_OWADDR = 26;
literal KA690$M_CIOEAR_ADDR = 536870911;
literal KA690$M_CIOEAR_ID = -536870912;
literal KA690$S_KA690_CIOEAR = 4;
macro KA690$V_CIOEAR_ADDR = 0,0,29,0 %;
literal KA690$S_CIOEAR_ADDR = 29;
macro KA690$V_CIOEAR_ID = 0,29,3,0 %;
literal KA690$S_CIOEAR_ID = 3;
literal KA690$M_CNEAR_ADDR = 536870911;
literal KA690$M_CNEAR_ID = -536870912;
literal KA690$S_KA690_CNEAR = 4;
macro KA690$V_CNEAR_ADDR = 0,0,29,0 %;
literal KA690$S_CNEAR_ADDR = 29;
macro KA690$V_CNEAR_ID = 0,29,3,0 %;
literal KA690$S_CNEAR_ID = 3;
 
!*** MODULE $KA810DEF ***
! +
!  KA810 Offset Definitions for Registers Accessible Through BI Node Private
!   Space.  Note that in making these registers available in virtual space,
!   we have only mapped real registers.  Therefore these virtual offsets are
!   different than the hardware physical offsets.
! -
literal KA810$M_PCNTL_CRD = 1;
literal KA810$M_PCNTL_CLR_CRD = 2;
literal KA810$M_PCNTL_CRD_IE = 4;
literal KA810$M_PCNTL_IP = 8;
literal KA810$M_PCNTL_CLR_IP = 16;
literal KA810$M_PCNTL_RX50_INT = 32;
literal KA810$M_PCNTL_CLR_RX50INT = 64;
literal KA810$M_PCNTL_RX50_IE = 128;
literal KA810$M_PCNTL_RXCD = 256;
literal KA810$M_PCNTL_CLR_RXCD = 512;
literal KA810$M_PCNTL_RXCD_IE = 1024;
literal KA810$M_PCNTL_CSR_11 = 2048;
literal KA810$M_PCNTL_TMO = 4096;
literal KA810$M_PCNTL_ENB_PIPE = 8192;
literal KA810$M_PCNTL_PAR_ERR = 16384;
literal KA810$M_PCNTL_WWPO = 32768;
literal KA810$M_PCNTL_EV0 = 65536;
literal KA810$M_PCNTL_EV1 = 131072;
literal KA810$M_PCNTL_EV2 = 262144;
literal KA810$M_PCNTL_EV3 = 524288;
literal KA810$M_PCNTL_EV4 = 1048576;
literal KA810$M_PCNTL_WRT_MEM = 2097152;
literal KA810$M_PCNTL_EV_LOCK = 4194304;
literal KA810$M_PCNTL_WWPE = 8388608;
literal KA810$M_PCNTL_RUN = 16777216;
literal KA810$M_PCNTL_STST_PASS = 33554432;
literal KA810$M_PCNTL_ENB_APT = 67108864;
literal KA810$M_PCNTL_STST_FAST = 134217728;
literal KA810$M_PCNTL_BI_RESET = 268435456;
literal KA810$M_PCNTL_CSL_ENB = 536870912;
literal KA810$M_PCNTL_CSL_LOG = 1073741824;
literal KA810$M_PCNTL_RSTRT_HALT = -2147483648;
literal KA810$M_EEPROM_SECOND = 1;
literal KA810$M_EEPROM_PATCH = 2046;
literal KA810$M_EEPROM_CPU = 63488;
literal KA810$M_EEPROM_DISABLE = 16;
literal KA810$M_EEPROM_FCHIP = 1;
literal KA810$M_EEPROM_BTB = 2;
literal KA810$M_EEPROM_CACHE = 4;
literal KA810$S_KA810DEF = 52224;
! 
!  BIIC registers - here we reserve space for the 256 bytes that these
! 		    registers occupy and we also fill out the virtual page to
! 		    512 bytes so that other items appear on page boundaries.
! 		    Being able to address the BIIC via these virtual addresses
! 		    allows a Scorpio CPU to determine its own node number.
! 		    That is, a reference here is via node private space and
! 		    always addresses a nodes own registers via a loop back
! 		    request.
!                               
macro KA810$B_BIICBASE = 0,0,8,0 %;     ! BIIC register Base
! 
!  Port Control CSR register
! 
macro KA810$L_PCNTL = 512,0,32,0 %;     ! Port Control CSR Register
macro KA810$V_PCNTL_CRD = 512,0,1,0 %;  !  RO bit set when CRD status rcvd
!   and CRD Interrupt Enabled.
macro KA810$V_PCNTL_CLR_CRD = 512,1,1,0 %; !  W1C bit to clear CRD interrupt.
macro KA810$V_PCNTL_CRD_IE = 512,2,1,0 %; !  R/W bit to enable CRD interrupts.
macro KA810$V_PCNTL_IP = 512,3,1,0 %;   !  RO bit set when Inter-Processor
!   INTR rcvd.
macro KA810$V_PCNTL_CLR_IP = 512,4,1,0 %; !  W1C bit to clear IP Interrupt.
macro KA810$V_PCNTL_RX50_INT = 512,5,1,0 %; !  RO bit set when RX50 interrupt
!   requested.
macro KA810$V_PCNTL_CLR_RX50INT = 512,6,1,0 %;
!  W1C bit to clear RX50 interrupt.
macro KA810$V_PCNTL_RX50_IE = 512,7,1,0 %; !  R/W bit to enable RX50 interrupts
macro KA810$V_PCNTL_RXCD = 512,8,1,0 %; !  RO bit set when RXCD data rcvd.
macro KA810$V_PCNTL_CLR_RXCD = 512,9,1,0 %; !  W1C bit to clear above bit.
macro KA810$V_PCNTL_RXCD_IE = 512,10,1,0 %; !  R/W bit to enable RXCD interrupts
macro KA810$V_PCNTL_CSR_11 = 512,11,1,0 %; !  ?
macro KA810$V_PCNTL_TMO = 512,12,1,0 %; !  R,W1C bit set when PCNTL times
!   out.
macro KA810$V_PCNTL_ENB_PIPE = 512,13,1,0 %; !  R/W bit. 0=> no pipeline writes.
macro KA810$V_PCNTL_PAR_ERR = 512,14,1,0 %; !  R,W1C bit. Signals cache or BTB
!   parity
macro KA810$V_PCNTL_WWPO = 512,15,1,0 %; !  R/W bit. Write Wrong Parity Odd.
macro KA810$V_PCNTL_EV0 = 512,16,1,0 %; !  BI Event Code bits
macro KA810$V_PCNTL_EV1 = 512,17,1,0 %; !  "    "    "    "
macro KA810$V_PCNTL_EV2 = 512,18,1,0 %; !  "    "    "    "
macro KA810$V_PCNTL_EV3 = 512,19,1,0 %; !  "    "    "    "
macro KA810$V_PCNTL_EV4 = 512,20,1,0 %; !  "    "    "    "
macro KA810$V_PCNTL_WRT_MEM = 512,21,1,0 %; !  RO bit. Indicates EV code due
!   to write to memory space.
macro KA810$V_PCNTL_EV_LOCK = 512,22,1,0 %; !  R,W1C bit. Set when BI Event
!   code and Write Memory bits
!   locked in CSR as result of
!   master port error.
macro KA810$V_PCNTL_WWPE = 512,23,1,0 %; !  R/W bit. Write Wrong Parity Even.
macro KA810$V_PCNTL_RUN = 512,24,1,0 %; !  R/W controlled by ucode.
macro KA810$V_PCNTL_STST_PASS = 512,25,1,0 %; !  Self Test passed.
macro KA810$V_PCNTL_ENB_APT = 512,26,1,0 %; !  ?
macro KA810$V_PCNTL_STST_FAST = 512,27,1,0 %; !  RO Self Test Fast. (NOT fast = 1)
macro KA810$V_PCNTL_BI_RESET = 512,28,1,0 %; ! 
macro KA810$V_PCNTL_CSL_ENB = 512,29,1,0 %; !  RO Enable=1(From console switch)
macro KA810$V_PCNTL_CSL_LOG = 512,30,1,0 %; !  RO Logical=1(From console switch)
macro KA810$V_PCNTL_RSTRT_HALT = 512,31,1,0 %; !  RO Halt=1(From console switch)
! 
!  NI Packet Buffer
! 
macro KA810$B_NIBUF = 1024,0,8,0 %;     ! NI Packet Buffer Base
! 
!  EEPROM - The KA810 contains a 2k x 8 EEPROM.  The physical address
!  	    bit <0> is not used in addressing the EEPROM.  Consequently,
! 	    the first byte is addressed at 2009 8000(hex), the second
! 	    byte at 2009 8002(hex) and so on.
! 
macro KA810$B_EEPROM = 33792,0,8,0 %;   ! EEPROM Base
macro KA810$B_EEPROM_CONSTANT_FF = 33792,0,8,0 %; ! FF Constant
macro KA810$B_EEPROM_CONSTANT_55 = 33794,0,8,0 %; ! 55 Constant
macro KA810$B_EEPROM_WATCH_TIMER = 34112,0,32,1 %;
literal KA810$S_EEPROM_WATCH_TIMER = 4; ! Watch Dog timer constant
macro KA810$B_EEPROM_CONSTANT_AA = 34132,0,8,0 %; ! AA constant
macro KA810$B_EEPROM_BI_SELFTEST = 34136,0,32,1 %;
literal KA810$S_EEPROM_BI_SELFTEST = 4; ! BI selftest timeout constant
macro KA810$W_EEPROM_DEVTYPE = 34152,0,16,0 %; ! BI device type for module
macro KA810$W_EEPROM_REV = 34156,0,16,0 %; ! BI Rev level for module
macro KA810$V_EEPROM_SECOND = 34156,0,1,0 %; ! secondary patches not needed
macro KA810$V_EEPROM_PATCH = 34156,1,10,0 %;
literal KA810$S_EEPROM_PATCH = 10;      ! patch rev
macro KA810$V_EEPROM_CPU = 34156,11,5,0 %;
literal KA810$S_EEPROM_CPU = 5;         ! cpu rev
macro KA810$B_EEPROM_RXC50 = 34166,0,8,0 %; ! RCX50 disable
macro KA810$V_EEPROM_DISABLE = 34166,4,1,0 %; !  
macro KA810$B_EEPROM_LOG_CONSOLE = 34168,0,8,0 %; ! Logical console BI number
macro KA810$B_EEPROM_BAUD_RATE = 34172,0,8,0 %; ! UART0 baud rate
macro KA810$B_EEPROM_FCHIP = 34174,0,8,0 %;
macro KA810$V_EEPROM_FCHIP = 34174,0,1,0 %; ! Set, Fchip disabled
macro KA810$V_EEPROM_BTB = 34174,1,1,0 %; ! Set, BTB disabled
macro KA810$V_EEPROM_CACHE = 34174,2,1,0 %; ! Set, Cache disabled
! 
!  NI Data Register
! 
macro KA810$L_NIDATA = 50176,0,32,0 %;  !  NI Data Register
! 
!  NI Address Register
! 
macro KA810$L_NIADDR = 50688,0,32,0 %;  !  NI Address Register
! 
!  RCX50 Registers
! 
macro KA810$B_RCX50 = 51200,0,8,0 %;    !  RCX50 Registers
! 
!  Watch Chip Registers
! 
macro KA810$B_WATCH = 51712,0,8,0 %;    !  Watch Chip Registers
 
!*** MODULE $KDZDEF ***
! +
!  KDZ11 Offset Definitions for Registers Accessible Through BI Node Private
!   Space.  Note that in making these registers available in virtual space,
!   we have only mapped real registers.  Therefore these virtual offsets are
!   different than the hardware physical offsets.
! -
literal KDZ$M_PCNTL_RSTRT = 1;
literal KDZ$M_PCNTL_PHYLOG = 2;
literal KDZ$M_PCNTL_SECENB = 4;
literal KDZ$M_PCNTL_STINIT = 8;
literal KDZ$M_PCNTL_STFAST = 16;
literal KDZ$M_PCNTL_ENBAPT = 32;
literal KDZ$M_PCNTL_STPASS = 64;
literal KDZ$M_PCNTL_RUN = 128;
literal KDZ$M_PCNTL_CLREVL = 512;
literal KDZ$M_PCNTL_WRMEM = 1024;
literal KDZ$M_PCNTL_EV4 = 2048;
literal KDZ$M_PCNTL_EV3 = 4096;
literal KDZ$M_PCNTL_EV2 = 8192;
literal KDZ$M_PCNTL_EV1 = 16384;
literal KDZ$M_PCNTL_EV0 = 32768;
literal KDZ$M_PCNTL_WWPO = 65536;
literal KDZ$M_PCNTL_NIDIS = 524288;
literal KDZ$M_PCNTL_CNSLIE = 1048576;
literal KDZ$M_PCNTL_CNSLCL = 2097152;
literal KDZ$M_PCNTL_CNSLIN = 4194304;
literal KDZ$M_PCNTL_WWPE = 8388608;
literal KDZ$M_PCNTL_RXDONE = 16777216;
literal KDZ$M_PCNTL_RXSTAT = 33554432;
literal KDZ$M_PCNTL_CLRIPI = 67108864;
literal KDZ$M_PCNTL_IPINTR = 134217728;
literal KDZ$M_PCNTL_CRDIE = 268435456;
literal KDZ$M_PCNTL_CLRCRD = 536870912;
literal KDZ$M_PCNTL_CRDINT = 1073741824;
literal KDZ$S_KDZDEF = 44032;
! 
!  BIIC registers - here we reserve space for the 256 bytes that these
! 		    registers occupy and we also fill out the virtual page to
! 		    512 bytes so that other items appear on page boundaries.
! 		    Being able to address the BIIC via these virtual addresses
! 		    allows a Scorpio CPU to determine its own node number.
! 		    That is, a reference here is via node private space and
! 		    always addresses a nodes own registers via a loop back
! 		    request.
! 
macro KDZ$B_BIICBASE = 0,0,8,0 %;       ! BIIC register Base
! 
!  Port Control CSR register
! 
macro KDZ$L_PCNTL = 512,0,32,0 %;       ! Port Control CSR Register
macro KDZ$V_PCNTL_RSTRT = 512,0,1,0 %;  !  (RO) Front Panel Switch
!   selecting RSTRT/HALT
macro KDZ$V_PCNTL_PHYLOG = 512,1,1,0 %; !  (RO) Backplane Bit
!   selecting PHYS/LOG Console
macro KDZ$V_PCNTL_SECENB = 512,2,1,0 %; !  (RO) Front Panel Switch
!   to lock out console input
macro KDZ$V_PCNTL_STINIT = 512,3,1,0 %; !  Self-Test INIT.
macro KDZ$V_PCNTL_STFAST = 512,4,1,0 %; !  (RO) Backplane bit to
!   select Fast Self-Test.
macro KDZ$V_PCNTL_ENBAPT = 512,5,1,0 %; !  Enable APT.
macro KDZ$V_PCNTL_STPASS = 512,6,1,0 %; !  Self-Test Pass.
macro KDZ$V_PCNTL_RUN = 512,7,1,0 %;    !  1=>Program mode,0=>Console
macro KDZ$V_PCNTL_CLREVL = 512,9,1,0 %; !  Clear Event Lock
macro KDZ$V_PCNTL_WRMEM = 512,10,1,0 %; !  Write Memory Bit
macro KDZ$V_PCNTL_EV4 = 512,11,1,0 %;   !  Event Bits - These
macro KDZ$V_PCNTL_EV3 = 512,12,1,0 %;   !   RO bits are event
macro KDZ$V_PCNTL_EV2 = 512,13,1,0 %;   !   codes from BIIC to
macro KDZ$V_PCNTL_EV1 = 512,14,1,0 %;   !   allow CPU to monitor
macro KDZ$V_PCNTL_EV0 = 512,15,1,0 %;   !   BI status
macro KDZ$V_PCNTL_WWPO = 512,16,1,0 %;  !  Write Wrong Parity Odd
macro KDZ$V_PCNTL_NIDIS = 512,19,1,0 %; !  Disable NI Lance
macro KDZ$V_PCNTL_CNSLIE = 512,20,1,0 %; !  Console Interrupt Enable
macro KDZ$V_PCNTL_CNSLCL = 512,21,1,0 %; !  Clear Console Interrupt
macro KDZ$V_PCNTL_CNSLIN = 512,22,1,0 %; !  Console Interrupt RCVD
macro KDZ$V_PCNTL_WWPE = 512,23,1,0 %;  !  Write Wrong Parity Even
macro KDZ$V_PCNTL_RXDONE = 512,24,1,0 %; !  RX Done Interrupt
macro KDZ$V_PCNTL_RXSTAT = 512,25,1,0 %; !  RX Status Interrupt
macro KDZ$V_PCNTL_CLRIPI = 512,26,1,0 %; !  Clear IP Interrupt
macro KDZ$V_PCNTL_IPINTR = 512,27,1,0 %; !  IP Interrupt RCVD
macro KDZ$V_PCNTL_CRDIE = 512,28,1,0 %; !  CRD Interrupt Enable
macro KDZ$V_PCNTL_CLRCRD = 512,29,1,0 %; !  Clear CRD Interrupt
macro KDZ$V_PCNTL_CRDINT = 512,30,1,0 %; !  CRD Interrupt RCVD
! 
!  NI Packet Buffer
! 
macro KDZ$B_NIBUF = 1024,0,8,0 %;       ! NI Packet Buffer Base
! 
!  EEPROM
! 
macro KDZ$B_EEPROM = 33792,0,8,0 %;     ! EEPROM Base
! 
!  NI Data Register
! 
macro KDZ$L_NIDATA = 41984,0,32,0 %;    !  NI Data Register
! 
!  NI Address Register
! 
macro KDZ$L_NIADDR = 42496,0,32,0 %;    !  NI Address Register
! 
!  RCX50 Registers
!                                                          
macro KDZ$B_RCX50 = 43008,0,8,0 %;      !  RCX50 Registers
! 
!  Watch Chip Registers
! 
macro KDZ$B_WATCH = 43520,0,8,0 %;      !  Watch Chip Registers
 
!*** MODULE $KFDDEF ***
! 
!  KNOWN FILE DEVICE AND DIRECTORY BLOCK DEFINITIONS
! 
literal KFD$C_LENGTH = 17;              !  Length of fixed area of kfd entry 
literal KFD$S_KFDDEF = 17;
macro KFD$L_LINK = 0,0,32,0 %;          !  Device, Directory, Extension (KFD) list link
macro KFD$L_KFELIST = 4,0,32,0 %;       !  Ordered Known file entry list header
macro KFD$W_SIZE = 8,0,16,0 %;          !  Size of block 
macro KFD$B_TYPE = 10,0,8,0 %;          !  Structure type 
macro KFD$B_SPARE = 11,0,8,0 %;         !  spare
macro KFD$W_REFCNT = 12,0,16,0 %;       !  Number of KFE's with same KFD
macro KFD$B_DEVLEN = 14,0,8,0 %;        !  Length of Device string
macro KFD$B_DIRLEN = 15,0,8,0 %;        !  Length of Directory string
macro KFD$B_DDTSTRLEN = 16,0,8,0 %;     !  Length of Device, Directory, Type (DDT) string
macro KFD$T_DDTSTR = 17,0,0,0 %;        !  Offset to DDT string
 
!*** MODULE $KFEDEF ***
! 
!  KNOWN FILE ENTRY DEFINITIONS
! 
literal KFE$M_PROTECT = 1;
literal KFE$M_LIM = 2;
literal KFE$M_PROCPRIV = 4;
literal KFE$M_OPEN = 8;
literal KFE$M_HDRRES = 16;
literal KFE$M_SHARED = 32;
literal KFE$M_SHMIDENT = 64;
literal KFE$M_COMPATMOD = 128;
literal KFE$M_NOPURGE = 256;
literal KFE$M_ACCOUNT = 512;
literal KFE$M_WRITEABLE = 1024;
literal KFE$M_EXEONLY = 2048;
literal KFE$K_LENGTH = 55;              !  Length of fixed area of KFE entry 
literal KFE$C_LENGTH = 55;              !  Length of fixed area of KFE entry 
literal KFE$K_MAXLEN = 94;              !  Max KFE length (includes max filename)
literal KFE$C_MAXLEN = 94;              !  Max KFE length (includes max filename)
literal KFE$S_KFEDEF = 55;
macro KFE$L_HSHLNK = 0,0,32,0 %;        !  Known file Hash table link 
macro KFE$L_KFELINK = 4,0,32,0 %;       !  Ordered Known file entry list link
macro KFE$W_SIZE = 8,0,16,0 %;          !  Size of block 
macro KFE$B_TYPE = 10,0,8,0 %;          !  Structure type 
macro KFE$B_HSHIDX = 11,0,8,0 %;        !  KFE hash table index (index into vector of HSHQ's) 
macro KFE$L_KFD = 12,0,32,0 %;          !  Device, Directory, Type block
macro KFE$R_FLAGS_OVERLAY = 16,0,16,0 %;
macro KFE$W_FLAGS = 16,0,16,0 %;        !  Flags word 
macro KFE$R_FLAGS_BITS = 16,0,16,0 %;
macro KFE$V_PROTECT = 16,0,1,0 %;       !  Known file was installed protected 
macro KFE$V_LIM = 16,1,1,0 %;           !  Linkable image 
macro KFE$V_PROCPRIV = 16,2,1,0 %;      !  Use process privilege mask 
macro KFE$V_OPEN = 16,3,1,0 %;          !  Image installed /OPEN
macro KFE$V_HDRRES = 16,4,1,0 %;        !  Image header block is resident 
macro KFE$V_SHARED = 16,5,1,0 %;        !  Image is shared 
macro KFE$V_SHMIDENT = 16,6,1,0 %;      !  Shared memory ident already set 
macro KFE$V_COMPATMOD = 16,7,1,0 %;     !  Image is compatability mode 
macro KFE$V_NOPURGE = 16,8,1,0 %;       !  Image entry may not be purged
macro KFE$V_ACCOUNT = 16,9,1,0 %;       !  Image level accounting
macro KFE$V_WRITEABLE = 16,10,1,0 %;    !  Global sections are writeable
macro KFE$V_EXEONLY = 16,11,1,0 %;      !  Image has only execute access allowed
macro KFE$W_GBLSECCNT = 18,0,16,0 %;    !  Global section count if shared 
macro KFE$L_USECNT = 20,0,32,0 %;       !  Usage counter 
macro KFE$R_WINDOW_OVERLAY = 24,0,32,0 %;
macro KFE$L_WCB = 24,0,32,0 %;          !  WCB address if open 
macro KFE$R_WINDOW_FIELDS = 24,0,32,0 %;
macro KFE$R_FID_OVERLAY = 24,0,16,0 %;
macro KFE$W_FID = 24,0,16,0 %;          !  File id 
macro KFE$W_FID_NUM = 24,0,16,0 %;      !  File number field of file id 
macro KFE$W_FID_SEQ = 26,0,16,0 %;      !  File sequence number field of file id 
macro KFE$R_IMGHDR_OVERLAY = 28,0,32,0 %;
macro KFE$L_IMGHDR = 28,0,32,0 %;       !  Image header address if resident 
macro KFE$W_FID_RVN = 28,0,16,0 %;      !  Relative volume number field of file id 
macro KFE$Q_PROCPRIV = 32,0,0,0 %;
literal KFE$S_PROCPRIV = 8;             !  Process privilege mask 
macro KFE$B_MATCHCTL = 40,0,8,0 %;      !  Global section match control 
macro KFE$W_AMECOD = 42,0,16,0 %;       !  Image header code specifying AME 
macro KFE$L_IDENT = 44,0,32,0 %;        !  Global section ident value 
macro KFE$L_ORB = 48,0,32,0 %;          !  Address of Object Rights Block
macro KFE$W_SHRCNT = 52,0,16,0 %;       !  High water mark for sharing
macro KFE$B_FILNAMLEN = 54,0,8,0 %;     !  Length of file name
macro KFE$T_FILNAM = 55,0,0,0 %;        !  Offset to file name
 
!*** MODULE $KFE52DEF ***
! 
!  CIRRUS CIO module related definitions
! 
literal KFE52RAM$M_REV = 2047;
literal KFE52RAM$M_SERIALNO = 4192256;
literal KFE52RAM$M_MODULEID = 62914560;
literal KFE52RAM$S_RAMDEF = 8;
macro KFE52RAM$L_MODDATA = 0,0,32,0 %;  !  
macro KFE52RAM$V_REV = 0,0,11,0 %;
literal KFE52RAM$S_REV = 11;            !  Module revision filed
macro KFE52RAM$V_SERIALNO = 0,11,11,0 %;
literal KFE52RAM$S_SERIALNO = 11;       !  Module serial number
macro KFE52RAM$V_MODULEID = 0,22,4,0 %;
literal KFE52RAM$S_MODULEID = 4;        !  Module id type
macro KFE52RAM$L_MODSTATUS = 4,0,32,0 %; !  Module status
literal KFE52RAM$K_MOD_GOOD = 179;      !  Good module status
literal KFE52RAM$K_MOD_BAD = 76;        !  Bad module status
literal KFE52RAM$L_TRDB = 13312;        !  Trace RAM data block
!  SLIM offsets and definitions
literal SLI520$M_TCA = 124;
literal SLI520$M_TESTPTRS = 128;
literal SLI520$M_DIAGMODE = 256;
literal SLI520$M_DMASEL = 1024;
literal SLI520$M_DISARB = 2048;
literal SLI520$S_SLIMDEF = 4;
macro SLI520$L_ICSR0 = 0,0,32,0 %;      !  II32 Control register
macro SLI520$V_TCA = 0,2,5,0 %;
literal SLI520$S_TCA = 5;               !  Trace RAM number
macro SLI520$V_TESTPTRS = 0,7,1,0 %;    !  Test pointers
macro SLI520$V_DIAGMODE = 0,8,1,0 %;    !  Diagnostic mode
macro SLI520$V_DMASEL = 0,10,1,0 %;     !  DMA select
macro SLI520$V_DISARB = 0,11,1,0 %;     !  Disable arbitration
!  FIREWALL offsets
literal FIR520$S_FIRDEF = 48;
macro FIR520$L_INTVEC0 = 0,0,32,0 %;    !  SWIFT
macro FIR520$L_INTVEC1 = 4,0,32,0 %;    !  LANCE
macro FIR520$L_INTVEC2 = 8,0,32,0 %;    !  Not used
macro FIR520$L_INTVEC3 = 12,0,32,0 %;   !  PCM
macro FIR520$L_UCCRVEC = 16,0,32,0 %;   !  UCCR (read only)
macro FIR520$L_DCCRVEC = 20,0,32,0 %;   !  DCCR (read only)
macro FIR520$L_WINVEC = 28,0,32,0 %;    !  Vector that has won interrupt arbitration
macro FIR520$L_IPL = 32,0,32,0 %;       !  IPL settings for INTVEC0 - INTVEC3 (Interrupt Level)
macro FIR520$L_IMR = 36,0,32,0 %;       !  Interrupt Mask Register
macro FIR520$L_ICS = 40,0,32,0 %;       !  Interrupt Control/Status register.
macro FIR520$L_PCMVEC = 44,0,32,0 %;    !  PCM
!  SCB offsets per section of the second page of the SCB. The second page
!  of the SCB is divided into 16 sections each of which correspond to
!  a slot (TR) number.
literal KA520SCB$S_CIRSCBDEF = 20;
macro KA520SCB$L_CONI = 0,0,32,0 %;     !  Console input
macro KA520SCB$L_CONO = 4,0,32,0 %;     !  Console output
macro KA520SCB$L_LANCE = 8,0,32,0 %;    !  LANCE
macro KA520SCB$L_SWIFT = 12,0,32,0 %;   !  SWIFT
macro KA520SCB$L_PCM = 16,0,32,0 %;     !  PCM
!  The physical byte offsets of various register from the beginning of a CIO
!  module.
literal KFE52$K_COMM_RAM = 0;           !  COMM RAM
literal KFE52$K_COMM_SIZE = 65536;      !  COMM RAM size
literal KFE52$K_SL_RAM = 65536;         !  SWIFT/LANCE RAM
literal KFE52$K_SL_SIZE = 196608;       !  SWIFT/LANCE RAM size
literal KFE52$K_LANCE_RAM = 65536;      !  LANCE RAM
literal KFE52$K_LANCE_SIZE = 65536;     !  LANCE RAM size
literal KFE52$K_SWIFT_RAM = 131072;     !  SWIFT RAM
literal KFE52$K_SWIFT_SIZE = 131072;    !  SWIFT RAM size
literal KFE52$K_ETH_ADR_ROM = 9043968;  !  Ethernet address ROM
literal KFE52$K_SSC_CSR = 9699328;      !  SSC CSR and RAM
literal KFE52$K_SSC_TOY_CLOCK = 9699436; !  SSC TOY clock
literal KFE52$K_FIREWALL = 10485760;    !  Firewall registers
literal KFE52$K_DMA_BCNT = 10489856;    !  DMA byte count
literal KFE52$K_DMA_STL = 10489860;     !  DMA sub transfer length
literal KFE52$K_DMA_STS = 10489864;     !  DMA status
literal KFE52$K_PCM_CSR = 10498048;     !  PCM CSR
literal KFE52$K_FW_CSR = 10502144;      !  Firewall CSR
literal KFE52$K_CONS_CSR = 10510336;    !  Console registers
literal KFE52$K_SLIM_CSR = 12582912;    !  SLIM CSR
literal KFE52$K_SWIFT_CSR = 12582976;   !  SWIFT CSR
literal KFE52$K_LANCE_CSR = 12583040;   !  LANCE CSR
!  CONSOLE REGISTER offsets and definitions
literal CON520$M_UTYP = 256;
literal CON520$M_UID = 3584;
literal CON520$M_UBRK = 4096;
literal CON520$M_UEIE = 8192;
literal CON520$M_UFIE = 16384;
literal CON520$M_UBSY = 32768;
literal CON520$M_DTYP = 256;
literal CON520$M_DID = 3584;
literal CON520$M_DEIE = 8192;
literal CON520$M_DFIE = 16384;
literal CON520$M_DBSY = 32768;
literal CON520$S_CONDEF = 8;
macro CON520$L_UCCR = 0,0,32,0 %;       !  UPWARD Console Communication Register
macro CON520$V_UDATA = 0,0,8,0 %;
literal CON520$S_UDATA = 8;             !  Data
macro CON520$V_UTYP = 0,8,1,0 %;        !  Type
macro CON520$V_UID = 0,9,3,0 %;
literal CON520$S_UID = 3;               !  ID
macro CON520$V_UBRK = 0,12,1,0 %;       !  CIO module Broken
macro CON520$V_UEIE = 0,13,1,0 %;       !  Empty Interrupt enable
macro CON520$V_UFIE = 0,14,1,0 %;       !  Full Interrupt enable
macro CON520$V_UBSY = 0,15,1,0 %;       !  Busy
macro CON520$L_DCCR = 4,0,32,0 %;       !  DOWNWARD Console Communication Register
macro CON520$V_DDATA = 4,0,8,0 %;
literal CON520$S_DDATA = 8;             !  Data
macro CON520$V_DTYP = 4,8,1,0 %;        !  Type
macro CON520$V_DID = 4,9,3,0 %;
literal CON520$S_DID = 3;               !  ID
macro CON520$V_DEIE = 4,13,1,0 %;       !  Empty interrupt enable
macro CON520$V_DFIE = 4,14,1,0 %;       !  Full Interrupt enable
macro CON520$V_DBSY = 4,15,1,0 %;       !  Busy
literal FWCSR520$M_TRACE_READ = 1;
literal FWCSR520$M_CPU_WRITE = 2;
literal FWCSR520$M_CPU_READ = 4;
literal FWCSR520$M_CPU_XCHK_ENA = 8;
literal FWCSR520$M_FW_LOCK = 16;
literal FWCSR520$M_II32_DRV = 32;
literal FWCSR520$M_DMR_ENA = 64;
literal FWCSR520$M_DIAG_MODE = 128;
literal FWCSR520$M_IO_XCHK_ERR = 256;
literal FWCSR520$M_DIAG_XCHK = 512;
literal FWCSR520$M_IO_XCHK_ENA = 1024;
literal FWCSR520$M_MBZ = 2048;
literal FWCSR520$M_RAIL_ID = 4096;
literal FWCSR520$M_SLOT_ID = 57344;
literal FWCSR520$S_FWCSRDEF = 4;
macro FWCSR520$L_FWCSR = 0,0,32,0 %;    !  Firewall Control register
macro FWCSR520$V_TRACE_READ = 0,0,1,0 %; !  Read Trace RAMs
macro FWCSR520$V_CPU_WRITE = 0,1,1,0 %; !  CVAX write downward console
macro FWCSR520$V_CPU_READ = 0,2,1,0 %;  !  CVAX read upward console
macro FWCSR520$V_CPU_XCHK_ENA = 0,3,1,0 %; !  CVAX crosscheck enable
macro FWCSR520$V_FW_LOCK = 0,4,1,0 %;   !  Firewall lock
macro FWCSR520$V_II32_DRV = 0,5,1,0 %;  !  1132(T) drive
macro FWCSR520$V_DMR_ENA = 0,6,1,0 %;   !  DMR enable
macro FWCSR520$V_DIAG_MODE = 0,7,1,0 %; !  Diagnostic mode
macro FWCSR520$V_IO_XCHK_ERR = 0,8,1,0 %; !  UVAX crosscheck error
macro FWCSR520$V_DIAG_XCHK = 0,9,1,0 %; !  Diagnostic crosscheck bit
macro FWCSR520$V_IO_XCHK_ENA = 0,10,1,0 %; !  UVAX crosscheck enable
macro FWCSR520$V_MBZ = 0,11,1,0 %;      !  Must be zero
macro FWCSR520$V_RAIL_ID = 0,12,1,0 %;  !  Rail ID
macro FWCSR520$V_SLOT_ID = 0,13,3,0 %;
literal FWCSR520$S_SLOT_ID = 3;         !  Slot ID
macro FWCSR520$V_UNUSED = 0,16,16,0 %;
literal FWCSR520$S_UNUSED = 16;         !  Unused
 
!*** MODULE $KFHDEF ***
! 
!  KNOWN FILE IMAGE HEADER DEFINITIONS	*** obsolete, to be removed ***
! 
literal KFH$K_LENGTH = 12;              ! LENGTH OF OVERHEAD AREA 
literal KFH$C_LENGTH = 12;              ! LENGTH OF OVERHEAD AREA 
! 
literal KFH$S_KFHDEF = 12;
macro KFH$L_BUFEND = 0,0,32,0 %;        ! ADDRESS OF END OF KNOWN FILE HEADER 
macro KFH$L_KFIADR = 4,0,32,0 %;        ! ADDRESS OF ASSOCIATED KNOWN FILE ENTRY 
macro KFH$W_SIZE = 8,0,16,0 %;          ! SIZE OF DYNAMIC STRUCTURE 
macro KFH$B_TYPE = 10,0,8,0 %;          ! DYNAMIC STRUCTURE TYPE 
!  THE REMAINDER OF THIS STRUCTURE CONTAINS THE IMAGE HEADER OF THE
!  SPECIFIED KNOWN FILE.  THE LOCATION KFI$L_IMGHDR IN THE KNOWN FILE
!  ENTRY POINTS KFH$C_LENGTH INTO THIS STRUCTURE, I.E AT THE IMAGE HEADER
!  ITSELF.
! 
 
!*** MODULE $KFIDEF ***
! 
!  KNOWN FILE ENTRY DEFINITIONS 	*** obsolete, to be removed ***
! 
literal KFI$M_KFIHD = 1;
literal KFI$M_FILIDOPEN = 2;
literal KFI$M_DONOTOPEN = 4;
literal KFI$M_NOREPLACE = 64;
literal KFI$M_MARKDEL = 128;
literal KFI$K_KFIHDLEN = 20;            ! LENGTH OF KFI HEADER FIXED PORTION 
literal KFI$C_KFIHDLEN = 20;            ! LENGTH OF KFI HEADER FIXED PORTION 
literal KFI$M_KFISEQ = 3;
literal KFI$M_KP_OPEN = 1;
literal KFI$M_KP_RESHDR = 2;
literal KFI$M_KP_SHARED = 4;
literal KFI$M_PROTECT = 8;
literal KFI$M_LIM = 64;
literal KFI$M_PROCPRIV = 128;
literal KFI$M_IS_RESHDR = 256;
literal KFI$M_IS_SHARED = 512;
literal KFI$M_SHMIDENT = 16384;
literal KFI$M_COMPATMOD = 32768;
literal KFI$K_LENGTH = 52;              ! LENGTH OF FIXED AREA OF KFI ENTRY 
literal KFI$C_LENGTH = 52;              ! LENGTH OF FIXED AREA OF KFI ENTRY 
literal KFI$S_KFIDEF = 52;
macro KFI$L_KFIQFL = 0,0,32,0 %;        ! KNOWN FILE QUEUE FORWARD LINK 
macro KFI$L_KFIQBL = 4,0,32,0 %;        ! KNOWN FILE QUEUE BACK LINK 
macro KFI$W_SIZE = 8,0,16,0 %;          ! SIZE OF BLOCK 
macro KFI$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE 
macro KFI$B_KFICTL = 11,0,8,0 %;        ! CONTROL BITS 
macro KFI$V_KFIHD = 11,0,1,0 %;         ! KNOWN FILE HEADER BLOCK 
macro KFI$V_FILIDOPEN = 11,1,1,0 %;     ! OPEN BY FILE ID IF SET 
macro KFI$V_DONOTOPEN = 11,2,1,0 %;     ! DO NOT OPEN THE FILE IF SET 
macro KFI$V_NOREPLACE = 11,6,1,0 %;     ! DELETE AND DO NOT REPLACE ENTRY 
macro KFI$V_MARKDEL = 11,7,1,0 %;       ! ENTRY IS TO BE DELETED 
macro KFI$B_DEVUCB = 12,0,8,0 %;        ! DEVICE UCB OFFSET 
macro KFI$B_DEVNAM = 12,0,8,0 %;        ! NAME THE ABOVE CONSISTENTLY 
macro KFI$B_DIRNAM = 13,0,8,0 %;        ! DIRECTORY NAME STRING OFFSET 
macro KFI$B_FILNAM = 14,0,8,0 %;        ! FILE NAME STRING OFFSET 
macro KFI$B_TYPNAM = 15,0,8,0 %;        ! FILE TYPE STRING OFFSET 
macro KFI$W_REFCNT = 16,0,16,0 %;       ! REFERENCE COUNT 
macro KFI$B_KFIQNUM = 18,0,8,0 %;       ! KFIQ NUMBER (INDEX INTO VECTOR OF KFIQ'S) 
macro KFI$B_KFISEQ = 19,0,8,0 %;        ! KNOWN FILE ENTRY SEQUENCE NUMBER 
macro KFI$V_KFISEQ = 19,0,2,0 %;
literal KFI$S_KFISEQ = 2;               ! SEQUENCE NUMBER FIELD 
macro KFI$W_FLAGS = 20,0,16,0 %;        ! FLAGS WORD 
macro KFI$V_KP_OPEN = 20,0,1,0 %;       ! KEEP THE IMAGE FILE OPEN 
macro KFI$V_KP_RESHDR = 20,1,1,0 %;     ! MAKE IMAGE HEADER RESIDENT 
macro KFI$V_KP_SHARED = 20,2,1,0 %;     ! MAKE IMAGE SHARED 
macro KFI$V_PROTECT = 20,3,1,0 %;       ! KNOWN FILE WAS INSTALLED PROTECTED 
macro KFI$V_LIM = 20,6,1,0 %;           ! LINKABLE IMAGE 
macro KFI$V_PROCPRIV = 20,7,1,0 %;      ! USE PROCESS PRIVILEGE MASK 
macro KFI$V_IS_RESHDR = 20,8,1,0 %;     ! IMAGE HEADER BLOCK IS RESIDENT 
macro KFI$V_IS_SHARED = 20,9,1,0 %;     ! IMAGE IS SHARED 
macro KFI$V_SHMIDENT = 20,14,1,0 %;     ! SHARED MEMORY IDENT ALREADY SET 
macro KFI$V_COMPATMOD = 20,15,1,0 %;    ! IMAGE IS COMPATABILITY MODE 
macro KFI$W_GBLSECCNT = 22,0,16,0 %;    ! GLOBAL SECTION COUNT IF SHARED 
macro KFI$L_USECNT = 24,0,32,0 %;       ! USAGE COUNTER 
macro KFI$L_WINDOW = 28,0,32,0 %;       ! WCB ADDRESS IF OPEN 
macro KFI$W_FID = 28,0,16,0 %;          ! FILE ID 
macro KFI$W_FID_NUM = 28,0,16,0 %;      ! FILE NUMBER FIELD OF FILE ID 
macro KFI$W_FID_SEQ = 30,0,16,0 %;      ! FILE SEQUENCE NUMBER FIELD OF FILE ID 
macro KFI$L_IMGHDR = 32,0,32,0 %;       ! IMAGE HEADER ADDRESS IF RESIDENT 
macro KFI$W_FID_RVN = 32,0,16,0 %;      ! RELATIVE VOLUME NUMBER FIELD OF FILE ID 
macro KFI$Q_PROCPRIV = 36,0,0,0 %;
literal KFI$S_PROCPRIV = 8;             ! PROCESS PRIVILEGE MASK 
macro KFI$B_MATCHCTL = 44,0,8,0 %;      ! GLOBAL SECTION MATCH CONTROL 
macro KFI$W_AMECOD = 46,0,16,0 %;       ! IMAGE HEADER CODE SPECIFYING AME 
macro KFI$L_IDENT = 48,0,32,0 %;        ! GLOBAL SECTION IDENT VALUE 
 
!*** MODULE $KFPDEF ***
! 
!  KNOWN FILE POINTER BLOCK DEFINITIONS 	*** obsolete, to be removed ***
! 
literal KFP$S_KFPDEF = 16;
macro KFP$B_QUECOUNT = 0,0,8,0 %;       ! INDEX OF LAST KNOWN FILE LIST IN USE 
macro KFP$W_SIZE = 8,0,16,0 %;          ! SIZE OF POINTER BLOCK IN BYTES 
macro KFP$B_TYPE = 10,0,8,0 %;          ! POINTER BLOCK TYPE 
macro KFP$B_TYPE1 = 11,0,8,0 %;         ! TYPE OF STRUCTURE POINTED TO 
macro KFP$L_QUE0 = 12,0,32,0 %;         ! POINTER TO KNOWN FILE QUEUE 0 
 
!*** MODULE $KFPBDEF ***
! 
!  KNOWN FILE POINTER BLOCK DEFINITIONS
! 
literal KFPB$K_LENGTH = 16;             !  Length of pointer block
literal KFPB$C_LENGTH = 16;             !  Length of pointer block
literal KFPB$S_KFPBDEF = 16;
macro KFPB$L_KFDLST = 0,0,32,0 %;       !  Device, Directory, Extension (KFD) list link
macro KFPB$L_KFEHSHTAB = 4,0,32,0 %;    !  Address of Known file name hash table
macro KFPB$W_SIZE = 8,0,16,0 %;         !  Size of pointer block in bytes 
macro KFPB$B_TYPE = 10,0,8,0 %;         !  Pointer block type 
macro KFPB$B_SPARE = 11,0,8,0 %;        !  spare byte
macro KFPB$W_KFDLSTCNT = 12,0,16,0 %;   !  Number of entries in KFD list
macro KFPB$W_HSHTABLEN = 14,0,16,0 %;   !  Length of Hash table
 
!*** MODULE $KFRHDEF ***
! 
!  KNOWN FILE RESIDENT IMAGE HEADER DEFINITIONS
! 
literal KFRH$K_LENGTH = 12;             !  Length of overhead area 
literal KFRH$C_LENGTH = 12;             !  Length of overhead area 
literal KFRH$S_KFRHDEF = 12;
macro KFRH$L_BUFEND = 0,0,32,0 %;       !  Address of end of known file header 
macro KFRH$W_ALIAS = 4,0,16,0 %;        !  Use secondary name on activation
macro KFRH$W_SIZE = 8,0,16,0 %;         !  Size of dynamic structure 
macro KFRH$B_TYPE = 10,0,8,0 %;         !  Dynamic structure type 
macro KFRH$B_HDRVER = 11,0,8,0 %;       !  Image header version
macro KFRH$T_IHD = 12,0,0,0 %;          !  Offset to decoded Image Header
! 
!  THE REMAINDER OF THIS STRUCTURE CONTAINS THE IMAGE HEADER OF THE
!  SPECIFIED KNOWN FILE.  THE LOCATION KFE$L_IMGHDR IN THE KNOWN FILE
!  ENTRY POINTS KFRH$C_LENGTH INTO THIS STRUCTURE, I.E AT THE IMAGE HEADER
!  ITSELF.
! 
 
!*** MODULE $L1701DEF ***
! +
!   This file contains offset definitions for registers accessible through LSB
!   private space on the Laser/Neon processor.  Note that in making these 
!   registers available in virtual space, we have only mapped real registers.  
!   Therefore these virtual offsets are different than the hardware physical 
!   offsets.
! -
literal L1701_WR0$C_NULL = 0;           !  Null Code
literal L1701_WR0$C_HIGH_GRP = 1;       !  Point to High Register Group
literal L1701_WR0$C_RESET = 2;          !  Reset Ext/Status Interrupts
literal L1701_WR0$C_ABORT = 3;          !  Send Abort
literal L1701_WR0$C_EN_RX_INT = 4;      !  Enable Intr on next RX char
literal L1701_WR0$C_RES_TX_INT = 5;     !  Reset TX Intr Pending
literal L1701_WR0$C_ERR_RES = 6;        !  Error Reset
literal L1701_WR0$C_RES_IUS = 7;        !  Reset Highest IUS
literal L1701_WR0$C_RES_RX_CRC = 1;     !  Reset RX CRC Checker
literal L1701_WR0$C_RES_TX_CRC = 2;     !  Reset TX CRC Checker
literal L1701_WR0$C_RES_TX_EOM = 3;     !  Reset TX Underrun/EOM Latch
literal L1701_RR0$M_RXAV = 1;
literal L1701_RR0$M_ZC = 2;
literal L1701_RR0$M_TXEM = 4;
literal L1701_RR0$M_DCD = 8;
literal L1701_RR0$M_SH = 16;
literal L1701_RR0$M_CTS = 32;
literal L1701_RR0$M_TXUREOM = 64;
literal L1701_RR0$M_BA = 128;
literal L1701_CSRA$M_UIP = 128;
literal L1701_CSRB$M_DSE = 1;
literal L1701_CSRB$M_HR_MODE = 2;
literal L1701_CSRB$M_DM = 4;
literal L1701_CSRB$M_SQWE = 8;
literal L1701_CSRB$M_UIE = 16;
literal L1701_CSRB$M_AIE = 32;
literal L1701_CSRB$M_PIE = 64;
literal L1701_CSRB$M_SET = 128;
literal L1701_CSRC$M_UF = 16;
literal L1701_CSRC$M_AF = 32;
literal L1701_CSRC$M_PF = 64;
literal L1701_CSRC$M_IRQF = 128;
literal L1701_CSRD$M_VRT = 128;
literal L1701_WHAMI$M_MFG = 8;
literal L1701_WHAMI$M_LSB_BAD = 16;
literal L1701_WHAMI$M_LSB_CONWIN = 32;
literal L1701_LEDS$M_STP = 1;
literal L1701_LEDS$M_LCW = 2;
literal L1701_LEDS$M_RUN = 4;
literal L1701_LEDS$M_LED3 = 8;
literal L1701_LEDS$M_LED4 = 16;
literal L1701_LEDS$M_LED5 = 32;
literal L1701_LEDS$M_LED6 = 64;
literal L1701_LEDS$M_LED7 = 128;
literal L1701_PMASK$M_HALT_EN = 1;
literal L1701_PMASK$M_PHALT_EN = 8;
literal L1701_INTR$M_DUART0 = 1;
literal L1701_INTR$M_DUART1 = 2;
literal L1701_INTR$M_LSB0 = 4;
literal L1701_INTR$M_LSB1 = 8;
literal L1701_INTR$M_LSB2 = 32;
literal L1701_INTR$M_IP = 64;
literal L1701_INTR$M_INTIM = 128;
literal L1701_HALT$M_NHALT = 8;
literal L1701_HALT$M_LSB_SECURE = 16;
literal L1701_HALT$M_CTL_P_HALT = 256;
literal L1701$C_VIRT_CSR_LEN = 3584;    !  Length of virtual CSR mapping
literal L1701$S_L1701DEF = 3584;
! *****************************************************************************/
!  Page 0                                                                     */
! *****************************************************************************/
!  Console UART 0
macro L1701$L_UART0B_WR0 = 0,0,0,0 %;
literal L1701$S_UART0B_WR0 = 64;        !  UART0B$WR0
macro L1701_WR0$V_REG_GRP = 0,0,3,0 %;
literal L1701_WR0$S_REG_GRP = 3;        !  Register Selected
macro L1701_WR0$V_FUNCT = 0,3,3,0 %;
literal L1701_WR0$S_FUNCT = 3;          !  Function Code
!  
macro L1701_WR0$V_RESET_MODE = 0,6,2,0 %;
literal L1701_WR0$S_RESET_MODE = 2;     !  Reset Mode
!  
macro L1701$L_UART0B_RR0 = 0,0,0,0 %;
literal L1701$S_UART0B_RR0 = 64;        !  UART0B$RR0
macro L1701_RR0$V_RXAV = 0,0,1,0 %;     !  RX Character Available
macro L1701_RR0$V_ZC = 0,1,1,0 %;       !  Zero Count
macro L1701_RR0$V_TXEM = 0,2,1,0 %;     !  TX Buffer Empty
macro L1701_RR0$V_DCD = 0,3,1,0 %;      !  DCD
macro L1701_RR0$V_SH = 0,4,1,0 %;       !  Sync/Hunt
macro L1701_RR0$V_CTS = 0,5,1,0 %;      !  Clear to Send
macro L1701_RR0$V_TXUREOM = 0,6,1,0 %;  !  TX Underrun or EOM
macro L1701_RR0$V_BA = 0,7,1,0 %;       !  Break and/or Abort
macro L1701$L_UART0B_WR8 = 64,0,0,0 %;
literal L1701$S_UART0B_WR8 = 64;        !  UART0B$WR8 (Transmit Data)
macro L1701$L_UART0B_RR8 = 64,0,0,0 %;
literal L1701$S_UART0B_RR8 = 64;        !  UART0B$RR8 (Receive Data)
macro L1701$L_UART0A_WR0 = 128,0,0,0 %;
literal L1701$S_UART0A_WR0 = 64;        !  UART0A$WR0 (See UART0B$WR0)
macro L1701$L_UART0A_RR0 = 128,0,0,0 %;
literal L1701$S_UART0A_RR0 = 64;        !  UART0B$RR0 (See UART0B$RR0)
macro L1701$L_UART0A_WR8 = 192,0,0,0 %;
literal L1701$S_UART0A_WR8 = 64;        !  UART0A$WR8 (Transmit Data)
macro L1701$L_UART0A_RR8 = 192,0,0,0 %;
literal L1701$S_UART0A_RR8 = 64;        !  UART0A$RR8 (Receive Data)
! *****************************************************************************/
!  Page 1                                                                     */
! *****************************************************************************/
!  Console UART 1
macro L1701$L_UART1B_WR0 = 512,0,0,0 %;
literal L1701$S_UART1B_WR0 = 64;        !  UART1B$WR0
macro L1701$L_UART1B_RR0 = 512,0,0,0 %;
literal L1701$S_UART1B_RR0 = 64;        !  UART1B$RR0
macro L1701$L_UART1B_WR8 = 576,0,0,0 %;
literal L1701$S_UART1B_WR8 = 64;        !  UART1B$WR8 (Transmit Data)
macro L1701$L_UART1B_RR8 = 576,0,0,0 %;
literal L1701$S_UART1B_RR8 = 64;        !  UART1B$RR8 (Receive Data)
macro L1701$L_UART1A_WR0 = 640,0,32,0 %; !  UART1A$WR0 (See UART0B$WR0)
macro L1701$L_UART1A_RR0 = 640,0,32,0 %; !  UART1A$RR0 (See UART0B$RR0)
macro L1701$L_UART1A_WR8 = 704,0,0,0 %;
literal L1701$S_UART1A_WR8 = 64;        !  UART1A$WR8 (Transmit Data)
macro L1701$L_UART1A_RR8 = 704,0,0,0 %;
literal L1701$S_UART1A_RR8 = 64;        !  UART1A$RR8 (Receive Data)
! *****************************************************************************/
!  Page 2                                                                     */
! *****************************************************************************/
!  Console UART 2
macro L1701$L_UART2B_WR0 = 1024,0,0,0 %;
literal L1701$S_UART2B_WR0 = 64;        !  UART2B$WR0
macro L1701$L_UART2B_RR0 = 1024,0,0,0 %;
literal L1701$S_UART2B_RR0 = 64;        !  UART2B$RR0
macro L1701$L_UART2B_WR8 = 1088,0,0,0 %;
literal L1701$S_UART2B_WR8 = 64;        !  UART2B$WR8 (Transmit Data)
macro L1701$L_UART2B_RR8 = 1088,0,0,0 %;
literal L1701$S_UART2B_RR8 = 64;        !  UART2B$RR8 (Receive Data)
macro L1701$L_UART2A_WR0 = 1152,0,0,0 %;
literal L1701$S_UART2A_WR0 = 64;        !  UART2A$WR0 (See UART0B$WR0)
macro L1701$L_UART2A_RR0 = 1152,0,0,0 %;
literal L1701$S_UART2A_RR0 = 64;        !  UART2A$RR0 (See UART0B$RR0)
macro L1701$L_UART2A_WR8 = 1216,0,0,0 %;
literal L1701$S_UART2A_WR8 = 64;        !  UART2A$WR8 (Transmit Data)
macro L1701$L_UART2A_RR8 = 1216,0,0,0 %;
literal L1701$S_UART2A_RR8 = 64;        !  UART2A$RR8 (Receive Data)
! *****************************************************************************/
!  Pages 3-4                                                                  */
! *****************************************************************************/
!  Watch Chip
macro L1701$L_SECONDS = 1536,0,0,0 %;
literal L1701$S_SECONDS = 64;           !  Seconds
macro L1701$L_MINUTES = 1664,0,0,0 %;
literal L1701$S_MINUTES = 64;           !  Minutes
macro L1701$L_HOURS = 1792,0,0,0 %;
literal L1701$S_HOURS = 64;             !  Housrs
macro L1701$L_DAY_OF_MONTH = 1920,0,0,0 %;
literal L1701$S_DAY_OF_MONTH = 64;      !  Day of Month (0:31)
macro L1701$L_MONTH = 1984,0,0,0 %;
literal L1701$S_MONTH = 64;             !  Month (1:12)
macro L1701$L_YEAR = 2048,0,0,0 %;
literal L1701$S_YEAR = 64;              !  Year (0:99)
macro L1701$L_CSRA = 2112,0,0,0 %;
literal L1701$S_CSRA = 64;              !  CSRA
macro L1701_CSRA$V_RS = 2112,0,4,0 %;
literal L1701_CSRA$S_RS = 4;            !  Rate Select
macro L1701_CSRA$V_DV = 2112,4,3,0 %;
literal L1701_CSRA$S_DV = 3;            !  Divider Select
macro L1701_CSRA$V_UIP = 2112,7,1,0 %;  !  Update in Progress
macro L1701$L_CSRB = 2176,0,0,0 %;
literal L1701$S_CSRB = 64;              !  CSRB
macro L1701_CSRB$V_DSE = 2176,0,1,0 %;  !  Daylight Savings Enable
macro L1701_CSRB$V_HR_MODE = 2176,1,1,0 %; !  Hour Mode
macro L1701_CSRB$V_DM = 2176,2,1,0 %;   !  Data Mode
macro L1701_CSRB$V_SQWE = 2176,3,1,0 %; !  Square Wave Enable
macro L1701_CSRB$V_UIE = 2176,4,1,0 %;  !  Update Ended Interrupt Enable
macro L1701_CSRB$V_AIE = 2176,5,1,0 %;  !  Alarm Interrupt Enable
macro L1701_CSRB$V_PIE = 2176,6,1,0 %;  !  Periodic Interrupt Enable
macro L1701_CSRB$V_SET = 2176,7,1,0 %;  !  Set Mode
macro L1701$L_CSRC = 2240,0,0,0 %;
literal L1701$S_CSRC = 64;              !  CSRC
macro L1701DEF$$_RSVD0 = 2240,0,4,0 %;
literal L1701DEFS_RSVD0 = 4;            !  Reserved
macro L1701_CSRC$V_UF = 2240,4,1,0 %;   !  Update Interrupt Flag
macro L1701_CSRC$V_AF = 2240,5,1,0 %;   !  Alarm Interrupt Flag
macro L1701_CSRC$V_PF = 2240,6,1,0 %;   !  Periodic Interrupt Flag
macro L1701_CSRC$V_IRQF = 2240,7,1,0 %; !  Logical OR of UF, AF, PF
macro L1701$L_CSRD = 2304,0,0,0 %;
literal L1701$S_CSRD = 64;              !  CSRD
macro L1701DEF$$_RSVD1 = 2304,0,7,0 %;
literal L1701DEFS_RSVD1 = 7;            !  Reserved
macro L1701_CSRD$V_VRT = 2304,7,1,0 %;  !  Valid RAM Time
! *****************************************************************************/
!  Page 5                                                                     */
! *****************************************************************************/
!  Garbage Bus (GBus)
macro L1701$L_WHAMI = 2560,0,0,0 %;
literal L1701$S_WHAMI = 64;             !  CPU ID register
macro L1701_WHAMI$V_NID = 2560,0,3,0 %;
literal L1701_WHAMI$S_NID = 3;          !  LSB Node ID
macro L1701_WHAMI$V_MFG = 2560,3,1,0 %; !  Manufacturing Status
macro L1701_WHAMI$V_LSB_BAD = 2560,4,1,0 %; !  LSB BAD signal
macro L1701_WHAMI$V_LSB_CONWIN = 2560,5,1,0 %; !  LSB console win
macro L1701DEF_WHAMI$$_RSVD = 2560,6,2,0 %;
literal L1701DEF_WHAMIS_RSVD = 2;       !  Reserved
macro L1701$L_LEDS = 2624,0,0,0 %;
literal L1701$S_LEDS = 64;              !  CPU module LEDS
macro L1701_LEDS$V_STP = 2624,0,1,0 %;  !  Self-Test Passed
macro L1701_LEDS$V_LCW = 2624,1,1,0 %;  !  Laser Console Win
macro L1701_LEDS$V_RUN = 2624,2,1,0 %;  !  Run
macro L1701_LEDS$V_LED3 = 2624,3,1,0 %; !  LED 3
macro L1701_LEDS$V_LED4 = 2624,4,1,0 %; !  LED 4
macro L1701_LEDS$V_LED5 = 2624,5,1,0 %; !  LED 5
macro L1701_LEDS$V_LED6 = 2624,6,1,0 %; !  LED 6
macro L1701_LEDS$V_LED7 = 2624,7,1,0 %; !  LED 7
macro L1701$L_PMASK = 2688,0,0,0 %;
literal L1701$S_PMASK = 64;             !  PMASK
macro L1701_PMASK$V_HALT_EN = 2688,0,1,0 %; !  Halt Enable
macro L1701_PMASK$V_SEL_CONS_TERM = 2688,1,2,0 %;
literal L1701_PMASK$S_SEL_CONS_TERM = 2; !  Select Console Terminal
macro L1701_PMASK$V_PHALT_EN = 2688,3,1,0 %; !  Control P Halt Enable
macro L1701DEF_PMASK$$_RSVD = 2688,4,4,0 %;
literal L1701DEF_PMASKS_RSVD = 4;       !  Reserved
macro L1701$L_INTR = 2752,0,0,0 %;
literal L1701$S_INTR = 64;              !  Interrupt Status
macro L1701_INTR$V_DUART0 = 2752,0,1,0 %; !  UART0 interrupt request
macro L1701_INTR$V_DUART1 = 2752,1,1,0 %; !  UART1 interrupt request
macro L1701_INTR$V_LSB0 = 2752,2,1,0 %; !  LSB Level 0 interrupt request
macro L1701_INTR$V_LSB1 = 2752,3,1,0 %; !  LSB Level 1 interrupt request
macro L1701DEF_INTR$$_RSVD = 2752,4,1,0 %; !  Reserved
macro L1701_INTR$V_LSB2 = 2752,5,1,0 %; !  LSB Level 2 interrupt request
macro L1701_INTR$V_IP = 2752,6,1,0 %;   !  LIPINTR for this CPU Node
macro L1701_INTR$V_INTIM = 2752,7,1,0 %; !  Intim
macro L1701$L_HALT = 2816,0,0,0 %;
literal L1701$S_HALT = 64;              !  HALT Conditions
macro L1701DEF_HALT$$_RSVD0 = 2816,0,3,0 %;
literal L1701DEF_HALTS_RSVD0 = 3;       !  Reserved
macro L1701_HALT$V_NHALT = 2816,3,1,0 %; !  NHalt bit in LCNR of LEVI-A
macro L1701_HALT$V_LSB_SECURE = 2816,4,1,0 %; !  PIU Secondary Status
macro L1701DEF_HALT$$_RSVD1 = 2816,5,3,0 %;
literal L1701DEF_HALTS_RSVD1 = 3;       !  Reserved
macro L1701_HALT$V_CTL_P_HALT = 2816,8,1,0 %; !  Control-P received
macro L1701DEF_HALT$$_RSVD2 = 2816,9,1,0 %; !  Reserved
macro L1701$L_LSBRST = 2880,0,0,0 %;
literal L1701$S_LSBRST = 64;            !  System-wide Reset
macro L1701$L_MISC = 2944,0,0,0 %;
literal L1701$S_MISC = 64;              !  MISC System Functions
macro L1701_MISC$V_EXPSEL = 2944,0,2,0 %;
literal L1701_MISC$S_EXPSEL = 2;        !  Expander Select
macro L1701DEF_MISC$$_RSVD = 2944,2,6,0 %;
literal L1701DEF_MISCS_RSVD = 6;        !  Reserved
! *****************************************************************************/
!  Page 6                                                                     */
! *****************************************************************************/
!  Broadcast Space
macro L1701$L_LIOINTR = 3072,0,0,0 %;
literal L1701$S_LIOINTR = 64;           !  LSB I/O Interrupt Register
macro L1701$V_CPU0 = 3072,0,4,0 %;
literal L1701$S_CPU0 = 4;               !  CPU0 Interrupt Levels
macro L1701$V_CPU1 = 3072,4,4,0 %;
literal L1701$S_CPU1 = 4;               !  CPU1 Interrupt Levels
macro L1701$V_CPU2 = 3072,8,4,0 %;
literal L1701$S_CPU2 = 4;               !  CPU2 Interrupt Levels
macro L1701$V_CPU3 = 3072,12,4,0 %;
literal L1701$S_CPU3 = 4;               !  CPU3 Interrupt Levels
macro L1701DEF_LIOINTR$$_RSVD = 3072,16,16,0 %;
literal L1701DEF_LIOINTRS_RSVD = 16;    !  Reserved
macro L1701$L_LIPINTR = 3136,0,0,0 %;
literal L1701$S_LIPINTR = 64;           !  LSB IP Interrupt Register
macro L1701$V_MASK = 3136,0,16,0 %;
literal L1701$S_MASK = 16;              !  I/O device/adapter vector
macro L1701DEF_LIPINTR$$_RSVD = 3136,16,16,0 %;
literal L1701DEF_LIPINTRS_RSVD = 16;    !  Reserved
 
!*** MODULE $LAMBDEF ***
!  LAMB registers visible from LSB only (these appear in XMI Private Space
!  and must be accessed via Mailbox transactions).  The LAMB also maps XMI
!  required registers into the same offsets in XMI Private Space.
literal LAMB$M_F39 = 256;
literal LAMB$M_STE = 512;
literal LAMB$M_FXA = 1024;
literal LAMB$M_DRNK = 16384;
literal LAMB$M_CRE = 1048576;
literal LAMB$M_LOOP = 8388608;
literal LAMB$M_LOCK = 16777216;
literal LAMB$M_AS = 33554432;
literal LAMB$M_IMBER = 16;
literal LAMB$M_IRBDPE = 32;
literal LAMB$M_IDFDPE = 64;
literal LAMB$M_ITTO = 8192;
literal LAMB$M_ICNAK = 32768;
literal LAMB$M_IRER = 65536;
literal LAMB$M_IRSE = 131072;
literal LAMB$M_INRR = 262144;
literal LAMB$M_ICRD = 524288;
literal LAMB$M_IWDNAK = 1048576;
literal LAMB$M_IRIDNAK = 2097152;
literal LAMB$M_IWSE = 4194304;
literal LAMB$M_IXPE = 8388608;
literal LAMB$M_IIPE = 16777216;
literal LAMB$M_IWEI = 33554432;
literal LAMB$M_ICC = 134217728;
literal LAMB$M_FE = 8;
literal LAMB$M_MBOF = 16;
literal LAMB$M_RBDPE = 32;
literal LAMB$M_DFDPE = 64;
literal LAMB$M_MBIA = 4096;
literal LAMB$M_MBIC = 8192;
literal LAMB$M_MBPE = 16384;
literal LAMB$M_DHDPE = 268435456;
literal LAMB$AL_XMI_IOSP_HIGH = 128;    !  High longword of XMI addresses
literal LAMB$AL_XMI_PRIVSP_LOW = 0;     !  Base of XMI private space
literal LAMB$AL_XMI_NODESP_LOW = 25165824; !  Base of XMI nodespaces
literal LAMB$C_XMI_NODESP_SIZ = 524288; !  Size of each 512 Kb nodespace
literal LAMB$AL_XMI_IOADAP_LOW = 33554432; !  Base of I/O Adapter windows
literal LAMB$C_XMI_IOADAP_SIZ = 33554432; !  Size of each 32 Mb window
literal LAMB$C_XMI_NODES = 16;          !  Number of XMI nodes per XMI bus
literal LAMB$S_XMI_REGISTER = 19;       !  Size of XMI register field
!  BI I/O Space definitions ("remote" I/O space)
literal LAMB$C_BI_NODESP_SIZ = 8192;    !  Size of each 8 Kb nodespace
literal LAMB$C_BI_WINDSP_OFS = 4194304; !  Offset to window space
literal LAMB$C_BI_WINDSP_SIZ = 262144;  !  Size of each 8 Mb window
literal LAMB$C_BI_NODES = 16;           !  Number of BI nodes per BI bus
!  LAMB command codes
literal LAMB$C_READ_CSR = 1;            !  READ CSR command
literal LAMB$C_WRITE_CSR = 7;           !  WRITE CSR command
literal LAMB$S_LAMBDEF = 96;
macro LAMB$L_LDIAG = 64,0,32,0 %;       !  LAMB Diagnostic Register
macro LAMBDEF_LDIAG$$_RSVD0 = 64,0,8,0 %;
literal LAMBDEF_LDIAGS_RSVD0 = 8;       !  Reserved
macro LAMB$V_F39 = 64,8,1,0 %;          !  Force Address bit 39 to ONE
macro LAMB$V_STE = 64,9,1,0 %;          !  Short XMI Timeout Enable
macro LAMB$V_FXA = 64,10,1,0 %;         !  Force XMI Register Access
macro LAMB$V_ASM = 64,11,2,0 %;
literal LAMB$S_ASM = 2;                 !  Arb Suppress Modes
macro LAMBDEF_LDIAG$$_RSVD1 = 64,13,1,0 %; !  Reserved
macro LAMB$V_DRNK = 64,14,1,0 %;        !  Disable Retries on NOACK	
macro LAMBDEF_LDIAG$$_RSVD2 = 64,15,1,0 %; !  Reserved
macro LAMB$V_FPE = 64,16,4,0 %;
literal LAMB$S_FPE = 4;                 !  Force Parity Errors
macro LAMB$V_CRE = 64,20,1,0 %;         !  Commander Request Enable
macro LAMB$V_FRRM = 64,21,2,0 %;
literal LAMB$S_FRRM = 2;                !  Force Read Response
macro LAMB$V_LOOP = 64,23,1,0 %;        !  DMA Loop Back Mode
macro LAMB$V_LOCK = 64,24,1,0 %;        !  Status of LOCKOUT
macro LAMB$V_AS = 64,25,1,0 %;          !  Status of Arb Suppress
macro LAMB$V_DLLF = 64,26,2,0 %;
literal LAMB$S_DLLF = 2;                !  DMA Loop Back Length Field
macro LAMB$V_NODE = 64,28,4,0 %;
literal LAMB$S_NODE = 4;                !  XMI Node ID of LAMB
macro LAMB$L_IMSK = 68,0,32,0 %;        !  LAMB Interrupt Mask Register
macro LAMBDEF_IMSK$$_RSVD0 = 68,0,4,0 %;
literal LAMBDEF_IMSKS_RSVD0 = 4;        !  Reserved
macro LAMB$V_IMBER = 68,4,1,0 %;        !  Interrupt on Mailbox Errors (MBOF, MBPE, MBIC, MBIA)
macro LAMB$V_IRBDPE = 68,5,1,0 %;       !  Read Buffer Data Parity Err
macro LAMB$V_IDFDPE = 68,6,1,0 %;       !  Data FIFO Data Field Par Err
macro LAMBDEF_IMSK$$_RSVD1 = 68,7,6,0 %;
literal LAMBDEF_IMSKS_RSVD1 = 6;        !  Reserved
macro LAMB$V_ITTO = 68,13,1,0 %;        !  Transaction Timeout
macro LAMBDEF_IMSK$$_RSVD2 = 68,14,1,0 %; !  Reserved
macro LAMB$V_ICNAK = 68,15,1,0 %;       !  Command NOACK
macro LAMB$V_IRER = 68,16,1,0 %;        !  Read Error Response
macro LAMB$V_IRSE = 68,17,1,0 %;        !  Read Sequence Error
macro LAMB$V_INRR = 68,18,1,0 %;        !  No Read Response
macro LAMB$V_ICRD = 68,19,1,0 %;        !  Corrected Read Data
macro LAMB$V_IWDNAK = 68,20,1,0 %;      !  Write Data NOACK
macro LAMB$V_IRIDNAK = 68,21,1,0 %;     !  Write Data NOACK
macro LAMB$V_IWSE = 68,22,1,0 %;        !  Write Sequence Error
macro LAMB$V_IXPE = 68,23,1,0 %;        !  XMI Parity Error
macro LAMB$V_IIPE = 68,24,1,0 %;        !  XMI Inconsistent Parity Error
macro LAMB$V_IWEI = 68,25,1,0 %;        !  Interrupt on Write Error Interrupt
macro LAMBDEF_IMSK$$_RSVD3 = 68,26,1,0 %; !  Reserved
macro LAMB$V_ICC = 68,27,1,0 %;         !  Correct Confirmation Error
macro LAMBDEF_IMSK$$_RSVD4 = 68,28,4,0 %;
literal LAMBDEF_IMSKS_RSVD4 = 4;        !  Reserved
macro LAMB$L_LEVR = 72,0,32,0 %;        !  LAMB Error Vector Register
macro LAMB$V_VEC = 72,0,16,0 %;
literal LAMB$S_VEC = 16;                !  SCB Vector
macro LAMBDEF_LEVR$$_RSVD = 72,16,16,0 %;
literal LAMBDEF_LEVRS_RSVD = 16;        !  Reserved
macro LAMB$L_LERR = 76,0,32,0 %;        !  LAMB Error Register
macro LAMBDEF_LERR$$_RSVD0 = 76,0,3,0 %;
literal LAMBDEF_LERRS_RSVD0 = 3;        !  Reserved
macro LAMB$V_FE = 76,3,1,0 %;           !  Fatal Error
macro LAMB$V_MBOF = 76,4,1,0 %;         !  Mailbox Overflow
macro LAMB$V_RBDPE = 76,5,1,0 %;        !  Read Buffer Data Parity Error
macro LAMB$V_DFDPE = 76,6,1,0 %;        !  Data FIFO Data Field Par Err
macro LAMBDEF_LERR$$_RSVD1 = 76,7,5,0 %;
literal LAMBDEF_LERRS_RSVD1 = 5;        !  Reserved
macro LAMB$V_MBIA = 76,12,1,0 %;        !  Mailbox Illegal Address
macro LAMB$V_MBIC = 76,13,1,0 %;        !  Mailbox Illegal Command
macro LAMB$V_MBPE = 76,14,1,0 %;        !  Mailbox Parity Error
macro LAMB$V_IVID = 76,15,4,0 %;
literal LAMB$S_IVID = 4;                !  INVINTR Source ID
macro LAMBDEF_LERR$$_RSVD2 = 76,19,9,0 %;
literal LAMBDEF_LERRS_RSVD2 = 9;        !  Reserved
macro LAMB$V_DHDPE = 76,28,1,0 %;       !  DOWN Hose Data Parity Error
macro LAMB$V_XMIPE = 76,29,3,0 %;
literal LAMB$S_XMIPE = 3;               !  Parity Bit Which Failed
macro LAMB$L_LGPR = 80,0,32,0 %;        !  LAMB General Purpose Register
macro LAMB$L_IPR1 = 84,0,32,0 %;        !  LAMB Interrupt Pending Reg 1
macro LAMB$V_IP1 = 84,0,4,0 %;
literal LAMB$S_IP1 = 4;                 !  Interrupt Pending Bits Node 1
macro LAMB$V_IP2 = 84,4,4,0 %;
literal LAMB$S_IP2 = 4;                 !  Interrupt Pending Bits Node 2
macro LAMB$V_IP3 = 84,8,4,0 %;
literal LAMB$S_IP3 = 4;                 !  Interrupt Pending Bits Node 3
macro LAMB$V_IP4 = 84,12,4,0 %;
literal LAMB$S_IP4 = 4;                 !  Interrupt Pending Bits Node 4
macro LAMB$V_IP5 = 84,16,4,0 %;
literal LAMB$S_IP5 = 4;                 !  Interrupt Pending Bits Node 5
macro LAMB$V_IP6 = 84,20,4,0 %;
literal LAMB$S_IP6 = 4;                 !  Interrupt Pending Bits Node 6
macro LAMB$V_IP7 = 84,24,4,0 %;
literal LAMB$S_IP7 = 4;                 !  Interrupt Pending Bits Node 7
macro LAMB$V_IP8 = 84,28,4,0 %;
literal LAMB$S_IP8 = 4;                 !  Interrupt Pending Bits Node 8
macro LAMB$L_IPR2 = 88,0,32,0 %;        !  LAMB Interrupt Pending Reg 2
macro LAMB$V_IP9 = 88,0,4,0 %;
literal LAMB$S_IP9 = 4;                 !  Interrupt Pending Bits Node 9
macro LAMB$V_IP10 = 88,4,4,0 %;
literal LAMB$S_IP10 = 4;                !  Interrupt Pending Bits Node 10
macro LAMB$V_IP11 = 88,8,4,0 %;
literal LAMB$S_IP11 = 4;                !  Interrupt Pending Bits Node 11
macro LAMB$V_IP12 = 88,12,4,0 %;
literal LAMB$S_IP12 = 4;                !  Interrupt Pending Bits Node 12
macro LAMB$V_IP13 = 88,16,4,0 %;
literal LAMB$S_IP13 = 4;                !  Interrupt Pending Bits Node 13
macro LAMB$V_IP14 = 88,20,4,0 %;
literal LAMB$S_IP14 = 4;                !  Interrupt Pending Bits Node 14
macro LAMBDEF_IPR2$$_RSVD = 88,24,7,0 %;
literal LAMBDEF_IPR2S_RSVD = 7;         !  Reserved
macro LAMB$V_LEIP = 88,31,1,0 %;        !  LAMB Error Interrupt Pending
macro LAMB$L_IIPR = 92,0,32,0 %;        !  LAMB Interrupt In Progress Reg
macro LAMB$V_IPL14ID = 92,0,4,0 %;
literal LAMB$S_IPL14ID = 4;             !  Node ID of int in progress IPL 14
macro LAMB$V_IPL15ID = 92,4,4,0 %;
literal LAMB$S_IPL15ID = 4;             !  Node ID of int in progress IPL 15
macro LAMB$V_IPL16ID = 92,8,4,0 %;
literal LAMB$S_IPL16ID = 4;             !  Node ID of int in progress IPL 16
macro LAMB$V_IPL17ID = 92,12,4,0 %;
literal LAMB$S_IPL17ID = 4;             !  Node ID of int in progress IPL 17
macro LAMB$V_IDENTID = 92,16,4,0 %;
literal LAMB$S_IDENTID = 4;             !  Node ID of IDENT in progress
macro LAMBDEF_IIPR$$_RSVD = 92,20,12,0 %;
literal LAMBDEF_IIPRS_RSVD = 12;        !  Reserved
!  The Laser I/O Processor (IOP) connects to up to four remote bus adapters,
!  such as the Laser IOP to XMI bus adapter (LAMB).  XMI address space is not
!  directly accessible to the Neon CPU; instead, references to I/O space are
!  made via a hardware mailbox mechanism.  The remote bus address is specified
!  in the mailbox structure as a 64-bit quantity.  Since SDL (and MACRO) are
!  not able to handle symbolic definitions larger than 32 bits, the 40-bit
!  XMI addresses are treated as a pair of high- and low-order longwords; the
!  appropriate definitions are made below.
! 
!  THESE DEFINITIONS ARE LAMB-SPECIFIC AND DO NOT BELONG IN $IO17xxDEF!
!  XMI I/O Space definitions ("remote" I/O space)
 
!*** MODULE $LCKCTXDEF ***
! +
!  LCKCTX - LOCK CONTEXT BLOCK
! 
! -
literal LCKCTX$M_BUSY = 1;
literal LCKCTX$M_CANCEL = 2;
literal LCKCTX$M_CMP_RQD = 4;
literal LCKCTX$K_FIX_LEN = 56;          !  FIXED LENGTH
literal LCKCTX$C_FIX_LEN = 56;          !  FIXED LENGTH
literal LCKCTX$S_LCKCTXDEF = 57;
macro LCKCTX$L_FQFL = 0,0,32,0 %;       !  FORWARD LINK
macro LCKCTX$L_FQBL = 4,0,32,0 %;       !  BACKWARD LINK
macro LCKCTX$W_SIZE = 8,0,16,0 %;       !  SIZE
macro LCKCTX$B_TYPE = 10,0,8,0 %;       !  TYPE
macro LCKCTX$B_FLCK = 11,0,8,0 %;       !  FORK LOCK
macro LCKCTX$L_FPC = 12,0,32,0 %;       !  FORK PC
macro LCKCTX$L_FR3 = 16,0,32,0 %;       !  FORK R3
macro LCKCTX$L_FR4 = 20,0,32,0 %;       !  FORK R4
macro LCKCTX$L_FLAGS = 24,0,32,0 %;     !  FLAGS
macro LCKCTX$V_BUSY = 24,0,1,0 %;       !  BUSY
macro LCKCTX$V_CANCEL = 24,1,1,0 %;     !  OPERATION CANCELED
macro LCKCTX$V_CMP_RQD = 24,2,1,0 %;    !  COMPLETION REQUIRED
macro LCKCTX$L_LKB = 28,0,32,0 %;       !  LKB ADDRESS
macro LCKCTX$L_CR3 = 32,0,32,0 %;       !  CALLER'S R3
macro LCKCTX$L_CR4 = 36,0,32,0 %;       !  CALLER'S R4
macro LCKCTX$L_CR5 = 40,0,32,0 %;       !  CALLER'S R5
macro LCKCTX$L_CRETADR = 44,0,32,0 %;   !  CALLER'S RETURN ADDRESS
macro LCKCTX$L_RET1 = 48,0,32,0 %;      !  STORAGE FOR SECOND RETURN
macro LCKCTX$L_TMP1 = 52,0,32,0 %;      !  TEMPORARY STORAGE
macro LCKCTX$L_CPLADR = 28,0,32,0 %;    !  COMPLETION NOTIFICATION ADDR
macro LCKCTX$L_CPLPRM = 32,0,32,0 %;    !  CONTEXT PARAMETER
macro LCKCTX$B_ARGS = 56,0,8,1 %;
literal LCKCTX$S_ARGS = 1;              !  VARIABLE PART
 
!*** MODULE $LCKMGRDEF ***
! +
!  This macro defines the bit definitions for the global Lock Manager
!  cell LCK$GL_FLAGS.
! 
! -
literal LCKMGR$M_CLUINT = 1;
literal LCKMGR$M_LCKINT = 2;
literal LCKMGR$M_CHK_BTR = 4;
literal LCKMGR$M_FRK_ENBL = 8;
literal LCKMGR$M_COMPAT_DYNRM = 16;
literal LCKMGR$M_COMPAT_RNGLCK = 32;
literal LCKMGR$M_COMPAT_MULTITASK = 64;
literal LCKMGR$M_COMPAT_CWPS = 128;
literal LCKMGR$S_LCKMGRDEF = 1;
macro LCKMGR$V_CLUINT = 0,0,1,0 %;      !  CLuster Init Complete
macro LCKMGR$V_LCKINT = 0,1,1,0 %;      !  Lock Manager Init Complete
macro LCKMGR$V_CHK_BTR = 0,2,1,0 %;     !  Check for better master
macro LCKMGR$V_FRK_ENBL = 0,3,1,0 %;    !  Fork interface enabled
macro LCKMGR$V_COMPAT_DYNRM = 0,4,1,0 %; !  Use old (V5.2) remastering algorithm
macro LCKMGR$V_COMPAT_RNGLCK = 0,5,1,0 %; !  node that does not support range locking is present
macro LCKMGR$V_COMPAT_MULTITASK = 0,6,1,0 %; !  node that does not support multitasking is present
macro LCKMGR$V_COMPAT_CWPS = 0,7,1,0 %; !  node that does not support cwps is present
!  Definitions for response codes for lock manager front end routines.
!  
! 
literal FRTN$K_QUEIT = 0;               !  request must be queued
literal FRTN$K_GRNT1 = 1;               !  request is compatible
literal FRTN$K_GRNT2 = 2;               !  rqst is compat, max-modes computed, grant waiters
literal FRTN$K_GRNT3 = 3;               !  rqst is compat, max-mode not computed, grant waiters
literal FRTN$S_FRTN_CODES = 1;          !  front end routine response codes
macro FRTN$B_CODES = 0,0,8,0 %;
 
!*** MODULE $LGIDEF ***
literal LGI$C_LENGTH = 24;              !  Data structure length
literal LGI$K_LENGTH = 24;              !  Data structure length
literal LGI$C_CHARTIME = 15;            !  Terminal driver timeout value
literal LGI$K_CHARTIME = 15;            !  Terminal driver timeout value
literal LGI$S_LGIDATDEF = 24;
macro LGI$L_ORIGUIC = 0,0,32,0 %;       !  Original UIC at job creation time
macro LGI$T_OUTFNM = 4,0,0,0 %;
literal LGI$S_OUTFNM = 20;              !  For batch, file name/type of output
!  for spooling log file in batch jobs
literal LGI$M_OPENACCT = 1;
literal LGI$M_PASSWORD = 2;
literal LGI$M_PASSWORD2 = 4;
literal LGI$_PRIMARY_PASSWORD = 1;      !  primary password
literal LGI$_SECONDARY_PASSWORD = 2;    !  secondary password
literal LGI$_SOURCE_NODE = 3;           !  source nodename
literal LGI$_SOURCE_ID = 4;             !  source id (username)
literal LGI$_SOURCE_ADDRESS = 5;        !  source DECnet address
literal LGI$_SOURCE_TERMINAL = 6;       !  source terminal
literal LGI$_PARENT_USERNAME = 7;       !  parent username
literal LGI$_PARENT_PID = 8;            !  parent PID
literal LGI$_JOB_TYPE = 9;              !  job type
literal LGI$_MAX_CODE = 10;             !  last item code (plus one)
literal LGI$S_LGIAUTHDEF = 4;
macro LGI$L_AUTH_FLAGS = 0,0,32,0 %;
macro LGI$V_OPENACCT = 0,0,1,0 %;       !  account requires no passwords
macro LGI$V_PASSWORD = 0,1,1,0 %;       !  account has primary password
macro LGI$V_PASSWORD2 = 0,2,1,0 %;      !  account has secondary password
literal LGI$_DISUSER_STOP = 1;          !  stop on error
literal LGI$_DISUSER_RETURN = 2;        !  return on error
literal LGI$_VALIDATE_STOP = 1;         !  stop on error
literal LGI$_VALIDATE_RETURN = 2;       !  return on error
literal LGI$_GET_INPUT_STOP = 0;        !  stop on error
literal LGI$_GET_INPUT_HANGUP = 1;      !  hangup quietly on error
literal LGI$_GET_INPUT_RETURN_TMO = 2;  !  return on timout
literal LGI$M_NET_PROXY = 1;
literal LGI$M_NET_PREAUTH = 2;
literal LGI$M_NET_DEFAULT_USER = 4;
literal LGI$M_NET_PROXY_OK = 8;
literal LGI$M_NET_REM_INFO_PRESENT = 16;
literal LGI$S_LGINETDEF = 2;
macro LGI$W_NET_AUTH_FLAGS = 0,0,16,0 %;
macro LGI$V_NET_PROXY = 0,0,1,0 %;      !  DECNET wants proxy login
macro LGI$V_NET_PREAUTH = 0,1,1,0 %;    !  DECNET has authenticated
macro LGI$V_NET_DEFAULT_USER = 0,2,1,0 %; !  DECNET application or session
!  database has username
macro LGI$V_NET_PROXY_OK = 0,3,1,0 %;   !  (local use) proxy validated
macro LGI$V_NET_REM_INFO_PRESENT = 0,4,1,0 %; !  Phase V provided rem info
literal LGI$S_LGIARG_VECTOR = 136;
macro LGI$ICB_GET_INPUT = 0,0,32,0 %;   !  Addresses of callbacks
macro LGI$ICB_DECW_IDENT = 4,0,32,0 %;
macro LGI$ICB_DECW_AUTH = 8,0,32,0 %;
macro LGI$ICB_GET_SYSPWD = 12,0,32,0 %;
macro LGI$ICB_USERPROMPT = 16,0,32,0 %;
macro LGI$ICB_USERPARSE = 20,0,32,0 %;
macro LGI$ICB_AUTOLOGIN = 24,0,32,0 %;
macro LGI$ICB_PASSWORD = 28,0,32,0 %;
macro LGI$ICB_CHECK_PASS = 32,0,32,0 %;
macro LGI$ICB_VALIDATE = 36,0,32,0 %;
macro LGI$ICB_ACCTEXPIRED = 40,0,32,0 %;
macro LGI$ICB_PWDEXPIRED = 44,0,32,0 %;
macro LGI$ICB_DISUSER = 48,0,32,0 %;
macro LGI$ICB_MODALHOURS = 52,0,32,0 %;
macro LGI$A_ICR_CREPRC_FLAGS = 56,0,32,0 %; !  Addresses of variables
macro LGI$A_ICR_JOB_TYPE = 60,0,32,0 %;
macro LGI$A_ICR_SUBPROCESS = 64,0,32,0 %;
macro LGI$A_ICR_TERMINAL_DEV = 68,0,32,0 %;
macro LGI$A_ICR_TT_PHYDEVNAM = 72,0,32,0 %;
macro LGI$A_ICR_TT_ACCPORNAM = 76,0,32,0 %;
macro LGI$A_ICR_CLINAME = 80,0,32,0 %;
macro LGI$A_ICR_CLITABLES = 84,0,32,0 %;
macro LGI$A_ICR_NCB = 88,0,32,0 %;
macro LGI$A_ICR_LOGLINK = 92,0,32,0 %;
macro LGI$A_ICR_REM_NODE_NAM = 96,0,32,0 %;
macro LGI$A_ICR_REM_ID = 100,0,32,0 %;
macro LGI$A_ICR_UAF_RECORD = 104,0,32,0 %;
macro LGI$A_ICR_INPUT_RAB = 108,0,32,0 %;
macro LGI$A_ICR_AUTOLOGIN = 112,0,32,0 %;
macro LGI$A_ICR_USERNAME = 116,0,32,0 %;
macro LGI$A_ICR_PWD1 = 120,0,32,0 %;
macro LGI$A_ICR_PWD2 = 124,0,32,0 %;
macro LGI$A_ICR_PWDCOUNT = 128,0,32,0 %;
macro LGI$A_ICR_NETFLAGS = 132,0,32,0 %;
literal LGI$ICR_INIT = 4;
literal LGI$ICR_IACT_START = 8;
literal LGI$ICR_DECWINIT = 12;
literal LGI$ICR_IDENTIFY = 16;
literal LGI$ICR_AUTHENTICATE = 20;
literal LGI$ICR_CHKRESTRICT = 24;
literal LGI$ICR_FINISH = 28;
literal LGI$ICR_LOGOUT = 32;
literal LGI$ICR_JOBSTEP = 36;
literal LGI$S_LGICALLOUT_VECTOR = 40;
macro LGI$L_ICR_ENTRY_COUNT = 0,0,32,0 %;
macro LGI$A_ICR_INIT = 4,0,32,0 %;
macro LGI$A_ICR_IACT_START = 8,0,32,0 %;
macro LGI$A_ICR_DECWINIT = 12,0,32,0 %;
macro LGI$A_ICR_IDENTIFY = 16,0,32,0 %;
macro LGI$A_ICR_AUTHENTICATE = 20,0,32,0 %;
macro LGI$A_ICR_CHKRESTRICT = 24,0,32,0 %;
macro LGI$A_ICR_FINISH = 28,0,32,0 %;
macro LGI$A_ICR_LOGOUT = 32,0,32,0 %;
macro LGI$A_ICR_JOBSTEP = 36,0,32,0 %;
 
!*** MODULE $LIRDEF ***
! +
!  $LIRDEF - LOADABLE IMAGE RECORD DEFINITION
! 
!  A LOADABLE IMAGE RECORD DEFINES A ALTERNATE EXEC IMAGE THAT CAN
!  BE LOADED BY INIT OR SYSINIT INTO THE SYSTEM.
! -
literal LIR$K_ID = 257;                 !  LIR ID plus version
literal LIR$K_INIT = 0;                 !    INIT 
literal LIR$K_SYSINIT = 1;              !    SYSINIT
literal LIR$K_WARNING = 0;              !    WARNING
literal LIR$K_SUCCESS = 1;              !    SUCCESS
literal LIR$K_ERROR = 2;                !    ERROR
literal LIR$K_INFORMATION = 3;          !    INFORMATION
literal LIR$K_FIXED = 8;                !  Length of fixed portion
literal LIR$C_FIXED = 8;                !  Length of fixed portion
literal LIR$K_LENGTH = 256;             ! Length of LIR
literal LIR$C_LENGTH = 256;             ! Length of LIR 
literal LIR$S_LIRDEF = 8;
macro LIR$W_ID = 0,0,16,0 %;            !  LIR ID field
macro LIR$W_PHASE = 2,0,16,0 %;         !  LIR phase indicator
!  LIR phase values
macro LIR$W_SEVERITY = 4,0,16,0 %;      !  LIR severity indicator
!  LIR severity values
macro LIR$B_ERR_LEN = 6,0,8,0 %;        !  Error message length
macro LIR$B_ERR_OFF = 7,0,8,0 %;        !  Error message offset
macro LIR$T_IMAGE_NAME = 8,0,0,0 %;     !  Start of image name counted string
 
!*** MODULE $LKBDEF ***
! +
!  LKB - LOCK BLOCK
! 
!  LOCK BLOCKS ARE USED TO REPRESENT LOCK REQUESTS (ONE BLOCK FOR EACH
!  REQUEST).  LOCK BLOCKS HAVE AN ENTRY IN THE LOCK ID TABLE POINTING
!  TO THEM AND ARE LINKED ONTO ONE OF THREE QUEUES IN A RESOURCE BLOCK (RSB)
! -
literal LKB$M_PKAST = 16;
literal LKB$M_NODELETE = 32;
literal LKB$M_QUOTA = 64;
literal LKB$M_KAST = 128;
literal LKB$M_DCPLAST = 1;
literal LKB$M_DBLKAST = 2;
literal LKB$M_ASYNC = 4;
literal LKB$M_BLKASTQED = 8;
literal LKB$M_MSTCPY = 16;
literal LKB$M_NOQUOTA = 32;
literal LKB$M_TIMOUTQ = 64;
literal LKB$M_WASSYSOWN = 128;
literal LKB$M_CVTTOSYS = 256;
literal LKB$M_PROTECT = 512;
literal LKB$M_RESEND = 1024;
literal LKB$M_RM_RBRQD = 2048;
literal LKB$M_FLOCK = 4096;
literal LKB$M_IP = 8192;
literal LKB$K_ACBLEN = 52;              ! LENGTH OF ACB PORTION OF LKB 
literal LKB$C_ACBLEN = 52;              ! LENGTH OF ACB PORTION OF LKB 
literal LKB$K_GRANTED = 1;              !  GRANTED
literal LKB$K_CONVERT = 0;              !  CONVERSION
literal LKB$K_WAITING = -1;             !  WAITING
literal LKB$K_RETRY = -2;               !  RETRY REQUEST
literal LKB$K_SCSWAIT = -3;             !  SCS WAIT
literal LKB$K_RSPNOTQED = -4;           !  RESPONSE NOT QUEUED
literal LKB$K_RSPQUEUED = -5;           !  RESPONSE QUEUED
literal LKB$K_RSPGRANTD = -6;           !  RESPONSE GRANTED
literal LKB$K_RSPDOLOCL = -7;           !  RESPONSE DO LOCALLY
literal LKB$K_RSPRESEND = -8;           !  RESPONSE RESEND
literal LKB$K_RSPWAIT = -9;             !  RESPONSE WAIT
literal LKB$K_RSP2PCRDY = -10;          !  Response Ready
literal LKB$K_RSPFATAL = -11;           !  Fatal Message response
literal LKB$M_BRL2 = 1;
literal LKB$M_NEWSUBRNG2 = 2;
literal LKB$M_CVTSUBRNG2 = 4;
literal LKB$M_RNGCHG2 = 8;
literal LKB$M_2PC_IP2 = 16;
literal LKB$M_2PC_PEND2 = 32;
literal LKB$M_BLKASTFLG2 = 64;
literal LKB$M_GRSUBRNG2 = 128;
literal LKB$M_CACHED2 = 256;
literal LKB$M_PCACHED2 = 512;
literal LKB$M_RNGBLK2 = 1024;
literal LKB$K_LENGTH = 124;             ! LENGTH OF LKB 
literal LKB$C_LENGTH = 124;             ! LENGTH OF LKB 
literal LKB$S_LKBDEF = 124;
macro LKB$L_ASTQFL = 0,0,32,0 %;        ! AST QUEUE FORWARD LINK 
macro LKB$L_ASTQBL = 4,0,32,0 %;        ! AST QUEUE BACKWARD LINK 
macro LKB$W_SIZE = 8,0,16,0 %;          ! SIZE OF LKB IN BYTES 
macro LKB$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE 
macro LKB$B_RMOD = 11,0,8,0 %;          ! ACCESS MODE OF REQUEST 
macro LKB$V_MODE = 11,0,2,0 %;
literal LKB$S_MODE = 2;                 !  MODE SUBFIELD 
macro LKB$V_PKAST = 11,4,1,0 %;         !  PIGGY BACK SPECIAL KERNEL AST 
macro LKB$V_NODELETE = 11,5,1,0 %;      !  DON'T DELETE ACB ON DELIVERY 
macro LKB$V_QUOTA = 11,6,1,0 %;         !  ACCOUNT FOR QUOTA 
macro LKB$V_KAST = 11,7,1,0 %;          !  SPECIAL KERNEL AST 
macro LKB$L_PID = 12,0,32,0 %;          ! PROCESS ID OF REQUESTING PROCESS 
macro LKB$L_AST = 16,0,32,0 %;          ! ADDRESS OF AST ROUTINE 
macro LKB$W_RQSEQNM = 16,0,16,0 %;      ! REQUEST SEQ. NUMBER 
macro LKB$L_ASTPRM = 20,0,32,0 %;       ! AST PARAMETER 
macro LKB$L_EPID = 20,0,32,0 %;         ! EPID (MASTER COPIES ONLY)
macro LKB$L_KAST = 24,0,32,0 %;         ! SPECIAL KERNEL AST ADDRESS 
macro LKB$L_DUETIME = 24,0,32,0 %;      ! DUETIME FOR WAITING LOCKS 
macro LKB$L_CPLASTADR = 28,0,32,0 %;    ! ADDRESS OF COMPLETION AST ROUTINE 
macro LKB$L_BLKASTADR = 32,0,32,0 %;    ! ADDRESS OF BLOCKING AST ROUTINE 
macro LKB$L_LKSB = 36,0,32,0 %;         ! ADDRESS OF LOCK STATUS BLOCK 
macro LKB$L_DLCKPRI = 36,0,32,0 %;      ! DEADLOCK PRIORITY (MASTER COPIES)
macro LKB$W_FLAGS = 40,0,16,0 %;        ! USER SPECIFIED FLAGS 
macro LKB$W_STATUS = 42,0,16,0 %;       ! INTERNAL STATUS
macro LKB$V_DCPLAST = 42,0,1,0 %;       !  DELIVER COMPLETION AST 
macro LKB$V_DBLKAST = 42,1,1,0 %;       !  DELIVER BLOCKING AST 
macro LKB$V_ASYNC = 42,2,1,0 %;         !  REQUEST COMPLETED ASYNCHRONOUSLY 
macro LKB$V_BLKASTQED = 42,3,1,0 %;     !  BLOCKING AST HAS BEEN QUEUED 
macro LKB$V_MSTCPY = 42,4,1,0 %;        !  LKB IS A MASTER COPY
macro LKB$V_NOQUOTA = 42,5,1,0 %;       !  DON'T CHARGE QUOTA
macro LKB$V_TIMOUTQ = 42,6,1,0 %;       !  LKB IS ON TIMEOUT QUEUE 
macro LKB$V_WASSYSOWN = 42,7,1,0 %;     !  WAS SYSTEM OWNED LOCK
macro LKB$V_CVTTOSYS = 42,8,1,0 %;      !  CVT BACK TO SYS. OWNED
macro LKB$V_PROTECT = 42,9,1,0 %;       !  PROTECTED LOCK
macro LKB$V_RESEND = 42,10,1,0 %;       !  RESEND DURING FAILOVER
macro LKB$V_RM_RBRQD = 42,11,1,0 %;     !  REMASTER REBUILD REQUIRED
macro LKB$V_FLOCK = 42,12,1,0 %;        !  FORK LOCK
macro LKB$V_IP = 42,13,1,0 %;           !  OPERATION IN PROGRESS
macro LKB$L_LKST1 = 44,0,32,0 %;        ! FIRST LOCK STATUS LONGWORD 
macro LKB$L_LKST2 = 48,0,32,0 %;        ! SECOND LOCK STATUS LONGWORD 
macro LKB$L_LKID = 48,0,32,0 %;         ! LOCK ID 
macro LKB$V_INDEX = 48,0,16,0 %;
literal LKB$S_INDEX = 16;               !  65k index
macro LKB$V_XINDX = 48,16,8,0 %;
literal LKB$S_XINDX = 8;                !  extended page index
macro LKB$V_SEQN = 48,24,8,0 %;
literal LKB$S_SEQN = 8;                 !  sequence number
macro LKB$B_RQMODE = 52,0,8,0 %;        ! REQUEST MODE 
macro LKB$B_GRMODE = 53,0,8,0 %;        ! GRANTED MODE 
macro LKB$B_STATE = 54,0,8,0 %;         ! LOCK STATE 
! LOCK STATE VALUES
macro LKB$B_EFN = 55,0,8,0 %;           ! EVENT FLAG NUMBER 
macro LKB$L_SQFL = 56,0,32,0 %;         ! STATE QUEUE FORWARD LINK 
macro LKB$L_SQBL = 60,0,32,0 %;         ! STATE QUEUE BACKWARD LINK 
macro LKB$L_OWNQFL = 64,0,32,0 %;       ! OWNER QUEUE FORWARD LINK 
macro LKB$L_OWNQBL = 68,0,32,0 %;       ! OWNER QUEUE BACKWARD LINK 
macro LKB$L_PARENT = 72,0,32,0 %;       ! ADDRESS OF PARENT LKB 
macro LKB$W_REFCNT = 76,0,16,0 %;       ! SUB LKB REFERENCE COUNT 
macro LKB$B_TSLT = 78,0,8,0 %;          ! TIMESTAMP LIFETIME
macro LKB$L_RSB = 80,0,32,0 %;          ! ADDRESS OF OWNER RSB 
macro LKB$L_REMLKID = 84,0,32,0 %;      ! REMOTE LOCK ID
macro LKB$L_CSID = 88,0,32,0 %;         ! CLUSTER SYSTEM ID (MASTER ONLY)
macro LKB$L_OLDASTPRM = 88,0,32,0 %;    ! OLD AST PARAMETER
macro LKB$L_OLDBLKAST = 92,0,32,0 %;    ! OLD BLOCKING AST ADDR,
macro LKB$L_LCKCTX = 96,0,32,0 %;       ! ADDRESS OF CONTEXT BLOCK
macro LKB$W_PRIORITY = 100,0,16,0 %;    ! REQUEST PRIORITY
macro LKB$W_STAT2 = 102,0,16,0 %;       ! INTERNAL STATUS
macro LKB$V_BRL2 = 102,0,1,0 %;         !  indicate byte range lock
macro LKB$V_NEWSUBRNG2 = 102,1,1,0 %;   !  new sub-range request 
macro LKB$V_CVTSUBRNG2 = 102,2,1,0 %;   !  sub-range cvt request 
macro LKB$V_RNGCHG2 = 102,3,1,0 %;      !  changing range 
macro LKB$V_2PC_IP2 = 102,4,1,0 %;      !  two phase op in progress
macro LKB$V_2PC_PEND2 = 102,5,1,0 %;    !  two phase op pending
macro LKB$V_BLKASTFLG2 = 102,6,1,0 %;   !  indicates blkast specified
macro LKB$V_GRSUBRNG2 = 102,7,1,0 %;    !  granted sub-range lock
macro LKB$V_CACHED2 = 102,8,1,0 %;      !  LKB is in cache
macro LKB$V_PCACHED2 = 102,9,1,0 %;     !  LKB is to be cached
macro LKB$V_RNGBLK2 = 102,10,1,0 %;     !  Range block specified 
macro LKB$L_RQSTSRNG = 104,0,32,0 %;    ! Starting byte of req range
macro LKB$L_RQSTERNG = 108,0,32,0 %;    ! Ending byte of req range
macro LKB$L_GRNTSRNG = 112,0,32,0 %;    ! Starting byte of granted range
macro LKB$L_GRNTERNG = 116,0,32,0 %;    ! Ending byte of granted range
macro LKB$L_TSKPID = 120,0,32,0 %;      ! Task id
 
!*** MODULE $LMBDEF ***
! +
!   LMB	-  Logical Memory Block
! 
!   Logical Memory Block definitions (for subsetted crash dumps)
!   Layout of each Logical Memory Block and accompanying hole descriptor.
!   Logical Memory Blocks are portions of selective memory dumps.  "Holes"
!   refer to areas of invalid or inaccessible virtual address space at the
!   time of the dump.
! -
literal LMB$C_SPT = 0;                  !  System Page Table
literal LMB$C_S0 = 1;                   !  S0 system space
literal LMB$C_GBL = 2;                  !  Global pages
literal LMB$C_PROCESS = 3;              !  Process memory
literal LMB$L_HOLE_START_VA = 0;
!  Starting VA for this hole
literal LMB$L_HOLE_TOTAL_PAGES = 4;
!  Running total of pages of holes
literal LMB$C_HOLE_LENGTH = 8;
!  Size of each hole table entry.
literal LMB$C_BAD_MEM_START = 0;
!  Starting VA of bad memory section
literal LMB$C_BAD_MEM_END = 4;
!  Ending VA of bad memory section
literal LMB$C_BAD_MEM_NEXT = 8;
!  Size of one entry in bad memory table
literal LMB$K_LENGTH = 32;              !  Logical mem block length
literal LMB$C_LENGTH = 32;              !  Logical mem block length
literal LMB$S_LMBDEF = 32;
macro LMB$L_TYPE = 0,0,32,0 %;          !  Type of LMB
!  LMB flavors
macro LMB$L_EXP_LENGTH = 4,0,32,0 %;    !  LMB data expected length (blocks)
macro LMB$L_ACT_LENGTH = 8,0,32,0 %;    !  LMB data actual length (blocks)
macro LMB$L_TIME_CHECK = 12,0,32,0 %;   !  Ones-complement of EMB$Q_CR_TIME
macro LMB$L_FILLER_SPT = 16,0,0,0 %;
literal LMB$S_FILLER_SPT = 8;
macro LMB$L_SPTADR = 24,0,32,0 %;       !  SVA of the start of SPT + GPT
macro LMB$L_S0_HOLE_TBL = 16,0,32,0 %;  !  VBN in dump of start of the table
!  describing the holes in the S0
!  virtual address space.
macro LMB$L_S0_TOTAL_HOLES = 20,0,32,0 %; !  Count of holes in S0 space
macro LMB$L_GBL_HOLE_TBL = 16,0,32,0 %; !  VBN in dump of start of the table
!  describing the holes in global
!  page space.
macro LMB$L_GBL_TOTAL_HOLES = 20,0,32,0 %; !  Count of global page holes
macro LMB$L_PROC_HOLE_TBL = 16,0,32,0 %; !  VBN in dump of start of the table
!  describing the holes in the
!  process P0/P1 virtual address space.
macro LMB$L_PROC_TOTAL_HOLES = 20,0,32,0 %; !  Count of holes in P0/P1 space
macro LMB$L_PCBADR = 24,0,32,0 %;       !  SVA of this process's PCB
!  up to the starting VA of this hole
!  Offset to get to the next hole
!  table entry.
macro LMB$L_BAD_MEM_PTRS = 28,0,32,0 %; !  Offset of bad memory descriptor
!  list. List terminates with -1 or
!  at end of LMB block 1.
!  Offset is from start of LMB block 1.
 
!*** MODULE $LMFITMDEF ***
! +
!  LMFITMDEF - LMF internal item-list definitions
! 
!  Items lists used by the internal routines LMF$LOAD and LMF$UNLOAD,
!  which manipulate the on-disk and in-memory License databases.
!  These routines now have a callable interface, and the caller needs
!  access to these item codes.
! -
!  These are the item codes passed from the LMF utility to the callable
!  routines in the item list.  New codes should be added to the end.
literal LMF$k_ldb = 0;
literal LMF$k_producer = 1;
literal LMF$k_product = 2;
literal LMF$k_version = 3;
literal LMF$k_issuer = 4;
literal LMF$k_comment = 5;
literal LMF$k_authorization = 6;
literal LMF$k_units = 7;
literal LMF$k_availability = 8;
literal LMF$k_activity = 9;
literal LMF$k_token = 10;
literal LMF$k_termination = 11;
literal LMF$k_date = 12;
literal LMF$k_hardware_id = 13;
literal LMF$k_checksum = 14;
literal LMF$K_INCLUDE = 15;
literal LMF$k_exclude = 16;
literal LMF$k_options = 17;
literal LMF$k_output_name = 18;
literal LMF$k_extinct_qualifier = 19;
literal LMF$k_load_qualifier = 20;
literal LMF$k_cust_termination = 21;
literal LMF$k_cust_date = 22;
literal LMF$k_full_qualifier = 23;
literal LMF$k_brief_qualifier = 24;
literal LMF$k_creation_date = 25;
literal LMF$K_LMF_version_number = 26;
literal LMF$k_creating_username = 27;
literal LMF$k_log_qualifier = 28;
 
!*** MODULE $LOGDEF ***
! +
!  LOG - LOGICAL NAME BLOCK
! 
!  THERE IS ONE LOGICAL NAME BLOCK FOR EACH LOGICAL NAME ASSIGNMENT IN A
!  SYSTEM. LOGICAL NAME BLOCKS CAN BE LINKED INTO ONE OF THREE TABLES:
!         1. A PER PROCESS TABLE.
!         2. A GROUP WIDE TABLE.
!         3. THE SYSTEM WIDE TABLE.
! -
literal LOG$K_LENGTH = 20;              ! LENGTH OF FIXED PART OF LOG 
literal LOG$C_LENGTH = 20;              ! LENGTH OF FIXED PART OF LOG 
literal LOG$C_SYSTEM = 0;               ! SYSTEM NAME TABLE 
literal LOG$C_GROUP = 1;                ! GROUP NAME TABLE 
literal LOG$C_PROCESS = 2;              ! PROCESS NAME TABLE 
! 
literal LOG$C_NAMLENGTH = 64;           ! MAXIMUM LENGTH OF LOGICAL NAME STRING 
literal LOG$S_LOGDEF = 20;
macro LOG$L_LTFL = 0,0,32,0 %;          ! LOGICAL TABLE FORWARD LINK 
macro LOG$L_LTBL = 4,0,32,0 %;          ! LOGICAL TABLE BACKWARD LINK 
macro LOG$W_SIZE = 8,0,16,0 %;          ! SIZE OF LOG IN BYTES 
macro LOG$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE FOR LOG 
macro LOG$B_TABLE = 11,0,8,0 %;         ! LOGICAL NAME TABLE TYPE 
macro LOG$W_GROUP = 12,0,16,0 %;        ! CREATOR GROUP NUMBER 
macro LOG$B_AMOD = 14,0,8,0 %;          ! ACCESS MODE OF CREATOR 
macro LOG$L_MBXUCB = 16,0,32,0 %;       ! MAILBOX UCB ADDRESS 
macro LOG$T_NAME = 20,0,0,0 %;          ! START OF LOGICAL NAME 
! 
!  LOGICAL NAME TABLE NUMBERS
! 
!  MAXIMUM LENGTH OF LOGICAL NAME STRING
! 
 
!*** MODULE $LNMSTRDEF ***
literal LNMB$M_NO_ALIAS = 1;
literal LNMB$M_CONFINE = 2;
literal LNMB$M_CRELOG = 4;
literal LNMB$M_TABLE = 8;
literal LNMB$M_NODELETE = 16;
literal LNMB$S_LNMBDEF = 18;
macro LNMB$L_FLINK = 0,0,32,0 %;        !  Forward link in list
macro LNMB$L_BLINK = 4,0,32,0 %;        !  Backward link in list
macro LNMB$W_SIZE = 8,0,16,0 %;         !  Size of LNMB in bytes
macro LNMB$B_TYPE = 10,0,8,0 %;         !  Structure type for LNMB
macro LNMB$B_ACMODE = 11,0,8,0 %;       !  Owner access mode / integrity level byte
macro LNMB$L_TABLE = 12,0,32,0 %;       !  Logical name table header address
macro LNMB$R_FLAG_BITS = 16,0,8,0 %;
macro LNMB$B_FLAGS = 16,0,8,0 %;        !  Name attributes
macro LNMB$R_BITS = 16,0,8,0 %;
literal LNMB$S_BITS = 1;
macro LNMB$V_NO_ALIAS = 16,0,1,0 %;     !  Do not allow outer mode alias
macro LNMB$V_CONFINE = 16,1,1,0 %;      !  Do not copy into subprocess
macro LNMB$V_CRELOG = 16,2,1,0 %;       !  Created with old $CRELOG service
macro LNMB$V_TABLE = 16,3,1,0 %;        !  This is a table name
macro LNMB$V_NODELETE = 16,4,1,0 %;     !  Do not allow this table to be deleted
macro LNMB$T_NAME = 17,0,8,0 %;         !  Name string (counted)
!  Translation blocks begin immediately
!  following name
literal LNMC$K_NUM_ENTRIES = 26;        !  Number of table header entries.
literal LNMC$K_LENGTH = 128;            !  Length of header
literal LNMC$S_LNMCDEF = 128;
macro LNMC$L_FLINK = 0,0,32,0 %;        !  Forward link in list
macro LNMC$L_BLINK = 4,0,32,0 %;        !  Backward link in list
macro LNMC$W_SIZE = 8,0,16,0 %;         !  Size of LNMC in bytes
macro LNMC$B_TYPE = 10,0,8,0 %;         !  Structure type for LNMC
macro LNMC$B_CACHEINDX = 11,0,8,0 %;    !  Current entry number
macro LNMC$L_TBLADDR = 12,0,32,0 %;     !  Logical name table name address
macro LNMC$L_PROCDIRSEQ = 16,0,32,0 %;  !  Process directory sequence number
macro LNMC$L_SYSDIRSEQ = 20,0,32,0 %;   !  System directory sequence number
macro LNMC$L_ENTRY = 24,0,0,1 %;
literal LNMC$S_ENTRY = 104;             !  Logical name table header addresses
literal LNMX$M_CONCEALED = 1;
literal LNMX$M_TERMINAL = 2;
literal LNMX$M_XEND = 4;
literal LNMX$C_HSHFCN = -128;           !  Hash function value
literal LNMX$C_BACKPTR = -127;          !  Backpointer translation
literal LNMX$C_TABLE = -126;            !  Logical name table header
literal LNMX$C_IGNORED_INDEX = -125;    !  Modified back pointer for process-private names
literal LNMX$S_LNMXDEF = 5;
macro LNMX$R_FLAG_BITS = 0,0,8,0 %;
macro LNMX$B_FLAGS = 0,0,8,0 %;         !  Translation attributes
macro LNMX$R_BITS = 0,0,8,0 %;
literal LNMX$S_BITS = 1;
macro LNMX$V_CONCEALED = 0,0,1,0 %;     !  Do not display result of translation
macro LNMX$V_TERMINAL = 0,1,1,0 %;      !  Do not retranslate result of translation
macro LNMX$V_XEND = 0,2,1,0 %;          !  End of translations flag
macro LNMX$B_INDEX = 1,0,8,1 %;         !  Translation index
macro LNMX$W_HASH = 2,0,16,1 %;         !  Hash code for logical names in directories
macro LNMX$T_XLATION = 4,0,8,0 %;       !  Translation string (counted)
!  The next translation block
!  begins immediately following
!  this translation string
literal LNMTH$M_SHAREABLE = 1;
literal LNMTH$M_DIRECTORY = 2;
literal LNMTH$M_GROUP = 4;
literal LNMTH$M_SYSTEM = 8;
literal LNMTH$K_LENGTH = 37;            !  Length of header
literal LNMTH$S_LNMTHDEF = 37;
macro LNMTH$R_FLAG_BITS = 0,0,8,0 %;
macro LNMTH$B_FLAGS = 0,0,8,0 %;        !  Logical name table flags
macro LNMTH$R_BITS = 0,0,8,0 %;
literal LNMTH$S_BITS = 1;
macro LNMTH$V_SHAREABLE = 0,0,1,0 %;    !  Logical name table is shareable (S0 space)
macro LNMTH$V_DIRECTORY = 0,1,1,0 %;    !  Logical name table is a directory table
macro LNMTH$V_GROUP = 0,2,1,0 %;        !  Logical name table is a group logical name table
macro LNMTH$V_SYSTEM = 0,3,1,0 %;       !  Logical name table is the system logical name table
macro LNMTH$L_HASH = 1,0,32,0 %;        !  Address of hash table
macro LNMTH$L_ORB = 5,0,32,0 %;         !  Address of Object Rights Block
macro LNMTH$L_NAME = 9,0,32,0 %;        !  Address of containing LNMB block
macro LNMTH$L_PARENT = 13,0,32,0 %;     !  Address of parent table
macro LNMTH$L_CHILD = 17,0,32,0 %;      !  Address of a child table
macro LNMTH$L_SIBLING = 21,0,32,0 %;    !  Address of a sibling table
macro LNMTH$L_QTABLE = 25,0,32,0 %;     !  Address of table holding quota
macro LNMTH$L_BYTESLM = 29,0,32,1 %;    !  Initial quota
macro LNMTH$L_BYTES = 33,0,32,1 %;      !  Remaining quota
literal LNMHSH$C_BUCKET = 12;           !  Length of fixed part of LNMHSH
literal LNMHSH$K_BUCKET = 12;           !  Length of fixed part of LNMHSH
literal LNMHSH$S_LNMHSHDEF = 12;
macro LNMHSH$L_MASK = 0,0,32,0 %;       !  Mask for hash value
macro LNMHSH$W_SIZE = 8,0,16,0 %;       !  Size of LNMHSH in bytes
macro LNMHSH$B_TYPE = 10,0,8,0 %;       !  Structure type for LNMHSH
 
!*** MODULE $LSBDEF ***
!  Registers for Laser-based devices are defined to begin on 64-byte
!  boundaries.  The (arbitrary) convention adopted in this module is
!  to define the longword definitions using "longword dimension 16".
!  This helps to illustrate the fact registers are spaced every 64
!  bytes to match the hardware definitions.
!  LSB Node Space Registers
literal LSB$M_E = 1;
literal LSB$M_UCE = 2;
literal LSB$M_UCE2 = 4;
literal LSB$M_CE = 8;
literal LSB$M_CE2 = 16;
literal LSB$M_CPE = 32;
literal LSB$M_CPE2 = 64;
literal LSB$M_CDPE = 128;
literal LSB$M_CDPE2 = 256;
literal LSB$M_TDE = 512;
literal LSB$M_STE = 1024;
literal LSB$M_CNFE = 2048;
literal LSB$M_NXAE = 4096;
literal LSB$M_CAE = 8192;
literal LSB$M_SHE = 16384;
literal LSB$M_DIE = 32768;
literal LSB$M_DTCE = 65536;
literal LSB$M_CTCE = 131072;
literal LSB$M_NSES = 262144;
literal LSB$M_CEEN = 1;
literal LSB$M_RSTSTAT = 268435456;
literal LSB$M_NHALT = 536870912;
literal LSB$M_NRST = 1073741824;
literal LSB$M_STF = -2147483648;
literal LSB$M_SCLK = 1;
literal LSB$M_XMT_SDAT = 2;
literal LSB$M_RCV_SDAT = 4;
literal LSB$M_EN = 1;
literal LSB$M_CNF = 32768;
literal LSB$M_SHARED = 65536;
literal LSB$M_DIRTY = 131072;
literal LSB$M_CLR_LOCK = 1024;
literal LSB$M_BTAGPE = 16;
literal LSB$M_BSTATPE = 32;
literal LSB$M_BMAPPE = 64;
literal LSB$M_BDATASBE = 128;
literal LSB$M_BDATADBE = 256;
literal LSB$M_ARBCOL = 512;
literal LSB$M_ARBDROP = 1024;
literal LSB$M_EDALTO = 2048;
literal LSB$M_L_BIT = -2147483648;
literal LSB$M_FDIRTY = 2;
literal LSB$M_FSHARE = 4;
literal LSB$M_FSBE = 8;
literal LSB$M_FDBE = 16;
literal LSB$M_FBCP = 32;
literal LSB$M_FBDP = 64;
literal LSB$M_FIGN = 128;
literal LSB$M_BT_PARITY = 16777216;
literal LSB$M_BS_PARITY = 33554432;
literal LSB$M_BM_PARITY = 67108864;
literal LSB$M_PM_PARITY = 134217728;
literal LSB$M_WVALID = 268435456;
literal LSB$M_WSHARED = 536870912;
literal LSB$M_WDIRTY = 1073741824;
literal LSB$M_LC0_OVFL = 1;
literal LSB$M_LC1_OVFL = 2;
literal LSB$M_LC0_RUN = 16384;
literal LSB$M_LC0_HALT = 32768;
literal LSB$M_LC1_RUN = 4194304;
literal LSB$M_LC1_HALT = 8388608;
literal LSB$M_UP_HIC_IE = 65536;
literal LSB$M_IPC_IE = 131072;
literal LSB$M_UP_VRTX_ERR = 262144;
literal LSB$M_DN_VRTX_ERR = 524288;
literal LSB$M_MULT_INTR_ERR = 1048576;
literal LSB$M_INTR_NSES = -2147483648;
literal LSB$M_DTYP = 1;
literal LSB$M_ENA = 1;
literal AMR$C_INTLV_1WAY = 0;           !  1-way interleave
literal AMR$C_INTLV_2WAY = 1;           !  2-way interleave
literal AMR$C_INTLV_4WAY = 2;           !  4-way interleave
literal AMR$C_RESVD = 3;                !  reserved
literal LSB$M_ARB_HIGH = 1;
literal LSB$M_HS_ERROR = 1;
literal LSB$M_HS_PWROK = 2;
literal LSB$M_HS_CBLOK = 4;
literal LSB$M_HS_PWRTRANS = 8;
literal LSB$M_FRC_DN_ILL_CMD = 1;
literal LSB$M_FRC_DN_SEQ_ERR = 2;
literal LSB$M_DIS_LSB_CMD = 1024;
literal LSB$M_HIC_LPBCK_EN = 2048;
literal LSB$M_FRC_DAT_PE = 4096;
literal LSB$M_FRC_CMD_PE = 8192;
literal LSB$M_FRC_CNFE = 4194304;
literal LSB$M_FRC_CAE = 8388608;
literal LSB$M_DIAG_ECC_EN = -2147483648;
literal LSB$M_CER = 1;
literal LSB$M_UCER = 2;
literal LSB$M_MULE = 4;
literal LSB$M_APER = 8;
literal LSB$M_CERA = 16;
literal LSB$M_CERB = 32;
literal LSB$M_BNKER = 512;
literal LSB$M_UCERA = 1024;
literal LSB$M_UCERB = 2048;
literal LSB$M_FCBS = 1;
literal LSB$M_DRDC = 2;
literal LSB$M_DWDC = 4;
literal LSB$M_BPAS = 8;
literal LSB$M_EXST = 16;
literal LSB$M_STPM = 32;
literal LSB$M_MODE = 64;
literal LSB$M_IGSB = 128;
literal LSB$M_FRPE = 256;
literal LSB$M_FCPE = 512;
literal LSB$M_DCRD = 134217728;
literal LSB$M_BRFSH = 1073741824;
literal LSB$M_DRFSH = -2147483648;
literal LSB$S_LSBDEF = 16960;
macro LSB$L_LDEV = 0,0,0,0 %;
literal LSB$S_LDEV = 64;                !  LSB Device Register  BB+00
macro LSB$W_DTYPE = 0,0,16,0 %;         !  Device type
macro LSB$B_DEV_ID = 0,0,8,0 %;         !  Device ID
macro LSB$B_CLASS = 1,0,8,0 %;          !  Device class
macro LSB$W_DREV = 2,0,16,0 %;          !  Device Revision
macro LSB$L_LBER = 64,0,0,0 %;
literal LSB$S_LBER = 64;                !  LSB Bus Error Register  BB+40
macro LSB$V_E = 64,0,1,0 %;             !  ERROR line asserted
macro LSB$V_UCE = 64,1,1,0 %;           !  Uncorrectable Data Error
macro LSB$V_UCE2 = 64,2,1,0 %;          !  2nd Uncorrectable Data Error
macro LSB$V_CE = 64,3,1,0 %;            !  Correctable Data Error
macro LSB$V_CE2 = 64,4,1,0 %;           !  2nd Correctable Data Error
macro LSB$V_CPE = 64,5,1,0 %;           !  Command Parity Error
macro LSB$V_CPE2 = 64,6,1,0 %;          !  2nd Command Parity Error
macro LSB$V_CDPE = 64,7,1,0 %;          !  CSR Data Parity Error
macro LSB$V_CDPE2 = 64,8,1,0 %;         !  2nd CSR Data Parity Error
macro LSB$V_TDE = 64,9,1,0 %;           !  Transmitter During Error
macro LSB$V_STE = 64,10,1,0 %;          !  STALL Error
macro LSB$V_CNFE = 64,11,1,0 %;         !  CNFE Error
macro LSB$V_NXAE = 64,12,1,0 %;         !  Non-existent Address Error
macro LSB$V_CAE = 64,13,1,0 %;          !  CA Error
macro LSB$V_SHE = 64,14,1,0 %;          !  SHARED Error
macro LSB$V_DIE = 64,15,1,0 %;          !  DIRTY Error
macro LSB$V_DTCE = 64,16,1,0 %;         !  Data Transmit Check Error
macro LSB$V_CTCE = 64,17,1,0 %;         !  Control Transmit Check Error
macro LSB$V_NSES = 64,18,1,0 %;         !  Node-specific Error Summary
macro LSBDEF_LBER$$_RSVD = 64,19,13,0 %;
literal LSBDEF_LBERS_RSVD = 13;         !  Reserved
macro LSB$L_LCNR = 128,0,0,0 %;
literal LSB$S_LCNR = 64;                !  LSB Configuration Reg  BB+80
macro LSB$V_CEEN = 128,0,1,0 %;         !  Enable Correctable Err Detect
macro LSBDEF_LCNR$$_RSVD = 128,1,27,0 %;
literal LSBDEF_LCNRS_RSVD = 27;         !  Reserved
macro LSB$V_RSTSTAT = 128,28,1,0 %;     !  Reset Status
macro LSB$V_NHALT = 128,29,1,0 %;       !  Node Halt
macro LSB$V_NRST = 128,30,1,0 %;        !  Node Reset
macro LSB$V_STF = 128,31,1,0 %;         !  Self Test Fail
macro LSB$L_IBRR = 192,0,0,0 %;
literal LSB$S_IBRR = 64;                !  LSB Information Base Repair Reg  BB+C0
macro LSB$V_SCLK = 192,0,1,0 %;         !  Serial Clock
macro LSB$V_XMT_SDAT = 192,1,1,0 %;     !  Transmit Serial Data
macro LSB$V_RCV_SDAT = 192,2,1,0 %;     !  Receive Serial Data
macro LSBDEF_IBRR$$_RSVD = 192,3,29,0 %;
literal LSBDEF_IBRRS_RSVD = 29;         !  Reserved
macro LSB$L_LMMR0 = 512,0,0,0 %;
literal LSB$S_LMMR0 = 64;               !  LSB Memory Mapping Register 0
macro LSB$V_EN = 512,0,1,0 %;           !  Enabled
macro LSB$V_INTL = 512,1,2,0 %;
literal LSB$S_INTL = 2;                 !  Interleave Mode
macro LSB$V_IA = 512,3,2,0 %;
literal LSB$S_IA = 2;                   !  Interleave Address
macro LSB$V_AW = 512,5,4,0 %;
literal LSB$S_AW = 4;                   !  Address Width
macro LSB$V_NBANKS = 512,9,2,0 %;
literal LSB$S_NBANKS = 2;               !  Number of Banks/Module
macro LSBDEF_LMMR$$_RSVD = 512,11,6,0 %;
literal LSBDEF_LMMRS_RSVD = 6;          !  Reserved
macro LSB$V_MADR = 512,17,15,0 %;
literal LSB$S_MADR = 15;                !  Module Address (MS bits)
macro LSB$L_LMMR1 = 576,0,0,0 %;
literal LSB$S_LMMR1 = 64;               !  LSB Memory Mapping Register 1
macro LSB$L_LMMR2 = 640,0,0,0 %;
literal LSB$S_LMMR2 = 64;               !  LSB Memory Mapping Register 2
macro LSB$L_LMMR3 = 704,0,0,0 %;
literal LSB$S_LMMR3 = 64;               !  LSB Memory Mapping Register 3
macro LSB$L_LMMR4 = 768,0,0,0 %;
literal LSB$S_LMMR4 = 64;               !  LSB Memory Mapping Register 4
macro LSB$L_LMMR5 = 832,0,0,0 %;
literal LSB$S_LMMR5 = 64;               !  LSB Memory Mapping Register 5
macro LSB$L_LMMR6 = 896,0,0,0 %;
literal LSB$S_LMMR6 = 64;               !  LSB Memory Mapping Register 6
macro LSB$L_LMMR7 = 960,0,0,0 %;
literal LSB$S_LMMR7 = 64;               !  LSB Memory Mapping Register 7
macro LSB$L_LBESR0 = 1536,0,0,0 %;
literal LSB$S_LBESR0 = 64;              !  LSB Bus Error Syndrome Reg 0
macro LSB$V_SYNDROME = 1536,0,7,0 %;
literal LSB$S_SYNDROME = 7;             !  Syndrome info
macro LSBDEF_LBESR$$_RSVD = 1536,7,25,0 %;
literal LSBDEF_LBESRS_RSVD = 25;        !  Reserved
macro LSB$L_LBESR1 = 1600,0,0,0 %;
literal LSB$S_LBESR1 = 64;              !  LSB Bus Error Syndrome Reg 1
macro LSB$L_LBESR2 = 1664,0,0,0 %;
literal LSB$S_LBESR2 = 64;              !  LSB Bus Error Syndrome Reg 2
macro LSB$L_LBESR3 = 1728,0,0,0 %;
literal LSB$S_LBESR3 = 64;              !  LSB Bus Error Syndrome Reg 3
macro LSB$L_LBECR0 = 1792,0,0,0 %;
literal LSB$S_LBECR0 = 64;              !  LSB Bus Error Command Reg 0
macro LSB$L_LBECR1 = 1856,0,0,0 %;
literal LSB$S_LBECR1 = 64;              !  LSB Bus Error Command Reg 1
macro LSB$V_CA3832 = 1856,0,7,0 %;
literal LSB$S_CA3832 = 7;               !  CA<38:32>
macro LSB$V_CID = 1856,7,4,0 %;
literal LSB$S_CID = 4;                  !  Commander ID
macro LSBDEF_LBECR$$_RSVD0 = 1856,11,4,0 %;
literal LSBDEF_LBECRS_RSVD0 = 4;        !  Responder ID
macro LSB$V_CNF = 1856,15,1,0 %;        !  CNF asserted for this cmd
macro LSB$V_SHARED = 1856,16,1,0 %;     !  SHARED asserted for this cmd
macro LSB$V_DIRTY = 1856,17,1,0 %;      !  DIRTY asserted for this cmd
macro LSB$V_DCYCLE = 1856,18,2,0 %;
literal LSB$S_DCYCLE = 2;               !  Data cycle which had error
macro LSBDEF_LBECR$$_RSVD1 = 1856,20,12,0 %;
literal LSBDEF_LBECRS_RSVD1 = 12;       !  Reserved
!  IOP-specific registers
macro LSB$L_LILID0 = 2560,0,0,0 %;
literal LSB$S_LILID0 = 64;              !  Interrupt Level 0 Ident Reg
macro LSB$V_IDENT = 2560,0,16,0 %;
literal LSB$S_IDENT = 16;               !  I/O device/adapter vector
macro LSBDEF_LILID$$_RSVD = 2560,16,16,0 %;
literal LSBDEF_LILIDS_RSVD = 16;        !  Reserved
macro LSB$L_LILID1 = 2624,0,0,0 %;
literal LSB$S_LILID1 = 64;              !  Interrupt Level 1 Ident Reg
macro LSB$L_LILID2 = 2688,0,0,0 %;
literal LSB$S_LILID2 = 64;              !  Interrupt Level 2 Ident Reg
macro LSB$L_LILID3 = 2752,0,0,0 %;
literal LSB$S_LILID3 = 64;              !  Interrupt Level 3 Ident Reg
macro LSB$L_LCPUMASK = 2816,0,0,0 %;
literal LSB$S_LCPUMASK = 64;            !  LSB CPU Interrupt Mask Reg
macro LSB$V_CPU0 = 2816,0,4,0 %;
literal LSB$S_CPU0 = 4;                 !  CPU0 Interrupt Levels Enable
macro LSB$V_CPU1 = 2816,4,4,0 %;
literal LSB$S_CPU1 = 4;                 !  CPU1 Interrupt Levels Enable
macro LSB$V_CPU2 = 2816,8,4,0 %;
literal LSB$S_CPU2 = 4;                 !  CPU2 Interrupt Levels Enable
macro LSB$V_CPU3 = 2816,12,4,0 %;
literal LSB$S_CPU3 = 4;                 !  CPU3 Interrupt Levels Enable
macro LSBDEF_LCPUMASK$$_RSVD = 2816,16,16,0 %;
literal LSBDEF_LCPUMASKS_RSVD = 16;     !  Reserved
macro LSB$L_LMODE = 3072,0,0,0 %;
literal LSB$S_LMODE = 64;               !  LNP Mode Register
macro LSB$V_BSIZE = 3072,0,2,0 %;
literal LSB$S_BSIZE = 2;                !  Size of B-Cache
macro LSB$V_WMODE = 3072,2,2,0 %;
literal LSB$S_WMODE = 2;                !  LEVI Behavior to LSB Writes
macro LSB$V_P_MODE = 3072,4,2,0 %;
literal LSB$S_P_MODE = 2;               !  VIC organization
macro LSB$V_LOCK_MODE = 3072,6,2,0 %;
literal LSB$S_LOCK_MODE = 2;            !  LSB_LOCKOUT
macro LSB$V_LOCK_TO = 3072,8,2,0 %;
literal LSB$S_LOCK_TO = 2;              !  Lockout assertion timeout
macro LSB$V_CLR_LOCK = 3072,10,1,0 %;   !  Deassert LSB_LOCKOUT
macro LSBDEF_LMODE$$_RSVD = 3072,11,21,0 %;
literal LSBDEF_LMODES_RSVD = 21;        !  Reserved
macro LSB$L_LMBPR = 3072,0,0,0 %;
literal LSB$S_LMBPR = 64;               !  IOP Mailbox Pointer Register
macro LSB$V_MBZ = 3072,0,6,0 %;
literal LSB$S_MBZ = 6;
macro LSB$L_MBX_ADDR = 3073,0,32,0 %;
macro LSB$L_LMERR = 3136,0,0,0 %;
literal LSB$S_LMERR = 64;               !  LNP Module Error Register
macro LSB$V_PMAPPE = 3136,0,4,0 %;
literal LSB$S_PMAPPE = 4;               !  P-Map Parity Error
macro LSB$V_BTAGPE = 3136,4,1,0 %;      !  B-Cache Tag Store Parity Err
macro LSB$V_BSTATPE = 3136,5,1,0 %;     !  B-Cache Status Store Parity Err
macro LSB$V_BMAPPE = 3136,6,1,0 %;      !  B-Map Parity Error
macro LSB$V_BDATASBE = 3136,7,1,0 %;    !  B-Cache Data Single Bit Err
macro LSB$V_BDATADBE = 3136,8,1,0 %;    !  B-Cache Data Double Bit Err
macro LSB$V_ARBCOL = 3136,9,1,0 %;      !  Arbitration Collision
macro LSB$V_ARBDROP = 3136,10,1,0 %;    !  Arbitration Drop
macro LSB$V_EDALTO = 3136,11,1,0 %;     !  EDAL Timeout
macro LSBDEF_LMERR$$_RSVD = 3136,12,20,0 %;
literal LSBDEF_LMERRS_RSVD = 20;        !  Reserved
macro LSB$L_LLOCK = 3200,0,0,0 %;
literal LSB$S_LLOCK = 64;               !  LNP Lock Address Register
macro LSBDEF_LLOCK$$_RSVD0 = 3200,0,1,0 %; !  Reserved
macro LSB$V_LADR = 3200,1,28,0 %;
literal LSB$S_LADR = 28;                !  Lock Address <33:6>
macro LSBDEF_LLOCK$$_RSVD1 = 3200,29,2,0 %;
literal LSBDEF_LLOCKS_RSVD1 = 2;        !  Reserved
macro LSB$V_L_BIT = 3200,31,1,0 %;      !  Lock Bit
macro LSB$L_LDIAG = 3328,0,0,0 %;
literal LSB$S_LDIAG = 64;               !  LNP Diagnostic Control Reg
macro LSBDEF_LDIAG$$_RSVD0 = 3328,0,1,0 %; !  Reserved
macro LSB$V_FDIRTY = 3328,1,1,0 %;      !  Force Dirty
macro LSB$V_FSHARE = 3328,2,1,0 %;      !  Force Share
macro LSB$V_FSBE = 3328,3,1,0 %;        !  Force Single Bit Error
macro LSB$V_FDBE = 3328,4,1,0 %;        !  Force Double Bit Error
macro LSB$V_FBCP = 3328,5,1,0 %;        !  Force Bad Command Parity
macro LSB$V_FBDP = 3328,6,1,0 %;        !  Force Bad Data Parity
macro LSB$V_FIGN = 3328,7,1,0 %;        !  Force LSB Ignore
macro LSB$V_TAG_SEL = 3328,8,3,0 %;
literal LSB$S_TAG_SEL = 3;              !  Tag Select
macro LSBDEF_LDIAG$$_RSVD1 = 3328,11,21,0 %;
literal LSBDEF_LDIAGS_RSVD1 = 21;       !  Reserved
macro LSB$L_LTAGA = 3392,0,0,0 %;
literal LSB$S_LTAGA = 64;               !  LNP Tag Address Register
macro LSB$V_TAG_ADDR = 3392,0,19,0 %;
literal LSB$S_TAG_ADDR = 19;            !  Tag Address <23:5>
macro LSBDEF_LTAGA$$_RSVD = 3392,19,13,0 %;
literal LSBDEF_LTAGAS_RSVD = 13;        !  Reserved
macro LSB$L_LTAGW = 3456,0,0,0 %;
literal LSB$S_LTAGW = 64;               !  LNP Tag Write Data Register
macro LSB$V_WTAG_DATA = 3456,0,24,0 %;
literal LSB$S_WTAG_DATA = 24;           !  Tag Data <33:10>
macro LSB$V_BT_PARITY = 3456,24,1,0 %;  !  B-Tag Parity
macro LSB$V_BS_PARITY = 3456,25,1,0 %;  !  B-Stat Parity
macro LSB$V_BM_PARITY = 3456,26,1,0 %;  !  B-Map Parity
macro LSB$V_PM_PARITY = 3456,27,1,0 %;  !  P-Map Parity
macro LSB$V_WVALID = 3456,28,1,0 %;     !  Valid
macro LSB$V_WSHARED = 3456,29,1,0 %;    !  Shared
macro LSB$V_WDIRTY = 3456,30,1,0 %;     !  Dirty
macro LSBDEF_LTAGW$$_RSVD = 3456,31,1,0 %; !   Reserved
macro LSB$L_LCON0 = 3584,0,0,0 %;
literal LSB$S_LCON0 = 64;               !  LSB Console Comms Register 0
macro LSB$L_LCON1 = 3648,0,0,0 %;
literal LSB$S_LCON1 = 64;               !  LSB Console Comms Register 1
macro LSB$L_LPERF = 3840,0,0,0 %;
literal LSB$S_LPERF = 64;               !  LNP Performance Counter Control Register
macro LSB$V_LC0_OVFL = 3840,0,1,0 %;
macro LSB$V_LC1_OVFL = 3840,1,1,0 %;
macro LSB$V_MA_FREQ = 3840,2,2,0 %;
literal LSB$S_MA_FREQ = 2;
macro LSBDEF_LPERF$$_RSVD0 = 3840,4,4,0 %;
literal LSBDEF_LPERFS_RSVD0 = 4;        !   Reserved
macro LSB$V_LC0_SEL = 3840,8,5,0 %;
literal LSB$S_LC0_SEL = 5;
macro LSBDEF_LPERF$$_RSVD1 = 3840,13,1,0 %; !   Reserved
macro LSB$V_LC0_RUN = 3840,14,1,0 %;
macro LSB$V_LC0_HALT = 3840,15,1,0 %;
macro LSB$V_LC1_SEL = 3840,16,5,0 %;
literal LSB$S_LC1_SEL = 5;
macro LSBDEF_LPERF$$_RSVD2 = 3840,21,1,0 %; !   Reserved
macro LSB$V_LC1_RUN = 3840,22,1,0 %;
macro LSB$V_LC1_HALT = 3840,23,1,0 %;
macro LSB$V_N_MASK = 3840,24,8,0 %;
literal LSB$S_N_MASK = 8;               !  N_Mask <7:0>
macro LSB$L_LCNTR0 = 3904,0,0,0 %;
literal LSB$S_LCNTR0 = 64;              !  LNP Performance Counter Register 0
macro LSB$L_LCNTR1 = 3968,0,0,0 %;
literal LSB$S_LCNTR1 = 64;              !  LNP Performance Counter Register 1
macro LSB$L_LMISSADDR = 4032,0,0,0 %;
literal LSB$S_LMISSADDR = 64;           !  LNP Last Miss Address
macro LSB$V_MISS_ADDR = 4032,0,29,0 %;
literal LSB$S_MISS_ADDR = 29;
macro LSBDEF_LMISSADDR$$_RSVD = 4032,29,3,0 %;
literal LSBDEF_LMISSADDRS_RSVD = 3;     !   Reserved
macro LSB$L_IPCNSE = 8192,0,0,0 %;
literal LSB$S_IPCNSE = 64;              !  IOP Chip Error Register
macro LSB$V_MBX_TIP = 8192,0,4,0 %;
literal LSB$S_MBX_TIP = 4;              !  Mailbox Transaction in Prog
macro LSB$V_UP_HOSE_OFLO = 8192,4,4,0 %;
literal LSB$S_UP_HOSE_OFLO = 4;         !  UP HOSE FIFO Overflow
macro LSB$V_UP_HOSE_PKT_ERR = 8192,8,4,0 %;
literal LSB$S_UP_HOSE_PKT_ERR = 4;      !  UP HOSE Packet Error
macro LSB$V_UP_HOSE_PAR_ERR = 8192,12,4,0 %;
literal LSB$S_UP_HOSE_PAR_ERR = 4;      !  UP HOSE Parity Error
macro LSB$V_UP_HIC_IE = 8192,16,1,0 %;  !  UP HIC Internal Error
macro LSB$V_IPC_IE = 8192,17,1,0 %;     !  IPC Internal Error
macro LSB$V_UP_VRTX_ERR = 8192,18,1,0 %; !  UP Vortex Error
macro LSB$V_DN_VRTX_ERR = 8192,19,1,0 %; !  DOWN Vortex Error
macro LSB$V_MULT_INTR_ERR = 8192,20,1,0 %; !  Multiple Interrupt Error
macro LSBDEF_IPCNSE$$_RSVD = 8192,21,10,0 %;
literal LSBDEF_IPCNSES_RSVD = 10;       !  Reserved
macro LSB$V_INTR_NSES = 8192,31,1,0 %;  !  Interrupt on NSES
macro LSB$L_MCR = 8192,0,0,0 %;
literal LSB$S_MCR = 64;                 !  Memory Configuration Register
macro LSB$V_DTYP = 8192,0,1,0 %;        !  DRAM Type
macro LSBDEF_MCR$$_RSVD0 = 8192,1,1,0 %; !  Reserved
macro LSB$V_STRN = 8192,2,2,0 %;
literal LSB$S_STRN = 2;                 !  Number of Strings Installed
macro LSBDEF_MCR$$_RSVD1 = 8192,4,28,0 %;
literal LSBDEF_MCRS_RSVD1 = 28;         !  Reserved
!  See LMMR for bit definitions
macro LSB$L_IPCVR = 8256,0,0,0 %;
literal LSB$S_IPCVR = 64;               !  IOP Chip Vector Register
macro LSB$V_VECTOR = 8256,0,16,0 %;
literal LSB$S_VECTOR = 16;              !  Vector <15:0>
macro LSBDEF_IPCVR$$_RSVD = 8256,16,16,0 %;
literal LSBDEF_IPCVRS_RSVD = 16;
macro LSB$L_AMR = 8256,0,0,0 %;
literal LSB$S_AMR = 64;                 !  Memory Address Mapping Register
macro LSB$V_ENA = 8256,0,1,0 %;         !  Enable
macro LSB$V_INTLV = 8256,1,2,0 %;
literal LSB$S_INTLV = 2;                !  Interleave Level
! 
macro LSB$V_IAD = 8256,3,2,0 %;
literal LSB$S_IAD = 2;                  !  Interleave Address
macro LSB$V_ADW = 8256,5,4,0 %;
literal LSB$S_ADW = 4;                  !  Address Width
macro LSB$V_NUMBANKS = 8256,9,2,0 %;
literal LSB$S_NUMBANKS = 2;             !  Number of Banks Per Module
macro LSBDEF_AMR$$_RSVD = 8256,11,6,0 %;
literal LSBDEF_AMRS_RSVD = 6;           !  Reserved
macro LSB$V_MODADR = 8256,17,15,0 %;
literal LSB$S_MODADR = 15;              !  Module Address
macro LSB$L_IPCMSR = 8320,0,0,0 %;
literal LSB$S_IPCMSR = 64;              !  IOP Chip Mode Select Register
macro LSB$V_ARB_HIGH = 8320,0,1,0 %;    !  Force High Priority Arbitration
macro LSB$V_ARB_CTL = 8320,1,2,0 %;
literal LSB$S_ARB_CTL = 2;              !  Arbitration Control mode
macro LSBDEF_IPCMSR$$_RSVD = 8320,3,29,0 %;
literal LSBDEF_IPCMSRS_RSVD = 29;       !  Reserved
macro LSB$L_MSTR0 = 8320,0,0,0 %;
literal LSB$S_MSTR0 = 64;               !  Memory Self-Test Register 0
macro LSB$L_IPCHST = 8384,0,0,0 %;
literal LSB$S_IPCHST = 64;              !  IOP Chip Hose Status Register
macro LSB$V_H0_STAT = 8384,0,4,0 %;
literal LSB$S_H0_STAT = 4;              !  Hose 0 Status
macro LSB$V_H1_STAT = 8384,4,4,0 %;
literal LSB$S_H1_STAT = 4;              !  Hose 1 Status
macro LSB$V_H2_STAT = 8384,8,4,0 %;
literal LSB$S_H2_STAT = 4;              !  Hose 2 Status
macro LSB$V_H3_STAT = 8384,12,4,0 %;
literal LSB$S_H3_STAT = 4;              !  Hose 3 Status
macro LSBDEF_IPCHST$$_RSVD = 8384,16,12,0 %;
literal LSBDEF_IPCHSTS_RSVD = 12;       !  Reserved
macro LSB$V_HOSE_RST = 8384,28,4,0 %;
literal LSB$S_HOSE_RST = 4;             !  Hose Reset
macro LSB$V_HS_ERROR = 8384,0,1,0 %;    !  ERROR asserted
macro LSB$V_HS_PWROK = 8384,1,1,0 %;    !  Power OK
macro LSB$V_HS_CBLOK = 8384,2,1,0 %;    !  Cable OK
macro LSB$V_HS_PWRTRANS = 8384,3,1,0 %; !  PWROK Transition
macro LSB$L_MSTR1 = 8384,0,0,0 %;
literal LSB$S_MSTR1 = 64;               !  Memory Self-Test Register 1
macro LSB$L_IPCDR = 8448,0,0,0 %;
literal LSB$S_IPCDR = 64;               !  IOP Chip Diagnostic Register
macro LSB$V_FRC_DN_ILL_CMD = 8448,0,1,0 %; !  Force Down Illegal Command
macro LSB$V_FRC_DN_SEQ_ERR = 8448,1,1,0 %; !  Force Down Sequence Error
macro LSB$V_FRC_DN_DPE = 8448,2,2,0 %;
literal LSB$S_FRC_DN_DPE = 2;           !  Force Down Data Parity Error
macro LSBDEF_IPCDR$$_RSVD0 = 8448,4,6,0 %;
literal LSBDEF_IPCDRS_RSVD0 = 6;        !  Reserved
macro LSB$V_DIS_LSB_CMD = 8448,10,1,0 %; !  Disable LSB Command Xmit
macro LSB$V_HIC_LPBCK_EN = 8448,11,1,0 %; !  HIC Loopback Enable
macro LSB$V_FRC_DAT_PE = 8448,12,1,0 %; !  Force Data Parity Error
macro LSB$V_FRC_CMD_PE = 8448,13,1,0 %; !  Force Command Parity Error
macro LSBDEF$$_RSVD1 = 8448,14,8,0 %;
literal LSBDEFS_RSVD1 = 8;              !  Reserved
macro LSB$V_FRC_CNFE = 8448,22,1,0 %;   !  Force CNF Error
macro LSB$V_FRC_CAE = 8448,23,1,0 %;    !  Force CA Error
macro LSB$V_DIAG_ECC = 8448,24,7,0 %;
literal LSB$S_DIAG_ECC = 7;             !  Diagnostic ECC
macro LSB$V_DIAG_ECC_EN = 8448,31,1,0 %; !  Diagnostic ECC Enable
macro LSB$L_FADR = 8448,0,0,0 %;
literal LSB$S_FADR = 64;                !  Memory Failing Address Register
macro LSB$L_MERA = 8512,0,0,0 %;
literal LSB$S_MERA = 64;                !  Memory Error Register A
macro LSB$V_CER = 8512,0,1,0 %;         !  Correctable Read Error
macro LSB$V_UCER = 8512,1,1,0 %;        !  Uncorrectable Read Error
macro LSB$V_MULE = 8512,2,1,0 %;        !  Multiple Errors
macro LSB$V_APER = 8512,3,1,0 %;        !  Address Parity Error
macro LSB$V_CERA = 8512,4,1,0 %;        !  Correctable ECC Error on MICA
macro LSB$V_CERB = 8512,5,1,0 %;        !  Correctable ECC Error on MICB
macro LSB$V_FSTR = 8512,6,3,0 %;
literal LSB$S_FSTR = 3;                 !  Failing String
macro LSB$V_BNKER = 8512,9,1,0 %;       !  Bank Conflict Error
macro LSB$V_UCERA = 8512,10,1,0 %;      !  Uncorrectable ECC Error on MICA
macro LSB$V_UCERB = 8512,11,1,0 %;      !  Uncorrectable ECC Error on MICB
macro LSBDEF_MERA$$_RSVD = 8512,12,20,0 %;
literal LSBDEF_MERAS_RSVD = 20;         !  Reserved
macro LSB$L_MSYNDA = 8576,0,0,0 %;
literal LSB$S_MSYNDA = 64;              !  Memory Error Syndrome Reg A
macro LSB$V_SYND = 8576,0,8,0 %;
literal LSB$S_SYND = 8;                 !  Syndrome
macro LSBDEF_MSYND$$_RSVD = 8576,8,24,0 %;
literal LSBDEF_MSYNDS_RSVD = 24;        !  Reserved
macro LSB$L_MDRA = 8640,0,0,0 %;
literal LSB$S_MDRA = 64;                !  Memory Diagnostic Register A
macro LSB$V_FCBS = 8640,0,1,0 %;        !  Force Check Bit Substitution
macro LSB$V_DRDC = 8640,1,1,0 %;        !  Disable Read Data Correction
macro LSB$V_DWDC = 8640,2,1,0 %;        !  Disable Write Data Correction
macro LSB$V_BPAS = 8640,3,1,0 %;        !  Bypass
macro LSB$V_EXST = 8640,4,1,0 %;        !  Execute Self-Test
macro LSB$V_STPM = 8640,5,1,0 %;        !  Self-Test Pause Mode
macro LSB$V_MODE = 8640,6,1,0 %;        !  Self-Test Mode
macro LSB$V_IGSB = 8640,7,1,0 %;        !  Ignore Single-Bit Self-Test Failure
macro LSB$V_FRPE = 8640,8,1,0 %;        !  Force Row Parity Erro
macro LSB$V_FCPE = 8640,9,1,0 %;        !  Force Column Parity Erro
macro LSBDEF_MDRA$$_RSVD = 8640,10,17,0 %;
literal LSBDEF_MDRAS_RSVD = 17;         !  Reserved
macro LSB$V_DCRD = 8640,27,1,0 %;       !  Corrected Read Data disable
macro LSB$V_RFR = 8640,28,2,0 %;
literal LSB$S_RFR = 2;                  !  Refresh Rate
macro LSB$V_BRFSH = 8640,30,1,0 %;      !  Burst Refresh
macro LSB$V_DRFSH = 8640,31,1,0 %;      !  Disable Refresh
macro LSB$L_MCBSA = 8704,0,0,0 %;
literal LSB$S_MCBSA = 64;               !  Memory Check Bit Subst Reg A
macro LSB$V_SCB = 8704,0,8,0 %;
literal LSB$S_SCB = 8;                  !  Substituted Check Bits
macro LSBDEF_MCBS$$_RSVD = 8704,8,24,0 %;
literal LSBDEF_MCBSS_RSVD = 24;         !  Reserved
macro LSB$L_MERB = 16704,0,0,0 %;
literal LSB$S_MERB = 64;                !  Memory Error Register B
macro LSB$L_MSYNDB = 16768,0,0,0 %;
literal LSB$S_MSYNDB = 64;              !  Memory Error Syndrome Reg B
macro LSB$L_MDRB = 16832,0,0,0 %;
literal LSB$S_MDRB = 64;                !  Memory Diagnostic Register B
macro LSB$L_MCBSB = 16896,0,0,0 %;
literal LSB$S_MCBSB = 64;               !  Memory Check Bit Subst Reg B
 
!*** MODULE $MBADEF ***
! +
!  MASSBUS ADAPTER REGISTER OFFSET DEFINITIONS
! -
literal MBA$M_CSR_OT = 2097152;
literal MBA$M_CSR_PU = 4194304;
literal MBA$M_CSR_PD = 8388608;
literal MBA$M_CSR_XMFLT = 67108864;
literal MBA$M_CSR_MT = 134217728;
literal MBA$M_CSR_URD = 536870912;
literal MBA$M_CSR_WS = 1073741824;
literal MBA$M_CSR_PE = -2147483648;
literal MBA$M_CR_INIT = 1;
literal MBA$M_CR_ABORT = 2;
literal MBA$M_CR_IE = 4;
literal MBA$M_SR_RDTO = 1;
literal MBA$M_SR_ISTO = 2;
literal MBA$M_SR_RDS = 4;
literal MBA$M_SR_ERCONF = 8;
literal MBA$M_SR_INVMAP = 16;
literal MBA$M_SR_MAPPE = 32;
literal MBA$M_SR_MDPE = 64;
literal MBA$M_SR_MBEXC = 128;
literal MBA$M_SR_MXF = 256;
literal MBA$M_SR_WCKLWR = 512;
literal MBA$M_SR_WCKUPR = 1024;
literal MBA$M_SR_DLT = 2048;
literal MBA$M_SR_DTABT = 4096;
literal MBA$M_SR_DTCOMP = 8192;
literal MBA$M_SR_SPE = 16384;
literal MBA$M_SR_ATTN = 65536;
literal MBA$M_SR_MCPE = 131072;
literal MBA$M_SR_NED = 262144;
literal MBA$M_SR_PGE = 524288;
literal MBA$M_SR_CBHUNG = 8388608;
literal MBA$M_SR_CRD = 536870912;
literal MBA$M_SR_NRCONF = 1073741824;
literal MBA$M_SR_DTBUSY = -2147483648;
literal MBA$M_ERROR = 942079;           !  PROGRAM ERROR 
literal MBA$S_MBADEF = 3072;
macro MBA$L_CSR = 0,0,32,0 %;           ! CONFIGURATION STATUS REGISTER 
macro MBA$V_CSR_ADCOD = 0,0,8,0 %;
literal MBA$S_CSR_ADCOD = 8;            !  ADAPTER CODE FIELD 
macro MBA$V_CSR_OT = 0,21,1,0 %;        !  OVER TEMPERATURE 
macro MBA$V_CSR_PU = 0,22,1,0 %;        !  ADAPTER POWER UP 
macro MBA$V_CSR_PD = 0,23,1,0 %;        !  ADAPTER POWER DOWN 
macro MBA$V_CSR_XMFLT = 0,26,1,0 %;     !  TRANSMITTER FAULT 
macro MBA$V_CSR_MT = 0,27,1,0 %;        !  MULTIPLE TRANSMITTERS 
macro MBA$V_CSR_URD = 0,29,1,0 %;       !  UNEXPECTED READ DATA 
macro MBA$V_CSR_WS = 0,30,1,0 %;        !  WRITE SEQUENCE DATA 
macro MBA$V_CSR_PE = 0,31,1,0 %;        !  SBI PARITY ERROR 
macro MBA$L_CR = 4,0,32,0 %;            ! CONTROL REGISTER 
macro MBA$V_CR_INIT = 4,0,1,0 %;        !  ADAPTER INITIALIZATION 
macro MBA$V_CR_ABORT = 4,1,1,0 %;       !  ABORT OPERATION 
macro MBA$V_CR_IE = 4,2,1,0 %;          !  INTERRUPT ENABLE 
macro MBA$L_SR = 8,0,32,0 %;            ! STATUS REGISTER 
macro MBA$V_SR_RDTO = 8,0,1,0 %;        !  READ DATA TIMEOUT 
macro MBA$V_SR_ISTO = 8,1,1,0 %;        !  INTERFACE SEQUENCE TIMEOUT 
macro MBA$V_SR_RDS = 8,2,1,0 %;         !  READ DATA SUBSTITUTE 
macro MBA$V_SR_ERCONF = 8,3,1,0 %;      !  ERROR CONFIRMATION 
macro MBA$V_SR_INVMAP = 8,4,1,0 %;      !  INVALID MAP REGISTER 
macro MBA$V_SR_MAPPE = 8,5,1,0 %;       !  MAP PARITY ERROR 
macro MBA$V_SR_MDPE = 8,6,1,0 %;        !  MASSBUS DATA PARITY ERROR 
macro MBA$V_SR_MBEXC = 8,7,1,0 %;       !  MASSBUS EXCEPTION 
macro MBA$V_SR_MXF = 8,8,1,0 %;         !  MISSED TRANSFER ERROR 
macro MBA$V_SR_WCKLWR = 8,9,1,0 %;      !  WRITE CHECK ERROR LOWER BYTE 
macro MBA$V_SR_WCKUPR = 8,10,1,0 %;     !  WRITE CHECK ERROR UPPER BYTE 
macro MBA$V_SR_DLT = 8,11,1,0 %;        !  DATA LATE ERROR 
macro MBA$V_SR_DTABT = 8,12,1,0 %;      !  DATA TRANSFER ABORTED 
macro MBA$V_SR_DTCOMP = 8,13,1,0 %;     !  DATA TRANSFER COMPLETE 
macro MBA$V_SR_SPE = 8,14,1,0 %;        !  SILO PARITY ERROR 
macro MBA$V_SR_ATTN = 8,16,1,0 %;       !  MASSBUS ATTENTION 
macro MBA$V_SR_MCPE = 8,17,1,0 %;       !  MASSBUS COMTROL PARITY ERROR 
macro MBA$V_SR_NED = 8,18,1,0 %;        !  NONEXISTENT DRIVE 
macro MBA$V_SR_PGE = 8,19,1,0 %;        !  PROGRAM ERROR 
macro MBA$V_SR_CBHUNG = 8,23,1,0 %;     !  CB HUNG 
macro MBA$V_SR_CRD = 8,29,1,0 %;        !  CORRECTED READ DATA 
macro MBA$V_SR_NRCONF = 8,30,1,0 %;     !  NO RESPONSE CONFIRMATION 
macro MBA$V_SR_DTBUSY = 8,31,1,0 %;     !  DATA TRANSFER BUSY 
!  ERROR BITS 
macro MBA$L_VAR = 12,0,32,0 %;          ! VIRTUAL ADDRESS REGISTER 
macro MBA$L_BCR = 16,0,32,0 %;          ! BYTE COUNT REGISTER 
macro MBA$L_DR = 20,0,32,0 %;           ! DIAGNOSTIC REGISTER 
macro MBA$L_SELMR = 24,0,32,0 %;        ! SELECTED MAP REGISTER 
macro MBA$L_ERB = 1024,0,32,0 %;        ! BASE ADDRESS OF EXTERNAL REGISTERS 
macro MBA$V_ERB_UNIT = 1024,7,3,0 %;
literal MBA$S_ERB_UNIT = 3;             !  DRIVE UNIT NUMBER 
macro MBA$L_AS = 1040,0,32,0 %;         ! ATTENTION SUMMARY REGISTER 
!  TO POSITION TO 2048
macro MBA$L_MAP = 2048,0,0,0 %;
literal MBA$S_MAP = 1024;               ! MAP REGISTERS 
 
!*** MODULE $MBXDEF ***
! +
!  SHARED MEMORY MAILBOX CONTROL BLOCK DEFINITIONS
! 
!  THERE IS ONE MAILBOX CONTROL BLOCK FOR EACH MAILBOX IN SHARED
!  MEMORY.  ANY PROCESSOR THAT WANTS TO ACCESS THE MAILBOX CREATES
!  A UCB TO CONTROL ACCESS TO THE MAILBOX.
! -
literal MBX$M_ALLOC = 1;
literal MBX$M_VALID = 2;
literal MBX$M_DELPEND = 4;
literal MBX$M_QUOTALCK = 8;
literal MBX$K_LENGTH = 48;              ! LENGTH OF STRUCTURE 
literal MBX$C_LENGTH = 48;              ! LENGTH OF STRUCTURE 
literal MBX$S_MBXDEF = 48;
macro MBX$Q_MSG = 0,0,0,0 %;
literal MBX$S_MSG = 8;                  ! MESSAGE QUEUE LISTHEAD 
macro MBX$B_FLAGS = 8,0,8,0 %;          ! FLAGS 
macro MBX$V_ALLOC = 8,0,1,0 %;          !  MAILBOX ALLOCATED 
macro MBX$V_VALID = 8,1,1,0 %;          !  MAILBOX INITIALIZED AND USEABLE 
macro MBX$V_DELPEND = 8,2,1,0 %;        !  DELETE PENDING 
macro MBX$V_QUOTALCK = 8,3,1,0 %;       !  QUOTA/COUNT MODIFICATION LOCK 
macro MBX$B_CREATPORT = 9,0,8,0 %;      ! PORT NUMBER OF MAILBOX CREATOR 
macro MBX$W_UNIT = 10,0,16,0 %;         ! MAILBOX UNIT NUMBER 
macro MBX$W_REF = 12,0,16,0 %;          ! REFERENCE FLAGS (1 BIT/PORT) 
macro MBX$W_READER = 14,0,16,0 %;       ! WAITING READER (1 BIT/PORT) 
macro MBX$W_READAST = 16,0,16,0 %;      ! WAITING READ AST (1 BIT/PORT) 
macro MBX$W_WRITAST = 18,0,16,0 %;      ! WAITING WRITE AST (1 BIT/PORT) 
macro MBX$W_MAXMSG = 20,0,16,0 %;       ! MAXIMUM MESSAGE SIZE 
macro MBX$W_MSGCNT = 22,0,16,0 %;       ! CURRENT NUMBER OF MESSAGES 
macro MBX$W_BUFFQUO = 24,0,16,0 %;      ! BUFFER QUOTA 
macro MBX$W_PROT = 26,0,16,0 %;         ! PROTECTION MASK 
macro MBX$L_OWNUIC = 28,0,32,0 %;       ! OWNER UIC 
macro MBX$T_NAME = 32,0,0,0 %;
literal MBX$S_NAME = 16;                ! MAILBOX NAME (COUNTED STRING) 
!  *** THE LENGTH OF THIS STRUCTURE MUST BE AN EVEN MULTIPLE OF 8 ***
!  *** BECAUSE THE MESSAGE QUEUE HEADER MUST BE QUADWORD ALIGNED ***
 
!*** MODULE $MCHKDEF ***
! +
!  MACHINE CHECK ERROR RECOVERY BLOCK MASK BIT DEFFINITIONS
!  BITS USED TO FILTER AND TEST FOR ERROR TYPES
! -
literal MCHK$M_LOG = 1;
literal MCHK$M_MCK = 2;
literal MCHK$M_NEXM = 4;
literal MCHK$M_UBA = 8;
literal MCHK$M_RSVD4 = 16;
literal MCHK$M_RSVD5 = 32;
literal MCHK$M_RSVD6 = 64;
literal MCHK$M_RSVD7 = 128;
literal MCHK$M_RSVD8 = 256;
literal MCHK$M_RSVD9 = 512;
literal MCHK$M_RSVD10 = 1024;
literal MCHK$M_RSVD11 = 2048;
literal MCHK$M_RSVD12 = 4096;
literal MCHK$M_RSVD13 = 8192;
literal MCHK$M_RSVD14 = 16384;
literal MCHK$M_RSVD15 = 32768;
literal MCHK$M_RSVD16 = 65536;
literal MCHK$M_RSVD17 = 131072;
literal MCHK$M_RSVD18 = 262144;
literal MCHK$M_RSVD19 = 524288;
literal MCHK$M_RSVD20 = 1048576;
literal MCHK$M_RSVD21 = 2097152;
literal MCHK$M_RSVD22 = 4194304;
literal MCHK$M_RSVD23 = 8388608;
literal MCHK$M_RSVD24 = 16777216;
literal MCHK$M_RSVD25 = 33554432;
literal MCHK$M_RSVD26 = 67108864;
literal MCHK$M_RSVD27 = 134217728;
literal MCHK$M_RSVD28 = 268435456;
literal MCHK$M_RSVD29 = 536870912;
literal MCHK$M_RSVD30 = 1073741824;
literal MCHK$M_SYSLOA = -2147483648;
literal MCHK$S_MCHKDEF = 4;
macro MCHK$V_LOG = 0,0,1,0 %;           ! INHIBIT ERROR LOGGING FOR THE ERROR 
macro MCHK$V_MCK = 0,1,1,0 %;           ! PROTECT AGAINST MACHINE CHECKS 
macro MCHK$V_NEXM = 0,2,1,0 %;          ! PROTECT AGAINST NON-EXISTENT MEMORY 
macro MCHK$V_UBA = 0,3,1,0 %;           ! PROTECT AGAINST UBA ADAPTER ERROR INTRPT 
macro MCHK$V_RSVD4 = 0,4,1,0 %;         !  reserved
macro MCHK$V_RSVD5 = 0,5,1,0 %;         !  reserved
macro MCHK$V_RSVD6 = 0,6,1,0 %;         !  reserved
macro MCHK$V_RSVD7 = 0,7,1,0 %;         !  reserved
macro MCHK$V_RSVD8 = 0,8,1,0 %;         !  reserved
macro MCHK$V_RSVD9 = 0,9,1,0 %;         !  reserved
macro MCHK$V_RSVD10 = 0,10,1,0 %;       !  reserved
macro MCHK$V_RSVD11 = 0,11,1,0 %;       !  reserved
macro MCHK$V_RSVD12 = 0,12,1,0 %;       !  reserved
macro MCHK$V_RSVD13 = 0,13,1,0 %;       !  reserved
macro MCHK$V_RSVD14 = 0,14,1,0 %;       !  reserved
macro MCHK$V_RSVD15 = 0,15,1,0 %;       !  reserved
macro MCHK$V_RSVD16 = 0,16,1,0 %;       !  reserved
macro MCHK$V_RSVD17 = 0,17,1,0 %;       !  reserved
macro MCHK$V_RSVD18 = 0,18,1,0 %;       !  reserved
macro MCHK$V_RSVD19 = 0,19,1,0 %;       !  reserved
macro MCHK$V_RSVD20 = 0,20,1,0 %;       !  reserved
macro MCHK$V_RSVD21 = 0,21,1,0 %;       !  reserved
macro MCHK$V_RSVD22 = 0,22,1,0 %;       !  reserved
macro MCHK$V_RSVD23 = 0,23,1,0 %;       !  reserved
macro MCHK$V_RSVD24 = 0,24,1,0 %;       !  reserved
macro MCHK$V_RSVD25 = 0,25,1,0 %;       !  reserved
macro MCHK$V_RSVD26 = 0,26,1,0 %;       !  reserved
macro MCHK$V_RSVD27 = 0,27,1,0 %;       !  reserved
macro MCHK$V_RSVD28 = 0,28,1,0 %;       !  reserved
macro MCHK$V_RSVD29 = 0,29,1,0 %;       !  reserved
macro MCHK$V_RSVD30 = 0,30,1,0 %;       !  reserved
macro MCHK$V_SYSLOA = 0,31,1,0 %;       ! Protect against specific SYSLOA-generated mchecks
 
!*** MODULE $MMBDEF ***
! ++
!  VOLUME SHADOWING MINI-MERGE MANAGEMENT BLOCK STRUCTURE DEFINITIONS 
! --
literal MMB$K_MAXMBRS = 3;              !  Maximum number of members
literal MMB$C_MAXMBRS = 3;              !  Maximum number of members
literal MMB$K_MAXNODES = 96;            !  Maximum number of nodes
literal MMB$C_MAXNODES = 96;            !  Maximum number of nodes
!  
literal MMB$M_VALID = 1;
literal MMB$K_LENGTH = 264;             ! Length of Structure
literal MMB$C_LENGTH = 264;             ! Length of Structure
literal MMB$S_MMBDEF = 264;
macro MMB$L_SHAD = 0,0,32,0 %;          !  Pointer to SHAD
macro MMB$L_BLINK = 4,0,32,0 %;         !  Backward link
macro MMB$W_SIZE = 8,0,16,0 %;          !  Size of this structure
macro MMB$B_TYPE = 10,0,8,0 %;          !  Standard fields
macro MMB$B_SUBTYP = 11,0,8,0 %;        !   ...
macro MMB$L_DST_TBL = 12,0,32,0 %;      !  Destination table
macro MMB$L_DST_ENTRIES = 16,0,32,0 %;  !  Curr. Dst table entries.
macro MMB$L_DST_MAX_ENTRIES = 20,0,32,0 %; !  Dst table max entries.
macro MMB$B_DEV_STS = 24,0,8,0 %;       !  Member status bits
macro MMB$V_VALID = 24,0,1,0 %;         !  Status information is valid
macro MMB$b_filler = 27,0,8,0 %;        !  Longword align.
macro MMB$L_ENTRIES = 28,0,0,0 %;
literal MMB$S_ENTRIES = 12;             !  No. of entries from cntrlr.
macro MMB$L_OFFSET = 40,0,0,0 %;
literal MMB$S_OFFSET = 12;              !  Controller entry Offset
macro MMB$L_ENT_BUF = 52,0,32,0 %;      !  Entry buffer addresses
macro MMB$W_UNIT_NO = 56,0,0,0 %;
literal MMB$S_UNIT_NO = 6;              !  Device Unit Number.
macro MMB$w_filler = 62,0,0,0 %;
literal MMB$s_filler = 6;               !  Longword align.
macro MMB$L_CRASHED_NODES = 68,0,32,0 %; !  Number of cnids.
macro MMB$W_CNIDS = 72,0,0,0 %;
literal MMB$S_CNIDS = 192;              ! 
! 	    Destination Table Descriptor
literal DTD$M_VALID = 1;
literal DTD$M_MRG_MAND = 2;
literal DTD$K_LENGTH = 16;              ! Length of Structure
literal DTD$C_LENGTH = 16;              ! Length of Structure
literal DTD$S_DST_TABLE_DESC = 16;
macro DTD$W_COUNT = 0,0,16,0 %;         !  Successful entries
macro DTD$W_UNIT = 2,0,16,0 %;          !  Unit Number
macro DTD$L_LENGTH = 4,0,32,0 %;        !  Transfer Length
macro DTD$L_LBN = 8,0,32,0 %;           !  Starting Logical Block Number
macro DTD$W_HRN = 12,0,16,0 %;          !  Host Reference Number
macro DTD$W_STS = 14,0,16,0 %;          !  Descriptor Flags
macro DTD$V_VALID = 14,0,1,0 %;         !  Slot valid			
macro DTD$V_MRG_MAND = 14,1,1,0 %;      !  Entry merge mandatory.
 
!*** MODULE $MMGDEF ***
!         -F        ,B,0                        /* ending address of negated structure
!  (needed to obtain length definition)
literal MMG$K_LENGTH = -36;             !  size of scratch area 
literal MMG$C_LENGTH = -36;             !  size of scratch area 
literal MMG$M_CHGPAGFIL = 256;
literal MMG$M_DELGBLDON = 512;
literal MMG$M_NOWAIT_IPL0 = 1024;
literal MMG$M_NO_OVERMAP = 2048;
literal MMG$M_JSB_ALTSUBR = 4096;
literal MMG$S_MMGDEF = 37;
macro MMG$L_ALTSUBR = -36,0,32,0 %;     !  address of POSIX PML callback
macro MMG$L_PGFLCNT = -32,0,32,0 %;     !  remaining page file quota
macro MMG$L_EFBLK = -28,0,32,0 %;       !  stored end-of-file block from WCB 
macro MMG$L_VFYFLAGS = -24,0,32,0 %;    !  verified section flags and maximum 
!   access mode for writing
macro MMG$L_SVSTARTVA = -20,0,32,0 %;   !  saved starting virtual address 
macro MMG$L_PAGESUBR = -16,0,32,0 %;    !  address of per page subroutine 
macro MMG$L_SAVRETADR = -12,0,32,0 %;   !  saved return address range 
macro MMG$L_CALLEDIPL = -8,0,32,0 %;    !  caller's IPL 
macro MMG$L_MAXACMODE = -4,0,32,0 %;    !  maximized read access mode 
! 
macro MMG$V_CHGPAGFIL = -4,8,1,0 %;     !  charge page file for this PTE 
macro MMG$V_DELGBLDON = -4,9,1,0 %;     !  global pages in this range 
!   already deleted
macro MMG$V_NOWAIT_IPL0 = -4,10,1,0 %;  !  abort instead of dropping to 0
macro MMG$V_NO_OVERMAP = -4,11,1,0 %;   !  don't overmap
macro MMG$V_JSB_ALTSUBR = -4,12,1,0 %;  !  jsb altsubr(sp)
! 
 
!*** MODULE $MPWDEF ***
literal MPW$C_IDLE = 0;
literal MPW$C_MAINTAIN = 1;
literal MPW$C_SVAPTE = 2;
literal MPW$C_OPCCRASH = 3;
literal MPW$C_MAXSTATE = 4;
literal MPW$C_DPTSCAN = 0;
literal MPW$C_DGBLSC = 1;
literal MPW$C_RELPHD = 2;
literal MPW$C_FREELIM = 3;
literal MPW$C_MPWCHECK = 4;
literal MPW$C_CRASH = 5;
literal MPW$C_MAXID = 6;
literal MPW$M_RCODE = 255;
literal MPW$M_RMODIFIERS = 65280;
literal MPW$M_RESERVED = 16711680;
literal MPW$M_IDCODE = -16777216;
literal MPW$M_LOLIMIT = 256;
literal MPW$S_MPWDEF = 4;
!  Basic request code/modifiers structure
macro MPW$V_RCODE = 0,0,8,0 %;
literal MPW$S_RCODE = 8;                !  Request Code Field
macro MPW$V_RMODIFIERS = 0,8,8,0 %;
literal MPW$S_RMODIFIERS = 8;           !  Request Modifiers Field
macro MPW$V_RESERVED = 0,16,8,0 %;
literal MPW$S_RESERVED = 8;
macro MPW$V_IDCODE = 0,24,8,0 %;
literal MPW$S_IDCODE = 8;               !  Requestor ID code Field
!  Request modifiers for MAINTAIN request
macro MPW$V_LOLIMIT = 0,8,1,0 %;        !  New MPL low limit specified in R1
 
!*** MODULE $MTLDEF ***
! +
!  MOUNTED VOLUME LIST ENTRY. ONE SUCH ENTRY APPEARS IN THE PROCESS MOUNTED
!  VOLUME LIST FOR EACH VOLUME MOUNTED BY THE PROCESS AS /SHARE OR /NOSHARE.
!  IN ADDITION, EACH VOLUME MOUNTED /SYSTEM OR /GROUP HAS AN ENTRY IN THE
!  SYSTEM WIDE MOUNTED VOLUME LIST.
! -
literal MTL$K_LENGTH = 28;              !  LENGTH OF STRUCTURE 
literal MTL$C_LENGTH = 28;              !  LENGTH OF STRUCTURE 
literal MTL$S_MTLDEF = 28;
macro MTL$L_MTLFL = 0,0,32,0 %;         !  FORWARD LIST POINTER 
macro MTL$L_MTLBL = 4,0,32,0 %;         !  BACK LIST POINTER 
macro MTL$W_SIZE = 8,0,16,0 %;          !  STRUCTURE SIZE IN BYTES 
macro MTL$B_TYPE = 10,0,8,0 %;          !  STRUCTURE TYPE CODE 
macro MTL$B_STATUS = 11,0,8,0 %;        !  STATUS BYTE 
macro MTL$V_VOLSET = 11,0,1,0 %;        !  ENTRY IS FOR A VOLUME SET 
macro MTL$L_UCB = 12,0,32,0 %;          !  POINTER TO DEVICE UCB 
macro MTL$L_LOGNAME = 16,0,32,0 %;      !  POINTER TO ASSOCIATED LOGICAL NAME
macro MTL$L_LOGNAM2 = 20,0,32,0 %;      !  POINTER TO ALTERNATE LOGICAL NAME 
 
!*** MODULE $MTXDEF ***
! +
!  MUTEX DEFINITIONS
! -
literal MTX$S_MTXDEF = 4;
macro MTX$V_WRT = 0,16,1,0 %;           !  WRITE PENDING OR IN PROGRESS 
macro MTX$V_INTERLOCK = 0,17,1,0 %;     !  INTERLOCK ACCESS TO MUTEX
macro MTX$W_OWNCNT = 0,0,16,0 %;        ! OWNERSHIP COUNT 
macro MTX$W_STS = 2,0,16,0 %;           ! STATUS BITS 
 
!*** MODULE $MPBDEF ***
! +
!  MULTIPROCESSOR LOGICAL CONSOLE RING BUFFER CONTROL BLOCK DEFINITIONS
! -
literal MPB$M_INPROG = 1;
literal MPB$M_COLD_BOOT = 2;
literal MPB$M_RESTART = 4;
literal MPB$M_PENDING = 8;
literal MPB$M_TQEACT = 16;
literal MPB$K_LENGTH = 64;              !  Minimum size of structure
literal MPB$C_LENGTH = 64;              !  Minimum size of structure
! 
literal MPB$S_MPBDEF = 68;
macro MPB$L_PTR = 0,0,32,0 %;           !  Next empty ring position
macro MPB$L_LIMIT = 4,0,32,0 %;         !  Size of ring buffer
macro MPB$W_SIZE = 8,0,16,0 %;          !  Size
macro MPB$B_TYPE = 10,0,8,0 %;          !  Type
macro MPB$B_SUBTYPE = 11,0,8,0 %;       !  Subtype
macro MPB$L_RING = 12,0,32,0 %;         !  Pointer to start of ring buffer
macro MPB$L_NXTSTATE = 16,0,32,0 %;     !  next attached console state
macro MPB$L_CMD_PTR = 20,0,32,0 %;      !  next byte in command string 
macro MPB$L_TQE = 24,0,32,0 %;          !  Pointer to TQE
macro MPB$Q_ASCIISP = 28,0,0,0 %;
literal MPB$S_ASCIISP = 8;              !  ASCII SP value for restart 
macro MPB$B_ASCIIAP = 36,0,8,0 %;       !  low byte of ASCII AP for restart 
macro MPB$B_RETRY_CNT = 37,0,8,0 %;     !  CPU BOOT retry count
macro MPB$W_STATUS = 38,0,16,0 %;
macro MPB$V_INPROG = 38,0,1,0 %;        !  boot fork in progress 
macro MPB$V_COLD_BOOT = 38,1,1,0 %;     !  cold boot in progree 
macro MPB$V_RESTART = 38,2,1,0 %;       !  restart in progress 
macro MPB$V_PENDING = 38,3,1,0 %;       !  boot thread pending fork
macro MPB$V_TQEACT = 38,4,1,0 %;        !  TQE is active
macro MPB$Q_HALT_PC = 40,0,0,0 %;
literal MPB$S_HALT_PC = 8;              !  ASCII halt PC for restart 
macro MPB$Q_HALT_PSL = 48,0,0,0 %;
literal MPB$S_HALT_PSL = 8;             !  ASCII halt PSL for restart 
macro MPB$L_PER_CPU = 56,0,32,0 %;      !  Virtual address of CPU database
macro MPB$L_PSILO = 60,0,32,0 %;        !  silo to accumulate console prompt (Scorpio)
macro MPB$L_CCABUF = 60,0,32,0 %;       !  Virtual address of CCA buffer (Calypso)
macro MPB$L_SLOT_ADDR = 60,0,32,0 %;    !  Virtual address of HWRPB CPU slot (Laser)
!  A FORK BLOCK will be added to the end of this structure,
!  followed by the ring buffer.
! 
macro MPB$L_FKB = 64,0,32,0 %;          !  Start of fork block
 
!*** MODULE $MPMDEF ***
! +
!  MULTIPORT MEMORY (MA780/MA750) ADAPTER REGISTER OFFSET DEFINITIONS
! -
! 
!  The UETP for the MA780 depends on some of the following definitions.  Please
!  let someone in that group know if the definitions change substantially.
! 
literal MPM$C_PORTS = 4;                ! MAXIMUM NUMBER OF PORTS PER MEMORY 
literal MPM$M_CSR_PORT = 3;
literal MPM$M_CSR_ADCOD = 255;
literal MPM$M_CSR_PU = 4194304;
literal MPM$M_CSR_PD = 8388608;
literal MPM$M_CSR_XMFLT = 67108864;
literal MPM$M_CSR_MT = 134217728;
literal MPM$M_CSR_IS = 268435456;
literal MPM$M_CSR_WS = 1073741824;
literal MPM$M_CSR_PE = -2147483648;
literal MPM$C_CSR_TYPE = 64;            !  MULTIPORT ADAPTER TYPE CODE 
literal MPM$M_CR_MIE = 1;
literal MPM$M_CR_EIE = 2;
literal MPM$M_CR_ERRS = -16777216;
literal MPM$M_SR_EIE = 2;
literal MPM$M_SR_SS = 8192;
literal MPM$M_SR_IDL = 16384;
literal MPM$M_SR_IT = 32768;
literal MPM$M_SR_AGP = 268435456;
literal MPM$M_SR_XDF = 536870912;
literal MPM$M_SR_MXF = 1073741824;
literal MPM$M_SR_ACA = -2147483648;
literal MPM$M_INV_ID = 65535;
literal MPM$M_INV_MEMSZ = 458752;
literal MPM$M_INV_STADR = 2146435072;
literal MPM$M_INV_CACHF = -2147483648;
literal MPM$M_ERR_ELR = 268435456;
literal MPM$M_ERR_HI = 536870912;
literal MPM$M_ERR_ICRD = 1073741824;
literal MPM$M_ERR_IMP = -2147483648;
literal MPM$M_CSR1_MIA = 1024;
literal MPM$S_MPMDEF = 40;
macro MPM$L_CSR = 0,0,32,0 %;           ! CONFIGURATION STATUS REGISTER 
macro MPM$V_CSR_PORT = 0,0,2,0 %;
literal MPM$S_CSR_PORT = 2;             !  PORT NUMBER 
macro MPM$V_CSR_ADCOD = 0,0,8,0 %;
literal MPM$S_CSR_ADCOD = 8;            !  ADAPTER CODE FIELD 
macro MPM$V_CSR_PU = 0,22,1,0 %;        !  ADAPTER POWER UP 
macro MPM$V_CSR_PD = 0,23,1,0 %;        !  ADAPTER POWER DOWN 
macro MPM$V_CSR_XMFLT = 0,26,1,0 %;     !  TRANSMITTER FAULT 
macro MPM$V_CSR_MT = 0,27,1,0 %;        !  MULTIPLE TRANSMITTERS 
macro MPM$V_CSR_IS = 0,28,1,0 %;        !  INTERLOCK SEQUENCE 
macro MPM$V_CSR_WS = 0,30,1,0 %;        !  WRITE SEQUENCE DATA 
macro MPM$V_CSR_PE = 0,31,1,0 %;        !  SBI PARITY ERROR 
macro MPM$L_CR = 4,0,32,0 %;            ! CONTROL REGISTER 
macro MPM$V_CR_MIE = 4,0,1,0 %;         !  MASTER INTERRUPT ENABLE 
macro MPM$V_CR_EIE = 4,1,1,0 %;         !  ERROR INTERRUPT ENABLE 
macro MPM$V_CR_ERRS = 4,24,8,0 %;
literal MPM$S_CR_ERRS = 8;              !  PORT INTERFACE ERRORS 
macro MPM$L_SR = 8,0,32,0 %;            ! STATUS REGISTER 
macro MPM$V_SR_EIE = 8,1,1,0 %;         !  ERROR INTERRUPT ENABLE 
macro MPM$V_SR_SS = 8,13,1,0 %;         !  SINGLE STEP 
macro MPM$V_SR_IDL = 8,14,1,0 %;        !  INVALIDATE DATA LOST IN MPC 
macro MPM$V_SR_IT = 8,15,1,0 %;         !  INTERLOCK TIMEOUT 
macro MPM$V_SR_AGP = 8,28,1,0 %;        !  ADMI GRANT PARITY ERROR 
macro MPM$V_SR_XDF = 8,29,1,0 %;        !  XMIT DURING FAULT 
macro MPM$V_SR_MXF = 8,30,1,0 %;        !  MULTIPLE XMITTER FAULT 
macro MPM$V_SR_ACA = 8,31,1,0 %;        !  ADMI COMMAND ABORT 
macro MPM$L_INV = 12,0,32,0 %;          ! INVALIDATION CONTROL REGISTER 
macro MPM$V_INV_ID = 12,0,16,0 %;
literal MPM$S_INV_ID = 16;              !  CACHED DEVICE NEXUS ID'S 
macro MPM$V_INV_MEMSZ = 12,16,3,0 %;
literal MPM$S_INV_MEMSZ = 3;            !  MEMORY SIZE (256KB BOARDS) 
macro MPM$V_INV_STADR = 12,20,11,0 %;
literal MPM$S_INV_STADR = 11;           !  STARTING SBI ADDR OF MEMORY 
macro MPM$V_INV_CACHF = 12,31,1,0 %;    !  CACHED FORCE (IGNORE ID'S) 
macro MPM$L_ERR = 16,0,32,0 %;          ! ARRAY ERROR REGISTER 
macro MPM$V_ERR_ELR = 16,28,1,0 %;      !  ERROR LOG REQUEST 
macro MPM$V_ERR_HI = 16,29,1,0 %;       !  HIGH ERROR RATE 
macro MPM$V_ERR_ICRD = 16,30,1,0 %;     !  INHIBIT CRD ERRORS 
macro MPM$V_ERR_IMP = 16,31,1,0 %;      !  INVALIDATE MAP PARITY ERROR 
macro MPM$L_CSR0 = 20,0,32,0 %;         ! CONFIGURATION STATUS REGISTER 0 
macro MPM$V_CSR0_POW = 20,4,4,0 %;
literal MPM$S_CSR0_POW = 4;             !  PER PORT POWER STATUS 
macro MPM$V_CSR0_ERR = 20,8,4,0 %;
literal MPM$S_CSR0_ERR = 4;             !  PER PORT ERROR STATUS 
macro MPM$V_CSR0_ONL = 20,12,4,0 %;
literal MPM$S_CSR0_ONL = 4;             !  PER PORT ONLINE STATUS 
macro MPM$L_CSR1 = 24,0,32,0 %;         ! CONFIGURATION STATUS REGISTER 1 
macro MPM$V_CSR1_MIA = 24,10,1,0 %;     !  MULTIPLE INTERLOCK ACCEPTED 
macro MPM$L_MR = 28,0,32,0 %;           ! MAINTENANCE REGISTER 
macro MPM$V_MR_UNIT = 28,14,2,0 %;
literal MPM$S_MR_UNIT = 2;              !  MEMORY UNIT NUMBER 
macro MPM$L_IIR = 32,0,32,0 %;          ! INTERPORT INTERRUPT REQUEST REGISTER 
macro MPM$V_IIR_STS = 32,0,16,0 %;
literal MPM$S_IIR_STS = 16;             !  STATUS BITS (WRITE TO CLEAR) 
macro MPM$V_IIR_CTL = 32,16,16,0 %;
literal MPM$S_IIR_CTL = 16;             !  CONTROL BITS (WRITE TO SET STATUS BITS) 
macro MPM$L_IIE = 36,0,32,0 %;          ! INTERPORT INTERRUPT ENABLE REGISTER 
macro MPM$V_IIE_STS = 36,0,16,0 %;
literal MPM$S_IIE_STS = 16;             !  CONTROL BITS (WRITE TO CLEAR) 
macro MPM$V_IIE_CTL = 36,16,16,0 %;
literal MPM$S_IIE_CTL = 16;             !  STATUS BITS (WRITE TO SET STATUS BITS) 
 
!*** MODULE $MSLGDEF ***
! +
!  MSLG, MScp error LoG message definitions
!  	These definitions describe the format of the error log messages 
!  	generated by MSCP and TMSCP devices.
! -
! 
! 	Generic MSCP/TMSCP error log entry format
! 
literal MSLG$M_LF_SQNRS = 1;
literal MSLG$M_LF_INFO = 2;
literal MSLG$M_LF_DCDC = 8;
literal MSLG$M_LF_RPLER = 16;
literal MSLG$M_LF_BBR = 32;
literal MSLG$M_LF_CONT = 64;
literal MSLG$M_LF_SUCC = 128;
literal MSLG$K_CNT_ERR = 0;
literal MSLG$K_BUS_ADDR = 1;
literal MSLG$K_DISK_TRN = 2;
literal MSLG$K_SDI = 3;
literal MSLG$K_SML_DSK = 4;
literal MSLG$K_TAPE_TRN = 5;
literal MSLG$K_STI_ERR = 6;
literal MSLG$K_STI_DEL = 7;
literal MSLG$K_STI_FEL = 8;
literal MSLG$K_REPLACE = 9;
literal MSLG$K_LDR_ERR = 10;
literal MSLG$K_DCD_CORR = 12;
literal MSLG$S_GENERIC_MSCP_ERRLOG = 44;
macro MSLG$L_CMD_REF = 0,0,32,0 %;      !  Command reference number 
macro MSLG$W_UNIT = 4,0,16,0 %;         !  Unit number 
macro MSLG$W_SEQ_NUM = 6,0,16,0 %;      !  Sequence Number
macro MSLG$B_FORMAT = 8,0,8,0 %;        !  Format
macro MSLG$B_FLAGS = 9,0,8,0 %;         !  Error Log Message Flags
macro MSLG$V_LF_SQNRS = 9,0,1,0 %;      !    Sequence Number Reset
macro MSLG$V_LF_INFO = 9,1,1,0 %;       !    Informational
macro MSLG$V_LF_DCDC = 9,3,1,0 %;       !    Disk Copy Data Correlated
macro MSLG$V_LF_RPLER = 9,4,1,0 %;      !    Error during replacement
macro MSLG$V_LF_BBR = 9,5,1,0 %;        !    Bad block replacement request
macro MSLG$V_LF_CONT = 9,6,1,0 %;       !    Operation continuing
macro MSLG$V_LF_SUCC = 9,7,1,0 %;       !    Operation successful
macro MSLG$W_EVENT = 10,0,16,0 %;       !  Event Code
macro MSLG$Q_CNT_ID = 12,0,0,0 %;
literal MSLG$S_CNT_ID = 8;              !  Controller ID
macro MSLG$B_CNT_SVR = 20,0,8,0 %;      !  Controller software version
macro MSLG$B_CNT_HVR = 21,0,8,0 %;      !  Controller hardware version
macro MSLG$W_MULT_UNT = 22,0,16,0 %;    !  Multi-unit Code
macro MSLG$Q_UNIT_ID = 24,0,0,0 %;
literal MSLG$S_UNIT_ID = 8;             !  Unit ID
macro MSLG$B_UNIT_SVR = 32,0,8,0 %;     !  Unit software version
macro MSLG$B_UNIT_HVR = 33,0,8,0 %;     !  Unit hardware version
macro MSLG$B_LEVEL = 34,0,8,0 %;        !  Level
macro MSLG$B_RETRY = 35,0,8,0 %;        !  Retry
macro MSLG$L_VOL_SER = 36,0,32,0 %;     !  Volume Serial Number (disks)
macro MSLG$L_GAP_CNT = 36,0,32,0 %;     !  Position - object count (tapes)
macro MSLG$B_FMTR_SVR = 40,0,8,0 %;     !  Formatter software version
macro MSLG$B_FMTR_HVR = 41,0,8,0 %;     !  Formatter hardware version
! 
!   Controller Error (MSLG$K_CNT_ERR)
! 
literal MSLG$S_MSLG_CNT_ERR = 23;
macro MSLG$Z_CNT_ERR = 22,0,8,1 %;      !  Controller dependent data
! 
!   Host Memory Access Error (MSLG$K_BUS_ADDR)
! 
literal MSLG$S_MSLG_BUS_ADDR = 28;
macro MSLG$L_BUS_ADDR = 24,0,32,0 %;    !  Bus Address
! 
!   Disk Transfer Error (MSLG$K_DISK_TRN)
! 
literal MSLG$K_DISK_TRN_MSGSIZ = 44;    !  Size of DISK_TRN_ERROR msg.
literal MSLG$S_MSLG_DISK_TRN = 45;
macro MSLG$L_HDR_CODE = 40,0,32,0 %;    !  Header Code
macro MSLG$Z_DISK_TRN = 44,0,8,1 %;     !  Controller or disk dependent data
! 
!   SDI Error (MSLG$K_SDI)
! 
literal MSLG$S_MSLG_SDI = 56;
macro MSLG$Z_SDI = 44,0,0,0 %;
literal MSLG$S_SDI = 12;                !  SDI Information
! 
!   Small Disk Error (MSLG$K_SML_DSK)
! 
literal MSLG$S_MSLG_SML_DSK = 41;
macro MSLG$W_SDE_CYL = 34,0,16,0 %;     !  Cylinder
macro MSLG$Z_SML_DSK = 40,0,8,1 %;      !  Controller or device dependent
! 
!   Tape Transfer Error (MSLG$K_STI_ERR)
! 
! 	There are no special field definitions for tape transfer errors at this time.
! 
!   STI communication or command failure (MSLG$K_STI_ERR)
!   STI drive error log (MSLG$K_STI_DEL)
!   STI formatter error log (MSLG$K_STI_FEL)
! 
literal MSLG$S_MSLG_STI_ERR = 64;
macro MSLG$Z_STI = 44,0,0,0 %;
literal MSLG$S_STI = 20;                !  STI Information
! 
!   Bad Block Replacement Attempted (MSLG$K_REPLACE)
! 
literal MSLG$M_LFR_BR = 1024;
literal MSLG$M_LFR_RI = 2048;
literal MSLG$M_LFR_RF = 4096;
literal MSLG$M_LFR_TE = 8192;
literal MSLG$M_LFR_FE = 16384;
literal MSLG$M_LFR_RP = 32768;
literal MSLG$K_REPLACE_MSGSIZ = 54;     !  Size of REPLACE msg for BBR error logging
literal MSLG$S_MSLG_REPLACE = 54;
macro MSLG$W_RPL_FLGS = 34,0,16,0 %;    !  Replace Flags
macro MSLG$V_LFR_BR = 34,10,1,0 %;      !   Bad RBN
macro MSLG$V_LFR_RI = 34,11,1,0 %;      !   RCT inconsistent
macro MSLG$V_LFR_RF = 34,12,1,0 %;      !   Reformat error
macro MSLG$V_LFR_TE = 34,13,1,0 %;      !   Tertiary revector
macro MSLG$V_LFR_FE = 34,14,1,0 %;      !   Forced error (data not recovered)
macro MSLG$V_LFR_RP = 34,15,1,0 %;      !   Replace attempted (block really bad)
macro MSLG$L_BAD_LBN = 40,0,32,0 %;     !  Bad LBN
macro MSLG$L_OLD_RBN = 44,0,32,0 %;     !  Previous RBN
macro MSLG$L_NEW_RBN = 48,0,32,0 %;     !  New RBN
macro MSLG$W_CAUSE = 52,0,16,0 %;       !  Event code causing replacement
! 
!   Media Loader Errors (MSLG$K_LDR_ERR)
! 
literal MSLG$S_MSLG_LDR_ERR = 49;
macro MSLG$Q_ML_ID = 36,0,0,0 %;
literal MSLG$S_ML_ID = 8;               !  Media loader identifier
macro MSLG$B_ML_SVR = 44,0,8,0 %;       !  Media loader software version
macro MSLG$B_ML_HVR = 45,0,8,0 %;       !  Media loader hardware version
macro MSLG$W_ML_UNIT = 46,0,16,0 %;     !  Media loader unit number
macro MSLG$Z_LDR_ERR = 48,0,8,1 %;      !  Controller dependent data
! 
!   Disk Copy Data Correlation (MSCP$K_DCD_ERROR)
! 
literal MSLG$S_MSLG_DCD_CORR = 60;
macro MSLG$W_DST_UNUM = 4,0,16,0 %;     !  Destination unit number
macro MSLG$Q_DST_UID = 16,0,0,0 %;
literal MSLG$S_DST_UID = 8;             !  Destination unit identifier
macro MSLG$W_SRC_UNUM = 24,0,16,0 %;    !  Source unit number
macro MSLG$Q_SRC_CID = 26,0,0,0 %;
literal MSLG$S_SRC_CID = 8;             !  Source controller identifier
macro MSLG$B_SRC_CSVR = 34,0,8,0 %;     !  Source controller SW version
macro MSLG$B_SRC_CHVR = 35,0,8,0 %;     !  Source controller HW version
macro MSLG$Q_SRC_UID = 36,0,0,0 %;
literal MSLG$S_SRC_UID = 8;             !  Source unit identifier
macro MSLG$Q_PORT_ADR = 44,0,0,0 %;
literal MSLG$S_PORT_ADR = 8;            !  ource unit's subsystem port address
macro MSLG$Q_SYS_ADR = 52,0,0,0 %;
literal MSLG$S_SYS_ADR = 8;             !  Source unit's subsystem system address
 
!*** MODULE $MSCPDEF ***
! ++
!  MSCP (Mass Storage Control Protocol) Definitions
! 
! 	These definitions describe the format of the command and end message 
! 	packets exchanged under MSCP between the host and the controller.
! --
literal MSCP$M_EU_NO = 255;
literal MSCP$M_EU_SUBU = 7;
literal MSCP$M_EU_SUBC = 248;
literal MSCP$K_EMS_CNSL = 0;
literal MSCP$K_EMS_RP = 1;
literal MSCP$K_EMS_RM = 2;
literal MSCP$K_EMS_RK = 3;
literal MSCP$K_EMS_RL = 4;
literal MSCP$K_EMS_RX = 5;
literal MSCP$K_EMS_FD1 = 6;
literal MSCP$K_EMS_FD2 = 7;
literal MSCP$K_EMS_FD3 = 8;
literal MSCP$K_EMS_FD4 = 9;
literal MSCP$K_EMS_FD5 = 10;
literal MSCP$K_EMS_FD6 = 11;
literal MSCP$K_EMS_FD7 = 12;
literal MSCP$K_EMS_FD8 = 13;
literal MSCP$M_EU_CTYPE = 3840;
literal MSCP$K_EMD_OLD = 0;
literal MSCP$K_EMD_UDA = 1;
literal MSCP$K_EMD_HSC = 2;
literal MSCP$K_EMD_AZT = 3;
literal MSCP$K_EMD_RDRX = 4;
literal MSCP$K_EMD_EMUL = 5;
literal MSCP$M_EU_DESIG = 28672;
literal MSCP$M_SHADOW = 32768;
literal MSCP$M_OP_ATTN = 64;
literal MSCP$M_OP_END = 128;
literal MSCP$M_EF_CPRET = 1;
literal MSCP$M_EF_DLS = 2;
literal MSCP$M_EF_PLS = 4;
literal MSCP$M_EF_EOT = 8;
literal MSCP$M_EF_SEREX = 16;
literal MSCP$M_EF_ERLOG = 32;
literal MSCP$M_EF_BBLKU = 64;
literal MSCP$M_EF_BBLKR = 128;
literal MSCP$M_EF_HISLO = 4;
literal MSCP$M_EF_ALLOF = 8;
literal MSCP$M_ST_MASK = 31;
literal MSCP$K_ST_SUCC = 0;
literal MSCP$K_ST_ICMD = 1;
literal MSCP$K_ST_ABRTD = 2;
literal MSCP$K_ST_OFFLN = 3;
literal MSCP$K_ST_AVLBL = 4;
literal MSCP$K_ST_MFMTE = 5;
literal MSCP$K_ST_WRTPR = 6;
literal MSCP$K_ST_COMP = 7;
literal MSCP$K_ST_DATA = 8;
literal MSCP$K_ST_HSTBF = 9;
literal MSCP$K_ST_CNTLR = 10;
literal MSCP$K_ST_DRIVE = 11;
literal MSCP$K_ST_FMTER = 12;
literal MSCP$K_ST_BOT = 13;
literal MSCP$K_ST_TAPEM = 14;
literal MSCP$K_ST_SHST = 12;
literal MSCP$K_ST_WHEAE = 13;
literal MSCP$K_ST_RDTRN = 16;
literal MSCP$K_ST_PLOST = 17;
literal MSCP$K_ST_PRESE = 18;
literal MSCP$K_ST_LED = 19;
literal MSCP$K_ST_BBR = 20;
literal MSCP$K_ST_IPARM = 21;
literal MSCP$K_ST_INFO = 22;
literal MSCP$K_ST_LOADR = 23;
literal MSCP$K_ST_HOST = 24;
literal MSCP$K_ST_UNREC = 20;
literal MSCP$K_ST_SBCERR = 30;
literal MSCP$K_ST_DIAG = 31;
literal MSCP$K_ST_SBCOD = 32;
literal MSCP$M_ST_SBCOD = 65504;
literal MSCP$K_OP_ABORT = 1;            !  Abort
literal MSCP$K_OP_ACCES = 16;           !  Access
literal MSCP$K_OP_ACCNM = 5;            !  Access non-volatile memory
literal MSCP$K_OP_AVAIL = 8;            !  Available
literal MSCP$K_OP_CMPCD = 17;           !  Compare Controller Data
literal MSCP$K_OP_COMP = 32;            !  Compare Host Data
literal MSCP$K_OP_DSPLY = 6;            !  Display
literal MSCP$K_OP_DTACP = 11;           !  Determine Access Paths
literal MSCP$K_OP_DCD = 13;             !  Disk Copy Data
literal MSCP$K_OP_ERASE = 18;           !  Erase
literal MSCP$K_OP_ERGAP = 22;           !  Erase Gap (tapes only)
literal MSCP$K_OP_FLUSH = 19;           !  Flush
literal MSCP$K_OP_FMT = 24;             !  Format (as in floppy disks)
literal MSCP$K_OP_GTCMD = 2;            !  Get Command Status
literal MSCP$K_OP_GTUNT = 3;            !  Get Unit Status
literal MSCP$K_OP_GTLDR = 7;            !  Get Loader Status
literal MSCP$K_OP_MOVE = 12;            !  Move Media
literal MSCP$K_OP_ONLIN = 9;            !  Online
literal MSCP$K_OP_RCEDC = 35;           !  Read Controller Encryption/Decryption Code
literal MSCP$K_OP_READ = 33;            !  Read
literal MSCP$K_OP_REPLC = 20;           !  Replace
literal MSCP$K_OP_REPOS = 37;           !  Reposition (tapes only)
literal MSCP$K_OP_STCON = 4;            !  Set Controller Characteristics
literal MSCP$K_OP_STUNT = 10;           !  Set Unit Characteristics
literal MSCP$K_OP_TERCO = 48;           !  Terminate Class Driver/Server Connection
literal MSCP$K_OP_WRITE = 34;           !  Write
literal MSCP$K_OP_WRITM = 36;           !  Write Tape Mark
literal MSCP$K_OP_WRHIM = 25;           !  Write History Management
!  MSCP End Message Codes
literal MSCP$K_OP_END = 128;            !  End Message Flag
!  MSCP Attention Message Codes (listed in alphabetical order)
literal MSCP$K_OP_ACPTH = 66;           !  Access Path
literal MSCP$K_OP_AVATN = 64;           !  Available
literal MSCP$K_OP_DUPUN = 65;           !  Duplicate Unit Number
literal MSCP$M_SLUN = 16384;
literal MSCP$K_SLUN_RSVP = 32767;       !  SLUN to request unit number for this controller
literal MSCP$S_GENERIC_MSCP = 14;
macro MSCP$L_CMD_REF = 0,0,32,0 %;      !  Command reference number
macro MSCP$W_UNIT = 4,0,16,0 %;         !  Unit number
macro MSCP$V_EU_NO = 4,0,8,0 %;
literal MSCP$S_EU_NO = 8;               !  Emulated unit number
macro MSCP$V_EU_SUBU = 4,0,3,0 %;
literal MSCP$S_EU_SUBU = 3;             !  Old-style unit number
macro MSCP$V_EU_SUBC = 4,3,5,0 %;
literal MSCP$S_EU_SUBC = 5;             !  Old-style controller subtype
macro MSCP$V_EU_CTYPE = 4,8,4,0 %;
literal MSCP$S_EU_CTYPE = 4;            !  Emulated controller type
macro MSCP$V_EU_DESIG = 4,12,3,0 %;
literal MSCP$S_EU_DESIG = 3;            !  Emulated controller designator
macro MSCP$V_SHADOW = 4,15,1,0 %;       !  Shadow unit
macro MSCP$W_SEQ_NUM = 6,0,16,0 %;      !  Sequence number (LAST error log)
macro MSCP$B_OPCODE = 8,0,8,0 %;        !  MSCP operation code
macro MSCP$V_OP_ATTN = 8,6,1,0 %;       !  Attention message
macro MSCP$V_OP_END = 8,7,1,0 %;        !  End message
macro MSCP$W_MODIFIER = 10,0,16,0 %;    !  MSCP command modifiers
macro MSCP$B_FLAGS = 9,0,8,0 %;         !  End message flags
macro MSCP$V_EF_CPRET = 9,0,1,0 %;      !  Communication Paths Retained
macro MSCP$V_EF_DLS = 9,1,1,0 %;        !  Cached Data Lost (tapes only)
macro MSCP$V_EF_PLS = 9,2,1,0 %;        !  Position Lost (tapes only)
macro MSCP$V_EF_EOT = 9,3,1,0 %;        !  End of Tape Encountered (tapes only)
macro MSCP$V_EF_SEREX = 9,4,1,0 %;      !  Serious exception (tapes only)
macro MSCP$V_EF_ERLOG = 9,5,1,0 %;      !  Error log generated
macro MSCP$V_EF_BBLKU = 9,6,1,0 %;      !  Bad block unreported (disks only)
macro MSCP$V_EF_BBLKR = 9,7,1,0 %;      !  Bad block reported (disks only)
macro MSCP$V_EF_HISLO = 9,2,1,0 %;      !  History Logged
macro MSCP$V_EF_ALLOF = 9,3,1,0 %;      !  Allocation Failure
macro MSCP$W_STATUS = 10,0,16,0 %;      !  End message status
macro MSCP$V_ST_MASK = 10,0,5,0 %;
literal MSCP$S_ST_MASK = 5;             !  Status code bits
macro MSCP$V_ST_SBCOD = 10,5,11,0 %;
literal MSCP$S_ST_SBCOD = 11;           !  Subcode bits
!  MSCP Command Operation Codes (defined in alphabetical order)
macro MSCP$V_SLUN = 12,14,1,0 %;        !  Server Local Unit Number flag
literal MSCP$M_MD_SEREC = 256;
literal MSCP$M_MD_SECOR = 512;
literal MSCP$M_MD_CLSEX = 8192;
literal MSCP$M_MD_COMP = 16384;
literal MSCP$M_MD_WRSEQ = 16;
literal MSCP$M_MD_WBKVL = 32;
literal MSCP$M_MD_WBKNV = 64;
literal MSCP$M_MD_SSHDW = 128;
literal MSCP$M_MD_SCCHL = 1024;
literal MSCP$M_MD_SCCHH = 2048;
literal MSCP$M_MD_ERROR = 4096;
literal MSCP$M_MD_EXPRS = 32768;
literal MSCP$M_MD_REWND = 2;
literal MSCP$M_MD_OBJCT = 4;
literal MSCP$M_MD_REVRS = 8;
literal MSCP$M_MD_UNLOD = 16;
literal MSCP$M_MD_IMMED = 64;
literal MSCP$M_MD_DLEOT = 128;
literal MSCP$M_MD_CDATL = 4096;
literal MSCP$M_MD_SPNDW = 1;
literal MSCP$M_MD_ALLCD = 2;
literal MSCP$M_MD_DSOLV = 16;
literal MSCP$M_MD_FLENU = 1;
literal MSCP$M_MD_VOLTL = 2;
literal MSCP$M_MD_NXUNT = 1;
literal MSCP$M_MD_RIP = 1;
literal MSCP$M_MD_IGNMF = 2;
literal MSCP$M_MD_STWRP = 4;
literal MSCP$M_MD_CLWBL = 8;
literal MSCP$M_MD_SHDSP = 16;
literal MSCP$M_MD_EXCAC = 32;
literal MSCP$M_MD_PRIMR = 1;
literal MSCP$M_MD_CRNPR = 1;
literal MSCP$M_MD_ENRWR = 16;
literal MSCP$M_MD_TBC = 32768;
literal MSCP$M_MD_HISLO = 8;
literal MSCP$M_MD_SUPWL = 16;
literal MSCP$M_MD_REUSE = 128;
literal MSCP$M_MD_LOCSU = 1;
literal MSCP$M_MD_ESTCP = 2;
literal MSCP$M_MD_RETCP = 4;
literal MSCP$S_MSCP_MODIFIERS = 12;
!  Generic MSCP Modifiers
macro MSCP$V_MD_SEREC = 10,8,1,0 %;     !    Suppress error recovery
macro MSCP$V_MD_SECOR = 10,9,1,0 %;     !    Suppress error correction
macro MSCP$V_MD_CLSEX = 10,13,1,0 %;    !    Clear serious exception
macro MSCP$V_MD_COMP = 10,14,1,0 %;     !    Compare
macro MSCP$V_MD_WRSEQ = 10,4,1,0 %;     !    Write shadow set 1 unit at a time
macro MSCP$V_MD_WBKVL = 10,5,1,0 %;     !    Write-back (volatile)
macro MSCP$V_MD_WBKNV = 10,6,1,0 %;     !    Write-back (non-volatile)
macro MSCP$V_MD_SSHDW = 10,7,1,0 %;     !    Suppress Shadowing
macro MSCP$V_MD_SCCHL = 10,10,1,0 %;    !    Suppress caching (low speed)
macro MSCP$V_MD_SCCHH = 10,11,1,0 %;    !    Suppress caching (high speed)
macro MSCP$V_MD_ERROR = 10,12,1,0 %;    !    Force error
macro MSCP$V_MD_EXPRS = 10,15,1,0 %;    !    Express request
macro MSCP$V_MD_REWND = 10,1,1,0 %;     !    Rewind
macro MSCP$V_MD_OBJCT = 10,2,1,0 %;     !    Object count
macro MSCP$V_MD_REVRS = 10,3,1,0 %;     !    Reverse
macro MSCP$V_MD_UNLOD = 10,4,1,0 %;     !    Unload
macro MSCP$V_MD_IMMED = 10,6,1,0 %;     !    Request immediate completion
macro MSCP$V_MD_DLEOT = 10,7,1,0 %;     !    Request detect LEOT
macro MSCP$V_MD_CDATL = 10,12,1,0 %;    !    Clear Cached Data Lost
macro MSCP$V_MD_SPNDW = 10,0,1,0 %;     !    Spin down
macro MSCP$V_MD_ALLCD = 10,1,1,0 %;     !    All class drivers
macro MSCP$V_MD_DSOLV = 10,4,1,0 %;     !    Disolve shadow set
macro MSCP$V_MD_FLENU = 10,0,1,0 %;     !    Flush entire unit
macro MSCP$V_MD_VOLTL = 10,1,1,0 %;     !    Flush volitile only
macro MSCP$V_MD_NXUNT = 10,0,1,0 %;     !    Next unit
macro MSCP$V_MD_RIP = 10,0,1,0 %;       !    Allow self-destruct (online only)
macro MSCP$V_MD_IGNMF = 10,1,1,0 %;     !    Ignore media format error (online only)
macro MSCP$V_MD_STWRP = 10,2,1,0 %;     !    Enable Set Write Protect
macro MSCP$V_MD_CLWBL = 10,3,1,0 %;     !    Clear Write-Back Data Lost
macro MSCP$V_MD_SHDSP = 10,4,1,0 %;     !    Shadow Unit Specified
macro MSCP$V_MD_EXCAC = 10,5,1,0 %;     !    Exclusive access
macro MSCP$V_MD_PRIMR = 10,0,1,0 %;     !    Primary replacement block
macro MSCP$V_MD_CRNPR = 10,0,1,0 %;     !     Connection Reference Number Present
macro MSCP$V_MD_ENRWR = 10,4,1,0 %;     !    Enable Re-Write Error Recovery (tapes)
macro MSCP$V_MD_TBC = 10,15,1,0 %;      !    To-be-continued (segmented tapes)
macro MSCP$V_MD_HISLO = 10,3,1,0 %;     !    History Log
macro MSCP$V_MD_SUPWL = 10,4,1,0 %;     !    Supplementary Write Log
macro MSCP$V_MD_REUSE = 10,7,1,0 %;     !    Reuse Entry
macro MSCP$V_MD_LOCSU = 10,0,1,0 %;     !    Local Source Unit
macro MSCP$V_MD_ESTCP = 10,1,1,0 %;     !    Establish Communications Paths 
macro MSCP$V_MD_RETCP = 10,2,1,0 %;     !    Retain Communications Paths
literal MSCP$K_SC_NORML = 0;            !  Normal
literal MSCP$K_SC_SDIGN = 1;            !  Spin Down IGNored
literal MSCP$K_SC_STCON = 2;            !  STill CONnected
literal MSCP$K_SC_DUPUN = 4;            !  DUPlicate UNit number
literal MSCP$K_SC_ALONL = 8;            !  ALready ONLine
literal MSCP$K_SC_STONL = 16;           !  STill ONLine
literal MSCP$K_SC_EOT = 32;             !  EOT encountered (tapes only)
literal MSCP$K_SC_INREP = 32;           !  INcomplete REPlacement (disks only)
literal MSCP$K_SC_IVRCT = 64;           !  InValid RCT (disks only)
literal MSCP$K_SC_RDONY = 128;          !  ReaD ONlY volume format
literal MSCP$M_SC_SDIGN = 32;
literal MSCP$M_SC_STCON = 64;
literal MSCP$M_SC_DUPUN = 128;
literal MSCP$M_SC_ALONL = 256;
literal MSCP$M_SC_STONL = 512;
literal MSCP$M_SC_EOT = 1024;
literal MSCP$M_SC_INREP = 1024;
literal MSCP$M_SC_IVRCT = 2048;
literal MSCP$M_SC_RDONY = 4096;
literal MSCP$K_SC_INVML = 0;            !  INValid Message Length
!  Unit-Offline Subcode Values
literal MSCP$K_SC_UNKNO = 0;            !  UNKoNOwn unit or online to another controller
literal MSCP$K_SC_NOVOL = 1;            !  NO VOLume mounted or drive disabled (RUN/STOP)
literal MSCP$K_SC_INOPR = 2;            !  unit is INOPeRative
literal MSCP$K_SC_UDSBL = 8;            !  Unit disabled by field service or diagnostic
literal MSCP$K_SC_EXUSE = 16;           !  Exclusive use
literal MSCP$K_SC_LDR = 32;             !  Loader cycle error
literal MSCP$M_SC_NOVOL = 32;
literal MSCP$M_SC_INOPR = 64;
literal MSCP$M_SC_UDSBL = 256;
literal MSCP$M_SC_EXUSE = 512;
literal MSCP$M_SC_LDR = 1024;
literal MSCP$K_SC_CPYIP = 2;            !  Copy in progress
literal MSCP$K_SC_NOMEM = 4;            !  No members in shadow set
literal MSCP$K_SC_ALUSE = 32;           !  Already in use
literal MSCP$M_SC_CPYIP = 64;
literal MSCP$M_SC_NOMEM = 128;
literal MSCP$M_SC_ALUSE = 1024;
literal MSCP$K_SC_IVHD = 2;
literal MSCP$K_SC_NOSYNC = 3;
literal MSCP$K_SC_SSCM = 4;
literal MSCP$K_SC_NO512 = 5;
literal MSCP$K_SC_NOFMT = 6;
literal MSCP$K_SC_ECCER = 7;
literal MSCP$K_SC_RCTBD = 8;
literal MSCP$K_SC_NORBL = 9;
!  Write-Protected Subcode Values
literal MSCP$K_SC_DATAL = 8;            !  Unit is DATA Loss write protected (data safety)
literal MSCP$K_SC_SOFTW = 128;          !  Unit is SOFTWare protected 
literal MSCP$K_SC_HARDW = 256;          !  Unit is HARDWare protected 
literal MSCP$M_SC_DATAL = 256;
literal MSCP$M_SC_SOFTW = 4096;
literal MSCP$M_SC_HARDW = 8192;
literal MSCP$K_SC_FRCER = 0;            !  Forced Error (disks)
literal MSCP$K_SC_LGE = 0;              !  Long Gap Encountered (tapes)
literal MSCP$K_SC_MEDIA = 3;            !  Media error.
!  Host Buffer Access Error Subcode Values
literal MSCP$K_SC_ODDTA = 1;
literal MSCP$K_SC_ODDBC = 2;
literal MSCP$K_SC_NXM = 3;
literal MSCP$K_SC_MPAR = 4;
literal MSCP$K_SC_IVPTE = 5;
literal MSCP$K_SC_IVBFN = 6;
literal MSCP$K_SC_BLENV = 7;
literal MSCP$K_SC_ACVIO = 8;
!  Controller Error Subcode Values
literal MSCP$K_SC_DLATE = 1;
literal MSCP$K_SC_EDCER = 2;
literal MSCP$K_SC_DTSTR = 3;
literal MSCP$K_SC_IEDC = 4;
literal MSCP$K_SC_LACIN = 5;
literal MSCP$K_SC_LACOU = 6;
literal MSCP$K_SC_LACCB = 7;
literal MSCP$K_SC_OVRUN = 8;
literal MSCP$K_SC_MEMER = 9;
literal MSCP$K_SC_REMRSRC = 10;
literal MSCP$K_SC_RCONL = 20;
literal MSCP$K_SC_RCONF = 21;
literal MSCP$K_SC_BADSA = 22;
literal MSCP$K_SC_NOSER = 23;
literal MSCP$K_SC_NORES = 24;
literal MSCP$K_SC_NOCRE = 25;
literal MSCP$K_SC_BADPR = 26;
literal MSCP$K_SC_NEGAK = 27;
literal MSCP$K_SC_TMOUT = 28;
literal MSCP$K_SC_LCONF = 29;
literal MSCP$K_SC_DISCN = 30;
!  Bad Block Replacement Subcode Values
literal MSCP$K_SC_BBROK = 0;
literal MSCP$K_SC_NOTRP = 1;
literal MSCP$K_SC_RPLFL = 2;
literal MSCP$K_SC_ICRCT = 3;
literal MSCP$K_SC_DRVER = 4;
literal MSCP$K_SC_RCTFULL = 5;
literal MSCP$K_SC_RECURFAIL = 6;
!  Unrecognized Media Subcode Values
literal MSCP$K_SC_NOTAPEFMT = 1;
!  Invalid Parameter Subcode Values
literal MSCP$K_SC_IVKLN = 1;
literal MSCP$K_SC_IVKTY = 2;
literal MSCP$K_SC_IVKVL = 3;
!  Media Loader Error Subcode Values
literal MSCP$K_SC_ML_TMO = 1;
literal MSCP$K_SC_ML_TXERR = 2;
literal MSCP$K_SC_ML_PRTCL = 3;
literal MSCP$K_SC_ML_ERROR = 4;
!  Host Error Subcode Values
literal MSCP$K_SC_SEGUNDR = 1;
!  Write History Entry Access Error Subcode Values
literal MSCP$K_SC_ALLOF = 1;
literal MSCP$K_SC_TABFU = 2;
literal MSCP$K_SC_NOENT = 8;
literal MSCP$M_SC_ALLOF = 2;
literal MSCP$M_SC_TABFU = 4;
literal MSCP$M_SC_NOENT = 16;
literal MSCP$K_SC_DCDC = 3;
!  Subcommand Error Status or Event Subcode Values
literal MSCP$K_SC_DST_TIMOUT = 1;
literal MSCP$K_SC_DST_INCSTA = 2;
literal MSCP$K_SC_DST_UNRCOV = 4;
literal MSCP$K_SC_SRC_TIMOUT = 1025;
literal MSCP$K_SC_SRC_INCSTA = 1026;
literal MSCP$K_SC_SRC_UNRCOV = 1028;
literal MSCP$S_MSCP_SUBCODES = 12;
!  Success Subcode Values
macro MSCP$V_SC_SDIGN = 10,5,1,0 %;     !  Spin Down IGNored
macro MSCP$V_SC_STCON = 10,6,1,0 %;     !  STill CONnected
macro MSCP$V_SC_DUPUN = 10,7,1,0 %;     !  DUPlicate UNit number
macro MSCP$V_SC_ALONL = 10,8,1,0 %;     !  ALready ONLine
macro MSCP$V_SC_STONL = 10,9,1,0 %;     !  STill ONLine
macro MSCP$V_SC_EOT = 10,10,1,0 %;      !  EOT encountered (tapes only)
macro MSCP$V_SC_INREP = 10,10,1,0 %;    !  INcomplete REPlacement (disks only)
macro MSCP$V_SC_IVRCT = 10,11,1,0 %;    !  InValid RCT (disks only)
macro MSCP$V_SC_RDONY = 10,12,1,0 %;    !  ReaD ONlY volume format
!  Invalid Command Subcode Values
macro MSCP$V_SC_NOVOL = 10,5,1,0 %;     !  NO VOLume mounted or drive disabled (RUN/STOP)
macro MSCP$V_SC_INOPR = 10,6,1,0 %;     !  unit is INOPeRative
macro MSCP$V_SC_UDSBL = 10,8,1,0 %;     !  Unit disabled by field service or diagnostic
macro MSCP$V_SC_EXUSE = 10,9,1,0 %;     !  Exclusive use
macro MSCP$V_SC_LDR = 10,10,1,0 %;      !  Loader cycle error
!  Unit-Available Subcode Values
macro MSCP$V_SC_CPYIP = 10,6,1,0 %;     !  Copy in progress
macro MSCP$V_SC_NOMEM = 10,7,1,0 %;     !  No members in shadow set
macro MSCP$V_SC_ALUSE = 10,10,1,0 %;    !  Already in use
!  Media Format Error Subcode Values
macro MSCP$V_SC_DATAL = 10,8,1,0 %;     !  Unit is DATA Loss write protected (data safety)
macro MSCP$V_SC_SOFTW = 10,12,1,0 %;    !  Unit is SOFTWare protected 
macro MSCP$V_SC_HARDW = 10,13,1,0 %;    !  Unit is HARDWare protected 
!  Data Error Subcode Values
macro MSCP$V_SC_ALLOF = 10,1,1,0 %;
macro MSCP$V_SC_TABFU = 10,2,1,0 %;
macro MSCP$V_SC_NOENT = 10,4,1,0 %;
!  Informational Event Subcode
!  Definitions for MSCP Transfer Commands
! 
!  Also the FORMAT command, which includes a
!  buffer descriptor just like transfer commands.
literal MSCP$K_FMT_DFLT = 0;            ! 	device's default
literal MSCP$K_FMT_SING = 1;            ! 	single density
literal MSCP$K_FMT_DOUB = 2;            ! 	double density
literal MSCP$K_FMT_RX33 = 282;          ! 	RX33 - ISO DIS8630-1985
literal MSCP$S_TRANSFER_COMMANDS = 52;
macro MSCP$L_BYTE_CNT = 12,0,32,0 %;    !  Byte count
macro MSCP$B_BUFFER = 16,0,0,0 %;
literal MSCP$S_BUFFER = 12;             !  Buffer descriptor
macro MSCP$L_LBN = 28,0,32,0 %;         !    Logical block number
macro MSCP$L_FRST_BAD = 28,0,32,0 %;    !    First bad block
macro MSCP$L_FMT_FUNC = 28,0,32,0 %;    !    Format function
macro MSCP$L_KEY_ID = 32,0,32,0 %;      !  Key identifier
macro MSCP$L_KEY_LGH = 36,0,32,0 %;     !  Key length
macro MSCP$L_KEY_BUF = 40,0,0,0 %;
literal MSCP$S_KEY_BUF = 12;            !  Key buffer descriptor
macro MSCP$L_POSITION = 28,0,32,0 %;    !  Position (object count)
macro MSCP$L_TAPEREC = 32,0,32,0 %;     !  Tape record byte count
!  Definitions for Abort and Get Command Status Commands and End Messages
literal MSCP$S_ABORT_GTCMD = 20;
macro MSCP$L_OUT_REF = 12,0,32,0 %;     !  Outstanding reference number
macro MSCP$L_CMD_STS = 16,0,32,0 %;     !  Command status
!  Definitions for the Access Non-Volatile Memory Command and End Message
literal MSCP$K_ANM_READ = 0;
literal MSCP$K_ANM_EXCG = 1;
literal MSCP$K_ANM_TSST = 2;
literal MSCP$S_ACCNM = 56;
macro MSCP$L_ANM_SIZE = 12,0,32,0 %;    !  Non-Volatile Memory Size
macro MSCP$L_ANM_OFFS = 16,0,32,0 %;    !  Offset into Non-Volatile Memory
macro MSCP$W_ANM_OPER = 20,0,16,0 %;    !  Non-Volatile Memory Access Operation
macro MSCP$W_ANM_DLGH = 22,0,16,0 %;    !  Data Length
macro MSCP$T_ANM_MEMD = 24,0,0,0 %;
literal MSCP$S_ANM_MEMD = 32;           !  Memory Data
!  Definitions for Display Command and End Message
literal MSCP$S_DISPLAY_CMD = 32;
macro MSCP$W_DITEM = 12,0,16,0 %;       !  Item code
macro MSCP$W_DMODE = 14,0,16,0 %;       !  Mode
macro MSCP$T_DTEXT = 16,0,0,0 %;
literal MSCP$S_DTEXT = 16;              !  Display text
!  Definitions for the Get Unit Status Command and End Message
literal MSCP$M_UF_CMPRD = 1;
literal MSCP$M_UF_CMPWR = 2;
literal MSCP$M_UF_WBKNV = 64;
literal MSCP$M_UF_WRTPD = 256;
literal MSCP$M_UF_EXACC = 1024;
literal MSCP$M_UF_SCCHH = 2048;
literal MSCP$M_UF_WRTPS = 4096;
literal MSCP$M_UF_WRTPH = 8192;
literal MSCP$M_UF_576 = 4;
literal MSCP$M_UF_WHL = 8;
literal MSCP$M_UF_RMVBL = 128;
literal MSCP$M_UF_SSMST = 512;
literal MSCP$M_UF_SSMEM = 16384;
literal MSCP$M_UF_REPLC = 32768;
literal MSCP$M_UF_CACFL = 4;
literal MSCP$M_UF_EWRER = 8;
literal MSCP$M_UF_VARSP = 16;
literal MSCP$M_UF_VSMSU = 32;
literal MSCP$M_UF_LOADR = 512;
literal MSCP$M_UF_CACH = 32768;
literal MSCP$M_SLUN_C = 31;
literal MSCP$M_SLUN_D1 = 992;
literal MSCP$M_SLUN_D0 = 31744;
literal MSCP$M_MTYP_N = 127;
literal MSCP$M_MTYP_A2 = 3968;
literal MSCP$M_MTYP_A1 = 126976;
literal MSCP$M_MTYP_A0 = 4063232;
literal MSCP$M_MTYP_D1 = 130023424;
literal MSCP$M_MTYP_D0 = -134217728;
literal MSCP$K_CM_NOCPY = 0;
literal MSCP$K_CM_COPY = 1;
literal MSCP$K_CM_MGCPY = 2;
literal MSCP$K_CM_MMRG = 3;
literal MSCP$M_TF_800 = 1;
literal MSCP$M_TF_PE = 2;
literal MSCP$M_TF_GCR = 4;
literal MSCP$M_TF_BLK = 8;
literal MSCP$M_TF_NOR = 1;
literal MSCP$M_TF_BHD = 2;
literal MSCP$M_TF_DN2 = 4;
literal MSCP$M_TF_ENH = 2;
literal MSCP$M_TF_NDC = 4;
literal MSCP$M_TF_EDC = 8;
literal MSCP$K_TC_OLD = 0;
literal MSCP$K_TC_9TR = 256;
literal MSCP$K_TC_CTP = 512;
literal MSCP$K_TC_HPC = 768;
literal MSCP$K_TC_WOD = 1024;
literal MSCP$M_TF_MASK = 255;           !  Density field mask
literal MSCP$K_TF_CODE = 256;           !  Format code multiplier
literal MSCP$S_GTUNT = 50;
macro MSCP$W_MULT_UNT = 12,0,16,0 %;    !  Multi-unit code
macro MSCP$W_UNT_FLGS = 14,0,16,0 %;    !  Unit flags
macro MSCP$V_UF_CMPRD = 14,0,1,0 %;     !    Compare reads 
macro MSCP$V_UF_CMPWR = 14,1,1,0 %;     !    Compare writes 
macro MSCP$V_UF_WBKNV = 14,6,1,0 %;     !    Write-back (non-volatile) [disks only]
macro MSCP$V_UF_WRTPD = 14,8,1,0 %;     !    Write protect (data safety)
macro MSCP$V_UF_EXACC = 14,10,1,0 %;    !    Exclusive access
macro MSCP$V_UF_SCCHH = 14,11,1,0 %;    !    Suppress caching (High speed) 
macro MSCP$V_UF_WRTPS = 14,12,1,0 %;    !    Write protect (software) 
macro MSCP$V_UF_WRTPH = 14,13,1,0 %;    !    Write protect (hardware)
macro MSCP$V_UF_576 = 14,2,1,0 %;       !    576 byte sectors
macro MSCP$V_UF_WHL = 14,3,1,0 %;       !    Write History Logging Support 
macro MSCP$V_UF_RMVBL = 14,7,1,0 %;     !    Removeable media
macro MSCP$V_UF_SSMST = 14,9,1,0 %;     !    Shadow set master
macro MSCP$V_UF_SSMEM = 14,14,1,0 %;    !    Shadow set member
macro MSCP$V_UF_REPLC = 14,15,1,0 %;    !    Controller initiated bad block replacement
macro MSCP$V_UF_CACFL = 14,2,1,0 %;     !    Cache flushed
macro MSCP$V_UF_EWRER = 14,3,1,0 %;     !    Enhanced Write Error Recovery
macro MSCP$V_UF_VARSP = 14,4,1,0 %;     !    Variable speed unit
macro MSCP$V_UF_VSMSU = 14,5,1,0 %;     !    Variable speed mode suppression
macro MSCP$V_UF_LOADR = 14,9,1,0 %;     !    Media Loader Present
macro MSCP$V_UF_CACH = 14,15,1,0 %;     !    Write-back Caching
macro MSCP$Q_UNIT_ID = 20,0,0,0 %;
literal MSCP$S_UNIT_ID = 8;             !  Unit identifier
macro MSCP$L_EXCL_LBA = 20,0,32,0 %;    !  Excluded LBN area address [disks only]
macro MSCP$L_EXCL_LBC = 24,0,32,0 %;    !  Excluded LBN block count [disks only]
macro MSCP$L_SLUN_ALLOCLS = 20,0,32,0 %;
macro MSCP$W_SLUN_UNIT = 24,0,16,0 %;
macro MSCP$W_SLUN_DEVNAME = 26,0,16,0 %;
macro MSCP$V_SLUN_C = 26,0,5,0 %;
literal MSCP$S_SLUN_C = 5;
macro MSCP$V_SLUN_D1 = 26,5,5,0 %;
literal MSCP$S_SLUN_D1 = 5;
macro MSCP$V_SLUN_D0 = 26,10,5,0 %;
literal MSCP$S_SLUN_D0 = 5;
macro MSCP$L_DEV_PARM = 28,0,32,0 %;    !  Device dependent parameters
macro MSCP$L_MEDIA_ID = 28,0,32,0 %;    !  Media type identifier
macro MSCP$V_MTYP_N = 28,0,7,0 %;
literal MSCP$S_MTYP_N = 7;              !    Media # (i.e. 7 of RK07)
macro MSCP$V_MTYP_A2 = 28,7,5,0 %;
literal MSCP$S_MTYP_A2 = 5;             !    Media name char.
macro MSCP$V_MTYP_A1 = 28,12,5,0 %;
literal MSCP$S_MTYP_A1 = 5;             !    Media name continued
macro MSCP$V_MTYP_A0 = 28,17,5,0 %;
literal MSCP$S_MTYP_A0 = 5;             !      "    "      "
macro MSCP$V_MTYP_D1 = 28,22,5,0 %;
literal MSCP$S_MTYP_D1 = 5;             !    Dev mnemonic char.
macro MSCP$V_MTYP_D0 = 28,27,5,0 %;
literal MSCP$S_MTYP_D0 = 5;             !    Mnemonic continued
macro MSCP$W_SHDW_UNT = 32,0,16,0 %;    !  Shadow unit
macro MSCP$W_COPY_MOD = 34,0,16,0 %;    !  Copy mode
macro MSCP$W_SHDW_STS = 34,0,16,0 %;    !  Shadow unit status
macro MSCP$W_FORMAT = 32,0,16,0 %;      !  Original (Old) format
macro MSCP$V_TF_800 = 32,0,1,0 %;       !   NRZI 800 bpi
macro MSCP$V_TF_PE = 32,1,1,0 %;        !   Phase encoded 1600 bpi
macro MSCP$V_TF_GCR = 32,2,1,0 %;       !   Group code recording 6250 bpi
macro MSCP$V_TF_BLK = 32,3,1,0 %;       !   Block format (TK50)
macro MSCP$V_TF_NOR = 32,0,1,0 %;       !   Normal (low) density (833 bpi TK50)
macro MSCP$V_TF_BHD = 32,1,1,0 %;       !   Block mode High Density (1250 bpi TK70)
macro MSCP$V_TF_DN2 = 32,2,1,0 %;       !   Block mode Density 2 (TF85 compatible)
macro MSCP$V_TF_ENH = 32,1,1,0 %;       !   Enhanced density
macro MSCP$V_TF_NDC = 32,2,1,0 %;       !   NOR with data comp.
macro MSCP$V_TF_EDC = 32,3,1,0 %;       !   ENH with data comp.
macro MSCP$W_SPEED = 34,0,16,0 %;       !  Speed
macro MSCP$W_TRACK = 36,0,16,0 %;       !  Track size
macro MSCP$W_GROUP = 38,0,16,0 %;       !  Group size
macro MSCP$W_CYLINDER = 40,0,16,0 %;    !  Cylinder size
macro MSCP$B_UNIT_SVR = 42,0,8,0 %;     !  Unit software version
macro MSCP$B_UNIT_HVR = 43,0,8,0 %;     !  Unit hardware version
macro MSCP$W_RCT_SIZE = 44,0,16,0 %;    !  RCT size
macro MSCP$B_RBNS = 46,0,8,0 %;         !  RBNs per track
macro MSCP$B_RCT_CPYS = 47,0,8,0 %;     !  Number of RCT copies
macro MSCP$W_LOAD_AVAIL = 48,0,16,0 %;  !  Controller load available (VMS server load balancing)
macro MSCP$W_FORMENU = 36,0,16,0 %;     !  Format menu
macro MSCP$B_FREECAP = 38,0,8,0 %;      !  Free capacity
!  Definitions for Online and Set Unit Characteristics Command and End Messages
literal MSCP$S_ONLIN_STUNT = 44;
macro MSCP$L_UNT_SIZE = 36,0,32,0 %;    !  Unit size
macro MSCP$L_VOL_SER = 40,0,32,0 %;     !  Volume serial number
macro MSCP$L_MAXWTREC = 36,0,32,0 %;    !  Maximum write record size
macro MSCP$W_NOISEREC = 40,0,16,0 %;    !  Noise record
!  Definitions for the Read Controller Encrypt/Decrypt Code Command and End Message
literal MSCP$S_RCEDC = 36;
macro MSCP$L_CODE = 32,0,32,0 %;        !  Encrypt/Decrypt Code Length
!  Definitions for the Replace Command and End Message (disks only)
literal MSCP$S_REPLC = 16;
macro MSCP$L_RBN = 12,0,32,0 %;         !  Replacement block number
!  Definitions for the Reposition Command and End Message (tapes only)
literal MSCP$S_REPOS = 20;
macro MSCP$L_REC_CNT = 12,0,32,0 %;     !  Record/Object count
macro MSCP$L_TMGP_CNT = 16,0,32,0 %;    !  Tape mark count
macro MSCP$L_RCSKIPED = 12,0,32,0 %;    !  Records skipped
macro MSCP$L_TMSKIPED = 16,0,32,0 %;    !  Tape markes skipped
!  Definitions for the Set Controller Characteristics Command and End Message
literal MSCP$M_CF_576 = 1;
literal MSCP$M_CF_SHADW = 2;
literal MSCP$M_CF_MLTHS = 4;
literal MSCP$M_CF_LDCD = 8;
literal MSCP$M_CF_THIS = 16;
literal MSCP$M_CF_OTHER = 32;
literal MSCP$M_CF_MISC = 64;
literal MSCP$M_CF_ATTN = 128;
literal MSCP$M_CF_RDCD = 256;
literal MSCP$M_CF_WHL = 512;
literal MSCP$M_CF_RDO = 1024;
literal MSCP$M_CF_LOAD = 8192;
literal MSCP$M_CF_EDCRP = 16384;
literal MSCP$M_CF_REPLC = 32768;
literal MSCP$M_CF_SRT = 32768;
literal MSCP$K_CL_CNTRL = 1;
literal MSCP$K_CL_DISK = 2;
literal MSCP$K_CL_TAPE = 3;
literal MSCP$K_CL_D144 = 4;
literal MSCP$K_CL_LDR = 5;
!   MSCP Controller Model
literal MSCP$K_CM_HSC50 = 1;
literal MSCP$K_CM_UDA50 = 2;
literal MSCP$K_CM_RC25 = 3;
literal MSCP$K_CM_EMULA = 4;
literal MSCP$K_CM_TU81 = 5;
literal MSCP$K_CM_UDA52 = 6;
literal MSCP$K_CM_UDA50A = 6;
literal MSCP$K_CM_RDRX = 7;
literal MSCP$K_CM_TOPS = 8;
literal MSCP$K_CM_TK50 = 9;
literal MSCP$K_CM_TQK50 = 9;
literal MSCP$K_CM_RUX50 = 10;
literal MSCP$K_CM_AIO = 12;
literal MSCP$K_CM_KFBTA = 12;
literal MSCP$K_CM_KDA50 = 13;
literal MSCP$K_CM_TK70 = 14;
literal MSCP$K_CM_TQK70 = 14;
literal MSCP$K_CM_RV20 = 15;
literal MSCP$K_CM_RRD50 = 16;
literal MSCP$K_CM_RRD50Q = 16;
literal MSCP$K_CM_KDB50 = 18;
literal MSCP$K_CM_RQDX3 = 19;
literal MSCP$K_CM_RQDX4 = 20;
literal MSCP$K_CM_DSSI_DISK = 21;
literal MSCP$K_CM_DSSI_TAPE = 22;
literal MSCP$K_CM_DSSI_DSKTAP = 23;
literal MSCP$K_CM_DSSI_OTHER = 24;
literal MSCP$K_CM_TUK50 = 25;
literal MSCP$K_CM_RRD50U = 26;
literal MSCP$K_CM_KDM70 = 27;
literal MSCP$K_CM_TQL70 = 28;
literal MSCP$K_CM_TM32 = 29;
literal MSCP$K_CM_HSC70 = 32;
literal MSCP$K_CM_HSC40 = 33;
literal MSCP$K_CM_HSC60 = 34;
literal MSCP$K_CM_HSC90 = 35;
literal MSCP$K_CM_RN20 = 36;
literal MSCP$K_CM_ENE10 = 37;
literal MSCP$K_CM_TN10 = 38;
literal MSCP$K_CM_KSB50 = 64;
literal MSCP$K_CM_TK50_DEBNT = 65;
literal MSCP$K_CM_TBK70 = 66;
literal MSCP$K_CM_TBK7L = 68;
literal MSCP$K_CM_RF30 = 96;
literal MSCP$K_CM_RF71 = 97;
literal MSCP$K_CM_TF85 = 98;
literal MSCP$K_CM_TF70 = 99;
literal MSCP$K_CM_RF31 = 100;
literal MSCP$K_CM_RF72 = 101;
literal MSCP$K_CM_RF73 = 102;
literal MSCP$K_CM_RF32 = 103;
literal MSCP$K_CM_HSX50 = 128;
literal MSCP$K_CM_ULTRIX = 248;
literal MSCP$K_CM_SVS = 249;
literal MSCP$S_STCON = 34;
macro MSCP$B_CNT_ALCS = 4,0,8,0 %;      !  Allocation class
macro MSCP$W_VERSION = 12,0,16,0 %;     !  MSCP version
macro MSCP$W_CNT_FLGS = 14,0,16,0 %;    !  Controller flags
macro MSCP$V_CF_576 = 14,0,1,0 %;       !    576 byte sectors [disks only]
macro MSCP$V_CF_SHADW = 14,1,1,0 %;     !    Shadowing [disks only]
macro MSCP$V_CF_MLTHS = 14,2,1,0 %;     !    Multi-Host
macro MSCP$V_CF_LDCD = 14,3,1,0 %;      !    Local Disk Copy Data
macro MSCP$V_CF_THIS = 14,4,1,0 %;      !    Enable this host's error log
macro MSCP$V_CF_OTHER = 14,5,1,0 %;     !    Enable other host's error log
macro MSCP$V_CF_MISC = 14,6,1,0 %;      !    Enable miscellaneous error log
macro MSCP$V_CF_ATTN = 14,7,1,0 %;      !    Enable attention messages
macro MSCP$V_CF_RDCD = 14,8,1,0 %;      !    Remote Disk Copy Data
macro MSCP$V_CF_WHL = 14,9,1,0 %;       !    Write History Logging Support
macro MSCP$V_CF_RDO = 14,10,1,0 %;      !    Restricted DISK COPY DATA Operations
macro MSCP$V_CF_LOAD = 14,13,1,0 %;     !    Controller returns load available information
macro MSCP$V_CF_EDCRP = 14,14,1,0 %;    !    Data Encrypt/Decrypt Supported
macro MSCP$V_CF_REPLC = 14,15,1,0 %;    !    Controller Initiated Bad Block Replacement [disks only]
macro MSCP$V_CF_SRT = 14,15,1,0 %;      !     Segemented Record Transfer
macro MSCP$W_HST_TMO = 16,0,16,0 %;     !  Host timeout
macro MSCP$W_CNT_TMO = 16,0,16,0 %;     !  Controller timeout
macro MSCP$B_CNT_SVR = 18,0,8,0 %;      !  Controller software version
macro MSCP$B_CNT_HVR = 19,0,8,0 %;      !  Controller hardware version
macro MSCP$Q_TIME = 20,0,0,0 %;
literal MSCP$S_TIME = 8;                !  Quad-word date-time
macro MSCP$Q_CNT_ID = 20,0,0,0 %;
literal MSCP$S_CNT_ID = 8;              !  Controller ID
macro MSCP$L_MAXBCNT = 28,0,32,0 %;     !  Maximum supported byte count
macro MSCP$W_CONN_REF = 32,0,16,0 %;    !  Connection reference number
!   Controller and Unit identifier Classes. (Device Class)
!  Definitions for Disk Data Copy Commands and End Messages
literal MSCP$K_MIN_SIZ = 12;            !  Shortest Command
literal MSCP$C_MIN_SIZ = 12;            !  Shortest Command
literal MSCP$K_MXCMDLEN = 36;           !  Longest Command
literal MSCP$C_MXCMDLEN = 36;           !  Longest Command
literal MSCP$K_DCDCMDLEN = 60;          !  DCD Command
literal MSCP$C_DCDCMDLEN = 60;          !  DCD Command
literal MSCP$K_LEN = 50;                !  Longest End Message
literal MSCP$C_LEN = 50;                !  Longest End Message
literal MSCP$S_DCD = 60;
macro MSCP$L_LBCOUNT = 12,0,32,0 %;     !  Logical block count
macro MSCP$W_SRC_UNUM = 16,0,16,0 %;    !  Source unit number
macro MSCP$Q_SRC_UID = 20,0,0,0 %;
literal MSCP$S_SRC_UID = 8;             !  Source unit identifier
macro MSCP$L_DEST_LBN = 28,0,32,0 %;    !  Destination LBN
macro MSCP$W_HRN = 32,0,16,0 %;         !  HRN or Entloc
macro MSCP$W_ENT_ID = 34,0,16,0 %;      !  Entry ID
macro MSCP$L_SRC_LBN = 40,0,32,0 %;     !  Source LBN
macro MSCP$Q_PORT_ADR = 44,0,0,0 %;
literal MSCP$S_PORT_ADR = 8;            !  Source unit's subsystem port address
macro MSCP$Q_SYS_ADR = 52,0,0,0 %;
literal MSCP$S_SYS_ADR = 8;             !  Source unit's subsystem system address
macro MSCP$Z_SBC_STS = 16,0,0,0 %;
literal MSCP$S_SBC_STS = 16;            !  Subcommand status
macro MSCP$W_ENT_LOC = 32,0,16,0 %;     !  Entry locator
!  Definitions for Write History Management Commands and End Messages
literal MSCP$K_WHM_DALL = 1;
literal MSCP$K_WHM_DHRN = 2;
literal MSCP$K_WHM_DELO = 3;
literal MSCP$K_WHM_RALL = 4;
literal MSCP$K_WHM_RHRN = 5;
literal MSCP$K_WHM_DAFC = 6;
literal MSCP$S_WRHIM = 32;
macro MSCP$B_WRHIS_BD = 16,0,0,0 %;
literal MSCP$S_WRHIS_BD = 12;           !  Write history buffer descriptor
macro MSCP$W_UNIT_AL = 16,0,16,0 %;     !  Unit allocated
macro MSCP$W_SERV_AL = 18,0,16,0 %;     !  Server allocated
macro MSCP$W_SERV_UNAL = 20,0,16,0 %;   !  Server unallocated
macro MSCP$W_OPER = 28,0,16,0 %;        !  Operation
macro MSCP$W_COUNT = 28,0,16,0 %;       !  Count
macro MSCP$W_OFFSET = 30,0,16,0 %;      !  Offset
!  Definitions for Write History Entry
literal WHIS$M_ET_TLIB = 16384;
literal WHIS$M_ET_ERR = 32768;
literal WHIS$K_WRITELOGLEN = 16;        !  Write log length
literal WHIS$C_WRITELOGLEN = 16;        ! 
literal WHIS$S_WRITE_LOG_ENTRY = 16;
macro WHIS$W_ELO = 0,0,16,0 %;          !  Entry Locator
macro WHIS$W_UNIT = 2,0,16,0 %;         !  Unit Number
macro WHIS$L_LENGTH = 4,0,32,0 %;       !  Transfer Length
macro WHIS$L_LBN = 8,0,32,0 %;          !  Starting Logical Block Number
macro WHIS$W_HRN = 12,0,16,0 %;         !  Host Reference Number
macro WHIS$W_ENTFLGS = 14,0,16,0 %;     !  Entry Flags
macro WHIS$V_ET_TLIB = 14,14,1,0 %;
macro WHIS$V_ET_ERR = 14,15,1,0 %;
 
!*** MODULE $MVIBDEF ***
! +      
!  This contains the definitions for the MVIA/MVIB which is a two board
!  option that iterfaces the Turbo Channel Bus to the VME bus.
! -
literal MVIB$M_MVIBR = 1;
literal MVIB$M_VMER = 2;
literal MVIB$M_VMESR = 4;
literal MVIB$M_VACLO = 8;
literal MVIB$M_VMFR = 16;
literal MVIB$M_YBXE = 32;
literal MVIB$M_YBPE = 64;
literal MVIB$M_PIOERR = 128;
literal MVIB$M_DMAERR = 256;
literal MVIB$M_YBIX = 512;
literal VME$M_A0 = 0;
literal VME$M_A1 = 1024;
literal VME$M_A2 = 2048;
literal VME$M_A3 = 3072;
literal MVIB$M_DMAPS = 4096;
literal MVIB$M_ADRTYP = 1;
literal MVIB$M_UERSUP = 2;
literal VME$M_IPL2 = 2;
literal MVIB$M_MSK = 128;
literal MVIB$M_LIRQ = 8;
literal MVIB$M_VECTOR = 16;
literal MVIB$M_EDGE = 32;
literal MVIB$M_POLA = 64;
literal MVIB$M_ENAB = 128;
literal VME$M_ERRGI_DIS = 240;
literal MVIB$M_SYSFAIL = 16;
literal MVIB$M_ARBTIM = 32;
literal MVIB$M_POST = 64;
literal MVIB$M_INCL = 1;
literal MVIB$M_DTACK = 2;
literal MVIB$M_DS = 16;
literal MVIB$M_SCON = 1;
literal MVIB$M_TURBO = 2;
literal MVIB$M_MEST = 4;
literal MVIB$M_SIGN = 8;
literal MVIB$M_DEDLK = 16;
literal MVIB$M_ACCES = 32;
literal MVIB$M_AS = 64;
literal MVIB$M_ASCON = 128;
literal MVIB$M_DRAM = 16;
literal MVIB$M_ARB = 128;
literal VME$M_ERRMSK1 = 3840;
literal MVIB$M_YAB_NCLK = 4096;
literal MVIB$M_YAB_NACK = 8192;
literal VME$M_ERRMSK2 = 49152;
literal MVIB$M_SPEED = 65536;
literal MVIB$M_RMVIB = 131072;
literal MVIB$M_RMVIA = 262144;
literal MVIB$M_PROM = 524288;
literal MVIB$M_IOSEL = 1048576;
literal MVIB$M_GENAB = 8388608;
literal MVIB$M_VALID = 1;
literal VME$M_INVLDTYP = 0;
literal VME$M_BYTEDTYP = 8;
literal VME$M_WORDDTYP = 16;
literal VME$M_LONGDTYP = 24;
literal VME$M_NXM = 0;
literal VME$M_A32 = 256;
literal VME$M_A16 = 512;
literal VME$M_A24 = 768;
literal VME$M_UDAT = 0;
literal VME$M_UPROG = 1024;
literal VME$M_SDAT = 2048;
literal VME$M_SPROG = 3072;
literal VME$M_SWAPB = 2;
literal VME$M_SWAPW = 4;
literal VME$M_SWAPNO = 0;
literal VME$M_SWAPL = 6;
literal VME$M_A24_32 = 24;
literal VME$M_SUPUSR = 96;
literal MVIB$M_RMW = 128;
literal MVIB$S_MVIBDEF = 34820;
macro MVIB$L_MVIB_CSR = 0,0,32,0 %;     !  MVIB  Control/Status
macro MVIB$V_MVIBR = 0,0,1,0 %;         !  MVIB Reset 
macro MVIB$V_VMER = 0,1,1,0 %;          !  VME Reset 
macro MVIB$V_VMESR = 0,2,1,0 %;         !  VME System Reset Status 
macro MVIB$V_VACLO = 0,3,1,0 %;         !  VME AC LOW 
macro MVIB$V_VMFR = 0,4,1,0 %;          !  VME Module Failure 
macro MVIB$V_YBXE = 0,5,1,0 %;          !  YAbus Xaction Fault Error 
macro MVIB$V_YBPE = 0,6,1,0 %;          !  YAbus Parity Error 
macro MVIB$V_PIOERR = 0,7,1,0 %;        !  PIO Page Fault Error 
macro MVIB$V_DMAERR = 0,8,1,0 %;        !  DMA Page Fault Error 
macro MVIB$V_YBIX = 0,9,1,0 %;          !  YAbus Interlocked Xaction 
macro MVIB$V_ADRS = 0,10,2,0 %;
literal MVIB$S_ADRS = 2;                !  Addr Size Control 
!  Address space selection 
macro MVIB$V_DMAPS = 0,12,1,0 %;        !  DMA Page Size 
macro MVIB$V_RESVD1 = 0,13,19,0 %;
literal MVIB$S_RESVD1 = 19;             !  Reserved 
macro MVIB$L_VMEFA = 4,0,32,0 %;        !  VME DMA Failing Address Register 
macro MVIB$V_ADRTYP = 4,0,1,0 %;        !  A24 or A32 address space 
macro MVIB$V_UERSUP = 4,1,1,0 %;        !  User or Supervisor space 
macro MVIB$V_VMEFADR = 4,2,30,0 %;
literal MVIB$S_VMEFADR = 30;            !  Failing VME Address 
macro MVIB$L_CPUFA = 8,0,32,0 %;        !  CPU PIO Failing Address Register 
!  VIC CSR's
macro MVIB$L_VIC_ICR1 = 516,0,32,0 %;   !  VME Interrupt CR 1 
macro MVIB$V_IPL = 516,0,3,0 %;
literal MVIB$S_IPL = 3;                 !  VME interrupt pending 
macro MVIB$V_UNDEF = 516,3,4,0 %;
literal MVIB$S_UNDEF = 4;               !  Undefined 
macro MVIB$V_MSK = 516,7,1,0 %;         !  Interrupt enable bit 	
macro MVIB$L_VIC_ICR2 = 520,0,32,0 %;   !  VME Interrupt CR 2 
macro MVIB$L_VIC_ICR3 = 524,0,32,0 %;   !  VME Interrupt CR 3 
macro MVIB$L_VIC_ICR4 = 528,0,32,0 %;   !  VME Interrupt CR 4 
macro MVIB$L_VIC_ICR5 = 532,0,32,0 %;   !  VME Interrupt CR 5 
macro MVIB$L_VIC_ICR6 = 536,0,32,0 %;   !  VME Interrupt CR 6 
macro MVIB$L_VIC_ICR7 = 540,0,32,0 %;   !  VME Interrupt CR 7 
macro MVIB$L_VIC_LICR1 = 548,0,32,0 %;  !  VME Local Interrupt CR 1 
!  Local interrupt pending 
macro MVIB$V_LIRQ = 548,3,1,0 %;        !  LIRQ(i) pin
macro MVIB$V_VECTOR = 548,4,1,0 %;      !  VIC Vector enable bit 	
macro MVIB$V_EDGE = 548,5,1,0 %;        !  edge/level
macro MVIB$V_POLA = 548,6,1,0 %;        !  active high/active low
macro MVIB$V_ENAB = 548,7,1,0 %;        !  Local interrupt enable
macro MVIB$L_VIC_LICR2 = 552,0,32,0 %;  !  VME Local Interrupt CR 2 
macro MVIB$L_VIC_LICR3 = 556,0,32,0 %;  !  VME Local Interrupt CR 3 
macro MVIB$L_VIC_LICR4 = 560,0,32,0 %;  !  VME Local Interrupt CR 4 
macro MVIB$L_VIC_LICR5 = 564,0,32,0 %;  !  VME Local Interrupt CR 5 
macro MVIB$L_VIC_LICR6 = 568,0,32,0 %;  !  VME Local Interrupt CR 6 
macro MVIB$L_VIC_LICR7 = 572,0,32,0 %;  !  VME Local Interrupt CR 7 
macro MVIB$L_VIC_ERRGI = 584,0,32,0 %;  !  Error Group Interrupt CR  
!  Error interrupt pending 
!  Undefined
macro MVIB$V_SYSFAIL = 584,4,1,0 %;     !  SYSFAIL enable bit 	
macro MVIB$V_ARBTIM = 584,5,1,0 %;      !  ARB Timeout enable bit 	
macro MVIB$V_POST = 584,6,1,0 %;        !  VME Write Post enable bit 	
macro MVIB$L_VIC_LVB = 596,0,32,0 %;    !  Local Interrupt Vector Base R  
macro MVIB$V_VECT = 596,0,3,0 %;
literal MVIB$S_VECT = 3;                !  Error interrupt pending 
macro MVIB$V_USER = 596,3,5,0 %;
literal MVIB$S_USER = 5;                !  User defined
macro MVIB$L_VIC_ERRVB = 600,0,32,0 %;  !  Error Group Interrupt Vector Base R  
macro MVIB$L_VIC_TTR = 672,0,32,0 %;    !  Transfer Timeout R  
macro MVIB$V_INCL = 672,0,1,0 %;        !  Include VME timeout
macro MVIB$V_DTACK = 672,1,1,0 %;       !  DTACK pin
macro MVIB$V_LTO = 672,2,3,0 %;
literal MVIB$S_LTO = 3;                 !  Local Bus Timeout
macro MVIB$V_VTO = 672,5,3,0 %;
literal MVIB$S_VTO = 3;                 !  VME Bus Timeout
macro MVIB$L_VIC_LBTR = 676,0,32,0 %;   !  Local Bus Timing R  
macro MVIB$V_PAS = 676,0,4,0 %;
literal MVIB$S_PAS = 4;                 !  Minimum PAS asserted time 
macro MVIB$V_DS = 676,4,1,0 %;          !  DS high time
macro MVIB$V_PASHW = 676,5,3,0 %;
literal MVIB$S_PASHW = 3;               !  PAS high width
macro MVIB$L_VIC_ICFR = 684,0,32,0 %;   !  Interface Configuration R  
macro MVIB$V_SCON = 684,0,1,0 %;        !  SCON pin
macro MVIB$V_TURBO = 684,1,1,0 %;       !  TURBO mode
macro MVIB$V_MEST = 684,2,1,0 %;        !  Metastability interval
macro MVIB$V_SIGN = 684,3,1,0 %;        !  Deadlock signalling change
macro MVIB$V_DEDLK = 684,4,1,0 %;       !  Enable deadlock signalling
macro MVIB$V_ACCES = 684,5,1,0 %;       !  Indivisible Access Control of VME
macro MVIB$V_AS = 684,6,1,0 %;          !  AS stretched
macro MVIB$V_ASCON = 684,7,1,0 %;       !  AS Control
macro MVIB$L_VIC_ARCR = 688,0,32,0 %;   !  Block Transfer Definition R  
macro MVIB$V_TIMER = 688,0,4,0 %;
literal MVIB$S_TIMER = 4;               !  Fairness Timer
macro MVIB$V_DRAM = 688,4,1,0 %;        !  DRAM refresh enable
macro MVIB$V_BRLVL = 688,5,2,0 %;
literal MVIB$S_BRLVL = 2;               !  VME BR level
macro MVIB$V_ARB = 688,7,1,0 %;         !  Priority/Round Robin 
macro MVIB$L_VIC_AMSR = 692,0,32,0 %;   !  Address Modifier Source R  
macro MVIB$L_VIC_BESR = 696,0,32,0 %;   !  Bus Error Status R  
macro MVIB$L_VIC_S0C0 = 704,0,32,0 %;   !  Slave Select 0 CR 0  
macro MVIB$L_VIC_S0C1 = 708,0,32,0 %;   !  Slave Select 0 CR 1  
macro MVIB$L_VIC_S1C0 = 712,0,32,0 %;   !  Slave Select 1 CR 0  
macro MVIB$L_VIC_S1C1 = 716,0,32,0 %;   !  Slave Select 1 CR 1  
macro MVIB$L_VIC_RCR = 720,0,32,0 %;    !  Release Control Register 
macro MVIB$W_IVS1 = 1026,0,16,0 %;      !  Interrupt Vector Source Register 1
macro MVIB$V_VMEVEC = 1026,0,8,0 %;
literal MVIB$S_VMEVEC = 8;              !  Vector
macro MVIB$W_IVS2 = 1028,0,16,0 %;      !  Interrupt Vector Source Register 2
macro MVIB$W_IVS3 = 1030,0,16,0 %;      !  Interrupt Vector Source Register 3
macro MVIB$W_IVS4 = 1032,0,16,0 %;      !  Interrupt Vector Source Register 4
macro MVIB$W_IVS5 = 1034,0,16,0 %;      !  Interrupt Vector Source Register 5
macro MVIB$W_IVS6 = 1036,0,16,0 %;      !  Interrupt Vector Source Register 6
macro MVIB$W_IVS7 = 1038,0,16,0 %;      !  Interrupt Vector Source Register 7
macro MVIB$L_VIACSR = 1536,0,32,0 %;    !  MVIA Command/Status Register 
macro MVIB$V_VIAVEC = 1536,0,8,0 %;
literal MVIB$S_VIAVEC = 8;              !  MVIA Vector
macro MVIB$V_ERRMSK1 = 1536,8,4,0 %;
literal MVIB$S_ERRMSK1 = 4;             !  Error mask
macro MVIB$V_YAB_NCLK = 1536,12,1,0 %;  !  MVIB Clock
macro MVIB$V_YAB_NACK = 1536,13,1,0 %;  !  Yabus Nack received
macro MVIB$V_ERRMSK2 = 1536,14,2,0 %;
literal MVIB$S_ERRMSK2 = 2;             !  Error mask
macro MVIB$V_SPEED = 1536,16,1,0 %;     !  25 MHz/< 25 MHz
macro MVIB$V_RMVIB = 1536,17,1,0 %;     !  MVIB Reset
macro MVIB$V_RMVIA = 1536,18,1,0 %;     !  MVIA Reset
macro MVIB$V_PROM = 1536,19,1,0 %;      !  PROM Enable
macro MVIB$V_IOSEL = 1536,20,1,0 %;     !  IO Space select
macro MVIB$V_GENAB = 1536,23,1,0 %;     !  Global Interrupt Enable
macro MVIB$V_REV = 1536,24,8,0 %;
literal MVIB$S_REV = 8;                 !  Revision
macro MVIB$L_VIACLR = 2048,0,32,0 %;    !  MVIA Clear/Status Register
macro MVIB$L_PIO_PMR = 2560,0,32,0 %;   !  PIO Page Map Register 1
macro MVIB$V_VALID = 2560,0,1,0 %;      !  Valid bit
macro MVIB$V_SWAP = 2560,1,2,0 %;
literal MVIB$S_SWAP = 2;                !  Swap Select
macro MVIB$V_DTYPE = 2560,3,2,0 %;
literal MVIB$S_DTYPE = 2;               !  Data Transfer Type
macro MVIB$V_ADDR = 2560,8,2,0 %;
literal MVIB$S_ADDR = 2;                !  Address Size
macro MVIB$V_FUNCT = 2560,10,2,0 %;
literal MVIB$S_FUNCT = 2;               !  Function Code
macro MVIB$V_VMEADR = 2560,12,20,0 %;
literal MVIB$S_VMEADR = 20;             !  VME Address
macro MVIB$L_DMA_PMR = 34816,0,32,0 %;  !  DMA Page Map Register 1
macro MVIB$V_ADRRS = 34816,3,2,0 %;
literal MVIB$S_ADRRS = 2;               !  Address Type Select
macro MVIB$V_SUPUSR = 34816,5,2,0 %;
literal MVIB$S_SUPUSR = 2;              !  Supervisor/User Control
macro MVIB$V_RMW = 34816,7,1,0 %;       !  RMW Select
macro MVIB$V_PFN = 34816,9,23,0 %;
literal MVIB$S_PFN = 23;                !  PFN
 
!*** MODULE $MVLDEF ***
! +
!  MAGNETIC TAPE VOLUME LIST
!  THIS STRUCTURE DESCRIBES THE VOLUMES IN A VOLUME SET
! -
literal MVL$K_FIXLEN = 36;              ! LENGTH OF FIXED AREA OF STRUCTURE 
literal MVL$C_FIXLEN = 36;              ! LENGTH OF FIXED AREA OF STRUCTURE 
literal MVL$S_MVLDEF = 36;
macro MVL$L_VCB = 0,0,32,0 %;           ! ADDRESS OF VCB 
macro MVL$W_SIZE = 8,0,16,0 %;          ! SIZE OF STRUCTURE 
macro MVL$B_TYPE = 10,0,8,0 %;          ! TYPE OF STRUCTURE 
macro MVL$B_NVOLS = 11,0,8,0 %;         ! NUMBER OF VOLUMES IN VOLUME SET 
macro MVL$T_SET_ID = 12,0,0,0 %;
literal MVL$S_SET_ID = 6;               ! FILE SET ID FOR THE VOLUME SET 
macro MVL$B_VOL_ACC = 18,0,8,0 %;       ! VOLUME ACCESSIBILTY CHARACTER DEFAULT 
macro MVL$B_MOU_PRV = 19,0,8,0 %;       ! USER'S MOUNT TIME PRIVILEGES 
macro MVL$V_VOLPRO = 19,0,1,0 %;        ! VOLPRO PRIVILEGE 
macro MVL$V_OVRPRO = 19,1,1,0 %;        ! OVERRIDE PRIVILEGE (BYPASS,SYSPRV,VOLPRO) 
macro MVL$V_OPER = 19,2,1,0 %;          ! OPER PRIVILEDGE
macro MVL$T_VOLOWNER = 20,0,0,0 %;
literal MVL$S_VOLOWNER = 14;            !  VOL1 ONER IDENTIFIER  FIELD
macro MVL$B_STDVER = 34,0,8,0 %;        !  ANSI VERSION OF VOLUME SET
!  THE FOLLOWING STRUCTURE IN REPEATED IN MVL FOR EACH REEL IN VOLUME SET
literal MVL$K_LENGTH = 8;               ! LENGTH OF STRUCTURE 
literal MVL$C_LENGTH = 8;               ! LENGTH OF STRUCTURE 
literal MVL$S_MVLDEF1 = 8;
macro MVL$T_VOLLBL = 0,0,0,0 %;
literal MVL$S_VOLLBL = 6;               ! VOLUME LABEL 
macro MVL$B_RVN = 6,0,8,0 %;            ! RELATIVE UNIT NUMBER 
macro MVL$B_STATUS = 7,0,8,0 %;         ! STATUS OF VOLUME 
macro MVL$V_MOUNTED = 7,0,1,0 %;        ! REEL IS MOUNTED 
macro MVL$V_UNUSED = 7,1,1,0 %;         ! IS THIS ENTRY IN USE 
macro MVL$V_OVERIDE = 7,2,1,0 %;        ! CAN OVERRIDE PROTECTION ON THIS REEL 
 
!*** MODULE $MVMSLDEF ***
! ++
!   $MVMSLDEF - mount verification messages list structure definition
! 
! 	The MVMSL provides a mechanism for communicating information about 
! 	mount verification messages to device driver special mount 
! 	verification processing routines.
! --
literal MVMSL$M_NOSUFFIX = 1;
literal MVMSL$M_SUPRESS = 2;
literal MVMSL$K_LENGTH = 8;             !  Length of a MVMSL entry.
literal MVMSL$S_MVMSLDEF = 13;
macro MVMSL$B_MAXIDX = -5,0,8,0 %;      !  Maximum legal MVMSL index.
macro MVMSL$L_SNDMSGOFF = -4,0,32,1 %;  !  Offset from MVMSL base to SEND_MESSAGE routine
macro MVMSL$W_MSG_CODE = 0,0,16,0 %;    !  The MSG$_ code for this entry.
macro MVMSL$W_FLAGS = 2,0,16,0 %;       !  Processing flags:
macro MVMSL$V_NOSUFFIX = 2,0,1,0 %;     ! 	Do not add suffix.
macro MVMSL$V_SUPRESS = 2,1,1,0 %;      ! 	May be suppressed.
macro MVMSL$L_TEXTOFF = 4,0,32,1 %;     !  Offset from MVMSL base to ASCIC message text.
 
!*** MODULE $NABDEF ***
! +
!  Generalized Event Notification Definitions
! 
!  Event NAme Block
! 
!  This is the third level structure of the event
!  notification database.  It contains the event
!  name and event facility code.
! 
!  These blocks are variable length based on the
!  length of the event name.
! 
! -
literal NAB$K_LENGTH = 16;              !  LENGTH OF BLOCK MINUS NAME
literal NAB$C_LENGTH = 16;              !  LENGTH OF BLOCK MINUS NAME
literal NAB$S_NABDEF = 48;
macro NAB$L_ADB_FLINK = 0,0,32,0 %;     !  LINK to AST DATA BLOCK
macro NAB$L_ADB_BLINK = 4,0,32,0 %;     !  BACKWARD LINK    
macro NAB$W_SIZE = 8,0,16,0 %;          !  STRUCTURE SIZE IN BYTES
macro NAB$B_TYPE = 10,0,8,0 %;          !  STRUCTURE TYPE CODE    
macro NAB$B_SUBTYPE = 11,0,8,0 %;       !  STRUCTURE SUBTYPE CODE
macro NAB$W_EVTFAC = 12,0,16,0 %;       !  FACILITY CODE
macro NAB$W_REMOTE_REFC = 14,0,16,0 %;  !  NUMBER OF ADBS WITH REMOTE REQUEST
macro NAB$T_EVENT_NAME = 16,0,0,0 %;
literal NAB$S_EVENT_NAME = 32;          !  EVENT NAME (MUST BE LAST)
 
!*** MODULE $NBIADEF ***
literal NBIA$M_NPE = 32768;
literal NBIA$M_BILP = 65536;
literal NBIA$M_FNPE = 131072;
literal NBIA$M_FDB = 262144;
literal NBIA$M_FLIP_29_22 = 524288;
literal NBIA$M_NIE = 2097152;
literal NBIA$M_TDF = 134217728;
literal NBIA$M_WDSF = 268435456;
literal NBIA$M_RDSF = 536870912;
literal NBIA$M_CPF = 1073741824;
literal NBIA$M_DPF = -2147483648;
literal NBIA$M_ADIN = 1;
literal NBIA$M_BI0P = 2;
literal NBIA$M_BI1P = 4;
literal NBIA$M_BI0_PE = 8;
literal NBIA$M_BI1_PE = 16;
literal NBIA$M_NBIA_PE = 32;
literal NBIA$M_BI0PU = 64;
literal NBIA$M_BI1PU = 128;
literal NBIA$M_NAWR = 512;
literal NBIA$M_FBPE = 1024;
literal NBIA$S_NBIADEF = 32;
! +
! 	Nautilus NBIA register definitions
! 
!  The NBIA sits in an NMI nexus and can connect one or two BIs to a Nautilus.
! -
macro NBIA$L_CSR0 = 0,0,32,0 %;         !  Control and Status
macro NBIA$B_NAC = 0,0,8,0 %;           !  Adapter Type Field
macro NBIA$V_NBIVO = 0,9,5,0 %;
literal NBIA$S_NBIVO = 5;               !  Vector Offset Register
macro NBIA$V_NPE = 0,15,1,0 %;          !  NBI Parity Error
macro NBIA$V_BILP = 0,16,1,0 %;         !  BIIC Loopback
macro NBIA$V_FNPE = 0,17,1,0 %;         !  Force NBI Parity error
macro NBIA$V_FDB = 0,18,1,0 %;          !  Force DMA busy
macro NBIA$V_FLIP_29_22 = 0,19,1,0 %;   !  Maintenance Magic
macro NBIA$V_NIE = 0,21,1,0 %;          !  NBI Interrupt Enable
macro NBIA$V_TOI = 0,24,3,0 %;
literal NBIA$S_TOI = 3;                 !  Time-out Interrupt
macro NBIA$V_TDF = 0,27,1,0 %;          !  Transmitter During Fault
macro NBIA$V_WDSF = 0,28,1,0 %;         !  Write Data Sequence Fault
macro NBIA$V_RDSF = 0,29,1,0 %;         !  Read Data Sequence Fault
macro NBIA$V_CPF = 0,30,1,0 %;          !  Control Parity Fault
macro NBIA$V_DPF = 0,31,1,0 %;          !  Data Parity Fault
macro NBIA$L_CSR1 = 4,0,32,0 %;         !  NBIA CSR1
macro NBIA$V_ADIN = 4,0,1,0 %;          !  Adaptor Init
macro NBIA$V_BI0P = 4,1,1,0 %;          !  BI0 Present
macro NBIA$V_BI1P = 4,2,1,0 %;          !  BI1 Present
macro NBIA$V_BI0_PE = 4,3,1,0 %;        !  BI0 Parity Error
macro NBIA$V_BI1_PE = 4,4,1,0 %;        !  BI1 Parity Error
macro NBIA$V_NBIA_PE = 4,5,1,0 %;       !  NBIA Parity Error
macro NBIA$V_BI0PU = 4,6,1,0 %;         !  BI0 Power Up
macro NBIA$V_BI1PU = 4,7,1,0 %;         !  BI1 Power Up
macro NBIA$V_NAWR = 4,9,1,0 %;          !  NBIA Wraparound (Maint Magic)
macro NBIA$V_FBPE = 4,10,1,0 %;         !  Force NBIB Parity Error
macro NBIA$V_MOD_REV = 4,12,4,0 %;
literal NBIA$S_MOD_REV = 4;             !  Module Revision
macro NBIA$L_BI0I = 8,0,32,0 %;         !  BI0 Stop Register
macro NBIA$L_BI1I = 12,0,32,0 %;        !  BI1 Stop Register
macro NBIA$L_BR4VR = 16,0,32,0 %;       !  BR4 Vector Register
macro NBIA$L_BR5VR = 20,0,32,0 %;       !  BR5 Vector Register
macro NBIA$L_BR6VR = 24,0,32,0 %;       !  BR6 Vector Register
macro NBIA$L_BR7VR = 28,0,32,0 %;       !  BR7 Vector Register
 
!*** MODULE $NAFDEF ***
! ++
! 
!  Structure for network proxy login file, NETUAF.DAT (VMS version 4.x)
! 
! --
literal NAF$M_TASK = 1;
literal NAF$M_BATCH = 2;
literal NAF$M_INTERACTIVE = 4;
literal NAF$K_LENGTH = 100;             !  Length of record 
literal NAF$C_LENGTH = 100;             !  Length of record 
literal NAF$S_NAFDEF = 100;
macro NAF$T_REMNAME = 0,0,0,0 %;
literal NAF$S_REMNAME = 64;             !  Combined nodename and remote username 
macro NAF$T_NODE = 0,0,0,0 %;
literal NAF$S_NODE = 32;                !  Node name 
macro NAF$T_REMUSER = 32,0,0,0 %;
literal NAF$S_REMUSER = 32;             !  Remote username 
macro NAF$T_LOCALUSER = 64,0,0,0 %;
literal NAF$S_LOCALUSER = 32;           !  Local username 
macro NAF$L_FLAGS = 96,0,32,1 %;        !  Flags longword
macro NAF$V_TASK = 96,0,1,0 %;          !  Allow task=0 access
macro NAF$V_BATCH = 96,1,1,0 %;         !  Allow batch jobs
macro NAF$V_INTERACTIVE = 96,2,1,0 %;   !  Allow interactive login
 
!*** MODULE $NAFV5DEF ***
! ++
! 
!  Structure for network proxy login file, NETPROXY.DAT
! 
! --
literal NAFV5$C_PROXY_FIXEDLEN = 4;
literal NAFV5$K_PROXY_FIXEDLEN = 4;
literal NAFV5$C_DEFPROXY = 1;           !  Default proxy account
literal NAFV5$C_PROXY = 2;              !  NONdefault proxy account
literal NAFV5$C_MAXPROXY = 15;          !  Max number of proxy accounts
literal NAFV5$K_MAXPROXY = 15;          !  Max number of proxy accounts
literal NAFV5$C_MAXPROXYLEN = 32;       !  Max length of proxy string
literal NAFV5$K_MAXPROXYLEN = 32;       !  Max length of proxy string
literal NAFV5$S_NAFV5PROXY = 4;
macro NAFV5$W_PROXYLEN = 0,0,16,0 %;    !  String length
macro NAFV5$W_TYPE = 2,0,16,0 %;        !  Type field
macro NAFV5$T_PROXY = 4,0,0,0 %;        !  Local proxy account name
literal NAFV5$M_TASK = 1;
literal NAFV5$M_BATCH = 2;
literal NAFV5$M_INTERACTIVE = 4;
literal NAFV5$M_UIC = 8;
literal NAFV5$K_FIXEDLEN = 76;          !  Length of fixed part of record 
literal NAFV5$C_FIXEDLEN = 76;          !  Length of fixed part of record 
literal NAFV5$C_FORMAT1 = 1;            !  format version #
literal NAFV5$K_FORMAT1 = 1;            !  format version #
!  Define the max record size
literal NAFV5$C_MAXREC = 656;
literal NAFV5$K_MAXREC = 656;
literal NAFV5$S_NAFV5DEF = 76;
macro NAFV5$W_FORMAT = 0,0,16,0 %;      !  Record format version
macro NAFV5$W_RECLEN = 2,0,16,0 %;      !  Record length
macro NAFV5$W_NODELEN = 4,0,16,0 %;     !  Length of remote node string
macro NAFV5$W_REMUSERLEN = 6,0,16,0 %;  !  Length of remote user string
macro NAFV5$L_FLAGS = 8,0,32,1 %;       !  Flags longword
macro NAFV5$V_TASK = 8,0,1,0 %;         !  Allow task=0 access
macro NAFV5$V_BATCH = 8,1,1,0 %;        !  Allow batch jobs
macro NAFV5$V_INTERACTIVE = 8,2,1,0 %;  !  Allow interactive login
macro NAFV5$V_UIC = 8,3,1,0 %;          !  Remote user uses UIC authentication
macro NAFV5$T_REMNAME = 12,0,0,0 %;
literal NAFV5$S_REMNAME = 64;           !  Combined nodename and remote username 
macro NAFV5$T_NODE = 12,0,0,0 %;
literal NAFV5$S_NODE = 32;              !  Node name 
macro NAFV5$T_REMUSER = 44,0,0,0 %;
literal NAFV5$S_REMUSER = 32;           !  Remote username 
macro NAFV5$L_REMUIC = 44,0,32,0 %;     !  Remote UIC
macro NAFV5$W_REMUIC_MEM = 44,0,16,0 %; !  Member number
macro NAFV5$W_REMUIC_GRP = 46,0,16,0 %; !  Group number
 
!*** MODULE $NBWDEF ***
! 
!  NMI Bus Window (NBW) register definitions. These are offsets from a virtual
!  base address. Due to the widely spaced addresses of the registers, they
!  are spread across 4 virtual pages. CSR0 starts on byte zero of the
!  first virtual page.
! 
literal NBW$L_NMIERR = 0;               !  NBW CSR0
literal NBW$L_NBWERR = 8;               !  NBW CSR1
literal NBW$L_DIAG = 512;               !  NBW CSR2
literal NBW$L_DIAGSC = 520;             !  NBW CSR3
literal NBW$L_IPINT = 1024;             !  NBW CSR4
literal NBW$L_NMIEAR = 1536;            !  NBW CSR6
literal NBW$L_SILO = 1544;              !  NBW CSR7
literal NMIERR$M_ADAP_CODE = 255;
literal NMIERR$M_RSRV_0 = 768;
literal NMIERR$M_NBW_CPE = 1024;
literal NMIERR$M_MEM_NMI = 2048;
literal NMIERR$M_BUF_FUL = 4096;
literal NMIERR$M_ILCK_BSY = 8192;
literal NMIERR$M_NBW_DPE = 16384;
literal NMIERR$M_CPU_NMI = 32768;
literal NMIERR$M_REV_LVL = 983040;
literal NMIERR$M_RSRV_1 = 15728640;
literal NMIERR$M_TMO_CODE = 117440512;
literal NMIERR$M_GUILTY = 134217728;
literal NMIERR$M_WSE = 268435456;
literal NMIERR$M_RSE = 536870912;
literal NMIERR$M_NMI_CPE = 1073741824;
literal NMIERR$M_NMI_DPE = -2147483648;
literal NMIERR$K_TMO_NOTMO = 0;         !  No timeout
literal NMIERR$K_TMO_MCLNAK = 1;        !  MCL No ACK
literal NMIERR$K_TMO_ILCKTO = 2;        !  Interlock timeout
literal NMIERR$K_TMO_NORRD = 3;         !  No read return data
literal NMIERR$K_TMO_NA_NR = 4;         !  No access, no response
literal NMIERR$K_TMO_NA_TB = 5;         !  No access to bus
literal NMIERR$K_TMO_NA_ILCK = 6;       !  No access, interlocked
literal NMIERR$K_TMO_NA_BSY = 7;        !  No access, busy
literal NBWERR$M_RSRV_2 = 255;
literal NBWERR$M_DIAG = 256;
literal NBWERR$M_RSRV_3 = 512;
literal NBWERR$M_TMO_IE = 1024;
literal NBWERR$M_MULT_TO = 2048;
literal NBWERR$M_I_BCON = 4096;
literal NBWERR$M_RSRV_4 = 8192;
literal NBWERR$M_GUILTY = 16384;
literal NBWERR$M_RSRV_5 = 33521664;
literal NBWERR$M_I_ADAP = 33554432;
literal NBWERR$M_RSRV_6 = -67108864;
literal NBWDIAG$M_RSRV_7 = 511;
literal NBWDIAG$M_DEV_LST = 512;
literal NBWDIAG$M_FPE = 7168;
literal NBWDIAG$M_RSRV_8 = 33546240;
literal NBWDIAG$M_LOOP = 33554432;
literal NBWDIAG$M_RSRV_9 = -67108864;
literal NBWDIAG$K_FPE_NO_ERR = 0;       !  No error
literal NBWDIAG$K_FPE_NMIDPE = 4;       !  NMI data parity err
literal NBWDIAG$K_FPE_NMICPE = 5;       !  NMI control par err
literal NBWDIAG$K_FPR_NBWCPE = 6;       !  NBW control par err
literal NBWDIAG$K_FPE_NBWDPE = 7;       !  NBW data parity err
literal NBWIP$M_RSRV_0 = 127;
literal NBWIP$M_IP0 = 128;
literal NBWIP$M_RSRV_1 = 32512;
literal NBWIP$M_IP1 = 32768;
literal NBWIP$M_RSRV_2 = 8323072;
literal NBWIP$M_IP2 = 8388608;
literal NBWIP$M_RSRV_3 = 2130706432;
literal NBWIP$M_IP3 = -2147483648;
literal NBWEAR$M_EADDR = 1073741823;
literal NBWEAR$M_RSRV_4 = 1073741824;
literal NBWEAR$M_WF_TO = -2147483648;
literal NBWSILO$M_MBZ_0 = 7;
literal NBWSILO$M_NMI_CONF = 24;
literal NBWSILO$M_NMI_PA = 32;
literal NBWSILO$M_NMI_FUNC0 = 192;
literal NBWSILO$M_MBZ_1 = 1792;
literal NBWSILO$M_NMI_FUNC1 = 14336;
literal NBWSILO$M_ID_MASK0 = 49152;
literal NBWSILO$M_MBZ_2 = 458752;
literal NBWSILO$M_ID_MASK1 = 1572864;
literal NBWSILO$M_NBW_ARB = 2097152;
literal NBWSILO$M_MEM_ARB = 4194304;
literal NBWSILO$M_P3_ARB = 8388608;
literal NBWSILO$M_MBZ_3 = 117440512;
literal NBWSILO$M_P1_ARB = 134217728;
literal NBWSILO$M_P0_ARB = 268435456;
literal NBWSILO$M_MEMBUSY = 536870912;
literal NBWSILO$M_RSRV_5 = 1073741824;
literal NBWSILO$M_A_FAULT = -2147483648;
literal NBWCSR$S_NBWCSR = 4;
macro NMIERR$V_ADAP_CODE = 0,0,8,0 %;
literal NMIERR$S_ADAP_CODE = 8;         !  Adapter code for NBW
macro NMIERR$V_RSRV_0 = 0,8,2,0 %;
literal NMIERR$S_RSRV_0 = 2;            !  Reserved
macro NMIERR$V_NBW_CPE = 0,10,1,0 %;    !  NBW Control Par err
macro NMIERR$V_MEM_NMI = 0,11,1,0 %;    !  Mem int/NMI fault 
macro NMIERR$V_BUF_FUL = 0,12,1,0 %;    !  Remote buffer full
macro NMIERR$V_ILCK_BSY = 0,13,1,0 %;   !  Interlock busy
macro NMIERR$V_NBW_DPE = 0,14,1,0 %;    !  NBW Data Parity Error
macro NMIERR$V_CPU_NMI = 0,15,1,0 %;    !  CPU NMI fault
macro NMIERR$V_REV_LVL = 0,16,4,0 %;
literal NMIERR$S_REV_LVL = 4;           !  NBW rev level
macro NMIERR$V_RSRV_1 = 0,20,4,0 %;
literal NMIERR$S_RSRV_1 = 4;            !  Reserved
macro NMIERR$V_TMO_CODE = 0,24,3,0 %;
literal NMIERR$S_TMO_CODE = 3;          !  Timeout reason code
macro NMIERR$V_GUILTY = 0,27,1,0 %;     !  This NBW caused fault
macro NMIERR$V_WSE = 0,28,1,0 %;        !  Write sequence error
macro NMIERR$V_RSE = 0,29,1,0 %;        !  Read sequence error
macro NMIERR$V_NMI_CPE = 0,30,1,0 %;    !  NMI Control parity error
macro NMIERR$V_NMI_DPE = 0,31,1,0 %;    !  NMI Data parity error
macro NBWERR$V_RSRV_2 = 0,0,8,0 %;
literal NBWERR$S_RSRV_2 = 8;            !  Reserved
macro NBWERR$V_DIAG = 0,8,1,0 %;        !  Diag mode
macro NBWERR$V_RSRV_3 = 0,9,1,0 %;      !  Reserved
macro NBWERR$V_TMO_IE = 0,10,1,0 %;     !  Timeout interrupt enable
macro NBWERR$V_MULT_TO = 0,11,1,0 %;    !  Multiple timeout
macro NBWERR$V_I_BCON = 0,12,1,0 %;     !  Initialize BCON MCA
macro NBWERR$V_RSRV_4 = 0,13,1,0 %;     !  Reserved
macro NBWERR$V_GUILTY = 0,14,1,0 %;     !  NBW caused memory interrupt
macro NBWERR$V_RSRV_5 = 0,15,10,0 %;
literal NBWERR$S_RSRV_5 = 10;           !  Reserved
macro NBWERR$V_I_ADAP = 0,25,1,0 %;     !  Init adapter
macro NBWERR$V_RSRV_6 = 0,26,6,0 %;
literal NBWERR$S_RSRV_6 = 6;            !  Reserved
macro NBWDIAG$V_RSRV_7 = 0,0,9,0 %;
literal NBWDIAG$S_RSRV_7 = 9;           !  Reserved
macro NBWDIAG$V_DEV_LST = 0,9,1,0 %;    !  Force device lost
macro NBWDIAG$V_FPE = 0,10,3,0 %;
literal NBWDIAG$S_FPE = 3;              !  Force parity error
macro NBWDIAG$V_RSRV_8 = 0,13,12,0 %;
literal NBWDIAG$S_RSRV_8 = 12;          !  Reserved
macro NBWDIAG$V_LOOP = 0,25,1,0 %;      !  Loopback mode
macro NBWDIAG$V_RSRV_9 = 0,26,6,0 %;
literal NBWDIAG$S_RSRV_9 = 6;           !  Reserved
macro NBWIP$V_RSRV_0 = 0,0,7,0 %;
literal NBWIP$S_RSRV_0 = 7;             !  Reserved
macro NBWIP$V_IP0 = 0,7,1,0 %;          !  Interrupt Processor 0
macro NBWIP$V_RSRV_1 = 0,8,7,0 %;
literal NBWIP$S_RSRV_1 = 7;             !  Reserved
macro NBWIP$V_IP1 = 0,15,1,0 %;         !  Interrupt Processor 1
macro NBWIP$V_RSRV_2 = 0,16,7,0 %;
literal NBWIP$S_RSRV_2 = 7;             !  Reserved
macro NBWIP$V_IP2 = 0,23,1,0 %;         !  Interrupt Processor 2
macro NBWIP$V_RSRV_3 = 0,24,7,0 %;
literal NBWIP$S_RSRV_3 = 7;             !  Reserved
macro NBWIP$V_IP3 = 0,31,1,0 %;         !  Interrupt Processor 3
macro NBWEAR$V_EADDR = 0,0,30,0 %;
literal NBWEAR$S_EADDR = 30;            !  Error address
macro NBWEAR$V_RSRV_4 = 0,30,1,0 %;     !  Reserved
macro NBWEAR$V_WF_TO = 0,31,1,0 %;      !  Write function time out
macro NBWSILO$V_MBZ_0 = 0,0,3,0 %;
literal NBWSILO$S_MBZ_0 = 3;            !  Must Be Zero
macro NBWSILO$V_NMI_CONF = 0,3,2,0 %;
literal NBWSILO$S_NMI_CONF = 2;         !  NMI conf <0:1>
macro NBWSILO$V_NMI_PA = 0,5,1,0 %;     !  NMI PA <29>
macro NBWSILO$V_NMI_FUNC0 = 0,6,2,0 %;
literal NBWSILO$S_NMI_FUNC0 = 2;        !  NMI function <0:1>
macro NBWSILO$V_MBZ_1 = 0,8,3,0 %;
literal NBWSILO$S_MBZ_1 = 3;            !  MBZ
macro NBWSILO$V_NMI_FUNC1 = 0,11,3,0 %;
literal NBWSILO$S_NMI_FUNC1 = 3;        !  NMI function <2:4>
macro NBWSILO$V_ID_MASK0 = 0,14,2,0 %;
literal NBWSILO$S_ID_MASK0 = 2;         !  NMI ID mask <0:1>
macro NBWSILO$V_MBZ_2 = 0,16,3,0 %;
literal NBWSILO$S_MBZ_2 = 3;            !  MBZ
macro NBWSILO$V_ID_MASK1 = 0,19,2,0 %;
literal NBWSILO$S_ID_MASK1 = 2;         !  NMI ID mask <2:3>
macro NBWSILO$V_NBW_ARB = 0,21,1,0 %;   !  NMI NBW arb
macro NBWSILO$V_MEM_ARB = 0,22,1,0 %;   !  NMI Memory/P2 arb
macro NBWSILO$V_P3_ARB = 0,23,1,0 %;    !  NMI P3/IO arb
macro NBWSILO$V_MBZ_3 = 0,24,3,0 %;
literal NBWSILO$S_MBZ_3 = 3;            !  MBZ
macro NBWSILO$V_P1_ARB = 0,27,1,0 %;    !  NMI P1/IO arb
macro NBWSILO$V_P0_ARB = 0,28,1,0 %;    !  NMI P0/IO arb
macro NBWSILO$V_MEMBUSY = 0,29,1,0 %;   !  NMI memory busy
macro NBWSILO$V_RSRV_5 = 0,30,1,0 %;    !  Reserved
macro NBWSILO$V_A_FAULT = 0,31,1,0 %;   !  After fault
 
!*** MODULE $NDTDEF ***
! +
!  NEXUS DEVICE AND ADAPTER TYPE CODES
! -
! DEFINE CONSTANT TYPE CODES 
literal NDT$_MEM4NI = 8;                ! MEMORY, 4K NOT INTERLEAVED 
literal NDT$_MEM4I = 9;                 ! MEMORY, 4K INTERLEAVED 
literal NDT$_MEM16NI = 16;              ! MEMORY, 16K NOT INTERLEAVED 
literal NDT$_MEM16I = 17;               ! MEMORY, 16K INTERLEAVED 
literal NDT$_MEM1664NI = 18;            ! MEMORY, 16K AND 64K MIXED
literal NDT$_MB = 32;                   ! MBA 0,1,2, OR 3 
literal NDT$_UB0 = 40;                  ! UB ADAPTER OR INTERCONNECT 0, 
literal NDT$_UB1 = 41;                  !  1, 
literal NDT$_UB2 = 42;                  !  2, 
literal NDT$_UB3 = 43;                  !  OR 3 
literal NDT$_DR32 = 48;                 ! DR32 0,1,2,... 
literal NDT$_CI = 56;                   ! CI780'S, CI750'S 
literal NDT$_MPM0 = 64;                 ! MULTIPORT MEMORY 0, 
literal NDT$_MPM1 = 65;                 !  1, 
literal NDT$_MPM2 = 66;                 !  2, 
literal NDT$_MPM3 = 67;                 !  OR 3 
literal NDT$_DISK9 = 81;                !  Disk on 009
literal NDT$_TERM9 = 82;                !  Terminal on 009
literal NDT$_TAPE9 = 83;                !  Tape on 009
literal NDT$_PRTR9 = 84;                !  Printer on 009
literal NDT$_SFUN9 = 85;                !  Spec. func. ctrllr. on 009
literal NDT$_USER9 = 86;                !  User-defined device on 009
literal NDT$_MEM64NIL = 104;            ! 64K NON-INTERLEAVED MEM, LOWER CONTROLLER 
literal NDT$_MEM64EIL = 105;            ! 64K EXTERNALLY INTERLEAVED MEM, LOWER 
literal NDT$_MEM64NIU = 106;            ! 64K NON-INTERLEAVED MEM, UPPER CONTROLLER 
literal NDT$_MEM64EIU = 107;            ! 64K EXTERNALLY INTERLEAVED MEM, UPPER 
literal NDT$_MEM64I = 108;              ! 64K INTERNALLY INTERLEAVED MEMORY 
literal NDT$_MEM256NIL = 112;           ! 256K NON-INTERLEAVED MEM, LOWER CONTROLLER 
literal NDT$_MEM256EIL = 113;           ! 256K EXTERNALLY INTERLEAVED MEM, LOWER 
literal NDT$_MEM256NIU = 114;           ! 256K NON-INTERLEAVED MEM, UPPER CONTROLLER 
literal NDT$_MEM256EIU = 115;           ! 256K EXTERNALLY INTERLEAVED MEM, UPPER 
literal NDT$_MEM256I = 116;             ! 256K INTERNALLY INTERLEAVED MEMORY 
literal NDT$_KA410 = 128;               ! VAXstar system
literal NDT$_KA420 = 128;               ! PVAX system
literal NDT$_KA640 = 129;               ! MAYFAIR II system
literal NDT$_SHAC = 130;
literal NDT$_SGEC = 131;
literal NDT$_KA520CIO = 132;            !  CIRRUS CIO module
literal NDT$_KA520COMM = 133;           !  CIRRUS COMM module
literal NDT$_KA43 = 134;
literal NDT$_KA440 = 135;
literal NDT$_KA46 = 135;
literal NDT$_KA49 = 136;
literal NDT$_TC = 137;
literal NDT$_X1303 = 138;
literal NDT$_XVIB = 232;                !  XMI-2-VME (VME side)
!  BI node device types.  Note low word is hardware device type on BI.
!   High order word (i.e. the 8000) distinguishes device as a BI device.
!  First BI memory nodes
literal NDT$_SCORMEM = -2147483647;     !  Scorpio Memory
!  Then other BI devices
literal NDT$_BIMFA = -2147483391;       !  BI Multi-Function Adapter
literal NDT$_BUA = -2147483390;         !  BI UNIBUS adapter
literal NDT$_BLA = -2147483389;         !  BI LESI adapter
literal NDT$_KDZ11 = -2147483387;       !  KDZ11 processor
literal NDT$_KA810 = -2147483387;       !  KA810 processor
literal NDT$_NBI = -2147483386;         !  BI-NMI Adapter
literal NDT$_XBIB = -2147475193;        !  BI-XMI Adapter
literal NDT$_XBIB_PLUS = -2147475185;   !  BI-XMI Plus Adapter
literal NDT$_BCA = -2147483384;         !  BI-CI Adapter
literal NDT$_BICOMBO = -2147483383;     !  BI Combo Board
literal NDT$_BCI750 = -2147483381;      !  Interim BI-CI Adapter
literal NDT$_BIACP = -2147483380;       !  Aurora Processor Module
literal NDT$_BDA = -2147483378;         !  BI-to-Disk Adapter
literal NDT$_BSA = -2147467004;         !  BI-to-SI Adapter
literal NDT$_KSB50 = -2147467004;       !  BI-to-SI Adapter
literal NDT$_AIO = -2147466995;         !  Aurora I/O Module
literal NDT$_KFBTA = -2147466995;       !  Aurora I/O Module
literal NDT$_AIE_TK = -2147466997;      !  Aurora I/O Extension Module
literal NDT$_AIE_TKNI = -2147466994;    !  Aurora I/O Extension Module
literal NDT$_AIE_NI = -2147466993;      !  Aurora I/O Extension Module
literal NDT$_DEBNT = -2147466993;       !  Aurora I/O Extension Module
literal NDT$_DSB32 = -2147483382;       !  BI-Hi speed sync comm adapter
literal NDT$_LACP = -2147466996;        !  BI-VAXstation 8000 graphics adapter
literal NDT$_DEBNI = -2147483368;       !  AIE varient
literal NDT$_KWB = -2147450853;         !  BI_KWB32 module
!  XMI node device types.  Note low word is hardware device type on XMI.
literal NDT$_CIXCD = 3077;              !  CI port CIXCD adapter
literal NDT$_KFMSA = 2064;              !  DSSI port KFMSA adapter
literal NDT$_XCP = 32769;               !  Calypso/CVAX CPU
literal NDT$_XRP = 32898;               !  RIGEL CPU
literal NDT$_XMA = 16385;               !  XMI Memory
literal NDT$_XBI = 8193;                !  XBI Adapter
literal NDT$_XWATCH = 3076;             !  XWATCH Adapter
literal NDT$_XJA = 4097;                !  XJA Adapter
literal NDT$_AXA = 4098;                !  AXA Adapter
literal NDT$_HSX50 = 3106;
literal NDT$_KDM70 = 3106;
literal NDT$_XBI_PLUS = 8194;           !  XBI-Plus adapter
literal NDT$_XVME = 8195;               !  XBI-Plus TO VME adapter
literal NDT$_X1202 = 32896;             !  Mariah CPU
literal NDT$_DEMNA = 3075;              !  NI port - DEMNA adapter
literal NDT$_XSA = 2085;                !  XMI-SCSI adapter
literal NDT$_X1302 = 32903;
literal NDT$_DEMFA = 2083;              !  XMI-FDDI adapter
literal NDT$_XCT = 3177;                !  IO Debug
!  Laser System Bus (LSB) Nexus device types
literal NDT$_LIOP = 8192;               !  IOP LSB device type code
literal NDT$_LMA = 16384;               !  Memory LSB device type code
literal NDT$_L1701_1 = 32773;           !  LNP (1MB cache) LSB device type code
literal NDT$_L1701_4 = 32770;           !  LNP (4MB cache) LSB device type code
literal NDT$_LAMB = 4138;               !  LAMB XMI device type code
!  Turbochannel device types 
literal NDT$_PMAD = -559087615;         !  TC to NI 
literal NDT$_PMAZ = -559087614;         !  TC to SCSI 
literal NDT$_PMAF = -559087613;         !  TC to FDDI 
literal NDT$_LOFI = -559087612;         !  TC to AUDIO 
literal NDT$_TCVME = -559087611;        !  TC to VME 
literal NDT$_TCHX = -559087610;         !  TC to SFB
literal NDT$_TCTX = -559087609;         !  TC to 24 plane 
literal NDT$_TC_GENERIC = -559087608;   !  Generic tc device
!  MBUS node devices.
literal NDT$_MBUS_FTAM = -1878982655;   ! Tape adapter
literal NDT$_MBUS_FQAM = -1878982399;   ! QBUS adapter
literal NDT$_MBUS_LEGSS = -1878982654;  ! LEGSS graphics
literal NDT$_MBUS_FWIOM = -1878982652;  ! I/O module
literal NDT$_MBUS_KA60 = -1878982392;   ! Dual CVAX CPU
literal NDT$_MBUS_8MB = -1878917104;    ! 8MB memory
literal NDT$_MBUS_16MB = -1878916848;   ! 16MB memory
literal NDT$_MBUS_32MB = -1878916336;   ! 32MB memory
literal NDT$_MBUS_32MBA = -1878916080;  ! 32MB memory
literal NDT$_MBUS_64MB = -1878915824;   ! 64MB memory
literal NDT$_MBUS_128MB = -1878915312;  ! 128MB memory
literal NDT$_MBUS_8MBFS = -1862402032;  ! 8MB Firestarter
!  (TYC0002) keep UCODE constants for CI boot adapters here
literal UCODE_CI780 = 1;
literal UCODE_BCA = 2;
literal UCODE_BCA_ONBOARD = 3;
literal UCODE_ONBOARD = 4;
 
!*** MODULE $NMBDEF ***
! +
! 
!  FORMAT OF THE FILE NAME BLOCK. THE FILE NAME BLOCK IS USED AS AN INTERNAL
!  INTERFACE TO THE DIRECTORY SCAN ROUTINE, AND IS ALSO THE FORMAT OF A
!  DIRECTORY RECORD.
! 
! -    
literal NMB$K_DIRENTRY = 16;            !  LENGTH OF DIRECTORY ENTRY 
literal NMB$C_DIRENTRY = 16;            !  LENGTH OF DIRECTORY ENTRY 
literal NMB$M_ALLVER = 8;
literal NMB$M_ALLTYP = 16;
literal NMB$M_ALLNAM = 32;
literal NMB$M_WILD = 256;
literal NMB$M_NEWVER = 512;
literal NMB$M_SUPERSEDE = 1024;
literal NMB$M_FINDFID = 2048;
literal NMB$M_LOWVER = 16384;
literal NMB$M_HIGHVER = 32768;
literal NMB$K_LENGTH = 40;              !  LENGTH OF NAME BLOCK 
literal NMB$C_LENGTH = 40;              !  LENGTH OF NAME BLOCK 
literal NMB$S_NMBDEF = 40;
macro NMB$W_FID = 0,0,0,0 %;
literal NMB$S_FID = 6;                  !  FILE ID 
macro NMB$W_FID_NUM = 0,0,16,0 %;       !  FID - FILE NUMBER 
macro NMB$W_FID_SEQ = 2,0,16,0 %;       !  FID - FILE SEQUENCE NUMBER 
macro NMB$W_FID_RVN = 4,0,16,0 %;       !  FID - RELATIVE VOLUME NUMBER 
macro NMB$W_NAME = 6,0,0,0 %;
literal NMB$S_NAME = 6;                 !  FILE NAME (RAD-50) 
macro NMB$W_TYPE = 12,0,16,0 %;         !  FILE TYPE (RAD-50) 
macro NMB$W_VERSION = 14,0,16,1 %;      !  VERSION NUMBER 
macro NMB$W_FLAGS = 16,0,16,0 %;        !  NAME STATUS FLAGS 
macro NMB$V_ALLVER = 16,3,1,0 %;        !  MATCH ALL VERSIONS 
macro NMB$V_ALLTYP = 16,4,1,0 %;        !  MATCH ALL TYPES 
macro NMB$V_ALLNAM = 16,5,1,0 %;        !  MATCH ALL NAMES 
macro NMB$V_WILD = 16,8,1,0 %;          !  WILD CARDS IN FILE NAME 
macro NMB$V_NEWVER = 16,9,1,0 %;        !  MAXIMIZE VERSION NUMBER 
macro NMB$V_SUPERSEDE = 16,10,1,0 %;    !  SUPERSEDE EXISTING FILE 
macro NMB$V_FINDFID = 16,11,1,0 %;      !  SEARCH FOR FILE ID 
macro NMB$V_LOWVER = 16,14,1,0 %;       !  LOWER VERSION OF FILE EXISTS 
macro NMB$V_HIGHVER = 16,15,1,0 %;      !  HIGHER VERSION OF FILE EXISTS 
macro NMB$B_ASCNAMSIZ = 18,0,8,0 %;
macro NMB$T_ASCNAMTXT = 19,0,0,0 %;
literal NMB$S_ASCNAMTXT = 19;
macro NMB$W_CONTEXT = 38,0,16,0 %;      !  START POINT FOR NEXT FIND 
 
!*** MODULE $NSAARGDEF ***
! +
!  Security Auditing argument list definitions
! -
! +
!  Argument list header offset definitions
! -
literal NSA$M_ARG_FLAG_ALARM = 1;
literal NSA$M_ARG_FLAG_JOURN = 2;
literal NSA$M_ARG_FLAG_MANDY = 4;
literal NSA$C_ARGHDR_LENGTH = 12;
literal NSA$K_ARGHDR_LENGTH = 12;
literal NSA$S_NSAARGHDRDEF = 12;
macro NSA$L_ARG_COUNT = 0,0,32,0 %;     !  Argument list count
macro NSA$L_ARG_ID = 4,0,32,0 %;        !  Record identification longword
macro NSA$W_ARG_TYPE = 4,0,16,0 %;      !  Record type
macro NSA$W_ARG_SUBTYPE = 6,0,16,0 %;   !  Record subtype
macro NSA$B_ARG_FLAG = 8,0,8,0 %;       !  Flags byte
macro NSA$V_ARG_FLAG_ALARM = 8,0,1,0 %; !  Generate alarm for this record
macro NSA$V_ARG_FLAG_JOURN = 8,1,1,0 %; !  Journal this record
macro NSA$V_ARG_FLAG_MANDY = 8,2,1,0 %; !  Mandatory auditing
macro NSA$B_ARG_PKTNUM = 9,0,8,0 %;     !  Number of packets
macro NSA$T_ARG_SPARE = 10,0,16,0 %;
literal NSA$S_ARG_SPARE = 2;            !  Spare bytes
macro NSA$T_ARG_LIST = 12,0,0,0 %;
! +
!  Data packet argument passing mechanism definitions
! -
literal NSA$K_ARG_MECH_BYTE = 0;        !  Byte value
literal NSA$K_ARG_MECH_WORD = 1;        !  Word value
literal NSA$K_ARG_MECH_LONG = 2;        !  Longword value
literal NSA$K_ARG_MECH_QUAD = 3;        !  Quadword value
literal NSA$K_ARG_MECH_DESCR = 4;       !  Descriptor
literal NSA$K_ARG_MECH_ADESCR = 5;      !  Address of descriptor
literal NSA$K_ARG_MECHNUM = 6;
! +
!  Argument list definitions
! -
!  File access
literal NSA$C_ARG1_LENGTH = 52;
literal NSA$K_ARG1_LENGTH = 52;
literal NSA$S_NSAARG1DEF = 52;
macro NSA$L_ARG1_FACMOD_TM = 12,0,32,0 %; !  FACMOD type and mechanism 
macro NSA$L_ARG1_FACMOD = 16,0,32,0 %;  !  File access mode
macro NSA$L_ARG1_FILNAM_TM = 20,0,32,0 %; !  FILNAM type and mechanism
macro NSA$L_ARG1_FILNAM_SIZ = 24,0,32,0 %; !  File name size
macro NSA$L_ARG1_FILNAM_PTR = 28,0,32,0 %; !  File name address
macro NSA$L_ARG1_IMGNAM_TM = 32,0,32,0 %; !  IMGNAM type and mechanism
macro NSA$Q_ARG1_IMGNAM = 36,0,0,0 %;
literal NSA$S_ARG1_IMGNAM = 8;          !  Image name
macro NSA$L_ARG1_PRIVUSED_TM = 44,0,32,0 %; !  PRIVUSED type and mechanism
macro NSA$L_ARG1_PRIVUSED = 48,0,32,0 %; !  Privileges used for access
!  Volume mount
literal NSA$C_ARG2_LENGTH = 96;
literal NSA$K_ARG2_LENGTH = 96;
literal NSA$S_NSAARG2DEF = 96;
macro NSA$L_ARG2_UIC_TM = 12,0,32,0 %;  !  UIC type and mechanism 
macro NSA$L_ARG2_UIC = 16,0,32,0 %;     !  Volume UIC
macro NSA$L_ARG2_VOLPRO_TM = 20,0,32,0 %; !  VOLPRO type and mechanism
macro NSA$L_ARG2_VOLPRO = 24,0,32,0 %;  !  Volume protection 
macro NSA$L_ARG2_MOUFLG_TM = 28,0,32,0 %; !  MOUFLG type and mechanism
macro NSA$L_ARG2_MOUFLG = 32,0,32,0 %;  !  Mount flags
macro NSA$L_ARG2_IMGNAM_TM = 36,0,32,0 %; !  IMGNAM type and mechanism
macro NSA$Q_ARG2_IMGNAM = 40,0,0,0 %;
literal NSA$S_ARG2_IMGNAM = 8;          !  Image name
macro NSA$L_ARG2_DEVNAM_TM = 48,0,32,0 %; !  DEVNAM type and mechanism
macro NSA$L_ARG2_DEVNAM_SIZ = 52,0,32,0 %; !  Device name size
macro NSA$L_ARG2_DEVNAM_PTR = 56,0,32,0 %; !  Device name address
macro NSA$L_ARG2_LOGNAM_TM = 60,0,32,0 %; !  LOGNAM type and mechanism
macro NSA$L_ARG2_LOGNAM_SIZ = 64,0,32,0 %; !  Logical name size
macro NSA$L_ARG2_LOGNAM_PTR = 68,0,32,0 %; !  Logical name address
macro NSA$L_ARG2_VOLNAM_TM = 72,0,32,0 %; !  VOLNAM type and mechanism
macro NSA$L_ARG2_VOLNAM_SIZ = 76,0,32,0 %; !  Volume name size
macro NSA$L_ARG2_VOLNAM_PTR = 80,0,32,0 %; !  Volume name address
macro NSA$L_ARG2_VOLSNAM_TM = 84,0,32,0 %; !  VOLSNAM type and mechanism
macro NSA$L_ARG2_VOLSNAM_SIZ = 88,0,32,0 %; !  Volume set name size
macro NSA$L_ARG2_VOLSNAM_PTR = 92,0,32,0 %; !  Volume set name address
!  Volume dismount
literal NSA$C_ARG3_LENGTH = 80;
literal NSA$K_ARG3_LENGTH = 80;
literal NSA$S_NSAARG3DEF = 80;
macro NSA$L_ARG3_DMOUFLG_TM = 12,0,32,0 %; !  DMOUFLG type and mechanism
macro NSA$L_ARG3_DMOUFLG = 16,0,32,0 %; !  Dismount flags
macro NSA$L_ARG3_IMGNAM_TM = 20,0,32,0 %; !  IMGNAM type and mechanism
macro NSA$Q_ARG3_IMGNAM = 24,0,0,0 %;
literal NSA$S_ARG3_IMGNAM = 8;          !  Image name
macro NSA$L_ARG3_DEVNAM_TM = 32,0,32,0 %; !  DEVNAM type and mechanism
macro NSA$L_ARG3_DEVNAM_SIZ = 36,0,32,0 %; !  Device name size
macro NSA$L_ARG3_DEVNAM_PTR = 40,0,32,0 %; !  Device name address
macro NSA$L_ARG3_LOGNAM_TM = 44,0,32,0 %; !  LOGNAM type and mechanism
macro NSA$L_ARG3_LOGNAM_SIZ = 48,0,32,0 %; !  Logical name size
macro NSA$L_ARG3_LOGNAM_PTR = 52,0,32,0 %; !  Logical name address
macro NSA$L_ARG3_VOLNAM_TM = 56,0,32,0 %; !  VOLNAM type and mechanism
macro NSA$L_ARG3_VOLNAM_SIZ = 60,0,32,0 %; !  Volume name size
macro NSA$L_ARG3_VOLNAM_PTR = 64,0,32,0 %; !  Volume name address
macro NSA$L_ARG3_VOLSNAM_TM = 68,0,32,0 %; !  VOLSNAM type and mechanism
macro NSA$L_ARG3_VOLSNAM_SIZ = 72,0,32,0 %; !  Volume set name size
macro NSA$L_ARG3_VOLSNAM_PTR = 76,0,32,0 %; !  Volume set name address
!  Global section access
literal NSA$C_ARG4_LENGTH = 64;
literal NSA$K_ARG4_LENGTH = 64;
literal NSA$S_NSAARG4DEF = 64;
macro NSA$L_ARG4_FACMOD_TM = 12,0,32,0 %; !  FACMOD type and mechanism 
macro NSA$L_ARG4_FACMOD = 16,0,32,0 %;  !  File access mode
macro NSA$L_ARG4_FILNAM_TM = 20,0,32,0 %; !  FILNAM type and mechanism
macro NSA$L_ARG4_FILNAM_SIZ = 24,0,32,0 %; !  File name size
macro NSA$L_ARG4_FILNAM_PTR = 28,0,32,0 %; !  File name address
macro NSA$L_ARG4_IMGNAM_TM = 32,0,32,0 %; !  IMGNAM type and mechanism
macro NSA$Q_ARG4_IMGNAM = 36,0,0,0 %;
literal NSA$S_ARG4_IMGNAM = 8;          !  Image name
macro NSA$L_ARG4_SECNAM_TM = 44,0,32,0 %; !  SECNAM type and mechanism
macro NSA$L_ARG4_SECNAM_SIZ = 48,0,32,0 %; !  File name size
macro NSA$L_ARG4_SECNAM_PTR = 52,0,32,0 %; !  File name address
macro NSA$L_ARG4_PRIVUSED_TM = 56,0,32,0 %; !  PRIVUSED type and mechanism
macro NSA$L_ARG4_PRIVUSED = 60,0,32,0 %; !  Privileges used for access
 
!*** MODULE $NSAEVTDEF ***
! +
!  Security Auditing event class bit definitions: This macro defines
!  the bits which are used to enable audit journaling and alarms for
!  each class of system event.
! -
literal NSA$M_EVT_ACL = 1;
literal NSA$M_EVT_MOUNT = 2;
literal NSA$M_EVT_UAF = 4;
literal NSA$M_EVT_INSTAL = 8;
literal NSA$M_EVT_AUDIT = 16;
literal NSA$M_EVT_SPARE = -32;
literal NSA$C_EVT_LENGTH = 40;
literal NSA$K_EVT_LENGTH = 40;
literal NSA$S_NSAEVTDEF = 40;
macro NSA$L_EVT_SYS = 0,0,32,0 %;       !  Misc system event mask
macro NSA$V_EVT_ACL = 0,0,1,0 %;        !  ACL requested audits
macro NSA$V_EVT_MOUNT = 0,1,1,0 %;      !  MOUNT and DISMOUNT requests
!  Modifications made to the system
macro NSA$V_EVT_UAF = 0,2,1,0 %;        !  or network authorization files
macro NSA$V_EVT_INSTAL = 0,3,1,0 %;     !  INSTALL operations
macro NSA$V_EVT_AUDIT = 0,4,1,0 %;      !  SET AUDIT operations
macro NSA$V_EVT_SPARE = 0,5,27,0 %;
literal NSA$S_EVT_SPARE = 27;
macro NSA$B_EVT_LOGB = 4,0,8,0 %;       !  Breakin detection event mask
macro NSA$B_EVT_LOGI = 5,0,8,0 %;       !  Login  event mask
macro NSA$B_EVT_LOGF = 6,0,8,0 %;       !  Login failure event mask
macro NSA$B_EVT_LOGO = 7,0,8,0 %;       !  Logout event mask
! ****************************************************************************
!  The following file access masks must be contiguous and in the current order
! ****************************************************************************
macro NSA$L_EVT_FAILURE = 8,0,32,0 %;   !  Access failures event mask
macro NSA$L_EVT_SUCCESS = 12,0,32,0 %;  !  Successful access event mask
macro NSA$L_EVT_SYSPRV = 16,0,32,0 %;   !  Success due to SYSPRV event mask
macro NSA$L_EVT_BYPASS = 20,0,32,0 %;   !  Success due to BYPASS event mask
macro NSA$L_EVT_UPGRADE = 24,0,32,0 %;  !  Success due to UPGRADE event mask
macro NSA$L_EVT_DOWNGRADE = 28,0,32,0 %; !  Success due to DOWNGRADE event mask
macro NSA$L_EVT_GRPPRV = 32,0,32,0 %;   !  Success due to GRPPRV event mask
macro NSA$L_EVT_READALL = 36,0,32,0 %;  !  Success due to READALL event mask
! ****************************************************************************
!  End of file access masks
! ****************************************************************************
literal NSA$M_EVT_LOG_BAT = 1;
literal NSA$M_EVT_LOG_DIA = 2;
literal NSA$M_EVT_LOG_LOC = 4;
literal NSA$M_EVT_LOG_REM = 8;
literal NSA$M_EVT_LOG_NET = 16;
literal NSA$M_EVT_LOG_SUB = 32;
literal NSA$M_EVT_LOG_DET = 64;
literal NSA$S_NSAEVTLOGBITS = 1;
macro NSA$V_EVT_LOG_BAT = 0,0,1,0 %;    !  Batch
macro NSA$V_EVT_LOG_DIA = 0,1,1,0 %;    !  Dialup
macro NSA$V_EVT_LOG_LOC = 0,2,1,0 %;    !  Local
macro NSA$V_EVT_LOG_REM = 0,3,1,0 %;    !  Remote
macro NSA$V_EVT_LOG_NET = 0,4,1,0 %;    !  Network
macro NSA$V_EVT_LOG_SUB = 0,5,1,0 %;    !  Subprocess
macro NSA$V_EVT_LOG_DET = 0,6,1,0 %;    !  Detached process
 
!*** MODULE $NSAFAIDEF ***
! 
!  Define the security auditing failure mode vectors.
! 
literal NSA$M_FAIL_WAIT = 1;
literal NSA$M_FAIL_CRASH = 2;
literal NSA$M_FAIL_IGNORE = 4;
literal NSA$M_MSG_LOST = 1;
literal NSA$C_FAI_LENGTH = 12;
literal NSA$K_FAI_LENGTH = 12;
literal NSA$S_NSAFAIDEF = 12;
macro NSA$W_FAILURE_MODE = 0,0,16,0 %;
macro NSA$V_FAIL_WAIT = 0,0,1,0 %;      !  Wait for resources
macro NSA$V_FAIL_CRASH = 0,1,1,0 %;     !  Crash the system
macro NSA$V_FAIL_IGNORE = 0,2,1,0 %;    !  Drop failed audits
macro NSA$W_FAILURE_FLAGS = 2,0,16,0 %;
macro NSA$V_MSG_LOST = 2,0,1,0 %;       !  Alarms lost message written?
macro NSA$L_LOST_COUNT = 4,0,32,0 %;    !  Failure count
macro NSA$W_SIZE = 8,0,16,0 %;          !  Stucture size
macro NSA$B_TYPE = 10,0,8,0 %;          !  Structure type (DYN$C_NSA)
macro NSA$B_SUBTYPE = 11,0,8,0 %;       !  Structure subtype (DYN$C_NSA_FAILURE)
 
!*** MODULE $NSAIDTDEF ***
! +
!  Security Auditing Impure Data Table offset definitions
! -
literal NSA$C_IDT_LENGTH = 1210;
literal NSA$K_IDT_LENGTH = 1210;
literal NSA$K_IDT_PAGES = 3;            !  Number of pages for IDT
literal NSA$S_NSAIDTDEF = 1210;
macro NSA$T_IDT_ALARM_HDR = 0,0,0,0 %;
literal NSA$S_IDT_ALARM_HDR = 46;       !  Alarm header buffer
macro NSA$T_IDT_RECORD_BUF = 46,0,0,0 %;
literal NSA$S_IDT_RECORD_BUF = 1024;    !  Record buffer
macro NSA$Q_IDT_RECORD_DESCR = 1070,0,0,0 %;
literal NSA$S_IDT_RECORD_DESCR = 8;     !  Record buffer descriptor
macro NSA$T_IDT_RECORD_DT = 1078,0,0,0 %;
literal NSA$S_IDT_RECORD_DT = 128;      !  Record descriptor table
!  audit journal channel number)
 
!*** MODULE $NTEDEF ***
! +
!  NOTIFICATION TABLE ENTRY DEFINITIONS
! 
!  NOTIFICATION TABLE ENTRIES ARE USED BY THE NOTIFICATION MODULE ROUTINES. 
!  EACH ENTRY STORES THE INFORMATION NEEDED FOR A SINGLE NOTIFICATION. THE
!  SYSTEM MAINTAINS TWO TABLES OF SUCH ENTRIES, ONE EACH FOR JOIN NOTIFICATION
!  AND REMOVAL NOTIFICATION.
! 
! -
literal NTE$K_LENGTH = 12;              !  LENGTH OF AN ENTRY 
literal NTE$C_LENGTH = 12;              !  LENGTH OF AN ENTRY
literal NTE$S_NTEDEF = 12;
macro NTE$L_NOTIFN_LIST_HDR = 0,0,32,0 %;
macro NTE$W_NOTIFNEFL = 0,0,16,0 %;     !  INDEX OF FIRST NOTIFICATION ENTRY ON THE TABLE
macro NTE$W_NOOFENT = 2,0,16,0 %;       !  NUMBER OF ENTRIES IN THE TABLE
macro NTE$L_NOTIFN_ID = 0,0,32,0 %;
macro NTE$W_LINK = 0,0,16,0 %;          !  LINK TO THE NEXT ENTRY ON THE LIST
macro NTE$W_SEQNO = 2,0,16,0 %;         !  SEQUENCE NUMBER OF THIS ENTRY
macro NTE$L_ROUTINE_ADDRESS = 4,0,32,0 %; !  ADDRESS OF ROUTINE TO BE CALLED DURING NOTIFICATION 
macro NTE$L_FREE_LIST_HDR = 4,0,32,0 %;
macro NTE$W_FREEFL = 4,0,16,0 %;        !  INDEX OF FIRST FREE ENTRY ON THE TABLE
macro NTE$L_NOTIFN_PARAM = 8,0,32,0 %;  !  PARAMETER TO BE PASSED TO THE ROUTINE
macro NTE$L_TYPE_DEFN = 8,0,32,0 %;
macro NTE$W_SIZE = 8,0,16,0 %;          !  SIZE OF THE TABLE
macro NTE$B_TYPE = 10,0,8,0 %;          !  TYPE OF THE DATA STRUCTURE
macro NTE$B_SUBTYPE = 11,0,8,0 %;       !  SUBTYPE OF THE DATA STRUCTURE
 
!*** MODULE $OLCKDEF ***
! +
!  OLCK - ORB LOCK
! 
!  This structures contains information about an outstanding LOCK
!  on the Object Rights Block of a specific resourse.  It is
!  maintained in a per process database (CTL$GQ_ORB_LOCKDB) used
!  to control ACL modifications through $CHANGE_ACL.
! 
! -
literal OLCK$M_RESV_1 = 1;
literal OLCK$K_FIXED_LEN = 30;          !  Fixed length 
literal OLCK$K_MAX_RSN = 33;            !  Maximum resource name
literal OLCK$S_OLCKDEF = 30;
macro OLCK$L_FLINK = 0,0,32,0 %;        !  Forward link
macro OLCK$L_BLINK = 4,0,32,0 %;        !  Backward link
macro OLCK$W_SIZE = 8,0,16,0 %;         !  Allocation size
macro OLCK$B_TYPE = 10,0,8,0 %;         !  Structure type
macro OLCK$B_STYPE = 11,0,8,0 %;        !  Subtype
macro OLCK$L_LOCKID = 12,0,32,0 %;      !  Lockid
macro OLCK$B_PRV_LKMODE = 16,0,8,0 %;   !  Previous lock mode
macro OLCK$B_CUR_LKMODE = 17,0,8,0 %;   !  Current lock mode
macro OLCK$W_FLAGS = 18,0,16,0 %;       !  Processing flags
macro OLCK$V_RESV_1 = 18,0,1,0 %;       !  reserved for future
macro OLCK$L_RESV_1 = 20,0,32,0 %;      !  Reserved 
macro OLCK$L_RESV_2 = 24,0,32,0 %;      !     for future use
macro OLCK$W_RSN_SIZE = 28,0,16,0 %;    !  Size of resource name
macro OLCK$T_RSN = 30,0,0,0 %;          !  Resource name string
 
!*** MODULE $ORBDEF ***
! +
! 
!  Object's Rights Block - structure defining the protection information
!  for various objects within the system.
! 
! -
literal ORB$M_PROT_16 = 1;
literal ORB$M_ACL_QUEUE = 2;
literal ORB$M_MODE_VECTOR = 4;
literal ORB$M_NOACL = 8;
literal ORB$M_CLASS_PROT = 16;
literal ORB$K_LENGTH = 88;              !  Structure length
literal ORB$C_LENGTH = 88;              !  Structure length
literal ORB$S_ORBDEF = 88;
macro ORB$L_OWNER = 0,0,32,0 %;         !  Object's owner
macro ORB$W_UICMEMBER = 0,0,16,0 %;     !  Member number
macro ORB$W_UICGROUP = 2,0,16,0 %;      !  Group number
macro ORB$L_ACL_MUTEX = 4,0,32,0 %;     !  Mutex for this ACL
macro ORB$W_SIZE = 8,0,16,0 %;          !  Size of the ORB in bytes
macro ORB$B_TYPE = 10,0,8,0 %;          !  Structure type
macro ORB$B_FLAGS = 11,0,8,0 %;         !  Field modifiers
macro ORB$V_PROT_16 = 11,0,1,0 %;       !  Use word not vector protection
macro ORB$V_ACL_QUEUE = 11,1,1,0 %;     !  Use ACL queue not descriptor list
macro ORB$V_MODE_VECTOR = 11,2,1,0 %;   !  Use vector not byte mode protection
macro ORB$V_NOACL = 11,3,1,0 %;         !  Object cannot have an ACL
macro ORB$V_CLASS_PROT = 11,4,1,0 %;    !  Security classification is valid
macro ORB$W_REFCOUNT = 14,0,16,0 %;     !  Reference count
macro ORB$Q_MODE_PROT = 16,0,0,0 %;
literal ORB$S_MODE_PROT = 8;            !  Mode protection vector
macro ORB$L_MODE_PROTL = 16,0,32,0 %;   !  Low longword of vector
macro ORB$L_MODE_PROTH = 20,0,32,0 %;   !  High longword of vector
macro ORB$B_MODE = 16,0,8,0 %;          !  Simple access mode
macro ORB$L_SYS_PROT = 24,0,32,0 %;     !  System protection field
macro ORB$W_PROT = 24,0,16,0 %;         !  Standard SOGW protection
macro ORB$L_OWN_PROT = 28,0,32,0 %;     !  Owner protection field
macro ORB$L_GRP_PROT = 32,0,32,0 %;     !  Group protection field
macro ORB$L_WOR_PROT = 36,0,32,0 %;     !  World protection field
macro ORB$L_ACLFL = 40,0,32,0 %;        !  ACL queue forward link
macro ORB$L_ACL_COUNT = 40,0,32,0 %;    !  Count of ACL segments
macro ORB$L_ACLBL = 44,0,32,0 %;        !  ACL queue backward link
macro ORB$L_ACL_DESC = 44,0,32,0 %;     !  Address of ACL segment descriptor list
macro ORB$R_MIN_CLASS = 48,0,0,0 %;
literal ORB$S_MIN_CLASS = 20;
macro ORB$R_MAX_CLASS = 68,0,0,0 %;
literal ORB$S_MAX_CLASS = 20;
 
!*** MODULE $PBDEF ***
! +
!  PB - SCS PATH BLOCK
! 
!  THE PB HAS INFORMATION ABOUT THE PHYSICAL PATH TO ANOTHER
!  SYSTEM IN A CLUSTER.  PATH BLOCKS TO THE SAME SYSTEM ARE
!  LINKED TOGETHER TO THE SYSTEM BLOCK (SB).
! -
literal PB$C_CLOSED = 0;                !  NEWLY CREATED PATHBLOCK 
literal PB$C_ST_SENT = 1;               !  START SENT 
literal PB$C_ST_REC = 2;                !  START RECEIVED 
literal PB$C_OPEN = 3;                  !  OPEN PORT-PORT VIRTUAL CIRCUIT 
!  CI port virtual circuit failure states
literal PB$C_STALL_SETCKT = 4;          !   SETCKT stalled by pool problem
literal PB$C_CLOSE_CKT = 5;             !   SETCKT in progress
literal PB$C_NOTIFY_VCFAIL = 6;         !   SYSAP notification for failed VC in progress
literal PB$C_STALL_CACHE = 7;           !   Cache Clear stalled by pool problem
literal PB$C_CACHE_CLEAR = 8;           !   Cache Clear in progress
literal PB$C_NOTIFY_PWFAIL = 9;         !   SYSAP notification for failed port in progress
!  
literal PB$C_VC_FAIL = 32768;           !  VC FAILURE IN PROGRESS STATE  (No longer used for CI)
literal PB$C_PWR_FAIL = 16384;          !  PWR FAIL RECOVERY IN PROGRESS STATE (No longer used for CI)
literal PB$M_DUALPATH = -2147483648;
literal PB$C_CI780 = 2;                 !  CI780 PORT
literal PB$C_CI750 = 2;                 !  CI750 PORT (=CI780)
literal PB$C_HSC = 4;                   !  HSC PORT
literal PB$C_KL10 = 6;                  !  KLIPA PORT
literal PB$C_CINT = 7;                  !  CI NODE TESTER
literal PB$C_NI = 8;                    !  NI-DEUNA PORT
literal PB$C_PS = 9;                    !  PASSTHRU PORT
literal PB$C_BCA = 11;                  !  BI-CI PORT
literal PB$C_BVPSSP = 12;               !  BVP STORAGE PORT
literal PB$C_BVPNI = 13;                !  BVP NI PORT
literal PB$C_CIXCD = 14;
literal PB$C_SII = 32;
literal PB$C_KFQSA = 33;
literal PB$C_SHAC = 34;
literal PB$C_XON = 35;
literal PB$C_SWIFT = 36;
literal PB$C_KFMSA = 37;
literal PB$C_RF70 = 48;
literal PB$C_RF71 = 48;
literal PB$C_RF30 = 49;
literal PB$C_RF31 = 50;
literal PB$C_RF72 = 51;
literal PB$C_TF70 = 64;
literal PB$C_TF30 = 65;
literal PB$C_TF85 = 65;
literal PB$C_TF86 = 66;
literal PB$M_SRSNTDATWM = 128;
literal PB$M_MAINT = 1;
literal PB$C_UNINIT = 0;                !  UNINITIALIZED, 
literal PB$C_DISAB = 1;                 !  DISABLED 
literal PB$C_ENAB = 2;                  !  ENABLED 
!  
literal PB$M_CUR_CBL = 1;
literal PB$M_CUR_PS = 1;
literal PB$M_TIM = 1;
literal PB$M_VCCHK_ENB = 2;
literal PB$M_SCS_EXP = 4;
literal PB$M_NEW_MSG = 8;
literal PB$M_LOCAL = 16;
literal PB$M_CREDIT = 32;
literal PB$M_DISC = 64;
literal PB$M_STORAGE = 128;
literal PB$K_LENGTH = 100;              ! LENGTH OF A PATH BLOCK 
literal PB$C_LENGTH = 100;              ! LENGTH OF A PATH BLOCK 
literal PB$S_PBDEF = 100;
macro PB$L_FLINK = 0,0,32,0 %;          ! FWD LINK TO NEXT PB 
macro PB$L_BLINK = 4,0,32,0 %;          ! BACK LINK TO PREVIOUS PB 
macro PB$W_SIZE = 8,0,16,0 %;           ! STRUCTURE SIZE IN BYTES 
macro PB$B_TYPE = 10,0,8,0 %;           ! SCS STRUCTURE TYPE 
macro PB$B_SUBTYP = 11,0,8,0 %;         ! SCS STRUCT SUBTYPE FOR PB 
macro PB$B_RSTATION = 12,0,0,0 %;
literal PB$S_RSTATION = 6;              ! REMOTE STATION ADDRESS 
macro PB$W_STATE = 18,0,16,0 %;         ! PATH STATE 
! STATE DEFINITIONS:
!  0 ORIGIN, INCREMENTS OF 1 
macro PB$L_RPORT_TYP = 20,0,32,0 %;     ! HARDWARE PORT TYPE CODE 
macro PB$V_PORT_TYP = 20,0,31,0 %;
literal PB$S_PORT_TYP = 31;             !  HARDWARE PORT TYPE, 
macro PB$V_DUALPATH = 20,31,1,0 %;      !  0/1 FOR SINGLE PATH/DUAL PATH PORT 
macro PB$L_RPORT_REV = 24,0,32,0 %;     ! REMOTE PORT HW REV LEVEL 
macro PB$V_RPORT_REV_SPARE = 24,0,30,0 %;
literal PB$S_RPORT_REV_SPARE = 30;      !  Spare
macro PB$V_RPORT_SPC_REV = 24,30,1,0 %; !  0 = -A / 1 = -B
macro PB$V_RPORT_REV_RESV1 = 24,31,1,0 %; !  Reserved
macro PB$L_RPORT_FCN = 28,0,32,0 %;     ! REMOTE PORT FUNCTION MASK
macro PB$V_MBZ = 28,0,7,0 %;
literal PB$S_MBZ = 7;                   !  reserved MBZ
macro PB$V_SRSNTDATWM = 28,7,1,0 %;     ! Send/Rec SNTDATWM (*not* in CI Port Arch)
macro PB$B_RST_PORT = 32,0,8,0 %;       ! OWNING PORT WHICH RESET REMOTE PORT 
macro PB$B_RSTATE = 33,0,8,0 %;         ! REMOTE PORT STATUS: 
macro PB$V_MAINT = 33,0,1,0 %;          !  0/1 FOR MAINTENANCE MODE NO/YES 
macro PB$V_STATE = 33,1,2,0 %;
literal PB$S_STATE = 2;                 !  REMOTE PORT STATE: 
!  DEFINE REMOTE STATES, 0 ORIGIN 
macro PB$W_RETRY = 34,0,16,0 %;         ! START HANDSHAKE RETRY COUNT 
macro PB$T_LPORT_NAME = 36,0,32,0 %;
literal PB$S_LPORT_NAME = 4;            ! LOCAL PORT DEVICE NAME 
macro PB$B_CBL_STS = 40,0,8,0 %;        ! CABLE STATUS TO THE REMOTE 
macro PB$V_CUR_CBL = 40,0,1,0 %;        !  1/0 FOR CURRENT STATUS OK/BAD 
macro PB$B_P0_STS = 41,0,8,0 %;         ! PATH 0 STATUS 
macro PB$B_P1_STS = 42,0,8,0 %;         ! PATH 1 STATUS 
macro PB$V_CUR_PS = 42,0,1,0 %;         !  1/0 FOR CURRENT STATUS OK/BROKEN 
macro PB$L_PDT = 44,0,32,0 %;           ! ADDR OF PORT DESCRIPTOR TABLE FOR 
!  LOCAL PORT
macro PB$L_SBLINK = 48,0,32,0 %;        ! LINK TO SYSTEM BLOCK
macro PB$L_CDTLST = 52,0,32,0 %;        ! LINK TO FIRST CDT OVER THIS PATH 
!  (0 IF NO CDT'S)
macro PB$L_WAITQFL = 56,0,32,0 %;       !  SCS SEND MSG WAIT QUEUE FLINK
macro PB$L_WAITQBL = 60,0,32,0 %;       ! SCS SEND MSG WAIT QUEUE BLINK 
macro PB$L_DUETIME = 60,0,32,0 %;       ! START HANDSHAKE TIMER 
macro PB$L_SCSMSG = 64,0,32,0 %;        ! ADDR OF SCS MESSAGE BUFFER 
macro PB$W_STS = 68,0,16,0 %;           ! PATH BLOCK STATUS 
macro PB$V_TIM = 68,0,1,0 %;            !  HANDSHAKE TIMEOUT IN PROGRESS 
macro PB$V_VCCHK_ENB = 68,1,1,0 %;      !  VC timeout checking enabled
macro PB$V_SCS_EXP = 68,2,1,0 %;        !  SCS message expected during timeout period
macro PB$V_NEW_MSG = 68,3,1,0 %;        !  New message arrived during timeout period
macro PB$V_LOCAL = 68,4,1,0 %;          !  Local port, (A BVP or PU port)
macro PB$V_CREDIT = 68,5,1,0 %;         !  SCS receive credit on free queue
macro PB$V_DISC = 68,6,1,0 %;           !  SCS disconnect request is in progress
macro PB$V_STORAGE = 68,7,1,0 %;        !  Storage only port (A DSSA port)
macro PB$W_VCFAIL_RSN = 70,0,16,0 %;    ! VC FAILURE REASON (VMS
! STATUS CODE
macro PB$B_PROTOCOL = 72,0,8,0 %;       ! PPD PROTOCOL LEVEL
macro PB$L_RPORT_MULT = 76,0,32,0 %;    ! LARGEST PACKET MULTIPLE OF THE REMOTE PORT (CI ONLY)
!  SHIFTED TO BIT POSITION <30:28> 
macro PB$L_TIME_STAMP = 80,0,32,0 %;    !  (TYC 9-Mar-89) PB INSERTION TO CONFIG. DB TIME STAMP
macro PB$L_SHARE_FLINK = 84,0,32,0 %;   !  (TYC 15-Feb-89) FWD LINK TO NEXT PB IN LOAD SHARE QUEUE
macro PB$L_SHARE_BLINK = 88,0,32,0 %;   !  (TYC 15-Feb-89) BACK LINK TO PREVIOUS PB IN LOAD SHARE QUEUE
 
!*** MODULE $PBHDEF ***
! +
!  DEFINE PERFORMANCE BUFFER HEADER
! -
literal PBH$K_START = 13;               ! START OF DATA AREA 
literal PBH$C_START = 13;               ! START OF DATA AREA 
literal PBH$K_LENGTH = 512;             ! LENGTH OF PERFORMANCE DATA BUFFER 
literal PBH$C_LENGTH = 512;             ! LENGTH OF PERFORMANCE DATA BUFFER 
literal PBH$S_PBHDEF = 512;
macro PBH$L_BUFRFL = 0,0,32,0 %;        ! BUFFER FORWARD LINK 
macro PBH$L_BUFRBL = 4,0,32,0 %;        ! BUFFER BACKWARD LINK 
macro PBH$W_SIZE = 8,0,16,0 %;          ! SIZE OF PERFORMANCE DATA BUFFER 
macro PBH$B_TYPE = 10,0,8,0 %;          ! DATA STRUCTURE TYPE 
macro PBH$W_MSGCNT = 11,0,16,0 %;       ! COUNT OF MESSAGES IN BUFFER 
 
!*** MODULE $PBODEF ***
! +
!  PBO - SCS$CONFIG_PTH CALL OUTPUT ARRAY FORMAT
! 
!  THE OUTPUT ARRAY RETURNED FROM THE SCS$CONFIG_PTH CALL.  DATA IS MOSTLY COPIED
!  FROM THE PATH BLOCK (PB) BEING LOOKED UP.
! -
literal PBO$M_SRSNTDATWM = 128;
literal PBO$C_NXT_VC = 32;              ! SPECIFIER OF NEXT VC (PB)
literal PBO$K_NXT_VC = 32;              !  TO THIS SYSTEM (12 BYTE
!  SPECIFIER FOLLOWS:)
literal PBO$C_LENGTH = 52;              ! LENGTH OF PBO
literal PBO$K_LENGTH = 52;              ! LENGTH OF PBO
literal PBO$S_PBODEF = 52;
macro PBO$B_RSTATION = 0,0,0,0 %;
literal PBO$S_RSTATION = 6;             ! REMOTE STATION ADDR
macro PBO$W_STATE = 6,0,16,0 %;         ! PATH STATE
macro PBO$L_RPORT_TYP = 8,0,32,0 %;     ! REMOTE PORT HW PORT TYPE
macro PBO$L_RPORT_REV = 12,0,32,0 %;    ! REMOTE PORT REV LEVEL
macro PBO$L_RPORT_FCN = 16,0,32,0 %;    ! REMOTE PORT FUNCTION MASK
macro PBO$V_MBZ = 16,0,7,0 %;
literal PBO$S_MBZ = 7;                  !  reserved MBZ
macro PBO$V_SRSNTDATWM = 16,7,1,0 %;    ! Send/Rec SNTDATWM (*not* in CI Port Arch)
macro PBO$B_RST_PORT = 20,0,8,0 %;      ! OWNING PORT WHICH LAST
!  RESET THIS REMOTE
macro PBO$B_RSTATE = 21,0,8,0 %;        ! REMOTE PORT STATE
macro PBO$W_RETRY = 22,0,16,0 %;        ! START HANDSHAKE RETRIES LEFT
macro PBO$T_LPORT_NAME = 24,0,32,0 %;
literal PBO$S_LPORT_NAME = 4;           ! LOCAL PORT DEVICE NAME
macro PBO$B_CBL_STS = 28,0,8,0 %;       ! CURRENT CABLE STATUS
macro PBO$B_P0_STS = 29,0,8,0 %;        ! PATH 0 STATUS
macro PBO$B_P1_STS = 30,0,8,0 %;        ! PATH 1 STATUS
macro PBO$B_NXT_RSTAT = 32,0,0,0 %;
literal PBO$S_NXT_RSTAT = 6;            !  REMOTE STATION ADDR
macro PBO$T_NXT_LPORT = 40,0,32,0 %;
literal PBO$S_NXT_LPORT = 4;            !  LOCAL PORT NAME ON NXT PB
macro PBO$B_SYSTEMID = 44,0,0,0 %;
literal PBO$S_SYSTEMID = 6;             ! ID OF SYSTEM ASSOC WITH 
!  THIS PB
 
!*** MODULE $PCADEF ***
literal PCA$M_BIF = 536870912;
literal PCA$S_PCADEF = 5;
macro PCA$V_REG_OFS = 0,0,18,0 %;
literal PCA$S_REG_OFS = 18;             !  Register offset
macro PCA$V_BI = 0,18,4,0 %;
literal PCA$S_BI = 4;                   !  BI node number
macro PCA$V_XMI = 0,22,4,0 %;
literal PCA$S_XMI = 4;                  !  XMI node number
macro PCA$V_HOSE = 0,26,3,0 %;
literal PCA$S_HOSE = 3;                 !  Hose number
macro PCA$V_BIF = 0,29,1,0 %;           !  BI address space flag
macro PCA$V_RSVD = 0,30,3,0 %;
literal PCA$S_RSVD = 3;                 !  Reserved for debug use
 
!*** MODULE $PCBDEF ***
! +
!  PCB DEFINITIONS
! -
literal PCB$M_RES = 1;
literal PCB$M_DELPEN = 2;
literal PCB$M_FORCPEN = 4;
literal PCB$M_INQUAN = 8;
literal PCB$M_PSWAPM = 16;
literal PCB$M_RESPEN = 32;
literal PCB$M_SSFEXC = 64;
literal PCB$M_SSFEXCE = 128;
literal PCB$M_SSFEXCS = 256;
literal PCB$M_SSFEXCU = 512;
literal PCB$M_SSRWAIT = 1024;
literal PCB$M_SUSPEN = 2048;
literal PCB$M_WAKEPEN = 4096;
literal PCB$M_WALL = 8192;
literal PCB$M_BATCH = 16384;
literal PCB$M_NOACNT = 32768;
literal PCB$M_NOSUSPEND = 65536;
literal PCB$M_ASTPEN = 131072;
literal PCB$M_PHDRES = 262144;
literal PCB$M_HIBER = 524288;
literal PCB$M_LOGIN = 1048576;
literal PCB$M_NETWRK = 2097152;
literal PCB$M_PWRAST = 4194304;
literal PCB$M_NODELET = 8388608;
literal PCB$M_DISAWS = 16777216;
literal PCB$M_INTER = 33554432;
literal PCB$M_RECOVER = 67108864;
literal PCB$M_SECAUDIT = 134217728;
literal PCB$M_HARDAFF = 268435456;
literal PCB$M_ERDACT = 536870912;
literal PCB$M_SOFTSUSP = 1073741824;
literal PCB$M_PREEMPTED = -2147483648;
literal PCB$M_QUANTUM_RESCHED = 1;
literal PCB$M_FORK_RESPEN = 2;
literal PCB$M_POSIX_SIGNAL = 4;
literal PCB$M_PHDLOCK = 8;
literal PCB$M_EPID_WILD = -2147483648;
literal PCB$K_SCHED_OTHER = 0;          !  Native VMS policy (MBZ)
literal PCB$K_SCHED_FIFO = 1;           !  VIP FIFO policy
literal PCB$K_SCHED_RR = 2;             !  VIP Round-Robbin policy
!  [1..10] for VIP
literal PCB$K_LENGTH = 432;             ! LENGTH OF PCB 
literal PCB$C_LENGTH = 432;             ! LENGTH OF PCB 
literal PCB$S_PCBDEF = 432;
macro PCB$L_SQFL = 0,0,32,0 %;          ! STATE QUEUE FORWARD LINK 
macro PCB$L_SQBL = 4,0,32,0 %;          ! STATE QUEUE BACKWARD LINK 
macro PCB$W_SIZE = 8,0,16,0 %;          ! SIZE IN BYTES 
macro PCB$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE CODE FOR PCB    
macro PCB$B_WEFC = 11,0,8,0 %;          ! WAITING EF CLUSTER NUMBER 
macro PCB$L_PHYPCB = 12,0,32,0 %;       ! PHYSICAL ADDRESS OF HW PCB 
macro PCB$L_ASTQFL = 16,0,32,0 %;       ! AST QUEUE FORWARD LINK(HEAD) 
macro PCB$L_ASTQBL = 20,0,32,0 %;       ! AST QUEUE BACK LINK(TAIL) 
macro PCB$B_ASTACT = 24,0,8,0 %;        ! ACCESS MODES WITH ACTIVE ASTS 
macro PCB$B_ASTEN = 25,0,8,0 %;         ! ACCESS MODES WITH ASTS ENABLED 
macro PCB$W_STATE = 26,0,16,0 %;        ! PROCESS STATE 
macro PCB$B_PRI = 28,0,8,0 %;           ! PROCESS CURRENT PRIORITY 				
macro PCB$B_PRIB = 29,0,8,0 %;          ! BASE PRIORITY 
macro PCB$B_RESERVED_B1 = 30,0,8,0 %;   !  RESERVED
macro PCB$B_AFFINITY_SKIP = 31,0,8,0 %; !  AFFINITY SKIP COUNT
macro PCB$L_OWNER = 32,0,32,0 %;        ! PID OF CREATOR 
macro PCB$L_STS = 36,0,32,0 %;          ! PROCESS STATUS FLAGS 
macro PCB$V_RES = 36,0,1,0 %;           !  RESIDENT, IN BALANCE SET 
macro PCB$V_DELPEN = 36,1,1,0 %;        !  DELETE PENDING                
macro PCB$V_FORCPEN = 36,2,1,0 %;       !  FORCE EXIT PENDING 
macro PCB$V_INQUAN = 36,3,1,0 %;        !  INITIAL QUANTUM IN PROGRESS 
macro PCB$V_PSWAPM = 36,4,1,0 %;        !  PROCESS SWAP MODE (1=NOSWAP) 
macro PCB$V_RESPEN = 36,5,1,0 %;        !  RESUME PENDING, SKIP SUSPEND 
macro PCB$V_SSFEXC = 36,6,1,0 %;        !  SYSTEM SERVICE EXCEPTION ENABLE (K) 
macro PCB$V_SSFEXCE = 36,7,1,0 %;       !  SYSTEM SERVICE EXCEPTION ENABLE (E) 
macro PCB$V_SSFEXCS = 36,8,1,0 %;       !  SYSTEM SERVICE EXCEPTION ENABLE (S) 
macro PCB$V_SSFEXCU = 36,9,1,0 %;       !  SYSTEM SERVICE EXCEPTION ENABLE (U) 
macro PCB$V_SSRWAIT = 36,10,1,0 %;      !  SYSTEM SERVICE RESOURCE WAIT DISABLE 
macro PCB$V_SUSPEN = 36,11,1,0 %;       !  SUSPEND PENDING 
macro PCB$V_WAKEPEN = 36,12,1,0 %;      !  WAKE PENDING, SKIP HIBERNATE 
macro PCB$V_WALL = 36,13,1,0 %;         !  WAIT FOR ALL EVENTS IN MASK 
macro PCB$V_BATCH = 36,14,1,0 %;        !  PROCESS IS A BATCH JOB 
macro PCB$V_NOACNT = 36,15,1,0 %;       !  NO ACCOUNTING FOR PROCESS 
macro PCB$V_NOSUSPEND = 36,16,1,0 %;    !  Process cannot be SUSPENDed
macro PCB$V_ASTPEN = 36,17,1,0 %;       !  AST PENDING 
macro PCB$V_PHDRES = 36,18,1,0 %;       !  PROCESS HEADER RESIDENT 
macro PCB$V_HIBER = 36,19,1,0 %;        !  HIBERNATE AFTER INITIAL IMAGE ACTIVATE 
macro PCB$V_LOGIN = 36,20,1,0 %;        !  LOGIN WITHOUT READING AUTH FILE 
macro PCB$V_NETWRK = 36,21,1,0 %;       !  NETWORK CONNECTED JOB 
macro PCB$V_PWRAST = 36,22,1,0 %;       !  POWER FAIL AST 
macro PCB$V_NODELET = 36,23,1,0 %;      !  NO DELETE 
macro PCB$V_DISAWS = 36,24,1,0 %;       !  1=DISABLE AUTOMATIC WS ADJUSTMENT 
macro PCB$V_INTER = 36,25,1,0 %;        !  PROCESS IS AN INTERACTIVE JOB
macro PCB$V_RECOVER = 36,26,1,0 %;      !  PROCESS CAN RECOVER LOCKS
macro PCB$V_SECAUDIT = 36,27,1,0 %;     !  MANDATORY SECURITY AUDITING
macro PCB$V_HARDAFF = 36,28,1,0 %;      !  PROCESS IS BOUND TO PARTICULAR CPU
macro PCB$V_ERDACT = 36,29,1,0 %;       !  Exec mode rundown active
macro PCB$V_SOFTSUSP = 36,30,1,0 %;     !  Process is in "soft" suspend
macro PCB$V_PREEMPTED = 36,31,1,0 %;    !  Hard suspend has preempted soft
macro PCB$L_STS2 = 40,0,32,0 %;         ! PROCESS STATUS FLAGS (2nd LW)
macro PCB$V_QUANTUM_RESCHED = 40,0,1,0 %; !  Quantum-oriented process reschedule
macro PCB$V_FORK_RESPEN = 40,1,1,0 %;   !  resume pending bit for a posix forked process
macro PCB$V_POSIX_SIGNAL = 40,2,1,0 %;  !  pending and deliverable posix signal/event
macro PCB$V_PHDLOCK = 40,3,1,0 %;       !  Don't swap PHD -- process has $LCKPAG pages
macro PCB$L_WTIME = 44,0,32,0 %;        ! TIME AT START OF WAIT 
macro PCB$B_PRISAV = 44,0,8,0 %;        ! SAVED CURRENT PRIORITY 
macro PCB$B_PRIBSAV = 45,0,8,0 %;       ! SAVE BASE PRIORITY 
macro PCB$B_DPC = 46,0,8,0 %;           ! DELETE PENDING COUNT
macro PCB$B_AUTHPRI = 47,0,8,0 %;       ! INITIAL PROCESS PRIORITY 
macro PCB$L_ONQTIME = 48,0,32,0 %;      ! Abs time when placed on COM/COMO queue,
! adjusted for process wait time
macro PCB$L_WAITIME = 52,0,32,0 %;      ! ABS TIME OF LAST PROCESS EVENT
macro PCB$W_ASTCNT = 56,0,16,0 %;       ! AST COUNT REMAINING 
macro PCB$W_BIOCNT = 58,0,16,0 %;       ! BUFFERED I/O COUNT REMAINING 
macro PCB$W_BIOLM = 60,0,16,0 %;        ! BUFFERED I/O LIMIT 
macro PCB$W_DIOCNT = 62,0,16,0 %;       ! DIRECT I/O COUNT REMAINING 
macro PCB$W_DIOLM = 64,0,16,0 %;        ! DIRECT I/O COUNT LIMIT 
macro PCB$W_PRCCNT = 66,0,16,0 %;       ! SUBPROCESS COUNT 
macro PCB$T_TERMINAL = 68,0,0,0 %;
literal PCB$S_TERMINAL = 8;             ! TERMINAL DEVICE NAME STRING 
! FOR INTERACTIVE JOBS
macro PCB$L_PQB = 76,0,32,0 %;          ! POINTER TO PROCESS QUOTA BLOCK 
! (PROCESS CREATION ONLY)
macro PCB$L_EFWM = 76,0,32,0 %;         ! EVENT FLAG WAIT MASK 
macro PCB$L_EFCS = 80,0,32,0 %;         ! LOCAL EVENT FLAG CLUSTER,SYSTEM 
macro PCB$L_EFCU = 84,0,32,0 %;         ! LOCAL EVENT FLAG CLUSTER, USER 
macro PCB$W_PGFLCHAR = 88,0,16,0 %;     ! PAGE FILE CHARACTERISTICS
macro PCB$B_PGFLINDEX = 90,0,8,0 %;     ! Desired SYSTEM page file index
macro PCB$L_EFC2P = 88,0,32,0 %;        ! POINTER TO GLOBAL CLUSTER !2 
macro PCB$L_EFC3P = 92,0,32,0 %;        ! POINTER TO GLOBAL CLUSTER !3
macro PCB$L_PID = 96,0,32,0 %;          ! PROCESS ID USED BY EXEC ON LOCAL NODE ONLY
!   
! *** WARNING - THE INTERNAL STRUCTURE OF THE EPID IS SUBJECT TO RADICAL CHANGE BETWEEN
! ***           VERSIONS OF VMS.  NO ASSUMPTIONS SHOULD EVER BE MADE ABOUT ITS FORMAT
! 
macro PCB$L_EPID = 100,0,32,0 %;        ! CLUSTER-WIDE PROCESS ID SEEN BY THE WORLD
macro PCB$V_EPID_PROC = 100,0,21,0 %;
literal PCB$S_EPID_PROC = 21;           ! PROCESS ID FIELD, CAN CONVERT TO PCB$L_PID
macro PCB$V_EPID_NODE_IDX = 100,21,8,0 %;
literal PCB$S_EPID_NODE_IDX = 8;        ! IDX - INDEX TO TABLE OF NODE IDENTIFICATIONS
macro PCB$V_EPID_NODE_SEQ = 100,29,2,0 %;
literal PCB$S_EPID_NODE_SEQ = 2;        ! SEQ - SEQUENCE NUMBER FOR NODE TABLE ENTRY REUSE
macro PCB$V_EPID_WILD = 100,31,1,0 %;   ! FLAG THAT EPID IS WILDCARD CONTEXT FOR $GETJPI, AND NOT
!  A VALID EPID
! 
macro PCB$L_EOWNER = 104,0,32,0 %;      ! EPID OF PROCESS OWNER
! 
macro PCB$L_PHD = 108,0,32,0 %;         ! PROCESS HEADER ADDRESS 
macro PCB$W_APTCNT = 112,0,16,0 %;      ! ACTIVE PAGE TABLE COUNT 
macro PCB$W_MTXCNT = 114,0,16,0 %;      ! COUNT OF MUTEX SEMAPHORES OWNED 
macro PCB$L_GPGCNT = 116,0,32,0 %;      ! GLOBAL PAGE COUNT IN WS 
macro PCB$L_PPGCNT = 120,0,32,0 %;      ! PROCESS PAGE COUNT IN WS
macro PCB$L_JIB = 124,0,32,0 %;         ! ADDRESS OF JOB INFORMATION BLOCK 
macro PCB$L_WSSWP = 128,0,32,0 %;       ! SWAP FILE DISK ADDRESS 
macro PCB$L_SWAPSIZE = 132,0,32,0 %;    ! SWAP BLOCK ALLOCATION 
macro PCB$R_PCBARB = 136,0,0,0 %;
literal PCB$S_PCBARB = 124;
macro PCB$Q_PRIV = 136,0,0,0 %;
literal PCB$S_PRIV = 8;                 ! CURRENT PRIVILEGE MASK 
macro PCB$L_ARB = 144,0,32,0 %;         ! ADDRESS OF ACCESS RIGHTS BLOCK 
macro PCB$L_UIC = 196,0,32,0 %;         ! LOGON UIC OF PROCESS 
macro PCB$W_MEM = 196,0,16,0 %;         ! MEMBER NUMBER IN UIC 
macro PCB$W_GRP = 198,0,16,0 %;         ! GROUP NUMBER IN UIC 
macro PCB$L_ORB = 260,0,32,0 %;         !  Address of the ORB
macro PCB$W_TMBU = 266,0,16,0 %;        ! TERMINATION MAILBOX UNIT NO. 
macro PCB$L_LOCKQFL = 268,0,32,0 %;     ! LOCK QUEUE FORWARD LINK 
macro PCB$L_LOCKQBL = 272,0,32,0 %;     ! LOCK QUEUE BACKWARD LINK 
macro PCB$L_DLCKPRI = 276,0,32,0 %;     ! DEADLOCK RESOLUTION PRIORITY 
macro PCB$L_IPAST = 280,0,32,0 %;       ! VECTOR OF MODE BITS FOR IPASTS 
macro PCB$L_DEFPROT = 284,0,32,0 %;     ! PROCESS DEFAULT PROTECTION
macro PCB$L_PMB = 288,0,32,0 %;         ! PMB ADDRESS
macro PCB$L_AFFINITY = 292,0,32,0 %;    ! CPU ID for affinity
macro PCB$L_SCHED_SPARE = 296,0,32,0 %; ! spare for scheduler
macro PCB$B_SCHED_POLICY = 296,0,8,0 %; ! POSIX sched policy    
macro PCB$L_CAPABILITY = 300,0,32,0 %;  !  CPU capability selection bitmask
macro PCB$L_CPU_ID = 304,0,32,0 %;      ! PHYSICAL CPU ID
macro PCB$L_CPUTIM = 308,0,32,0 %;      ! Accumulated CPU time
! at last outswap
macro PCB$T_LNAME = 312,0,0,0 %;
literal PCB$S_LNAME = 16;               ! LOGICAL NAME OF PROCESS 
macro PCB$L_PRCPDB = 328,0,32,0 %;      !  Address of process performance data block
! **** NB: For DIGITAL software use only *****
macro PCB$L_PIXHIST = 332,0,32,0 %;     !  PIXSCAN history summary LW 
macro PCB$L_NS_RESERVED_Q1 = 336,0,32,0 %; !  Reserved for VP
macro PCB$L_NS_RESERVED_Q1_L1 = 336,0,32,0 %;
macro PCB$L_VP_CONTEXT = 336,0,32,0 %;  !  Address of vector context area
macro PCB$L_AFFINITY_CALLBACK = 340,0,32,0 %; !  Callback for breaking affinity
macro PCB$L_PERMANENT_CAPABILITY = 344,0,32,0 %; !  Permanent capability  mask
macro PCB$L_PERMANENT_CPU_AFFINITY = 348,0,32,0 %; !  Permanent CPU affinity
macro PCB$Q_CWPSSRV_QUEUE = 352,0,0,0 %;
literal PCB$S_CWPSSRV_QUEUE = 8;        !  CWPS service block queue
macro PCB$L_CURRENT_AFFINITY = 360,0,32,0 %; !  Current CPU mask
macro PCB$L_CAPABILITY_SEQ = 364,0,32,0 %; !  Copy of last sequence number
macro PCB$L_XPCB = 368,0,32,0 %;        !  address of the posix extended pcb
macro PCB$Q_BUFOBJ_LIST = 372,0,0,0 %;
literal PCB$S_BUFOBJ_LIST = 8;          !  Defined buffer objects queue head
macro PCB$L_ADB_LINK = 380,0,32,0 %;    !  Address of AST Data Blocks (GEN)
macro PCB$W_TOTAL_EVTAST = 384,0,16,0 %; !  Total AST quota in use for event (GEN)
macro PCB$A_CURRENT_TX = 388,0,32,0 %;  !  Pointer to process default transaction
macro PCB$A_CURRENT_CD = 392,0,32,0 %;  !  Pointer to process default commit domain
macro PCB$A_CURRENT_VERTEX = 396,0,32,0 %; !  Pointer to process default execution vertex
macro PCB$Q_XSCB_QUE = 400,0,0,0 %;
literal PCB$S_XSCB_QUE = 8;             !  Transaction Segment list
macro PCB$A_XSCB_FLINK = 400,0,32,0 %;
macro PCB$A_XSCB_BLINK = 404,0,32,0 %;
macro PCB$Q_RMCB_QUE = 408,0,0,0 %;
literal PCB$S_RMCB_QUE = 8;             !  Declared resource manager list
macro PCB$A_RMCB_FLINK = 408,0,32,0 %;
macro PCB$A_RMCB_BLINK = 412,0,32,0 %;
macro PCB$Q_CD_QUE = 416,0,0,0 %;
literal PCB$S_CD_QUE = 8;               !  Commit domain membership list
macro PCB$A_CD_FLINK = 416,0,32,0 %;
macro PCB$A_CD_BLINK = 420,0,32,0 %;
macro PCB$L_CPUTIME_REF = 424,0,32,0 %; !  CPUTIME at last TICK time 
macro PCB$L_ACC_WAITIME = 428,0,32,0 %; !  Accumulated wait time 
 
!*** MODULE $PDBDEF ***
! +
!  DEFINE DEVICE PERFORMANCE DATA BLOCK
! -
literal PDB$K_LENGTH = 52;              ! LENGTH OF DATA CONTROL BLOCK 
literal PDB$C_LENGTH = 52;              ! LENGTH OF DATA CONTROL BLOCK 
literal PDB$S_PDBDEF = 52;
macro PDB$L_FREEFL = 0,0,32,0 %;        ! FREE BUFFER LISTHEAD FORWARD LINK 
macro PDB$L_FREEBL = 4,0,32,0 %;        ! FREE BUFFER LISTHEAD BACKLINK 
macro PDB$W_SIZE = 8,0,16,0 %;          ! SIZE OF DATA STRUCTURE 
macro PDB$B_TYPE = 10,0,8,0 %;          ! TYPE OF DATA STRUCTURE 
macro PDB$B_OVERRUN = 11,0,8,0 %;       ! OVERRUN INDICATOR 
macro PDB$L_FILLFL = 12,0,32,0 %;       ! FILLED BUFFER LISTHEAD FORWARD LINK 
macro PDB$L_FILLBL = 16,0,32,0 %;       ! FILLED BUFFER LISTHEAD BACKWARD LINK 
macro PDB$L_CURBUF = 20,0,32,0 %;       ! ADDRESS OF CURRENT BUFFER 
macro PDB$L_NXTBUF = 24,0,32,0 %;       ! ADDRESS OF NEXT LOCATION IN BUFFER 
macro PDB$L_ENDBUF = 28,0,32,0 %;       ! ADDRESS OF END OF BUFFER 
macro PDB$L_PID = 32,0,32,0 %;          ! PROCESS ID OF DATA COLLECTION PROCESS 
macro PDB$B_DEVCLASS = 36,0,8,0 %;      ! DEVICE CLASS SELECTION 
macro PDB$B_DEVTYPE = 37,0,8,0 %;       ! DEVICE TYPE SELECTION 
macro PDB$W_ANDM = 38,0,16,0 %;         ! STATUS SELECTION 'AND' MASK 
macro PDB$W_XORM = 40,0,16,0 %;         ! STATUS SELECTION 'XOR' MASK 
macro PDB$W_BUFCNT = 42,0,16,0 %;       ! COUNT OF FILLED BUFFERS 
macro PDB$Q_FUNC = 44,0,0,0 %;
literal PDB$S_FUNC = 8;                 ! SELECTION FUNCTION MASK 
 
!*** MODULE $PDTDEF ***
! +
!  DEFINE PORT-INDEPENDENT OFFSETS IN A PORT DESCRIPTOR TABLE.
! 
!  THERE IS ONE PDT PER PORT ACCESSED VIA SCS.  THESE PORTS INCLUDE
!  CI'S AND UDA'S.  THE PDT CONTAINS A PORT-INDEPENDENT PIECE (DEFINED
!  HERE) FOLLOWED BY AN OPTIONAL PORT-SPECIFIC PIECE DEFINED IN THE
!  PORT DRIVER.  PDT'S ARE CREATED BY THE CONTROLLER INIT ROUTINES
!  OF THE INDIVIDUAL PORT DRIVERS.
! -
literal PDT$M_SNGLHOST = 1;
literal PDT$C_PA = 1;                   !  CI PORT 
literal PDT$C_PU = 2;                   !  UDA PORT 
literal PDT$C_PE = 3;                   !  NI PORT
literal PDT$C_PS = 4;                   !  PASSTHRU PORT
literal PDT$C_PB = 5;                   !  BVP storage port
literal PDT$C_PI = 6;                   !  DSSI PORT
literal PDT$C_PL = 7;                   !  Gapless tape port
literal PDT$C_PW = 8;                   !  SWIFT port
literal PDT$K_SCSBASE = 12;             ! SCS ENTRIES INTO THE PORT DRIVER: 
literal PDT$C_SCSBASE = 12;             ! SCS ENTRIES INTO THE PORT DRIVER: 
literal PDT$K_SCSEND = 184;             ! END OF SCS ENTRIES TO PORT DRIVER 
literal PDT$C_SCSEND = 184;             ! END OF SCS ENTRIES TO PORT DRIVER 
literal PDT$M_CNTBSY = 1;
literal PDT$M_CNTRLS = 2;
literal PDT$C_BASEVER = 0;              ! V4.0 drivers
literal PDT$C_LISTENVER = 1;            ! V5.0 redesigned listener connection state transitions
literal PDT$C_BALANCEVER = 2;           ! Dynamic load balancing version
literal PDT$C_REORGVER = 1;             ! V5.0 reorganized PDT format
literal PDT$C_CREDITVER = 2;            ! Optimistic credit allocation format
literal PDT$C_NI_CLASS = 10;            !  NI/SCA performance level port/interconnect
literal PDT$C_CI_CLASS = 20;            !  CI     performance level port/interconnect
! 
literal PDT$C_YELLOW = 4;               !  Port is in YELLOW zone
literal PDT$C_RED = 6;                  !  Port is in RED zone
literal PDT$C_UNEQUAL_PATH = 7;         !  Unequal path load sharing (i.e. NI->CI)
literal PDT$K_LENGTH = 552;             ! SIZE OF PORT-INDEPENDENT PIECE 
literal PDT$C_LENGTH = 552;             ! SIZE OF PORT-INDEPENDENT PIECE 
!  OF PDT.
literal PDT$S_PDTDEF = 552;
macro PDT$L_FLINK = 0,0,32,0 %;         ! LINK TO NEXT SCS PDT
macro PDT$W_PORTCHAR = 4,0,16,0 %;      ! Port Characteristics
macro PDT$V_SNGLHOST = 4,0,1,0 %;       !  Port to single host bus
macro PDT$B_PDT_TYPE = 7,0,8,0 %;       !  TYPE OF PDT 
macro PDT$W_SIZE = 8,0,16,0 %;          ! STRUCTURE SIZE IN BYTES 
macro PDT$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE = SCS 
macro PDT$B_SUBTYP = 11,0,8,0 %;        ! STRUCTURE SUBTYPE 
macro PDT$L_ACCEPT = 12,0,32,0 %;       !  ACCEPT A CONNECT REQUEST 
macro PDT$L_ALLOCDG = 16,0,32,0 %;      !  ALLOCATE A DG BUFFER 
macro PDT$L_ALLOCMSG = 20,0,32,0 %;     !  ALLOCATE A MESSAGE BUFFER 
macro PDT$L_CONNECT = 24,0,32,0 %;      !  REQUEST CONNECTION TO REMOTE 
macro PDT$L_DEALLOCDG = 28,0,32,0 %;    !  DEALLOCATE DG BUFFER 
macro PDT$L_DEALLOMSG = 32,0,32,0 %;    !  DEALLOCATE MSG BUFFER 
macro PDT$L_DEALRGMSG = 36,0,32,0 %;    !  DEALLOC MSG BUFF, ARGS IN REGISTERS 
macro PDT$L_DCONNECT = 40,0,32,0 %;     !  BREAK CONNECTION 
macro PDT$L_MAP = 44,0,32,0 %;          !  MAP A BUFFER FOR BLK XFER 
macro PDT$L_MAPBYPASS = 48,0,32,0 %;    !  MAP, DISABL ACCESS CHECKS 
macro PDT$L_MAPIRP = 52,0,32,0 %;       !  MAP, GET ARGS FROM IRP 
macro PDT$L_MAPIRPBYP = 56,0,32,0 %;    !  MAP, ARGS FROM IRP, DISABL ACCESS CHECKS 
macro PDT$L_QUEUEDG = 60,0,32,0 %;      !  QUEUE A DG FOR RECEIVE 
macro PDT$L_QUEUEMDGS = 64,0,32,0 %;    !  ALLOC/DEALLOC DG'S FOR RECEIVE 
macro PDT$L_RCHMSGBUF = 68,0,32,0 %;    !  RECYCLE MSG BUFF, HIGH PRIORITY 
macro PDT$L_RCLMSGBUF = 72,0,32,0 %;    !  RECYCLE MSG BUFF, LOW PRIORITY 
macro PDT$L_REJECT = 76,0,32,0 %;       !  REJECT CONNECT REQUEST 
macro PDT$L_REQDATA = 80,0,32,0 %;      !  REQUEST BLK DATA XFER 
macro PDT$L_SENDDATA = 84,0,32,0 %;     !  SEND BLK DATA XFER 
macro PDT$L_SENDDG = 88,0,32,0 %;       !  SEND A DATAGRAM 
macro PDT$L_SENDMSG = 92,0,32,0 %;      !  SEND A MESSAGE 
macro PDT$L_SNDCNTMSG = 96,0,32,0 %;    !  SEND MSG WITH BYTE COUNT 
macro PDT$L_UNMAP = 100,0,32,0 %;       !  UNMAP A BUFFER 
macro PDT$L_READCOUNT = 104,0,32,0 %;   !  READ COUNTERS (FMT PORT SPECIFIC) 
macro PDT$L_RLSCOUNT = 108,0,32,0 %;    !  RELEASE AND READ COUNTERS 
macro PDT$L_MRESET = 112,0,32,0 %;      !  MAINT RESET OF REMOTE 
macro PDT$L_MSTART = 116,0,32,0 %;      !  MAINT START OF REMOTE 
macro PDT$L_MAINTFCN = 120,0,32,0 %;    !  MISC MAINT FUNCTIONS NOT SUPPORTED 
!   IN VMS
macro PDT$L_SENDRGDG = 124,0,32,0 %;    !  SEND DG W/ REGISTER INPUTS
macro PDT$L_STOP_VCS = 128,0,32,0 %;    !  SEND STOP DGS ON ALL VCS
macro PDT$L_SHUT_PATH = 132,0,32,0 %;   !  FORCE VC SHUTDOWN
macro PDT$L_SET_CRASH = 136,0,32,0 %;   !  Define the cluster crash message
macro PDT$L_SEND_CRASH = 140,0,32,0 %;  !  Send the cluster crash message
macro PDT$L_SCAN_MAP_WAIT = 144,0,32,0 %; !  Search for stalled map resources
macro PDT$L_SENDDATAWMSG = 148,0,32,0 %; !  send data w/piggyback message
macro PDT$L_REINIT_PORT = 152,0,32,0 %; !  (TYC 10-Feb-89) REINIT A PORT
!  (TYC 8-Dec-88) merge SHUT_ALL_VC from V5.1 variant
macro PDT$L_SHUT_ALL_VC = 156,0,32,0 %; !  Shutdown all VCs on a port
macro PDT$L_WAITQFL = 184,0,32,0 %;     ! LISTHEAD FOR FORK BLOCKS WAITING 
macro PDT$L_WAITQBL = 188,0,32,0 %;     !  FOR NONPAGED POOL 
macro PDT$L_MSGHDRSZ = 192,0,32,0 %;    ! MESSAGE HEADER SIZE 
macro PDT$L_DGOVRHD = 196,0,32,0 %;     ! DATAGRAM HEADER SIZE 
macro PDT$L_MAXBCNT = 200,0,32,0 %;     ! MAXIMUM TRANSFER BCNT
macro PDT$W_FLAGS = 204,0,16,0 %;       ! PORT FLAGS 
macro PDT$V_CNTBSY = 204,0,1,0 %;       !  COUNTERS IN USE 
macro PDT$V_CNTRLS = 204,1,1,0 %;       !  RELEASE COUNTERS 
macro PDT$T_CNTOWNER = 208,0,0,0 %;
literal PDT$S_CNTOWNER = 16;            ! NAME OF SYSAP USING COUNTERS 
macro PDT$L_CNTCDRP = 224,0,32,0 %;     ! CDRP OF SYSAP READING COUNTERS 
macro PDT$L_POLLSWEEP = 228,0,32,0 %;   ! # SECONDS TO DO A POLLER SWEEP
macro PDT$L_UCB0 = 232,0,32,0 %;        ! ADDR OF UCB.
macro PDT$L_ADP = 236,0,32,0 %;         ! ADDR OF ADP.
macro PDT$L_MAX_VCTMO = 240,0,32,0 %;   ! Maximum VC timeout
macro PDT$W_SCSVERSION = 244,0,16,0 %;  ! SCSLOA version
macro PDT$W_PPDVERSION = 246,0,16,0 %;  ! PPD driver version
macro PDT$L_LOAD_VECTOR = 248,0,32,0 %; ! Load vector
macro PDT$W_LOAD_CLASS = 252,0,16,0 %;  ! Load class (higher arbitrary numbers for higher interconnect performance)
!  class = 0 for default lowest performance level
!  (TYC 15-Feb-89) Dynamic Load Sharing Specific Counters and Fields                 
! 
macro PDT$Q_PB = 256,0,0,0 %;
literal PDT$S_PB = 8;                   !  Queue header for path blocks
macro PDT$Q_CONN_WAIT = 264,0,0,0 %;
literal PDT$S_CONN_WAIT = 8;            !  Queue header for CDTs in Load Share Wait Queue
macro PDT$Q_YELLOW = 272,0,0,0 %;
literal PDT$S_YELLOW = 8;               !  Queue header for CDTs in Load Share Yellow Queue
macro PDT$Q_RED = 280,0,0,0 %;
literal PDT$S_RED = 8;                  !  Queue header for CDTs in Load Share Red Queue
macro PDT$Q_DISABLED = 288,0,0,0 %;
literal PDT$S_DISABLED = 8;             !  Queue header for CDTs in Load Share Disabled Queue
macro PDT$L_PORT_MAP = 296,0,32,0 %;    !  32-bit load sharing domain bit map
macro PDT$L_AVAIL_THRUPUT = 300,0,32,1 %; !  Port's available throughput
macro PDT$L_LOAD_RATING = 304,0,32,0 %; !  Port load share rating
macro PDT$L_TIME_STAMP = 308,0,32,0 %;  !  Load sharing port time stamp
!  Load share thresholds
macro PDT$L_SATURATION_PT = 312,0,32,0 %; !  Port saturation point
macro PDT$L_MAX_THRUPUT_THRESHOLD = 316,0,32,0 %; !  Port maximum throughput threshold
macro PDT$L_MIN_THRUPUT_THRESHOLD = 320,0,32,0 %; !  Port minimum throughput threshold
macro PDT$L_TOLERANCE_THRESHOLD = 324,0,32,0 %; !  Port load tolerance threshold
!  Load sharing data transfer counters
macro PDT$L_BYTES_DG_XMT = 328,0,32,0 %; !  Total bytes xmitted by port for DG only
macro PDT$L_BYTES_DG_RCV = 332,0,32,0 %; !  Total bytes rcv'd by port for DG only
macro PDT$L_BYTES_MSG_XMT = 336,0,32,0 %; !  Total bytes xmitted by port for MSG only
macro PDT$L_BYTES_MSG_RCV = 340,0,32,0 %; !  Total bytes rcv'd by port for MSG only
macro PDT$L_BYTES_MAPPED = 344,0,32,0 %; !  Total bytes mapped by port for BT only
macro PDT$L_DG_XMT = 348,0,32,0 %;      !  Total DGs xmitted by port
macro PDT$L_DG_RCV = 352,0,32,0 %;      !  Total DGs rcv'd by port
macro PDT$L_MSG_XMT = 356,0,32,0 %;     !  Total MSGs xmitted by port
macro PDT$L_MSG_RCV = 360,0,32,0 %;     !  Total MSGs rcv'd by port
macro PDT$Q_BYTES_XFER = 364,0,0,0 %;
literal PDT$S_BYTES_XFER = 8;           !  Total bytes xferred by port (both XMIT and RCV)
macro PDT$L_NUM_MAP = 372,0,32,0 %;     !  (TYC0001) # of map operations completed
macro PDT$L_PORT_CMD = 376,0,32,0 %;    !  Total # of port commands placed on
!   queue when the queue is not empty
!   (this is a conditional counter)
macro PDT$L_BYTES_DG_XMT_LAST = 380,0,32,0 %; !  Total bytes xmitted by port for DG only
!   up to last load sharing interval
macro PDT$L_BYTES_DG_RCV_LAST = 384,0,32,0 %; !  Total bytes rcv'd by port for DG only
!   up to last load sharing interval
macro PDT$L_BYTES_MSG_XMT_LAST = 388,0,32,0 %; !  Total bytes xmitted by port for MSG only
!   up to last load sharing interval
macro PDT$L_BYTES_MSG_RCV_LAST = 392,0,32,0 %; !  Total bytes rcv'd by port for MSG only
!   up to last load sharing interval
macro PDT$L_BYTES_MAPPED_LAST = 396,0,32,0 %; !  Total bytes mapped by port for BT only
!   up to last load sharing interval
macro PDT$L_DG_XMT_LAST = 400,0,32,0 %; !  Total DGs xmitted by port
!   up to last load sharing interval
macro PDT$L_DG_RCV_LAST = 404,0,32,0 %; !  Total DGs rcv'd by port
!   up to last load sharing interval
macro PDT$L_MSG_XMT_LAST = 408,0,32,0 %; !  Total MSGs xmitted by port
!   up to last load sharing interval
macro PDT$L_MSG_RCV_LAST = 412,0,32,0 %; !  Total MSGs rcv'd by port
!   up to last load sharing interval
macro PDT$Q_BYTES_XFER_LAST = 416,0,0,0 %;
literal PDT$S_BYTES_XFER_LAST = 8;      !  Total bytes xferred by port 
!   up to last load sharing interval
macro PDT$L_NUM_MAP_LAST = 424,0,32,0 %; !  (TYC0001) # of map operations completed
!   by port up to last load sharing interval
macro PDT$L_PORT_CMD_LAST = 428,0,32,0 %; !  Total # of port commands placed on
!   queue when the queue is not empty
!   up to last load sharing interval
!   (this is a conditional counter)
macro PDT$L_BYTES_XFER_INT = 432,0,32,0 %; !  (TYC 31-AUG-89) TOTAL BYTES XFERRED
!  DURING LAST LOAD SHARING INTERVAL
macro PDT$L_EQUAL_PATH_CALL_COUNT = 436,0,32,0 %; !  Number of equal path move requests made
!   to connections on this port
macro PDT$L_UNEQUAL_PATH_CALL_COUNT = 440,0,32,0 %; !  Number of unequal path move requests made
!   to connections on this port
macro PDT$L_CONNECTION_MOVE_COUNT = 444,0,32,0 %; !  Number of connection moves from this port
! 
!  (TYC 27-Feb-89) peak counters used with conditional assembly
macro PDT$L_BYTES_DG_XMT_PEAK = 448,0,32,0 %; !  Peak value of total bytes xmitted 
!   by port for DG only
macro PDT$L_BYTES_DG_RCV_PEAK = 452,0,32,0 %; !  Peak value of total bytes rcv'd 
!   by port for DG only
macro PDT$L_BYTES_MSG_XMT_PEAK = 456,0,32,0 %; !  Peak value of total bytes xmitted 
!   by port for MSG only
macro PDT$L_BYTES_MSG_RCV_PEAK = 460,0,32,0 %; !  Peak value of total bytes rcv'd 
!   by port for MSG only
macro PDT$L_BYTES_MAPPED_PEAK = 464,0,32,0 %; !  Peak value of total bytes mapped 
!   by port for BT only
macro PDT$L_DG_XMT_PEAK = 468,0,32,0 %; !  Peak value of total DGs xmitted by port
macro PDT$L_DG_RCV_PEAK = 472,0,32,0 %; !  Peak value of total DGs rcv'd by port
macro PDT$L_MSG_XMT_PEAK = 476,0,32,0 %; !  Peak value of total MSGs xmitted by port
macro PDT$L_MSG_RCV_PEAK = 480,0,32,0 %; !  Peak value of total MSGs rcv'd by port
macro PDT$Q_BYTES_XFER_PEAK = 484,0,0,0 %;
literal PDT$S_BYTES_XFER_PEAK = 8;      !  Peak value of total bytes xferred 
!   by port (both XMIT and RCV)
macro PDT$L_PORT_CMD_PEAK = 492,0,32,0 %; !  Peak value of total # of port commands placed on
!   queue when the queue is not empty
! 
!  (TYC 27-Feb-89) average counters used with conditional assembly
macro PDT$L_BYTES_DG_XMT_AVG = 496,0,32,0 %; !  Average value of total bytes xmitted 
!   by port for DG only
macro PDT$L_BYTES_DG_RCV_AVG = 500,0,32,0 %; !  Average value of total bytes rcv'd 
!   by port for DG only
macro PDT$L_BYTES_MSG_XMT_AVG = 504,0,32,0 %; !  Average value of total bytes xmitted 
!   by port for MSG only
macro PDT$L_BYTES_MSG_RCV_AVG = 508,0,32,0 %; !  Average value of total bytes rcv'd 
!   by port for MSG only
macro PDT$L_BYTES_MAPPED_AVG = 512,0,32,0 %; !  Average value of total bytes mapped 
!   by port for BT only
macro PDT$L_DG_XMT_AVG = 516,0,32,0 %;  !  Average value of total DGs xmitted by port
macro PDT$L_DG_RCV_AVG = 520,0,32,0 %;  !  Average value of total DGs rcv'd by port
macro PDT$L_MSG_XMT_AVG = 524,0,32,0 %; !  Average value of total MSGs xmitted by port
macro PDT$L_MSG_RCV_AVG = 528,0,32,0 %; !  Average value of total MSGs rcv'd by port
macro PDT$Q_BYTES_XFER_AVG = 532,0,0,0 %;
literal PDT$S_BYTES_XFER_AVG = 8;       !  Average value of total bytes xferred 
!   by port (both XMIT and RCV)
macro PDT$L_PORT_CMD_AVG = 540,0,32,0 %; !  Average value of total # of port commands placed on
!   queue when the queue is not empty
!  (TYC 22-Jun-89) Moved down here to longword-align
macro PDT$B_LS_FLAG = 544,0,8,0 %;      !  Load share flag, if set, load sharing disabled for now
 
!*** MODULE $PDTLISTDEF ***
! +
!  SCS PDT LIST  (TYC 15-Feb-89)
!  
!  THIS DATA STRUCTURE CONTAINS A VECTOR LISTING UP TO 32 PDT ADDRESSES OF
!  DYNAMIC LOAD SHARING PORTS.  THE INDEX IS MAINTAINED IN THE SCS
!  LOAD SHARING PORT BIT MAP.
! -
literal PDTLIST$C_MAX_INDEX = 32;
literal PDTLIST$K_LENGTH = 140;
literal PDTLIST$C_LENGTH = 140;
literal PDTLIST$S_PDTLISTDEF = 16;
macro PDTLIST$L_FLINK = -12,0,32,0 %;   ! FWD LINK 
macro PDTLIST$L_BLINK = -8,0,32,0 %;    ! BCK LINK 
macro PDTLIST$W_SIZE = -4,0,16,0 %;     ! STRUCTURE SIZE IN BYTES 
macro PDTLIST$B_TYPE = -2,0,8,0 %;      ! SCS STRUCTURE TYPE 
macro PDTLIST$B_SUBTYP = -1,0,8,0 %;    ! SCS STRUCTURE SUBTYPE FOR PDTLIST
macro PDTLIST$L_PDTADDR = 0,0,32,0 %;   ! FIRST PDT ADDRESS
 
!*** MODULE $PEMCOMPDEF ***
literal COMP$C_MAX_NAME_LEN = 110;
literal COMP$C_NODE = 1;
literal COMP$C_ADAPTER = 2;
literal COMP$C_COMPONENT = 3;
literal COMP$C_CLOUD = 4;
literal COMP$C_INVALID = 5;
literal COMP$M_HW_ADDR_VALID = 1;
literal COMP$M_DECNET_ADDR_VALID = 2;
literal COMP$M_PRIMARY_SUSPECT = 4;
literal COMP$M_SECONDARY_SUSPECT = 8;
literal COMP$S_COMPDEF = 60;
macro COMP$A_SUSPECT_FLINK = 0,0,32,0 %;
macro COMP$A_SUSPECT_BLINK = 4,0,32,0 %;
macro COMP$W_SIZE = 8,0,16,0 %;
macro COMP$B_TYPE = 10,0,8,0 %;
macro COMP$B_SUBTYPE = 11,0,8,0 %;
macro COMP$B_NAME_LEN = 12,0,8,0 %;
macro COMP$B_NODENAME_LEN = 13,0,8,0 %;
macro COMP$B_COMP_TYPE = 14,0,8,0 %;
macro COMP$B_FLAGS = 15,0,8,0 %;
macro COMP$V_HW_ADDR_VALID = 15,0,1,0 %;
macro COMP$V_DECNET_ADDR_VALID = 15,1,1,0 %;
macro COMP$V_PRIMARY_SUSPECT = 15,2,1,0 %;
macro COMP$V_SECONDARY_SUSPECT = 15,3,1,0 %;
macro COMP$A_NAME = 16,0,32,0 %;
macro COMP$AB_HW_ADDR = 20,0,0,0 %;
literal COMP$S_HW_ADDR = 6;
macro COMP$AB_DECNET_ADDR = 26,0,0,0 %;
literal COMP$S_DECNET_ADDR = 6;
macro COMP$A_COMP_FLINK = 32,0,32,0 %;
macro COMP$A_COMP_BLINK = 36,0,32,0 %;
macro COMP$L_REFERENCE_COUNT = 40,0,32,0 %;
macro COMP$L_WORKING_COUNT = 44,0,32,0 %;
macro COMP$L_SUSPECT_COUNT = 48,0,32,0 %;
macro COMP$L_PRIME_SUSPECT = 52,0,32,0 %;
macro COMP$L_SECONDARY_SUSPECT = 56,0,32,0 %;
 
!*** MODULE $PEMCLSTDEF ***
literal CLST$S_CLSTDEF = 44;
macro CLST$A_FAILURE_FLINK = 0,0,32,0 %;
macro CLST$A_FAILURE_BLINK = 4,0,32,0 %;
macro CLST$W_SIZE = 8,0,16,0 %;
macro CLST$B_TYPE = 10,0,8,0 %;
macro CLST$B_SUBTYPE = 11,0,8,0 %;
macro CLST$L_COMP_ENTRIES = 12,0,32,0 %;
macro CLST$A_CLST_FLINK = 16,0,32,0 %;
macro CLST$A_CLST_BLINK = 20,0,32,0 %;
macro CLST$A_HW_HASH_LINK = 24,0,32,0 %;
macro CLST$A_DECNET_HASH_LINK = 28,0,32,0 %;
macro CLST$A_LOCAL_ADAPTER = 32,0,32,0 %;
macro CLST$A_REMOTE_ADAPTER = 36,0,32,0 %;
macro CLST$L_REFERENCE_COUNT = 40,0,32,0 %;
macro CLST$AA_COMP_LIST = 44,0,0,0 %;
 
!*** MODULE $PFBDEF ***
! +
!  PAGE FAULT MONITOR BUFFER
! -
literal PFB$B_USER_BUFFER = 12;
literal PFB$B_BUFFER = 20;              ! Beginning of PC/VA pairs
literal PFB$K_LENGTH = 524;             ! Length of PFB 
literal PFB$C_LENGTH = 524;             ! Length of PFB 
literal PFB$S_PFBDEF = 524;
macro PFB$L_FLINK = 0,0,32,0 %;         ! Forward link
macro PFB$L_BLINK = 4,0,32,0 %;         ! Back    link
macro PFB$W_SIZE = 8,0,16,0 %;          ! Structure size
macro PFB$B_TYPE = 10,0,8,0 %;          ! Dynamic structure type (PFB)
macro PFB$R_USER_BUFFER = 12,0,0,0 %;
literal PFB$S_USER_BUFFER = 512;        ! Buffer returned to user
macro PFB$L_RECCNT = 12,0,32,0 %;       ! Record count
macro PFB$L_OVERFLOW = 16,0,32,0 %;     ! Overflow count
 
!*** MODULE $PFLDEF ***
! +
!  PAGE FILE CONTROL BLOCK
! -
! 
!  ***** L_VBN, L_WINDOW, AND B_PFC MUST BE THE SAME OFFSET VALUES AS THE
!  ***** EQUIVALENTLY NAMED OFFSETS IN $SECDEF
! 
literal PFL$K_LENGTH = 52;              ! SIZE OF PAGE FILE CONTROL BLOCK 
literal PFL$C_LENGTH = 52;              ! SIZE OF PAGE FILE CONTROL BLOCK 
literal PFL$M_INITED = 1;
literal PFL$M_PAGFILFUL = 2;
literal PFL$M_SWPFILFUL = 4;
literal PFL$M_DINSPEN = 16;
literal PFL$M_STOPPER = 128;
literal PFL$S_PFLDEF = 56;
macro PFL$L_BITMAP = 0,0,32,0 %;        ! ADDRESS OF START OF BIT MAP 
! BIT = 1 MEANS AVAILABLE
macro PFL$L_STARTBYTE = 4,0,32,0 %;     ! STARTING BYTE OFFSET TO SCAN 
macro PFL$W_SIZE = 8,0,16,0 %;          ! SIZE OF PAGE FILE CONTROL BLOCK 
macro PFL$B_TYPE = 10,0,8,0 %;          ! PAGE FILE CONTROL BLOCK TYPE CODE 
macro PFL$B_PFC = 11,0,8,0 %;           ! PAGE FAULT CLUSTER FOR PAGE READS 
macro PFL$L_WINDOW = 12,0,32,0 %;       ! WINDOW ADDRESS 
macro PFL$L_VBN = 16,0,32,0 %;          ! BASE VBN 
macro PFL$L_BITMAPSIZ = 20,0,32,0 %;    ! SIZE IN BYTES OF PAGE FILE 
macro PFL$L_FREPAGCNT = 24,0,32,0 %;    ! COUNT - 1 OF PAGES WHICH MAY BE ALLOCATED 
macro PFL$L_MINFREPAGCNT = 28,0,32,0 %; !  Minimum free page count
macro PFL$L_RSRVPAGCNT = 32,0,32,0 %;   !  Count of pages which may be reserved
!  without "overcommiting" the pagefile
macro PFL$L_REFCNT = 36,0,32,0 %;       !  No. of processes using this pagefile
macro PFL$L_SWPREFCNT = 40,0,32,0 %;    !  No. of processes using this file for swapping
macro PFL$L_MAXVBN = 44,0,32,0 %;       ! MASK APPLIED TO PTE WITH PAGING FILE 
!  BACKING STORE ADDRESS
macro PFL$B_PGFLX = 48,0,8,0 %;         !  Page file vector index
macro PFL$B_ALLOCSIZ = 50,0,8,0 %;      ! CURRENT ALLOCATION REQUEST SIZE 
macro PFL$B_FLAGS = 51,0,8,0 %;         ! FLAGS BYTE FOR THIS PAGE FILE 
macro PFL$V_INITED = 51,0,1,0 %;        ! THIS PAGE FILE IS USABLE 
macro PFL$V_PAGFILFUL = 51,1,1,0 %;     ! REQUEST FOR PAGING SPACE HAS FAILED 
macro PFL$V_SWPFILFUL = 51,2,1,0 %;     ! REQUEST FOR SWAPPING SPACE HAS FAILED 
macro PFL$V_DINSPEN = 51,4,1,0 %;       !  File deinstall pending
macro PFL$V_STOPPER = 51,7,1,0 %;       ! RESERVED FOR ALL TIME (MUST NEVER BE SET) 
macro PFL$L_BITMAPLOC = 52,0,32,0 %;    ! BITMAP FOLLOWS PFL HEADER 
 
!*** MODULE $PFLMAPDEF ***
! +
!  PAGE FILE MAPPING WINDOW BLOCK
! -
literal PFLMAP$C_MAXPTRS = 61;
literal PFLMAP$K_LENGTH = 508;          ! Size of structure
literal PFLMAP$C_LENGTH = 508;          ! Size of structure
literal PFLMAP$S_PFLMAPDEF = 20;
macro PFLMAP$L_PAGECNT = 0,0,32,0 %;    ! Total pages in all pointers
macro PFLMAP$W_SIZE = 8,0,16,0 %;       ! Size of structure
macro PFLMAP$B_TYPE = 10,0,8,0 %;       ! Structure type (DYN$C_PFLMAP)
macro PFLMAP$B_ACTPTRS = 11,0,8,0 %;    ! No. of active pointers in window
macro PFLMAP$Q_PTR = 12,0,0,0 %;
literal PFLMAP$S_PTR = 8;               ! Beginning of mapping pointers
!  The structure overhead includes an extra mapping pointer not included
!  in the calculation of "MAXPTRS" below. This mapping pointer is for
!  "overflow" and is included to simplify the logic that does the space
!  allocation and structure maintenance.
!  structure OH + ptrs <= 1 page
 
!*** MODULE $PFNDEF ***
! +
!  PFN DATA BASE DEFINITIONS
! -
! 
!  VIELD DEFINITIONS IN PFN$AB_STATE
! 
literal PFN$M_LOC = 7;
literal PFN$M_DELCON = 16;
literal PFN$M_BUFOBJ = 32;
literal PFN$M_MODIFY = 128;
literal PFN$M_PAGTYP = 7;
literal PFN$M_COLLISION = 16;
literal PFN$M_BADPAG = 32;
literal PFN$M_RPTEVT = 64;
literal PFN$M_PGFLVBN = 1048575;
literal PFN$M_PRCPGFLX = 3145728;
literal PFN$M_BAKX = 4194303;
literal PFN$M_BAK0 = 8388607;
literal PFN$M_GBLBAK = 8388608;
literal PFN$M_PGFLX = -16777216;
literal PFN$C_FREPAGLST = 0;            ! ON FREE PAGE LIST 
literal PFN$C_MFYPAGLST = 1;            ! ON MODIFIED PAGE LIST 
literal PFN$C_BADPAGLST = 2;            ! ON BAD PAGE LIST 
literal PFN$C_RELPEND = 3;              ! RELEASE PENDING 
! WHEN REFCNT = 0 RELEASE PFN
literal PFN$C_RDERR = 4;                ! READ ERROR WHILE PAGING IN 
literal PFN$C_WRTINPROG = 5;            ! WRITE IN PROGRESS (BY MFY PAG WRITER) 
literal PFN$C_RDINPROG = 6;             ! READ IN PROGRESS (PAGE IN) 
literal PFN$C_ACTIVE = 7;               ! PAGE IS ACTIVE AND VALID 
! 
literal PFN$C_PROCESS = 0;              ! PROCESS PAGE 
literal PFN$C_SYSTEM = 1;               ! SYSTEM PAGE 
literal PFN$C_GLOBAL = 2;               ! GLOBAL PAGE (READ ONLY) 
literal PFN$C_GBLWRT = 3;               ! GLOBAL WRITABLE PAGE 
literal PFN$C_PPGTBL = 4;               ! PROCESS PAGE TABLE 
literal PFN$C_GPGTBL = 5;               ! GLOBAL PAGE TABLE 
literal PFN$S_PFNDEF = 4;
macro PFN$V_LOC = 0,0,3,0 %;
literal PFN$S_LOC = 3;                  ! LOCATION OF PAGE 
! 
!  ***** THE FOLLOWING SPARE BIT MUST BE USED FOR EXTENSION OF THE LOC FIELD
!  ***** OR ALTERNATIVELY THE DELCON BIT MUST BE MOVED ADJACENT TO LOC
! 
macro PFN$V_DELCON = 0,4,1,0 %;         ! DELETE PFN CONTENTS WHEN REF=0 
macro PFN$V_BUFOBJ = 0,5,1,0 %;         ! Set if any buffer objects reference this PFN
! NB: Implies SWPVBN used as reference count
macro PFN$V_MODIFY = 0,7,1,0 %;         ! MODIFY BIT 
! 
!  VIELD DEFINITIONS IN PFN$AB_TYPE
! 
macro PFN$V_PAGTYP = 0,0,3,0 %;
literal PFN$S_PAGTYP = 3;               ! PAGE TYPE 
macro PFN$V_COLLISION = 0,4,1,0 %;      ! EMPTY COLLISION QUEUE WHEN PAGE READ COMPLETE 
macro PFN$V_BADPAG = 0,5,1,0 %;         ! BAD PAGE BIT 
macro PFN$V_RPTEVT = 0,6,1,0 %;         ! REPORT EVENT ON I/O COMPLETE 
! 
!  VIELD DEFINITIONS IN PFN$AL_BAK
! 
macro PFN$R_BAK_OVERLAY = 0,0,24,0 %;
macro PFN$R_BAK_PGFL = 0,0,24,0 %;
literal PFN$S_BAK_PGFL = 3;
macro PFN$V_PGFLVBN = 0,0,20,0 %;
literal PFN$S_PGFLVBN = 20;             !  Page file VBN
macro PFN$V_PRCPGFLX = 0,20,2,0 %;
literal PFN$S_PRCPGFLX = 2;             !  PROCESS page file index
macro PFN$V_BAKX = 0,0,22,0 %;
literal PFN$S_BAKX = 22;                ! BACKUP ADDRESS (uninterpreted)
macro PFN$V_BAK0 = 0,0,23,0 %;
literal PFN$S_BAK0 = 23;                ! BACKUP ADDRESS (w/TYP0)
macro PFN$R_GBLBAK_OVERLAY = 0,0,24,0 %;
macro PFN$V_GBLBAK = 0,23,1,0 %;        ! GLOBAL BACKING STORE ADDRESS 
macro PFN$V_PGFLX = 0,24,8,0 %;
literal PFN$S_PGFLX = 8;                !  SYSTEM page file index 
! 
!  LOCATION VIELD VALUES
! 
!  PAGE TYPE VIELD DEFINITIONS
! 
 
!*** MODULE $PHDDEF ***
! +
!  A PROCESS HEADER CONTAINS THE SWAPPABLE SCHEDULER AND
!  MEMORY MANAGEMENT DATA BASES FOR A PROCESS IN THE
!  BALANCE SET.
! 
!  When adding cells to this structure, insure that the
!  location PHD$L_PCB (the beginning of the HW PCB) remains
!  hexaword aligned and that the HW PCB does not cross a
!  virtual page boundary.
! -
literal PHD$C_HWPCBLEN = 100;           ! HW PCB LENGTH
literal PHD$K_HWPCBLEN = 100;           ! HW PCB LENGTH
! 
literal PHD$M_PFMFLG = 1;
literal PHD$M_DALCSTX = 2;
literal PHD$M_WSPEAKCHK = 4;
literal PHD$M_NOACCVIO = 8;
literal PHD$M_IWSPEAKCK = 16;
literal PHD$M_IMGDMP = 32;
literal PHD$M_NO_WS_CHNG = 64;
literal PHD$M_PGFLACC = 128;
literal PHD$M_VP_CONSUMER = 256;
literal PHD$M_VP_DISABLED = 512;
literal PHD$C_PHDPAGCTX = 8;            !  SIZE OF CONTEXT FOR PHD PAGES 
literal PHD$K_LENGTH = 404;             ! LENGTH OF FIXED PART OF PROCESS HEADER 
literal PHD$C_LENGTH = 404;             ! LENGTH OF FIXED PART OF PROCESS HEADER 
literal PHD$S_PHDDEF = 408;
macro PHD$Q_PRIVMSK = 0,0,0,0 %;
literal PHD$S_PRIVMSK = 8;              ! PRIVILEGE MASK 
macro PHD$W_SIZE = 8,0,16,0 %;          ! Structure size
macro PHD$B_TYPE = 10,0,8,0 %;          ! Dynamic structure type (PFB)
! 
!  WORKING SET LIST POINTERS - THESE CONTAIN LONG WORD OFFSETS FROM THE
!  BEGINNING OF THE PROCESS HEADER.
! 
macro PHD$L_WSLIST = 12,0,32,0 %;       ! 1ST WORKING SET LIST ENTRY 
macro PHD$L_WSLOCK = 16,0,32,0 %;       ! 1ST LOCKED WORKING SET LIST ENTRY 
macro PHD$L_WSDYN = 20,0,32,0 %;        ! 1ST DYNAMIC WORKING SET LIST ENTRY 
macro PHD$L_WSNEXT = 24,0,32,0 %;       ! LAST WSL ENTRY REPLACED 
macro PHD$L_WSLAST = 28,0,32,0 %;       ! LAST WSL ENTRY IN LIST 
! 
!  HARDWARE PCB PORTION OF PROCESS HEADER - Must remain hexaword aligned and must
! 	not be allowed to cross a virtual page boundary.
! 
macro PHD$L_PCB = 32,0,32,0 %;          ! HARDWARE PCB 
macro PHD$L_KSP = 32,0,32,0 %;          ! KERNEL STACK POINTER 
macro PHD$L_ESP = 36,0,32,0 %;          ! EXEC STACK POINTER 
macro PHD$L_SSP = 40,0,32,0 %;          ! SUPERVISOR STACK POINTER 
macro PHD$L_USP = 44,0,32,0 %;          ! USER STACK POINTER 
macro PHD$L_R0 = 48,0,32,0 %;           ! R0 
macro PHD$L_R1 = 52,0,32,0 %;           ! R1 
macro PHD$L_R2 = 56,0,32,0 %;           ! R2 
macro PHD$L_R3 = 60,0,32,0 %;           ! R3 
macro PHD$L_R4 = 64,0,32,0 %;           ! R4 
macro PHD$L_R5 = 68,0,32,0 %;           ! R5 
macro PHD$L_R6 = 72,0,32,0 %;           ! R6 
macro PHD$L_R7 = 76,0,32,0 %;           ! R7 
macro PHD$L_R8 = 80,0,32,0 %;           ! R8 
macro PHD$L_R9 = 84,0,32,0 %;           ! R9 
macro PHD$L_R10 = 88,0,32,0 %;          ! R10 
macro PHD$L_R11 = 92,0,32,0 %;          ! R11 
macro PHD$L_R12 = 96,0,32,0 %;          ! R12 
macro PHD$L_R13 = 100,0,32,0 %;         ! R13 
macro PHD$L_PC = 104,0,32,0 %;          ! PC 
macro PHD$L_PSL = 108,0,32,0 %;         ! PROGRAM STATUS LONGWORD 
macro PHD$L_P0BR = 112,0,32,0 %;        ! P0 BASE REGISTER 
macro PHD$L_P0LRASTL = 116,0,32,0 %;    ! P0LR, ASTLVL 
macro PHD$V_P0LR = 116,0,24,0 %;
literal PHD$S_P0LR = 24;                ! P0 LENGTH REGISTER 
macro PHD$V_ASTLVL = 116,24,8,0 %;
literal PHD$S_ASTLVL = 8;               !  AST LEVEL 
macro PHD$B_ASTLVL = 119,0,8,0 %;       ! AST LEVEL SUBFIELD 
macro PHD$L_P1BR = 120,0,32,0 %;        ! P1 BASE REGISTER 
macro PHD$L_P1LR = 124,0,32,0 %;        ! P1 LENGTH REGISTER 
macro PHD$L_ASNPRVCPU = 128,0,32,0 %;   ! ASN, PRVCPU
macro PHD$V_PRVCPU = 128,0,8,0 %;
literal PHD$S_PRVCPU = 8;               ! PREVIOUS CPU
macro PHD$V_ASN = 128,8,24,0 %;
literal PHD$S_ASN = 24;                 ! ADDRESS SPACE NUMBER
macro PHD$B_PRVCPU = 128,0,8,0 %;       ! PREVIOUS CPU
!  End of HW PCB portion of process header
! 
! 
!  THE FOLLOWING THREE LONGWORDS SPECIFY THE MAXIMUM AND INITIAL WORKING SET
!  SIZES FOR THE PROCESS.  RATHER THAN CONTAINING THE COUNT OF PAGES
!  THEY CONTAIN THE LONG WORD INDEX TO WHAT WOULD BE THE LAST WORKING
!  SET LIST ENTRY.
! 
macro PHD$L_WSEXTENT = 132,0,32,0 %;    ! MAX WORKING SET SIZE AGAINST BORROWING 
macro PHD$L_WSQUOTA = 136,0,32,0 %;     ! QUOTA ON WORKING SET SIZE 
macro PHD$L_DFWSCNT = 140,0,32,0 %;     ! DEFAULT WORKING SET SIZE 
macro PHD$L_PAGFIL = 144,0,32,0 %;      !  Template to assign page file backing store
macro PHD$B_PAGFIL = 147,0,8,0 %;       !  Current SYSTEM page file index
! 
!  PROCESS SECTION TABLE DATA BASE
!         PSTBASOFF IS THE BYTE OFFSET (INTEGRAL ! OF PAGES) FROM THE
!  BEGINNING OF THE PROCESS HEADER TO THE 1ST LONG WORD BEYOND THE
!  PROCESS SECTION TABLE.
!         THE WORDS, PSTLAST AND PSTFREE ARE SECTION TABLE INDICES WHICH
!  ARE THE NEGATIVE LONG WORD INDEX FROM THE END OF THE SECTION TABLE TO
!  THE SECTION TABLE ENTRY.
! 
macro PHD$L_PSTBASOFF = 148,0,32,0 %;   ! BYTE OFFSET TO BASE OF PST 
! FIRST LONG WORD NOT IN PST
! PST GROWS BACKWARDS FROM HERE
macro PHD$W_PSTLAST = 152,0,16,0 %;     ! END OF PROCESS SECTION TABLE 
! ADR OF LAST PSTE ALLOCATED
macro PHD$W_PSTFREE = 154,0,16,0 %;     ! HEAD OF FREE PSTE LIST 
! 
!  CREATE/DELETE PAGE CONTEXT
! 
macro PHD$L_FREP0VA = 156,0,32,0 %;     ! 1ST FREE VIRTUAL ADR AT END OF P0 SPACE 
! ***** MUST BE QUAD WORD AWAY FROM FREP1VA
macro PHD$L_FREPTECNT = 160,0,32,0 %;   ! CNT OF FREE PTE'S BETWEEN THE ENDS 
! 0F THE P0 AND P1 PAGE TABLES
macro PHD$L_FREP1VA = 164,0,32,0 %;     ! 1ST FREE VIRTUAL ADR AT END OF P1 SPACE 
macro PHD$B_DFPFC = 168,0,8,0 %;        ! DEFAULT PAGE FAULT CLUSTER 
macro PHD$B_PGTBPFC = 169,0,8,0 %;      ! PAGE TABLE CLUSTER FACTOR 
macro PHD$W_FLAGS = 170,0,16,0 %;       ! FLAGS WORD 
macro PHD$V_PFMFLG = 170,0,1,0 %;       ! PAGE FAULT MONITORING ENABLED 
macro PHD$V_DALCSTX = 170,1,1,0 %;      ! NEED TO DEALLOCATE SECTION INDICES 
macro PHD$V_WSPEAKCHK = 170,2,1,0 %;    ! CHECK FOR NEW WORKING SET SIZE (PROC) 
macro PHD$V_NOACCVIO = 170,3,1,0 %;     ! SET AFTER INSWAP OF PROCESS HEADER 
macro PHD$V_IWSPEAKCK = 170,4,1,0 %;    ! CHECK FOR NEW WORKING SET SIZE (IMAGE) 
macro PHD$V_IMGDMP = 170,5,1,0 %;       ! TAKE IMAGE DUMP ON ERROR EXIT
macro PHD$V_NO_WS_CHNG = 170,6,1,0 %;   ! NO CHANGE TO WORKING SET OR SWAPPING
!  TRANSIENT USE BY MMG CODE ONLY
macro PHD$V_PGFLACC = 170,7,1,0 %;      !  Page file reservation
!  accounting enabled
macro PHD$V_VP_CONSUMER = 170,8,1,0 %;  !  Current process is a vector consumer
macro PHD$V_VP_DISABLED = 170,9,1,0 %;  !  Use of VP disabled
! 
!  QUOTAS AND LIMITS
! 
macro PHD$L_CPUTIM = 172,0,32,0 %;      ! ACCUMULATED CPU TIME CHARGED 
macro PHD$W_QUANT = 176,0,16,0 %;       ! ACCUMULATED CPU TIME SINCE 
! LAST QUANTUM OVERFLOW
macro PHD$W_PRCLM = 178,0,16,0 %;       ! SUBPROCESS QUOTA 
macro PHD$W_ASTLM = 180,0,16,0 %;       ! AST LIMIT 
macro PHD$W_PHVINDEX = 182,0,16,0 %;    ! PROCESS HEADER VECTOR INDEX 
macro PHD$L_BAK = 184,0,32,0 %;         ! POINTER TO BACKUP ADDRESS VECTOR FOR 
! PROCESS HEADER PAGES
macro PHD$L_WSLX = 188,0,32,0 %;        ! POINTER TO WORKING SET LIST INDEX 
! SAVE AREA
macro PHD$L_PSTBASMAX = 188,0,32,0 %;   ! LW OFFSET TO TOP PST ADDRESS 
macro PHD$L_PAGEFLTS = 192,0,32,0 %;    ! COUNT OF PAGE FAULTS 
macro PHD$L_WSSIZE = 196,0,32,0 %;      ! CURRENT ALLOWED WORKING SET SIZE 
macro PHD$W_UCPUTIM = 200,0,16,0 %;     !  # clock tics left to reach 10 ms
! 
!  THE NEXT TWO I/O COUNTERS MUST BE ADJACENT
! 
macro PHD$L_DIOCNT = 204,0,32,0 %;      ! DIRECT I/O COUNT 
macro PHD$L_BIOCNT = 208,0,32,0 %;      ! BUFFERED I/O COUNT 
macro PHD$L_CPULIM = 212,0,32,0 %;      ! LIMIT ON CPU TIME FOR PROCESS 
macro PHD$B_CPUMODE = 216,0,8,0 %;      ! ACCESS MODE TO NOTIFY ABOUT CPUTIME 
macro PHD$B_AWSMODE = 217,0,8,0 %;      ! ACCESS MODE FLAG FOR AUTO WS AST 
macro PHD$B_PRCPAGFIL = 218,0,8,0 %;    !  Current PROCESS page file index
macro PHD$B_PGFLCNT = 219,0,8,0 %;      !  No. of assigned page files
! 
!  PAGE TABLE STATISTICS
! 
macro PHD$L_PTWSLELCK = 220,0,32,0 %;   !  BYTE OFFSET TO BYTE ARRAY OF COUNTS 
!  OF LOCKED WSLE'S IN THIS PAGE TABLE
macro PHD$L_PTWSLEVAL = 224,0,32,0 %;   !  BYTE OFFSET TO BYTE ARRAY OF COUNTS 
!  OF VALID WSLE'S IN THIS PAGE TABLE
macro PHD$W_PTCNTLCK = 228,0,16,0 %;    !  COUNT OF PAGE TABLES CONTAINING 
!  1 OR MORE LOCKED WSLE
macro PHD$W_PTCNTVAL = 230,0,16,0 %;    !  COUNT OF PAGE TABLES CONTAINING 
!  1 OR MORE VALID WSLE
macro PHD$W_PTCNTACT = 232,0,16,0 %;    !  COUNT OF ACTIVE PAGE TABLES 
macro PHD$W_PTCNTMAX = 234,0,16,0 %;    !  MAX COUNT OF PAGE TABLES 
!  WHICH HAVE NON-ZERO PTE'S
macro PHD$L_WSFLUID = 236,0,32,0 %;     !  GUARANTEED NUMBER OF FLUID WS PAGES 
macro PHD$W_EMPTPG = 240,0,16,0 %;      !  COUNT OF EMPTY WORKING SET PAGES 
macro PHD$L_EXTDYNWS = 244,0,32,0 %;    !  EXTRA DYNAMIC WORKING SET LIST ENTRIES 
!  ABOVE REQUIRED WSFLUID MINIMUM
macro PHD$W_PRCPGFLPAGES = 248,0,16,0 %; !  Remaining number of reserved pages in
!  the current process page file
macro PHD$W_PRCPGFLOPAGES = 250,0,16,0 %; !  Original number of reserved pages in
!  the current process page file
macro PHD$B_PRCPGFL = 252,0,32,0 %;
literal PHD$S_PRCPGFL = 4;              !  Current SYSTEM page file assignments
macro PHD$L_WSAUTH = 256,0,32,0 %;      ! AUTHORIZED WORKING SET SIZE 
macro PHD$L_WSAUTHEXT = 260,0,32,0 %;   ! AUTHORIZED WS EXTENT 
macro PHD$Q_AUTHPRIV = 264,0,0,0 %;
literal PHD$S_AUTHPRIV = 8;             ! AUTHORIZED PRIVILEGES MASK 
macro PHD$Q_IMAGPRIV = 272,0,0,0 %;
literal PHD$S_IMAGPRIV = 8;             ! INSTALLED IMAGE PRIVILEGES MASK 
macro PHD$L_RESLSTH = 280,0,32,0 %;     ! POINTER TO RESOURCE LIST 
macro PHD$L_IMGCNT = 284,0,32,0 %;      ! IMAGE COUNTER BUMPED BY SYSRUNDWN 
macro PHD$L_PFLTRATE = 288,0,32,0 %;    ! PAGE FAULT RATE 
macro PHD$L_PFLREF = 292,0,32,0 %;      ! PAGE FAULTS AT END OF LAST INTERVAL 
macro PHD$L_TIMREF = 296,0,32,0 %;      ! TIME AT END OF LAST INTERVAL 
macro PHD$L_PGFLTIO = 300,0,32,0 %;     ! COUNT OF PAGEFAULT I/O 
macro PHD$B_AUTHPRI = 304,0,8,0 %;      ! INITIAL PROCESS PRIORITY 
macro PHD$L_EXTRACPU = 308,0,32,0 %;    ! ACCUMULATED CPU TIME LIMIT EXTENSION 
macro PHD$R_MIN_CLASS = 312,0,0,0 %;
literal PHD$S_MIN_CLASS = 20;           !  MINIMUM AUTHORIZED SECURITY CLEARANCE
macro PHD$R_MAX_CLASS = 332,0,0,0 %;
literal PHD$S_MAX_CLASS = 20;           !  MAXIMUM AUTHORIZED SECURITY CLEARANCE
macro PHD$L_PRCPGFLREFS = 352,0,0,0 %;
literal PHD$S_PRCPGFLREFS = 16;         !  # pages currently being used 
!  in each process page file
macro PHD$L_PPGFLVA = 368,0,32,0 %;     !  "Quota" of available pages which may
!  have page file backing store
! 
macro PHD$Q_PSCANCTX_QUEUE = 372,0,0,0 %;
literal PHD$S_PSCANCTX_QUEUE = 8;       !  Queue of PSCAN blocks
macro PHD$l_spare_L1 = 380,0,32,0 %;    !  available
macro PHD$l_spare_L2 = 384,0,32,0 %;    !  available
macro PHD$W_PSCANCTX_SEQNUM = 388,0,16,0 %; !  PSCAN sequence number
macro PHD$w_spare_W2 = 390,0,16,0 %;    !  available
! 
macro PHD$L_UCPUTIM = 392,0,32,0 %;     !  absolute micro-clock tics
macro PHD$L_NS_SPARE = 396,0,32,0 %;    ! SPARE for Vector 
macro PHD$L_VP_CPUTIM = 396,0,32,0 %;   ! Vector Processing CPU time 
! 
!  SPARE EXPANSION PORTION OF PROCESS HEADER
! 
! 
!  END OF FIXED PORTION OF PROCESS HEADER
! 
macro PHD$L_WSL = 404,0,32,0 %;         ! FIRST WORKING SET LIST ENTRY 
 
!*** MODULE $PIBDEF ***
! +
!  PERFORMANCE I/O INFORMATION BLOCK
! -
literal PIB$S_PIBDEF = 1;
macro PIB$B_TYPE = 0,0,8,0 %;           ! TYPE OF ENTRY 
! 
!  START OF I/O REQUEST TRANSACTION MESSAGE BLOCK
! 
literal PIB$K_SRQ_SIZE = 32;            ! LENGTH OF START I/O MESSAGE 
literal PIB$C_SRQ_SIZE = 32;            ! LENGTH OF START I/O MESSAGE 
! 
literal PIB$S_PIBDEF1 = 32;
macro PIB$B_SRQ_PRI = 1,0,8,0 %;        ! BASE PRIORITY OF PROCESS 
macro PIB$W_SRQ_ACON = 2,0,16,0 %;      ! Access control info from WCB or 0
macro PIB$Q_SRQ_TIME = 4,0,0,0 %;
literal PIB$S_SRQ_TIME = 8;             ! TIME OF I/O TRANSACTION 
macro PIB$L_SRQ_SEQN = 12,0,32,0 %;     ! SEQUENCE NUMBER OF I/O TRANSACTION 
macro PIB$L_SRQ_PID = 16,0,32,0 %;      ! REQUESTER PID 
macro PIB$L_SRQ_UCB = 20,0,32,0 %;      ! ADDRESS OF DEVICE UCB 
macro PIB$W_SRQ_FUNC = 24,0,16,0 %;     ! I/O FUNCTION CODE 
macro PIB$W_SRQ_STS = 26,0,16,0 %;      ! I/O PACKET STATUS 
macro PIB$B_SRQ_ACCESS = 28,0,8,0 %;    ! Access control info from WCB or 0
!  START OF I/O TRANSACTION MESSAGE BLOCK
! 
literal PIB$K_SIO_SIZE = 24;            ! LENGTH OF I/O TRANSACTION MESSAGE 
literal PIB$C_SIO_SIZE = 24;            ! LENGTH OF I/O TRANSACTION MESSAGE 
! 
literal PIB$S_PIBDEF2 = 24;
macro PIB$Q_SIO_TIME = 4,0,0,0 %;
literal PIB$S_SIO_TIME = 8;             ! TIME OF TRANSACTION 
macro PIB$L_SIO_SEQN = 12,0,32,0 %;     ! SEQUENCE NUMBER OF TRANSACTION 
macro PIB$L_SIO_MEDIA = 16,0,32,0 %;    ! TRANSFER MEDIA ADDRESS 
macro PIB$L_SIO_BCNT = 20,0,32,0 %;     ! TRANSFER BYTE COUNT 
!  END OF I/O TRANSACTION MESSAGE BLOCK
! 
literal PIB$K_EIO_SIZE = 24;            ! LENGTH OF END OF I/O TRANSACTION 
literal PIB$C_EIO_SIZE = 24;            ! LENGTH OF END OF I/O TRANSACTION 
! 
literal PIB$S_PIBDEF3 = 24;
macro PIB$Q_EIO_TIME = 4,0,0,0 %;
literal PIB$S_EIO_TIME = 8;             ! TIME OF TRANSACTION 
macro PIB$L_EIO_SEQN = 12,0,32,0 %;     ! SEQUENCE NUMBER OF TRANSACTION 
macro PIB$Q_EIO_IOSB = 16,0,0,0 %;
literal PIB$S_EIO_IOSB = 8;             ! FINAL I/O STATUS 
!  END OF I/O REQUEST MESSAGE BLOCK
! 
literal PIB$K_ERQ_SIZE = 16;            ! LENGTH OF END OF I/O REQUEST TRANSACTION 
literal PIB$C_ERQ_SIZE = 16;            ! LENGTH OF END OF I/O REQUEST TRANSACTION 
! 
literal PIB$K_SRQ = 0;                  ! START OF I/O REQUEST 
literal PIB$K_SIO = 1;                  ! START OF I/O TRANSACTION 
literal PIB$K_EIO = 2;                  ! END OF I/O TRANSACTION 
literal PIB$K_ERQ = 3;                  ! END OF I/O REQUEST 
literal PIB$K_ARQ = 4;                  ! ABORTED I/O REQUEST 
literal PIB$S_PIBDEF4 = 16;
macro PIB$Q_ERQ_TIME = 4,0,0,0 %;
literal PIB$S_ERQ_TIME = 8;             ! TIME OF TRANSACTION 
macro PIB$L_ERQ_SEQN = 12,0,32,0 %;     ! SEQUENCE NUMBER OF TRANSACTION 
!  I/O MESSAGE BLOCK ENTRY TYPE CODES
! 
literal PIB$K_ARQ_SIZE = 16;            ! LENGTH OF ABORTED I/O TRANSACTION
literal PIB$C_ARQ_SIZE = 16;            ! LENGTH OF ABORTED I/O TRANSACTION 
! 
literal PIB$S_PIBDEF5 = 16;
macro PIB$Q_ARQ_TIME = 4,0,0,0 %;
literal PIB$S_ARQ_TIME = 8;             ! TIME OF TRANSACTION 
macro PIB$L_ARQ_SEQN = 12,0,32,0 %;     ! SEQUENCE NUMBER OF TRANSACTION 
!  ABORTED I/O REQUEST MESSAGE BLOCK
! 
 
!*** MODULE $PLVECDEF ***
! +
!  PLVEC - SCS PORT LOAD VECTOR
! 
!  THIS DATA STRUCTURE CONTAINS A VECTOR LISTING THE ACTIVE CONNECTIONS BY
!  TYPE ON A PORT.  THE INDEX IS CONTAINED IN THE SBNB (SCS LOAD SHARE
!  NAME BLOCK and in the CDT$L_
!  
! -
literal PLVEC$C_MAX_INDEX = 10;
literal PLVEC$K_LENGTH = 60;            !  (TYC 15-Feb-89)
literal PLVEC$C_LENGTH = 60;
literal PLVEC$S_PLVECDEF = 16;
macro PLVEC$L_FLINK = -12,0,32,0 %;     ! FWD LINK 
macro PLVEC$L_BLINK = -8,0,32,0 %;      ! BCK LINK 
macro PLVEC$W_SIZE = -4,0,16,0 %;       ! STRUCTURE SIZE IN BYTES 
macro PLVEC$B_TYPE = -2,0,8,0 %;        ! SCS STRUCTURE TYPE 
macro PLVEC$B_SUBTYP = -1,0,8,0 %;      ! SCS STRUCTURE SUBTYPE FOR PLVEC
macro PLVEC$L_TOT_CONNECT = 0,0,32,0 %; ! TOTAL NUMBER OF CONNECTIONS ON
!  THIS PORT
 
!*** MODULE $PMBDEF ***
! +
!  PAGE FAULT MONITOR CONTROL BLOCK
! -
literal PMB$M_MODE = 1;
literal PMB$K_SUBPROC = 0;              ! Subprocess mode
literal PMB$K_IMAGE = 1;                ! Image mode
literal PMB$M_ASTIP = 2;
literal PMB$M_QAST = 4;
literal PMB$K_LENGTH = 64;              ! Length of PMB 
literal PMB$C_LENGTH = 64;              ! Length of PMB 
literal PMB$S_PMBDEF = 64;
macro PMB$L_CURBUF = 0,0,32,0 %;        ! Current buffer pointer 
macro PMB$L_BUFBASE = 4,0,32,0 %;       ! Current buffer base address
macro PMB$W_SIZE = 8,0,16,0 %;          ! Block size field 
macro PMB$B_TYPE = 10,0,8,0 %;          ! Dynamic structure type (PMB)
macro PMB$B_FLAGS = 11,0,8,0 %;         ! Processing flags
macro PMB$V_MODE = 11,0,1,0 %;          ! Mode of operation
macro PMB$V_ASTIP = 11,1,1,0 %;         ! AST in progress flag
macro PMB$V_QAST = 11,2,1,0 %;          ! Imbedded ACB is enqueued on the PCB
macro PMB$L_LASTCPU = 12,0,32,0 %;      ! Last recorded CPU time
macro PMB$L_OVERFLOW = 16,0,32,0 %;     ! Buffer overflow counter (both modes)
macro PMB$Q_HDR = 20,0,0,0 %;
literal PMB$S_HDR = 8;                  ! Free   buffer queue header 
macro PMB$Q_SBPHDR = 28,0,0,0 %;
literal PMB$S_SBPHDR = 8;               ! Filled buffer queue header 
macro PMB$L_ASTQFL = 36,0,32,0 %;       ! ACB flink
macro PMB$L_ASTQBL = 40,0,32,0 %;       ! ACB blink
macro PMB$B_ACMODE = 46,0,8,0 %;        ! Owner access mode
macro PMB$B_RMOD = 47,0,8,0 %;          ! AST delivery mode/flags
macro PMB$L_PID = 48,0,32,0 %;          ! PID for AST delivery
macro PMB$L_AST = 52,0,32,0 %;          ! AST routine address
macro PMB$L_ASTPRM = 56,0,32,0 %;       ! AST parameter
macro PMB$L_KAST = 60,0,32,0 %;         ! Address of piggy-back kernel AST routine
macro PMB$W_MBXCHN = 44,0,16,0 %;       ! Subprocess mailbox channel 
macro PMB$B_OACMODE = 46,0,8,0 %;       ! Owner access mode (Synonym for ACMODE)
macro PMB$L_IPID = 48,0,32,0 %;         ! IPID of subprocess (Synonym for PID)
macro PMB$L_EPID = 52,0,32,0 %;         ! EPID of subprocess
 
!*** MODULE $PQBDEF ***
! +
!  PROCESS QUOTA BLOCK DEFINITION
! -
literal PQB$M_IMGDMP = 1;
literal PQB$M_DEBUG = 2;
literal PQB$M_DBGTRU = 4;
literal PQB$K_LENGTH = 2256;            !  LENGTH OF PROCESS QUOTA BLOCK 
literal PQB$C_LENGTH = 2256;            !  LENGTH OF PROCESS QUOTA BLOCK 
literal PQB$S_PQBDEF = 2256;
macro PQB$Q_PRVMSK = 0,0,0,0 %;
literal PQB$S_PRVMSK = 8;               !  PRIVILEGE MASK 
macro PQB$W_SIZE = 8,0,16,0 %;          !  SIZE OF PQB IN BYTES 
macro PQB$B_TYPE = 10,0,8,0 %;          !  STRUCTURE TYPE CODE 
macro PQB$B_STS = 11,0,8,0 %;           !  STATUS FLAGS 
macro PQB$L_ASTLM = 12,0,32,0 %;        !  AST LIMIT 
macro PQB$L_BIOLM = 16,0,32,0 %;        !  BUFFERED I/O LIMIT 
macro PQB$L_BYTLM = 20,0,32,0 %;        !  BUFFERED I/O LIMIT 
macro PQB$L_CPULM = 24,0,32,0 %;        !  CPU TIME LIMIT 
macro PQB$L_DIOLM = 28,0,32,0 %;        !  DIRECT I/O LIMIT 
macro PQB$L_FILLM = 32,0,32,0 %;        !  OPEN FILE LIMIT 
macro PQB$L_PGFLQUOTA = 36,0,32,0 %;    !  PAGING FILE QUOTA 
macro PQB$L_PRCLM = 40,0,32,0 %;        !  SUB-PROCESS LIMIT 
macro PQB$L_TQELM = 44,0,32,0 %;        !  TIMER QUEUE ENTRY LIMIT 
macro PQB$L_WSQUOTA = 48,0,32,0 %;      !  WORKING SET QUOTA 
macro PQB$L_WSDEFAULT = 52,0,32,0 %;    !  WORKING SET DEFAULT 
macro PQB$L_ENQLM = 56,0,32,0 %;        !  ENQUEUE LIMIT 
macro PQB$L_WSEXTENT = 60,0,32,0 %;     !  MAXIMUM WORKING SET SIZE 
macro PQB$L_JTQUOTA = 64,0,32,0 %;      !  JOB-WIDE LOGICAL NAME TABLE CREATION QUOTA
macro PQB$W_FLAGS = 68,0,16,0 %;        !  MISC FLAGS
macro PQB$V_IMGDMP = 68,0,1,0 %;        !  TAKE IMAGE DUMP ON SERIOUS ERROR
macro PQB$V_DEBUG = 68,1,1,0 %;         !  /DEBUG startup desired
macro PQB$V_DBGTRU = 68,2,1,0 %;        !  debugger present
macro PQB$B_MSGMASK = 70,0,8,0 %;       !  MESSAGE FLAGS 
macro PQB$B_FILL_1 = 71,0,8,0 %;        !  Spare
macro PQB$L_UAF_FLAGS = 72,0,32,0 %;    !  FLAGS FROM UAF RECORD
macro PQB$L_CREPRC_FLAGS = 76,0,32,0 %; !  FLAGS FROM $CREPRC ARGUMENT LIST
macro PQB$R_MIN_CLASS = 80,0,0,0 %;
literal PQB$S_MIN_CLASS = 20;           !  MINIMUM AUTHORIZED SECURITY CLEARANCE
macro PQB$R_MAX_CLASS = 100,0,0,0 %;
literal PQB$S_MAX_CLASS = 20;           !  MAXIMUM AUTHORIZED SECURITY CLEARANCE
macro PQB$L_INPUT_ATT = 120,0,32,0 %;   !   SYS$INPUT attributes
macro PQB$L_OUTPUT_ATT = 124,0,32,0 %;  !   SYS$OUTPUT attributes
macro PQB$L_ERROR_ATT = 128,0,32,0 %;   !   SYS$ERROR attributes
macro PQB$L_DISK_ATT = 132,0,32,0 %;    !   SYS$DISK attributes
macro PQB$T_CLI_NAME = 136,0,0,0 %;
literal PQB$S_CLI_NAME = 32;            !  CLI name
macro PQB$T_CLI_TABLE = 168,0,0,0 %;
literal PQB$S_CLI_TABLE = 256;          !  CLI table name
macro PQB$T_SPAWN_CLI = 424,0,0,0 %;
literal PQB$S_SPAWN_CLI = 32;           !  Spawn CLI name
macro PQB$T_SPAWN_TABLE = 456,0,0,0 %;
literal PQB$S_SPAWN_TABLE = 256;        !  Spawn CLI table name
macro PQB$T_INPUT = 712,0,0,0 %;
literal PQB$S_INPUT = 256;              !  LOGICAL NAME FOR INPUT 
macro PQB$T_OUTPUT = 968,0,0,0 %;
literal PQB$S_OUTPUT = 256;             !  LOGICAL NAME FOR OUTPUT 
macro PQB$T_ERROR = 1224,0,0,0 %;
literal PQB$S_ERROR = 256;              !  LOGICAL NAME FOR ERROR OUTPUT 
macro PQB$T_DISK = 1480,0,0,0 %;
literal PQB$S_DISK = 256;               !  LOGICAL NAME FOR SYS$DISK 
macro PQB$T_DDSTRING = 1736,0,0,0 %;
literal PQB$S_DDSTRING = 256;           !  DEFAULT DIRECTORY STRING 
macro PQB$T_IMAGE = 1992,0,0,0 %;
literal PQB$S_IMAGE = 256;              !  IMAGE NAME FOR NEW PROCESS 
macro PQB$T_ACCOUNT = 2248,0,0,0 %;
literal PQB$S_ACCOUNT = 8;              !  ACCOUNT NAME FOR NEW PROCESS 
 
!*** MODULE $PRBDEF ***
! +
! 
!  Protection block definition. The protection block is used to specify
!  protection on objects internal to the system (e.g., devices, logical
!  name tables, etc.) It is used as input to the EXE$CHECKACCESS routine.
! 
! -
literal PRB$M_UIC = 1;
literal PRB$M_ACL = 2;
literal PRB$M_CLASS = 4;
literal PRB$M_CLASSMAX = 8;
literal PRB$S_PRBDEF = 8;
macro PRB$W_FLAGS = 0,0,16,0 %;         !  Presence flag bits
macro PRB$V_UIC = 0,0,1,0 %;            !  Set for simple UIC protection
macro PRB$V_ACL = 0,1,1,0 %;            !  Set for access control list
macro PRB$V_CLASS = 0,2,1,0 %;          !  Set for security classification
macro PRB$V_CLASSMAX = 0,3,1,0 %;       !  Set for security class range
macro PRB$W_PROTECTION = 2,0,16,0 %;    !  SOGW protection mask
macro PRB$L_OWNER = 4,0,32,0 %;         !  Owner UIC
! 
!  The remaining items in the protection block are optional and therefore
!  do not have fixed offsets. The description given below is for a
!  hypothetical fully configured protection block.
! 
!   ACL quadword;			/* ACL listhead
!   CLASS structure;			/* Classification mask
! 	FILL_1 long dimension 5 fill;
! 	end CLASS;
!   CLASSMAX structure;			/* Maximum class mask for range
! 	FILL_2 long dimension 5 fill;
! 	end CLASSMAX;
! 
 
!*** MODULE $PRCPOLDEF ***
! +
!  PROCESS POLLER MAILBOX MESSAGE DEFINITIONS
! -
literal PRCPOL$C_SIZ = 56;              ! SIZE OF MESSAGE	
literal PRCPOL$S_PRCPOLDEF = 56;
macro PRCPOL$L_SYSIDL = 0,0,32,0 %;     ! LOW ORDER SYSTEM ID
macro PRCPOL$W_SYSIDH = 4,0,16,0 %;     ! HIGH ORDER SYSTEM ID
macro PRCPOL$T_NODNAM = 8,0,0,0 %;
literal PRCPOL$S_NODNAM = 16;           ! SCA NODE NAME (COUNTED ASCII)
macro PRCPOL$B_PRCNAM = 24,0,0,0 %;
literal PRCPOL$S_PRCNAM = 16;           ! PROCESS NAME
macro PRCPOL$B_DIRINF = 40,0,0,0 %;
literal PRCPOL$S_DIRINF = 16;           ! DIRECTORY INFORMATION
 
!*** MODULE $PRIDEF ***
! +
!  PRIORITY INCREMENT CLASS DEFINITIONS
! -
literal PRI$_NULL = 0;                  !  NO PRIORITY INCREMENT (must be equal to 0)
literal PRI$_IOCOM = 1;                 !  DIRECT I/O COMPLETION 
literal PRI$_RESAVL = 2;                !  RESOURCE AVAIL 
literal PRI$_TOCOM = 3;                 !  TERMINAL OUTPUT COMPLETE 
literal PRI$_TICOM = 4;                 !  TERMINAL INPUT COMPLETE 
literal PRI$_TIMER = 5;                 !  TIMER INTERVAL COMPLETION 
literal PRI$_PINC_CNT = 6;              !  No. of priority increment classes
 
!*** MODULE $PRMDEF ***
! +
!  DEFINE PARAMETER DESCRIPTOR BLOCK
! -
literal PRM$M_DYNAMIC = 1;
literal PRM$M_STATIC = 2;
literal PRM$M_SYSGEN = 4;
literal PRM$M_ACP = 8;
literal PRM$M_JBC = 16;
literal PRM$M_RMS = 32;
literal PRM$M_SYS = 64;
literal PRM$M_SPECIAL = 128;
literal PRM$M_DISPLAY = 256;
literal PRM$M_CONTROL = 512;
literal PRM$M_MAJOR = 1024;
literal PRM$M_PQL = 2048;
literal PRM$M_NEG = 4096;
literal PRM$M_TTY = 8192;
literal PRM$M_SCS = 16384;
literal PRM$M_CLUSTER = 32768;
literal PRM$M_ASCII = 65536;
literal PRM$M_LGI = 131072;
literal PRM$M_MULTIPROCESSING = 262144;
literal PRM$C_BYTE = 8;                 !  
literal PRM$C_WORD = 16;                !  
literal PRM$C_LONG = 32;                !  
literal PRM$C_QUAD = 64;                ! 
literal PRM$C_OCTA = 128;               ! 
literal PRM$C_MAXNAMLEN = 15;           ! MAXIMUM LENGTH FOR PARAMETER NAME 
literal PRM$C_MAXUNILEN = 11;           ! MAXIMUM LENGTH FOR UNIT NAME 
literal PRM$K_LENGTH = 50;              ! SIZE OF DESCRIPTOR BLOCK 
literal PRM$C_LENGTH = 50;              ! SIZE OF DESCRIPTOR BLOCK 
literal PRM$S_PRM_DEF = 50;
macro PRM$L_ADDR = 0,0,32,0 %;          ! ADDRESS OF PARAMETER 
macro PRM$L_DEFAULT = 4,0,32,0 %;       ! DEFAULT VALUE 
macro PRM$L_MIN = 8,0,32,0 %;           ! MINIMUM VALUE (-1)=>NONE 
macro PRM$L_MAX = 12,0,32,0 %;          ! MAXIMUM VALUE (-1)=>NONE 
macro PRM$L_FLAGS = 16,0,32,0 %;        ! TYPE FLAGS 
macro PRM$V_DYNAMIC = 16,0,1,0 %;       !  DYNAMIC PARAMETER 
macro PRM$V_STATIC = 16,1,1,0 %;        !  STATIC PARAMETER 
macro PRM$V_SYSGEN = 16,2,1,0 %;        !  SYSGEN PARAMETER 
macro PRM$V_ACP = 16,3,1,0 %;           !  ACP CONTROL PARAMETER 
macro PRM$V_JBC = 16,4,1,0 %;           !  JOB CONTROL PARAMETER 
macro PRM$V_RMS = 16,5,1,0 %;           !  RMS CONTROL PARAMETER 
macro PRM$V_SYS = 16,6,1,0 %;           !  GENERAL SYSTEM PARAMETER 
macro PRM$V_SPECIAL = 16,7,1,0 %;       !  SPECIAL PARAMETER 
macro PRM$V_DISPLAY = 16,8,1,0 %;       !  DISPLAY ONLY (NO CHANGE) 
macro PRM$V_CONTROL = 16,9,1,0 %;       !  CONTROL PARAMETER 
macro PRM$V_MAJOR = 16,10,1,0 %;        !  MAJOR PARAMETER 
macro PRM$V_PQL = 16,11,1,0 %;          !  PROCESS QUOTA LIST 
macro PRM$V_NEG = 16,12,1,0 %;          !  NEGATIVE 
macro PRM$V_TTY = 16,13,1,0 %;          !  TERMINAL CONTROL PARAMETER 
macro PRM$V_SCS = 16,14,1,0 %;          !  SCS CONTROL PARAMETERS 
macro PRM$V_CLUSTER = 16,15,1,0 %;      !  CLUSTER CONTROL PARAMETERS
macro PRM$V_ASCII = 16,16,1,0 %;        !  ASCII PARAMETER
macro PRM$V_LGI = 16,17,1,0 %;          !  LOGIN PARAMETER
macro PRM$V_MULTIPROCESSING = 16,18,1,0 %; !  MULTIPROCESSING control
macro PRM$B_SIZE = 20,0,8,0 %;          ! SIZE CODE FOR DATUM 
macro PRM$B_POS = 21,0,8,0 %;           ! BIT POSITION 
macro PRM$T_NAME = 22,0,0,0 %;
literal PRM$S_NAME = 16;                ! ASCIC NAME STRING 
macro PRM$T_UNIT = 38,0,0,0 %;
literal PRM$S_UNIT = 12;                ! ASCIC UNIT STRING 
 
!*** MODULE $PRQDEF ***
! +
!  INTER-PROCESSOR REQUEST BLOCK DEFINITIONS
! 
!  THIS IS THE BASIC FORMAT FOR AN EXECUTIVE OR DRIVER REQUEST FROM
!  ONE PROCESSOR TO ANOTHER PROCESSOR.
! -
literal PRQ$C_EXEC = 0;                 !  EXECUTIVE REQUEST ID 
literal PRQ$C_MAILBOX = 1;              !  MAILBOX REQUEST ID 
literal PRQ$C_REMDISK = 2;              !  REMOTE DISK REQUEST ID 
literal PRQ$C_HSC50 = 3;                !  HSC-50 REQUEST ID 
literal PRQ$C_SETEF = 0;                !  COPY COMMON EVENT FLAG REQUEST ID 
literal PRQ$C_RESAVL = 1;               !  REPORT RESOURCE AVAILABLE 
literal PRQ$C_MINLENGTH = 64;           ! MINIMUM REQUEST BLOCK LENGTH 
literal PRQ$S_PRQDEF = 40;
macro PRQ$L_FLINK = 0,0,32,0 %;         ! FORWARD LINK TO NEXT BLOCK 
macro PRQ$L_BLINK = 4,0,32,0 %;         ! BACKWARD LINK TO PREVIOUS BLOCK 
macro PRQ$W_TO_PORT = 24,0,16,0 %;      ! PORT NUMBER TO SEND REQUEST TO 
macro PRQ$W_FR_PORT = 26,0,16,0 %;      ! PORT NUMBER REQUEST IS FROM 
macro PRQ$W_DISPATCH = 28,0,16,0 %;     ! MESSAGE DISPATCHER ID 
!  MESSAGE DISPATCHER ID'S
! 
macro PRQ$W_REQTYPE = 32,0,16,0 %;      ! REQUEST TYPE 
!  MESSAGE DISPATCHER REQUEST SUB-TYPES
macro PRQ$W_UNIT = 34,0,16,0 %;         ! UNIT NUMBER 
macro PRQ$L_PARAM = 36,0,32,0 %;        ! FIRST PARAMETER 
 
!*** MODULE $PSCANCTXDEF ***
! 
!  The PSCANCTX$ structure is exchanged with remote nodes.  Any updates to this
!  structure must take mixed-version operation into account.
! 
literal pscanctx$m_super = 1;
literal pscanctx$m_csid_vec = 2;
literal pscanctx$m_locked = 4;
literal pscanctx$m_multi_node = 8;
literal pscanctx$m_busy = 16;
literal pscanctx$m_relock = 32;
literal pscanctx$k_length = 64;         !  length of data structure
literal pscanctx$m_node_item = -2147483648; !  item code references a node
literal pscanctx$v_node_item = 31;      !  item code references a node
literal pscanctx$S_$pscanctxdef = 64;
macro pscanctx$l_flink = 0,0,32,0 %;    !  forward link
macro pscanctx$l_blink = 4,0,32,0 %;    !  back link
macro pscanctx$w_size = 8,0,16,0 %;     !  size of structure
macro pscanctx$b_type = 10,0,8,0 %;     !  structure type code
macro pscanctx$b_subtype = 11,0,8,0 %;  !  structure subtype
macro pscanctx$w_maj_vers = 12,0,16,0 %; !  incompatible level
macro pscanctx$w_min_vers = 14,0,16,0 %; !  upwards-compatible level
macro pscanctx$l_flags = 16,0,32,0 %;
macro pscanctx$v_super = 16,0,1,0 %;    !  allocated from supervisor mode
macro pscanctx$v_csid_vec = 16,1,1,0 %; !  csid vector is present
macro pscanctx$v_locked = 16,2,1,0 %;   !  cell is locked in memory
macro pscanctx$v_multi_node = 16,3,1,0 %; !  scan is for more than one node
macro pscanctx$v_busy = 16,4,1,0 %;     !  scan in progress on this block
macro pscanctx$v_relock = 16,5,1,0 %;   !  ignore BUSY flag, allow a "lock"
macro pscanctx$l_cur_csid = 20,0,32,0 %; !  CSID for scan in progress
macro pscanctx$l_cur_ipid = 24,0,32,0 %; !  initial IPID for scan in progress
macro pscanctx$l_next_ipid = 28,0,32,0 %; !  updated IPID for scan in progress
macro pscanctx$l_cur_epid = 32,0,32,0 %; !  EPID for scan in progress
macro pscanctx$w_itmlstoff = 36,0,16,0 %; !  offset to item list
macro pscanctx$w_bufferoff = 38,0,16,0 %; !  offset to buffer area
macro pscanctx$w_csidoff = 40,0,16,0 %; !  offset to csid vector
macro pscanctx$w_csididx = 42,0,16,0 %; !  index of current csid
macro pscanctx$l_svapte = 44,0,32,0 %;  !  sva of pte for this block
macro pscanctx$l_cwpssrv = 48,0,32,0 %; !  address of CWPSSRV structure
macro pscanctx$l_jpibufadr = 52,0,32,0 %; !  address of $GETJPI buffer
macro pscanctx$w_seqnum = 56,0,16,0 %;  !  sequence number
macro pscanctx$b_acmode = 58,0,8,0 %;   !  access mode of original call
macro pscanctx$b_spare0 = 59,0,8,0 %;   !  just a little extra
macro pscanctx$l_spare1 = 60,0,32,0 %;  !  just a little extra
! 
!  The PSCANBUF$ structure is exchanged with remote nodes.  Any updates to this
!  structure must take mixed-version operation into account.
! 
literal pscanbuf$m_spare0 = 1;
literal pscanbuf$k_length = 32;         !  length of data structure
literal pscanbuf$S_$pscanbufdef = 32;
macro pscanbuf$l_buflen = 0,0,32,0 %;   !  length of data area
macro pscanbuf$l_spare0 = 4,0,32,0 %;   !  spare0
macro pscanbuf$w_size = 8,0,16,0 %;     !  size of structure
macro pscanbuf$b_type = 10,0,8,0 %;     !  structure type code
macro pscanbuf$b_subtype = 11,0,8,0 %;  !  structure subtype
macro pscanbuf$w_maj_vers = 12,0,16,0 %; !  incompatible level
macro pscanbuf$w_min_vers = 14,0,16,0 %; !  upwards-compatible level
macro pscanbuf$l_flags = 16,0,32,0 %;
macro pscanbuf$v_spare0 = 16,0,1,0 %;   !  filler
macro pscanbuf$l_itmlstadr = 20,0,32,0 %; !  address of copy of JPI item list
macro pscanbuf$l_buffer_offset = 24,0,32,0 %; !  offset to start of buffer
macro pscanbuf$l_free_offset = 28,0,32,0 %; !  offset to next free byte
! 
!  The PSCANITM$ structure is a local structure.  If modified, you do not need
!  to take mixed-version operation into account, however you must be sure that
!  all modules and images which reference the structure are updated together.
! 
literal pscanitm$k_length = 12;         !  length of data structure
literal pscanitm$S_$pscanitmdef = 13;
macro pscanitm$l_alloc_length = 0,0,32,0 %; !  allocated length
macro pscanitm$l_itmlen = 4,0,32,0 %;   !  length of item list
macro pscanitm$w_size = 8,0,16,0 %;     !  size of header
macro pscanitm$b_type = 10,0,8,0 %;     !  structure type code
macro pscanitm$b_subtype = 11,0,8,0 %;  !  structure subtype
macro pscanitm$b_itmlst = 12,0,8,0 %;   !  start of the item list
 
!*** MODULE $PSMDEF ***
!  Print symbiont definitions
! +
!  Symbolic definitions for print symbionts.
! 
! 	Public definition of various constants and data structures
! 	used by the standard VMS print symbiont, and by user modified
! 	print symbionts.
! 
! -
! 
! 	Service routine function codes
! 
! 
!  IO functions
! 
literal PSM$K_CANCEL = 1;               !  Cancel pending operations
literal PSM$K_CLOSE = 2;                !  Release resources
literal PSM$K_FORMAT = 3;               !  Format buffer
literal PSM$K_OPEN = 4;                 !  Obtain resources
literal PSM$K_READ = 5;                 !  Read
literal PSM$K_GET_KEY = 6;              !  Read record key
literal PSM$K_POSITION_TO_KEY = 7;      !  Read by record context
literal PSM$K_REWIND = 8;               !  Rewind file
literal PSM$K_WRITE = 9;                !  Write
literal PSM$K_WRITE_NOFORMAT = 10;      !  Write with driver formatting disabled
literal PSM$K_WRITE_SUPPRESSED = 11;    !  Write but suppress output
! 
!  Message notification functions
! 
literal PSM$K_PAUSE_TASK = 12;          !  STOP /QUEUE
literal PSM$K_RESET_STREAM = 13;        !  STOP /QUEUE /RESET
literal PSM$K_RESUME_TASK = 14;         !  START /QUEUE	(when paused)
literal PSM$K_START_STREAM = 15;        !  START /QUEUE (when stopped)
literal PSM$K_START_TASK = 16;          !  (ofiginated by job controller)
literal PSM$K_STOP_TASK = 17;           !  STOP /QUEUE /ABORT or /REQUEUE
literal PSM$K_STOP_STREAM = 18;         !  STOP /QUEUE /NEXT
! 
! 	Replacement routines
! 
! 
!  Task services -- where applicable the ordering of these literals
!  determines the sequence of the corresponding service routines.
! 
! 
!  Page services
! 
literal PSM$K_PAGE_SETUP = 1;           !  Page setup	    - page setup modules
literal PSM$K_PAGE_HEADER = 2;          !  Page separation  - page headers
! 
!  Library module service
! 
literal PSM$K_LIBRARY_INPUT = 3;        !  Module services
! 
!  Filter services
! 
literal PSM$K_INPUT_FILTER = 4;         !  Filter service   - input
literal PSM$K_MAIN_FORMAT = 5;          !  Format service   - carriage control
literal PSM$K_OUTPUT_FILTER = 6;        !  Filter service   - output
! 
!  Output services
! 
literal PSM$K_OUTPUT = 7;               !  Main output routine
! 
!  General input services
! 
literal PSM$K_JOB_SETUP = 8;            !  Job setup	    - job reset modules
literal PSM$K_FORM_SETUP = 9;           !  Form setup	    - form setup modules
literal PSM$K_JOB_FLAG = 10;            !  Job separation   - flag page
literal PSM$K_JOB_BURST = 11;           !  Job separation   - burst page
literal PSM$K_FILE_SETUP = 12;          !  File setup	    - file setup modules
literal PSM$K_FILE_FLAG = 13;           !  File separation  - flag page
literal PSM$K_FILE_BURST = 14;          !  File separation  - burst page
literal PSM$K_FILE_SETUP_2 = 15;        !  File setup	    - top of form
literal PSM$K_MAIN_INPUT = 16;          !  File service	    - main routine
literal PSM$K_FILE_INFORMATION = 17;    !  Additional information print
literal PSM$K_FILE_ERRORS = 18;         !  Errors during task processing
literal PSM$K_FILE_TRAILER = 19;        !  File separation  - trailer page
literal PSM$K_JOB_RESET = 20;           !  Job reset	    - job reset modules
literal PSM$K_JOB_TRAILER = 21;         !  Job separation   - trailer page
literal PSM$K_JOB_COMPLETION = 22;      !  Job completion   - top of form
literal PSM$K_PAGE_FOOTER = 23;         !  Page separation  - page footers
literal PSM$k_max = 24;                 !  MUST BE LAST
! 
! 	Carriage control types
! 
literal PSM$K_CC_INTERNAL = 1;          !   - imbedded
literal PSM$K_CC_IMPLIED = 2;           !   - implied
literal PSM$K_CC_FORTRAN = 3;           !   - fortran
literal PSM$K_CC_PRINT = 4;             !   - print file (PRN)
literal PSM$K_CC_MAX = 5;               !  MUST BE LAST
 
!*** MODULE $PTADEF ***
literal PTA$M_TCRESET = 256;
literal PTA$M_ENBMAP = 512;
literal PTA$M_INVREF = 1024;
literal PTA$M_TCTMO = 2048;
literal PTA$M_ENBTCINT = 4096;
literal PTA$M_TCINT = 8192;
literal PTA$M_TCERR = 16384;
literal PTA$M_ALT_MODE = 32768;
literal PTA$M_ENBPVPRTY = 65536;
literal PTA$M_FIFOEMP = 131072;
literal PTA$S_PTACSR = 32776;
macro PTA$L_CSR = 32772,0,32,0 %;
macro PTA$V_BLKSIZE = 32772,0,8,0 %;
literal PTA$S_BLKSIZE = 8;              !  Block size for TC transactions
macro PTA$V_TCRESET = 32772,8,1,0 %;    !  TC reset
macro PTA$V_ENBMAP = 32772,9,1,0 %;     !  Enable map registers 
macro PTA$V_INVREF = 32772,10,1,0 %;    !  Invalid ref to map register
macro PTA$V_TCTMO = 32772,11,1,0 %;     !  TC timeout (128 TC cycles)
macro PTA$V_ENBTCINT = 32772,12,1,0 %;  !  Enable ints from TC int signal
macro PTA$V_TCINT = 32772,13,1,0 %;     !  TC int signal state
macro PTA$V_TCERR = 32772,14,1,0 %;     !  TC err signal state
macro PTA$V_ALT_MODE = 32772,15,1,0 %;  !  Alternate Cycle mode(DMA)
macro PTA$V_ENBPVPRTY = 32772,16,1,0 %; !  Enable parity generation to pvax
macro PTA$V_FIFOEMP = 32772,17,1,0 %;   !  Fifo is empty flag
macro PTA$V_UNUSED = 32772,18,14,0 %;
literal PTA$S_UNUSED = 14;              !  UNUSED 
literal PTA$M_VALID = -2147483648;
literal PTA$S_PTAMPR = 4;
macro PTA$L_MAPREG = 0,0,32,0 %;        !  PTA map register layout
macro PTA$V_PFN = 0,0,18,0 %;
literal PTA$S_PFN = 18;                 !  PFN to map register 
macro PTA$V_SPARE = 0,18,5,0 %;
literal PTA$S_SPARE = 5;                !  UNUSED bits
macro PTA$V_RESRVED = 0,23,8,0 %;
literal PTA$S_RESRVED = 8;              !  UNSED bits
macro PTA$V_VALID = 0,31,1,0 %;         !  Valid bit for map register
 
!*** MODULE $PTEDEF ***
! +
!  DEFINE PAGE TABLE ENTRY VIELDS AND VALUES
! -
! 
!  VIELD DEFINITION FOR "VALID" PTE'S
! 
literal PTE$M_PFN = 2097151;
literal PTE$M_WINDOW = 2097152;
literal PTE$M_OWN = 25165824;
literal PTE$M_MODIFY = 67108864;
literal PTE$M_PROT = 2013265920;
literal PTE$M_VALID = -2147483648;
literal PTE$M_CRF = 65536;
literal PTE$M_DZRO = 131072;
literal PTE$M_WRT = 262144;
literal PTE$M_TYP0 = 4194304;
literal PTE$M_TYP1 = 67108864;
literal PTE$M_PGFLVBN = 1048575;
literal PTE$M_PRCPGFLX = 3145728;
literal PTE$M_BAKX = 4194303;
literal PTE$M_BAK0 = 8388607;
literal PTE$M_GPTX = 4194303;
literal PTE$C_NA = 0;                   !  NO ACCESS 
literal PTE$C_KR = 402653184;           !  KERNEL READ ONLY 
literal PTE$C_KW = 268435456;           !  KERNEL WRITE 
literal PTE$C_ER = 939524096;           !  EXEC READ ONLY 
literal PTE$C_EW = 671088640;           !  EXEC WRITE 
literal PTE$C_SR = 1476395008;          !  SUPER READ ONLY 
literal PTE$C_SW = 1073741824;          !  SUPER WRITE 
literal PTE$C_UR = 2013265920;          !  USER READ ONLY 
literal PTE$C_UW = 536870912;           !  USER WRITE 
literal PTE$C_ERKW = 805306368;         !  EXEC READ KERNEL WRITE 
literal PTE$C_SRKW = 1342177280;        !  SUPER READ KERNEL WRITE 
literal PTE$C_SREW = 1207959552;        !  SUPER READ EXEC WRITE 
literal PTE$C_URKW = 1879048192;        !  USER READ KERNEL WRITE 
literal PTE$C_UREW = 1744830464;        !  USER READ EXEC WRITE 
literal PTE$C_URSW = 1610612736;        !  USER READ SUPER WRITE 
! +
literal PTE$C_KOWN = 0;                 !  KERNEL OWNER 
literal PTE$C_EOWN = 8388608;           !  EXEC OWNER 
literal PTE$C_SOWN = 16777216;          !  SUPER OWNER 
literal PTE$C_UOWN = 25165824;          !  USER OWNER 
literal PTE$S_PTEDEF = 4;
macro PTE$V_PFN = 0,0,21,0 %;
literal PTE$S_PFN = 21;                 !  PAGE FRAME NUMBER 
macro PTE$V_WINDOW = 0,21,1,0 %;        !  WINDOW BIT 
macro PTE$V_OWN = 0,23,2,0 %;
literal PTE$S_OWN = 2;                  !  MODE OF THE OWNER 
macro PTE$V_MODIFY = 0,26,1,0 %;        !  MODIFY BIT 
macro PTE$V_PROT = 0,27,4,0 %;
literal PTE$S_PROT = 4;                 !  PROTECTION 
macro PTE$V_VALID = 0,31,1,0 %;         !  VALID BIT 
! 
!  VIELD DEFINITIONS FOR VARIOUS INVALID FORMS OF PTE
! 
macro PTE$V_STX = 0,0,16,1 %;
literal PTE$S_STX = 16;                 !  SECTION TABLE INDEX 
macro PTE$V_CRF = 0,16,1,0 %;           !  COPY ON REFERENCE 
macro PTE$V_DZRO = 0,17,1,0 %;          !  DEMAND ZERO 
macro PTE$V_WRT = 0,18,1,0 %;           !  SECTION FILE IS ACCESSED FOR WRITING 
macro PTE$V_TYP0 = 0,22,1,0 %;          !  LOW ORDER BIT OF PTE TYPE 
macro PTE$V_TYP1 = 0,26,1,0 %;          !  HIGH ORDER BIT OF PTE TYPE 
!  OVERLAYS MODIFY BIT
macro PTE$R_PTEDEF_BITS2 = 0,0,24,0 %;
macro PTE$R_BAK_OVERLAY = 0,0,24,0 %;
macro PTE$R_BAK_PGFL = 0,0,24,0 %;
literal PTE$S_BAK_PGFL = 3;
macro PTE$V_PGFLVBN = 0,0,20,0 %;
literal PTE$S_PGFLVBN = 20;             !  Page file VBN
macro PTE$V_PRCPGFLX = 0,20,2,0 %;
literal PTE$S_PRCPGFLX = 2;             !  Process page file index
macro PTE$V_BAKX = 0,0,22,0 %;
literal PTE$S_BAKX = 22;                ! BACKUP ADDRESS (uninterpreted)
macro PTE$V_BAK0 = 0,0,23,0 %;
literal PTE$S_BAK0 = 23;                ! BACKUP ADDRESS (w/TYP0)
macro PTE$V_GPTX = 0,0,22,0 %;
literal PTE$S_GPTX = 22;                !  GLOBAL PAGE TABLE INDEX 
! +
!  PROTECTION FIELD DEFINITIONS
! -
!  OWNER FIELD DEFINITIONS
! _
 
!*** MODULE $PTRDEF ***
! +
!  POINTER CONTROL BLOCK
!         THIS IS A STRUCTURE OF POINTERS TO OTHER DYNAMIC STRUCTURES
!         OF LIKE KIND.  TYPICALLY THE STRUCTURES POINTED TO ARE KNOWN
!         BY THEIR LONG WORD INDEX INTO THE TABLE AND TO FACILITATE FETCHING
!         THESE, IT IS CONVENTIONAL TO KEEP A POINTER TO THE BASE OF THE
!         STRUCTURE POINTERS RATHER THAN (OR IN ADDITION TO) THE POINTER
!         TO THE FRONT OF THE POINTER CONTROL BLOCK.  THE NUMBER OF POINTERS
!         IN THE ARRAY PRECEEDS THE FIRST POINTER IN THE ARRAY.
! -
literal PTR$K_LENGTH = 16;              ! LENGTH OF FIXED PORTION 
literal PTR$C_LENGTH = 16;              ! LENGTH OF FIXED PORTION 
literal PTR$S_PTRDEF = 20;
macro PTR$W_SIZE = 8,0,16,0 %;          ! SIZE OF DYNAMIC CONTROL BLOCK 
macro PTR$B_TYPE = 10,0,8,0 %;          ! TYPE OF DYNAMIC CONTROL BLOCK 
macro PTR$B_PTRTYPE = 11,0,8,0 %;       ! TYPE OF CONTROL BLOCK POINTED TO 
macro PTR$L_PTRCNT = 12,0,32,0 %;       ! COUNT OF ENTRIES 
macro PTR$L_PTR0 = 16,0,32,0 %;         ! PTR NUMBER 0 
 
!*** MODULE $PWDHISDEF ***
!  Password History Record - This structure defines the layout of the system
!  password history file.  This is a variable record length indexed file (keyed
!  by username) where each record contains the last "n" quadword hash values for
!  the user's last "n" passwords.
literal PWDHIS$C_ENTRY_LENGTH = 16;     !  size of one entry
literal PWDHIS$K_ENTRY_LENGTH = 16;     !  size of one entry
literal PWDHIS$S_PWDENTDEF = 16;
macro PWDHIS$Q_ENTRY = 0,0,0,0 %;
literal PWDHIS$S_ENTRY = 8;             !  the quadword hash
macro PWDHIS$Q_CHANGE = 8,0,0,0 %;
literal PWDHIS$S_CHANGE = 8;            !  password change date
literal PWDHIS$C_FIXED = 32;            !  fixed part of record
literal PWDHIS$K_FIXED = 32;            !  fixed part of record
literal PWDHIS$C_DEFAULT_LIFETIME = 365; !  default history lifetime (days)
literal PWDHIS$K_DEFAULT_LIFETIME = 365; !  default history lifetime (days)
literal PWDHIS$C_DEFAULT_LIMIT = 60;    !  default # of history entries per user
literal PWDHIS$K_DEFAULT_LIMIT = 60;    !  default # of history entries per user
literal PWDHIS$C_MAXIMUM_LIMIT = 2000;  !  maximum # of history entries per user
literal PWDHIS$K_MAXIMUM_LIMIT = 2000;  !  maximum # of history entries per user
literal PWDHIS$S_PWDHISDEF = 36;
macro PWDHIS$T_USERNAME = 0,0,0,0 %;
literal PWDHIS$S_USERNAME = 32;         !  username (KEY0)
macro PWDHIS$R_HISTORY = 32,0,32,0 %;
literal PWDHIS$S_HISTORY = 4;           !  offset to start of list
 
!*** MODULE $PXDSRRDEF IDENT X-6 ***
literal psx$_psx$spare_vms_1 = 0;
literal psx$_psx$set_masks = 1;
literal psx$_psx$child_swapin = 2;
literal psx$_psx$same_session = 3;
literal psx$_psx$process_deletion = 4;
literal psx$_psx$process_exit = 5;
literal psx$_psx$posix_proc_del = 6;
literal psx$_psx$check_new_pid = 7;
literal psx$_psx$deliv_signal = 8;
literal psx$_psx$delivery = 9;
literal psx$_psx$vip_astexit_chmk = 10;
literal psx$_psx$check_cpulim = 11;
literal psx$_psx$get_cpulim = 12;
literal psx$_psx$rdc_cpulim = 13;
literal psx$_psx$alloc_p1_pages = 14;
literal psx$_psx$time_mode = 15;
literal psx$_psx$make_callbacks = 16;
literal psx$_psx$system_callback_list = 17;
literal psx$_psx$fork_check = 18;
literal psx$_psx$callback_service = 19;
literal psx$_psx$spare_vms_19 = 20;
literal psx$_psx$spare_vms_20 = 21;
literal psx$_psx$spare_vms_21 = 22;
literal psx$_psx$spare_vms_22 = 23;
literal psx$_psx$spare_vms_23 = 24;
literal psx$_psx$spare_vms_24 = 25;
literal psx$_psx$spare_vms_25 = 26;
literal psx$_psx$spare_vms_26 = 27;
literal psx$_psx$spare_vms_27 = 28;
literal psx$_psx$spare_vms_28 = 29;
literal psx$_psx$spare_vms_29 = 30;
literal psx$_psx$spare_vms_30 = 31;
literal psx$_psx$spare_vms_31 = 32;
literal psx$_psx$spare_vms_32 = 33;
literal psx$_psx$spare_vms_33 = 34;
literal psx$_psx$spare_vms_34 = 35;
literal psx$_psx$spare_vms_35 = 36;
literal psx$_psx$spare_vms_36 = 37;
literal psx$_psx$spare_vms_37 = 38;
literal psx$_psx$spare_vms_38 = 39;
literal psx$_psx$spare_vms_39 = 40;
literal psx$_psx$send_signal = 41;
literal psx$_psx$send_signal_to_group = 42;
literal psx$_psx$send_signal_to_session = 43;
literal psx$_psx$rundown = 44;
literal psx$_psx$rundown_exec = 45;
literal psx$_psx$ga_cfs_base = 46;
literal psx$_psx$gl_next_rndwn = 47;
literal psx$_psx$gl_next_rndwn_exec = 48;
literal psx$_psx$ga_spg_table = 49;
literal psx$_psx$gl_spg_size = 50;
literal psx$_psx$gl_spg_hash = 51;
literal psx$_psx$gl_max_fork_in_prg = 52;
literal psx$_psx$gl_max_fork_perproc = 53;
literal psx$_psx$gl_max_sess_perproc = 54;
literal psx$_psx$gl_exec_arg_size = 55;
literal psx$_psx$gl_fs_buff_size = 56;
literal psx$_psx$gl_fork_in_prg = 57;
literal psx$_psx$gl_def_process_flags = 58;
literal psx$_psx$lookup_spg_table = 59;
literal psx$_psx$ga_default_termios = 60;
literal psx$_psx$spare_13 = 61;
literal psx$_psx$spare_14 = 62;
literal psx$_psx$spare_15 = 63;
literal psx$_psx$spare_16 = 64;
literal psx$_psx$spare_17 = 65;
literal psx$_psx$spare_18 = 66;
literal psx$_psx$spare_19 = 67;
literal psx$_psx$spare_20 = 68;
literal psx$_psx$spare_21 = 69;
literal psx$_psx$spare_22 = 70;
literal psx$_psx$spare_23 = 71;
literal psx$_psx$spare_24 = 72;
literal psx$_psx$spare_25 = 73;
literal psx$_psx$spare_26 = 74;
literal psx$_psx$spare_27 = 75;
literal psx$_psx$spare_28 = 76;
literal psx$_psx$spare_29 = 77;
literal psx$_sub_total_number = 78;
literal PXDSRR$K_LENGTH = 312;
literal PXDSRR$C_LENGTH = 312;
literal PXDSRR$S_PXDSRR = 312;
macro PXDSRR$L_GLOBAL_CELLS = 0,0,0,0 %;
literal PXDSRR$S_GLOBAL_CELLS = 312;
 
!*** MODULE $RBMDEF ***
! +
!  RBM        - realtime bit map of SPTs available for real time processes
! -
literal RBM$K_LENGTH = 12;              !  Length of block so far. 
literal RBM$C_LENGTH = 12;              !  Length of block so far. 
literal RBM$S_RBMDEF = 16;
macro RBM$L_STARTVPN = 0,0,32,0 %;      !  Starting VPN of bit map. 
macro RBM$L_FREECOUNT = 4,0,32,0 %;     !  Number of free SPTs. 
macro RBM$W_SIZE = 8,0,16,0 %;          !  Size of control block. 
macro RBM$B_TYPE = 10,0,8,0 %;          !  Type of control block. 
macro RBM$L_BITMAP = 12,0,32,0 %;       !  Start of bit map. 
 
!*** MODULE $RDIDEF ***
! ++
!  Rights Database Identifier Block definitions: This structure contains the
!  RMS Internal File Identifiers (IFI's) and Internal Stream Identifiers
!  (ISI's) for the rights database. This structure is allocated from the
!  process allocation region pool.
! --
literal RDI$K_ISI_MAX = 10;             !  Maximum number of concurrent record streams
literal RDI$S_RDIDEF = 56;
macro RDI$L_SIZE = 0,0,32,0 %;          !  Size of allocated block
macro RDI$L_IFI_READ = 4,0,32,0 %;      !  Internal File Identifier for read operations
macro RDI$L_IFI_WRITE = 8,0,32,0 %;     !  Internal File Identifier for write operations
macro RDI$L_ISI_VEC = 12,0,0,0 %;
literal RDI$S_ISI_VEC = 44;             !  Internal Stream Identifier vector
 
!*** MODULE $RDPDEF ***
! 
!  REMOTE DEVICE PROTOCOL DEFINITIONS
! 
literal RDP$K_HEADERLEN = 10;           ! HEADER LENGTH 
literal RDP$C_HEADERLEN = 10;           ! HEADER LENGTH 
literal RDP$C_ATTN = -1;                !  ATTENTION 
literal RDP$C_END = -2;                 !  I/O REQUEST COMPLETE 
literal RDP$C_LOG = -3;                 !  ERROR LOG 
literal RDP$S_RDPDEF = 34;
macro RDP$W_OPCODE = 0,0,16,0 %;        ! OPERATION CODE 
macro RDP$W_MOD = 2,0,16,0 %;           ! OPERATION CODE MODIFIERS 
macro RDP$L_REFID = 4,0,32,0 %;         ! REFERENCE ID 
macro RDP$W_UNIT = 8,0,16,0 %;          ! DEVICE UNIT NUMBER 
macro RDP$W_SIZE = 8,0,16,0 %;          ! SIZE OF MESSAGE (ACP/DRIVER USE ONLY) 
macro RDP$L_PARAM1 = 10,0,32,0 %;       ! PARAMETER 1 
macro RDP$L_PARAM2 = 14,0,32,0 %;       ! PARAMETER 2 
macro RDP$L_PARAM3 = 18,0,32,0 %;       ! PARAMETER 3 
macro RDP$L_PARAM4 = 22,0,32,0 %;       ! PARAMETER 4 
macro RDP$L_PARAM5 = 26,0,32,0 %;       ! PARAMETER 5 
macro RDP$L_PARAM6 = 30,0,32,0 %;       ! PARAMETER 6 
! 
!  RESPONSE FROM REMOTE PACKET DEFINITIONS
! 
! RESPONSE PACKET OPCODES 
literal RDP$S_RDPDEF1 = 18;
macro RDP$Q_STATUS = 10,0,0,0 %;
literal RDP$S_STATUS = 8;               ! END PACKET I/O STATUS 
! 
!  TERMINAL SPECIFIC PARAMETER DEFINITIONS
! 
!   READ/WRITE REQUEST
literal RDP$S_RDPDEF2 = 19;
macro RDP$L_TT_BCNT = 10,0,32,0 %;      ! BYTE COUNT 
macro RDP$L_TT_CARCON = 14,0,32,0 %;    ! WRITE CARRIAGE CONTROL 
macro RDP$L_TT_TIMOUT = 14,0,32,0 %;    ! READ TIMEOUT 
macro RDP$T_TT_WDATA = 18,0,8,0 %;      ! WRITE DATA 
macro RDP$T_TT_TERM = 18,0,8,0 %;       ! BYTE OF SIZE + TERMINATOR MASK 
! WORD OF SIZE + PROMPT STRING
!  SET MODE/CHARACTERISTICS REQUEST
literal RDP$S_RDPDEF3 = 34;
macro RDP$Q_TT_CHAR = 10,0,0,0 %;
literal RDP$S_TT_CHAR = 8;              ! CHARACTERISTICS 
macro RDP$L_TT_ASTPRM = 10,0,32,0 %;    ! AST PARAMETER 
macro RDP$L_TT_SPEED = 18,0,32,0 %;     ! LINE SPEED 
macro RDP$L_TT_FILL = 22,0,32,0 %;      ! FILL SPECIFIER 
macro RDP$L_TT_PARITY = 26,0,32,0 %;    ! PARITY FLAGS 
macro RDP$L_TT_CHAR2 = 30,0,32,0 %;     !  Remaining longword of characters 
!   READ REQUEST END PACKET
literal RDP$S_RDPDEF4 = 19;
macro RDP$T_TT_RDATA = 18,0,8,0 %;      ! WORD OF SIZE + READ DATA 
!   SENSE MODE/CHARACTERISTICS END PACKET
literal RDP$S_RDPDEF5 = 30;
macro RDP$Q_TT_SCHAR = 18,0,0,0 %;
literal RDP$S_TT_SCHAR = 8;             ! SENSED CHARACTERISTICS 
macro RDP$L_TT_SCHAR2 = 26,0,32,0 %;    !  Additional longword of characters 
!  Broadcast message attention packet
literal RDP$C_TT_BRDNAME = 16;          !  Size of name field 
literal RDP$S_RDPDEF6 = 34;
macro RDP$W_TT_BRDTOTSIZE = 10,0,16,0 %; !  Total size of data 
macro RDP$W_TT_BRDMSG = 12,0,16,0 %;    !  Message code 
macro RDP$W_TT_BRDUNIT = 14,0,16,0 %;   !  Unit number 
macro RDP$T_TT_BRDNAME = 16,0,0,0 %;
literal RDP$S_TT_BRDNAME = 16;          !  Device name as counted string 
macro RDP$W_TT_BRDTXTSIZE = 32,0,16,0 %; !  Count for message text 
macro RDP$T_TT_BRDTEXT = 34,0,0,0 %;    !  Message text start 
!  Out of band attention packet
literal RDP$C_TT_UNSOL = 0;             ! UNSOLICITED DATA 
literal RDP$C_TT_HANGUP = 1;            ! MODEM HANGUP 
literal RDP$C_TT_CTRLC = 2;             ! CONTROL/C 
literal RDP$C_TT_CTRLY = 3;             ! CONTROL/Y 
literal RDP$C_TT_STARTRCV = 4;          !  Start a receive to the net 
literal RDP$C_TT_BRDCST = 5;            !  Broadcast message for mailbox 
literal RDP$C_TT_OUTBAND = 6;           !  Out of band AST 
literal RDP$S_RDPDEF7 = 11;
macro RDP$B_TT_OUTBAND = 10,0,8,0 %;    !  Out of band character 
!  ATTENTION PACKET MODIFIERS
 
!*** MODULE $RBFDEF ***
! 
!         Remote buffer as stored in dynamic memory
! 
!         This structure must be identical to the above structure except
!         for the header, which is the header for a buffered io buffer.
! 
! 
!         Buffered io buffer header
! 
literal RBF$K_HEADERLEN = 24;           ! HEADER LENGTH 
literal RBF$C_HEADERLEN = 24;           ! HEADER LENGTH 
literal RBF$C_ATTN = -1;                !  ATTENTION 
literal RBF$C_END = -2;                 !  I/O REQUEST COMPLETE 
literal RBF$C_LOG = -3;                 !  ERROR LOG 
literal RBF$S_RBFDEF = 48;
macro RBF$L_MSGDAT = 0,0,32,0 %;        !  Address of message data 
macro RBF$L_USRBFR = 4,0,32,0 %;        !  User buffer address 
macro RBF$W_SIZE = 8,0,16,0 %;          !  Size of structure 
macro RBF$B_TYPE = 10,0,8,0 %;          !  Type of structure, DYN$C_BUFIO 
macro RBF$B_SPARE = 11,0,8,0 %;         !  Alignment 
macro RBF$W_DATSIZE = 12,0,16,0 %;      !  Data size 
! 
!         End of header
! 
macro RBF$W_OPCODE = 14,0,16,0 %;       ! OPERATION CODE 
macro RBF$W_MOD = 16,0,16,0 %;          ! OPERATION CODE MODIFIERS 
macro RBF$L_REFID = 18,0,32,0 %;        ! REFERENCE ID 
macro RBF$W_UNIT = 22,0,16,0 %;         ! DEVICE UNIT NUMBER 
!         S        SIZE,0,W                /*SIZE OF MESSAGE (ACP/DRIVER USE ONLY)
macro RBF$L_PARAM1 = 24,0,32,0 %;       ! PARAMETER 1 
macro RBF$L_PARAM2 = 28,0,32,0 %;       ! PARAMETER 2 
macro RBF$L_PARAM3 = 32,0,32,0 %;       ! PARAMETER 3 
macro RBF$L_PARAM4 = 36,0,32,0 %;       ! PARAMETER 4 
macro RBF$L_PARAM5 = 40,0,32,0 %;       ! PARAMETER 5 
macro RBF$L_PARAM6 = 44,0,32,0 %;       ! PARAMETER 6 
! 
!  RESPONSE FROM REMOTE PACKET DEFINITIONS
! 
! RESPONSE PACKET OPCODES 
literal RBF$S_RBFDEF1 = 32;
macro RBF$Q_STATUS = 24,0,0,0 %;
literal RBF$S_STATUS = 8;               ! END PACKET I/O STATUS 
! 
!  TERMINAL SPECIFIC PARAMETER DEFINITIONS
! 
!   READ/WRITE REQUEST
literal RBF$S_RBFDEF2 = 33;
macro RBF$L_TT_BCNT = 24,0,32,0 %;      ! BYTE COUNT 
macro RBF$L_TT_CARCON = 28,0,32,0 %;    ! WRITE CARRIAGE CONTROL 
macro RBF$L_TT_TIMOUT = 28,0,32,0 %;    ! READ TIMEOUT 
macro RBF$T_TT_WDATA = 32,0,8,0 %;      ! WRITE DATA 
macro RBF$T_TT_TERM = 32,0,8,0 %;       ! BYTE OF SIZE + TERMINATOR MASK 
! WORD OF SIZE + PROMPT STRING
!  SET MODE/CHARACTERISTICS REQUEST
literal RBF$S_RBFDEF3 = 48;
macro RBF$Q_TT_CHAR = 24,0,0,0 %;
literal RBF$S_TT_CHAR = 8;              ! CHARACTERISTICS 
macro RBF$L_TT_ASTPRM = 24,0,32,0 %;    ! AST PARAMETER 
macro RBF$L_TT_SPEED = 32,0,32,0 %;     ! LINE SPEED 
macro RBF$L_TT_FILL = 36,0,32,0 %;      ! FILL SPECIFIER 
macro RBF$L_TT_PARITY = 40,0,32,0 %;    ! PARITY FLAGS 
macro RBF$L_TT_CHAR2 = 44,0,32,0 %;     !  Another longword of characters 
!   READ REQUEST END PACKET
literal RBF$S_RBFDEF4 = 33;
macro RBF$T_TT_RDATA = 32,0,8,0 %;      ! WORD OF SIZE + READ DATA 
!   SENSE MODE/CHARACTERISTICS END PACKET
literal RBF$S_RBFDEF5 = 44;
macro RBF$Q_TT_SCHAR = 32,0,0,0 %;
literal RBF$S_TT_SCHAR = 8;             ! SENSED CHARACTERISTICS 
macro RBF$L_TT_SCHAR2 = 40,0,32,0 %;    !  Another longword of characters 
!  Broadcast message attention packet
literal RBF$C_TT_BRDNAME = 16;          !  Size of name field 
literal RBF$S_RBFDEF6 = 48;
macro RBF$W_TT_BRDTOTSIZE = 24,0,16,0 %; !  Total size of data 
macro RBF$W_TT_BRDMSG = 26,0,16,0 %;    !  Message code 
macro RBF$W_TT_BRDUNIT = 28,0,16,0 %;   !  Unit number 
macro RBF$T_TT_BRDNAME = 30,0,0,0 %;
literal RBF$S_TT_BRDNAME = 16;          !  Device name as counted string 
macro RBF$W_TT_BRDTXTSIZE = 46,0,16,0 %; !  Count for message text 
macro RBF$T_TT_BRDTEXT = 48,0,0,0 %;    !  Message text start 
!  Out of band attention packet
literal RBF$C_TT_UNSOL = 0;             ! UNSOLICITED DATA 
literal RBF$C_TT_HANGUP = 1;            ! MODEM HANGUP 
literal RBF$C_TT_CTRLC = 2;             ! CONTROL/C 
literal RBF$C_TT_CTRLY = 3;             ! CONTROL/Y 
literal RBF$C_TT_STARTRCV = 4;          !  Start a receive to the net 
literal RBF$C_TT_BRDCST = 5;            !  Broadcast message for mailbox 
literal RBF$C_TT_OUTBAND = 6;           !  Out of band AST 
literal RBF$S_RBFDEF7 = 25;
macro RBF$B_TT_OUTBAND = 24,0,8,0 %;    !  Out of band character 
!  ATTENTION PACKET MODIFIERS
 
!*** MODULE $RCTDEF ***
! +
!  RCT - Replacement and Caching Table sector !0 layout.
!         The RCT is a structure residing on disks controlled by MSCP
!         speaking disk controllers.  The RCT is maintained by the intelligent
!         controllers and the disk class driver.  The disk class driver mainly
!         gets involved in RCT manipulations during host initiated bad
!         block replacement.
literal RCT$M_WB = 1;
literal RCT$M_FE = 128;
literal RCT$M_BR = 8192;
literal RCT$M_RP2 = 16384;
literal RCT$M_RP1 = 32768;
literal RCT$M_LBN = 268435455;
literal RCT$M_CODE = -268435456;
literal RCT$M_NONPRIME = 268435456;
literal RCT$M_ALLOCATED = 536870912;
literal RCT$M_UNUSABLE = 1073741824;
literal RCT$M_NULL = -2147483648;
literal RCT$K_EMPTY = 0;                !  Unallocated (empty) replacement block 
literal RCT$K_ALOCPRIME = 2;            !  Allocated replace blk - primary RBN 
literal RCT$K_ALOCNONP = 3;             !  Allocated replace blk - non-primary RBN 
literal RCT$K_UNUSABLE = 4;             !  Unusable replacement block 
literal RCT$K_ALTUNUSE = 5;             !  Alternate unusable replacement block 
literal RCT$K_NULL = 8;                 !  Null entry - no corresponding RBN sector 
literal RCT$S_RCTDEF = 44;
macro RCT$Q_VOLSER = 0,0,0,0 %;
literal RCT$S_VOLSER = 8;               !  Volume serial number 
macro RCT$W_FLAGS = 8,0,16,0 %;         !  Flags word 
macro RCT$V_WB = 8,0,1,0 %;             !  Write back caching in use 
macro RCT$V_FE = 8,7,1,0 %;             !  Forced Error flag for block being replaced 
macro RCT$V_BR = 8,13,1,0 %;            !  Replacement caused by Bad RBN 
macro RCT$V_RP2 = 8,14,1,0 %;           !  Replacement in Progress phase 2 
macro RCT$V_RP1 = 8,15,1,0 %;           !  Replacement in Progress phase 1 
macro RCT$L_LBN = 12,0,32,0 %;          !  LBN curently being replaced. 
macro RCT$L_RBN = 16,0,32,0 %;          !  RBN allocated to replace LBN 
macro RCT$L_BAD_RBN = 20,0,32,0 %;      !  If BR flag, RBN of bad replacement block 
macro RCT$Q_WB_CTRL = 24,0,0,0 %;
literal RCT$S_WB_CTRL = 8;              !  Serial ! of last controller doing Write back 
macro RCT$L_WB_INCAR = 32,0,32,0 %;     !  Write back incarnation ! 
macro RCT$Q_INCARTIME = 36,0,0,0 %;
literal RCT$S_INCARTIME = 8;            !  Date-time of last update of incarnation no. 
! 
!  Structure of a Replacement Block Descriptor
! 
macro RCT$V_LBN = 36,0,28,0 %;
literal RCT$S_LBN = 28;                 !  Space for LBN replaced by this RBN 
macro RCT$V_CODE = 36,28,4,0 %;
literal RCT$S_CODE = 4;                 !  Describes how this descriptor being used 
macro RCT$V_NONPRIME = 36,28,1,0 %;     !  Set implies allocated, but not prime RBN 
macro RCT$V_ALLOCATED = 36,29,1,0 %;    !  This RBN allocated 
macro RCT$V_UNUSABLE = 36,30,1,0 %;     !  This RBN unusable 
macro RCT$V_NULL = 36,31,1,0 %;         !  This marks a NULL entry 
!  Values of CODE 
 
!*** MODULE $RDTDEF ***
! +
!  RDT - SCS RESPONSE DESCRIPTOR TABLE
! 
!  ONE RESPONSE DESCRIPTOR (RD) IS ALLOCATED FOR EACH SCS MESSAGE
!  SENT FOR WHICH THE SENDER EXPECTS A MATCHING RESPONSE.
! -
literal RDT$C_LENGTH = 24;              ! LENGTH OF NEG PORTION OF STRUCTURE 
! 
literal RDT$S_RDTDEF = 25;
macro RDT$L_WAITFL = -24,0,32,0 %;      ! RD WAIT QUEUE FWD LINK 
macro RDT$L_WAITBL = -20,0,32,0 %;      ! RD WAIT QUEUE BACK LINK 
macro RDT$W_SIZE = -16,0,16,0 %;        ! STRUCTURE SIZE IN BYTES 
macro RDT$B_TYPE = -14,0,8,0 %;         ! SCS STURCTURE TYPE 
macro RDT$B_SUBTYP = -13,0,8,0 %;       ! SCS STRUCT SUBTYPE FOR RDT 
macro RDT$L_FREERD = -12,0,32,0 %;      ! ADDR OF 1ST FREE RD 
macro RDT$L_MAXRDIDX = -8,0,32,0 %;     ! MAXIMUM ! OF DESCRIPTORS 
macro RDT$L_QRDT_CNT = -4,0,32,0 %;     ! Count of stalls because of no response ID's
 
!*** MODULE $RDDEF ***
! +
!  RD - SCS RESPONSE DESCRIPTOR FORMAT
! -
literal RD$K_LENGTH = 8;                ! LENGTH OF RD 
literal RD$C_LENGTH = 8;                ! LENGTH OF RD 
literal RD$S_RDDEF = 8;
macro RD$L_CDRP = 0,0,32,0 %;           ! ADDR OF ASSOC CDRP OR 
!  OR OTHER CONTEXT BLOCK
macro RD$L_LINK = 0,0,32,0 %;           !  OR LINK TO NEXT FREE RD 
macro RD$W_STATE = 4,0,16,0 %;          ! RD STATE FLAGS 
macro RD$V_BUSY = 4,0,1,0 %;            !  ALLOCATED IF SET 
macro RD$V_PERM = 4,1,1,0 %;            !  PERMANENTLY ALLOCATED RD IF SET 
macro RD$W_SEQNUM = 6,0,16,0 %;         ! SEQUENCE NUMBER OF RD 
 
!*** MODULE $REV8NNDEF ***
! +
!  Minimum revision levels for NAUTILUS SMP operation
! -
literal REV8NN$C_CPUMINREV = 0;         !  Minimum CPU revision for REV8NN operation
literal REV8NN$C_UCODEREV = 0;          !  Minimum microcode revision for REV8NN operation
literal REV8NN$C_UWCSREV = 0;           !  Minimum UW control storage for REV8NN
 
!*** MODULE $REV8PSDEF ***
! +
!  Minimum revision levels for POLARSTAR SMP operation
! -
literal REV8PS$C_CPUMINREV = 0;         !  Minimum CPU revision for REV8PS operation
literal REV8PS$C_UCODEREV = 0;          !  Minimum microcode revision for REV8PS operation
literal REV8PS$C_UWCSREV = 0;           !  Minimum UW control storage for REV8PS operation
 
!*** MODULE $REV8SSDEF ***
! +
!  Minimum revision levels for SCORPIO SMP operation
! -
literal REV8SS$C_CPUMINREV = 5;         !  Minimum CPU revision for SMP operation
literal REV8SS$C_UCODEREV = 20;         !  Minimum microcode revision for SMP operation
literal REV8SS$C_PATMINREV = 21;        !  Minimum ECO revision for SMP operation
literal REV825$C_CPUMINREV = 2;         !  Minimum CPU revision for SMP operation
literal REV825$C_UCODEREV = 20;         !  Minimum microcode revision for SMP operation
literal REV825$C_PATMINREV = 21;        !  Minimum ECO revision for SMP operation
 
!*** MODULE $REV9CCDEF ***
! +
!  Minimum revision levels for CALYPSO SMP operation
! -
literal REV9CC$C_CVAXMINREV = 0;        !  Minimum CVAX CPU revision for SMP operation
literal REV9CC$C_XCPFWREV = 0;          !  Minimum XCP firmware revision for SMP operation
literal REV9CC$C_XCPGAREV = 0;          !  Minimum XCP gate array revision for SMP operation
 
!*** MODULE $REV9RRDEF ***
! +
!  Minimum revision levels for CALYPSO/XRP SMP operation
! -
literal REV9RR$C_RVAXMINREV = 0;        !  Minimum RVAX CPU revision for SMP operation
literal REV9RR$C_XSID_XRPFWREV = 16;    !  Minimum XRP console revision
literal REV9RR$C_XRPFWREV = 0;          !  Minimum XRP firmware revision
literal REV9RR$C_XRPXCAREV = 0;         !  Minimum XCA chip revision for SMP operation
 
!*** MODULE $REV9AQDEF ***
! +
!  Minimum revision levels for AQUARIUS operation
! -
literal REV9AQ$C_REVLVL = 0;            !  Minimum System Revision (in SID)
 
!*** MODULE $RGBDEF ***
! +
!  RGB - Range Block
! 
!  Range Block is a user defined structure passed by reference to the Lock
!  Manager $enq, $enqw and $deq system system services via the optional [RANGE]
!  argument. 
!  The Range Block specifies a relative start and length of a resource range 
!  to be locked, converted or unlocked.
! -
literal RGB$C_LENGTH = 16;              ! LENGTH OF FIXED PART
literal RGB$K_LENGTH = 16;              ! LENGTH OF FIXED PART
literal RGB$K_MAXRANGE = -1;            ! Maximum range of resource
literal RGB$S_RGBDEF = 16;
macro RGB$Q_START = 0,0,0,0 %;
literal RGB$S_START = 8;                !  relative start of range to lock
macro RGB$Q_LENGTH = 8,0,0,0 %;
literal RGB$S_LENGTH = 8;               !  length of range to lock
 
!*** MODULE $RPBDEF ***
! +
!  RESTART PARAMETER BLOCK DEFINITIONS
! -
literal RPB$M_CONV = 1;
literal RPB$M_DEBUG = 2;
literal RPB$M_INIBPT = 4;
literal RPB$M_BBLOCK = 8;
literal RPB$M_DIAG = 16;
literal RPB$M_BOOBPT = 32;
literal RPB$M_HEADER = 64;
literal RPB$M_NOTEST = 128;
literal RPB$M_SOLICT = 256;
literal RPB$M_HALT = 512;
literal RPB$M_NOPFND = 1024;
literal RPB$M_MPM = 2048;
literal RPB$M_USEMPM = 4096;
literal RPB$M_MEMTEST = 8192;
literal RPB$M_FINDMEM = 16384;
literal RPB$M_AUTOTEST = 32768;
literal RPB$M_CRDTEST = 65536;
literal RPB$M_DIFSYSDEV = 131072;
literal RPB$M_BOOTLOG = 262144;
literal RPB$M_TOPSYS = -268435456;
literal RPB$M_NOSYSDISK = 1;
literal RPB$M_PERCPU_VEC = 2;
literal RPB$M_CRAMIO = 4;
literal RPB$M_FILL_TEMP = 8;
literal RPB$M_INTLCK_EMUL = 16;
literal RPB$C_MEMDSCSIZ = 8;            ! NUMBER OF BYTES IN ONE MEM DESCRIPTOR 
literal RPB$C_NMEMDSC = 8;              ! NUMBER OF MEMORY DESCRIPTORS IN RPB 
literal RPB$K_LENGTH = 284;             ! LENGTH OF RPB 
literal RPB$C_LENGTH = 284;             ! LENGTH OF RPB 
literal RPB$S_RPBDEF = 284;
macro RPB$L_BASE = 0,0,32,0 %;          ! PHYSICAL BASE ADDRESS OF 64K BLOCK 
macro RPB$L_RESTART = 4,0,32,0 %;       ! POINTER TO RESTART ROUTINE (PHYSICAL) 
macro RPB$L_CHKSUM = 8,0,32,0 %;        ! CHECKSUM OF BYTES 0-7F OF RESTART ROUTINE 
macro RPB$L_RSTRTFLG = 12,0,32,0 %;     ! RESTART IN PROGRESS FLAG 
macro RPB$L_HALTPC = 16,0,32,0 %;       ! PC AT RESTART/HALT 
macro RPB$L_HALTPSL = 20,0,32,0 %;      ! PSL AT RESTART/HALT 
macro RPB$L_HALTCODE = 24,0,32,0 %;     ! CODE DESCRIBING RESTART REASON 
macro RPB$L_BOOTR0 = 28,0,32,0 %;       ! SAVED BOOT PARAMETER R0 
macro RPB$B_R0DEVTYP = 28,0,8,0 %;      !  DEVICE TYPE SUBFIELD 
macro RPB$W_R0UBVEC = 30,0,16,0 %;      !  UNIBUS INT VECTOR SUBFIELD 
macro RPB$L_BOOTR1 = 32,0,32,0 %;       ! SAVED BOOT PARAMETER R1 
macro RPB$V_NEXUS = 32,0,4,0 %;
literal RPB$S_NEXUS = 4;                ! NEXUS OF SYSTEM DEVICE ADAPTER 
macro RPB$V_ABUS = 32,4,2,0 %;
literal RPB$S_ABUS = 2;                 ! ABUS ADAPTER NUMBER OF SBIA 
macro RPB$L_BOOTR2 = 36,0,32,0 %;       ! SAVED BOTT PARAMETER R2 
macro RPB$L_BOOTR3 = 40,0,32,0 %;       ! SAVED BOOT PARAMETER R3 
macro RPB$L_BOOTR4 = 44,0,32,0 %;       ! SAVED BOOT PARAMETER R4 
macro RPB$L_BOOTR5 = 48,0,32,0 %;       ! SAVED BOOT PARAMETER R5 
macro RPB$V_CONV = 48,0,1,0 %;          !  CONVERSATIONAL BOOTSTRAP 
macro RPB$V_DEBUG = 48,1,1,0 %;         !  KEEP DEBUGGER CODE 
macro RPB$V_INIBPT = 48,2,1,0 %;        !  INITIAL BREAKPOINT 
macro RPB$V_BBLOCK = 48,3,1,0 %;        !  TRANSFER TO BOOTBLOCK 
macro RPB$V_DIAG = 48,4,1,0 %;          !  BOOT DIAGNOSTIC FILE 
macro RPB$V_BOOBPT = 48,5,1,0 %;        !  BOOTSTRAP BREAKPOINT 
macro RPB$V_HEADER = 48,6,1,0 %;        !  USE START ADDRESS FROM IMAGE HEADER 
macro RPB$V_NOTEST = 48,7,1,0 %;        !  FLAG TO INHIBIT MEMORY TESTING 
macro RPB$V_SOLICT = 48,8,1,0 %;        !  SOLICIT BOOT FILE NAME 
macro RPB$V_HALT = 48,9,1,0 %;          !  HALT BEFORE TRANSFER 
macro RPB$V_NOPFND = 48,10,1,0 %;       !  INHIBIT PFN DELETION 
macro RPB$V_MPM = 48,11,1,0 %;          !  ASMP BOOT, USE MA780 ONLY 
macro RPB$V_USEMPM = 48,12,1,0 %;       !  USE MA780 AS IF IT WERE LOCAL MEMORY 
macro RPB$V_MEMTEST = 48,13,1,0 %;      !  USE STRICTER TEST TO VALIDATE MEMORY 
macro RPB$V_FINDMEM = 48,14,1,0 %;      !  FIND SUFFICIENT MEMORY TO BOOT (>512K) 
macro RPB$V_AUTOTEST = 48,15,1,0 %;     !  USED BY DIAGNOSTIC SUPERVISOR
macro RPB$V_CRDTEST = 48,16,1,0 %;      !  REMOVE PAGES WITH CRD ERRORS
macro RPB$V_DIFSYSDEV = 48,17,1,0 %;    !  SYSTEM DISK DIFFERENT FROM BOOT DEVICE
macro RPB$V_BOOTLOG = 48,18,1,0 %;      !  SELF TEST STATUS MESSAGES
macro RPB$V_TOPSYS = 48,28,4,0 %;
literal RPB$S_TOPSYS = 4;               ! SYSTEM DIRECTORY NUMBER 
macro RPB$L_IOVEC = 52,0,32,0 %;        ! ADDRESS OF BOOTSTRAP QIO VECTOR 
macro RPB$L_IOVECSZ = 56,0,32,0 %;      ! SIZE OF BOOT QIO ROUTINE 
macro RPB$L_FILLBN = 60,0,32,0 %;       ! LOGICAL BLOCK NUMBER OF BOOT FILE 
macro RPB$L_FILSIZ = 64,0,32,0 %;       ! SIZE OF BOOT FILE 
macro RPB$Q_PFNMAP = 68,0,0,0 %;
literal RPB$S_PFNMAP = 8;               ! DESCRIPTOR FOR PFN BITMAP 
macro RPB$L_PFNCNT = 76,0,32,0 %;       ! COUNT OF PHYSICAL PAGES 
macro RPB$L_SVASPT = 80,0,32,0 %;       ! SYSTEM VIRTUAL ADDRESS OF SPT 
macro RPB$L_CSRPHY = 84,0,32,0 %;       ! UBA DEVICE CSR ADDRESS (PHYSICAL) 
macro RPB$L_CSRVIR = 88,0,32,0 %;       ! UBA DEVICE CSR ADDRESS (VIRTUAL) 
macro RPB$L_ADPPHY = 92,0,32,0 %;       ! ADAPTER CONFIGURATION REGISTER (PHYSICAL) 
macro RPB$L_ADPVIR = 96,0,32,0 %;       ! ADAPTER CONFIGURATION REGISTER (VIRTUAL) 
macro RPB$W_UNIT = 100,0,16,0 %;        ! UNIT NUMBER 
macro RPB$B_DEVTYP = 102,0,8,0 %;       ! DEVICE TYPE CODE 
macro RPB$B_SLAVE = 103,0,8,0 %;        ! SLAVE UNIT NUMBER 
macro RPB$T_FILE = 104,0,0,0 %;
literal RPB$S_FILE = 40;                ! BOOT FILE NAME (ASCIC) 
macro RPB$B_CONFREG = 144,0,0,0 %;
literal RPB$S_CONFREG = 16;             ! ARRAY OF ADAPTER TYPES 
macro RPB$B_HDRPGCNT = 160,0,8,0 %;     ! COUNT OF HEADER PAGES 
macro RPB$W_BOOTNDT = 161,0,16,0 %;     ! 16-BIT BOOT ADAPTER NEXUS DEVICE TYPE
macro RPB$B_BOOTNDT = 161,0,8,0 %;      !  8-BIT BOOT ADAPTER NEXUS DEVICE TYPE
macro RPB$B_FLAGS = 163,0,8,0 %;        ! MISCELLANEOUS FLAG BITS
macro RPB$V_NOSYSDISK = 163,0,1,0 %;    !  BOOT DISK IS NOT PRESENT
macro RPB$V_PERCPU_VEC = 163,1,1,0 %;   !  SET=>CPUDBVEC POINTS TO VECTOR OF DATABASES
!  CLR=>CPUDBVEC POINTS TO PRIMARY'S DATABASE
macro RPB$V_CRAMIO = 163,2,1,0 %;       !  BOOT DEVICE USES CRAM
macro RPB$V_FILL_TEMP = 163,3,1,0 %;    !  PLACEHOLDER FOR EXTENDED MEMORY MODE
macro RPB$V_INTLCK_EMUL = 163,4,1,0 %;  !  BOOT DEVICE REQUIRES INTERLOCK EMULATION
macro RPB$L_ISP = 164,0,32,0 %;         !      <OFFSET IS OBSOLETED BY SMP>
macro RPB$L_MAX_PFN = 164,0,32,0 %;     ! ABSOLUTE HIGHEST PFN
macro RPB$L_PCBB = 168,0,32,0 %;        !      <OFFSET IS OBSOLETED BY SMP>
macro RPB$L_SPTEP = 168,0,32,0 %;       ! SYSTEM SPACE PTE PROTOTYPE REGISTER
macro RPB$L_SBR = 172,0,32,0 %;         ! SYSTEM BASE REGISTER 
macro RPB$L_SCBB = 176,0,32,0 %;        !      <OFFSET IS OBSOLETED BY SMP>
macro RPB$L_CPUDBVEC = 176,0,32,0 %;    ! PHYSICAL PER-CPU DATABASE VECTOR PA,
! OR PA OF PRIMARY'S PER-CPU DATABASE
macro RPB$L_SISR = 180,0,32,0 %;        !      <OFFSET IS OBSOLETED BY SMP>
macro RPB$L_CCA_ADDR = 180,0,32,0 %;    ! ADDRESS OF CCA (CALYPSO)
macro RPB$L_CSL_SAVE_AREA = 180,0,32,0 %; ! CONSOLE STATE SAVE AREA POINTER
macro RPB$L_HWRPB_ADDR = 180,0,32,0 %;  ! ADDRESS OF HWRPB (LASER)
macro RPB$L_SLR = 184,0,32,0 %;         ! SYSTEM LENGTH REGISTER 
macro RPB$L_MEMDSC = 188,0,0,0 %;
literal RPB$S_MEMDSC = 64;              ! MEMORY DESCRIPT. - PAGCNT, TR, BASE PFN 
macro RPB$V_PAGCNT = 188,0,24,0 %;
literal RPB$S_PAGCNT = 24;              !  COUNT OF PAGES FOR THIS MEMORY 
macro RPB$V_TR = 188,24,8,0 %;
literal RPB$S_TR = 8;                   !  TR NUMBER FOR THIS MEMORY 
macro RPB$V_BASEPFN = 192,0,32,0 %;
literal RPB$S_BASEPFN = 32;             !  BASE PFN FOR THIS MEMORY 
macro RPB$L_BUGCHK = 252,0,32,0 %;      ! 	<OFFSET IS OBSOLETED BY SMP>
macro RPB$L_SMP_PC = 252,0,32,0 %;      ! SMP BOOT PAGE PHYSICAL ADDRESS
macro RPB$B_WAIT = 256,0,32,0 %;
literal RPB$S_WAIT = 4;                 ! SECONDARY CPU TRANSFERS TO CODE HERE
macro RPB$L_BADPGS = 260,0,32,0 %;      ! NUMBER OF BAD PAGES FOUND IN MEM SCAN
macro RPB$B_CTRLLTR = 264,0,8,0 %;      ! CONTROLLER LETTER DESIGNATOR
macro RPB$B_SCBPAGCT = 265,0,8,0 %;     ! SCB PAGE COUNT
macro RPB$B_LAN_CTRLLTR = 266,0,8,0 %;  ! Controller letter designator for the LAN adapter.
macro RPB$B_XTRA_B = 267,0,8,0 %;       ! SPARE BYTE
macro RPB$L_XTRA_L = 268,0,32,0 %;      ! SPARE LONGWORD
macro RPB$L_VMB_REVISION = 272,0,32,0 %; ! VMB REVISION LEVEL -- FORMAT VARIES 
!  BETWEEN MAIN VMB AND MICROVAX VMB'S. 
macro RPB$L_MBPRPHY = 276,0,32,0 %;     !  MAILBOX POINTER REGISTER (PHYSICAL)
macro RPB$L_MBPRVIR = 280,0,32,0 %;     !  MAILBOX POINTER REGISTER (VIRTUAL)
 
!*** MODULE $RSBDEF ***
! +
!  RSB - RESOURCE BLOCK
! 
!  RESOURCE BLOCKS REPRESENT RESOURCES FOR WHICH THERE ARE LOCKS OUTSTANDING.
!  EACH RESOURCE BLOCK MAY HAVE ONE OR MORE LOCK BLOCKS (LKB) QUEUED TO IT.
! -
literal RSB$M_DIRENTRY = 1;
literal RSB$M_VALINVLD = 2;
literal RSB$M_DIR_RQD = 4;
literal RSB$M_RM_PEND = 8;
literal RSB$M_RM_IP = 16;
literal RSB$M_RM_ACCEPT = 32;
literal RSB$M_RM_RBLD = 64;
literal RSB$M_RM_WAIT = 128;
literal RSB$M_RM_DEFLECT = 256;
literal RSB$M_DIR_IP = 512;
literal RSB$M_RBLD_IP = 1024;
literal RSB$M_RBLD_RQD = 2048;
literal RSB$M_RBLD_ACT = 4096;
literal RSB$M_CHK_BTR = 8192;
literal RSB$K_MAXLEN = 31;              ! MAXIMUM LENGTH OF RESOURCE NAME 
literal RSB$M_BRL2 = 1;
literal RSB$M_WTFULRNG2 = 2;
literal RSB$M_WTSUBRNG2 = 4;
literal RSB$M_ENBSUBRNG2 = 8;
literal RSB$M_INHSUBRNG2 = 16;
literal RSB$M_2PC_IP2 = 32;
literal RSB$M_CVTFULRNG2 = 64;
literal RSB$M_CVTSUBRNG2 = 128;
literal RSB$M_VALCUR2 = 256;
literal RSB$M_INVPEND2 = 512;
literal RSB$K_LENGTH = 163;             ! LENGTH OF FIXED PART OF RSB 
literal RSB$C_LENGTH = 163;             ! LENGTH OF FIXED PART OF RSB 
literal RSB$S_RSBDEF = 163;
macro RSB$L_HSHCHN = 0,0,32,0 %;        ! HASH CHAIN 
macro RSB$L_HSHCHNBK = 4,0,32,0 %;      ! HASH CHAIN BACK POINTER 
macro RSB$W_SIZE = 8,0,16,0 %;          ! SIZE OF RSB 
macro RSB$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE 
macro RSB$B_DEPTH = 11,0,8,0 %;         ! DEPTH IN TREE 
macro RSB$B_GGMODE = 12,0,8,0 %;        ! GROUP GRANT MODE 
macro RSB$B_CGMODE = 13,0,8,0 %;        ! CONVERSION GRANT MODE 
macro RSB$W_STATUS = 14,0,16,0 %;       ! STATUS
macro RSB$V_DIRENTRY = 14,0,1,0 %;      !  ENTERED IN DIR. DURING FAILOVER
macro RSB$V_VALINVLD = 14,1,1,0 %;      !  VALUE BLOCK INVALID
macro RSB$V_DIR_RQD = 14,2,1,0 %;       !  DIRECTORY ENTRY REQUIRED
macro RSB$V_RM_PEND = 14,3,1,0 %;       !  RESOURCE REMASTER OP PENDING
macro RSB$V_RM_IP = 14,4,1,0 %;         !  RESOURCE BEING REMASTERED
macro RSB$V_RM_ACCEPT = 14,5,1,0 %;     !  NEW MASTER ACCEPTS
macro RSB$V_RM_RBLD = 14,6,1,0 %;       !  ALWAYS REBUILD TREE
macro RSB$V_RM_WAIT = 14,7,1,0 %;       !  BLOCK LOCAL ACTIVITY
macro RSB$V_RM_DEFLECT = 14,8,1,0 %;    !  DEFLECT REMOTE INTEREST
macro RSB$V_DIR_IP = 14,9,1,0 %;        !  DIRECTORY ENTRY BEING CREATED
macro RSB$V_RBLD_IP = 14,10,1,0 %;      !  REBUILD IN PROGRESS
macro RSB$V_RBLD_RQD = 14,11,1,0 %;     !  REBUILD REQUIRED FOR THIS TREE
macro RSB$V_RBLD_ACT = 14,12,1,0 %;     !  LOCK RBLD ACTIVE FOR TREE
macro RSB$V_CHK_BTR = 14,13,1,0 %;      !  CHECK FOR BETTER MASTER
macro RSB$L_GRQFL = 16,0,32,0 %;        ! GRANTED QUEUE FORWARD LINK 
macro RSB$L_GRQBL = 20,0,32,0 %;        ! GRANTED QUEUE BACKWARD LINK 
macro RSB$L_CVTQFL = 24,0,32,0 %;       ! CONVERSION QUEUE FORWARD LINK 
macro RSB$L_CVTQBL = 28,0,32,0 %;       ! CONVERSION QUEUE BACKWARD LINK 
macro RSB$L_WTQFL = 32,0,32,0 %;        ! WAIT QUEUE FORWARD LINK 
macro RSB$L_WTQBL = 36,0,32,0 %;        ! WAIT QUEUE BACKWARD LINK 
macro RSB$Q_VALBLK = 40,0,0,0 %;
literal RSB$S_VALBLK = 8;               ! VALUE BLOCK 
macro RSB$L_CSID = 56,0,32,0 %;         ! SYSTEM ID OF MASTER SYS.
macro RSB$L_RRSFL = 60,0,32,0 %;        ! ROOT LIST FORWARD LINK 
macro RSB$L_RRSBL = 64,0,32,0 %;        ! ROOT LIST BACKWARD LINK 
macro RSB$L_SRSFL = 68,0,32,0 %;        ! TREE LIST FORWARD LINK 
macro RSB$L_SRSBL = 72,0,32,0 %;        ! TREE LIST BACKWARD LINK 
macro RSB$L_RM_CSID = 76,0,32,0 %;      ! PENDNG REMASTER CSID
macro RSB$L_RTRSB = 80,0,32,0 %;        ! POINTER TO ROOT RSB
macro RSB$L_CLURCB = 84,0,32,0 %;       ! REMASTER CONTROL BLOCK
macro RSB$W_ACTIVITY = 88,0,16,0 %;     ! RESOURCE ACTIVITY COUNTER
macro RSB$W_LCKCNT = 90,0,16,0 %;       ! COUNT OF LOCKS ON RESOURCE
macro RSB$L_VALSEQNUM = 92,0,32,0 %;    ! VALUE BLOCK SEQ. NUMBER
macro RSB$W_REFCNT = 96,0,16,0 %;       ! SUB RSB REFERENCE COUNT 
macro RSB$W_BLKASTCNT = 98,0,16,0 %;    ! BLOCKING AST COUNT 
macro RSB$W_HASHVAL = 100,0,16,0 %;     ! HASH VALUE
macro RSB$W_RQSEQNM = 102,0,16,0 %;     ! REQUEST SEQUENCE NUMBER
macro RSB$L_PARENT = 104,0,32,0 %;      ! ADDRESS OF PARENT RSB 
macro RSB$W_GROUP = 108,0,16,0 %;       ! GROUP NUMBER 
macro RSB$B_RMOD = 110,0,8,0 %;         ! ACCESS MODE OF RESOURCE 
macro RSB$B_RSNLEN = 111,0,8,0 %;       ! RESOURCE NAME LENGTH 
macro RSB$T_RESNAM = 112,0,0,0 %;
literal RSB$S_RESNAM = 32;              ! START OF RESOURCE NAME 
macro RSB$L_2PCQFL = 144,0,32,0 %;      ! Que of 2PC ops is progress
macro RSB$L_2PCQBL = 148,0,32,0 %;      ! 
macro RSB$W_NACT = 152,0,16,0 %;        ! NEW ACTIVITY
macro RSB$W_OACT = 154,0,16,0 %;        ! OLD (historical) ACTIVITY
macro RSB$W_NMACT = 156,0,16,0 %;       ! NEW MASTER'S ACTIVITY
macro RSB$B_LSTCSID_IDX = 158,0,8,0 %;  ! LAST CSID INDEX
macro RSB$B_SAME_CNT = 159,0,8,0 %;     ! SAME NODE COUNTER
macro RSB$W_STAT2 = 160,0,16,0 %;       ! High word of status
macro RSB$V_BRL2 = 160,0,1,0 %;         !  indicates byte range resource
macro RSB$V_WTFULRNG2 = 160,1,1,0 %;    !  FULL-RANGE REQs IN WAIT QUE
macro RSB$V_WTSUBRNG2 = 160,2,1,0 %;    !  SUB-RANGE REQs IN WAIT QUE
macro RSB$V_ENBSUBRNG2 = 160,3,1,0 %;   !  sub-range locking enabled
macro RSB$V_INHSUBRNG2 = 160,4,1,0 %;   !  sub-range locking inhibited
macro RSB$V_2PC_IP2 = 160,5,1,0 %;      !  Two Phase CVT In Progress
macro RSB$V_CVTFULRNG2 = 160,6,1,0 %;   !  FULL-RANGE REQs IN CVT QUE
macro RSB$V_CVTSUBRNG2 = 160,7,1,0 %;   !  SUB-RANGE REQs IN CVT QUE
macro RSB$V_VALCUR2 = 160,8,1,0 %;      !  value block is current
macro RSB$V_INVPEND2 = 160,9,1,0 %;     !  do valblk invalidation chk
macro RSB$B_FGMODE = 162,0,8,0 %;       ! FULL-RANGE GRANT MODE
 
!*** MODULE $RSNDEF ***
! +
!  RESOURCE NAME DEFINITIONS
! -
! 0 ORIGIN IN INCREMENTS OF 1 
literal RSN$_ASTWAIT = 1;               ! WAIT FOR AST EVENT, CHANNEL INTERLOCK 
literal RSN$_MAILBOX = 2;               ! MAILBOX SPACE 
literal RSN$_NPDYNMEM = 3;              ! NON-PAGED DYNAMIC MEMORY 
literal RSN$_PGFILE = 4;                ! PAGING FILE SPACE 
literal RSN$_PGDYNMEM = 5;              ! PAGED DYNAMIC MEMORY 
literal RSN$_BRKTHRU = 6;               ! TERMINAL BROADCAST 
literal RSN$_IACLOCK = 7;               ! IMAGE ACTIVATION INTERLOCK 
literal RSN$_JQUOTA = 8;                ! JOB POOLED QUOTA 
literal RSN$_LOCKID = 9;                ! LOCKIDS 
literal RSN$_SWPFILE = 10;              ! SWAPPING FILE SPACE 
literal RSN$_MPLEMPTY = 11;             ! MODIFIED PAGE LIST EMPTY 
literal RSN$_MPWBUSY = 12;              ! MODIFIED PAGE WRITER BUSY 
literal RSN$_SCS = 13;                  ! SYSTEM COMMUNICATION
literal RSN$_CLUSTRAN = 14;             ! CLUSTER STATE TRANSITION
literal RSN$_CPUCAP = 15;               ! CPU Capability
literal RSN$_CLUSRV = 16;               ! CLUSTER SERVER
literal RSN$_SNAPSHOT = 17;             ! 
literal RSN$_MAX = 18;                  ! MAXIMUM RESOURCE NUMBER 
 
!*** MODULE $RVTDEF ***
! +
!  RVT - RELATIVE VOLUME TABLE
! 
!  A RELATIVE VOLUME MAPPING TABLE IS REQUIRED FOR EVERY MULTIVOLUME
!  STRUCTURE THAT IS MOUNTED IN A SYSTEM.
! -
literal RVT$K_LENGTH = 68;              !  LENGTH OF STANDARD RVT 
literal RVT$C_LENGTH = 68;              !  LENGTH OF STANDARD RVT 
literal RVT$C_MINSIZE = 18;             !  MINIMUM NUMBER OF ENTRIES TO ALLOCATE 
literal RVT$S_RVTDEF = 72;
macro RVT$L_STRUCLKID = 0,0,32,0 %;     !  LOCK ID OF VOLUME SET LOCK.
macro RVT$W_REFC = 4,0,16,0 %;          !  REFERENCE COUNT 
macro RVT$W_ACTIVITY = 6,0,16,0 %;      !  ACTIVITY COUNT/FLAG
macro RVT$W_SIZE = 8,0,16,0 %;          !  SIZE OF RVT IN BYTES 
macro RVT$B_TYPE = 10,0,8,0 %;          !  STRUCTURE TYPE OF RVT 
macro RVT$B_NVOLS = 11,0,8,0 %;         !  NUMBER OF VOLUMES IN SET 
macro RVT$T_STRUCNAME = 12,0,0,0 %;
literal RVT$S_STRUCNAME = 12;           !  STRUCTURE (VOLUME SET) NAME 
macro RVT$T_VLSLCKNAM = 24,0,0,0 %;
literal RVT$S_VLSLCKNAM = 12;           !  Volume set lock name.
macro RVT$L_BLOCKID = 36,0,32,0 %;      !  Blocking lock id.
macro RVT$B_ACB = 40,0,0,0 %;
literal RVT$S_ACB = 28;                 !  ACB for blocking ast.
macro RVT$R_TRANS_STRUCT = 40,0,0,0 %;
literal RVT$S_TRANS_STRUCT = 10;        !  Share ACB$W_SIZE field
macro RVT$B_FILLER = 40,0,0,0 %;
literal RVT$S_FILLER = 8;
macro RVT$W_TRANS = 48,0,16,0 %;        !  Transaction count for volume sets
macro RVT$L_UCBLST = 68,0,32,0 %;       !  ADDRESSES OF THE RESPECTIVE UCB'S 
 
!*** MODULE $SBDEF ***
! +
!  SB - SCS SYSTEM BLOCK
! 
!  THE SB HAS INFORMATION ABOUT KNOWN SYSTEMS IN A CPU CLUSTER.
! -
literal SB$K_LENGTH = 100;              ! LENGTH OF SB 
literal SB$C_LENGTH = 100;              ! LENGTH OF SB 
literal SB$S_SBDEF = 100;
macro SB$L_FLINK = 0,0,32,0 %;          ! FWD LINK TO NEXT SB 
macro SB$L_BLINK = 4,0,32,0 %;          ! BACK LINK TO PREVIOUS SB 
macro SB$W_SIZE = 8,0,16,0 %;           ! STRUCTURE SIZE IN BYTES 
macro SB$B_TYPE = 10,0,8,0 %;           ! SCS STRUCTURE TYPE 
macro SB$B_SUBTYP = 11,0,8,0 %;         ! SCS STRUCT SUBTYPE FOR SB 
macro SB$L_PBFL = 12,0,32,0 %;          ! LINK TO NEXT PATH BLOCK 
macro SB$L_PBBL = 16,0,32,0 %;          ! LINK TO PREVIOUS PATH BLOCK 
macro SB$L_PBCONNX = 20,0,32,0 %;       ! ADDR OF NEXT PB TO USE FOR 
!  A CONNECTION
macro SB$B_SYSTEMID = 24,0,0,0 %;
literal SB$S_SYSTEMID = 6;              ! SYSTEM ID 
macro SB$W_MAXDG = 32,0,16,0 %;         ! MAXIMUM DATAGRAM SIZE 
macro SB$W_MAXMSG = 34,0,16,0 %;        ! MAXIMUM MESSAGE SIZE 
macro SB$T_SWTYPE = 36,0,32,0 %;
literal SB$S_SWTYPE = 4;                ! SOFTWARE TYPE, 1-4 CHAR 
macro SB$T_SWVERS = 40,0,32,0 %;
literal SB$S_SWVERS = 4;                ! SOFTWARE VERSION, 1-4 CHAR 
macro SB$Q_SWINCARN = 44,0,0,0 %;
literal SB$S_SWINCARN = 8;              ! SOFTWARE INCARNATION # 
macro SB$T_HWTYPE = 52,0,32,0 %;
literal SB$S_HWTYPE = 4;                ! HW TYPE; 1-4 CHAR, BLANK FILL
macro SB$B_HWVERS = 56,0,0,0 %;
literal SB$S_HWVERS = 12;               ! HW VERSION #
macro SB$T_NODENAME = 68,0,0,0 %;
literal SB$S_NODENAME = 16;             ! SCS NODENAME, COUNTED ASCII STRING
macro SB$L_DDB = 84,0,32,0 %;           ! DDB LIST HEAD
macro SB$W_TIMEOUT = 88,0,16,1 %;       ! SCA PROCESS POLLER, WAITING TIME REMAINING
macro SB$B_ENBMSK = 90,0,16,0 %;
literal SB$S_ENBMSK = 2;                ! SCA PROCESS POLLER, PROCESS ENABLE MASK
macro SB$L_CSB = 92,0,32,0 %;           ! LINK TO NEWEST CLUSTER SYSTEM BLOCK
macro SB$L_PORT_MAP = 96,0,32,0 %;      !  (TYC 13-Feb-89) LOAD SHARING PORT BIT MAP
 
!*** MODULE $SBNBDEF ***
! +
!  SBNB - SCA LOAD SHARING NAME BLOCK
! 
!  THIS DATA STRUCTURE DESCRIBES A PROCESS NAME KNOWN TO THE SCA
!  DYNAMIC LOAD SHARING CODE. 
! -
literal SBNB$K_LENGTH = 36;
literal SBNB$C_LENGTH = 36;
literal SBNB$S_SBNBDEF = 36;
macro SBNB$L_FLINK = 0,0,32,0 %;        ! FWD LINK 
macro SBNB$L_BLINK = 4,0,32,0 %;        ! BCK LINK 
macro SBNB$W_SIZE = 8,0,16,0 %;         ! STRUCTURE SIZE IN BYTES 
macro SBNB$B_TYPE = 10,0,8,0 %;         ! SCS STRUCTURE TYPE 
macro SBNB$B_SUBTYP = 11,0,8,0 %;       ! SCS STRUCTURE SUBTYPE FOR SBNB
macro SBNB$B_PROCNAM = 12,0,0,0 %;
literal SBNB$S_PROCNAM = 16;            ! ASCII STRING FOR PROCESS NAME 
macro SBNB$W_LOCAL_INDEX = 28,0,16,0 %; ! BIT ASSIGNED TO THIS PROCESS NAME
macro SBNB$L_DISCON_COUNT = 30,0,32,0 %; ! (TYC 13-Feb-89) # OF DISCONNECT 
!  DUE TO LOAD SHARING ACTIVITY
 
!*** MODULE $SBODEF ***
! +
!  SBO - SCS CONFIG_SYS OUTPUT ARRAY FORMAT
! 
!  THE OUTPUT ARRAY RETURNED FROM CALL TO SCS$CONFIG_SYS.  DATA IS MOSTLY COPIED FROM 
!  THE SYSTEM BLOCK (SB) BEING LOOKED UP.
! -
literal SBO$C_VC1 = 60;                 ! START OF 12 BYTE SPECIFIER OF
literal SBO$K_VC1 = 60;                 !  1ST VC (PATH BLK) TO SYSTEM
literal SBO$K_LENGTH = 80;              ! LENGTH OF SBO ARRAY
literal SBO$C_LENGTH = 80;              ! LENGTH OF SBO ARRAY
literal SBO$S_SBODEF = 80;
macro SBO$B_SYSTEMID = 0,0,0,0 %;
literal SBO$S_SYSTEMID = 6;             ! SYSTEM ID
macro SBO$W_MAXDG = 8,0,16,0 %;         ! MAXIMUM DG SIZE
macro SBO$W_MAXMSG = 10,0,16,0 %;       ! MAXIMUM MSG SIZE
macro SBO$T_SWTYPE = 12,0,32,0 %;
literal SBO$S_SWTYPE = 4;               ! SW TYPE, 1-4 CHAR, BLNK FILL
macro SBO$T_SWVERS = 16,0,32,0 %;
literal SBO$S_SWVERS = 4;               ! SW VERSION, 1-4 CHAR, BLNK FILL
macro SBO$Q_SWINCARN = 20,0,0,0 %;
literal SBO$S_SWINCARN = 8;             ! SW INCARNATION #
macro SBO$T_HWTYPE = 28,0,32,0 %;
literal SBO$S_HWTYPE = 4;               ! HW TYPE, 1-4 CHAR BLNK FILL
macro SBO$B_HWVERS = 32,0,0,0 %;
literal SBO$S_HWVERS = 12;              ! HW VERSION, 1-4 CHAR BLNK FILL
macro SBO$T_NODENAME = 44,0,0,0 %;
literal SBO$S_NODENAME = 16;            ! NODE NAME, COUNTED ASCII STRING
macro SBO$B_RSTATION1 = 60,0,0,0 %;
literal SBO$S_RSTATION1 = 6;            ! REMOTE STATION OF 1ST VC
macro SBO$T_LPORT1 = 68,0,32,0 %;
literal SBO$S_LPORT1 = 4;               ! LOCAL PORT NAME OF 1ST VC
macro SBO$B_NXT_SYSID = 72,0,0,0 %;
literal SBO$S_NXT_SYSID = 6;            ! ID OF NEXT SYSTEM IN CONFIGURATION
 
!*** MODULE $SCDRPDEF ***
! +
!  SCDRP - SCSI CLASS DRIVER I/O REQUEST PACKET
! 
!  This structure contains SCSI class driver request packet, which is used
!  to pass parameters between the SCSI class and port drivers. In addition,
!  the drivers use it to save information temporarily during the execution
!  of a SCSI command.
!                                               
!  Note: unlike the class driver request packet (SCDRP), this structure does
!  NOT contain an IRP accessed at negative offsets from the base of the packet.
!  Instead, several IRP fields used in the SCDRP are located at positive offsets
!  from the base.
! 
!  ***NOTE:**** IF AN INCOMPATIBLE CHANGE IS MADE TO THIS STRUCTURE BUMP
!               THE VERSION NUMBER OF THIS STRUCTURE.
!                                                                       
! -
literal SCDRP$C_VERSION = 2;            ! COMPATIBLE VERSION NUMBER.
literal SCDRP$K_SCDRPBASE = 0;
literal SCDRP$C_SCDRPBASE = 0;
literal SCDRP$M_S0BUF = 1;
literal SCDRP$M_BUFFER_MAPPED = 2;
literal SCDRP$M_DISK_SPUN_UP = 4;
literal SCDRP$M_LOCK = 8;
literal SCDRP$M_MREG_DONE = 16;
literal SCDRP$M_ONEBYTE = 32;
literal SCDRP$M_IDENTIFY = 1;
literal SCDRP$M_SYNC_OUT = 2;
literal SCDRP$M_BUS_DEVICE_RESET = 4;
literal SCDRP$M_MESSAGE_PARITY_ERROR = 8;
literal SCDRP$M_ID_ERROR = 16;
literal SCDRP$M_ABORT = 32;
literal SCDRP$M_NOP = 64;
literal SCDRP$M_MESSAGE_REJECT = 128;
literal SCDRP$M_LAST_MSGO_BIT = 256;
literal SCDRP$M_SYNC_IN = 1;
literal SCDRP$K_SCSI_LEN = 368;
literal SCDRP$C_SCSI_LEN = 368;
literal SCDRP$K_LENGTH = 412;
literal SCDRP$C_LENGTH = 412;
literal SCDRP$S_SCDRPDEF = 412;
macro SCDRP$L_FQFL = 0,0,32,0 %;        !  Fork Queue FLINK 
macro SCDRP$L_FQBL = 4,0,32,0 %;        !  Fork Queue Blink 
macro SCDRP$W_SCDRPSIZE = 8,0,16,0 %;   !  Size field for positive section only 
macro SCDRP$B_CD_TYPE = 10,0,8,0 %;     !  Type, always of interest 
macro SCDRP$B_FLCK = 11,0,8,0 %;        !  Fork lock
macro SCDRP$B_FIPL = 11,0,8,0 %;        !  Fork IPL
macro SCDRP$L_FPC = 12,0,32,0 %;        !  Fork PC 
macro SCDRP$L_FR3 = 16,0,32,0 %;        !  Fork R3 
macro SCDRP$L_FR4 = 20,0,32,0 %;        !  Fork R4 
!  Thie following field must follow immediately after the fork block for use
!  by MKDRIVER.
macro SCDRP$L_PORT_UCB = 24,0,32,0 %;   !  Saved UCB address for REQCHAN
!  Fields that came from IPR portion of the old SCDRP.
macro SCDRP$L_UCB = 28,0,32,0 %;        ! ADDRESS OF DEVICE UCB 
macro SCDRP$W_FUNC = 32,0,16,0 %;       ! I/O FUNCTION CODE AND MODIFIERS 
macro SCDRP$W_STS = 34,0,16,0 %;        ! REQUEST STATUS 
macro SCDRP$L_SVAPTE = 36,0,32,0 %;     ! SYSTEM VIRTUAL ADDRESS OF FIRST PTE 
macro SCDRP$W_BOFF = 40,0,16,0 %;       ! BYTE OFFSET IN FIRST PAGE 
macro SCDRP$W_FILL_1 = 42,0,16,0 %;     ! ROUND UP TO NEXT LONGWORD 
macro SCDRP$L_BCNT = 44,0,32,0 %;       ! BYTE COUNT OF TRANSFER 
macro SCDRP$W_BCNT = 44,0,16,0 %;       ! OLD WORD DEFINITION FOR COMPATIBILITY 
macro SCDRP$L_MEDIA = 48,0,32,0 %;      ! MEDIA ADDRESS 
macro SCDRP$L_ABCNT = 52,0,32,0 %;      ! ACCUMULATED BYTES TRANSFERED 
macro SCDRP$L_SAVD_RTN = 56,0,32,0 %;   !  Saved return address from level 1 JSB 
macro SCDRP$L_MSG_BUF = 60,0,32,0 %;    !  Address of allocated MSCP buffer 
macro SCDRP$L_RSPID = 64,0,32,0 %;      !  Allocated Request ID 
macro SCDRP$L_CDT = 68,0,32,0 %;        !  Address of Connection Descriptor Table 
macro SCDRP$L_RWCPTR = 72,0,32,0 %;     !  RWAITCNT pointer 
! 	SCDRP extensions
! 	SCSI port/class driver extension
macro SCDRP$L_IRP = 76,0,32,0 %;        !  Address of IRP
macro SCDRP$L_SVA_USER = 80,0,32,0 %;   !  S0 address of double mapped user buffer
macro SCDRP$L_CMD_BUF = 84,0,32,0 %;    !  Address of SCSI command buffer
macro SCDRP$L_CMD_BUF_LEN = 88,0,32,0 %; !  Length of SCSI command buffer
macro SCDRP$L_CMD_PTR = 92,0,32,0 %;    !  Address of SCSI command
macro SCDRP$L_STS_PTR = 96,0,32,0 %;    !  Address of SCSI status byte
macro SCDRP$L_SCSI_FLAGS = 100,0,32,0 %; !  SCSI flags
macro SCDRP$V_S0BUF = 100,0,1,0 %;      !  Buffer allocated by class driver from S0 space
macro SCDRP$V_BUFFER_MAPPED = 100,1,1,0 %; !  Buffer (S0 or user) has been mapped */
macro SCDRP$V_DISK_SPUN_UP = 100,2,1,0 %; !  Start unit has been issued
macro SCDRP$V_LOCK = 100,3,1,0 %;       !  Fork block in use flag
macro SCDRP$V_MREG_DONE = 100,4,1,0 %;  !  Map registers already setup
macro SCDRP$V_ONEBYTE = 100,5,1,0 %;    !  One byte transfer in progress
macro SCDRP$L_DATACHECK = 104,0,32,0 %; !  Address of buffer for datacheck operations
macro SCDRP$L_SCSI_STK_PTR = 108,0,32,0 %; !  Class driver return addr stack ptr
macro SCDRP$L_SCSI_STK = 112,0,0,1 %;
literal SCDRP$S_SCSI_STK = 32;          !  Class driver return addr stack
macro SCDRP$L_CL_RETRY = 144,0,32,0 %;  !  Retry count
macro SCDRP$L_DMA_TIMEOUT = 148,0,32,0 %; !  Time in seconds for a DMA timeout.
macro SCDRP$L_DISCON_TIMEOUT = 152,0,32,0 %; !  Time in seconds for a disconnect to timeout.
! 	SCSI PORT driver extension
macro SCDRP$W_PAD_BCNT = 156,0,16,0 %;  !  Number of bytes to pad user buffer with
macro SCDRP$L_PAD_BCNT = 156,0,32,0 %;  !  Number of bytes to pad user buffer with
macro SCDRP$B_TQE = 160,0,0,0 %;
literal SCDRP$S_TQE = 52;               !  Timer queue entry
macro SCDRP$L_TQE_DELAY = 212,0,32,0 %; !  Delay time for next TQE delay.
macro SCDRP$L_SVA_DMA = 216,0,32,0 %;   !  S0 address of chunk of 128KB DMA buffer
macro SCDRP$L_SVA_CMD = 220,0,32,0 %;   !  S0 address of chunk of 128KB DMA buffer for cmd buf
macro SCDRP$W_MAPREG = 224,0,16,0 %;    !  Base map register allocated
macro SCDRP$W_CMD_MAPREG = 226,0,16,0 %; !  Base map register allocated for cmd buf
macro SCDRP$W_NUMREG = 228,0,16,0 %;    !  Number of map registers allocated
macro SCDRP$W_CMD_NUMREG = 230,0,16,0 %; !  Number of map registers allocated for command
macro SCDRP$L_SVA_SPTE = 232,0,32,0 %;  !  SVA of SPTE mapping user buffer.
macro SCDRP$L_SCSIMSGO_PTR = 236,0,32,0 %; !  SCSI OUTPUT MSG PTR, REQUIRED FOR THE SII PORT
macro SCDRP$L_SCSIMSGI_PTR = 240,0,32,0 %; !  SCSI INPUT MSG PTR, REQUIRED FOR THE SII PORT
macro SCDRP$B_SCSIMSGO_BUF = 244,0,0,1 %;
literal SCDRP$S_SCSIMSGO_BUF = 6;       !  SCSI OUTPUT MSG buffer of port.
macro SCDRP$B_SCSIMSGI_BUF = 250,0,0,1 %;
literal SCDRP$S_SCSIMSGI_BUF = 6;       !  SCSI INPUT MSG buffer of port.
macro SCDRP$L_MSGO_PENDING = 256,0,32,0 %; !  Bit set if 
macro SCDRP$V_IDENTIFY = 256,0,1,0 %;   ! corresponding message 
macro SCDRP$V_SYNC_OUT = 256,1,1,0 %;   ! is to be sent.
macro SCDRP$V_BUS_DEVICE_RESET = 256,2,1,0 %;
macro SCDRP$V_MESSAGE_PARITY_ERROR = 256,3,1,0 %;
macro SCDRP$V_ID_ERROR = 256,4,1,0 %;
macro SCDRP$V_ABORT = 256,5,1,0 %;
macro SCDRP$V_NOP = 256,6,1,0 %;
macro SCDRP$V_MESSAGE_REJECT = 256,7,1,0 %;
macro SCDRP$V_LAST_MSGO_BIT = 256,8,1,0 %; !  THIS MUST BE LAST
macro SCDRP$L_MSGI_PENDING = 260,0,32,0 %; !  Bit set if 
macro SCDRP$V_SYNC_IN = 260,0,1,0 %;    ! corresponding message 
! is expected.
macro SCDRP$B_LAST_MSGO = 264,0,8,0 %;  !  Last message sent
macro SCDRP$B_PADIT = 265,0,24,1 %;
literal SCDRP$S_PADIT = 3;              !  longword align
macro SCDRP$L_DATA_PTR = 268,0,32,0 %;  !  Current data pointer address.
macro SCDRP$L_TRANS_CNT = 272,0,32,0 %; !  Count of the # of bytes of users data transfered
macro SCDRP$L_SAVE_DATA_CNT = 276,0,32,0 %; !  Running 2's complement count of bytes to be transfered
macro SCDRP$L_SAVE_DATA_PTR = 280,0,32,0 %; !  Running data pointer.
macro SCDRP$L_SDP_DATA_CNT = 284,0,32,0 %; !  Storage for SDP
macro SCDRP$L_SDP_DATA_PTR = 288,0,32,0 %; !  Storage for SDP
macro SCDRP$L_DUETIME = 292,0,32,0 %;   !  Timeout time for disconnected IO.
macro SCDRP$L_TIMEOUT_ADDR = 296,0,32,0 %; !  Address of timeout routine if an IO times out.
macro SCDRP$W_CMD_BCNT = 300,0,16,0 %;  !  temporary storage for cmd bytecnt
macro SCDRP$W_BUSY_RETRY_CNT = 302,0,16,0 %; !  Number retries left, for bus busy.
macro SCDRP$W_ARB_RETRY_CNT = 304,0,16,0 %; !  Number of retries left, for arbitration failures.
macro SCDRP$W_SEL_RETRY_CNT = 306,0,16,0 %; !  Number of retries left, for selection failures.
macro SCDRP$W_CMD_RETRY_CNT = 308,0,16,0 %; !  Number of times the port will retry a command.
macro SCDRP$W_SEL_TQE_RETRY_CNT = 310,0,16,0 %; !  Number of TQE retries left, for selection failures.
macro SCDRP$L_SAVER3 = 312,0,32,0 %;    !  Safe place to save register. 
macro SCDRP$L_SAVER6 = 316,0,32,0 %;    !  Safe place to save register. 
macro SCDRP$L_SAVER7 = 320,0,32,0 %;    !  Safe place to save register. 
macro SCDRP$L_SAVER3CL = 324,0,32,0 %;  !  Safe place to save the class drivers R3.
macro SCDRP$L_SAVEPCCL = 328,0,32,0 %;  !  Safe place to save the class drivers return PC.
macro SCDRP$L_ABORTPCCL = 332,0,32,0 %; !  Save the class drivers return PC during cancel operations.
macro SCDRP$L_PO_STK_PTR = 336,0,32,0 %; !  Port driver return addr stack ptr
macro SCDRP$L_PO_STK = 340,0,0,1 %;
literal SCDRP$S_PO_STK = 24;            !  Port driver return addr stack
macro SCDRP$L_TAG = 364,0,32,0 %;       !  Tag field for queued commands
macro SCDRP$L_RSVD_LONG = 368,0,0,1 %;
literal SCDRP$S_RSVD_LONG = 44;         !  Reserved space.
 
!*** MODULE $SCDTDEF ***
! +
!  SCDT - SCSI CONNECTION DESCRIPTOR TABLE
! 
!  ONE SCDT IS USED PER SCSI CONNECTION. A CONNECTION IS A LOGICAL LINK BETWEEN
!  A CLASS DRIVER UCB AND A DEVICE ON THE SCSI BUS. THE SCDT CONTAINS THE 
!  ENTIRE CONTEXT OF A CONNECTION BETWEEN A CLASS DRIVER (SYSAP) AND A 
!  DEVICE ON THE SCSI BUS. 
!  SCDT'S ARE CREATED BY PORT DRIVERS WHEN CLASS DRIVERS CALL PORT DRIVER'S
!  CONNECT ENTRY POINT.
! 
!  THE CLASS DRIVER HAS NO ACCESS TO THIS DATA STRUCTURE. THE SCDT IS USED 
!  EXCLUSIVELY BY THE PORT DRIVER.
! 
!  ***NOTE:**** IF AN INCOMPATIBLE CHANGE IS MADE TO THIS STRUCTURE BUMP
!               THE VERSION NUMBER OF THIS STRUCTURE.
!                                                                       
! -         
literal SCDT$C_VERSION = 1;             ! COMPATIBLE VERSION NUMBER.
literal SCDT$M_BSY = 1;
literal SCDT$M_ABORT_PND = 2;
literal SCDT$M_ABORT_CMPL = 4;
literal SCDT$M_ABORT_INPROG = 8;
literal SCDT$M_ABORT_RESEL = 16;
literal SCDT$M_PND_RESEL = 32;
literal SCDT$M_DSCN = 64;
literal SCDT$M_TMODSCN = 128;
literal SCDT$C_CLOSED = 0;              !  CLOSED   
literal SCDT$C_OPEN = 1;                !  OPEN  
literal SCDT$C_FAIL = 2;                !  CONNECT FAILED 
!  
literal SCDT$M_DATAOUT = 1;
literal SCDT$M_DATAIN = 2;
literal SCDT$M_CMD = 4;
literal SCDT$M_STS = 8;
literal SCDT$M_INV1 = 16;
literal SCDT$M_INV2 = 32;
literal SCDT$M_MSGOUT = 64;
literal SCDT$M_MSGIN = 128;
literal SCDT$M_ARB = 256;
literal SCDT$M_SEL = 512;
literal SCDT$M_RESEL = 1024;
literal SCDT$M_DISCON = 2048;
literal SCDT$M_CMD_CMPL = 4096;
literal SCDT$M_TMODISCON = 8192;
literal SCDT$M_FREE = 16384;
literal SCDT$M_PARERR = 1;
literal SCDT$M_BSYERR = 2;
literal SCDT$M_MISPHS = 4;
literal SCDT$M_BADPHS = 8;
literal SCDT$M_RST = 16;
literal SCDT$M_CTLERR = 32;
literal SCDT$M_BUSERR = 64;
literal SCDT$M_ABORT = 128;
literal SCDT$M_MSGERR = 256;
literal SCDT$M_ENA_DISCON = 1;
literal SCDT$M_DIS_RETRY = 2;
literal SCDT$M_TARGET_MODE = 4;
literal SCDT$C_LENGTH = 244;            ! LENGTH OF CDT 
literal SCDT$S_SCDTDEF = 244;
macro SCDT$L_FLINK = 0,0,32,0 %;        ! LINK TO NEXT SCDT
macro SCDT$W_SIZE = 4,0,16,0 %;         ! STRUCTURE SIZE IN BYTES 
macro SCDT$B_TYPE = 6,0,8,0 %;          ! SCS STRUCTURE TYPE 
macro SCDT$B_SUBTYP = 7,0,8,0 %;        ! SCSI STRUCT SUBTYPE FOR CDT 
macro SCDT$W_RSRV1 = 8,0,16,0 %;        ! RESERVED, WORD.
macro SCDT$B_RSRV2 = 10,0,8,0 %;        ! RESERVED, BYTE.
macro SCDT$B_FLCK = 11,0,8,0 %;         ! FORK LOCK INDEX 
macro SCDT$L_FPC = 12,0,32,0 %;         ! SAVED FORK PROCESS PC 
macro SCDT$L_FR3 = 16,0,32,0 %;         ! SAVED FORK PROCESS R3
macro SCDT$L_FR4 = 20,0,32,0 %;         ! SAVED FORK PROCESS R4 
macro SCDT$L_STS = 24,0,32,0 %;         ! CONNECTION STATUS
macro SCDT$V_BSY = 24,0,1,0 %;          ! CONNECTION BUSY
macro SCDT$V_ABORT_PND = 24,1,1,0 %;    ! ABORT PENDING ON CONNECTION.
macro SCDT$V_ABORT_CMPL = 24,2,1,0 %;   ! ABORT COMPLETED ON CONNECTION.
macro SCDT$V_ABORT_INPROG = 24,3,1,0 %; ! ABORT IS IN PROGRESS.
macro SCDT$V_ABORT_RESEL = 24,4,1,0 %;  ! PORT HAS BEEN RESELECTED WHILE ABORT WAS IN PROGRESS.
macro SCDT$V_PND_RESEL = 24,5,1,0 %;    ! RESELECTION INTERRUPT PENDING.
macro SCDT$V_DSCN = 24,6,1,0 %;         ! CONNECTION IS DISCONNECTED.
macro SCDT$V_TMODSCN = 24,7,1,0 %;      ! CONNECTION TIMED OUT-
macro SCDT$W_SCDT_TYPE = 28,0,16,0 %;   ! TYPE OF SCDT  
macro SCDT$W_STATE = 30,0,16,0 %;       ! CONNECTION STATE 
macro SCDT$L_SPDT = 32,0,32,0 %;        ! ADDR OF ASSOC PORT DESC TABLE 
macro SCDT$L_SCSI_PORT_ID = 36,0,32,0 %; !  SCSI PORT ID.
macro SCDT$L_SCSI_BUS_ID = 40,0,32,0 %; !  SCSI BUS ID.
macro SCDT$L_SCSI_LUN = 44,0,32,0 %;    !  SCSI DEVICE LUN.
macro SCDT$L_AUXSTRUC = 48,0,32,0 %;    ! ADDR OF AUX DATA STRUCTURE 
macro SCDT$L_SCDTLST = 52,0,32,0 %;     ! LINK FOR SCDT LIST FROM SPDT
macro SCDT$L_SCDRP_ADDR = 56,0,32,0 %;  ! ADDR OF CL DRV SCDRP.
macro SCDT$L_BUS_PHASE = 60,0,32,0 %;   !  CURRENT BUS PHASE.
macro SCDT$V_DATAOUT = 60,0,1,0 %;      !  DATAIN Phase.
macro SCDT$V_DATAIN = 60,1,1,0 %;       !  DATAIN Phase.
macro SCDT$V_CMD = 60,2,1,0 %;          !  Command Phase.
macro SCDT$V_STS = 60,3,1,0 %;          !  Status Phase.
macro SCDT$V_INV1 = 60,4,1,0 %;         !  Invalid Phase 1.           
macro SCDT$V_INV2 = 60,5,1,0 %;         !  Invalid Phase 1.
macro SCDT$V_MSGOUT = 60,6,1,0 %;       !  MESSAGEOUT Phase.
macro SCDT$V_MSGIN = 60,7,1,0 %;        !  MESSAGEIN Phase.
macro SCDT$V_ARB = 60,8,1,0 %;          !  Arbitration Phase.  
macro SCDT$V_SEL = 60,9,1,0 %;          !  Selection Phase.
macro SCDT$V_RESEL = 60,10,1,0 %;       !  Reselection Phase.
macro SCDT$V_DISCON = 60,11,1,0 %;      !  Disconnect seen.    
macro SCDT$V_CMD_CMPL = 60,12,1,0 %;    !  Command complete received. 
macro SCDT$V_TMODISCON = 60,13,1,0 %;   !  Disconnect operation timed out.
macro SCDT$V_FREE = 60,14,1,0 %;        !  The bus went free.
macro SCDT$L_OLD_PHASES = 64,0,32,0 %;  !  LONGWORD USED TO TRACK BUS PHASES.
macro SCDT$W_PHASES = 68,0,0,1 %;
literal SCDT$S_PHASES = 44;             !  TRACK BUS PHASES
macro SCDT$L_PHASE_STK_PTR = 112,0,32,0 %; !  ADDRESS OF TOP OF PHASE STK.
macro SCDT$L_PHASE_END_STK_PTR = 116,0,32,0 %; !  ADDRESS OF END OF PHASE STK.
macro SCDT$L_EVENTS_SEEN = 120,0,32,0 %; !  MASK OF EVENTS SEEN.
macro SCDT$V_PARERR = 120,0,1,0 %;      !  PARITY ERROR OCCURED.
macro SCDT$V_BSYERR = 120,1,1,0 %;      !  LOST BUSY DURING COMMAND.
macro SCDT$V_MISPHS = 120,2,1,0 %;      !  MISSING BUS PHASE DETECTED.
macro SCDT$V_BADPHS = 120,3,1,0 %;      !  A BAD PHASE TRANSITION OCCURED.
macro SCDT$V_RST = 120,4,1,0 %;         !  THE BUS HAS BEEN RESET DURING THIS command.
macro SCDT$V_CTLERR = 120,5,1,0 %;      !  A SCSI CONTROLLER ERROR HAS BEEN DETECTED
macro SCDT$V_BUSERR = 120,6,1,0 %;      !  A SCSI BUS ERROR HAS BEEN DETECTED
macro SCDT$V_ABORT = 120,7,1,0 %;       !  THIS IO HAS BEEN ABORTED.
macro SCDT$V_MSGERR = 120,8,1,0 %;      !  AN ERROR WAS DETECTED DURING
! 
!  Port connection performance and error counters.                            
! 
macro SCDT$L_ARB_FAIL_CNT = 124,0,32,0 %; !  COUNT OF ARBITRATION FAILURES.
macro SCDT$L_SEL_FAIL_CNT = 128,0,32,0 %; !  COUNT OF SELECTION FAILURES.
macro SCDT$L_PARERR_CNT = 132,0,32,0 %; !  COUNT OF PARITY ERRORS.
macro SCDT$L_MISPHS_CNT = 136,0,32,0 %; !  COUNT OF MISSING PHASES ERRORS.
macro SCDT$L_BADPHS_CNT = 140,0,32,0 %; !  COUNT OF BAD PHASE ERRORS.
macro SCDT$L_RETRY_CNT = 144,0,32,0 %;  !  COUNT OF RETRIES, THIS ON CONNECTION.
macro SCDT$L_RST_CNT = 148,0,32,0 %;    !  COUNT OF BUS RESETS.
macro SCDT$L_CTLERR_CNT = 152,0,32,0 %; !  COUNT OF CONTROLLER ERRORS
macro SCDT$L_BUSERR_CNT = 156,0,32,0 %; !  COUNT OF BUS ERRORS
macro SCDT$L_CMDSENT = 160,0,32,0 %;    ! # COMMANDS SENT
macro SCDT$L_MSGSENT = 164,0,32,0 %;    ! # MESSAGES SENT
macro SCDT$L_BYTSENT = 168,0,32,0 %;    ! # BYTES SENT DURING DATAOUT
! 
!  Set connection characteristic information
! 
macro SCDT$L_CON_FLAGS = 172,0,32,0 %;  !  CONNECTION SPECIFIC FLAGS.
macro SCDT$V_ENA_DISCON = 172,0,1,0 %;  !  ENABLE DISCONNECT 
macro SCDT$V_DIS_RETRY = 172,1,1,0 %;   !  DISABLE RETRY ON COMMAND FAIL.
macro SCDT$V_TARGET_MODE = 172,2,1,0 %; !  TARGET MODE SUPPORTED
macro SCDT$L_SYNCHRONOUS = 176,0,32,0 %; !  1 = supported
macro SCDT$W_REQACK_OFFSET = 180,0,16,0 %; !  reqack offset for sync IO
macro SCDT$W_TRANSFER_PERIOD = 182,0,16,0 %; !  m*4 nanoseconds
macro SCDT$W_BUSY_RETRY_CNT = 184,0,16,0 %; !  Number retries left, for bus busy.
macro SCDT$W_ARB_RETRY_CNT = 186,0,16,0 %; !  Number of retries left, for arbitration failures.
macro SCDT$W_SEL_RETRY_CNT = 188,0,16,0 %; !  Number of retries left, for selection failures.
macro SCDT$W_CMD_RETRY_CNT = 190,0,16,0 %; !  Number of times the port will retry a command.
macro SCDT$L_DMA_TIMEOUT = 192,0,32,0 %; !  Time in seconds for a DMA timeout.
macro SCDT$L_DISCON_TIMEOUT = 196,0,32,0 %; !  Time in seconds for a disconnect to timeout.
macro SCDT$L_SEL_CALLBACK = 200,0,32,0 %; !  Address of Class drv callback.
macro SCDT$L_SEL_CONTEXT = 204,0,32,0 %; !  Context for Class drv callback.
macro SCDT$L_RSVD_LONG = 208,0,0,1 %;
literal SCDT$S_RSVD_LONG = 36;          !  Reserved space.
 
!*** MODULE $SCSDEF ***
! +
!  SCS MESSAGE DEFINITIONS
! 
!  THIS STRUCTURE DEFINES OFFSETS AND FIELDS WITHIN THE SCS PORTION OF
!  A CLUSTER MESSAGE.  OFFSETS ARE DEFINED RELATIVE TO THE START OF THE
!  APPLICATION DATA OR SCS CONTROL MESSAGE DATA.  THE FULL MESSAGE FORMAT
!  CONSISTS OF A PORT DRIVER LAYER HEADER (SEE STRUCTURE PPD) FOLLOWED
!  BY THE SCS HEADER LAYER FOLLOWED BY THE APPLICATION DATA OR SCS CONTROL
!  MESSAGE DATA.
! -
literal SCS$C_OVHD = 14;                !  SCS LAYER OVERHEAD
literal SCS$C_CON_REQL = 66;            !  CONNECT_REQ LENGTH 
literal SCS$C_CON_RSPL = 22;            !  (TYC 20-apr-89) CONNECT_RSP LENGTH 
literal SCS$C_ACCP_REQL = 66;           !  ACCEPT_REQ LENGTH 
literal SCS$C_ACCP_RSPL = 18;           !  ACCEPT_RSP LENGTH 
literal SCS$C_REJ_REQL = 18;            !  REJECT_REQ LENGTH 
literal SCS$C_REJ_RSPL = 14;            !  REJECT_RSP LENGTH 
literal SCS$C_DISC_REQL = 18;           !  DISCONNECT_REQ LENGTH 
literal SCS$C_DISC_RSPL = 14;           !  DISCONNECT_RSP LENGTH 
literal SCS$C_CR_REQL = 14;             !  CREDIT_REQ LENGTH 
literal SCS$C_CR_RSPL = 14;             !  CREDIT_RSP LENGHT 
literal SCS$C_CON_REQ = 0;              !  CONNECT_REQ 
literal SCS$C_CON_RSP = 1;              !  CONNECT_RSP 
literal SCS$C_ACCP_REQ = 2;             !  ACCEPT_REQ 
literal SCS$C_ACCP_RSP = 3;             !  ACCEPT_RSP 
literal SCS$C_REJ_REQ = 4;              !  REJECT_REQ 
literal SCS$C_REJ_RSP = 5;              !  REJECT_RSP 
literal SCS$C_DISC_REQ = 6;             !  DISCONNECT_REQ 
literal SCS$C_DISC_RSP = 7;             !  DISCONNECT_RSP 
literal SCS$C_CR_REQ = 8;               !  CREDIT_REQ 
literal SCS$C_CR_RSP = 9;               !  CREDIT_RSP 
literal SCS$C_APPL_MSG = 10;            !  APPLICATION MESSAGE 
literal SCS$C_APPL_DG = 11;             !  APPLICATION DATAGRAM 
literal SCS$K_APPL_BASE = 0;            ! BASE OF APPLICTION MESSAGE DATA 
literal SCS$C_APPL_BASE = 0;            ! BASE OF APPLICTION MESSAGE DATA 
literal SCS$M_UAP = 1;
literal SCS$K_STNORMAL = 1;             !  NORMAL, SUCCESS
literal SCS$C_STNORMAL = 1;             ! 
literal SCS$K_STNOMAT = 10;             !  NO MATCHING LISTENER
literal SCS$C_STNOMAT = 10;             ! 
literal SCS$K_STNORS = 18;              !  NO RESOURCES
literal SCS$C_STNORS = 18;              ! 
literal SCS$K_STDISC = 25;              !  DISCONNECTED
literal SCS$C_STDISC = 25;              ! 
literal SCS$K_STINSFCR = 33;            !  INSUFF CREDIT
literal SCS$C_STINSFCR = 33;            ! 
literal SCS$K_STBALANCE = 41;           !  LOAD BALANCE
literal SCS$C_STBALANCE = 41;           !   DISCONNECT
literal SCS$K_USE_ALTERNATE_PORT = 42;  !  (TYC 13-Feb-89) Load Share
literal SCS$C_USE_ALTERNATE_PORT = 42;  !   Status code for using alternate port
literal SCS$K_CON_BASE = 4;             ! BASE OF CONNECT/ACCEPT INFO TO 
literal SCS$C_CON_BASE = 4;             ! BASE OF CONNECT/ACCEPT INFO TO 
!  GIVE TO SYSAP'S
literal SCS$S_SCSDEF = 84;
macro SCS$B_PPD = -32,0,0,0 %;
literal SCS$S_PPD = 16;                 ! 16 BYTES OF PPD HEADER 
macro SCS$W_LENGTH = -16,0,16,0 %;      ! MESSAGE LENGTH (INCLUDES ALL 
!  BYTES FROM SCS$W_LENGTH ON,
!  NOT INCLUDING SCS$W_LENGTH)
!  (FIELD SHARED BY PPD)
! DEFINE LENGTHS OF SCS CONTROL MSGS: 
macro SCS$W_MTYPE = -12,0,16,0 %;       ! SCS MESSAGE TYPE 
! SCS MESSAGE TYPE CODES:
!  0 ORIGIN, INCREMENTS OF 1 
macro SCS$W_CREDIT = -10,0,16,0 %;      ! CREDIT BEING EXTENDED 
macro SCS$L_DST_CONID = -8,0,32,0 %;    ! DESTINATION (RECVING) CONNX ID 
macro SCS$L_SRC_CONID = -4,0,32,0 %;    ! SOURCE (SENDING) CONNX ID 
macro SCS$W_MIN_CR = 0,0,16,0 %;        ! MINIMUM SEND CREDIT 
macro SCS$W_STATUS = 2,0,16,0 %;        ! STATUS/REASON  
macro SCS$V_UAP = 2,0,1,0 %;            !  USE ALTERNATE PORT is supported
! DEFINE STATUS/REASON CODES:
! FORMAT OF CONNECT/ACCEPT_REQ MSGS:
macro SCS$T_DST_PROC = 4,0,0,0 %;
literal SCS$S_DST_PROC = 16;            !  DESTINATION PROCESS NAME 
macro SCS$B_SUBNODE = 4,0,8,0 %;        !  MUST BE ZERO FOR NOW
macro SCS$B_PGRP = 5,0,8,0 %;           !  ALTERNATE PORT'S PPD ADDR
macro SCS$W_RSV = 6,0,16,0 %;           !  RESERVED FIELD
macro SCS$T_SRC_PROC = 20,0,0,0 %;
literal SCS$S_SRC_PROC = 16;            !  SOURCE PROCESS NAME 
macro SCS$B_CON_DAT = 36,0,0,0 %;
literal SCS$S_CON_DAT = 16;             !  CONNECT DATA 
! 
!  DEFINITION OF THE REQUEST/SEND DATA OFFSETS 
! 
literal SCS$S_SCSDEF1 = 28;
macro SCS$L_LCONID = -16,0,32,0 %;      !  LOCAL CONNECTION ID
macro SCS$L_RSPID = -12,0,32,0 %;       !  LOCAL RESPONSE ID
macro SCS$L_XCT_LEN = -8,0,32,0 %;      !  TRANSACTION LENGTH
macro SCS$L_SND_NAME = -4,0,32,0 %;     !  SEND BUFFER NAME
macro SCS$L_SND_BOFF = 0,0,32,0 %;      !   AND OFFSET
macro SCS$L_REC_NAME = 4,0,32,0 %;      !  RECEIVE BUFFER NAME
macro SCS$L_REC_BOFF = 8,0,32,0 %;      !   AND OFFSET
 
!*** MODULE $SCSCMGDEF ***
! +
!  SCSCMG - SCS CONNECTION MANAGEMENT MESSAGE FORMAT
! 
!  THIS PORTION OF A CONNECT/ACCEPT MESSAGE IS SEEN BY A
!  SYSTEM APPLICATION.
! -
literal SCSCMG$S_SCSCMGDEF = 48;
macro SCSCMG$T_RECNAM = 0,0,0,0 %;
literal SCSCMG$S_RECNAM = 16;           ! RECEIVE PROCESS NAME 
macro SCSCMG$T_SNDNAM = 16,0,0,0 %;
literal SCSCMG$S_SNDNAM = 16;           ! SENDER PROCESS NAME 
macro SCSCMG$B_SNDDAT = 32,0,0,0 %;
literal SCSCMG$S_SNDDAT = 16;           ! SENDER CONNECT DATA 
 
!*** MODULE $SCSNETDEF ***
! +
!  SCS CI PPD definitions
! 
!  This structure defines offsets and fields for SCS datagrams used in the 
!  datagram handshake between remote systems.  The full format consists of
!  a port heder (See Structure PPD) followed by these definitions.  The origin
!  of this field is the beginning of user data for a normal SCS datagram
!  so that the PDT$L_DGHDRSZ may be used to determine the true origin of the 
!  packet.
! -
literal SCSNET$C_START_LEN = 62;        !  Start dg length
literal SCSNET$C_STACK_LEN = 62;        !  Stack dg length
literal SCSNET$C_ACK_LEN = 2;           !  Ack dg length
literal SCSNET$C_HSHUT_LEN = 2;         !  Host shutdown dg length
literal SCSNET$C_CACHE_LEN = 2;         !  Cache clear marker length
literal SCSNET$C_START = 0;             !  START DATAGRAM
literal SCSNET$C_STACK = 1;             !  STACK DATAGRAM
literal SCSNET$C_ACK = 2;               !  ACK DATAGRAM
literal SCSNET$C_SCS_DG = 3;            !  SCS DATAGRAM
literal SCSNET$C_SCS_MSG = 4;           !  SCS MESSAGE
literal SCSNET$C_ELOG = 5;              !  ERROR LOG DATAGRAM
literal SCSNET$C_HOSTSHUT = 6;          !  HOST SHUTDOWN DATAGRAM
literal SCSNET$C_CACHECLR = 32768;      !  CACHE CLEAR MARKER MSG
!  (8000 hex)
literal SCSNET$C_PRT_BASE = 0;          !  1st PPD Protocol Rev
literal SCSNET$C_PRT_ELOG = 1;          !  2nd rev, supports error
!  log dgs and host shutdown.
literal SCSNET$C_MIN_DGSIZ = 48;        ! Minimum allowed DG size,
!  not including the SCS header.
literal SCSNET$S_SCSNETDEF = 80;
macro SCSNET$B_PPD = -32,0,0,0 %;
literal SCSNET$S_PPD = 16;              ! 16 bytes of PPD header 
macro SCSNET$W_LENGTH = -16,0,16,0 %;   ! message length (includes all 
!  bytes from scs$w_length on,
!  not including SCS$W_LENGTH)
!  (field shared by PPD)
macro SCSNET$W_MTYPE = -14,0,16,0 %;
macro SCSNET$B_SYSTEMID = -12,0,0,0 %;
literal SCSNET$S_SYSTEMID = 6;          !  Sending System ID
macro SCSNET$B_PROTOCOL = -6,0,8,0 %;   !  PPD Protocol Level
macro SCSNET$W_MAXDG = -4,0,16,0 %;     !  Max DG size
macro SCSNET$W_MAXMSG = -2,0,16,0 %;    !  Max MSG size
macro SCSNET$T_SWTYPE = 0,0,32,0 %;
literal SCSNET$S_SWTYPE = 4;            !  Software type
macro SCSNET$T_SWVERS = 4,0,32,0 %;
literal SCSNET$S_SWVERS = 4;            !  Software version
macro SCSNET$Q_SWINCARN = 8,0,0,0 %;
literal SCSNET$S_SWINCARN = 8;          !  Software incarnation #
macro SCSNET$T_HWTYPE = 16,0,32,0 %;
literal SCSNET$S_HWTYPE = 4;            !  Hardware type
macro SCSNET$B_HWVERS = 20,0,0,0 %;
literal SCSNET$S_HWVERS = 12;           !  Hardware version
macro SCSNET$Q_NODENAME = 32,0,0,0 %;
literal SCSNET$S_NODENAME = 8;          !  Node Name
macro SCSNET$Q_CURTIME = 40,0,0,0 %;
literal SCSNET$S_CURTIME = 8;           !  Current system time measured
!    in 100 nsec units
 
!*** MODULE $SDIRDEF ***
! +
!  SDIR - SCS DIRECTORY ENTRY
! 
!  THIS DATA STRUCTURE IS ALLOCATED FOR EACH LOCAL PROCESS THAT WANTS
!  TO BE KNOWN TO SCS.
! -
literal SDIR$K_LENGTH = 48;
literal SDIR$C_LENGTH = 48;
literal SDIR$S_SDIRDEF = 48;
macro SDIR$L_FLINK = 0,0,32,0 %;        ! FWD LINK 
macro SDIR$L_BLINK = 4,0,32,0 %;        ! BCK LINK 
macro SDIR$W_SIZE = 8,0,16,0 %;         ! STRUCTURE SIZE IN BYTES 
macro SDIR$B_TYPE = 10,0,8,0 %;         ! SCS STRUCTURE TYPE 
macro SDIR$B_SUBTYP = 11,0,8,0 %;       ! SCS STRUCTURE SUBTYPE FOR SDIR 
macro SDIR$B_PROCNAM = 12,0,0,0 %;
literal SDIR$S_PROCNAM = 16;            ! ASCII STRING FOR PROCESS NAME 
macro SDIR$B_PROCINF = 28,0,0,0 %;
literal SDIR$S_PROCINF = 16;            ! ASCII STRING FOR PROCESS INFO 
macro SDIR$L_CONID = 44,0,32,0 %;       ! CONNECTION ID 
 
!*** MODULE $SFCDEF ***
! +
!  DEFINE FLAGS VIELDS
! -
literal SFC$M_PRIMARY_BOOTING = 1;
literal SFC$M_MESSAGES = 2;
literal SFC$M_SYNCHRONOUS_MESSAGES = 4;
literal SFC$M_SPARE1 = 8;
literal SFC$M_SPARE2 = 16;
literal SFC$M_SPARE3 = 32;
literal SFC$S_SFCDEF = 1;
macro SFC$V_PRIMARY_BOOTING = 0,0,1,0 %; !  First 10 minutes of system operation
macro SFC$V_MESSAGES = 0,1,1,0 %;       !  Print messages
macro SFC$V_SYNCHRONOUS_MESSAGES = 0,2,1,0 %; !  Print messages right now
macro SFC$V_SPARE1 = 0,3,1,0 %;         !  Spare bit definition
macro SFC$V_SPARE2 = 0,4,1,0 %;         !  Spare bit definition
macro SFC$V_SPARE3 = 0,5,1,0 %;         !  Spare bit definition
 
!*** MODULE $SGNDEF ***
! +
!  SYSGEN PARAMETER DEFINITIONS
! -
!  
literal SGN$C_BALSETCNT = 24;           !  NUMBER OF PROCESSES IN BALANCE SET 
literal SGN$C_DFWSCNT = 100;            !  DEFAULT WORKING SET COUNT 
literal SGN$C_DFWSQUOTA = 120;          !  DEFAULT WORKING SET QUOTA 
literal SGN$C_GBLSECCNT = 40;           !  GLOBAL SECTION COUNT 
literal SGN$C_MAXGPGCNT = 2048;         !  GLOBAL PAGE COUNT (GPT SIZE) 
literal SGN$C_MAXPAGCNT = 16384;        !  PHYSICAL MEMORY SIZE IN PAGES 
literal SGN$C_MAXPGFL = 4096;           !  DEFAULT MAXIMUM PAGING FILE 
literal SGN$C_MAXPSTCNT = 5;            !  MAX NUMBER OF PST ENTRIES 
literal SGN$C_MAXVPGCNT = 8192;         !  MAX PROCESS VIRTUAL SIZE (PAGES) 
literal SGN$C_MAXWSCNT = 1024;          !  MAX WORKING SET SIZE (PAGES) 
literal SGN$C_MINWSCNT = 10;            !  MIN WORKING SET SIZE (PAGES) 
literal SGN$C_NPAGEDYN = 26624;         !  NON-PAGED DYNAMIC POOL SIZE 
literal SGN$C_NPROCS = 64;              !  MAX NUMBER OF PROCESSES 
literal SGN$C_PAGEDYN = 16384;          !  PAGED DYNAMIC POOL SIZE IN BYTES 
literal SGN$C_PHYPAGCNT = 4096;         !  ACTUAL PHYSICAL PAGE COUNT 
literal SGN$C_SYSDWSCNT = 40;           !  DEFAULT SYSTEM WORKING SET COUNT 
literal SGN$C_SYSVECPGS = 6;            !  NO. OF PAGES OF SYSTEM SERVICE VECTORS 
literal SGN$C_SYSWSCNT = 96;            !  SYSTEM WORKING SET COUNT 
 
!*** MODULE $SHADDEF ***
! ++
!  VOLUME SHADOWING STRUCTURE DEFINITIONS 
! --
literal SHAD$K_MINDEVS = 1;             !  Minimum number of devices
literal SHAD$C_MINDEVS = 1;             !  Minimum number of devices
literal SHAD$K_MINMBRS = 1;             !  Minimum number of members
literal SHAD$C_MINMBRS = 1;             !  Minimum number of members
literal SHAD$K_MAXMBRS = 3;             !  Maximum number of members
literal SHAD$C_MAXMBRS = 3;             !  Maximum number of members
literal SHAD$K_MBRSIZ = 16;
literal SHAD$C_MBRSIZ = 16;
!  Duplicate the above constants
!  Number of bits in the member status
!   fields used to determine copy type
!  Warning : Please check the shad_irp alignment at the end of this module if
! 	     max_nodes is changed.
!  CLU$C_MAX_NODES
literal LOCK$M_DEQUEUE = 1;
literal LOCK$M_WATCHER = 2;
literal LOCK$M_VALUE_UPDATE = 4;
literal LOCK$M_MBR_CHANGE_HERE = 8;
literal LOCK$M_COPY_ACTIVE = 16;
literal LOCK$M_STALL = 32;
literal LOCK$M_STALL_IP = 64;
literal LOCK$K_LENGTH = 80;             ! Length of Structure
literal LOCK$C_LENGTH = 80;             ! Length of Structure
literal LOCK$S_LOCKDEF = 80;            !  Lock substructure
macro LOCK$B_RESNAM_STR = 0,0,0,0 %;
literal LOCK$S_RESNAM_STR = 32;         !  Resource name string
macro LOCK$Q_RESNAM = 32,0,0,0 %;
literal LOCK$S_RESNAM = 8;              !  Resource name descriptor
macro LOCK$L_FLINK = 40,0,32,0 %;       !  CDRP queue Forward link 
macro LOCK$L_BLINK = 44,0,32,0 %;       !  CDRP Queue Backward link
macro LOCK$L_BLKADR = 48,0,32,0 %;      !  Blocking address for function
macro LOCK$L_LKSB = 52,0,32,0 %;        !  Lock status block base
macro LOCK$L_LKID = 56,0,32,0 %;        !  Lock ID
macro LOCK$L_LKVALBLK = 60,0,0,0 %;
literal LOCK$S_LKVALBLK = 16;           !  Lock value block
macro LOCK$B_STATE = 76,0,8,0 %;        !  Lock state semaphore
macro LOCK$V_DEQUEUE = 76,0,1,0 %;      !  DEQUEUE in progress
macro LOCK$V_WATCHER = 76,1,1,0 %;      !  Watcher node
macro LOCK$V_VALUE_UPDATE = 76,2,1,0 %; !  Watcher value update node
macro LOCK$V_MBR_CHANGE_HERE = 76,3,1,0 %; !  Set change in progress
macro LOCK$V_COPY_ACTIVE = 76,4,1,0 %;  !  Copy active here 
macro LOCK$V_STALL = 76,5,1,0 %;        !  Lock does stalls
macro LOCK$V_STALL_IP = 76,6,1,0 %;     !  Stall new requests until NL
literal SHAD$M_NORMAL = 1;
literal SHAD$M_NEW = 2;
literal SHAD$M_REBLDNG = 4;
literal SHAD$M_VERIFY = 8;
literal SHAD$M_MVBEGUN = 16;
literal SHAD$M_COPYING = 32;
literal SHAD$M_MERGING = 64;
literal SHAD$M_MINIMRG = 128;
literal SHAD$M_CPY_RESET = 256;
literal SHAD$M_BOOTING = 512;
literal SHAD$M_WLG = 1024;
literal SHAD$M_INVWLG = 2048;
literal SHAD$M_FAILED = 32768;
literal SHAD$M_COPY_TYPE = 3;
literal SHAD$M_MBR_MODIF = 252;
literal SHAD$M_MBR_FCPY = 1;
literal SHAD$M_MBR_MERGE = 2;
literal SHAD$M_MBR_CIP = 4;
literal SHAD$M_MBR_MASTER = 8;
literal SHAD$M_MBR_ERROR = 16;
literal SHAD$M_MBR_SRC = 32;
literal SHAD$M_MBR_DCD = 64;
literal SHAD$M_MBR_VALID = 128;
literal SHAD$M_CA_COPY_ACTIVATED = 1;
literal SHAD$M_CA_LOCAL_COPY = 2;
literal SHAD$M_CA_REMOTE_COPY = 4;
literal SHAD$M_CA_COPY_PATH_EST = 8;
literal SHAD$M_CA_COPY_RETRY = 16;
literal SHAD$M_CA_COPY_DISABLE = 32;
literal SHAD$M_IN_PROG = 1;
literal SHAD$M_INITING = 2;
literal SHAD$M_MMB_VALID = 4;
literal SHAD$M_MMB_ALLOCATION_FAILED = 8;
literal SHAD$M_LOST_CNID = 16;
literal SHAD$M_TABLE_GENERATION = 32;
literal SHAD$M_SWITCHING = 64;
literal SHAD$M_FLUSH_RATE_EXCEEDED = 1;
literal SHAD$K_LENGTH = 1048;           ! Length of Structure
literal SHAD$C_LENGTH = 1048;           ! Length of Structure
literal SHAD$S_SHADDEF = 1052;
macro SHAD$L_FLINK = 0,0,32,0 %;        !  Forward link to next SHAD
macro SHAD$L_BLINK = 4,0,32,0 %;        !  Backward link
macro SHAD$W_SIZE = 8,0,16,0 %;         !  Size of this structure
macro SHAD$B_TYPE = 10,0,8,0 %;         !  Standard fields
macro SHAD$B_SUBTYP = 11,0,8,0 %;       !   ...
macro SHAD$L_VU_UCB = 12,0,32,0 %;      !  Unit Control Block for VU
macro SHAD$L_VU_VCB = 16,0,32,0 %;      !  Volume Control Block for VU
macro SHAD$L_ACTIVE_IRPS = 20,0,32,0 %; !  Active "Master" IRPs
macro SHAD$L_BADBLOCKS = 24,0,32,0 %;   !  Number of badblocks repaired.	
macro SHAD$L_NOTIFICATION_ID = 28,0,32,0 %; !  Notification ID
macro SHAD$B_MEMBERSHIP_PERMISSION = 32,0,0,0 %;
literal SHAD$S_MEMBERSHIP_PERMISSION = 80; !  Shadow set membership change permission lock
macro SHAD$B_MEMBERSHIP_LOCK = 112,0,0,0 %;
literal SHAD$S_MEMBERSHIP_LOCK = 80;    !  Shadow set membership lock
macro SHAD$B_MEMBER_OF_SET = 192,0,0,0 %;
literal SHAD$S_MEMBER_OF_SET = 80;      !  Shadow set guaranteed member lock
macro SHAD$B_WATCHER_LOCK = 272,0,0,0 %;
literal SHAD$S_WATCHER_LOCK = 80;       !  Shadow set membership lock watcher lock
macro SHAD$B_SEQ_CMD_PERMISSION = 352,0,0,0 %;
literal SHAD$S_SEQ_CMD_PERMISSION = 80; !  Shadow set sequential command permission lock
macro SHAD$B_SEQ_CMD_LOCK = 432,0,0,0 %;
literal SHAD$S_SEQ_CMD_LOCK = 80;       !  Shadow set sequential command lock
macro SHAD$B_COPIER_LOCK = 512,0,0,0 %;
literal SHAD$S_COPIER_LOCK = 80;        !  Shadow set copier lock
macro SHAD$B_COPIER_THRESHOLD = 592,0,0,0 %;
literal SHAD$S_COPIER_THRESHOLD = 80;   !  Copier threshold lock
macro SHAD$B_NODE_MAP = 672,0,0,0 %;
literal SHAD$S_NODE_MAP = 32;           !  Mounted node bit map
macro SHAD$l_filler = 704,0,32,0 %;     !  For quad alignment of queues	
macro SHAD$L_ACTIVE_FL = 708,0,32,0 %;  !  Active Queue flink
macro SHAD$L_ACTIVE_BL = 712,0,32,0 %;  !  Active Queue bLink
macro SHAD$L_RESTART_FL = 716,0,32,0 %; !  FL for restart wait queue
macro SHAD$L_RESTART_BL = 720,0,32,0 %; !  BL for restart wait queue
! 
!  define the LAST_INDEX so that it can be used as a byte and yet maintain
!  longword alignment.
! 
macro SHAD$L_LAST_INDX = 724,0,32,0 %;  !  Tot num phys IRPs active.
macro SHAD$B_LAST_INDX = 724,0,8,0 %;   !  Tot num phys IRPs assoc.
macro SHAD$L_LAST_RINDX = 728,0,32,0 %; !  Index of last read SSM
macro SHAD$R_VECTOR = 732,0,0,0 %;
literal SHAD$S_VECTOR = 16;
macro SHAD$L_COPY_VECTOR = 732,0,32,0 %; !   Address of COPY routine
macro SHAD$L_MERGE_VECTOR = 736,0,32,0 %; !   Address of MINI-MERGE routine
macro SHAD$L_WRITE_VECTOR = 740,0,32,0 %; !   Address of WRITE Startio routine
macro SHAD$L_READ_VECTOR = 744,0,32,0 %; !   Address of DSE Startio routine
! 
!  The following fields, up to the next comment are placed contiguously in 
!  this data structure so that they can be copied from the SCB in one 
!  instruction.
! 
macro SHAD$Q_GENERNUM = 748,0,0,0 %;
literal SHAD$S_GENERNUM = 8;            !  Shadow Set generation number
macro SHAD$Q_UNIT_ID = 756,0,0,0 %;
literal SHAD$S_UNIT_ID = 8;             !   unique cluster-wide identifier
macro SHAD$W_STATUS = 764,0,16,0 %;     !  Volume status:
macro SHAD$V_NORMAL = 764,0,1,0 %;      !  Shadow set populated and online
macro SHAD$V_NEW = 764,1,1,0 %;         !  Newly created, no members yet
macro SHAD$V_REBLDNG = 764,2,1,0 %;     !  rebuilding shadow set
macro SHAD$V_VERIFY = 764,3,1,0 %;      !  This SS needs verification
macro SHAD$V_MVBEGUN = 764,4,1,0 %;     !  Mount verification initiated
macro SHAD$V_COPYING = 764,5,1,0 %;     !  Full copy in progreess
macro SHAD$V_MERGING = 764,6,1,0 %;     !  Merge copy in progress
macro SHAD$V_MINIMRG = 764,7,1,0 %;     !  Mini-merge in progress
macro SHAD$V_CPY_RESET = 764,8,1,0 %;   !  Copy mode is reset.
macro SHAD$V_BOOTING = 764,9,1,0 %;     !  Shadow set in booting state
macro SHAD$V_WLG = 764,10,1,0 %;        !  Write logging
macro SHAD$V_INVWLG = 764,11,1,0 %;     !  Invalid write log table.
macro SHAD$V_FAILED = 764,15,1,0 %;     !  Shadow set not populated
macro SHAD$B_MEMBER_STATUS = 766,0,8,0 %; !  Member status bits
macro SHAD$V_COPY_TYPE = 766,0,2,0 %;
literal SHAD$S_COPY_TYPE = 2;           !  Function Code Field
macro SHAD$V_MBR_MODIF = 766,2,6,0 %;
literal SHAD$S_MBR_MODIF = 6;           !  Function Modifiers Field
macro SHAD$V_MBR_FCPY = 766,0,1,0 %;    !  Member involved in copy
macro SHAD$V_MBR_MERGE = 766,1,1,0 %;   !  Member being merged
macro SHAD$V_MBR_CIP = 766,2,1,0 %;     !  Copy (or merge) in progress
macro SHAD$V_MBR_MASTER = 766,3,1,0 %;  !  Member with guaranteed correct
!   SCB. Same member as MEMBERSHIP_LOCK
macro SHAD$V_MBR_ERROR = 766,4,1,0 %;   !  Error processing in progress
macro SHAD$V_MBR_SRC = 766,5,1,0 %;     !  member can be used for source
macro SHAD$V_MBR_DCD = 766,6,1,0 %;     !  Assisted copy source
macro SHAD$V_MBR_VALID = 766,7,1,0 %;   !  Status information is valid
macro SHAD$Q_MEMBER_IDS = 772,0,0,0 %;
literal SHAD$S_MEMBER_IDS = 24;         !  Unit ID for member
macro SHAD$L_SCB_LBN = 796,0,32,0 %;    !  Unit Control Block for VU
macro SHAD$B_DEVICES = 800,0,8,0 %;     !  Number of devices in SS
macro SHAD$B_MEMBERS = 801,0,8,0 %;     !  Number of full members
macro SHAD$B_MAST_INDX = 802,0,8,0 %;   !  Array index to master UCB
macro SHAD$B_MRG_TARGETS = 803,0,8,0 %; !  Merge Copy Targets
macro SHAD$B_FC_TARGETS = 804,0,8,0 %;  !  Full Copy Targets
!  Preserve quadword alignment for IRP.
!  Maintain the following array as the last part of this data structure 
!  in order to maintain the longword alignment of fields preceding it.
!  
macro SHAD$L_MEMBER_UCB = 812,0,0,0 %;
literal SHAD$S_MEMBER_UCB = 12;         !  UCB for member
macro SHAD$L_MEMBER_VCB = 824,0,0,0 %;
literal SHAD$S_MEMBER_VCB = 12;         !  VCB for member
macro SHAD$L_COPY_LBN = 836,0,0,0 %;
literal SHAD$S_COPY_LBN = 12;           !  Last LBN Copied
!  Command Assist Information is added at the end of the shad to be
!  backwardly compatable.
macro SHAD$L_VP_IRP = 848,0,32,0 %;     !  Volume processing master.
macro SHAD$L_WLG = 852,0,0,0 %;
literal SHAD$S_WLG = 12;                !  Array of table indicators.
macro SHAD$B_WLG_INV = 864,0,0,0 %;
literal SHAD$S_WLG_INV = 80;            !  Invalidate WLG lock
macro SHAD$L_CA_COPY_STATUS = 944,0,32,0 %; !  Command Assisted Copy Status
macro SHAD$V_CA_COPY_ACTIVATED = 944,0,1,0 %; !   Copy activated.
macro SHAD$V_CA_LOCAL_COPY = 944,1,1,0 %; !   Local copy.
macro SHAD$V_CA_REMOTE_COPY = 944,2,1,0 %; !   Remote copy.
macro SHAD$V_CA_COPY_PATH_EST = 944,3,1,0 %; !   Communication path established.
macro SHAD$V_CA_COPY_RETRY = 944,4,1,0 %; !   Retrying last I/O on a diff disk
macro SHAD$V_CA_COPY_DISABLE = 944,5,1,0 %; !   Disable assisted copy.
macro SHAD$L_CA_SOURCE_INDEX = 948,0,32,0 %; !  Command Assisted Copy Source
macro SHAD$L_CA_TARGET_INDEX = 952,0,32,0 %; !  Command Assisted Copy Target
macro SHAD$L_TQE = 956,0,32,0 %;        !  Pointer to shadow TQE
macro SHAD$W_FAILED_CNID = 960,0,16,0 %;
macro SHAD$W_FILLER = 962,0,16,0 %;     !  Longword boundary
macro SHAD$L_MMB = 964,0,32,0 %;        !  Pointer to Merge Mngmnt Block
macro SHAD$L_SRVR_IRP = 968,0,32,0 %;   !  Shadow server I/O PTR
macro SHAD$L_MM_STS = 972,0,32,0 %;     !  Longword boundary
macro SHAD$V_IN_PROG = 972,0,1,0 %;     !   In-progress
macro SHAD$V_INITING = 972,1,1,0 %;     !   Table generation phase
macro SHAD$V_MMB_VALID = 972,2,1,0 %;   !   mmb valid
macro SHAD$V_MMB_ALLOCATION_FAILED = 972,3,1,0 %; !   allocation failed
macro SHAD$V_LOST_CNID = 972,4,1,0 %;   !   lost one or more cnids
macro SHAD$V_TABLE_GENERATION = 972,5,1,0 %; !   mmb in use for table
macro SHAD$V_SWITCHING = 972,6,1,0 %;   !   mini-merge to merge switch
! 
!  Additional count to track how many seqcmd threads are queued.
! 
macro SHAD$L_SEQCMD_THREAD_COUNT = 976,0,32,0 %; !  Count concurrent seqcmd threads
macro SHAD$B_WLGINV_MAP = 980,0,0,0 %;
literal SHAD$S_WLGINV_MAP = 32;         !  Node with WLG Lock
macro SHAD$L_FLUSH_COUNT = 1012,0,32,0 %; !  Flush count
macro SHAD$L_FLUSH_TICK_COUNT = 1016,0,32,0 %; !  Heart beat counter.
macro SHAD$L_FLUSH_STS = 1020,0,32,0 %; !  Longword boundary
macro SHAD$V_FLUSH_RATE_EXCEEDED = 1020,0,1,0 %; !   Flush rate exceeded
! 
!  DCD copy fence and some reserved longwords
! 
macro SHAD$L_DCD_COPY_LBN = 1024,0,32,0 %; !  DCD Copy Fence for Assisted Full Copy
macro SHAD$L_RESERVED1 = 1028,0,32,0 %; !  Reserved longword
macro SHAD$L_RESERVED2 = 1032,0,32,0 %; !  Reserved longword
macro SHAD$L_RESERVED3 = 1036,0,32,0 %; !  Reserved longword
macro SHAD$L_RESERVED4 = 1040,0,32,0 %; !  Reserved longword
macro SHAD$L_RESERVED5 = 1044,0,32,0 %; !  Reserved longword
!  Warning : Must be quadword aligned
macro SHAD$L_IRP = 1048,0,32,0 %;       !  Pointer to shadow IRP
 
!*** MODULE $SHBDEF ***
! +
!  SHARED MEMORY CONTROL BLOCK DEFINITIONS
! -
! 
!  The UETP for the MA780 depends on some of the following definitions.  Please
!  let someone in that group know if the definitions change substantially.
! 
literal SHB$M_CONNECT = 1;
literal SHB$K_LENGTH = 32;              ! LENGTH OF CONTROL BLOCK 
literal SHB$C_LENGTH = 32;              ! LENGTH OF CONTROL BLOCK 
literal SHB$S_SHBDEF = 32;
macro SHB$L_LINK = 0,0,32,0 %;          ! LINK TO NEXT SHB 
macro SHB$L_DATAPAGE = 4,0,32,0 %;      ! VIRTUAL ADDRESS OF DATAPAGE 
macro SHB$W_SIZE = 8,0,16,0 %;          ! SIZE OF SHB IN BYTES 
macro SHB$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE FOR SHB 
macro SHB$B_FLAGS = 11,0,8,0 %;         ! FLAGS 
macro SHB$V_CONNECT = 11,0,1,0 %;       !  MEMORY IS CONNECTED, USEABLE 
macro SHB$L_REFCNT = 12,0,32,0 %;       ! COUNT OF REFERENCES TO MEMORY 
macro SHB$L_BASGSPFN = 16,0,32,0 %;     ! BASE PFN FOR GLOBAL SECTION PAGES 
macro SHB$B_NEXUS = 20,0,8,0 %;         ! NEXUS OF PORT 
macro SHB$B_PORT = 21,0,8,0 %;          ! PORT NUMBER 
macro SHB$L_POOLEND = 24,0,32,0 %;      ! ADDRESS PAST LAST BYTE OF POOL 
macro SHB$L_ADP = 28,0,32,0 %;          ! ADAPTER CONTROL BLOCK ADDRESS 
 
!*** MODULE $SHDDEF ***
! +
!  SHARED MEMORY DATAPAGE DEFINITIONS
! -
! 
!  The UETP for the MA780 depends on some of the following definitions.  Please
!  let someone in that group know if the definitions change substantially.
! 
literal SHD$C_MAXPORTS = 16;            ! MAXIMUM NUMBER PORTS HANDLED BY THIS 
! DATA STRUCTURE
! *** START OF CONSTANT FIELDS:
literal SHD$C_NAMLENGTH = 16;           ! MAXIMUM LENGTH OF NAME OF MEMORY 
literal SHD$M_INITLCK = 1;
literal SHD$M_BITMAPLCK = 2;
literal SHD$M_GSDLCK = 4;
literal SHD$M_MBXLCK = 8;
literal SHD$M_CEFLCK = 16;
literal SHD$K_LENGTH = 384;             ! LENGTH OF DATAPAGE 
literal SHD$C_LENGTH = 384;             ! LENGTH OF DATAPAGE 
literal SHD$S_SHDDEF = 384;
macro SHD$L_MBXPTR = 0,0,32,0 %;        ! RELATIVE POINTER TO MAILBOX TABLE 
macro SHD$L_GSDPTR = 4,0,32,0 %;        ! RELATIVE POINTER TO GSD TABLE 
macro SHD$L_CEFPTR = 8,0,32,0 %;        ! RELATIVE POINTER TO CEF TABLE 
macro SHD$L_GSBITMAP = 12,0,32,0 %;     ! RELATIVE POINTER TO BITMAP 
macro SHD$L_GSPAGCNT = 16,0,32,0 %;     ! CNT OF PAGES ALLOTTED FOR GBL SECTIONS 
macro SHD$L_GSPFN = 20,0,32,0 %;        ! RELATIVE PFN OF 1ST GBL SECTION PAGE 
macro SHD$W_GSDMAX = 24,0,16,0 %;       ! MAX GSD'S (SIZE OF TABLE) 
macro SHD$W_MBXMAX = 26,0,16,0 %;       ! MAX MAILBOXES (SIZE OF TABLE) 
macro SHD$W_CEFMAX = 28,0,16,0 %;       ! MAX CEF CLUSTERS (SIZE OF TABLE) 
macro SHD$T_NAME = 32,0,0,0 %;
literal SHD$S_NAME = 16;                ! NAME OF MEMORY (COUNTED STRING) 
macro SHD$Q_INITTIME = 48,0,0,0 %;
literal SHD$S_INITTIME = 8;             ! INITIALIZATION TIME 
! *** END OF CONSTANT FIELDS.
macro SHD$L_CRC = 56,0,32,0 %;          ! CRC OF CONSTANT FIELDS 
macro SHD$W_GSDQUOTA = 60,0,0,0 %;
literal SHD$S_GSDQUOTA = 32;            ! COUNT OF GSD'S CREATED (ONE/PORT) 
macro SHD$W_MBXQUOTA = 92,0,0,0 %;
literal SHD$S_MBXQUOTA = 32;            ! COUNT OF MAILBOXES CREATED (ONE/PORT) 
macro SHD$W_CEFQUOTA = 124,0,0,0 %;
literal SHD$S_CEFQUOTA = 32;            ! COUNT OF CLUSTERS CREATED (ONE/PORT) 
macro SHD$B_PORTS = 156,0,8,0 %;        ! NUMBER OF PORTS 
macro SHD$B_INITLCK = 157,0,8,0 %;      ! OWNER OF INIT LOCK 
macro SHD$B_BITMAPLCK = 158,0,8,0 %;    ! OWNER OF GS BITMAP LOCK 
macro SHD$B_FLAGS = 159,0,8,0 %;        ! FLAGS FOR LOCKING DATA STRUCTURES 
macro SHD$V_INITLCK = 159,0,1,0 %;      ! COMMON DATA PAGE BEING INITIALIZED 
macro SHD$V_BITMAPLCK = 159,1,1,0 %;    ! BITMAP BEING MODIFIED 
macro SHD$V_GSDLCK = 159,2,1,0 %;       ! GLOBAL SECTION DSC TABLE BEING SEARCHED 
macro SHD$V_MBXLCK = 159,3,1,0 %;       ! MAILBOX TABLE BEING SEARCHED 
macro SHD$V_CEFLCK = 159,4,1,0 %;       ! COMMON EVENT FLAG TABLE BEING SEARCHED 
macro SHD$B_GSDLOCK = 160,0,8,0 %;      ! OWNER OF GSD TABLE LOCK 
macro SHD$B_MBXLOCK = 161,0,8,0 %;      ! OWNER OF MBX TABLE LOCK 
macro SHD$B_CEFLOCK = 162,0,8,0 %;      ! OWNER OF CEF TABLE LOCK 
macro SHD$W_PRQWAIT = 164,0,16,0 %;     ! PORTS WAITING FOR INTER-PROCESSOR REQUEST BLOCKS 
!  (ONE BIT/PORT)
macro SHD$W_POLL = 166,0,16,0 %;        ! PORTS ACTIVELY USING THE MEMORY 
!  (ONE BIT/PORT)
macro SHD$W_RESWAIT = 168,0,0,0 %;
literal SHD$S_RESWAIT = 32;             ! PORTS WAITING FOR A RESOURCE 
!  (ONE BIT/PORT, ONE MASK/RESOURCE)
macro SHD$W_RESAVAIL = 200,0,0,0 %;
literal SHD$S_RESAVAIL = 32;            ! PORTS NEEDING TO REPORT RESOURCE AVAILABLE 
!  (ONE BIT/PORT, ONE MASK/RESOURCE)
macro SHD$W_RESSUM = 232,0,16,0 %;      ! PORTS WITH RESOURCES TO REPORT 
!  (ONE BIT/PORT)
! *** NOTE: THE FOLLOWING FIELDS MUST BE QUADWORD ALIGNED:
macro SHD$Q_PRQ = 240,0,0,0 %;
literal SHD$S_PRQ = 8;                  ! FREE INTER-PROCESSOR REQUEST BLOCK LISTHEAD 
macro SHD$Q_POOL = 248,0,0,0 %;
literal SHD$S_POOL = 8;                 ! FREE POOL BLOCK LISTHEAD 
macro SHD$Q_PRQWRK = 256,0,0,0 %;
literal SHD$S_PRQWRK = 128;             ! INTER-PROCESSOR REQUEST WORK QUEUE LISTHEADS 
!  (ONE LISTHEAD/PORT)
 
!*** MODULE $SHLDEF ***
! +
!  SHL - SHAREABLE IMAGE LIST
! 
!  THIS LIST IS CREATED IN THE IMAGE FIXUP SECTION BY THE LINKER AND
!  USED BY THE IMAGE ACTIVATOR FOR DOING SHAREABLE IMAGE FIXUPS.
! -
literal SHL$C_OLD_SHL_SIZE = 56;        !  Size of "old" SHL
literal SHL$C_MAXNAMLNG = 39;           !  Maximum length of image name 
literal SHL$K_LENGTH = 64;              !  Length of shareable image list element 
literal SHL$C_LENGTH = 64;              !  Length of shareable image list element 
literal SHL$S_SHLDEF = 64;
macro SHL$L_BASEVA = 0,0,32,0 %;        !  Base address of this shareable image 
macro SHL$L_SHLPTR = 4,0,32,0 %;        !  Pointer from SHL in shareable image 
!   to associated SHL in executable image
macro SHL$L_IDENT = 8,0,32,0 %;         !  GSMATCH 
macro SHL$L_PERMCTX = 12,0,32,0 %;      !  Permanent sharable image context 
macro SHL$B_SHL_SIZE = 16,0,8,0 %;      !  Size of SHL elements
macro SHL$T_IMGNAM = 24,0,0,0 %;
literal SHL$S_IMGNAM = 40;              !  Shareable image name (ASCIC string) 
macro SHL$B_NAMLNG = 24,0,8,0 %;        !  Synonym for name count 
 
!*** MODULE $SIGDEF ***
! +
!  Generalized Event Notification Definitions
! 
!  SIGnature Block
! 
!  This is the second level structure in the event notification
!  database.  It contains an array of signature list pointers
!  and list signature lists.
! 
!  This structure is variable length in increments of 512 bytes.
! -
literal SIG$C_ENTRY_SIZE = 8;
literal SIG$S_SIGDEF = 152;
macro SIG$L_QFL = 0,0,32,0 %;           !  QUEUE FORWARD LINK     
macro SIG$L_QBL = 4,0,32,0 %;           !  QUEUE BACKWARD LINK    
macro SIG$W_SIZE = 8,0,16,0 %;          !  STRUCTURE SIZE IN BYTES
macro SIG$B_TYPE = 10,0,8,0 %;          !  STRUCTURE TYPE CODE    
macro SIG$B_SUBTYPE = 11,0,8,0 %;       !  STRUCTURE SUBTYPE CODE
macro SIG$L_FREE = 12,0,32,0 %;         !  ADDRESS OF FIRST FREE ENTRY
macro SIG$L_LIST_PTRS = 16,0,0,0 %;
literal SIG$S_LIST_PTRS = 128;          !  SIGNATURE POINTERS
macro SIG$L_SIG = 144,0,32,0 %;         !  FIRST SIGNATURE
macro SIG$L_NAB = 148,0,32,0 %;         !  ADDRESS OF NAME BLOCK
 
!*** MODULE $SIIDEF ***
! ++
! 	SII register definitions
! --
literal SII$W_SDB = 0;                  ! SCSI data bus
literal SII$W_SC1 = 4;                  ! SCSI control signals 1
literal SII$W_SC2 = 8;                  ! SCSI control signals 2
literal SII$W_CSR = 12;                 ! CSR
literal SII$W_ID = 16;                  ! Bus ID
literal SII$W_SLCSR = 20;               ! Selector CSR
literal SII$W_DESTAT = 24;              ! Selector detection status
literal SII$W_DSTMO = 28;               ! DSSI timeout
literal SII$W_DATA = 32;                ! Data
literal SII$W_DMCTRL = 36;              ! DMA control
literal SII$W_DMLOTC = 40;              ! DMA length of transfer
literal SII$W_DMADDRL = 44;             ! DMA address (low)
literal SII$W_DMADDRH = 48;             ! DMA address (high)
literal SII$W_DMABYTE = 52;             ! DMA initial byte
literal SII$W_STLP = 56;                ! Short target list pointer
literal SII$W_LTLP = 60;                ! Long target list pointer
literal SII$W_ILP = 64;                 ! Initiator list pointer
literal SII$W_DSCTRL = 68;              ! DSSI control
literal SII$W_CSTAT = 72;               ! Connection status
literal SII$W_DSTAT = 76;               ! Data transfer status
literal SII$W_COMM = 80;                ! Command
literal SII$W_DICTRL = 84;              ! Diagnostic control
literal SII$W_CLOCK = 88;               ! Diagnostic clock
literal SII$W_BHDIAG = 92;              ! Bus handler diagnostic
literal SII$W_SIDIAG = 96;              ! SCSI IO diagnostic
literal SII$W_DMDIAG = 100;             ! Data mover diagnostic
literal SII$W_MCDIAG = 104;             ! Main control diagnostic
literal SII$M_SDB_DATA = 255;
literal SII$M_SDB_PTY = 256;
literal SII$S_SDB = 2;
macro SII$V_SDB_DATA = 0,0,8,0 %;
literal SII$S_SDB_DATA = 8;             ! Data
macro SII$V_SDB_PTY = 0,8,1,0 %;        ! Parity
literal SII$M_SC1_IO = 1;
literal SII$M_SC1_CD = 2;
literal SII$M_SC1_MSG = 4;
literal SII$M_SC1_ATN = 8;
literal SII$M_SC1_REQ = 16;
literal SII$M_SC1_ACK = 32;
literal SII$M_SC1_RST = 64;
literal SII$M_SC1_SEL = 128;
literal SII$M_SC1_BSY = 256;
literal SII$S_SC1 = 2;
macro SII$V_SC1_IO = 0,0,1,0 %;         !  I/O signal
macro SII$V_SC1_CD = 0,1,1,0 %;         !  CD signal
macro SII$V_SC1_MSG = 0,2,1,0 %;        !  MSG signal
macro SII$V_SC1_ATN = 0,3,1,0 %;        !  ATN signal
macro SII$V_SC1_REQ = 0,4,1,0 %;        !  REQ signal
macro SII$V_SC1_ACK = 0,5,1,0 %;        !  ACK signal
macro SII$V_SC1_RST = 0,6,1,0 %;        !  RST signal
macro SII$V_SC1_SEL = 0,7,1,0 %;        !  SEL signal
macro SII$V_SC1_BSY = 0,8,1,0 %;        !  BSY signal
literal SII$M_SC2_SBE = 1;
literal SII$M_SC2_ARB = 2;
literal SII$M_SC2_TGS = 4;
literal SII$M_SC2_IGS = 8;
literal SII$S_SC2 = 1;
macro SII$V_SC2_SBE = 0,0,1,0 %;        !  Drive data and parity lines
macro SII$V_SC2_ARB = 0,1,1,0 %;        !  Enable for arbitration
macro SII$V_SC2_TGS = 0,2,1,0 %;        !  Target role
macro SII$V_SC2_IGS = 0,3,1,0 %;        !  Initiator role
literal SII$M_CSR_IE = 1;
literal SII$M_CSR_PCE = 2;
literal SII$M_CSR_SLE = 4;
literal SII$M_CSR_RSE = 8;
literal SII$M_CSR_HPM = 16;
literal SII$S_CSR = 1;
macro SII$V_CSR_IE = 0,0,1,0 %;         !  Interrupt Enable
macro SII$V_CSR_PCE = 0,1,1,0 %;        !  Parity Check Enable
macro SII$V_CSR_SLE = 0,2,1,0 %;        !  SeLection Enable
macro SII$V_CSR_RSE = 0,3,1,0 %;        !  ReSelection Enable
macro SII$V_CSR_HPM = 0,4,1,0 %;        !  Arbitrated bus
literal SII$M_ID_BUSID = 7;
literal SII$M_ID_IO = 32768;
literal SII$S_ID = 2;
macro SII$V_ID_BUSID = 0,0,3,0 %;
literal SII$S_ID_BUSID = 3;             !  BUS ID
macro SII$V_ID_IO = 0,15,1,0 %;         !  Output to bus
literal SII$M_CSTAT_LST = 2;
literal SII$M_CSTAT_SIP = 4;
literal SII$M_CSTAT_SWA = 8;
literal SII$M_CSTAT_TGT = 16;
literal SII$M_CSTAT_DST = 32;
literal SII$M_CSTAT_CON = 64;
literal SII$M_CSTAT_SCH = 128;
literal SII$M_CSTAT_LDN = 256;
literal SII$M_CSTAT_BUF = 512;
literal SII$M_CSTAT_TZ = 1024;
literal SII$M_CSTAT_OBC = 2048;
literal SII$M_CSTAT_BER = 4096;
literal SII$M_CSTAT_RST = 8192;
literal SII$M_CSTAT_DI = 16384;
literal SII$M_CSTAT_CI = 32768;
literal SII$S_CSTAT = 2;
macro SII$V_CSTAT_LST = 0,1,1,0 %;      !  Lost
macro SII$V_CSTAT_SIP = 0,2,1,0 %;      !  Selection in progress
macro SII$V_CSTAT_SWA = 0,3,1,0 %;      !  Selected with ATN
macro SII$V_CSTAT_TGT = 0,4,1,0 %;      !  Target
macro SII$V_CSTAT_DST = 0,5,1,0 %;      !  Destination
macro SII$V_CSTAT_CON = 0,6,1,0 %;      !  Connected
macro SII$V_CSTAT_SCH = 0,7,1,0 %;      !  State change
macro SII$V_CSTAT_LDN = 0,8,1,0 %;      !  List element done
macro SII$V_CSTAT_BUF = 0,9,1,0 %;      !  Buffer service
macro SII$V_CSTAT_TZ = 0,10,1,0 %;      !  Target pointer zero
macro SII$V_CSTAT_OBC = 0,11,1,0 %;     !  OUTEN bit cleared
macro SII$V_CSTAT_BER = 0,12,1,0 %;     !  Bus error
macro SII$V_CSTAT_RST = 0,13,1,0 %;     !  RST asserted
macro SII$V_CSTAT_DI = 0,14,1,0 %;      !  DSTAT interrupt
macro SII$V_CSTAT_CI = 0,15,1,0 %;      !  CSTAT Interrupt
literal SII$M_DSTAT_PHASE = 7;
literal SII$M_DSTAT_IO = 1;
literal SII$M_DSTAT_CD = 2;
literal SII$M_DSTAT_MSG = 4;
literal SII$M_DSTAT_ATN = 8;
literal SII$M_DSTAT_MIS = 16;
literal SII$M_DSTAT_OBB = 256;
literal SII$M_DSTAT_IPE = 512;
literal SII$M_DSTAT_IBF = 1024;
literal SII$M_DSTAT_TBE = 2048;
literal SII$M_DSTAT_TCZ = 4096;
literal SII$M_DSTAT_DNE = 8192;
literal SII$M_DSTAT_DI = 16384;
literal SII$M_DSTAT_CI = 32768;
literal SII$S_DSTAT = 2;
macro SII$V_DSTAT_PHASE = 0,0,3,0 %;
literal SII$S_DSTAT_PHASE = 3;
macro SII$V_DSTAT_IO = 0,0,1,0 %;       !  I/O signal
macro SII$V_DSTAT_CD = 0,1,1,0 %;       !  CD signal
macro SII$V_DSTAT_MSG = 0,2,1,0 %;      !  Message signal
macro SII$V_DSTAT_ATN = 0,3,1,0 %;      !  Attention
macro SII$V_DSTAT_MIS = 0,4,1,0 %;      !  Phase mismatch
macro SII$V_DSTAT_OBB = 0,8,1,0 %;      !  Odd Byte Boundary
macro SII$V_DSTAT_IPE = 0,9,1,0 %;      !  Incoming parity error
macro SII$V_DSTAT_IBF = 0,10,1,0 %;     !  Input buffer full
macro SII$V_DSTAT_TBE = 0,11,1,0 %;     !  Transmit buffer empty
macro SII$V_DSTAT_TCZ = 0,12,1,0 %;     !  Transfer counter zero
macro SII$V_DSTAT_DNE = 0,13,1,0 %;     !  Transfer done
macro SII$V_DSTAT_DI = 0,14,1,0 %;      !  DSTAT interrupt
macro SII$V_DSTAT_CI = 0,15,1,0 %;      !  CSTAT interrupt
literal SII$M_COMM_PHASE = 7;
literal SII$M_COMM_IO = 1;
literal SII$M_COMM_CD = 2;
literal SII$M_COMM_MSG = 4;
literal SII$M_COMM_ATN = 8;
literal SII$M_COMM_TGT = 16;
literal SII$M_COMM_ORI = 32;
literal SII$M_COMM_CON = 64;
literal SII$M_COMM_CMD_RESET = 128;
literal SII$M_COMM_CMD_DISC = 256;
literal SII$M_COMM_CMD_REQD = 512;
literal SII$M_COMM_CMD_SEL = 1024;
literal SII$M_COMM_CMD_XFER = 2048;
literal SII$M_COMM_RSL = 4096;
literal SII$M_COMM_RST = 16384;
literal SII$M_COMM_DMA = 32768;
literal SII$M_COMM_CMD = 3968;
literal SII$S_COMM = 2;
macro SII$V_COMM_PHASE = 0,0,3,0 %;
literal SII$S_COMM_PHASE = 3;
macro SII$V_COMM_IO = 0,0,1,0 %;        !  IO signal
macro SII$V_COMM_CD = 0,1,1,0 %;        !  CD signal
macro SII$V_COMM_MSG = 0,2,1,0 %;       !  MSG signal
macro SII$V_COMM_ATN = 0,3,1,0 %;       !  ATN signal
macro SII$V_COMM_TGT = 0,4,1,0 %;       !  Target state
macro SII$V_COMM_ORI = 0,5,1,0 %;       !  Destination state
macro SII$V_COMM_CON = 0,6,1,0 %;       !  Connected
macro SII$V_COMM_CMD_RESET = 0,7,1,0 %; !  Reset command
macro SII$V_COMM_CMD_DISC = 0,8,1,0 %;  !  Disconnect command
macro SII$V_COMM_CMD_REQD = 0,9,1,0 %;  !  Request Data command
macro SII$V_COMM_CMD_SEL = 0,10,1,0 %;  !  Select command
macro SII$V_COMM_CMD_XFER = 0,11,1,0 %; !  Data transfer command
macro SII$V_COMM_RSL = 0,12,1,0 %;      !  Reselect
macro SII$V_COMM_RST = 0,14,1,0 %;      !  Reset
macro SII$V_COMM_DMA = 0,15,1,0 %;      !  Perform DMA
macro SII$V_COMM_CMD = 0,7,5,0 %;
literal SII$S_COMM_CMD = 5;
literal SII$M_DICTRL_TST = 1;
literal SII$M_DICTRL_DIA = 2;
literal SII$M_DICTRL_PRE = 4;
literal SII$M_DICTRL_LDB = 8;
literal SII$S_DICTRL = 1;
macro SII$V_DICTRL_TST = 0,0,1,0 %;     !  Test mode
macro SII$V_DICTRL_DIA = 0,1,1,0 %;     !  Diagnostics mode
macro SII$V_DICTRL_PRE = 0,2,1,0 %;     !  Port Enable
macro SII$V_DICTRL_LDB = 0,3,1,0 %;     !  Loopback
 
!*** MODULE $SLMFLAGSDEF ***
! +
!  DEFINE FLAGS VIELDS
! -
! 
!  VIELD DEFINITION FOR FLAGS ARGUMENT
! 
literal SLM$M_NOHEADER = 1;
literal SLM$M_SYNCHRONOUS_OUTPUT = 2;
literal SLM$S_SLMFLAGSDEF = 1;
macro SLM$V_NOHEADER = 0,0,1,0 %;       !  Do not print header
macro SLM$V_SYNCHRONOUS_OUTPUT = 0,1,1,0 %; !  Print right now
 
!*** MODULE $SLVDEF ***
! 
! 
!  Define symbolic offsets for System Loadable Vectors.  These symbols
!  are used by the various pieces of the loadable EXEC, notably SCSVEC,
!  to create a list of vectors in system space and a corresponding image
!  that will be loaded into pool and connected to the system vectors.
! 
! 
literal SLV$K_LENGTH = 676;             !  SLV$K_LENGTH
literal SLV$S_SLV = 676;
macro SLV$L_CODESIZE = 0,0,32,0 %;      !  Loadable image size (in bytes)
macro SLV$L_INITRTN = 4,0,32,0 %;       !  Offset to init. routine
macro SLV$W_SIZE = 8,0,16,0 %;          !  Same as SLV$L_CODESIZE
macro SLV$B_TYPE = 10,0,8,0 %;          !  Structure type (DYN$C_LOADCODE)
macro SLV$B_SUBTYP = 11,0,8,0 %;        !  Sturcture Subtype
macro SLV$B_PROT_R = 12,0,8,0 %;        !  writeable protection for image
macro SLV$B_PROT_W = 13,0,8,0 %;        !  read-only protection for image
macro SLV$W_SPARE = 14,0,16,0 %;        !  spare field for future use
macro SLV$A_SYSVECS = 16,0,32,0 %;      !  address of vectors in SYS.EXE
macro SLV$T_FACILITY = 20,0,0,0 %;
literal SLV$S_FACILITY = 16;            !  facility name (.ASCIC)
macro SLV$T_LIST = 36,0,0,0 %;
literal SLV$S_LIST = 640;               !  Start of vector list (MAXVEC*5)
! 
! 
!  Define vector type codes.  The codes LODUMMY and HIDUMMY are
!  used as placeholders, to make the definition of the upper and
!  lower bound vector type symbols automatic.  New vector type codes
!  should be added at the end of the list, but before HIDUMMY.
! 
! 
literal SLV$K_LODUMMY = 0;              !  
literal SLV$K_LDATA = 1;                !  Longword pointer to data
literal SLV$K_AJUMP = 2;                !  Aligned jump
literal SLV$K_UJUMP = 3;                !  Unaligned jump
literal SLV$K_SDATA = 4;                !  Specified data
literal SLV$K_SJUMP = 5;                !  Specified jump
literal SLV$K_HIDUMMY = 6;              ! 
literal SLV$K_MINTYPE = 1;              !  Lower bound of vector type codes
literal SLV$K_MAXTYPE = 5;              !  Upper bount of vector type codes
literal SLV$K_MAXVEC = 128;             !  Max. # of vectors in list.
 
!*** MODULE $SMBDEF ***
!  Symbiont interface definitions
! +
!  Symbolic definitions for the symbiont to job controller interface.
! 
! 	Public definitions of message types, item codes, and
! 	other constants utilied by the symbiont to job controller
! 	interface facility.
! 
! -
! 
! 	Structure level
! 
literal SMBMSG$K_STRUCTURE_LEVEL = 1;   !  Current structure level
literal SMBMSG$K_STRUCTURE_LEVEL_1 = 1; !  Structure level 1
literal SMBMSG$K_ARCH_MAX_STREAMS = 32; !  Architected maximum streams per symbiont
! 
! 	Request header
! 
literal SMBMSG$K_PAUSE_TASK = 1;        !   - STOP /QUEUE
literal SMBMSG$K_RESET_STREAM = 2;      !   - STOP /QUEUE /RESET
literal SMBMSG$K_RESUME_TASK = 3;       !   - START /QUEUE (when paused)
literal SMBMSG$K_START_STREAM = 4;      !   - START /QUEUE (when stopped)
literal SMBMSG$K_START_TASK = 5;        !   - task available
literal SMBMSG$K_STOP_STREAM = 6;       !   - STOP /QUEUE /NEXT
literal SMBMSG$K_STOP_TASK = 7;         !   - STOP /QUEUE /ABORT or /REQUEUE
literal SMBMSG$K_TASK_COMPLETE = 8;     !   - stream is idle
literal SMBMSG$K_TASK_STATUS = 9;       !   - asynchronous status update
literal SMBMSG$K_START_SYMBIONT = 10;   !   - symbiont creation confirmation
literal SMBMSG$K_JOB_REQUEST = 11;      !   - request a job to be executed
literal SMBMSG$K_MAX_REQUEST_CODE = 12; !  MUST BE LAST
literal SMBMSG$S_REQUEST_HEADER = 12;
macro SMBMSG$W_REQUEST_CODE = 0,0,16,0 %; !  Request code
!   Define request codes
macro SMBMSG$B_STRUCTURE_LEVEL = 2,0,8,0 %; !  Message structure level
macro SMBMSG$B_STREAM_INDEX = 3,0,8,0 %; !  Stream index
macro SMBMSG$L_SYMBIONT_ID = 4,0,32,0 %; !  Symbiont identification
macro SMBMSG$L_JOB_ID = 8,0,32,0 %;     !  Job number (or 0 if a queue-oriented request)
! 
! 	Item header
! 
literal SMBMSG$K_ACCOUNTING_DATA = 1;   !   - accounting information
literal SMBMSG$K_ACCOUNT_NAME = 2;      !   - account name
literal SMBMSG$K_AFTER_TIME = 3;        !   - /AFTER value
literal SMBMSG$K_ALIGNMENT_PAGES = 4;   !   - /ALIGN count
literal SMBMSG$K_BOTTOM_MARGIN = 5;     !   - trailing blank lines
literal SMBMSG$K_CHARACTERISTICS = 6;   !   - /CHARACTERISTICS value
literal SMBMSG$K_CHECKPOINT_DATA = 7;   !   - checkpoint information
literal SMBMSG$K_CONDITION_VECTOR = 8;  !   - task error messages
literal SMBMSG$K_DEVICE_NAME = 9;       !   - /ON value
literal SMBMSG$K_DEVICE_STATUS = 10;    !   - device status
literal SMBMSG$K_ENTRY_NUMBER = 11;     !   - job entry number
literal SMBMSG$K_EXECUTOR_QUEUE = 12;   !   - this output queue
literal SMBMSG$K_FILE_COPIES = 13;      !   - /COPIES value
literal SMBMSG$K_FILE_COUNT = 14;       !   - current file copy number
literal SMBMSG$K_FILE_SETUP_MODULES = 15; !   - file setup module list
literal SMBMSG$K_FIRST_PAGE = 16;       !   - first page to print
literal SMBMSG$K_FORM_LENGTH = 17;      !   - lines per page
literal SMBMSG$K_FORM_NAME = 18;        !   - name of physical form
literal SMBMSG$K_FORM_SETUP_MODULES = 19; !   - form setup module list
literal SMBMSG$K_FORM_WIDTH = 20;       !   - columns per line
literal SMBMSG$K_FILE_IDENTIFICATION = 21; !   - device, fid, and did
literal SMBMSG$K_FILE_SPECIFICATION = 22; !   - file name
literal SMBMSG$K_JOB_COPIES = 23;       !   - /JOB_COUNT value
literal SMBMSG$K_JOB_COUNT = 24;        !   - current job copy number
literal SMBMSG$K_JOB_NAME = 25;         !   - /NAME value
literal SMBMSG$K_JOB_RESET_MODULES = 26; !   - job reset module list
literal SMBMSG$K_LAST_PAGE = 27;        !   - last page to print
literal SMBMSG$K_LEFT_MARGIN = 28;      !   - leading blank columns
literal SMBMSG$K_LIBRARY_SPECIFICATION = 29; !   - library name
literal SMBMSG$K_MAXIMUM_STREAMS = 30;  !   - maximum supported symbiont
literal SMBMSG$K_MESSAGE_VECTOR = 31;   !   - error messages to print
literal SMBMSG$K_NOTE = 32;             !   - /NOTE value
literal SMBMSG$K_PAGE_SETUP_MODULES = 33; !   - page setup module list
literal SMBMSG$K_PARAMETER_1 = 34;      !   - user parameter 1
literal SMBMSG$K_PARAMETER_2 = 35;      !   - user parameter 2
literal SMBMSG$K_PARAMETER_3 = 36;      !   - user parameter 3
literal SMBMSG$K_PARAMETER_4 = 37;      !   - user parameter 4
literal SMBMSG$K_PARAMETER_5 = 38;      !   - user parameter 5
literal SMBMSG$K_PARAMETER_6 = 39;      !   - user parameter 6
literal SMBMSG$K_PARAMETER_7 = 40;      !   - user parameter 7
literal SMBMSG$K_PARAMETER_8 = 41;      !   - user parameter 8
literal SMBMSG$K_PRINT_CONTROL = 42;    !   - printing control
literal SMBMSG$K_PRIORITY = 43;         !   - queue priority
literal SMBMSG$K_QUEUE = 44;            !   - generic queue name
literal SMBMSG$K_REFUSE_REASON = 45;    !   - reason task refused
literal SMBMSG$K_RELATIVE_PAGE = 46;    !   - /BACKWARD, /FORWARD values
literal SMBMSG$K_REQUEST_CONTROL = 47;  !   - request control
literal SMBMSG$K_REQUEST_RESPONSE = 48; !   - request code being responded to
literal SMBMSG$K_RIGHT_MARGIN = 49;     !   - trailing blank columns
literal SMBMSG$K_SEARCH_STRING = 50;    !   - /SEARCH value
literal SMBMSG$K_SEPARATION_CONTROL = 51; !   - separation control
literal SMBMSG$K_STOP_CONDITION = 52;   !   - reason for print abort
literal SMBMSG$K_TIME_QUEUED = 53;      !   - time queued
literal SMBMSG$K_TOP_MARGIN = 54;       !   - leading blank lines
literal SMBMSG$K_UIC = 55;              !   - UIC of submittor
literal SMBMSG$K_USER_NAME = 56;        !   - username
literal SMBMSG$K_CHECKPOINT_FREQUENCY = 57; !   - pages per checkpoint
literal SMBMSG$K_QUEUING_CONTROL = 58;  !   - queuing control
literal SMBMSG$K_RETRY_TIME = 59;       !   - delta time at which symbiont should retry job
literal SMBMSG$K_DEVICE_CONDITION = 60; !   - device error messages
literal SMBMSG$K_MESSAGE_FILE = 61;     !   - symbiont's message file
literal SMBMSG$K_AGENT_PROFILE = 62;    !   - security info
literal SMBMSG$K_CPU_LIMIT = 63;
literal SMBMSG$K_FILE_SEPARATION = 64;
literal SMBMSG$K_LOG_QUEUE = 65;
literal SMBMSG$K_LOG_SPECIFICATION = 66;
literal SMBMSG$K_LOG_SPOOL = 67;
literal SMBMSG$K_OPERATOR_REQUEST = 68;
literal SMBMSG$K_WSDEFAULT = 69;
literal SMBMSG$K_WSEXTENT = 70;
literal SMBMSG$K_WSQUOTA = 71;
literal SMBMSG$K_FILE_ATTRIBUTES = 72;
literal SMBMSG$K_FILE_ATTRIBUTES_SIZE = 73;
literal SMBMSG$K_JOB_ATTRIBUTES = 74;
literal SMBMSG$K_JOB_ATTRIBUTES_SIZE = 75;
literal SMBMSG$K_QUEUE_ATTRIBUTES = 76;
literal SMBMSG$K_QUEUE_ATTRIBUTES_SIZE = 77;
literal SMBMSG$K_SUBMITTER_EPID = 78;
! 
literal SMBMSG$K_MAX_ITEM_CODE = 79;    !  MUST BE LAST
literal SMBMSG$S_ITEM_HEADER = 4;
macro SMBMSG$W_ITEM_SIZE = 0,0,16,0 %;  !  Item size
macro SMBMSG$W_ITEM_CODE = 2,0,16,0 %;  !  Item code
!   Define item codes
! 
! 	ACCOUNTING_DATA item
! 
literal SMBMSG$S_ACCOUNTING_DATA = 16;
macro SMBMSG$L_PAGES_PRINTED = 0,0,32,0 %; !  Pages printed
macro SMBMSG$l_qio_puts = 4,0,32,0 %;   !  Lines printed
macro SMBMSG$l_rms_gets = 8,0,32,0 %;   !  File reads
macro SMBMSG$L_CPU_TIME = 12,0,32,0 %;  !  Processor time
! 
! 	CHECKPOINT_DATA item
! 
literal SMBMSG$S_CHECKPOINT_DATA = 24;
macro SMBMSG$B_FILLER = 0,0,8,0 %;      !  Reserved
macro SMBMSG$B_CHECKPOINT_LEVEL = 1,0,8,0 %; !  Checkpoint structure level
macro SMBMSG$W_OFFSET = 2,0,16,0 %;     !  Offset into record
macro SMBMSG$L_CARCON = 4,0,32,0 %;     !  Carriage control
macro SMBMSG$L_PAGE = 8,0,32,0 %;       !  Page number
macro SMBMSG$L_RECORD_NUMBER = 12,0,32,0 %; !  Record number
macro SMBMSG$Q_USER_KEY = 16,0,0,0 %;
literal SMBMSG$S_USER_KEY = 8;          !  User positioning key
! 
! 	DEVICE_STATUS item
! 
literal SMBMSG$M_LOWERCASE = 1;
literal SMBMSG$M_PAUSE_TASK = 2;
literal SMBMSG$M_REMOTE = 4;
literal SMBMSG$M_SERVER = 8;
literal SMBMSG$M_STALLED = 16;
literal SMBMSG$M_STOP_STREAM = 32;
literal SMBMSG$M_TERMINAL = 64;
literal SMBMSG$M_UNAVAILABLE = 128;
literal SMBMSG$M_SYM_NOTIFIES = 256;
literal SMBMSG$M_SYM_REQUESTS_OPER = 512;
literal SMBMSG$M_SYM_COPIES_FILE = 1024;
literal SMBMSG$M_SYM_COPIES_JOB = 2048;
literal SMBMSG$M_SYM_ACCEPTS_ALL_FORMS = 4096;
literal SMBMSG$M_SYM_NO_JOB_CHECKPOINT = 8192;
literal SMBMSG$M_SYM_ALL_CHARACTERISTIC = 16384;
literal SMBMSG$M_NOTIFY_ON_INTERRUPT = 32768;
literal SMBMSG$S_DEVICE_STATUS = 4;
macro SMBMSG$L_DEVICE_FLAGS = 0,0,32,0 %; !  Device flags
macro SMBMSG$V_LOWERCASE = 0,0,1,0 %;   !   - supports lowercase
macro SMBMSG$V_PAUSE_TASK = 0,1,1,0 %;  !   - symbiont initiated pause
macro SMBMSG$V_REMOTE = 0,2,1,0 %;      !   - device is remote
macro SMBMSG$V_SERVER = 0,3,1,0 %;      !   - server symbiont
macro SMBMSG$V_STALLED = 0,4,1,0 %;     !   - task stalled
macro SMBMSG$V_STOP_STREAM = 0,5,1,0 %; !   - symbiont requesting stop stream
macro SMBMSG$V_TERMINAL = 0,6,1,0 %;    !   - device is a terminal
macro SMBMSG$V_UNAVAILABLE = 0,7,1,0 %; !   - device unavailable
macro SMBMSG$V_SYM_NOTIFIES = 0,8,1,0 %; !   - Symbiont notifies for job completions
macro SMBMSG$V_SYM_REQUESTS_OPER = 0,9,1,0 %; !   - Symbiont generates operator messages
macro SMBMSG$V_SYM_COPIES_FILE = 0,10,1,0 %; !   - Symbiont generates multiple file copies
macro SMBMSG$V_SYM_COPIES_JOB = 0,11,1,0 %; !   - Symbiont generates multiple job copies
macro SMBMSG$V_SYM_ACCEPTS_ALL_FORMS = 0,12,1,0 %; !   - Symbiont processes all form types
macro SMBMSG$V_SYM_NO_JOB_CHECKPOINT = 0,13,1,0 %; !   - Always reprocess full job on a restart
macro SMBMSG$V_SYM_ALL_CHARACTERISTIC = 0,14,1,0 %; !   - Symbiont processes all characteristics
macro SMBMSG$V_NOTIFY_ON_INTERRUPT = 0,15,1,0 %; !   - Symbiont notifies user on job interrupt
! 
! 	PRINT_CONTROL item
! 
literal SMBMSG$M_DOUBLE_SPACE = 1;
literal SMBMSG$M_PAGE_HEADER = 2;
literal SMBMSG$M_PAGINATE = 4;
literal SMBMSG$M_PASSALL = 8;
literal SMBMSG$M_SEQUENCED = 16;
literal SMBMSG$M_SHEET_FEED = 32;
literal SMBMSG$M_TRUNCATE = 64;
literal SMBMSG$M_WRAP = 128;
literal SMBMSG$M_RECORD_BLOCKING = 256;
literal SMBMSG$M_PAGE_FOOTER = 512;
literal SMBMSG$M_DELETE_FILE = 1024;
literal SMBMSG$M_LOWERCASE_EXPLICIT = 2048;
literal SMBMSG$M_NOTIFY = 4096;
literal SMBMSG$M_RESTART = 8192;
literal SMBMSG$M_JOB_RETAIN = 16384;
literal SMBMSG$M_JOB_ERROR_RETAIN = 32768;
literal SMBMSG$S_PRINT_CONTROL = 4;
macro SMBMSG$L_PRINT_FLAGS = 0,0,32,0 %; !  Print flags
macro SMBMSG$V_DOUBLE_SPACE = 0,0,1,0 %; !   - double space
macro SMBMSG$V_PAGE_HEADER = 0,1,1,0 %; !   - print page headers
macro SMBMSG$V_PAGINATE = 0,2,1,0 %;    !   - insert <FF>'s
macro SMBMSG$V_PASSALL = 0,3,1,0 %;     !   - binary print file
macro SMBMSG$V_SEQUENCED = 0,4,1,0 %;   !   - print sequence numbers
macro SMBMSG$V_SHEET_FEED = 0,5,1,0 %;  !   - pause at every TOF
macro SMBMSG$V_TRUNCATE = 0,6,1,0 %;    !   - truncate on overflow
macro SMBMSG$V_WRAP = 0,7,1,0 %;        !   - wrap on overflow
macro SMBMSG$V_RECORD_BLOCKING = 0,8,1,0 %; !   - block records in output buffer
macro SMBMSG$V_PAGE_FOOTER = 0,9,1,0 %; !   - print page footers
macro SMBMSG$V_DELETE_FILE = 0,10,1,0 %; !   - delete file after printing
macro SMBMSG$V_LOWERCASE_EXPLICIT = 0,11,1,0 %; !   - job for printer that supports lowercase
macro SMBMSG$V_NOTIFY = 0,12,1,0 %;     !   - notify user when job completes
macro SMBMSG$V_RESTART = 0,13,1,0 %;    !   - restart job after crash or requeue
macro SMBMSG$V_JOB_RETAIN = 0,14,1,0 %; !   - per job retain
macro SMBMSG$V_JOB_ERROR_RETAIN = 0,15,1,0 %; !   - per job retain on error
! 
! 	REQUEST_CONTROL item
! 
literal SMBMSG$M_ALIGNMENT_MASK = 1;
literal SMBMSG$M_PAUSE_COMPLETE = 2;
literal SMBMSG$M_RESTARTING = 4;
literal SMBMSG$M_TOP_OF_FILE = 8;
literal SMBMSG$S_REQUEST = 4;
macro SMBMSG$L_REQUEST_FLAGS = 0,0,32,0 %; !  Print flags
macro SMBMSG$V_ALIGNMENT_MASK = 0,0,1,0 %; !   - print A's and 9's
macro SMBMSG$V_PAUSE_COMPLETE = 0,1,1,0 %; !   - pause when request complete
macro SMBMSG$V_RESTARTING = 0,2,1,0 %;  !   - job is restarting
macro SMBMSG$V_TOP_OF_FILE = 0,3,1,0 %; !   - rewind before resume
! 
! 	SEPARATION_CONTROL item
! 
literal SMBMSG$M_FILE_BURST = 1;
literal SMBMSG$M_FILE_FLAG = 2;
literal SMBMSG$M_FILE_TRAILER = 4;
literal SMBMSG$M_FILE_TRAILER_ABORT = 8;
literal SMBMSG$M_JOB_FLAG = 16;
literal SMBMSG$M_JOB_BURST = 32;
literal SMBMSG$M_JOB_RESET = 64;
literal SMBMSG$M_JOB_RESET_ABORT = 128;
literal SMBMSG$M_JOB_TRAILER = 256;
literal SMBMSG$M_JOB_TRAILER_ABORT = 512;
literal SMBMSG$M_FIRST_FILE_OF_JOB = 1024;
literal SMBMSG$M_LAST_FILE_OF_JOB = 2048;
literal SMBMSG$S_SEPARATION_CONTROL = 4;
macro SMBMSG$L_SEPARATION_FLAGS = 0,0,32,0 %; !  Print flags
macro SMBMSG$V_FILE_BURST = 0,0,1,0 %;  !   - print file burst page
macro SMBMSG$V_FILE_FLAG = 0,1,1,0 %;   !   - print file flag page
macro SMBMSG$V_FILE_TRAILER = 0,2,1,0 %; !   - print file trailer page
macro SMBMSG$V_FILE_TRAILER_ABORT = 0,3,1,0 %; !   - print file trailer page
macro SMBMSG$V_JOB_FLAG = 0,4,1,0 %;    !   - print job flag page
macro SMBMSG$V_JOB_BURST = 0,5,1,0 %;   !   - print job burst page
macro SMBMSG$V_JOB_RESET = 0,6,1,0 %;   !   - execute job reset sequence
macro SMBMSG$V_JOB_RESET_ABORT = 0,7,1,0 %; !   - execute job reset sequence
macro SMBMSG$V_JOB_TRAILER = 0,8,1,0 %; !   - print job trailer page
macro SMBMSG$V_JOB_TRAILER_ABORT = 0,9,1,0 %; !   - print job trailer page
macro SMBMSG$V_FIRST_FILE_OF_JOB = 0,10,1,0 %; !   - this is the first file of the current job
macro SMBMSG$V_LAST_FILE_OF_JOB = 0,11,1,0 %; !   - this is the last file of the current job
! 
! 	QUEUING_CONTROL item
! 
literal SMBMSG$M_RETAIN_JOB = 1;
literal SMBMSG$S_QUEUING_CONTROL = 4;
macro SMBMSG$L_QUEUING_FLAGS = 0,0,32,0 %; !  Queuing flags
macro SMBMSG$V_RETAIN_JOB = 0,0,1,0 %;  !   - symbiont retained job on "fixable" error
 
!*** MODULE SNAPFKVECDEF ***
literal SNAPFKVEC$K_TIMEOUT = 15;       !  MAXIMUM DELAY TIME
literal SNAPFKVEC$K_LENGTH = 32;        ! LENGTH OF OVERHEAD AREA
literal SNAPFKVEC$C_LENGTH = 32;        ! LENGTH OF OVERHEAD AREA
literal SNAPFKVEC$S_SNAPFKVECDEF = 32;
macro SNAPFKVEC$L_FQFL = 0,0,32,0 %;    ! FORK QUEUE FORWARD LINK 
macro SNAPFKVEC$L_FQBL = 4,0,32,0 %;    ! FORK QUEUE BACKWARD LINK 
macro SNAPFKVEC$W_SIZE = 8,0,16,0 %;    ! SIZE OF BLOCK IN BYTES 
macro SNAPFKVEC$W_TYPE = 10,0,16,0 %;   ! STRUCTURE TYPE
macro SNAPFKVEC$L_REFCNT = 12,0,32,0 %; ! REFERENCE COUNT
macro SNAPFKVEC$L_COUNT = 16,0,32,0 %;  ! MAXIMUM VECTOR INDEX
macro SNAPFKVEC$W_EVENT = 20,0,16,0 %;  ! CURRENT EVENT CODE
macro SNAPFKVEC$W_SEED = 22,0,16,0 %;   ! SEQUENCE SEED
macro SNAPFKVEC$L_STATUS = 24,0,32,0 %; ! ABORT STATUS
macro SNAPFKVEC$L_VECTOR = 28,0,32,0 %; ! BEGINNING OF VECTOR AREA
! THE VECTOR AREA SIZE IS "COUNT" LONGWORDS
 
!*** MODULE SNAPSTATEDEF ***
literal SNAPSTATE$M_ACTIVE = 1;
literal SNAPSTATE$M_NORETURN = 2;
literal SNAPSTATE$M_ABORT = 4;
literal SNAPSTATE$M_RESUME = 8;
literal SNAPSTATE$M_POWER = 16;
literal SNAPSTATE$M_WATCHDOG = 32;
literal SNAPSTATE$M_ENABLEWATCH = 64;
literal SNAPSTATE$M_DEBUG = 128;
literal SNAPSTATE$M_CLEANUP = 256;
literal SNAPSTATE$S_SNAPSTATEDEF = 4;
macro SNAPSTATE$V_ACTIVE = 0,0,1,0 %;   !  Snapshot process is active
macro SNAPSTATE$V_NORETURN = 0,1,1,0 %; !  Snapshot is committed and an abort is not possible
macro SNAPSTATE$V_ABORT = 0,2,1,0 %;    !  Snapshot being aborted
macro SNAPSTATE$V_RESUME = 0,3,1,0 %;   !  O.K. to resume other processes.
macro SNAPSTATE$V_POWER = 0,4,1,0 %;    !  Powerfail exception in progress
macro SNAPSTATE$V_WATCHDOG = 0,5,1,0 %; !  Snapshot watchdog is active (set by the watchdog process)
macro SNAPSTATE$V_ENABLEWATCH = 0,6,1,0 %; !  Snapshot watchdog is enabled (set by the snapshot process)
macro SNAPSTATE$V_DEBUG = 0,7,1,0 %;    !  Snapshot watchdog may detect erroneous timeouts caused by the debugger
macro SNAPSTATE$V_CLEANUP = 0,8,1,0 %;  !  Snapshot cleanup process has been started
 
!*** MODULE $SPDTDEF ***
! +
!  $SPDTDEF	- SCSI PORT DESCRIPTOR TABLE DEFINITIONS.    
!                     
!  THERE IS ONE SPDT PER PORT. THE SPDT CONTAINS THE SCSI PORT INFORMATION
!  FOR ONE SCSI PORT. SPDT'S ARE CREATED BY THE UNIT INIT ROUTINES 
!  OF THE INDIVIDUAL PORT DRIVERS. DURING INITIALIZATION THE PORT DRIVER'S
!  PORT ROUTINE ENTRY POINTS ARE INITIALIZED IN THE SPDT. THE CLASS DRIVERS 
!  EXECUTE THESE ENTRY POINTS TO INTERACT WITH THE UNDERLYING PORT HARDWARE.
! 
!  THIS STRUCTURE IS READ ACCESSABLE TO THE CLASS DRIVER AND READABLE AND
!  WRITEABLE BY THE PORT DRIVER.
! -
! 
!  ***NOTE1:**** NEW SPDT FIELDS MUST BE ENTERED AFTER THE DISPATCH VECTORS
!                                                                       
! 
!  ***NOTE2:**** IF AN INCOMPATIBLE CHANGE IS MADE TO THIS STRUCTURE BUMP
!                THE VERSION NUMBER OF THIS STRUCTURE.
!                                                                       
literal SPDT$C_VERSION = 2;             ! COMPATIBLE VERSION NUMBER.
literal SPDT$C_PKN = 1;                 ! SCSI NCR 5380 Port.
literal SPDT$C_PKS = 2;                 ! SCSI SII Port.
literal SPDT$C_PKC = 3;                 ! SCSI NCR 53C94 Port.
literal SPDT$M_ONLINE = 1;
literal SPDT$M_TIMOUT = 2;
literal SPDT$M_ERLOGIP = 4;
literal SPDT$M_CANCEL = 8;
literal SPDT$M_POWER = 16;
literal SPDT$M_BSY = 32;
literal SPDT$M_FAILED = 64;
literal SPDT$M_FIFOLCK = 128;
literal SPDT$M_SYNCH = 1;
literal SPDT$M_ASYNCH = 2;
literal SPDT$M_MAPPING_REG = 4;
literal SPDT$M_BUF_DMA = 8;
literal SPDT$M_DIR_DMA = 16;
literal SPDT$M_AEN = 32;
literal SPDT$M_LUNS = 64;
literal SPDT$C_PKSLENGTH = 684;         ! SIZE OF SPDT
literal SPDT$C_PKCLENGTH = 684;         ! SIZE OF SPDT
! 
literal SPDT$C_PKNLENGTH = 704;         ! SIZE OF SPDT
literal SPDT$S_SPDTDEF = 704;
macro SPDT$L_FLINK = 0,0,32,0 %;        ! LINK TO NEXT SCS SPDT
macro SPDT$W_SIZE = 4,0,16,0 %;         ! STRUCTURE SIZE IN BYTES 
macro SPDT$B_TYPE = 6,0,8,0 %;          ! STRUCTURE TYPE 
macro SPDT$B_SUBTYP = 7,0,8,0 %;        ! STRUCTURE SUBTYPE 
macro SPDT$W_SPDT_TYPE = 8,0,16,0 %;    ! TYPE OF SPDT       
macro SPDT$B_SCSI_INT_MSK = 10,0,8,0 %; ! PORT-SPECIFIC INTERRUPT MASK
!  FORK BLOCK USED DURING RESELECTIONS.
macro SPDT$B_FLCK = 11,0,8,0 %;         !  FORK LOCK INDEX 
macro SPDT$L_FPC = 12,0,32,0 %;         ! SAVED FORK PROCESS PC 
macro SPDT$L_FR3 = 16,0,32,0 %;         ! SAVED FORK PROCESS R3
macro SPDT$L_FR4 = 20,0,32,0 %;         ! SAVED FORK PROCESS R4 
macro SPDT$L_SCSI_PORT_ID = 24,0,32,0 %; ! SCSI PORT ID.  (A..Z)   
macro SPDT$L_SCSI_BUS_ID = 28,0,32,0 %; ! SCSI BUS ID.   (0..7)
macro SPDT$L_STS = 32,0,32,0 %;         ! PORT DEVICE STATUS 
macro SPDT$V_ONLINE = 32,0,1,0 %;       !  UNIT ONLINE (1=YES) 
macro SPDT$V_TIMOUT = 32,1,1,0 %;       !  UNIT TIMED OUT (1=YES)    
macro SPDT$V_ERLOGIP = 32,2,1,0 %;      !  ERROR LOG IN PROGRESS ON UNIT (1=YES) 
macro SPDT$V_CANCEL = 32,3,1,0 %;       !  CANCEL I/O ON UNIT (1=YES) 
macro SPDT$V_POWER = 32,4,1,0 %;        !  POWER FAILED WHILE UNIT BUSY (1=YES) 
macro SPDT$V_BSY = 32,5,1,0 %;          !  UNIT IS BUSY (1=YES) 
macro SPDT$V_FAILED = 32,6,1,0 %;       !  PORT FAILED OPERATION OR INITIALIZATION.
macro SPDT$V_FIFOLCK = 32,7,1,0 %;      !  N53C94 fifo in use.
macro SPDT$L_PORT_WQFL = 36,0,32,0 %;   ! PORT WAIT QUEUE FORWARD LINK
macro SPDT$L_PORT_WQBL = 40,0,32,0 %;   ! PORT WAIT QUEUE BACKWARD LINK
macro SPDT$L_MAXBYTECNT = 44,0,32,0 %;  ! MAXIMUM BYTE COUNT FOR A TRANSFER.
macro SPDT$L_WAITQFL = 48,0,32,0 %;     ! LISTHEAD FOR FORK BLOCKS WAITING 
macro SPDT$L_WAITQBL = 52,0,32,0 %;     ! FOR NONPAGED POOL    
macro SPDT$L_PORT_UCB = 56,0,32,0 %;    ! ADDR OF PORT UCB.
macro SPDT$L_PORT_CSR = 60,0,32,0 %;    ! CSR ADDR OF PORT HARDWARE. 
macro SPDT$L_PORT_IDB = 64,0,32,0 %;    ! ADDR OF PORT IDB.
macro SPDT$L_DMA_BASE = 68,0,32,0 %;    ! BASE ADDRESS OF DMA BUFFER
macro SPDT$L_SPTE_BASE = 72,0,32,0 %;   ! S0 BASE ADDRESS OF BUFFER
macro SPDT$L_SPTE_SVAPTE = 76,0,32,0 %; ! SVAPTE OF 1ST SPTE USED TO DOUBLE MAP 
macro SPDT$L_ADP = 80,0,32,0 %;         ! ADDR OF ADP
macro SPDT$L_PORT_RING = 84,0,0,0 %;
literal SPDT$S_PORT_RING = 64;
macro SPDT$L_PORT_RING_PTR = 148,0,32,0 %;
macro SPDT$L_OWNERSCDT = 152,0,32,0 %;  ! SCDT ADDR OF CNNCTN WHICH OWNS PORT.
macro SPDT$L_SCDT_VECTOR = 156,0,0,1 %;
literal SPDT$S_SCDT_VECTOR = 256;       ! SCDT VECTOR
macro SPDT$L_SCDT_VECTOR_ID0 = 156,0,0,1 %;
literal SPDT$S_SCDT_VECTOR_ID0 = 32;    ! SCDT VECTOR FOR SCSI ID 0
macro SPDT$L_SCDT_VECTOR_ID1 = 188,0,0,1 %;
literal SPDT$S_SCDT_VECTOR_ID1 = 32;    ! SCDT VECTOR FOR SCSI ID 1
macro SPDT$L_SCDT_VECTOR_ID2 = 220,0,0,1 %;
literal SPDT$S_SCDT_VECTOR_ID2 = 32;    ! SCDT VECTOR FOR SCSI ID 2
macro SPDT$L_SCDT_VECTOR_ID3 = 252,0,0,1 %;
literal SPDT$S_SCDT_VECTOR_ID3 = 32;    ! SCDT VECTOR FOR SCSI ID 3
macro SPDT$L_SCDT_VECTOR_ID4 = 284,0,0,1 %;
literal SPDT$S_SCDT_VECTOR_ID4 = 32;    ! SCDT VECTOR FOR SCSI ID 4
macro SPDT$L_SCDT_VECTOR_ID5 = 316,0,0,1 %;
literal SPDT$S_SCDT_VECTOR_ID5 = 32;    ! SCDT VECTOR FOR SCSI ID 5
macro SPDT$L_SCDT_VECTOR_ID6 = 348,0,0,1 %;
literal SPDT$S_SCDT_VECTOR_ID6 = 32;    ! SCDT VECTOR FOR SCSI ID 6
macro SPDT$L_SCDT_VECTOR_ID7 = 380,0,0,1 %;
literal SPDT$S_SCDT_VECTOR_ID7 = 32;    ! SCDT VECTOR FOR SCSI ID 7
macro SPDT$L_DLCK = 412,0,32,0 %;       ! DEVICE LOCK ADDRESS
macro SPDT$B_DIPL = 416,0,8,0 %;        ! DEVICE IPL
macro SPDT$B_PAD1 = 417,0,8,0 %;        ! BYTE PAD
macro SPDT$W_PAD2 = 418,0,16,0 %;       ! WORD PAD
macro SPDT$L_AUXSTRUC = 420,0,32,0 %;   ! ADDR OF AUXILARY DATA STRUCTURE 
macro SPDT$L_SEL_SCDRP = 424,0,32,0 %;  ! SCDRP used during selection interrupt
macro SPDT$L_ENB_SEL_SCDRP = 428,0,32,0 %; ! SCDRP used to enable selection 
! interrupts in port timer routine
! 
!  The SCSI Port Interface entry points follow. These entry
!  points are fork entry points that the class driver envokes
!  to execute port specific functions.
!                                 
macro SPDT$L_MAP_BUFFER = 432,0,32,0 %; ! MAP A BUFFER FOR READ OR WRITE XFER
macro SPDT$L_UNMAP = 436,0,32,0 %;      ! UNMAP A BUFFER 
macro SPDT$L_SEND = 440,0,32,0 %;       ! SEND TO DEVICE.      
macro SPDT$L_SET_CONN_CHAR = 444,0,32,0 %; ! SET CONNECT CHAR.
macro SPDT$L_GET_CONN_CHAR = 448,0,32,0 %; ! GET CONNECT CHAR.
macro SPDT$L_RESET = 452,0,32,0 %;      ! MAINT RESET OF PORT
macro SPDT$L_CONNECT = 456,0,32,0 %;    ! REQUEST CONNECTION TO TARGET.
macro SPDT$L_DISCONNECT = 460,0,32,0 %; ! BREAK CONNECTION.
macro SPDT$L_ALLOC_COMMAND_BUFFER = 464,0,32,0 %; ! ALLOCATE A MESSAGE BUFFER 
macro SPDT$L_DEALLOC_COMMAND_BUFFER = 468,0,32,0 %; ! DEALLOCATE BUFFER 
macro SPDT$L_ABORT = 472,0,32,0 %;      ! ABORT OUTSTANDING CMD.
!  The following set of entry points are for target mode operation
macro SPDT$L_SET_PHASE = 476,0,32,0 %;  !  Set SCSI bus phase
macro SPDT$L_SENSE_PHASE = 480,0,32,0 %; !  Sense SCSI bus phase, ATN signal
macro SPDT$L_SEND_BYTES = 484,0,32,0 %; !  Send bytes on SCSI bus
macro SPDT$L_RECEIVE_BYTES = 488,0,32,0 %; !  Receive bytes from SCSI bus
macro SPDT$L_FINISH_CMD = 492,0,32,0 %; !  Complete command
macro SPDT$L_RELEASE_BUS = 496,0,32,0 %; !  Release SCSI bus
macro SPDT$L_RSVD1 = 500,0,32,0 %;      ! TBD
macro SPDT$L_RSVD2 = 504,0,32,0 %;      ! TBD
macro SPDT$L_RSVD3 = 508,0,32,0 %;      ! TBD
macro SPDT$B_BUS_HUNG_VEC = 552,0,8,0 %; ! VECTOR OF SUSPECTED HUNG CONNECTIONS.
macro SPDT$B_FILL_11 = 553,0,24,1 %;
literal SPDT$S_FILL_11 = 3;
! 
!  This TQE is used by the port driver to timeout pending disconnected IO's
!  When this TQE expires, the timer thread will timeout expired pending IO's.
! 
macro SPDT$B_TQE = 556,0,0,0 %;
literal SPDT$S_TQE = 52;                !  Timer queue entry
macro SPDT$L_TQE_DELAY = 608,0,32,0 %;  !  Delay time for next TQE delay.
! 
!  SCSI PORT EVENT COUNTERS, THESE COUNTERS ARE FOR EVENTS THAT ARE
!  CHARACTERISTIC OF THE PORT NOT A CONNECTION AND THAT DON'T NEED
!  TO BE RECORDED ON A CONNECTION BY CONNECTION BASIS.
!                                                                      
macro SPDT$L_BUS_HUNG_CNT = 612,0,32,0 %; !  COUNT OF DETECTED BUS HANGS.
macro SPDT$L_TARRST_CNT = 616,0,32,0 %; !  COUNT OF TARGET INITIATED BUS RESETS.
macro SPDT$L_RETRY_CNT = 620,0,32,0 %;  !  COUNT OF TOTAL NUMBER OF RETRY ATTEMPTS.
macro SPDT$L_STRAY_INT_CNT = 624,0,32,0 %; !  COUNT OF INT WHEN NO OWNER OF CHAN.
macro SPDT$L_UNEXP_INT_CNT = 628,0,32,0 %; !  COUNT OF UNEXP INT WHEN CHAN OWNED.
macro SPDT$L_NODISCON_CNT = 632,0,32,0 %; !  COUNT OF RESEL WHEN NOT DISCONNECTED.
macro SPDT$W_FILL_12 = 636,0,16,0 %;
macro SPDT$W_DISCON_CNT = 638,0,16,0 %; !  COUNT OF OUTSTANDING DISCONNECTS
macro SPDT$L_PORT_FLAGS = 640,0,32,0 %; !  PORT SPECIFIC FLAGS.
macro SPDT$V_SYNCH = 640,0,1,0 %;       !  SUPPORTS SYNCHRONOUS MODE.
macro SPDT$V_ASYNCH = 640,1,1,0 %;      !  SUPPORTS ASYNCHRONOUS MODE.
macro SPDT$V_MAPPING_REG = 640,2,1,0 %; !  SUPPORTS MAPPING REGISTERS.
macro SPDT$V_BUF_DMA = 640,3,1,0 %;     !  SUPPORTS BUFFERED DMA.
macro SPDT$V_DIR_DMA = 640,4,1,0 %;     !  SUPPORTS DIRECT DMA.
macro SPDT$V_AEN = 640,5,1,0 %;         !  SUPPORTS ASYNC EVENT NOTIFICATION
macro SPDT$V_LUNS = 640,6,1,0 %;        !  SUPPORTS LUNS
macro SPDT$L_VERSION_CHECK = 644,0,32,0 %; !  VALUE USED TO CHECK DRIVER VERSIONS
macro SPDT$L_RSVD_LONG = 648,0,0,1 %;
literal SPDT$S_RSVD_LONG = 36;          !  Reserved space.
!  These fields are required by PKNDRIVER until TKDRIVER is migrated to a 
!  full class driver.
!  When TVDRIVER is rewritten these fields MUST be moved to the UCB of 
!  PKNDRIVER. These fields are here to provide a work around which will
!  allow the port to detect multiple interrupting conditions during a single 
!  interrupt.                                               
! 
macro SPDT$B_CUR_STAT = 684,0,8,0 %;    ! COPY OF CUR_STAT REGISTER. 
macro SPDT$B_STATUS = 685,0,8,0 %;      ! COPY OF STATUS REGISTER.
macro SPDT$B_MODE = 686,0,8,0 %;        ! COPY OF THE MODE.             
macro SPDT$B_EVENT_CNT = 687,0,8,0 %;   ! COUNT NUMBER OF EVENTS THIS INTERRUPT.
!                                                                             
!  The following fields are used to allow TVDRIVER and DVDRIVER to execute on
!  same system as PKNDRIVER. These fields may be removed when TVDRIVER is 
!  no longer supported.
!   
macro SPDT$L_TVDRV_ISR = 688,0,32,0 %;  ! ADDR OF TVDRIVER'S ISR
macro SPDT$L_TVDRV_DMA_BASE = 692,0,32,0 %; ! ADDR OF TVDRIVER DMA BUFFER 
macro SPDT$L_TVDRV_DMA_SIZE = 696,0,32,0 %; ! SIZE OF TVDRIVER'S DMA BUFFER 
macro SPDT$L_TVDRV_UCB = 700,0,32,0 %;  ! ADDR OF TVDRIVER'S UCB
 
!*** MODULE $SPLCODDEF ***
! +
! 
!  SPINLOCK INDEX DEFINITIONS
! 
! -
! 
!  DEFINE THE HARDWARE LEVEL LOCKS (INDICES 0-F)
! 
literal SPL$C_EMB = 32;                 !  EMB spinlock index
literal SPL$C_MCHECK = 33;              !  Machine Check spinlock index
literal SPL$C_MEGA = 34;                !  Kitchen sink of spinlocks
literal SPL$C_HWCLK = 35;               !  HWCLK spinlock index
literal SPL$C_VIRTCONS = 36;            !  VIRTCONS spinlock index
literal SPL$C_INVALIDATE = 37;          !  INVALIDATE spinlock index
literal SPL$C_PERFMON = 38;             !  PERFMON spinlock index
literal SPL$C_POOL = 39;                !  POOL spinlock index
literal SPL$C_MAILBOX = 40;             !  MAILBOX spinlock index
literal SPL$C_PR_LK11 = 41;             !  PRIMARY IPL 11 spinlock index
literal SPL$C_IOLOCK11 = 42;            !  IPL 11 I/O spinlock index
literal SPL$C_PR_LK10 = 43;             !  PRIMARY IPL 10 spinlock index
literal SPL$C_IOLOCK10 = 44;            !  IPL 10 I/O spinlock index
literal SPL$C_PR_LK9 = 45;              !  PRIMARY IPL 9 spinlock index
literal SPL$C_IOLOCK9 = 46;             !  IPL 9 I/O spinlock index
literal SPL$C_SCHED = 47;               !  SCHED spinlock index
literal SPL$C_MMG = 48;                 !  Memory management spinlock index
literal SPL$C_JIB = 49;                 !  JIB spinlock index
literal SPL$C_TIMER = 50;               !  TIMER spinlock index
literal SPL$C_PR_LK8 = 51;              !  PRIMARY IPL 8 spinlock index
literal SPL$C_IOLOCK8 = 52;             !  IPL 8 I/O spinlock index
literal SPL$C_FILSYS = 53;              !  File system spinlock index
literal SPL$C_QUEUEAST = 54;            !  QUEUEAST spinlock index
literal SPL$C_ASTDEL = 55;              !   temporary lock for UIS
literal SPL$C_SCS = 52;                 !  SCS spinlock index
literal SPL$_MIN_INDEX = 32;            !  Min spinlock index
literal SPL$_MAX_INDEX = 56;            !  Max spinlock index
literal SPL$_NUM_LOCKS = 31;            !  Max number of spinlocks (ever)
! 
!  Define some system-wide multiprocessing control flags
! 
literal SMP$M_ENABLED = 1;
literal SMP$M_START_CPU = 2;
literal SMP$M_CRASH_CPU = 4;
literal SMP$M_TODR = 8;
literal SMP$M_UNMOD_DRIVER = 16;
literal SMP$M_TODR_ACK = 32;
literal SMP$M_SYNCH = 64;
literal SMP$M_BENIGN = 128;
literal SMP$M_OVERRIDE = 1;
literal SMP$M_FOREVER = 2;
literal SMP$S_SMPDEF = 8;
macro SMP$L_FLAGS = 0,0,32,0 %;         !  SMP$GL_FLAGS
macro SMP$V_ENABLED = 0,0,1,0 %;        !  SMP operation is enabled
macro SMP$V_START_CPU = 0,1,1,0 %;      !  PRIMARY CPU has finished INIT
macro SMP$V_CRASH_CPU = 0,2,1,0 %;      !  A CPU is initiating BUGCHECK
macro SMP$V_TODR = 0,3,1,0 %;           !  SMP$GL_PROPOSED_TODR in use
macro SMP$V_UNMOD_DRIVER = 0,4,1,0 %;   !  Unmodified driver is loaded
macro SMP$V_TODR_ACK = 0,5,1,0 %;       !  SMP TODR operation complete
macro SMP$V_SYNCH = 0,6,1,0 %;          !  SMP SYNCHRONIZATION IMAGE LOADED
macro SMP$V_BENIGN = 0,7,1,0 %;         !  BENIGN STATE REQUESTED
macro SMP$L_STOP_CPU_FLAGS = 4,0,32,0 %; !  Input to STOP/CPU
macro SMP$V_OVERRIDE = 4,0,1,0 %;       !  Skip checks before stopping CPU
macro SMP$V_FOREVER = 4,1,1,0 %;        !  FOREVER means remove from
!  available set after stopping.
 
!*** MODULE $SPLDEF ***
! 
!   SPINLOCK Control Block
! 
literal SPL$M_INTERLOCK = 1;
literal SPL$C_SPL_SPINLOCK = 1;         !  Static system spinlock
literal SPL$C_SPL_FORKLOCK = 2;         !  Spinlock used for FORKLOCK
literal SPL$C_SPL_DEVICELOCK = 3;       !  Dynamic spinlock (devicelock)
literal SPL$K_PC_VEC_CNT = 8;           !  Size of PC vector
literal SPL$K_LENGTH = 80;              !  Structure size
literal SPL$C_LENGTH = 80;              !  Structure size
literal SPL$S_SPLDEF = 80;
macro SPL$B_SPINLOCK = 0,0,8,0 %;       !  Structure lock semaphore
macro SPL$V_INTERLOCK = 0,0,1,0 %;      !  Spinlock access interlock
macro SPL$B_IPL = 1,0,8,0 %;            !  Lock IPL defined for spinlock
macro SPL$B_RANK = 2,0,8,0 %;           !  RANK of spinlock
macro SPL$B_VEC_INX = 3,0,8,0 %;        !  PC vector index
macro SPL$W_OWN_CNT = 4,0,16,0 %;       !  Count of concurrent acquires
macro SPL$W_WAIT_CPUS = 6,0,16,0 %;     !  Count of waiting CPUs
macro SPL$W_SIZE = 8,0,16,0 %;          !  Structure size
macro SPL$B_TYPE = 10,0,8,0 %;          !  Structure type
macro SPL$B_SUBTYPE = 11,0,8,0 %;       !  Spinlock subtype
macro SPL$L_OWN_CPU = 12,0,32,0 %;      !  Owner CPU's physical ID
macro SPL$L_OWN_PC_VEC = 16,0,0,0 %;
literal SPL$S_OWN_PC_VEC = 32;          !  Last 8 calling PCs of acquirers
!   and releasers
macro SPL$L_WAIT_PC = 48,0,32,0 %;      !  Last busywait PC
macro SPL$Q_ACQ_COUNT = 52,0,0,0 %;
literal SPL$S_ACQ_COUNT = 8;            !  Count of actual acquisitions
macro SPL$L_BUSY_WAITS = 60,0,32,0 %;   !  Count of failed acquisitions
macro SPL$Q_SPINS = 64,0,0,0 %;
literal SPL$S_SPINS = 8;                !  Count number of spins
macro SPL$L_TIMO_INT = 72,0,32,0 %;     !  Busywait timeout interval
macro SPL$L_RLS_PC = 76,0,32,0 %;       !  PC of nested acquisition releaser
 
!*** MODULE $SPNBDEF ***
! +
!  SPNB - SCA POLLER NAME BLOCK
! 
!  THIS DATA STRUCTURE CONTAINS A LIST OF PROCESS NAMES WHICH WILL
!  BE SEARCHED FOR ON THE GIVEN REMOTE NODE.
! -
literal SPNB$C_HDRSIZ = 24;             ! SIZE OF HEADER
literal SPNB$S_SPNBDEF = 25;
macro SPNB$L_FLINK = 0,0,32,0 %;        ! FWD LINK 
macro SPNB$L_BLINK = 4,0,32,0 %;        ! BCK LINK 
macro SPNB$W_SIZE = 8,0,16,0 %;         ! STRUCTURE SIZE IN BYTES 
macro SPNB$B_TYPE = 10,0,8,0 %;         ! SCS STRUCTURE TYPE 
macro SPNB$B_SUBTYP = 11,0,8,0 %;       ! SCS STRUCTURE SUBTYPE FOR SPNB
macro SPNB$L_SB = 12,0,32,0 %;          ! SYSTEM BLOCK OF REMOTE NOTE
macro SPNB$L_ROUTINE = 16,0,32,0 %;     ! ADDRESS OF ROUTINE TO BE CALLED WHEN PROCESS FOUND
macro SPNB$B_INDEX = 20,0,8,0 %;        ! INDEX INTO PROCESS LIST OF NEXT PROCESS TO SEARCH FOR
macro SPNB$W_REFC = 21,0,16,0 %;        ! NUMBER OF REFERENCES TO SPNB
macro SPNB$B_FREE = 23,0,8,0 %;
literal SPNB$S_FREE = 1;                ! FREE BYTE
macro SPNB$B_NAMLST = 24,0,8,0 %;       ! START OF VARIABLE LENGTH LIST OF ADDRESSES OF PROCESS NAMES
! LIST IS ZERO TERMINATED
 
!*** MODULE $SPPBDEF ***
! +
!  SPPB - SCA POLLER PROCESS BLOCK
! 
!  THIS DATA STRUCTURE DESCRIBES A PROCESS NAME KNOWN
!  TO THE SCA DIRECTORY POLLER.
! -
literal SPPB$K_LENGTH = 40;
literal SPPB$C_LENGTH = 40;
literal SPPB$S_SPPBDEF = 40;
macro SPPB$L_FLINK = 0,0,32,0 %;        ! FWD LINK 
macro SPPB$L_BLINK = 4,0,32,0 %;        ! BCK LINK 
macro SPPB$W_SIZE = 8,0,16,0 %;         ! STRUCTURE SIZE IN BYTES 
macro SPPB$B_TYPE = 10,0,8,0 %;         ! SCS STRUCTURE TYPE 
macro SPPB$B_SUBTYP = 11,0,8,0 %;       ! SCS STRUCTURE SUBTYPE FOR SPPB
macro SPPB$B_PROCNAM = 12,0,0,0 %;
literal SPPB$S_PROCNAM = 16;            ! ASCII STRING FOR PROCESS NAME 
macro SPPB$L_RTN = 28,0,32,0 %;         ! ADDRESS OF NOTIFICATION ROUTINE
macro SPPB$L_CTX = 32,0,32,0 %;         ! CONTEXT FOR NOTIFICATION ROUTINE
macro SPPB$W_BIT = 36,0,16,0 %;         ! BIT ASSIGNED TO THIS PROCESS NAME
 
!*** MODULE $SRVBUFDEF ***
! +
!  SRVBUF Definitions -- MSCP Server local buffer
! -
literal SRVBUF$S_SRVBUFDEF = 24;
macro SRVBUF$L_FLINK = 0,0,32,0 %;      !  Field maintained for 
macro SRVBUF$L_BLINK = 4,0,32,0 %;      !   compatability
macro SRVBUF$W_DEBITS = 8,0,16,0 %;     !  Number of requestors memory has been lent to
macro SRVBUF$B_TYPE = 10,0,8,0 %;       !  MSCP type structure
macro SRVBUF$B_SUBTYPE = 11,0,8,0 %;    !   with a SRVBUF subtype  (4)
macro SRVBUF$L_SIZE = 12,0,32,0 %;      !  Total buffer area size
macro SRVBUF$L_BUFF_START = 16,0,32,0 %; !  List head for buffer free list
macro SRVBUF$L_FREE_SIZE = 20,0,32,0 %; !  Buffer size for free list
 
!*** MODULE $SSCDEF ***
! ++
! 	SSC definitions
! --
!  The BASE register is at physical address %X2014000.  It is loaded with
!  a value at which to locate all the other registers.  All other registers
!  are at @BASE+offset.
literal SSC$AL_BASE = 538181632;        ! Base address
literal SSC$L_CONFIG = 16;              ! Configuration
literal SSC$L_TODR = 108;               ! Time-of-year
literal SSC$L_TCR0 = 256;               ! Timer 0 control
literal SSC$L_TIR0 = 260;               ! Timer 0 interval
literal SSC$L_TNIR0 = 264;              ! Timer 0 next interval
literal SSC$L_TIVR0 = 268;              ! Timer 0 interrupt vector
literal SSC$L_TCR1 = 272;               ! Timer 1 control
literal SSC$L_TIR1 = 276;               ! Timer 1 interval
literal SSC$L_TNIR1 = 264;              ! Timer 1 next interval
literal SSC$L_TIVR1 = 268;              ! Timer 1 interrupt vector
literal SSC$B_RAM_START = 1024;         ! Start of SSC RAM
literal SSC$B_RAM_END = 2047;           ! End of SSC RAM
literal SSC$M_TCR_RUN = 1;
literal SSC$M_TCR_STP = 4;
literal SSC$M_TCR_XFR = 16;
literal SSC$M_TCR_SGL = 32;
literal SSC$M_TCR_IE = 64;
literal SSC$M_TCR_INT = 128;
literal SSC$M_TCR_ERR = -2147483648;
literal SSC$S_TCR = 4;
macro SSC$V_TCR_RUN = 0,0,1,0 %;
macro SSC$V_TCR_MBZ_0 = 0,1,1,0 %;
macro SSC$V_TCR_STP = 0,2,1,0 %;
macro SSC$V_TCR_MBZ_1 = 0,3,1,0 %;
macro SSC$V_TCR_XFR = 0,4,1,0 %;
macro SSC$V_TCR_SGL = 0,5,1,0 %;
macro SSC$V_TCR_IE = 0,6,1,0 %;
macro SSC$V_TCR_INT = 0,7,1,0 %;
macro SSC$V_TCR_MBZ_2 = 0,8,23,0 %;
literal SSC$S_TCR_MBZ_2 = 23;
macro SSC$V_TCR_ERR = 0,31,1,0 %;
 
!*** MODULE $SSCTDEF ***
! +
!   This file contains offset definitions for SSC timer registers accessible 
!  through XMI private space on the XMI-based processors.
! -
literal SSCT_TCR0$M_RUN = 1;
literal SSCT_TCR0$M_STP = 4;
literal SSCT_TCR0$M_XFR = 16;
literal SSCT_TCR0$M_SGL = 32;
literal SSCT_TCR0$M_IE = 64;
literal SSCT_TCR0$M_INT = 128;
literal SSCT_TCR0$M_ERR = -2147483648;
literal SSCT_TIVR0$M_VECTOR = 1020;
literal SSCT_TCR1$M_RUN = 1;
literal SSCT_TCR1$M_STP = 4;
literal SSCT_TCR1$M_XFR = 16;
literal SSCT_TCR1$M_SGL = 32;
literal SSCT_TCR1$M_IE = 64;
literal SSCT_TCR1$M_INT = 128;
literal SSCT_TCR1$M_ERR = -2147483648;
literal SSCT_TIVR1$M_VECTOR = 1020;
literal SSCT$S_SSCTDEF = 32;
macro SSCT$L_TCR0 = 0,0,32,0 %;
macro SSCT_TCR0$V_RUN = 0,0,1,0 %;      !  Enables timer
macro SSCT_TCR0$V_STP = 0,2,1,0 %;      !  Stop on overflow
macro SSCT_TCR0$V_XFR = 0,4,1,0 %;      !  1=copy TNIRn to TIRn
macro SSCT_TCR0$V_SGL = 0,5,1,0 %;      !  Increment counter by one
macro SSCT_TCR0$V_IE = 0,6,1,0 %;       !  Interrupt Enable
macro SSCT_TCR0$V_INT = 0,7,1,0 %;      !  Set on timer overflow
macro SSCT_TCR0$V_ERR = 0,31,1,0 %;     !  Indicates missed overflow
macro SSCT$L_TIR0 = 4,0,32,0 %;         !  Timer Interval Register 0
macro SSCT$L_TNIR0 = 8,0,32,0 %;        !  Timer Next Interval Reg. 0
macro SSCT$L_TIVR0 = 12,0,32,0 %;
macro SSCT_TIVR0$V_VECTOR = 12,2,8,0 %;
literal SSCT_TIVR0$S_VECTOR = 8;        !  Longword aligned SCB vector
macro SSCT$L_TCR1 = 16,0,32,0 %;
macro SSCT_TCR1$V_RUN = 16,0,1,0 %;     !  Enables timer           
macro SSCT_TCR1$V_STP = 16,2,1,0 %;     !  Stop on overflow
macro SSCT_TCR1$V_XFR = 16,4,1,0 %;     !  1=copy TNIRn to TIRn
macro SSCT_TCR1$V_SGL = 16,5,1,0 %;     !  Increment counter by one
macro SSCT_TCR1$V_IE = 16,6,1,0 %;      !  Interrupt Enable
macro SSCT_TCR1$V_INT = 16,7,1,0 %;     !  Set on timer overflow
macro SSCT_TCR1$V_ERR = 16,31,1,0 %;    !  Indicates missed overflow
macro SSCT$L_TIR1 = 20,0,32,0 %;        !  Timer Interval Register 1
macro SSCT$L_TNIR1 = 24,0,32,0 %;       !  Timer Next Interval Reg. 1
macro SSCT$L_TIVR1 = 28,0,32,0 %;
macro SSCT_TIVR1$V_VECTOR = 28,2,8,0 %;
literal SSCT_TIVR1$S_VECTOR = 8;        !  Longword aligned SCB vector
 
!*** MODULE $STATEDEF ***
! +
!  SCHEDULING STATES
! -
!  DEFINITIONS START AT 1 
literal SCH$C_COLPG = 1;                ! COLLIDED PAGE WAIT 
literal SCH$C_MWAIT = 2;                ! MUTEX AND MISCELLANEOUS RESOURCE WAIT 
literal SCH$C_CEF = 3;                  ! COMMON EVENT FLAG WAIT STATE 
literal SCH$C_PFW = 4;                  ! PAGE FAULT WAIT 
literal SCH$C_LEF = 5;                  ! LOCAL EVENT FLAG WAIT 
literal SCH$C_LEFO = 6;                 ! LOCAL EVENT FLAG WAIT OUT OF BALANCE SET 
literal SCH$C_HIB = 7;                  ! HIBERNATE WAIT 
literal SCH$C_HIBO = 8;                 ! HIBERNATE WAIT OUT OF BALANCE SET 
literal SCH$C_SUSP = 9;                 ! SUSPENDED 
literal SCH$C_SUSPO = 10;               ! SUSPENDED OUT OF THE BALANCE SET 
literal SCH$C_FPG = 11;                 ! FREEPAGE WAIT 
literal SCH$C_COM = 12;                 ! COMPUTE, IN BALANCE SET STATE 
literal SCH$C_COMO = 13;                ! COMPUTE, OUT OF BALANCE SET STATE 
literal SCH$C_CUR = 14;                 ! CURRENT PROCESS STATE 
 
!*** MODULE $SYSAPDEF ***
! +
!  SYSAP - FLAGS USED IN THE SYSAP-SCS INTERFACE
! -
! OPTIONS FOR DISPOSING OF
!  SENT DATAGRAM:
!  0 ORIGIN, INCR OF 1:
literal SYSAP$C_DISPQ = 0;              !  DISPOSE ON DG FREE QUEUE
literal SYSAP$C_DISPRET = 1;            !  DISPOSE BY RETURN TO SYSAP
literal SYSAP$C_DISPPO = 2;             !  DISPOSE BY RETURN TO POOL
! FLAGS SPECIFYING TYPE OF DG
!  REC'D FROM REMOTE SYSAP:
!  0 ORIGIN, INCR OF 1:
literal SYSAP$C_DGREC = 0;              !  DG REC'D FROM REMOTE
literal SYSAP$C_DGSNT = 1;              !  DG SENT
 
!*** MODULE $SYSGDEF ***
literal SYSG$M_WORKSTATION_PRESENT = 1;
literal SYSG$M_COLOR = 2;
literal SYSG$M_DISK_BUFFER = 4;
literal SYSG$M_KAPRI = 8;
literal SYSG$M_ASYNC_OUTPUT = 16;
literal SYSG$M_SCANPROC = 32;
literal SYSG$K_LENGTH = 24;
literal SYSG$C_LENGTH = 24;
literal SYSG$S_SYSG$ = 24;
macro SYSG$L_LK201_UCB = 0,0,32,0 %;    !  Addr. of UCB for the LK201.
macro SYSG$L_MOUSE_UCB = 4,0,32,0 %;    !  Addr. of UCB for mouse line.
macro SYSG$W_SIZE = 8,0,16,0 %;         !  Length of structure.
macro SYSG$R_KB_DATA = 10,0,16,0 %;
literal SYSG$S_KB_DATA = 2;             !  KB info
macro SYSG$W_KB_INFO = 10,0,16,0 %;
macro SYSG$R_KB_PARTS = 10,0,16,0 %;
literal SYSG$S_KB_PARTS = 2;
macro SYSG$B_KB_LANGUAGE = 10,0,8,0 %;  !  Language
macro SYSG$B_KB_TYPE = 11,0,8,0 %;      !  Hardware type
macro SYSG$L_SCRATCH_RAM = 12,0,32,0 %; !  PHYSICAL adr of CP scratch RAM
macro SYSG$L_CTSI = 12,0,32,0 %;        !  CTSI pointer on Firefox
macro SYSG$L_STATE_ARRAY = 16,0,32,0 %; !  Pointer to state array
macro SYSG$W_UCB_CONFIG = 20,0,16,0 %;  !  This field tells YEDRIVER
!   which serial lines should
!   receive new UCBs.
macro SYSG$W_FLAGS = 22,0,16,0 %;       !  Contains the following flags:
macro SYSG$V_WORKSTATION_PRESENT = 22,0,1,0 %; !  LK201 was on serial line 0
!  (Bit set by OPDRV in SYSLOA)
macro SYSG$V_COLOR = 22,1,1,0 %;        !  Color option was found
!  (Bit set by CPU410)
macro SYSG$V_DISK_BUFFER = 22,2,1,0 %;  !  Disk/tape buffer was found
macro SYSG$V_KAPRI = 22,3,1,0 %;        !  KAPRI video was found
!  (Set by CPU410)
macro SYSG$V_ASYNC_OUTPUT = 22,4,1,0 %; !  Output never interrupts
macro SYSG$V_SCANPROC = 22,5,1,0 %;     !  ScanProc video was found
 
!*** MODULE $TASTDEF ***
! 
!  TERMINAL AST PACKET. THIS STRUCTURE IS USED BY TERMINAL SERVICES TO
!  DELIVER OUT OF BAND CHARACTER ASTS.
! 
literal TAST$M_MASK_DSBL = 1;
literal TAST$M_INCLUDE = 2;
literal TAST$M_ONE_SHOT = 4;
literal TAST$M_BUSY = 8;
literal TAST$M_LOST = 16;
literal TAST$M_ABORT = 32;
literal TAST$K_LENGTH = 52;
literal TAST$C_LENGTH = 52;
literal TAST$M_ABO = 16384;
literal TAST$M_INC = 32768;
literal TAST$S_TASTDEF = 54;
macro TAST$L_FLINK = 28,0,32,0 %;       ! FORWARD LINK 
macro TAST$L_AST = 32,0,32,0 %;         ! SAVED AST ADDRESS 
macro TAST$L_ASTPRM = 36,0,32,0 %;      ! SAVED AST PARAMETER 
macro TAST$L_PID = 40,0,32,0 %;         ! SAVED PID 
macro TAST$B_RMOD = 44,0,8,0 %;         ! SAVED RMOD 
macro TAST$B_CTRL = 45,0,8,0 %;         ! CONTROL FIELD 
macro TAST$V_MASK_DSBL = 45,0,1,0 %;    ! DISABLE MASK PROCESSING 
macro TAST$V_INCLUDE = 45,1,1,0 %;      ! INCLUDE CHARACTER 
macro TAST$V_ONE_SHOT = 45,2,1,0 %;     ! ONE SHOT AST 
macro TAST$V_BUSY = 45,3,1,0 %;         ! BLOCK BUSY 
macro TAST$V_LOST = 45,4,1,0 %;         ! AST LOST
macro TAST$V_ABORT = 45,5,1,0 %;        ! ABORT I/O
macro TAST$W_CHAN = 46,0,16,0 %;        ! CHANNEL 
macro TAST$L_MASK = 48,0,32,0 %;        ! OUT OF BAND MASK 
macro TAST$R_STATUS_BITS = 52,0,16,0 %;
macro TAST$V_FILL = 52,0,14,0 %;
literal TAST$S_FILL = 14;               !  First byte and spares
macro TAST$V_ABO = 52,14,1,0 %;         !  ABORT flag
macro TAST$V_INC = 52,15,1,0 %;         !  INCLUDE flag
 
!*** MODULE $TBIDEF ***
! +
!  TBI - DEFINE EXTENDED TB INVALIDATION BITS FOR MMG$GL_TBI_FLAGS
! 
!  The EXTENDED_TBI bit is set during init if the system may require
!  extended tb invalidation.  The extended invalidation routines are
!  located in PAGEFAULT.  The GRAPHICS_TBI bit is set if the graphics
!  invalidation SYSLOA vector is initialized.
! 
! -
literal MMG$M_EXTENDED_TBI = 1;
literal MMG$M_GRAPHICS_TBI = -2147483648;
literal MMG$S_TBI_BITS = 4;
macro MMG$V_EXTENDED_TBI = 0,0,1,0 %;
macro MMG$v_spare_tbi = 0,1,30,0 %;
literal MMG$s_spare_tbi = 30;
macro MMG$V_GRAPHICS_TBI = 0,31,1,0 %;
 
!*** MODULE $TCDEF ***
! 
!  Constant definitions
! 
literal TC$K_MAXSLOTS = 16;
! 
literal TC$S_TCDEF = 1152;
! 
!  Define the layout of Turbochannel option ROM Contents from the base address
!  of the option slot.
! 
!  Offset from slot base
macro TC$L_ROM_WIDTH = 992,0,32,0 %;    !  width of ROM loc in bytes
macro TC$L_ROM_STRIDE = 996,0,32,0 %;   !  stride between ROM locations
macro TC$L_ROM_SIZE = 1000,0,32,0 %;    !  Bytes in ROM/8192 
macro TC$L_ROM_SLOTSZ = 1004,0,32,0 %;  !  Slot size in MB/4MB
macro TC$O_ROM_TSTDATA = 1008,0,0,0 %;
literal TC$S_ROM_TSTDATA = 16;          !  Constant test data
macro TC$T_ROM_FIRMVER = 1024,0,0,0 %;
literal TC$S_ROM_FIRMVER = 32;          !  Firmware revision 8 ACSII 
macro TC$T_ROM_VENDOR = 1056,0,0,0 %;
literal TC$S_ROM_VENDOR = 32;           !  Vendor Name
macro TC$T_ROM_DEVNAM = 1088,0,0,0 %;
literal TC$S_ROM_DEVNAM = 32;           !  Module/device Name
macro TC$T_ROM_HOSTTYP = 1120,0,0,0 %;
literal TC$S_ROM_HOSTTYP = 32;          !  Host firmware type
literal TCGCB$M_MAILBOX = 1;
literal TCGCB$M_NOMAPS = 2;
literal TCGCB$S_TCGCB = 20;
! 
!  Define the TC generic system configuration block. This block will be passed
!  to the common configuration routines, and will define all system specific
!  parameters of the TC. These include number of slots, base address of the
!  slots, slot ordering. This with the option ROMs the TC can be configured by
!  common routines regaurdless of which system they are on.
!                         
macro TCGCB$L_BASE_ADDRS = 0,0,32,0 %;  !  Base address for Slot 
macro TCGCB$L_INT_VECTOR = 4,0,32,0 %;  !  Interrupt vector for this slot
macro TCGCB$L_SLOT_SIZE = 8,0,32,0 %;   !  Size of the slot in bytes
macro TCGCB$L_SLOT_NUM = 12,0,32,0 %;   !  Number of this slot
macro TCGCB$L_SLOT_FLAGS = 16,0,32,0 %; !  Special init flags
macro TCGCB$V_MAILBOX = 16,0,1,0 %;     !  Mail box I/O needed
macro TCGCB$V_NOMAPS = 16,1,1,0 %;      !  Adap does not support map regs
literal TCCTB$M_MAPREQ = 1;
literal TCCTB$S_TCCTB = 32;
! 
!  The TC configure table lists all devices known to VMS and the address of
!  their init routine. The init routine will perform all necessary work to get
!  the device ready for autoconfigure.
!  
macro TCCTB$T_NAME = 0,0,0,0 %;
literal TCCTB$S_NAME = 8;               !  Name of device as in ROM
macro TCCTB$L_INITROUT = 8,0,32,0 %;    !  Init routine for TC device
macro TCCTB$L_FLAGS = 12,0,32,0 %;      !  Special init flags
macro TCCTB$V_MAPREQ = 12,0,1,0 %;      !  Adapter map registers needed
macro TCCTB$L_NUM_UNITS = 16,0,32,0 %;  !  Number of units possible
macro TCCTB$L_TBL_LENGTH = 20,0,32,0 %; !  This tbl entry length in bytes
macro TCCTB$L_PAGE_COUNT = 24,0,32,0 %; !  Pages needed by device
macro TCCTB$L_ADDRS_DESC = 28,0,32,0 %; !  Start of address desc
literal TCONFIG$M_SUPPORTED = 1;
literal TCONFIG$M_GENERIC = 2;
literal TCONFIG$S_TCONFIG = 28;
! 
!  This is the same type of array as confreg, and xmi_structure_array. It is used to pass information 
!  about the config of the TC. If there are more than on TC bus on a system the second ect bus info
!  will be concatinated on to the end of the first bus's info.
!  
macro TCONFIG$L_FLAGS = 0,0,32,0 %;     !  Device info flag
macro TCONFIG$V_SUPPORTED = 0,0,1,0 %;  !  This device supported by VMS
macro TCONFIG$V_GENERIC = 0,1,1,0 %;    !  Generic support for this device
macro TCONFIG$L_DEV_TYPE = 4,0,32,0 %;  !  The NDT number for this device
macro TCONFIG$L_CRB = 8,0,32,0 %;       !  CRB for this device
macro TCONFIG$L_SLOT = 12,0,32,0 %;     !  Slot number of device
macro TCONFIG$L_NEXUS = 16,0,32,0 %;    !  NEXUS number of this device
macro TCONFIG$T_DEV_NAME = 20,0,0,0 %;
literal TCONFIG$S_DEV_NAME = 8;         !  Name of device as in ROM
literal TC_MD$S_TC_MD_LAYOUT = 4;
! 
!  This is the definition for the Map regsiter descriptor. used in the map
!  register routines and drivers who call the N version of the map routines. 
!  They contain the infomation needed to describe a portion of TC physical
!  address space that can be mapped into system virtual addrss space.
! 
macro TC_MD$W_MAPREG = 0,0,16,0 %;
macro TC_MD$W_NUMREG = 2,0,16,0 %;
literal TC_FLAGS$M_MAPREQ = 1;
literal TC_FLAGS$M_DIRREQ = 2;
literal TC_FLAGS$M_MAILBOX = 4;
literal TC_FLAGS$S_TC_FLAGS = 4;
! 
!  Define the different flags that indicate different states of the TC config
!  process. For example, the ADAPMAP flag indicates that a device has been
!  configured that needs adapter mapping. This mean any device that requires
!  mapping to be disabled cannot be configured. In this case we write a config
!  warning message out to the console, don't config this device and continue
!  with remaining slots.
! 
macro TC_FLAGS$L_CONFIGFLG = 0,0,32,0 %; !  Special init flags
macro TC_FLAGS$V_MAPREQ = 0,0,1,0 %;    !  mapping req by a device
macro TC_FLAGS$V_DIRREQ = 0,1,1,0 %;    !  Direct required
macro TC_FLAGS$V_MAILBOX = 0,2,1,0 %;   !  device requires MB I/O
 
!*** MODULE $TLVDEF ***
!  Define the layout of a general purpose type-length-value structure which is
!  used to pass a variety of data structures around the cluster.
literal TLV$K_MAX_ORB_LENGTH = 13312;
literal TLV$K_MAX_ARB_LENGTH = 3072;
literal TLV$S_CHECKSUM = 8;             !  header minus checksum
literal TLV$K_MSG_HDR_LENGTH = 24;      !  message header length
literal TLV$K_VERSION_1 = 1;            !  version number 1
literal TLV$K_CURRENT_VERSION = 1;      !  current protocol
literal TLV$K_GRANULARITY = 7;          !  allocation granularity
literal TLV$S_HEADER = 24;
macro TLV$L_CHECKSUM = 0,0,32,0 %;      !  checksum (includes header)
macro TLV$L_UNUSED_L1 = 4,0,32,0 %;     !  start of checksum
macro TLV$L_MSG_SIZE = 8,0,32,0 %;      !  message size
macro TLV$W_MSG_COUNT = 12,0,16,0 %;    !  # of packets in message
macro TLV$B_VERSION = 14,0,8,0 %;       !  TLV protocol version number
macro TLV$Q_SECURITY_DOMAIN = 16,0,0,0 %;
literal TLV$S_SECURITY_DOMAIN = 8;      !  security domain ($KGBDEF)
literal TLV$K_PKT_HDR_LENGTH = 4;       !  packet header length
literal TLV$S_PACKET = 8;
macro TLV$W_TYPE = 0,0,16,0 %;          !  packet type
macro TLV$W_LENGTH = 2,0,16,0 %;        !  packet length (including packet header)
macro TLV$R_VALUE = 4,0,32,0 %;         !  offset to start of data
 
!*** MODULE $TQEDEF ***
! +
!  TQE - TIME QUEUE ENTRY
! 
!  TIME QUEUE ENTRIES ARE UTILIZED TO SET TIMERS, WAKE UP PROCESSES, AND
!  FOR INTERNAL SYSTEM SUBROUTINES.
! -
literal TQE$M_REPEAT = 4;
literal TQE$M_ABSOLUTE = 8;
literal TQE$M_CHK_CPUTIM = 16;
literal TQE$K_LENGTH = 52;              ! LENGTH OF STANDARD TQE 
literal TQE$C_LENGTH = 52;              ! LENGTH OF STANDARD TQE 
! 
literal TQE$C_TMSNGL = 0;               ! TIMER ENTRY SINGLE SHOT REQUEST 
literal TQE$C_SSREPT = 5;               ! SYSTEM SUBROUTINE REPEAT REQUEST 
literal TQE$C_SSSNGL = 1;               ! SYSTEM SUBROUTINE SINGLE SHOT REQUEST 
literal TQE$C_WKREPT = 6;               ! WAKE ENTRY REPEAT REQUEST 
literal TQE$C_WKSNGL = 2;               ! WAKE ENTRY SINGLE SHOT REQUEST 
literal TQE$S_TQEDEF = 52;
macro TQE$L_TQFL = 0,0,32,0 %;          ! TIME QUEUE FORWARD LINK 
macro TQE$L_TQBL = 4,0,32,0 %;          ! TIME QUEUE BACKWARD LINK 
macro TQE$W_SIZE = 8,0,16,0 %;          ! SIZE OF TQE IN BYTES 
macro TQE$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE FOR TQE 
macro TQE$B_RQTYPE = 11,0,8,0 %;        ! TIME QUEUE ENTRY TYPE 
macro TQE$V_REPEAT = 11,2,1,0 %;        !  REPEAT REQUEST (1=YES) 
macro TQE$V_ABSOLUTE = 11,3,1,0 %;      !  Absolute expiration time specified 
macro TQE$V_CHK_CPUTIM = 11,4,1,0 %;    !  Process CPU time constrained request
macro TQE$L_PID = 12,0,32,0 %;          ! TIMER OR WAKE REQUEST PROCESS ID 
macro TQE$L_FPC = 12,0,32,0 %;          ! TIMER SUBROUTINE ADDRESS 
macro TQE$L_AST = 16,0,32,0 %;          ! ADDRESS OF AST ROUTINE 
macro TQE$L_FR3 = 16,0,32,0 %;          ! TIMER SUBROUTINE SAVED R3 
macro TQE$L_ASTPRM = 20,0,32,0 %;       ! AST PARAMETER 
macro TQE$L_FR4 = 20,0,32,0 %;          ! TIMER SUBROUTINE SAVED R4 
macro TQE$Q_TIME = 24,0,0,0 %;
literal TQE$S_TIME = 8;                 ! ABSOLUTE EXPIRATION TIME 
macro TQE$Q_DELTA = 32,0,0,0 %;
literal TQE$S_DELTA = 8;                ! DELTA REPEAT TIME 
macro TQE$B_RMOD = 40,0,8,0 %;          ! ACCESS MODE OF REQUEST 
macro TQE$B_EFN = 41,0,8,0 %;           ! EVENT FLAG NUMBER AND EVENT GROUP 
macro TQE$L_RQPID = 44,0,32,0 %;        ! REQUESTER PROCESS ID 
macro TQE$L_CPUTIM = 48,0,32,0 %;       !  Process CPU time at which entry becomes due
!  TIME QUEUE ENTRY REQUEST TYPE DEFINITIONS
! 
 
!*** MODULE $TSRVDEF ***
! +
!  TSRV  ( )  Definitions
! 
! 	This module defines the main data structure of the TMSCP
! 	server. This structure contains the values specified in
! 	the start up qualifiers when the server was loaded, the 
! 	UQB vector table, and statistics that are kept for server
! 	performance measurements.
! 	
! 	This structure is being checked in with fields aligned
! 	to the MSCP structure DSRV. This is not a requirement
! 	and may be changed in the future if necessary.
! 
!  <<== !NOTICE! ==>>
! 
! 	DO NOT change offsets of the top part of the data structure.
!  	If new fields have to be added please make them below the 
! 	forward and backward links to the UQB.
! -
literal TSRV$M_LOG_ENABLD = 1;
literal TSRV$M_LOG_PRESENT = 2;
literal TSRV$M_PKT_LOGGED = 4;
literal TSRV$M_PKT_LOST = 8;
literal TSRV$M_LBSTEP1 = 16;
literal TSRV$M_LBSTEP2 = 32;
literal TSRV$M_LBEVENT = 64;
literal TSRV$M_HULB_DEL = 128;
literal TSRV$M_MON_ACTIVE = 256;
literal TSRV$M_LB_REQ = 512;
literal TSRV$C_LENGTH = 1900;
literal TSRV$K_LENGTH = 1900;
literal TSRV$K_AR_START = 1;
literal TSRV$K_AR_ADD = 2;
literal TSRV$S_TSRVDEF = 1900;
macro TSRV$L_FLINK = 0,0,32,0 %;        !  Field maintained for 
macro TSRV$L_BLINK = 4,0,32,0 %;        !   compatability
macro TSRV$W_SIZE = 8,0,16,0 %;         !  Structure size in bytes
macro TSRV$B_TYPE = 10,0,8,0 %;         !  MSCP type structure
macro TSRV$B_SUBTYPE = 11,0,8,0 %;      !   with a TSRV subtype      (1)
macro TSRV$W_STATE = 12,0,16,0 %;       !  Current state of the server
macro TSRV$V_LOG_ENABLD = 12,0,1,0 %;   !  Logging is enabled
macro TSRV$V_LOG_PRESENT = 12,1,1,0 %;  !  Logging code is present
macro TSRV$V_PKT_LOGGED = 12,2,1,0 %;   !  A packet has been logged
macro TSRV$V_PKT_LOST = 12,3,1,0 %;     !  One or more packets over-
!   written since last read
macro TSRV$V_LBSTEP1 = 12,4,1,0 %;      !  Load balancing step1 active
macro TSRV$V_LBSTEP2 = 12,5,1,0 %;      !  Load balancing step2 active
macro TSRV$V_LBEVENT = 12,6,1,0 %;      !  An event of interest to LB has
!   occured while STEP1 was active
macro TSRV$V_HULB_DEL = 12,7,1,0 %;     !  One or more HULBs to be deleted
macro TSRV$V_MON_ACTIVE = 12,8,1,0 %;   !  The load monitor thread is active
macro TSRV$V_LB_REQ = 12,9,1,0 %;       !  A load balance request has been sent
macro TSRV$W_BUFWAIT = 14,0,16,0 %;     ! I/Os that had to wait
macro TSRV$L_LOG_BUF_START = 16,0,32,0 %; !  Address of start of buffer
macro TSRV$L_LOG_BUF_END = 20,0,32,0 %; !  Address of end of buffer
macro TSRV$L_NEXT_READ = 24,0,32,0 %;   !  Adrs of next packet to read
macro TSRV$L_NEXT_WRITE = 28,0,32,0 %;  !  Adrs of next packet to write
macro TSRV$W_INC_LOLIM = 32,0,16,0 %;   !  Low unit number to log
macro TSRV$W_INC_HILIM = 34,0,16,0 %;   !  High unit number to log
macro TSRV$W_EXC_LOLIM = 36,0,16,0 %;   !  Low unit number not to log
macro TSRV$W_EXC_HILIM = 38,0,16,0 %;   !  High unit number not to log
macro TSRV$W_VERSION = 60,0,16,0 %;     !  Server software version
macro TSRV$W_CFLAGS = 62,0,16,0 %;      !  Controller flags
macro TSRV$W_CTIMO = 64,0,16,0 %;       !  Controller timeout
macro TSRV$Q_CTRL_ID = 68,0,0,0 %;
literal TSRV$S_CTRL_ID = 8;             !  Unique MSCP device identifier
macro TSRV$W_NUM_HOST = 92,0,16,0 %;    !  Count of hosts being served
macro TSRV$W_NUM_UNIT = 94,0,16,0 %;    !  Count of disks being served
macro TSRV$L_HQB_FL = 96,0,32,0 %;      !  Host queue block list head
macro TSRV$L_HQB_BL = 100,0,32,0 %;     ! 
macro TSRV$L_UQB_FL = 104,0,32,0 %;     !  Unit queue block list head
macro TSRV$L_UQB_BL = 108,0,32,0 %;     ! 
macro TSRV$L_UNITS = 196,0,0,0 %;
literal TSRV$S_UNITS = 1024;            !  Table of UQB addresses
! 
!  new fields should be added here, after the UQB linkages
! 
! 
! 	Statistics gathering fields
! 
! 	Two tables are maintained below. The first table is made up of the 
! 	frequency count for each of the opcodes received since the server
! 	was loaded. The opcode is used as an index into the table to its own
! 	frequency count (the zeroeth element contains a total count). The 
! 	second table is made up of the frequency counters for all the
! 	different sized block transfers. For this table, the size of the 
! 	transfer is the index into the table.
! 
macro TSRV$L_OPCOUNT = 1220,0,32,0 %;   !  Total operations count
macro TSRV$L_ABORT_CNT = 1224,0,32,0 %; !    - 1 -
macro TSRV$L_GET_CMD_CNT = 1228,0,32,0 %; !    - 2 -
macro TSRV$L_GET_UNT_CNT = 1232,0,32,0 %; !    - 3 -
macro TSRV$L_SET_CON_CNT = 1236,0,32,0 %; !    - 4 -
macro TSRV$L_AVAIL_CNT = 1252,0,32,0 %; !    - 8 -
macro TSRV$L_ONLIN_CNT = 1256,0,32,0 %; !    - 9 -
macro TSRV$L_SET_UNT_CNT = 1260,0,32,0 %; !    - 10 -
macro TSRV$L_DET_ACC_CNT = 1264,0,32,0 %; !    - 11 -
macro TSRV$L_ACCES_CNT = 1284,0,32,0 %; !    - 16 -
macro TSRV$L_CMP_CON_CNT = 1288,0,32,0 %; !    - 17 -
macro TSRV$L_ERASE_CNT = 1292,0,32,0 %; !    - 18 -
macro TSRV$L_FLUSH_CNT = 1296,0,32,0 %; !    - 19 -
macro TSRV$L_REPLC_CNT = 1300,0,32,0 %; !    - 20 -
macro TSRV$L_CMP_HST_CNT = 1348,0,32,0 %; !    - 32 -
macro TSRV$L_READ_CNT = 1352,0,32,0 %;  !    - 33 -
macro TSRV$L_WRITE_CNT = 1356,0,32,0 %; !    - 34 -
macro TSRV$L_VCFAIL_CNT = 1380,0,32,0 %; !  Count of VC failures
macro TSRV$L_BLKCOUNT = 1384,0,0,0 %;
literal TSRV$S_BLKCOUNT = 516;          !  Counters for block xfer reqs
 
!*** MODULE $UAFDEF ***
! ++
!  User authorization file format
!  Note: With the exception of the username and account name,
!  all strings are blank padded counted strings. Username and
!  account name are uncounted, blank padded.
! --
literal UAF$C_USER_ID = 1;              !  main user ID record
literal UAF$C_VERSION1 = 1;             !  this version
literal UAF$C_KEYED_PART = 52;          !  ISAM keys come this far
literal UAF$C_MAX_PWD_LENGTH = 32;      !  maximum plaintext password length
literal UAF$K_MAX_PWD_LENGTH = 32;      !  maximum plaintext password length
literal UAF$C_AD_II = 0;                !  AUTODIN-II 32 bit crc code
literal UAF$C_PURDY = 1;                !  Purdy polynomial over salted input
literal UAF$C_PURDY_V = 2;              !  Purdy polynomial + variable length username
literal UAF$C_PURDY_S = 3;              !  PURDY_V folded into password length
literal UAF$C_PREFERED_ALGORITHM = 3;   !  prefered hash algorithm
literal UAF$K_PREFERED_ALGORITHM = 3;   !  prefered hash algorithm
literal UAF$C_CUST_ALGORITHM = 128;     !  customer algorithm division
literal UAF$K_CUST_ALGORITHM = 128;     !  customer algorithm division
literal UAF$K_FIXED = 644;              !  length of fixed portion
literal UAF$C_FIXED = 644;              !  length of fixed portion
literal UAF$K_LENGTH = 1412;
literal UAF$C_LENGTH = 1412;
literal UAF$S_UAFDEF = 1412;
macro UAF$B_RTYPE = 0,0,8,0 %;          !  UAF record type
macro UAF$B_VERSION = 1,0,8,0 %;        !  UAF format version
macro UAF$W_USRDATOFF = 2,0,16,0 %;     !  offset of counted string of user data
macro UAF$T_USERNAME = 4,0,0,0 %;
literal UAF$S_USERNAME = 32;            !  username
macro UAF$T_USERNAME_TAG = 35,0,8,0 %;  !  tag to differentiate records
macro UAF$L_UIC = 36,0,32,0 %;          !  user ID code
macro UAF$W_MEM = 36,0,16,0 %;          !  member subfield
macro UAF$W_GRP = 38,0,16,0 %;          !  group subfield
macro UAF$L_SUB_ID = 40,0,32,0 %;       !  user sub-identifier
macro UAF$Q_PARENT_ID = 44,0,0,0 %;
literal UAF$S_PARENT_ID = 8;            !  identifier of owner of this account
macro UAF$T_ACCOUNT = 52,0,0,0 %;
literal UAF$S_ACCOUNT = 32;             !  account name
macro UAF$T_OWNER = 84,0,0,0 %;
literal UAF$S_OWNER = 32;               !  owner's name
macro UAF$T_DEFDEV = 116,0,0,0 %;
literal UAF$S_DEFDEV = 32;              !  default device
macro UAF$T_DEFDIR = 148,0,0,0 %;
literal UAF$S_DEFDIR = 64;              !  default directory
macro UAF$T_LGICMD = 212,0,0,0 %;
literal UAF$S_LGICMD = 64;              !  login command file
macro UAF$T_DEFCLI = 276,0,0,0 %;
literal UAF$S_DEFCLI = 32;              !  default command interpreter
macro UAF$T_CLITABLES = 308,0,0,0 %;
literal UAF$S_CLITABLES = 32;           !  user CLI tables
macro UAF$Q_PWD = 340,0,0,0 %;
literal UAF$S_PWD = 8;                  !  hashed password
macro UAF$L_PWD = 340,0,32,0 %;         !  32 bit subfield
macro UAF$Q_PWD2 = 348,0,0,0 %;
literal UAF$S_PWD2 = 8;                 !  second password
macro UAF$W_LOGFAILS = 356,0,16,0 %;    !  count of login failures
macro UAF$W_SALT = 358,0,16,0 %;        !  random password salt
macro UAF$B_ENCRYPT = 360,0,8,0 %;      !  primary password hash algorithm
!  known hash algorithm indices
macro UAF$B_ENCRYPT2 = 361,0,8,0 %;     !  secondary password hash algorithm
macro UAF$B_PWD_LENGTH = 362,0,8,0 %;   !  minimum password length
macro UAF$Q_EXPIRATION = 364,0,0,0 %;
literal UAF$S_EXPIRATION = 8;           !  expiration date for account
macro UAF$Q_PWD_LIFETIME = 372,0,0,0 %;
literal UAF$S_PWD_LIFETIME = 8;         !  password lifetime
macro UAF$Q_PWD_DATE = 380,0,0,0 %;
literal UAF$S_PWD_DATE = 8;             !  date of password change
macro UAF$Q_PWD2_DATE = 388,0,0,0 %;
literal UAF$S_PWD2_DATE = 8;            !  date of 2nd password change
macro UAF$Q_LASTLOGIN_I = 396,0,0,0 %;
literal UAF$S_LASTLOGIN_I = 8;          !  date of last interactive login
macro UAF$Q_LASTLOGIN_N = 404,0,0,0 %;
literal UAF$S_LASTLOGIN_N = 8;          !  date of last non-interactive login
macro UAF$Q_PRIV = 412,0,0,0 %;
literal UAF$S_PRIV = 8;                 !  process privilege vector
macro UAF$Q_DEF_PRIV = 420,0,0,0 %;
literal UAF$S_DEF_PRIV = 8;             !  default process privileges
macro UAF$R_MIN_CLASS = 428,0,0,0 %;
literal UAF$S_MIN_CLASS = 20;           !  minimum security class
macro UAF$R_MAX_CLASS = 448,0,0,0 %;
literal UAF$S_MAX_CLASS = 20;           !  maximum security class
macro UAF$L_FLAGS = 468,0,32,0 %;       !  user flags longword
macro UAF$V_DISCTLY = 468,0,1,0 %;      !  no user control-y
macro UAF$V_DEFCLI = 468,1,1,0 %;       !  only allow user default CLI
macro UAF$V_LOCKPWD = 468,2,1,0 %;      !  disable SET PASSWORD command
macro UAF$V_RESTRICTED = 468,3,1,0 %;   !  restricted account (pre-V5.2 CAPTIVE)
macro UAF$V_DISACNT = 468,4,1,0 %;      !  no interactive login
macro UAF$V_DISWELCOM = 468,5,1,0 %;    !  skip welcome message
macro UAF$V_DISMAIL = 468,6,1,0 %;      !  skip new mail message
macro UAF$V_NOMAIL = 468,7,1,0 %;       !  disable mail delivery
macro UAF$V_GENPWD = 468,8,1,0 %;       !  passwords must be generated
macro UAF$V_PWD_EXPIRED = 468,9,1,0 %;  !  password has expired
macro UAF$V_PWD2_EXPIRED = 468,10,1,0 %; !  2nd password has expired
macro UAF$V_AUDIT = 468,11,1,0 %;       !  audit all actions
macro UAF$V_DISREPORT = 468,12,1,0 %;   !  skip last login messages
macro UAF$V_DISRECONNECT = 468,13,1,0 %; !  inhibit reconnections
macro UAF$V_AUTOLOGIN = 468,14,1,0 %;   !  auto-login only
macro UAF$V_DISFORCE_PWD_CHANGE = 468,15,1,0 %; !  disable forced password change
macro UAF$V_CAPTIVE = 468,16,1,0 %;     !  captive account (no overrides)
macro UAF$V_DISIMAGE = 468,17,1,0 %;    !  disable arbitrary image activation
macro UAF$V_DISPWDDIC = 468,18,1,0 %;   !  disable password dictionary search
macro UAF$V_DISPWDHIS = 468,19,1,0 %;   !  disable password history search
macro UAF$B_NETWORK_ACCESS_P = 472,0,24,0 %;
literal UAF$S_NETWORK_ACCESS_P = 3;     !  hourly network access, primary
macro UAF$B_NETWORK_ACCESS_S = 475,0,24,0 %;
literal UAF$S_NETWORK_ACCESS_S = 3;     !  hourly network access, secondary
macro UAF$B_BATCH_ACCESS_P = 478,0,24,0 %;
literal UAF$S_BATCH_ACCESS_P = 3;       !  hourly batch access, primary
macro UAF$B_BATCH_ACCESS_S = 481,0,24,0 %;
literal UAF$S_BATCH_ACCESS_S = 3;       !  hourly batch access, secondary
macro UAF$B_LOCAL_ACCESS_P = 484,0,24,0 %;
literal UAF$S_LOCAL_ACCESS_P = 3;       !  hourly local access, primary
macro UAF$B_LOCAL_ACCESS_S = 487,0,24,0 %;
literal UAF$S_LOCAL_ACCESS_S = 3;       !  hourly local access, secondary
macro UAF$B_DIALUP_ACCESS_P = 490,0,24,0 %;
literal UAF$S_DIALUP_ACCESS_P = 3;      !  hourly dialup access, primary
macro UAF$B_DIALUP_ACCESS_S = 493,0,24,0 %;
literal UAF$S_DIALUP_ACCESS_S = 3;      !  hourly dialup access, secondary
macro UAF$B_REMOTE_ACCESS_P = 496,0,24,0 %;
literal UAF$S_REMOTE_ACCESS_P = 3;      !  hourly remote access, primary
macro UAF$B_REMOTE_ACCESS_S = 499,0,24,0 %;
literal UAF$S_REMOTE_ACCESS_S = 3;      !  hourly remote access, secondary
macro UAF$B_PRIMEDAYS = 514,0,8,0 %;    !  bits representing primary days
macro UAF$V_MONDAY = 514,0,1,0 %;       !  bit clear means this is a primary day
macro UAF$V_TUESDAY = 514,1,1,0 %;      !  bit set means this is an off day
macro UAF$V_WEDNESDAY = 514,2,1,0 %;
macro UAF$V_THURSDAY = 514,3,1,0 %;
macro UAF$V_FRIDAY = 514,4,1,0 %;
macro UAF$V_SATURDAY = 514,5,1,0 %;
macro UAF$V_SUNDAY = 514,6,1,0 %;
macro UAF$B_PRI = 516,0,8,0 %;          !  base process priority
macro UAF$B_QUEPRI = 517,0,8,0 %;       !  maximum job queuing priority
macro UAF$W_MAXJOBS = 518,0,16,0 %;     !  maximum jobs for UIC allowed
!  0 means no limit
macro UAF$W_MAXACCTJOBS = 520,0,16,0 %; !  maximum jobs for account allowed
!  0 means no limit
macro UAF$W_MAXDETACH = 522,0,16,0 %;   !  maximum detached processes for UIC
!  0 means no limit
macro UAF$W_PRCCNT = 524,0,16,0 %;      !  subprocess creation limit
macro UAF$W_BIOLM = 526,0,16,0 %;       !  buffered I/O limit
macro UAF$W_DIOLM = 528,0,16,0 %;       !  direct I/O limit
macro UAF$W_TQCNT = 530,0,16,0 %;       !  timer queue entry limit
macro UAF$W_ASTLM = 532,0,16,0 %;       !  AST queue limit
macro UAF$W_ENQLM = 534,0,16,0 %;       !  enqueue limit
macro UAF$W_FILLM = 536,0,16,0 %;       !  open file limit
macro UAF$W_SHRFILLM = 538,0,16,0 %;    !  shared file limit
macro UAF$L_WSQUOTA = 540,0,32,0 %;     !  working set size quota
macro UAF$L_DFWSCNT = 544,0,32,0 %;     !  default working set size
macro UAF$L_WSEXTENT = 548,0,32,0 %;    !  working set size limit
macro UAF$L_PGFLQUOTA = 552,0,32,0 %;   !  page file quota
macro UAF$L_CPUTIM = 556,0,32,0 %;      !  CPU time quota
macro UAF$L_BYTLM = 560,0,32,0 %;       !  buffered I/O byte count limit
macro UAF$L_PBYTLM = 564,0,32,0 %;      !  paged buffer I/O byte count limit
macro UAF$L_JTQUOTA = 568,0,32,0 %;     !  job-wide logical name table creation quota
macro UAF$W_PROXY_LIM = 572,0,16,0 %;   !  number of proxies user can grant
macro UAF$W_PROXIES = 574,0,16,0 %;     !  number of proxies granted
macro UAF$W_ACCOUNT_LIM = 576,0,16,0 %; !  number of sub-accounts allowed
macro UAF$W_ACCOUNTS = 578,0,16,0 %;    !  number of sub-accounts in use
 
!*** MODULE $UASDEF ***
! +
!  UNIBUS ADDRESS SPACE REGISTER DEFINITIONS FOR DW750
!  	(SECOND UNIBUS ADAPTER ON 11/750)
! -
literal UAS$M_IP_CR1_PIE = 4096;
literal UAS$M_IP_CR1_PDN = 8192;
literal UAS$S_UASDEF = 5222;
macro UAS$R_IP = 5216,0,0,0 %;
literal UAS$S_IP = 6;                   !  INTER-PROCESSOR EXERCISER COMMUNICATOR
macro UAS$W_IP_CR1 = 5220,0,16,0 %;     !  THE THIRD IPEC REGISTER, CR1
macro UAS$V_IP_CR1_PIE = 5220,12,1,0 %; !  POWERFAIL INTERRUPT ENABLE
macro UAS$V_IP_CR1_PDN = 5220,13,1,0 %; !  POWER DOWN STATUS BIT
 
!*** MODULE $UBADEF ***
! +
!  UNIBUS ADAPTER REGISTER OFFSET DEFINITIONS
! -
literal UBA$M_CSR_UBIC = 65536;
literal UBA$M_CSR_UBPDN = 131072;
literal UBA$M_CSR_UBIIP = 262144;
literal UBA$M_CSR_OT = 2097152;
literal UBA$M_CSR_PU = 4194304;
literal UBA$M_CSR_PD = 8388608;
literal UBA$M_CSR_XMFLT = 67108864;
literal UBA$M_CSR_MT = 134217728;
literal UBA$M_CSR_IS = 268435456;
literal UBA$M_CSR_URD = 536870912;
literal UBA$M_CSR_WS = 1073741824;
literal UBA$M_CSR_PE = -2147483648;
literal UBA$M_CR_INIT = 1;
literal UBA$M_CR_UBPF = 2;
literal UBA$M_CR_CNFIE = 4;
literal UBA$M_CR_SUEFIE = 8;
literal UBA$M_CR_USEFIE = 16;
literal UBA$M_CR_BRIE = 32;
literal UBA$M_CR_IFSIE = 64;
literal UBA$M_CR_ARLVL = 384;
literal UBA$M_SR_SSYNC = 1;
literal UBA$M_SR_UBSTO = 2;
literal UBA$M_SR_LER = 4;
literal UBA$M_SR_MRPE = 8;
literal UBA$M_SR_IVMR = 16;
literal UBA$M_SR_DPPE = 32;
literal UBA$M_SR_CXTMO = 64;
literal UBA$M_SR_CXTER = 128;
literal UBA$M_SR_CRD = 256;
literal UBA$M_SR_RDS = 512;
literal UBA$M_SR_RDTO = 1024;
literal UBA$M_SR_BRID = 2048;
literal UBA$M_SR_BRSVF = 268435456;
literal UBA$M_SR_RIE = 536870912;
literal UBA$M_SR_UBIFS = 1073741824;
literal UBA$M_BRRVR_AIR = -2147483648;
literal UBA$M_DPR_DPF = 536870912;
literal UBA$M_DPR_XMTER = 1073741824;
literal UBA$M_DPR_BNE = -2147483648;
literal UBA$M_MAP_BO = 33554432;
literal UBA$M_MAP_VALID = -2147483648;
literal UBA$C_MAXDP = 15;               ! MAXIMUM DATAPATH ! 
literal UBA$S_UBADEF = 4032;
macro UBA$L_CSR = 0,0,32,0 %;           ! CONFIGURATION STATUS REGISTER 
macro UBA$V_CSR_ADCOD = 0,0,8,0 %;
literal UBA$S_CSR_ADCOD = 8;            !  ADAPTER CODE FIELD 
macro UBA$V_CSR_UBIC = 0,16,1,0 %;      !  UNIBUS INITIALIZATION COMPLETE 
macro UBA$V_CSR_UBPDN = 0,17,1,0 %;     !  UNIBUS POWER DOWN 
macro UBA$V_CSR_UBIIP = 0,18,1,0 %;     !  UNIBUS INITIALIZATION IN PROGRESS 
macro UBA$V_CSR_OT = 0,21,1,0 %;        !  OVER TEMPERATURE 
macro UBA$V_CSR_PU = 0,22,1,0 %;        !  ADAPTER POWER UP 
macro UBA$V_CSR_PD = 0,23,1,0 %;        !  ADAPTER POWER DOWN 
macro UBA$V_CSR_XMFLT = 0,26,1,0 %;     !  TRANSMITTER FAULT 
macro UBA$V_CSR_MT = 0,27,1,0 %;        !  MULTIPLE TRANSMITTERS 
macro UBA$V_CSR_IS = 0,28,1,0 %;        !  INTERLOCK SEQUENCE FAULT 
macro UBA$V_CSR_URD = 0,29,1,0 %;       !  UNEXPECTED READ DATA 
macro UBA$V_CSR_WS = 0,30,1,0 %;        !  WRITE SEQUENCE DATA 
macro UBA$V_CSR_PE = 0,31,1,0 %;        !  SBI PARITY ERROR 
macro UBA$L_CR = 4,0,32,0 %;            ! CONTROL REGISTER 
macro UBA$V_CR_INIT = 4,0,1,0 %;        !  ADAPTER INITIALIZATION 
macro UBA$V_CR_UBPF = 4,1,1,0 %;        !  UNIBUS POWER FAIL 
macro UBA$V_CR_CNFIE = 4,2,1,0 %;       !  CONFIGURATION INTERRUPT ENABLE 
macro UBA$V_CR_SUEFIE = 4,3,1,0 %;      !  SBI TO UNIBUS ERROR FIELD INTERRUPT ENABLE 
macro UBA$V_CR_USEFIE = 4,4,1,0 %;      !  UNIBUS TO SBI ERROR FIELD INTERRUPT ENABLE 
macro UBA$V_CR_BRIE = 4,5,1,0 %;        !  BUS REQUEST INTERRUPT ENABLE 
macro UBA$V_CR_IFSIE = 4,6,1,0 %;       !  INTERRUPT FIELD SWITCH INTERRUPT ENABLE 
macro UBA$V_CR_ARLVL = 4,7,2,0 %;
literal UBA$S_CR_ARLVL = 2;             !  ADAPTER REQUEST LEVEL 
macro UBA$V_CR_MRDSB = 4,26,5,0 %;
literal UBA$S_CR_MRDSB = 5;             !  MAP REGISTER DISABLE 
macro UBA$L_SR = 8,0,32,0 %;            ! STATUS REGISTER 
macro UBA$V_SR_SSYNC = 8,0,1,0 %;       !  UNIBUS SLAVE SYNC TIMEOUT 
macro UBA$V_SR_UBSTO = 8,1,1,0 %;       !  UNIBUS SELECT TIMEOUT 
macro UBA$V_SR_LER = 8,2,1,0 %;         !  LOST ERROR 
macro UBA$V_SR_MRPE = 8,3,1,0 %;        !  MAP REGISTER PARITY ERROR 
macro UBA$V_SR_IVMR = 8,4,1,0 %;        !  INVALID MAP REGISTER 
macro UBA$V_SR_DPPE = 8,5,1,0 %;        !  DATAPATH PARITY ERROR 
macro UBA$V_SR_CXTMO = 8,6,1,0 %;       !  COMMAND TRANSMISSION TIMEOUT 
macro UBA$V_SR_CXTER = 8,7,1,0 %;       !  COMMAND TRANSMISSION ERROR 
macro UBA$V_SR_CRD = 8,8,1,0 %;         !  CORRECTED READ DATA 
macro UBA$V_SR_RDS = 8,9,1,0 %;         !  READ DATA SUBSTITUTE 
macro UBA$V_SR_RDTO = 8,10,1,0 %;       !  READ DATA TIMEOUT 
macro UBA$V_SR_BRID = 8,11,1,0 %;       !  BUS REQUEST INTERRUPT DONE 
macro UBA$V_SR_BRRVF = 8,24,4,0 %;
literal UBA$S_SR_BRRVF = 4;             !  BUS REQUEST RECEIVE VECTOR FULL 
macro UBA$V_SR_BRSVF = 8,28,1,0 %;      !  BUS REQUEST SEND VECTOR FULL 
macro UBA$V_SR_RIE = 8,29,1,0 %;        !  REQUEST INTERRUPT ENABLED 
macro UBA$V_SR_UBIFS = 8,30,1,0 %;      !  UNIBUS INTERRUPT FIELD SWITCH 
macro UBA$L_DCR = 12,0,32,0 %;          ! DIAGNOSTIC CONTROL REGISTER 
macro UBA$L_FMER = 16,0,32,0 %;         ! FAILED MAP ENTRY REGISTER 
macro UBA$V_FMER_MRN = 16,0,9,0 %;
literal UBA$S_FMER_MRN = 9;             !  FAILED MAP REGISTER NUMBER 
macro UBA$L_FUBAR = 20,0,32,0 %;        ! FAILED UNIBUS ADDRESS REGISTER 
macro UBA$V_FUBAR_ADR = 20,0,18,0 %;
literal UBA$S_FUBAR_ADR = 18;           !  FAILED SBI TO UNIBUS ADDRESS 
macro UBA$L_BRSVR = 32,0,0,0 %;
literal UBA$S_BRSVR = 16;               ! BUS REQUEST SEND VECTOR REGISTERS 
macro UBA$L_BRRVR = 48,0,0,0 %;
literal UBA$S_BRRVR = 16;               ! BUS REQUEST RECEIVE VECTOR REGISTER 
macro UBA$V_BRRVR_IVA = 48,0,16,0 %;
literal UBA$S_BRRVR_IVA = 16;           !  INTERRUPT VECTOR ADDRESS 
macro UBA$V_BRRVR_AIR = 48,31,1,0 %;    !  ADAPTER INTERRUPT REQUEST PENDING 
macro UBA$L_DPR = 64,0,0,0 %;
literal UBA$S_DPR = 64;                 ! DATAPATH REGISTERS 
macro UBA$V_DPR_ADDR = 64,0,16,0 %;
literal UBA$S_DPR_ADDR = 16;            !  BUFFERED UNIBUS ADDRESS 
macro UBA$V_DPR_STATE = 64,16,8,0 %;
literal UBA$S_DPR_STATE = 8;            !  BUFFER STATE FLAGS 
macro UBA$V_DPR_DPF = 64,29,1,0 %;      !  DATAPATH FUNCTION 
macro UBA$V_DPR_XMTER = 64,30,1,0 %;    !  BUFFER TRANSFER ERROR 
macro UBA$V_DPR_BNE = 64,31,1,0 %;      !  BUFFER NOT EMPTY 
macro UBA$L_MAP = 2048,0,0,0 %;
literal UBA$S_MAP = 1984;               ! MAP REGISTERS 
macro UBA$V_MAP_ADDR = 2048,0,21,0 %;
literal UBA$S_MAP_ADDR = 21;            !  SBI PAGE ADDRESS 
macro UBA$V_MAP_DPD = 2048,21,4,0 %;
literal UBA$S_MAP_DPD = 4;              !  DATAPATH DESIGNATOR 
macro UBA$V_MAP_BO = 2048,25,1,0 %;     !  BYTE OFFSET 
macro UBA$V_MAP_VALID = 2048,31,1,0 %;  !  MAP REGISTER VALID 
 
!*** MODULE $UBIDEF ***
! +
!  UNIBUS INTERCONNECT (VAX 11/750 & 11/730) REGISTER OFFSETS AND FIELDS
! -
literal UBI$M_DPR_PUR = 1;
literal UBI$M_DPR_UCE = 536870912;
literal UBI$M_DPR_NXM = 1073741824;
literal UBI$M_DPR_ERROR = -2147483648;
literal UBI$S_UBIDEF = 16;
macro UBI$L_DPR = 0,0,0,0 %;
literal UBI$S_DPR = 16;                 ! DATAPATH REGISTERS 
!  (DPR 0 NOT IMPLEMENTED)
macro UBI$V_DPR_PUR = 0,0,1,0 %;        !  DATAPATH PURGE 
macro UBI$V_DPR_UCE = 0,29,1,0 %;       !  UNCORRECTABLE ERROR 
macro UBI$V_DPR_NXM = 0,30,1,0 %;       !  NON-EXISTENT MEMORY 
macro UBI$V_DPR_ERROR = 0,31,1,0 %;     !  ERROR (UCE!NXM) 
literal UBI$M_DSR_CD = 134217728;
literal UBI$S_UBIDEF1 = 32;
macro UBI$L_DSR = 16,0,0,0 %;
literal UBI$S_DSR = 16;                 ! DIAGNOSTIC STATUS REGISTERS 
!  (DSR 0 NOT IMPLEMENTED)
macro UBI$V_DSR_CD = 16,27,1,0 %;       !  ALL 4 BYTES IN BDP FULL 
macro UBI$V_DSR_BF = 16,28,4,0 %;
literal UBI$S_DSR_BF = 4;               !  BYTE 0,1,2,3 IN BDP HAS VALID DATA 
literal UBI$M_SR_UWE = 16384;
literal UBI$M_SR_MRPE = 32768;
literal UBI$M_SR_NXM = 65536;
literal UBI$M_SR_UCE = -2147483648;
literal UBI$S_UBIDEF2 = 20;
macro UBI$L_SR = 16,0,32,0 %;           ! UB STATUS REGISTER: 
macro UBI$V_SR_UWE = 16,14,1,0 %;       !  UNCORRECTED WRITE ERROR 
macro UBI$V_SR_MRPE = 16,15,1,0 %;      !  MAP REGISTER PARITY ERROR 
macro UBI$V_SR_NXM = 16,16,1,0 %;       !  NONEXISTENT MEMORY REF 
macro UBI$V_SR_UCE = 16,31,1,0 %;       !  UNCORRECTED READ ERROR 
! END OF CPU_SPECIFIC REGISTERS
literal UBI$C_MAXDP = 3;                ! MAXIMUM DATAPATH ! 
literal UBI$C_PURCNT = 10;              ! MAX ! OF TESTS OF PURGE DONE 
literal UBI$S_UBIDEF3 = 4032;
macro UBI$L_MAP = 2048,0,0,0 %;
literal UBI$S_MAP = 1984;               ! MAP REGISTERS, SAME FORMAT AS UBA 
 
!*** MODULE $UBMDDEF ***
! +
!  UBMD - UNIBUS Map Descriptor used to record UNIBUS map registers
!         and datapaths allocated.
! -
literal UBMD$S_UBMDDEF = 4;
macro UBMD$W_MAPREG = 0,0,16,0 %;       !  Starting map register 
macro UBMD$B_NUMREG = 2,0,8,0 %;        !  Number of registers in extent 
macro UBMD$B_DATAPATH = 3,0,8,0 %;      !  Associated Buffered datapath 
 
!*** MODULE $UCBDEF ***
literal UCB$M_TIM = 1;
literal UCB$M_INT = 2;
literal UCB$M_ERLOGIP = 4;
literal UCB$M_CANCEL = 8;
literal UCB$M_ONLINE = 16;
literal UCB$M_POWER = 32;
literal UCB$M_TIMOUT = 64;
literal UCB$M_INTTYPE = 128;
literal UCB$M_BSY = 256;
literal UCB$M_MOUNTING = 512;
literal UCB$M_DEADMO = 1024;
literal UCB$M_VALID = 2048;
literal UCB$M_UNLOAD = 4096;
literal UCB$M_TEMPLATE = 8192;
literal UCB$M_MNTVERIP = 16384;
literal UCB$M_WRONGVOL = 32768;
literal UCB$M_DELETEUCB = 65536;
literal UCB$M_LCL_VALID = 131072;
literal UCB$M_SUPMVMSG = 262144;
literal UCB$M_MNTVERPND = 524288;
literal UCB$M_DISMOUNT = 1048576;
literal UCB$M_CLUTRAN = 2097152;
literal UCB$M_WRTLOCKMV = 4194304;
literal UCB$M_SVPN_END = 8388608;
literal UCB$M_ALTBSY = 16777216;
literal UCB$M_SNAPSHOT = 33554432;
literal UCB$M_JOB = 1;
literal UCB$M_TEMPL_BSY = 64;
literal UCB$M_PRMMBX = 1;
literal UCB$M_DELMBX = 2;
literal UCB$M_SHMMBX = 8;
literal UCB$M_TT_TIMO = 2;
literal UCB$M_TT_NOTIF = 4;
literal UCB$M_TT_HANGUP = 8;
literal UCB$M_TT_NOLOGINS = 32768;
literal UCB$M_NT_BFROVF = 4;
literal UCB$M_NT_NAME = 16;
literal UCB$M_NT_BREAK = 32;
literal UCB$M_ECC = 1;
literal UCB$M_DIAGBUF = 2;
literal UCB$M_NOCNVRT = 4;
literal UCB$M_DX_WRITE = 8;
literal UCB$M_DATACACHE = 16;
literal UCB$M_MSCP_MNTVERIP = 256;
literal UCB$M_MSCP_INITING = 512;
literal UCB$M_MSCP_WAITBMP = 1024;
literal UCB$M_MSCP_FLOVR = 2048;
literal UCB$M_MSCP_PKACK = 4096;
literal UCB$M_MSCP_WRTP = 8192;
literal UCB$M_MSCP_IGNSRV = 16384;
literal UCB$M_DU_SHMV_STRTD = 8;
literal UCB$M_DU_0MNOTE = 32;
literal UCB$M_TU_OVRSQCHK = 1;
literal UCB$M_TU_TRACEACT = 2;
literal UCB$M_TU_SEQNOP = 4;
literal UCB$M_TU_1DENS = 8;
literal UCB$M_TU_DENS_DETERMINED = 16;
literal UCB$M_TU_MEDIA_LOADED = 32;
literal UCB$M_SHD_SEQCMD_HERE = 1024;
literal UCB$M_SHD_SEQCMD_THERE = 2048;
literal UCB$M_SHD_PASSIVE_MV = 4096;
literal UCB$M_SHD_NODE_FAILURE = 8192;
literal UCB$M_SHD_WLGSTA_CHA = 16384;
literal UCB$K_LENGTH = 164;             ! LENGTH OF STANDARD UCB 
literal UCB$C_LENGTH = 164;             ! LENGTH OF STANDARD UCB 
literal UCB$S_UCBDEF = 164;
macro UCB$L_FQFL = 0,0,32,0 %;          ! FORK QUEUE FORWARD LINK 
macro UCB$W_UNIT_SEED = 0,0,16,0 %;     !  UNIT NUMBER SEED 
macro UCB$W_MB_SEED = 0,0,16,0 %;       !  MB -- UNIT NUMBER SEED 
macro UCB$L_RQFL = 0,0,32,0 %;          !  NET -- RCV QUEUE FORWARD LINK 
macro UCB$L_MB_MSGQFL = 0,0,32,0 %;     !  MAILBOX MESSAGE QUEUE LISTHEAD
macro UCB$L_FQBL = 4,0,32,0 %;          ! FORK QUEUE BACKWARD LINK 
macro UCB$L_RQBL = 4,0,32,0 %;          !  NET -- RCV QUEUE BACKWARD LINK 
macro UCB$L_MB_MSGQBL = 4,0,32,0 %;     !  MAILBOX MESSAGE QUEUE LISTHEAD
macro UCB$W_SIZE = 8,0,16,0 %;          ! SIZE OF UCB IN BYTES 
macro UCB$B_TYPE = 10,0,8,0 %;          ! STRUCTURE TYPE FOR UCB 
macro UCB$B_FLCK = 11,0,8,0 %;          ! FORK LOCK NUMBER
macro UCB$B_FIPL = 11,0,8,0 %;          ! FORK IPL
macro UCB$L_FPC = 12,0,32,0 %;          ! FORK PC 
macro UCB$L_ASTQFL = 12,0,32,0 %;       !  MB -- AST QUEUE LISTHEAD FORWARD LINK 
macro UCB$L_MB_W_AST = 12,0,32,0 %;     !  MAILBOX WRITE ATTN AST LIST
macro UCB$T_PARTNER = 12,0,8,0 %;       !  NET -- PARTNER'S NODENAME 
macro UCB$L_FR3 = 16,0,32,0 %;          ! FORK R3 
macro UCB$L_ASTQBL = 16,0,32,0 %;       !  MB -- AST QUEUE LISTHEAD BACKWARD LINK 
macro UCB$L_MB_R_AST = 16,0,32,0 %;     !  MAILBOX READ ATTN AST LIST
macro UCB$L_FR4 = 20,0,32,0 %;          ! FORK R4 
macro UCB$W_MSGMAX = 20,0,16,0 %;       !  MB -- MAXIMUM MESSAGES ALLOWED 
macro UCB$W_MSGCNT = 22,0,16,0 %;       !  MB -- CURRENT NUMBER OF MESSAGES 
macro UCB$L_FIRST = 20,0,32,0 %;        !  NET -- ADDR OF 1ST SEG OF CHAINED MSG 
macro UCB$W_BUFQUO = 24,0,16,0 %;       !  BUFFERED I/O QUOTA CHARGED FOR THIS UCB
macro UCB$W_DSTADDR = 24,0,16,0 %;      !  NET -- REMOTE CONNECT NO. 
macro UCB$W_INIQUO = 26,0,16,0 %;       !  INITIAL BUFFERED I/O QUOTA FOR THIS UCB
macro UCB$W_SRCADDR = 26,0,16,0 %;      !  NET -- LOCAL CONNECT NO. 
macro UCB$L_ORB = 28,0,32,0 %;          !  OBJECT'S RIGHTS BLOCK ADDRESS
macro UCB$L_LOCKID = 32,0,32,0 %;       ! DEVICE LOCK ID
macro UCB$L_CPID = 32,0,32,0 %;         ! PID CHARGED FOR BUFQUO BY UCBCREDEL
macro UCB$L_CRB = 36,0,32,0 %;          ! ADDRESS OF PRIMARY CHANNEL REQUEST BLOCK 
macro UCB$L_DLCK = 40,0,32,0 %;         ! ADDRESS OF DEVICE IPL SPINLOCK
macro UCB$L_DDB = 44,0,32,0 %;          ! BACKPOINTER TO DEVICE DATA BLOCK 
macro UCB$L_PID = 48,0,32,0 %;          ! PROCESS ID OF OWNER PROCESS 
macro UCB$L_LINK = 52,0,32,0 %;         ! ADDRESS OF NEXT UCB FOR RESPECTIVE DDB 
macro UCB$L_VCB = 56,0,32,0 %;          ! ADDRESS OF VOLUME CONTROL BLOCK 
macro UCB$Q_DEVCHAR = 60,0,0,0 %;
literal UCB$S_DEVCHAR = 8;              !  Device characteristic bits quadword
macro UCB$L_DEVCHAR = 60,0,32,0 %;      !   Original device characteristic bits
macro UCB$L_DEVCHAR2 = 64,0,32,0 %;     !   Extended device characteristic bits
macro UCB$L_AFFINITY = 68,0,32,0 %;     ! DEVICE AFFINITY
macro UCB$L_XTRA = 72,0,32,0 %;         ! EXTRA LONGWORD (FOR SMP)
macro UCB$L_ALTIOWQ = 72,0,32,0 %;      ! ALTERNATE STARTIO WAIT
! QUEUE
macro UCB$B_DEVCLASS = 76,0,8,0 %;      ! DEVICE CLASS 
macro UCB$B_DEVTYPE = 77,0,8,0 %;       ! DEVICE TYPE 
macro UCB$W_DEVBUFSIZ = 78,0,16,0 %;    ! DEVICE DEFAULT BUFFER SIZE 
macro UCB$Q_DEVDEPEND = 80,0,0,0 %;
literal UCB$S_DEVDEPEND = 8;            ! Device dependent quadword
macro UCB$R_DEVDEPEND_Q_BLOCK = 80,0,0,0 %;
literal UCB$S_DEVDEPEND_Q_BLOCK = 8;
macro UCB$L_DEVDEPEND = 80,0,32,0 %;    !   First device dependent longword
macro UCB$R_DISK_DEVDEPEND = 80,0,32,0 %;
literal UCB$S_DISK_DEVDEPEND = 4;       !     Disk fields
macro UCB$B_SECTORS = 80,0,8,0 %;       ! 	Sectors per track
macro UCB$B_TRACKS = 81,0,8,0 %;        ! 	Track per cylinder
macro UCB$W_CYLINDERS = 82,0,16,0 %;    ! 	Cylinders per disk
macro UCB$R_TERM_DEVDEPEND = 80,0,32,0 %;
literal UCB$S_TERM_DEVDEPEND = 4;       !     Terminal fields
macro UCB$B_VERTSZ = 83,0,8,0 %;        ! 	Vertical page size (lines per page)
macro UCB$R_NET_DEVDEPEND = 80,0,32,0 %;
literal UCB$S_NET_DEVDEPEND = 4;        !     Network fields
macro UCB$B_LOCSRV = 80,0,8,0 %;        ! 	Local link services 
macro UCB$B_REMSRV = 81,0,8,0 %;        ! 	Remote link services
macro UCB$W_BYTESTOGO = 82,0,16,0 %;    ! 	No. of bytes left in rcv bfr
macro UCB$L_DEVDEPND2 = 84,0,32,0 %;    !   Second device dependent long word 
macro UCB$L_TT_DEVDP1 = 84,0,32,0 %;    !     Terminal -- Device dependent long word 
macro UCB$W_TU_FORMENU = 84,0,16,0 %;   !     TU/TMSCP -- Supported formats (returned by GETDVI).
macro UCB$Q_DEVDEPEND2 = 88,0,0,0 %;
literal UCB$S_DEVDEPEND2 = 8;           ! Device dependent quadword
macro UCB$R_DEVDEPEND2_Q_BLOCK = 88,0,0,0 %;
literal UCB$S_DEVDEPEND2_Q_BLOCK = 8;
macro UCB$L_DEVDEPND3 = 88,0,32,0 %;    !   3rd device dependent longword
macro UCB$L_DEVDEPND4 = 92,0,32,0 %;    !   4th device dependent long word
macro UCB$L_TL_POSIX_DATA = 92,0,32,0 %; !   Pointer to POSIX data block
macro UCB$R_TMV_BCNT = 88,0,0,0 %;
literal UCB$S_TMV_BCNT = 8;             !  Tape Mount verification byte counts
macro UCB$W_TMV_BCNT1 = 88,0,16,0 %;    !  Byte count for 1st CRC
macro UCB$W_TMV_BCNT2 = 90,0,16,0 %;    !  ...2nd CRC
macro UCB$W_TMV_BCNT3 = 92,0,16,0 %;    !  ...3rd CRC
macro UCB$W_TMV_BCNT4 = 94,0,16,0 %;    !  ...4th CRC
macro UCB$R_CHAR_SET = 88,0,32,0 %;
literal UCB$S_CHAR_SET = 4;             !  Overlay to hold asian character set 
macro UCB$W_TL_A_RESERVED = 88,0,16,0 %; !  reserved for device characteristics bits
macro UCB$W_TL_A_CHARSET = 90,0,16,0 %; !  character set data
macro UCB$R_CHAR_SET_2 = 88,0,0,0 %;
literal UCB$S_CHAR_SET_2 = 5;           !  Define a second overlay of DEVDEPND3 for 
macro UCB$B_TL_A_PSEUDO_MODE = 88,0,8,0 %; !  to make adding $GETDVI support easier and 
macro UCB$L_TL_A_CHARSET = 89,0,32,0 %; !  to be comapatible with other planned versions
macro UCB$L_IOQFL = 96,0,32,0 %;        ! I/O QUEUE LISTHEAD FORWARD LINK 
macro UCB$L_IOQBL = 100,0,32,0 %;       ! I/O QUEUE LISTHEAD BACKWARD LINK 
macro UCB$W_UNIT = 104,0,16,0 %;        ! PHYSICAL DEVICE UNIT NUMBER 
macro UCB$W_CHARGE = 106,0,16,0 %;      ! MAILBOX BYTE COUNT QUOTA CHARGE 
macro UCB$W_RWAITCNT = 106,0,16,0 %;    !  CLASS DRIVERS -- THREADS WAITING RESOURCES 
macro UCB$B_CM1 = 106,0,8,0 %;          !  LEVEL 1 CONTROLLER ALLOCATION MASK 
macro UCB$B_CM2 = 107,0,8,0 %;          !  LEVEL 2 CONTROLLER ALLOCATION MASK 
macro UCB$L_IRP = 108,0,32,0 %;         ! CURRENT I/O REQUEST PACKET ADDRESS 
macro UCB$W_REFC = 112,0,16,0 %;        ! REFERENCE COUNT OF PROCESSES 
macro UCB$B_DIPL = 114,0,8,0 %;         ! DEVICE INTERRUPT PRIORITY LEVEL 
macro UCB$B_STATE = 114,0,8,0 %;        !  NET -- LINK STATE FOR NETWORK TRANSITIONS 
macro UCB$B_AMOD = 115,0,8,0 %;         ! ALLOCATION ACCESS MODE 
macro UCB$L_AMB = 116,0,32,0 %;         ! ASSOCIATED UNIT CONTROL BLOCK POINTER 
macro UCB$L_STS = 120,0,32,0 %;         ! DEVICE UNIT STATUS 
macro UCB$W_STS = 120,0,16,0 %;
macro UCB$V_TIM = 120,0,1,0 %;          !  TIME OUT ENABLED (1=YES) 
macro UCB$V_INT = 120,1,1,0 %;          !  INTERRUPT EXPECTED (1=YES) 
macro UCB$V_ERLOGIP = 120,2,1,0 %;      !  ERROR LOG IN PROGRESS ON UNIT (1=YES) 
macro UCB$V_CANCEL = 120,3,1,0 %;       !  CANCEL I/O ON UNIT (1=YES) 
macro UCB$V_ONLINE = 120,4,1,0 %;       !  UNIT ONLINE (1=YES) 
macro UCB$V_POWER = 120,5,1,0 %;        !  POWER FAILED WHILE UNIT BUSY (1=YES) 
macro UCB$V_TIMOUT = 120,6,1,0 %;       !  UNIT TIMED OUT (1=YES) 
macro UCB$V_INTTYPE = 120,7,1,0 %;      !  RECEIVER INTERRUPT IF SET 
macro UCB$V_BSY = 120,8,1,0 %;          !  UNIT IS BUSY (1=YES) 
macro UCB$V_MOUNTING = 120,9,1,0 %;     !  DEVICE IS BEING MOUNTED 
macro UCB$V_DEADMO = 120,10,1,0 %;      !  DEALLOCATE AT DISMOUNT 
macro UCB$V_VALID = 120,11,1,0 %;       !  VOLUME IS SOFTWARE VALID 
macro UCB$V_UNLOAD = 120,12,1,0 %;      !  UNLOAD VOLUME AT DISMOUNT 
macro UCB$V_TEMPLATE = 120,13,1,0 %;    !  SET IF THIS IS TEMPLATE UCB
macro UCB$V_MNTVERIP = 120,14,1,0 %;    !  MOUNT VERIFICATION IN PROGRESS 
macro UCB$V_WRONGVOL = 120,15,1,0 %;    !  WRONG VOLUME DETECTED DURING MOUNT VERIFICATION 
macro UCB$V_DELETEUCB = 120,16,1,0 %;   !  DELETE THIS UCB WHEN REFC REACHES ZERO
macro UCB$V_LCL_VALID = 120,17,1,0 %;   !  VOLUME IS VALID ON THE LOCAL NODE
macro UCB$V_SUPMVMSG = 120,18,1,0 %;    !  IF SET, SUPPRESS SUCCESS TYPE MOUNT VER. MSGS.
macro UCB$V_MNTVERPND = 120,19,1,0 %;   !  MOUNT VERIFICATION IS PENDING ON BUSY DEVICE.
macro UCB$V_DISMOUNT = 120,20,1,0 %;    !  DISMOUNT IN PROGRESS
macro UCB$V_CLUTRAN = 120,21,1,0 %;     !  VAXcluster STATE TRANSITION IN PROGRESS
macro UCB$V_WRTLOCKMV = 120,22,1,0 %;   !  Write-locked mount verification in progress
macro UCB$V_SVPN_END = 120,23,1,0 %;    !  Last byte used from page mapped by SVPN
macro UCB$V_ALTBSY = 120,24,1,0 %;      !  Unit is busy via alternate startio path
macro UCB$V_SNAPSHOT = 120,25,1,0 %;    !    Restart validation is in progress
macro UCB$W_DEVSTS = 124,0,16,0 %;      ! DEVICE DEPENDENT STATUS 
macro UCB$V_JOB = 124,0,1,0 %;          !    Job Controller notified 
macro UCB$V_TEMPL_BSY = 124,6,1,0 %;    !    Template UCB is busy 
macro UCB$V_PRMMBX = 124,0,1,0 %;       !    Permanent mailbox 
macro UCB$V_DELMBX = 124,1,1,0 %;       !    Mailbox marked for delete 
macro UCB$V_SHMMBX = 124,3,1,0 %;       !    Shared memory mailbox 
macro UCB$V_TT_TIMO = 124,1,1,0 %;      !    Terminal read timeout in progress 
macro UCB$V_TT_NOTIF = 124,2,1,0 %;     !    Terminal user notified of unsolicted data 
macro UCB$V_TT_HANGUP = 124,3,1,0 %;    !    Process hang up
macro UCB$V_TT_DEVSTS_FILL = 124,4,11,0 %;
literal UCB$S_TT_DEVSTS_FILL = 11;      !    fill to the end the word
macro UCB$V_TT_NOLOGINS = 124,15,1,0 %; !  NOLOGINS ALLOWED
macro UCB$V_NT_BFROVF = 124,2,1,0 %;    !    Too many bytes rcvd 
macro UCB$V_NT_NAME = 124,4,1,0 %;      !    Link has declared a connect name 
macro UCB$V_NT_BREAK = 124,5,1,0 %;     !    Link is being broken 
macro UCB$V_ECC = 124,0,1,0 %;          !    ECC correction was made
macro UCB$V_DIAGBUF = 124,1,1,0 %;      !    Diagnostic buffer specified
macro UCB$V_NOCNVRT = 124,2,1,0 %;      !    No LBN to media address conversion
macro UCB$V_DX_WRITE = 124,3,1,0 %;     !    Console floppy write operation
macro UCB$V_DATACACHE = 124,4,1,0 %;    !    Data blocks being cached
macro UCB$V_MSCP_MNTVERIP = 124,8,1,0 %; !    Mount verification in progress
macro UCB$V_MSCP_INITING = 124,9,1,0 %; !    UCB is being initialized
macro UCB$V_MSCP_WAITBMP = 124,10,1,0 %; !    RWAITCNT has been bumped
macro UCB$V_MSCP_FLOVR = 124,11,1,0 %;  !    Bit toggled everytime a failover succeeds.
macro UCB$V_MSCP_PKACK = 124,12,1,0 %;  !    Set when a IO$_PACKACK is in progress.
macro UCB$V_MSCP_WRTP = 124,13,1,0 %;   !    Unit MSCP write protected in some way.
macro UCB$V_MSCP_IGNSRV = 124,14,1,0 %; !    Ignore served paths during connection failover.
macro UCB$V_DU_SHMV_STRTD = 124,3,1,0 %; !    Shadowing mount verification started
macro UCB$V_DU_0MNOTE = 124,5,1,0 %;    !    Zero members message sent
macro UCB$V_TU_OVRSQCHK = 124,0,1,0 %;  !    Override sequence checking
macro UCB$V_TU_TRACEACT = 124,1,1,0 %;  !    IRP trace table active
macro UCB$V_TU_SEQNOP = 124,2,1,0 %;    !    Sequential NOP tape operation in progress
macro UCB$V_TU_1DENS = 124,3,1,0 %;     !    Single density device
macro UCB$V_TU_DENS_DETERMINED = 124,4,1,0 %; !    Density already determined. Basically a
!     bit that says that a particular part of
!     PACKACK processing has already been done
!     once for this unit.
macro UCB$V_TU_MEDIA_LOADED = 124,5,1,0 %; !    Media loaded into drive and drive available.
macro UCB$V_SHD_SEQCMD_HERE = 124,10,1,0 %; !    Sequential command in progress on this node
macro UCB$V_SHD_SEQCMD_THERE = 124,11,1,0 %; !    Sequential command in progress on another node
macro UCB$V_SHD_PASSIVE_MV = 124,12,1,0 %; !    Passive MV in progress
macro UCB$V_SHD_NODE_FAILURE = 124,13,1,0 %; !    Node failure in progress
macro UCB$V_SHD_WLGSTA_CHA = 124,14,1,0 %; !    Write log state change
macro UCB$W_QLEN = 126,0,16,0 %;        !  Device queue length
macro UCB$L_DUETIM = 128,0,32,0 %;      ! DUE TIME FOR I/O COMPLETION 
macro UCB$L_OPCNT = 132,0,32,0 %;       ! COUNT OF OPERATIONS COMPLETED 
macro UCB$L_SVPN = 136,0,32,0 %;        ! SYSTEM VIRTUAL PAGE/MAP REGISTER NUMBER 
macro UCB$L_LOGADR = 136,0,32,0 %;      !  MB -- LOGICAL NAME BLOCK ADDRESS 
macro UCB$L_SVAPTE = 140,0,32,0 %;      ! SYSTEM VIRTUAL ADDRESS OF PTE 
macro UCB$W_BOFF = 144,0,16,0 %;        ! BYTE OFFSET IN FIRST PAGE 
macro UCB$W_BCNT = 146,0,16,0 %;        ! BYTE COUNT OF TRANSFER 
macro UCB$B_ERTCNT = 148,0,8,0 %;       ! ERROR LOG DEVICE CURRENT ERROR RETRY COUNT 
macro UCB$B_ERTMAX = 149,0,8,0 %;       ! ERROR LOG DEVICE MAXIMUM ERROR RETRY COUNT 
macro UCB$B_TL_A_MODE = 149,0,8,0 %;    !  TTDRIVER SLOT FOR ASIAN DRIVER MODE 
macro UCB$W_ERRCNT = 150,0,16,0 %;      ! DEVICE ERROR COUNT 
macro UCB$L_PDT = 152,0,32,0 %;         ! ADDR OF PORT DESCRIPTOR TABLE
macro UCB$L_DDT = 156,0,32,0 %;         ! ADDR OF DDT (OPTIONAL BUT PREFERRED) 
macro UCB$L_MEDIA_ID = 160,0,32,0 %;    ! BIT ENCODED MEDIA IDENTIFICATION 
macro UCB$V_MEDIA_ID_NN = 160,0,7,0 %;
literal UCB$S_MEDIA_ID_NN = 7;          !  MEDIA NAME NUMBER
macro UCB$V_MEDIA_ID_N2 = 160,7,5,0 %;
literal UCB$S_MEDIA_ID_N2 = 5;          !  MEDIA NAME CHAR 2
macro UCB$V_MEDIA_ID_N1 = 160,12,5,0 %;
literal UCB$S_MEDIA_ID_N1 = 5;          !  MEDIA NAME CHAR 1
macro UCB$V_MEDIA_ID_N0 = 160,17,5,0 %;
literal UCB$S_MEDIA_ID_N0 = 5;          !  MEDIA NAME CHAR 0
macro UCB$V_MEDIA_ID_T1 = 160,22,5,0 %;
literal UCB$S_MEDIA_ID_T1 = 5;          !  MEDIA TYPE CHAR 1
macro UCB$V_MEDIA_ID_T0 = 160,27,5,0 %;
literal UCB$S_MEDIA_ID_T0 = 5;          !  MEDIA TYPE CHAR 0
macro UCB$L_TL_ASIAN_DATA = 160,0,32,0 %; !  Pointer to ASIAN data block
!  for $TTYUCBDEF
! 
!  DEVICE DEPENDENT UCB EXTENSIONS
! 
!  MAILBOX
! 
literal UCB$K_MB_LENGTH = 192;          ! SIZE OF MAILBOX UCB 
literal UCB$C_MB_LENGTH = 192;          ! SIZE OF MAILBOX UCB 
literal UCB$S_UCBDEF3 = 192;
macro UCB$L_MB_WAST = 164,0,32,0 %;     ! WRITE ATTENTION AST BLOCK ADDR 
macro UCB$L_MB_RAST = 168,0,32,0 %;     ! READ ATTENTION AST BLOCK ADDR 
macro UCB$L_MB_MBX = 172,0,32,0 %;      ! MAILBOX CONTROL BLOCK ADDR 
macro UCB$L_MB_SHB = 176,0,32,0 %;      ! SHARED MEM. CONTROL BLOCK ADDR 
macro UCB$L_MB_WIOQFL = 180,0,32,0 %;   ! WRITE I/O QUEUE FORWARD LINK 
macro UCB$L_MB_WIOQBL = 184,0,32,0 %;   ! WRITE I/O QUEUE BACKWARD LINK 
macro UCB$L_MB_PORT = 188,0,32,0 %;     ! SHARED MEM. PORT NUMBER 
! 
!  ERROR LOG DEVICES (ALL)
! 
literal UCB$K_ERL_LENGTH = 180;         ! SIZE OF ERROR LOG UCB
literal UCB$C_ERL_LENGTH = 180;         ! SIZE OF ERROR LOG UCB
literal UCB$S_UCBDEF4 = 180;
macro UCB$B_SLAVE = 164,0,8,0 %;        ! SLAVE CONTROLLER NUMBER 
macro UCB$B_SPR = 165,0,8,0 %;          ! SPARE UNUSED BYTE 
macro UCB$B_FEX = 166,0,8,0 %;          ! FUNCTION DISPATCH TABLE INDEX 
macro UCB$B_CEX = 167,0,8,0 %;          ! CASE TABLE FUNCTION EXECUTION INDEX 
macro UCB$L_EMB = 168,0,32,0 %;         ! ADDRESS OF ERROR MESSAGE BUFFER 
macro UCB$W_FUNC = 174,0,16,0 %;        ! I/O FUNCTION MODIFIERS 
macro UCB$L_DPC = 176,0,32,0 %;         ! SAVED DRIVER SUBROUTINE RETURN ADDRESS
! 
!  DUAL PORTED DEVICES (ALL DISKS AND MOST TAPES)
! 
literal UCB$K_DP_LENGTH = 192;          !  Size of dual path UCB
literal UCB$C_DP_LENGTH = 192;          !  size of dual path UCB
literal UCB$K_2P_LENGTH = 192;          !  Size of dual path UCB
literal UCB$C_2P_LENGTH = 192;          !  size of dual path UCB
literal UCB$S_DUALPATH_EXTENSION = 192;
macro UCB$L_DP_DDB = 180,0,32,0 %;      !  Pointer to alternate DDB
macro UCB$L_DP_LINK = 184,0,32,0 %;     !  Address of next UCB for this DDB 
macro UCB$L_DP_ALTUCB = 188,0,32,0 %;   !  Addr of alternate UCB for this unit
macro UCB$L_2P_DDB = 180,0,32,0 %;      !  Pointer to alternate DDB
macro UCB$L_2P_LINK = 184,0,32,0 %;     !  Address of next UCB for this DDB 
macro UCB$L_2P_ALTUCB = 188,0,32,0 %;   !  Addr of alternate UCB for this unit
! 
!  ALL DISKS AND TAPES
! 
literal UCB$M_AST_ARMED = 32768;
literal UCB$K_LCL_TAPE_LENGTH = 216;    !  Size of local tape UCB
literal UCB$C_LCL_TAPE_LENGTH = 216;    !  Size of local tape UCB
literal UCB$S_DISKTAPE_UCB_EXTENSION = 216;
macro UCB$W_DIRSEQ = 192,0,16,0 %;      !  Directory sequence number
macro UCB$V_AST_ARMED = 192,15,1,0 %;   !   Blocking AST armed flag
macro UCB$B_ONLCNT = 194,0,8,0 %;       !  Online count
macro UCB$L_MAXBLOCK = 196,0,32,0 %;    !  Random access device highest block
macro UCB$L_MAXBCNT = 200,0,32,0 %;     !  Maximum transfer BCNT
macro UCB$L_DCCB = 204,0,32,0 %;        !  Pointer to data cache control block
macro UCB$L_QLENACC = 208,0,32,0 %;     !  Queue length accumulator
macro UCB$B_PREV_RECORD = 195,0,8,0 %;  !  Tape position prior at start of last I/O
macro UCB$L_RECORD = 196,0,32,0 %;      !  Current tape position or frame counter
macro UCB$L_TMV_RECORD = 204,0,32,0 %;  !  Position following last guaranteed successful I/O
macro UCB$W_TMV_CRC1 = 208,0,16,0 %;    !  1st CRC for Mount Ver's media validation
macro UCB$W_TMV_CRC2 = 210,0,16,0 %;    !  2nd CRC ...
macro UCB$W_TMV_CRC3 = 212,0,16,0 %;    !  3rd CRC ...
macro UCB$W_TMV_CRC4 = 214,0,16,0 %;    !  4th CRC ...
literal UCB$K_LCL_DISK_LENGTH = 228;    !  Size of local disk UCB
literal UCB$C_LCL_DISK_LENGTH = 228;    !  Size of local disk UCB
! 
literal UCB$S_LCL_DISK_UCB_EXTENSION = 244;
macro UCB$L_MEDIA = 212,0,32,0 %;       !  Media address (longword)
macro UCB$W_DA = 212,0,16,0 %;          !  Saved desired sector/track address register
macro UCB$W_DC = 214,0,16,0 %;          !  Saved desired cylinder address register
macro UCB$L_BCR = 216,0,32,0 %;         !  Byte count register
macro UCB$W_BCR = 216,0,16,0 %;
macro UCB$W_EC1 = 220,0,16,0 %;         !  ECC position register
macro UCB$W_EC2 = 222,0,16,0 %;         !  ECC pattern register
macro UCB$W_OFFSET = 224,0,16,0 %;      !  Current offset register contents
macro UCB$B_OFFNDX = 226,0,8,0 %;       !  Current offset table index
macro UCB$B_OFFRTC = 227,0,8,0 %;       !  Current offset retry count
!  FLOPPY DEPENDENT BIT DEFINITIONS
! 
macro UCB$L_DX_BUF = 228,0,32,0 %;      ! ADDRESS OF SECTOR BUFFER 
macro UCB$L_DX_BFPNT = 232,0,32,0 %;    ! CURRENT SECTOR BUFFER POINTER 
macro UCB$L_DX_RXDB = 236,0,32,0 %;     ! SAVED RECEIVER DATA BUFFER 
macro UCB$W_DX_BCR = 240,0,16,0 %;      ! CURRENT FLOPPY BYTE COUNT 
macro UCB$B_DX_SCTCNT = 242,0,8,0 %;    ! CURRENT SECTOR BYTE COUNT 
! 
!  MSCP DISKS AND TAPES UCB EXTENSION
! 
literal UCB$K_MSCP_DISK_LENGTH = 268;   !  Size of MSCP disk UCB
literal UCB$K_MSCP_TAPE_LENGTH = 268;   !  Size of MSCP tape UCB
literal UCB$S_MSCP_UCB_EXTENSION = 268;
macro UCB$L_CDDB = 216,0,32,0 %;        !  Pointer to active CDDB
macro UCB$L_2P_CDDB = 220,0,32,0 %;     !  Pointer to alternate CDDB
macro UCB$L_CDDB_LINK = 224,0,32,0 %;   !  Pointer to next UCB in CDDB chain
macro UCB$L_CDT = 228,0,32,0 %;         !  Pointer to active CDT
macro UCB$L_WAIT_CDDB = 232,0,32,0 %;   !  Address of CDDB waiting for mnt. ver. to complete on this UCB
macro UCB$L_PREF_CDDB = 236,0,32,0 %;   !  CDDB address for preferred path
macro UCB$Q_UNIT_ID = 240,0,0,0 %;
literal UCB$S_UNIT_ID = 8;              !  Unique MSCP unit identifier
macro UCB$W_MSCPUNIT = 248,0,16,0 %;    !  Primary path MSCP unit number 
macro UCB$W_UNIT_FLAGS = 250,0,16,0 %;  !  MSCP unit flags
macro UCB$W_LCL_MSCPUNIT = 252,0,16,0 %; !  MSCP unit number for local (non-emulated) controllers
macro UCB$W_SRV_MSCPUNIT = 254,0,16,0 %; !  MSCP unit number for served (emulated) controllers
macro UCB$L_MSCPDEVPARAM = 256,0,32,0 %; !  MSCP device-dependent parameters
macro UCB$B_FREECAP = 260,0,8,0 %;      !  Free capacity
macro UCB$W_MSCP_RESVDW = 262,0,16,0 %; !  Reserved for MSCP enhancements
macro UCB$L_SHAD = 264,0,32,0 %;        !  Virtual Unit Pointer to HBS SHAD
! 
!  DISK CLASS DRIVER DEVICE DEPENDENT UNIT CONTROL BLOCK OFFSETS
! 
literal UCB$K_DU_LENGTH = 294;          !  Size of DISK CLASS DRIVER dependent UCB
literal UCB$S_DUDRIVER_EXTENSION = 294;
macro UCB$L_DU_VOLSER = 268,0,32,0 %;   !  Serial umber as returned
!   in ONLINE end packet.
macro UCB$L_DU_USIZE = 272,0,32,0 %;    !  Size of user visible area of 
!   unit in logical blocks
macro UCB$L_DU_TOTSZ = 276,0,32,0 %;    !  Size of unit including RCT 
!   area in logical blocks
macro UCB$W_DU_RCTSIZE = 280,0,16,0 %;  !  Size of the RCT in blocks
macro UCB$B_DU_RCTCPYS = 282,0,8,0 %;   !  Number of RCT copies on the unit
macro UCB$B_DU_RBNPTRK = 283,0,8,0 %;   !  RBNs per track
macro UCB$W_DU_LBNPTRK = 284,0,16,0 %;  !  LBNs per track
macro UCB$W_DU_TRKPGRP = 286,0,16,0 %;  !  Tracks per group
macro UCB$W_DU_GRPPCYL = 288,0,16,0 %;  !  Groups per cylinder
macro UCB$W_DU_MUNTC = 290,0,16,0 %;    !  Multi-unit code
macro UCB$B_DU_USVR = 292,0,8,0 %;      !  Unit software version
macro UCB$B_DU_UHVR = 293,0,8,0 %;      !  Unit hardware version
! 
!  TAPE CLASS DRIVER DEVICE DEPENDENT UNIT CONTROL BLOCK OFFSETS
! 
literal UCB$M_TU_RPTREQ = 1;
literal UCB$M_TU_RPTPND = 2;
literal UCB$M_TU_DENSITY = 4;
literal UCB$K_TU_LENGTH = 280;          !  Size of TAPE CLASS DRIVER dependent UCB
literal UCB$S_TUDRIVER_EXTENSION = 280;
macro UCB$L_TU_MAXWRCNT = 268,0,32,0 %; !  Largest size record likely to have reliability statistics.
macro UCB$W_TU_FORMAT = 272,0,16,0 %;   !  Format (density).
macro UCB$W_TU_SPEED = 274,0,16,0 %;    !  Current speed.
macro UCB$W_TU_NOISE = 276,0,16,0 %;    !  Size of noise records ignored by controller.
macro UCB$B_TU_SOFTERR = 278,0,8,0 %;   !  Media quality reporting counter.
macro UCB$B_TU_SOFTFLAGS = 279,0,8,0 %; !  Media quality reporting flags.
macro UCB$V_TU_RPTREQ = 279,0,1,0 %;    !  Report request.
macro UCB$V_TU_RPTPND = 279,1,1,0 %;    !  Report pending.
macro UCB$V_TU_DENSITY = 279,2,1,0 %;   !  Density check done if set.
! 
!  NETWORK LOGICAL LINK (NETWORK MAILBOX) EXTENSION
! 
literal UCB$M_BACKP = 32;
literal UCB$C_LOGLNK = 1;               !  CONNECT IS FOR LOGICAL LINK (NOT SINGLE MSG) 
literal UCB$S_UCBDEF7 = 176;
macro UCB$L_NT_DATSSB = 164,0,32,0 %;   !  ADDRESS OF DATA SUBCHANNEL STATUS BLOCK 
macro UCB$L_NT_INTSSB = 168,0,32,0 %;   !  ADDRESS OF INT/LS SSB 
macro UCB$W_NT_CHAN = 172,0,16,0 %;     !  DDCMP CHANNEL NO. 
macro UCB$V_LTYPE = 174,0,2,0 %;
literal UCB$S_LTYPE = 2;                !  LINK TYPE BITS 
macro UCB$V_SEGFLO = 174,2,1,0 %;       !  SEGMENT REQUEST COUNTS 
macro UCB$V_MSGFLO = 174,3,1,0 %;       !  MESSAGE REQUEST COUNTS 
macro UCB$V_MSGACK = 174,4,1,0 %;       !  MESSAGE ACK/NAK 
macro UCB$V_BACKP = 174,5,1,0 %;        !  BACKPRESSURE (1=> NO FLOW) 
macro UCB$V_LNKPRI = 174,6,2,0 %;
literal UCB$S_LNKPRI = 2;               !  LINK PRIORITY (IGNORED) 
!  NETWORK CONSTANTS 
! 
!  NI DEVICE EXTENSION
! 
literal UCB$K_NI_LENGTH = 172;          ! SIZE OF NI DEVICE UCB 
literal UCB$C_NI_LENGTH = 172;          ! SIZE OF NI DEVICE UCB 
literal UCB$S_UCBDEF9 = 172;
macro UCB$L_NI_HWAPTR = 164,0,32,0 %;   ! ADDRESS OF NI DEVICE HARDWARE ADDRESS
macro UCB$L_NI_MLTPTR = 168,0,32,0 %;   ! ADDRESS OF PROTOCOL MULTICAST TABLE
! 
!  DAP DEVICE EXTENSION (FOR DEVICES THAT USE THE DAP INTERFACE WITHOUT
!  UNDELYING DECNET, SUCH AS CERTAIN CONSOLE DISKS).
! 
literal UCB$K_DAPDEV_LENGTH = 196;      ! SIZE OF DAP DEVICE UCB
literal UCB$C_DAPDEV_LENGTH = 196;      ! SIZE OF DAP DEVICE UCB
literal UCB$S_UCBDEF10 = 196;
macro UCB$T_DAPDEVNAM = 164,0,0,0 %;
literal UCB$S_DAPDEVNAM = 32;           ! EQUIVALENCE NAME STRING
! 
!  MAILBOX (Extended Mailbox - Above definitions are for Shared Memory Mailboxes.)
! 
literal UCB$K_MB_UCBLENGTH = 212;       ! SIZE OF MAILBOX UCB 
literal UCB$C_MB_UCBLENGTH = 212;       ! SIZE OF MAILBOX UCB 
literal UCB$S_UCBDEF11 = 212;
macro UCB$W_MB_READERREFC = 164,0,16,0 %; ! REFERENCE COUNT OF READ ENABLED CHANNELS TO DEVICE
macro UCB$W_MB_WRITERREFC = 166,0,16,0 %; ! REFERENCE COUNT OF WRITE ENABLED CHANNELS TO DEVICE
macro UCB$L_MB_READQFL = 168,0,32,0 %;  ! MAILBOX READ IRP QUEUE LISTHEAD
macro UCB$L_MB_READQBL = 172,0,32,0 %;
macro UCB$L_MB_WRITERWAITQFL = 176,0,32,0 %; ! MAILBOX WAIT FOR WRITE CHANNEL TO BE ASSIGNED QUEUE
macro UCB$L_MB_WRITERWAITQBL = 180,0,32,0 %;
macro UCB$L_MB_READERWAITQFL = 184,0,32,0 %; ! MAILBOX WAIT FOR READ CHANNEL TO BE ASSIGNED QUEUE
macro UCB$L_MB_READERWAITQBL = 188,0,32,0 %;
macro UCB$L_MB_NOWRITERWAITQFL = 192,0,32,0 %; ! MAILBOX WAIT FOR ALL WRITE CHANNELS TO BE DEASSIGNED QUEUE
macro UCB$L_MB_NOWRITERWAITQBL = 196,0,32,0 %;
macro UCB$L_MB_NOREADERWAITQFL = 200,0,32,0 %; ! MAILBOX WAIT FOR ALL READ CHANNELS TO BE DEASSIGNED QUEUE
macro UCB$L_MB_NOREADERWAITQBL = 204,0,32,0 %;
macro UCB$L_MB_ROOM_NOTIFY = 208,0,32,0 %; ! ROOM NOTIFY AST LIST
 
!*** MODULE $UCODEDEF ***
! +
!  Define device microcode image header
! 
!  When SYSGEN loads device microcode with a driver, the DPT$L_UCODE
!  field will point to this header structure which contains the size
!  and beginning address of the microcode.
!  
! -
literal UCODE$S_UCODEDEF = 20;
macro UCODE$L_FLINK = 0,0,32,0 %;       ! 
macro UCODE$L_BLINK = 4,0,32,0 %;       ! 
macro UCODE$W_SIZE = 8,0,16,0 %;        ! STRUCTURE SIZE IN BYTES 
!  (zero if gt 64 kb)
macro UCODE$B_TYPE = 10,0,8,0 %;        ! STRUCTURE TYPE
macro UCODE$B_SUBTYP = 11,0,8,0 %;      ! STRUCTURE SUBTYPE 
macro UCODE$L_USIZE = 12,0,32,0 %;      ! SIZE OF THE MICROCODE IMAGE
macro UCODE$L_BASE = 16,0,32,0 %;       ! START OF THE MICROCODE IMAGE
 
!*** MODULE $UNCDEF ***
! 
!  UNCHDRDEF - universal Context Segment Header definition
! 
literal UNC$C_JPI = 1;                  !  JPI CONTEXT SEGMENT
literal UNC$C_UAI = 2;                  !  UAI CONTEXT SEGMENT
literal UNC$C_HDR_LENGTH = 16;          !  SIZE OF CONTEXT SEGMENT HEADER
literal UNC$C_LIST = 16;                !  OFFSET TO FIRST CONTEXT BLOCK
literal UNC$S_UNCHDRDEF = 16;
macro UNC$L_FLINK = 0,0,32,0 %;         !  FORWARD LINK TO NEXT CONTEXT SEGMENT
macro UNC$L_BLINK = 4,0,32,0 %;         !  BACK LINK TO PREV CONTEXT SEGMENT
macro UNC$W_SIZE = 8,0,16,0 %;          !  TOTAL SIZE OF CONTEXT SEGMENT
macro UNC$B_TYPE = 10,0,8,0 %;          !  VMS TYPE OF BLOCK (DYN$C_UNC)
macro UNC$B_SUBTYPE = 11,0,8,0 %;       !  TYPE OF CONTEXT SEGMENT
macro UNC$W_COUNT = 12,0,16,0 %;        !  NUMBER OF CONTEXT BLOCKS IN SEGMENT
macro UNC$W_UNUSED_W1 = 14,0,16,0 %;
! 
!  universal Context Block definition
! 
literal UNC$C_LENGTH = 16;              !  SIZE OF CONTEXT BLOCK
literal UNC$C_SEGMENTS = 31;
!  NATURAL NUMBER OF BLOCKS/SEGMENT
literal UNC$S_UNCDEF = 16;
macro UNC$W_FLAGS = 0,0,16,0 %;         !  CONTEXT CELL FLAGS
macro UNC$B_ACCESS_MODE = 2,0,8,0 %;    !  ACCESS MODE OF CONTEXT CELL
macro UNC$B_UNUSED_B1 = 3,0,8,0 %;
macro UNC$L_IMAGE_COUNT = 4,0,32,0 %;   !  IMGCNT WHEN CONTEXT CELL ASSIGNED
macro UNC$L_TARGET_PID = 8,0,32,0 %;    !  TARGET PROCESS PID
macro UNC$W_SEGIDX = 12,0,16,0 %;       !  RIGHTS SEGMENT INDEX
macro UNC$W_RIGHTS = 14,0,16,0 %;       !  RIGHTS LIST INDEX
macro UNC$W_IFI = 8,0,16,0 %;           !  FAB$W_IFI
macro UNC$W_ISI = 10,0,16,0 %;          !  RAB$W_ISI
macro UNC$W_CHANNEL = 12,0,16,0 %;      !  UAF CHANNEL
 
!*** MODULE $UTCDEF ***
! +
! 
!  $UTCDEF defines the storage format for UTC based times.
! 
! -
literal UTC$M_TDF = 4095;
literal UTC$M_VER = 61440;
literal UTC$S_UTCDEF = 16;
macro UTC$A_WHOLE_TIME = 0,0,0,0 %;
literal UTC$S_WHOLE_TIME = 16;          !  Double quad to fetch entire time
macro UTC$Q_ABSTIME = 0,0,0,0 %;
literal UTC$S_ABSTIME = 8;              !  64 bit system time
!  In units of 100ns ticks
macro UTC$Q_TDF_ETC = 8,0,0,0 %;
literal UTC$S_TDF_ETC = 8;              !  Inaccuracy, TDF, and version
macro UTC$L_ABS0 = 0,0,32,0 %;          !  Least sig 4 bytes of binary time
macro UTC$L_ABS1 = 4,0,32,0 %;          !  Most sig 4 bytes of binary time
macro UTC$L_INAC = 8,0,32,0 %;          !  4 least sig bytes of inaccuracy
macro UTC$L_TDFV = 12,0,32,0 %;         !  4 bits vers, 12 bits TDF, 2 
!  most sig bytes of inaccuracy
macro UTC$A_INACCUR = 0,0,0,1 %;
literal UTC$S_INACCUR = 6;              !  Six bytes of inaccuracy
!  In units of 100ns ticks
macro UTC$W_TDFWRD = 6,0,16,0 %;        !  Fetch the TDF and the version 
macro UTC$V_TDF = 6,0,12,0 %;
literal UTC$S_TDF = 12;                 !  12 bits of offset from UTC to local
!  In units of minutes
macro UTC$V_VER = 6,12,4,0 %;
literal UTC$S_VER = 4;                  !  Unsigned version number
 
!*** MODULE $UV2DEF ***
! ++
!  VIRTUAL ADDRESS SPACE LAYOUT FOR MicroVAX II CPU NODE SPECIFIC REGION
!  POINTED TO BY EXE$GL_CPUNODSP
! --
literal UV2$W_QVSS_CSR = 128;           !  QVSS CSR (IF EXISTS)
literal UV2$W_QDSS_CSR0 = 256;          !  QDSS CSR ADR (POSSIBLY)
literal UV2$W_QDSS_CSR2 = 258;          !  QDSS CSR ADR (POSSIBLY)
literal UV2$W_QDSS_CSR4 = 260;          !  QDSS CSR ADR (POSSIBLY)
literal UV2$W_QDSS_CSR6 = 262;          !  QDSS CSR ADR (POSSIBLY)
literal UV2$W_QDSS_CSR8 = 264;          !  QDSS CSR ADR (POSSIBLY)
literal UV2$W_QDSS_CSRA = 266;          !  QDSS CSR ADR (POSSIBLY)
literal UV2$W_QDSS_CSRC = 268;          !  QDSS CSR ADR (POSSIBLY)
literal UV2$W_QDSS_CSRE = 270;          !  QDSS CSR ADR (POSSIBLY)
literal UV2$W_INTPR0 = 320;             !  INTERPROC COMMUN REG
!    (ICR) FOR ARBITER
literal UV2$W_INTPR1 = 322;             !  ICR FOR AUXIL 1
literal UV2$W_INTPR2 = 324;             !  ICR FOR AUXIL 2
literal UV2$W_INTPR3 = 326;             !  ICR FOR AUXIL 3
literal UV2$L_SIDEX = 516;              !  SYS ID EXTENSION REG
literal UV2$W_BTDIAG = 1024;            !  BOOT & DIAG REG
literal UV2$L_MEMERR = 1028;            !  MEM SYSTEM ERR REG
literal UV2$L_CPUERR = 1032;            !  CPU ERROR ADDR REG
literal UV2$L_DMAERR = 1036;            !  DMA ERROR ADDR REG
literal UV2$L_QMAPS = 1536;             !  FIRST QBUS MAP REG
literal UV2$L_QMAPE = 34300;            !  LAST QBUS MAP REG
literal UV2$W_TODSEC = 34304;           !  TODR SECOND
literal UV2$W_TODSAL = 34306;           !  TODR SECOND ALARM
literal UV2$W_TODMIN = 34308;           !  TODR MINUTE
literal UV2$W_TODMAL = 34310;           !  TODR MINUTE ALARM
literal UV2$W_TODHR = 34312;            !  TODR HOUR
literal UV2$W_TODDWK = 34316;           !  TODR DAY OF WEEK
literal UV2$W_TODDAY = 34318;           !  TODR DAY OF MONTH
literal UV2$W_TODMON = 34320;           !  TODR MONTH
literal UV2$W_TODYR = 34322;            !  TODR YEARR
literal UV2$W_CPMBX = 34332;            !  CONSOLE PROG MAILBOX
literal UV2$W_CPMBX2 = 34334;           !  CONSOLE PROG MAILBOX2
literal UV2$S_UV2DEF = 34816;           !  SIZE MAPPED BY $UV2DEF
!  System ID Extension Longword
literal UV2$S_SIDEX = 4;
macro UV2$W_SIDEX_FILL1 = 0,0,16,0 %;   ! RESERVED
macro UV2$B_SIDEX_ROMVER = 2,0,8,0 %;   ! BOOT ROM VERSION
macro UV2$B_SIDEX_SYSCODE = 3,0,8,0 %;  ! SYSTEM CODE. 1=uVAX II
!  Interprocessor Communication Register
literal UV2$M_INTPR_IRQ = 1;
literal UV2$M_INTPR_LMEAE = 32;
literal UV2$M_INTPR_IE = 64;
literal UV2$M_INTPR_AUXHLT = 256;
literal UV2$M_INTPR_DMAQPE = 32768;
literal UV2$S_INTPR = 2;
macro UV2$V_INTPR_IRQ = 0,0,1,0 %;      ! INTERRUPT REQUEST
macro UV2$V_INTPR_FILL1 = 0,1,4,0 %;
literal UV2$S_INTPR_FILL1 = 4;          ! UNUSED
macro UV2$V_INTPR_LMEAE = 0,5,1,0 %;    ! LOCAL MEM EXT ACCESS ENABLE
macro UV2$V_INTPR_IE = 0,6,1,0 %;       ! INTERRUPT ENABLE
macro UV2$V_INTPR_FILL2 = 0,7,1,0 %;    ! UNUSED
macro UV2$V_INTPR_AUXHLT = 0,8,1,0 %;   ! AUXILIARY HALT
macro UV2$V_INTPR_FILL3 = 0,9,6,0 %;
literal UV2$S_INTPR_FILL3 = 6;          ! UNUSED
macro UV2$V_INTPR_DMAQPE = 0,15,1,0 %;  ! DMA QBUS PARITY ERROR
!  Boot and Diagnostic Configuration Register (BDR)
literal UV2$M_BDR_DSPL = 7;
literal UV2$M_BDR_BDG = 1536;
literal UV2$M_BDR_CPU = 6144;
literal UV2$M_BDR_HLT = 16384;
literal UV2$M_BDR_PWROK = 32768;
literal UV2$S_BDR = 2;
macro UV2$V_BDR_DSPL = 0,0,3,0 %;
literal UV2$S_BDR_DSPL = 3;             ! LED DISPLAY BITS
macro UV2$V_BDR_FILL1 = 0,3,6,0 %;
literal UV2$S_BDR_FILL1 = 6;            ! UNUSED
macro UV2$V_BDR_BDG = 0,9,2,0 %;
literal UV2$S_BDR_BDG = 2;              ! POWER-UP MODE CONTROL BITS
macro UV2$V_BDR_CPU = 0,11,2,0 %;
literal UV2$S_BDR_CPU = 2;              ! CPU NUMBER (0-3)
!   0 = ARBITER CPU
!   1 = AUX CPU NUMBER 1
!   2 = AUX CPU NUMBER 2
!   3 = AUX CPU NUMBER 3
macro UV2$V_BDR_FILL2 = 0,13,1,0 %;     ! UNUSED
macro UV2$V_BDR_HLT = 0,14,1,0 %;       ! HALT ENABLE
macro UV2$V_BDR_PWROK = 0,15,1,0 %;     ! 1 IF POWER IS STABLE
!  Memory System Error Register (MSER)
literal UV2$M_MSER_PARENB = 1;
literal UV2$M_MSER_WRWPAR = 2;
literal UV2$M_MSER_MSLEB = 8;
literal UV2$M_MSER_DMAQPE = 16;
literal UV2$M_MSER_CPUQPE = 32;
literal UV2$M_MSER_CPULPE = 64;
literal UV2$M_MSER_CPUNXM = 128;
literal UV2$M_MSER_MEMCD = 768;
literal UV2$S_MSER = 4;
macro UV2$V_MSER_PARENB = 0,0,1,0 %;    ! PARITY ENABLE
macro UV2$V_MSER_WRWPAR = 0,1,1,0 %;    ! WRITE WRONG PARITY
macro UV2$V_MSER_FILL1 = 0,2,1,0 %;     ! UNUSED
macro UV2$V_MSER_MSLEB = 0,3,1,0 %;     ! MEM SYS LOST ERROR BIT
macro UV2$V_MSER_DMAQPE = 0,4,1,0 %;    ! DMA QBUS ADR SP PARITY ERROR
macro UV2$V_MSER_CPUQPE = 0,5,1,0 %;    ! CPU QBUS ADR SP PARITY ERROR
macro UV2$V_MSER_CPULPE = 0,6,1,0 %;    ! CPU LOCAL ADR SP PARITY ERROR
macro UV2$V_MSER_CPUNXM = 0,7,1,0 %;    ! CPU NON-EXIST MEMORY
macro UV2$V_MSER_MEMCD = 0,8,2,0 %;
literal UV2$S_MSER_MEMCD = 2;           ! MEMORY CODE
!   00 = QBUS MEM OR DEV
!   01 = KDQ32 ON-BOARD MEM
!   10 = MEM EXPAN MODULE #1
!   11 = MEM EXPAN MODULE #2
macro UV2$V_MSER_FILL2 = 0,10,21,0 %;
literal UV2$S_MSER_FILL2 = 21;          ! UNUSED
!  CPU Error Address Register (CEAR)
literal UV2$S_CEAR = 4;
macro UV2$W_CEAR_ADR = 0,0,16,0 %;      ! LOCAL MEM ADR BITS <23:09>
macro UV2$W_CEAR_FILL1 = 2,0,16,0 %;    ! UNUSED, RETURNS AS 0
!  DMA Error Address Register (DEAR)
literal UV2$S_DEAR = 4;
macro UV2$W_DEAR_ADR = 0,0,16,0 %;      ! LOCAL MEM ADR BITS <23:09>
macro UV2$W_DEAR_FILL1 = 2,0,16,0 %;    ! UNUSED, RETURNS AS 0
!  Console Program Mailbox (CPMBX)
literal UV2$M_CPMBX_HLT = 3;
literal UV2$M_CPMBX_BIP = 4;
literal UV2$M_CPMBX_RIP = 8;
literal UV2$M_CPMBX_LNG = 240;
literal UV2$S_CPMBX = 2;
macro UV2$V_CPMBX_HLT = 0,0,2,0 %;
literal UV2$S_CPMBX_HLT = 2;            ! PROCESSOR HALT ACTION
!   0 = USE BDR<14> TO
!       DETERMINE ACTION
!   1 = RESTART, HALT
!   2 = REBOOT, HALT
!   3 = HALT
macro UV2$V_CPMBX_BIP = 0,2,1,0 %;      ! BOOT IN PROGRESS
macro UV2$V_CPMBX_RIP = 0,3,1,0 %;      ! RESTARTIN PROGRESS
macro UV2$V_CPMBX_LNG = 0,4,4,0 %;
literal UV2$S_CPMBX_LNG = 4;            ! CONSOLE TEXT LANGUAGE
!   0 = PROMPT FOR LANG
!   1 = GERMAN
!   2 = ENGLISH
!   3 = SPANISH
!   4 = FRENCH
!   5 = ITALIAN
!   6 = DANISH
!   7 = DUTCH
!   8 = FINNISH
!   9 = NORWEGIAN
!  10 = SWEDISH
macro UV2$V_CPMBX_FILL1 = 0,8,8,0 %;
literal UV2$S_CPMBX_FILL1 = 8;          ! UNUSED
!  Console Program Mailbox 2 Register(CPMBX2)
literal UV2$M_CPMBX2_QXSS = 32;
literal UV2$S_CPMBX2 = 2;
macro UV2$V_CPMBX2_FILL1 = 0,0,5,0 %;
literal UV2$S_CPMBX2_FILL1 = 5;         ! UNUSED
macro UV2$V_CPMBX2_QXSS = 0,5,1,0 %;    ! 1 IF QxSS=CONSOLE TERMINAL
macro UV2$V_CPMBX2_FILL2 = 0,6,10,0 %;
literal UV2$S_CPMBX2_FILL2 = 10;        ! UNUSED
 
!*** MODULE $TTYUCBDEF ***
! 
!   $TTYUCBDEF follows here only because there is no way to get the 
!   UCB$K_LENGTH symbol into another module. TTYUCBDEF was formerly
!   included in TTYDEF.MAR.
! 
!  TERMINAL DRIVER DEFINITIONS
! 
!  These definitions define the device dependent extensions of the UCB.
!  Certain portions of the ucb are assumed to be contiguous and must not
!  be split. These areas are documented in the following definitions.
! 
literal UCB$C_TL_LENGTH = 196;
literal UCB$K_TL_LENGTH = 196;
! 
literal TTY$M_ST_POWER = 1;
literal TTY$M_ST_CTRLS = 2;
literal TTY$M_ST_MODEM_OFF = 4;
literal TTY$M_ST_FILL = 8;
literal TTY$M_ST_CURSOR = 16;
literal TTY$M_ST_SENDLF = 32;
literal TTY$M_ST_BACKSPACE = 64;
literal TTY$M_ST_MULTI = 128;
literal TTY$M_ST_WRITE = 256;
literal TTY$M_ST_EOL = 512;
literal TTY$M_ST_EDITREAD = 1024;
literal TTY$M_ST_RDVERIFY = 2048;
literal TTY$M_ST_RECALL = 4096;
literal TTY$M_ST_READ = 8192;
literal TTY$M_ST_POSIXREAD = 16384;
literal TTY$M_ST_CTRLO = 1;
literal TTY$M_ST_DEL = 2;
literal TTY$M_ST_PASALL = 4;
literal TTY$M_ST_NOECHO = 8;
literal TTY$M_ST_WRTALL = 16;
literal TTY$M_ST_PROMPT = 32;
literal TTY$M_ST_NOFLTR = 64;
literal TTY$M_ST_ESC = 128;
literal TTY$M_ST_BADESC = 256;
literal TTY$M_ST_NL = 512;
literal TTY$M_ST_REFRSH = 1024;
literal TTY$M_ST_ESCAPE = 2048;
literal TTY$M_ST_TYPFUL = 4096;
literal TTY$M_ST_SKIPLF = 8192;
literal TTY$M_ST_ESC_O = 16384;
literal TTY$M_ST_WRAP = 32768;
literal TTY$M_ST_OVRFLO = 65536;
literal TTY$M_ST_AUTOP = 131072;
literal TTY$M_ST_CTRLR = 262144;
literal TTY$M_ST_SKIPCRLF = 524288;
literal TTY$M_ST_EDITING = 1048576;
literal TTY$M_ST_TABEXPAND = 2097152;
literal TTY$M_ST_QUOTING = 4194304;
literal TTY$M_ST_OVERSTRIKE = 8388608;
literal TTY$M_ST_TERMNORM = 16777216;
literal TTY$M_ST_ECHAES = 33554432;
literal TTY$M_ST_PRE = 67108864;
literal TTY$M_ST_NINTMULTI = 134217728;
literal TTY$M_ST_RECONNECT = 268435456;
literal TTY$M_ST_CTSLOW = 536870912;
literal TTY$M_ST_TABRIGHT = 1073741824;
literal UCB$M_TT_XXPARITY = 1;
literal UCB$M_TT_DISPARERR = 2;
literal UCB$M_TT_USERFRAME = 4;
literal UCB$M_TT_LEN = 24;
literal UCB$M_TT_STOP = 32;
literal UCB$M_TT_PARTY = 64;
literal UCB$M_TT_ODD = 128;
literal TTY$M_TANK_PREMPT = 256;
literal TTY$M_TANK_STOP = 512;
literal TTY$M_TANK_HOLD = 1024;
literal TTY$M_TANK_BURST = 2048;
literal TTY$M_TANK_DMA = 4096;
literal TTY$M_PC_NOTIME = 1;
literal TTY$M_PC_DMAENA = 2;
literal TTY$M_PC_DMAAVL = 4;
literal TTY$M_PC_PRMMAP = 8;
literal TTY$M_PC_MAPAVL = 16;
literal TTY$M_PC_XOFAVL = 32;
literal TTY$M_PC_XOFENA = 64;
literal TTY$M_PC_NOCRLF = 128;
literal TTY$M_PC_BREAK = 256;
literal TTY$M_PC_PORTFDT = 512;
literal TTY$M_PC_NOMODEM = 1024;
literal TTY$M_PC_NODISCONNECT = 2048;
literal TTY$M_PC_SMART_READ = 4096;
literal TTY$M_PC_ACCPORNAM = 8192;
literal TTY$M_PC_MULTISESSION = 32768;
literal UCB$M_TT_DSBL = 128;
literal UCB$C_TT_CLSLEN = 348;
literal UCB$K_TT_CLSLEN = 348;
literal TTY$M_TP_ABORT = 1;
literal TTY$M_TP_ALLOC = 2;
literal TTY$M_TP_DLLOC = 4;
literal UCB$C_TP_LENGTH = 356;
literal UCB$K_TP_LENGTH = 356;
literal UCB$C_TT_LENGTH = 356;
literal UCB$K_TT_LENGTH = 356;
!  TERMINAL DRIVER SX STATE TABLE
literal FLG$M_CTRLO = 1;
literal FLG$M_CANCTRLO = 2;
literal FLG$M_VAXTOVAX = 4;
literal FLG$M_CTRLC = 8;
literal FLG$M_INIT = 16;
literal FLG$M_RESET_TIMER = 32;
literal FLG$M_DECNET_BUSY = 64;
literal FLG$M_OUTPUT_BUSY = 128;
literal FLG$M_READ_BUSY = 256;
literal FLG$M_SENSE_BUSY = 512;
literal FLG$M_OOB_CHAR = 1024;
literal FLG$M_FLUSH_OUTPUT = 2048;
literal FLG$M_CLR_NOBRDCST = 4096;
literal FLG$M_READ_ABORT = 8192;
literal FLG$M_READ_ABORTED = 16384;
literal FLG$M_ISUPPORT = 32768;
literal FLG$M_PARTIAL_READ = 65536;
literal UCB$C_RTT_LENGTH = 332;         !  Length must be same for both RTTDRIVER
literal UCB$K_RTT_LENGTH = 332;         !  and CTDRIVER.
literal UCB$S_TTYUCBDEF = 364;
! 
!  Logical terminal UCB extension
! 
macro UCB$L_TL_CTRLY = 164,0,32,0 %;    !  CONTROL Y AST BLOCK LIST HEAD
macro UCB$L_TL_CTRLC = 168,0,32,0 %;    !  CONTROL C AST BLOCK LIST HEAD
macro UCB$L_TL_OUTBAND = 172,0,32,0 %;  !  OUT OF BAND CHARACTER MASK
macro UCB$L_TL_BANDQUE = 176,0,32,0 %;  !  OUT OF BAND AST QUEUE
macro UCB$L_TL_PHYUCB = 180,0,32,0 %;   !  THE PHYSICAL UCB ADDRESS
macro UCB$L_TL_CTLPID = 184,0,32,0 %;   !  CONTROLING PID (USED WITH SPAWN)
macro UCB$Q_TL_BRKTHRU = 188,0,0,0 %;
literal UCB$S_TL_BRKTHRU = 8;           !  FACILITY BROADCAST BITMASK
! 	TL_POSIX_DATA	longword unsigned; 	/* POSIX PTC POINTER
! 	TL_A_MODE_OVERLAY union fill;
! 	  TL_A_MODE	byte unsigned;		/* CURRENT ASIAN MODES
! 	  TL_A_CHARSET	longword unsigned;	/* CHARACTER SET BITMASK
! 	end TL_A_MODE_OVERLAY;
!  Terminal class driver dependant region
!  Split here between local and remote terminal UCB's
! 
macro UCB$R_TTYRTTUCB = 196,0,0,0 %;
literal UCB$S_TTYRTTUCB = 168;          !  local/remote union (overlay)
macro UCB$R_TTYUCB = 196,0,0,0 %;
literal UCB$S_TTYUCB = 168;             !  this structure defines remainder of local ucb
!  READ TIMEOUT CONTROL
macro UCB$L_TT_RDUE = 196,0,32,0 %;     !  ABSTIME WHEN READ TIMEOUT DUE
macro UCB$L_TT_RTIMOU = 200,0,32,0 %;   !  ADDRESS OF READ TIMEOUT ROUTINE
!  TERMINAL DRIVER STATE TABLE
!  (NOTE: Any changes made to this state table must also be made to
!         the SX state table.)
macro UCB$Q_TT_STATE = 204,0,0,0 %;
literal UCB$S_TT_STATE = 8;             !  CURRENT UNIT STATE VECTOR
macro UCB$L_TT_STATE1 = 204,0,32,0 %;
macro TTY$V_ST_POWER = 204,0,1,0 %;     ! 
macro TTY$V_ST_CTRLS = 204,1,1,0 %;     ! 
macro TTY$V_ST_MODEM_OFF = 204,2,1,0 %; ! 
macro TTY$V_ST_FILL = 204,3,1,0 %;      ! 
macro TTY$V_ST_CURSOR = 204,4,1,0 %;    ! 
macro TTY$V_ST_SENDLF = 204,5,1,0 %;    ! 
macro TTY$V_ST_BACKSPACE = 204,6,1,0 %; ! 
macro TTY$V_ST_MULTI = 204,7,1,0 %;     ! 
macro TTY$V_ST_WRITE = 204,8,1,0 %;
macro TTY$V_ST_EOL = 204,9,1,0 %;       ! 
macro TTY$V_ST_EDITREAD = 204,10,1,0 %; ! 
macro TTY$V_ST_RDVERIFY = 204,11,1,0 %; ! 
macro TTY$V_ST_RECALL = 204,12,1,0 %;   ! 
macro TTY$V_ST_READ = 204,13,1,0 %;     ! 
macro TTY$V_ST_POSIXREAD = 204,14,1,0 %; ! 
macro UCB$L_TT_STATE2 = 208,0,32,0 %;
macro TTY$V_ST_CTRLO = 208,0,1,0 %;     ! 
macro TTY$V_ST_DEL = 208,1,1,0 %;       ! 
macro TTY$V_ST_PASALL = 208,2,1,0 %;    ! 
macro TTY$V_ST_NOECHO = 208,3,1,0 %;    ! 
macro TTY$V_ST_WRTALL = 208,4,1,0 %;    ! 
macro TTY$V_ST_PROMPT = 208,5,1,0 %;    ! 
macro TTY$V_ST_NOFLTR = 208,6,1,0 %;    ! 
macro TTY$V_ST_ESC = 208,7,1,0 %;       ! 
macro TTY$V_ST_BADESC = 208,8,1,0 %;    ! 
macro TTY$V_ST_NL = 208,9,1,0 %;        ! 
macro TTY$V_ST_REFRSH = 208,10,1,0 %;   ! 
macro TTY$V_ST_ESCAPE = 208,11,1,0 %;   ! 
macro TTY$V_ST_TYPFUL = 208,12,1,0 %;   ! 
macro TTY$V_ST_SKIPLF = 208,13,1,0 %;   ! 
macro TTY$V_ST_ESC_O = 208,14,1,0 %;    ! 
macro TTY$V_ST_WRAP = 208,15,1,0 %;     ! 
macro TTY$V_ST_OVRFLO = 208,16,1,0 %;   ! 
macro TTY$V_ST_AUTOP = 208,17,1,0 %;    ! 
macro TTY$V_ST_CTRLR = 208,18,1,0 %;    ! 
macro TTY$V_ST_SKIPCRLF = 208,19,1,0 %; ! 
macro TTY$V_ST_EDITING = 208,20,1,0 %;  ! 
macro TTY$V_ST_TABEXPAND = 208,21,1,0 %; ! 
macro TTY$V_ST_QUOTING = 208,22,1,0 %;  ! 
macro TTY$V_ST_OVERSTRIKE = 208,23,1,0 %; ! 
macro TTY$V_ST_TERMNORM = 208,24,1,0 %; ! 
macro TTY$V_ST_ECHAES = 208,25,1,0 %;   ! 
macro TTY$V_ST_PRE = 208,26,1,0 %;      ! 
macro TTY$V_ST_NINTMULTI = 208,27,1,0 %; ! 
macro TTY$V_ST_RECONNECT = 208,28,1,0 %; ! 
macro TTY$V_ST_CTSLOW = 208,29,1,0 %;   ! 
macro TTY$V_ST_TABRIGHT = 208,30,1,0 %; ! 
macro UCB$L_TT_LOGUCB = 212,0,32,0 %;   !  ADDRESS OF THE LOGICAL UCB
!  DEFAULT CHARACTERISTICS
macro UCB$L_TT_DECHAR = 216,0,32,0 %;   !  DEFAULT DEVICE CHARACTERISTICS
macro UCB$L_TT_DECHA1 = 220,0,32,0 %;   !  DEFAULT DEVICE CHAR EXTENSIONS
macro UCB$L_TT_DECHA2 = 224,0,32,0 %;   !  MORE DEVICE CHARACTERISTICS
macro UCB$L_TT_DECHA3 = 228,0,32,0 %;   !  ANOTHER DEVICE CHAR EXTENSIONS
!  WRITE QUEUE POINTERS
macro UCB$L_TT_WFLINK = 232,0,32,0 %;   !  Write queue forward link.
macro UCB$L_TT_WBLINK = 236,0,32,0 %;   !  Write queue backward link.
macro UCB$L_TT_WRTBUF = 240,0,32,0 %;   !  Current write buffer block.
!  ADDRESS AND LENGTH OF MULTI-ECHO STRING
macro UCB$L_TT_MULTI = 244,0,32,0 %;    !  CURRENT MULTIECHO BUFFER ADDRESS
macro UCB$W_TT_MULTILEN = 248,0,16,0 %; !  LENGTH OF STRING TO OUTPUT
macro UCB$W_TT_SMLTLEN = 250,0,16,0 %;  !  SAVED MULTI LENGTH
macro UCB$L_TT_SMLT = 252,0,32,0 %;     !  AND THE SAVED ADDRESS
! -- **********************************************************************
!  DEFAULT SPEED, FILL ,PARITY (MUST BE CONTIGUOUS)
! ++ *******************************************************************
macro UCB$W_TT_DESPEE = 256,0,16,0 %;   !  DEFAULT SPEED
macro UCB$B_TT_DECRF = 258,0,8,0 %;     !  DEFAULT CR FILL
macro UCB$B_TT_DELFF = 259,0,8,0 %;     !  DEFAULT LF FILL
macro UCB$B_TT_DEPARI = 260,0,8,0 %;    !  DEFAULT PARITY/CHAR SIZE
macro UCB$B_TT_DEFSPE_SPARE1 = 261,0,8,0 %;
macro UCB$W_TT_DEFSPE_SPARE2 = 262,0,16,0 %;
! -- **********************************************************************
! 
!  DEFAULT TERMINAL TYPE AND SIZE (MUST BE CONTIGUOUS)
! 
! ++  ***********************************************************************
macro UCB$B_TT_DETYPE = 264,0,8,0 %;    !  DEFAULT TERMINAL TYPE
macro UCB$W_TT_DESIZE = 265,0,16,0 %;   !  DEFAULT LINE SIZE
macro UCB$B_TT_SPARE1 = 267,0,8,0 %;    !  SPARE BYTE MUST FOLLOW
! -- **********************************************************************
!  SPEED, FILL, PARITY (MUST BE CONTIGUOUS)
! ++ *****************************************************************
macro UCB$W_TT_SPEED = 268,0,16,0 %;    !  SPEED CODES (SPLIT SPEED)
macro UCB$B_TT_TSPEED = 268,0,8,0 %;    !  TRANSMIT SPEED
macro UCB$B_TT_RSPEED = 269,0,8,0 %;    !  RECEIVE SPEED
macro UCB$B_TT_CRFILL = 270,0,8,0 %;    !  NUMBER FILLS TO OUTPUT ON CR
macro UCB$B_TT_LFFILL = 271,0,8,0 %;    !  NUMBER FILLS TO OUTPUT ON LF
macro UCB$B_TT_PARITY = 272,0,8,0 %;    !  PARITY AND CHARACTER SIZE DEFINITIONS
macro UCB$V_TT_XXPARITY = 272,0,1,0 %;  !  UNUSED ??
macro UCB$V_TT_DISPARERR = 272,1,1,0 %; !  SPECIFY DISREGARD PARITY ERRORS
macro UCB$V_TT_USERFRAME = 272,2,1,0 %; !  SPECIFY USER FRAME SETUP
macro UCB$V_TT_LEN = 272,3,2,0 %;
literal UCB$S_TT_LEN = 2;               !  CHARACTER LENGTH
macro UCB$V_TT_STOP = 272,5,1,0 %;      !  STOP BITS
macro UCB$V_TT_PARTY = 272,6,1,0 %;     !  PARITY ENABLED
macro UCB$V_TT_ODD = 272,7,1,0 %;       !  ODD PARITY
macro UCB$B_TT_PAR_SPARE1 = 273,0,8,0 %;
macro UCB$W_TT_PAR_SPARE2 = 274,0,16,0 %;
! -- ******************************************************************
!  Typeahead buffer address
macro UCB$L_TT_TYPAHD = 276,0,32,0 %;   !  TYPEAHEAD BUFFER ADDRESS
!  CURRENT CURSOR AND LINE POSITION FOR FORMATTED OPERATIONS
macro UCB$W_TT_CURSOR = 280,0,16,0 %;   !  CURRENT CURSOR POSITION
macro UCB$B_TT_LINE = 282,0,8,0 %;      !  CURRENT LINE ON PAGE
macro UCB$B_TT_LASTC = 283,0,8,0 %;     !  LAST FORMATTED OUTPUT CHARACTER
!  Number of back spaces to output for non-ansi terminals
macro UCB$W_TT_BSPLEN = 284,0,16,0 %;   !  NUMBER OF BACKSPACES
!  FILL HANDLING
macro UCB$B_TT_FILL = 286,0,8,0 %;      !  CURRENT FILL COUNT
!  ESCAPE SYNTAX RULE STATE.
macro UCB$B_TT_ESC = 287,0,8,0 %;       !  CURRENT  READ ESCAPE SYNTAX STATE
macro UCB$B_TT_ESC_O = 288,0,8,0 %;     !  OUPUT ESCAPE STATE
!  Count of characters in interrupt string
macro UCB$B_TT_INTCNT = 289,0,8,0 %;
!  Bit used for modem control
macro UCB$W_TT_UNITBIT = 290,0,16,0 %;  !  BIT USED TO ENABLE AND DISABLE MODEM CONTROL.
!  PORT SPECIFIC OUTPUT CONTROL
macro UCB$W_TT_HOLD = 292,0,16,0 %;     !  UNIT HOLDING TANK AND PORT DISPATCH
macro TTY$B_TANK_CHAR = 292,0,8,0 %;    !  CHARACTER
macro TTY$V_TANK_PREMPT = 292,8,1,0 %;  !  SEND PREMPT CHARACTER
macro TTY$V_TANK_STOP = 292,9,1,0 %;    !  STOP OUTPUT
macro TTY$V_TANK_HOLD = 292,10,1,0 %;   !  CHAR IN TANK
macro TTY$V_TANK_BURST = 292,11,1,0 %;  !  BURST ACTIVE
macro TTY$V_TANK_DMA = 292,12,1,0 %;    !  DMA ACTIVE **** SHOULD MOVE BEFORE BURST ****
macro UCB$B_TT_PREMPT = 294,0,8,0 %;    !  THE BYTE USED TO PREMPT INPUT
macro UCB$B_TT_OUTYPE = 295,0,8,0 %;    !  TYPE OF OUTPUT THAT THIS CALL
!  CLASS & PORT VECTOR POINTERS
macro UCB$L_TT_GETNXT = 296,0,32,0 %;   !  ADDRESS OF CLASS INPUT ROUTINE
macro UCB$L_TT_PUTNXT = 300,0,32,0 %;   !  ADDRESS OF CLASS OUTPUT ROUTINE
macro UCB$L_TT_CLASS = 304,0,32,0 %;    !  ADDRESS OF CLASS VECTOR
macro UCB$L_TT_PORT = 308,0,32,0 %;     !  ADDRESS OF PORT VECTOR
macro UCB$L_TT_OUTADR = 312,0,32,0 %;   !  ADDRESS OF OUTPUT  CURRENT STREAM
macro UCB$W_TT_OUTLEN = 316,0,16,0 %;   !  LENGTH OF OUTPUT STREAM
macro UCB$W_TT_PRTCTL = 318,0,16,0 %;   !  THE PORT DRIVER CONTROL WORD
macro TTY$V_PC_NOTIME = 318,0,1,0 %;    !  IF SET NO TIMEOUT WILL BE CALCULATED
macro TTY$V_PC_DMAENA = 318,1,1,0 %;    !  DMA CURRENTLY ENABLED 
macro TTY$V_PC_DMAAVL = 318,2,1,0 %;    !  DMA SUPPORTED ON THIS PORT
macro TTY$V_PC_PRMMAP = 318,3,1,0 %;    !  UNIT CAN HAVE PERMANENT MAP REGISTERS
macro TTY$V_PC_MAPAVL = 318,4,1,0 %;    !  MAP REGISTER CURRENTLY ALLOCATED
macro TTY$V_PC_XOFAVL = 318,5,1,0 %;    !  AUTO XOFF SUPPORTED ON THIS PORT
macro TTY$V_PC_XOFENA = 318,6,1,0 %;    !  AUTO XOFF CURRENTLY ENABLED 
macro TTY$V_PC_NOCRLF = 318,7,1,0 %;    !  don't do free linefeed after creturn
macro TTY$V_PC_BREAK = 318,8,1,0 %;     !  TURN ON OR OFF BREAK
macro TTY$V_PC_PORTFDT = 318,9,1,0 %;   !  PORT CONTAINS FDT ROUTINE
macro TTY$V_PC_NOMODEM = 318,10,1,0 %;  !  Port cannot support modem operations
macro TTY$V_PC_NODISCONNECT = 318,11,1,0 %; !  Device cannot support virtual terminal operations
macro TTY$V_PC_SMART_READ = 318,12,1,0 %; !  Port contains additional read capabilities
macro TTY$V_PC_ACCPORNAM = 318,13,1,0 %; !  Port supports access port name
macro TTY$V_PC_MULTISESSION = 318,15,1,0 %; !  part of multi-session terminal
!  MODEM CONTROL DEFINITIONS
macro UCB$B_TT_DS_RCV = 320,0,8,0 %;    !  CURRENT RECEIVE MODEM
macro UCB$B_TT_DS_TX = 321,0,8,0 %;     !  CURRENT TRANSMIT MODEM
macro UCB$W_TT_DS_ST = 322,0,16,0 %;    !  CURRENT MODEM STATE
macro UCB$W_TT_DS_TIM = 324,0,16,0 %;   !  CURRENT MODEM TIMEOUT
macro UCB$B_TT_MAINT = 326,0,8,0 %;     !  MAINTENANCE PARAMETERS
macro UCB$V_TT_MAINT_FILL = 326,0,7,0 %;
literal UCB$S_TT_MAINT_FILL = 7;
macro UCB$V_TT_DSBL = 326,7,1,0 %;      !  LINE DISABLED
macro UCB$B_TT_OLDCPZORG = 327,0,8,0 %; !  spare byte make this longword alligned
macro UCB$L_TT_FBK = 328,0,32,0 %;      !  PTR TO FALLBACK BLOCK
macro UCB$L_TT_RDVERIFY = 332,0,32,0 %; !  PTR TO READ/VERIFY TABLE
!  can be extended
macro UCB$L_TT_CLASS1 = 336,0,32,0 %;   !  CLASS DRIVER LONGWORD
macro UCB$B_TT_A_CHAR = 336,0,8,0 %;    !  Default Asian modes
macro UCB$L_TT_A_DECHSET = 336,0,32,0 %; !  Default char set bitmask
macro UCB$L_TT_CLASS2 = 340,0,32,0 %;   !   AND ANOTHER ONE
macro UCB$L_TT_ACCPORNAM = 344,0,32,0 %; !  Address of counted string describing the port 
!  typicall LAT server name / and port name or number
! *****************************************************************************
! 
!  Asian VMS extension
! 
! ++ **************************************************************************
! 
! 	TT_A_GCBADR	longword unsigned;	/* Glyph Control Block address
! 	TT_A_EDSTS	word unsigned;		/* Multi-byte line edit states
! 	TT_A_STATE	byte unsigned;		/* On-demand loading states
! 	TT_A_PARSE	byte unsigned;		/* ODL parse states
! 	TT_A_TRANS	byte unsigned;		/* JIS conversion states
! 	TT_A_XEDSTS	byte unsigned;		/* Extended line edit states
! 	TT_A_RESRV1	word unsigned;		/* Reserved
! 	TT_A_CHAR_OVERLAY union fill;
! 	  TT_A_CHAR	byte unsigned;		/* Default Asian modes
! 	  TT_A_DECHSET	longword unsigned;	/* Default char set bitmask
! 	end TT_A_CHAR_OVERLAY;
! -- **************************************************************************
!  For FTUCBDEF
! ****************************************************************
! 
!  Terminal Port driver dependant extension region
macro UCB$L_TP_MAP = 348,0,32,0 %;      !  UNIBUS MAP REGISTERS
macro UCB$B_TP_STAT = 352,0,8,0 %;      !  DMA PORT SPECIFIC STATUS
macro TTY$V_TP_ABORT = 352,0,1,0 %;     !  DMA ABORT REQUESTED ON THIS LINE
macro TTY$V_TP_ALLOC = 352,1,1,0 %;     !  ALLOC MAP FORK IN PROGRESS
macro TTY$V_TP_DLLOC = 352,2,1,0 %;     !  DEALLOCATE MAP FORK IN PROGRESS
macro UCB$B_TP_SPARE1 = 353,0,8,0 %;
macro UCB$W_TP_SPARE2 = 354,0,16,0 %;
!  (NOTE: Any changes made to this state table must also be made to
!         the ST state table.)
macro UCB$R_TT_STATE_SX = 356,0,0,0 %;
literal TTY$S_TT_STATE_SX = 8;
macro TTY$V_SX_POWER = 356,0,1,0 %;     ! 	
macro TTY$V_SX_CTRLS = 356,1,1,0 %;     ! 
macro TTY$V_SX_MODEM_OFF = 356,2,1,0 %; ! 
macro TTY$V_SX_FILL = 356,3,1,0 %;      ! 
macro TTY$V_SX_CURSOR = 356,4,1,0 %;    ! 
macro TTY$V_SX_SENDLF = 356,5,1,0 %;    ! 
macro TTY$V_SX_BACKSPACE = 356,6,1,0 %; !  OUTPUT BACKSPACES FOR SEVERAL LOOPS
macro TTY$V_SX_MULTI = 356,7,1,0 %;     ! 
macro TTY$V_SX_WRITE = 356,8,1,0 %;     !  Write state
macro TTY$V_SX_EOL = 356,9,1,0 %;       ! 
macro TTY$V_SX_EDITREAD = 356,10,1,0 %; ! 
macro TTY$V_SX_RDVERIFY = 356,11,1,0 %; ! 
macro TTY$V_SX_RECALL = 356,12,1,0 %;   ! 
macro TTY$V_SX_READ = 356,13,1,0 %;     ! 
macro TTY$V_SX_POSIXREAD = 356,14,1,0 %; ! 
macro TTY$V_SX_FILLBITS = 356,15,17,0 %;
literal TTY$S_SX_FILLBITS = 17;         !  END OF FIRST LONGWORD
macro TTY$V_SX_CTRLO = 360,0,1,0 %;     ! 
macro TTY$V_SX_DEL = 360,1,1,0 %;       ! 
macro TTY$V_SX_PASALL = 360,2,1,0 %;    ! 
macro TTY$V_SX_NOECHO = 360,3,1,0 %;    ! 
macro TTY$V_SX_WRTALL = 360,4,1,0 %;    ! 
macro TTY$V_SX_PROMPT = 360,5,1,0 %;    ! 
macro TTY$V_SX_NOFLTR = 360,6,1,0 %;    ! 
macro TTY$V_SX_ESC = 360,7,1,0 %;       ! 
macro TTY$V_SX_BADESC = 360,8,1,0 %;    ! 
macro TTY$V_SX_NL = 360,9,1,0 %;        !  New line must directly precede
macro TTY$V_SX_REFRSH = 360,10,1,0 %;   !  refresh, or all breaks.
macro TTY$V_SX_ESCAPE = 360,11,1,0 %;   ! 
macro TTY$V_SX_TYPFUL = 360,12,1,0 %;   ! 
macro TTY$V_SX_SKIPLF = 360,13,1,0 %;   ! 
macro TTY$V_SX_ESC_O = 360,14,1,0 %;    ! 
macro TTY$V_SX_WRAP = 360,15,1,0 %;     ! 
macro TTY$V_SX_OVRFLO = 360,16,1,0 %;   ! 
macro TTY$V_SX_AUTOP = 360,17,1,0 %;    ! 
macro TTY$V_SX_CTRLR = 360,18,1,0 %;    ! 
macro TTY$V_SX_SKIPCRLF = 360,19,1,0 %; ! 
macro TTY$V_SX_EDITING = 360,20,1,0 %;  ! 
macro TTY$V_SX_TABEXPAND = 360,21,1,0 %; ! 
macro TTY$V_SX_QUOTING = 360,22,1,0 %;  ! 
macro TTY$V_SX_OVERSTRIKE = 360,23,1,0 %; ! 
macro TTY$V_SX_TERMNORM = 360,24,1,0 %; ! 
macro TTY$V_SX_ECHAES = 360,25,1,0 %;   ! 
macro TTY$V_SX_PRE = 360,26,1,0 %;      ! 
macro TTY$V_SX_NINTMULTI = 360,27,1,0 %; ! 
macro TTY$V_SX_RECONNECT = 360,28,1,0 %; ! 
macro TTY$V_SX_CTSLOW = 360,29,1,0 %;   ! 
macro TTY$V_SX_TABRIGHT = 360,30,1,0 %; ! 
!  remote terminal extension
macro UCB$R_RTTUCB = 196,0,0,0 %;
literal UCB$S_RTTUCB = 136;
macro UCB$L_RTT_NETUCB = 196,0,32,0 %;  !  NET DEVICE UCB
macro UCB$L_RTT_NETWIND = 200,0,32,0 %; !  NET DEVICE WCB
macro UCB$L_RTT_IRPFL = 204,0,32,0 %;   !  IRP QUEUE
macro UCB$L_RTT_IRPBL = 208,0,32,0 %;   !  IRP QUEUE
macro UCB$L_RTT_NETIRP = 212,0,32,0 %;  !  READ NET IIRP
macro UCB$L_RTT_BANDINCL = 216,0,32,0 %; !  OUT OF BAND INCLUDES
macro UCB$L_RTT_BANDINMSK = 220,0,32,0 %; !  OUT OF BAND INCLUDE MASK
macro UCB$L_RTT_BANDEXCL = 224,0,32,0 %; !  out of band exclude mask
macro UCB$L_RTT_BANDEXMSK = 228,0,32,0 %; !  out of band exclude
macro UCB$B_RTT_PROVRS = 232,0,8,0 %;   !  PROTOCOL VERSION
macro UCB$B_RTT_PROECO = 233,0,8,0 %;   !  PROTOCOL ECO
macro UCB$W_RTT_LINK = 234,0,16,0 %;    !  LINK NUMBER (for LOGINOUT)
macro UCB$B_RTT_OBJ = 236,0,8,0 %;      !  OBJECT NUMBER CONNECTED
macro UCB$W_RTT_SYSTYPE = 237,0,16,0 %; !  SYSTEM TYPE (VMS=7)
macro UCB$B_RTT_FILLBYTE = 239,0,8,0 %; !  fill - use when convenient
! 	CTERM driver only
macro UCB$L_CT_FLAGS = 240,0,32,0 %;    !  MISC FLAGS
macro FLG$V_CTRLO = 240,0,1,0 %;        !  CTRLO IN PROGRESS
macro FLG$V_CANCTRLO = 240,1,1,0 %;     !  CANCEL CTRLO ON WRITE
macro FLG$V_VAXTOVAX = 240,2,1,0 %;     !  VAX TO VAX
macro FLG$V_CTRLC = 240,3,1,0 %;        !  CTRL/C DELIVERED
macro FLG$V_INIT = 240,4,1,0 %;         !  AWAITING FIRST WRITE
macro FLG$V_RESET_TIMER = 240,5,1,0 %;  !  Restart timer due to write.
macro FLG$V_DECNET_BUSY = 240,6,1,0 %;  !  DECnet Output task busy.
macro FLG$V_OUTPUT_BUSY = 240,7,1,0 %;  !  Output task busy.
macro FLG$V_READ_BUSY = 240,8,1,0 %;    !  Read task busy.
macro FLG$V_SENSE_BUSY = 240,9,1,0 %;   !  Sense task busy.
macro FLG$V_OOB_CHAR = 240,10,1,0 %;    !  Process OOB character later.
macro FLG$V_FLUSH_OUTPUT = 240,11,1,0 %; !  Flush output for out-of-band abort.
macro FLG$V_CLR_NOBRDCST = 240,12,1,0 %; !  Don't broadcast until after first write.
macro FLG$V_READ_ABORT = 240,13,1,0 %;  !  Read abort in progress.
macro FLG$V_READ_ABORTED = 240,14,1,0 %; !  Read has already been aborted.
macro FLG$V_ISUPPORT = 240,15,1,0 %;    !  Support of ISUPPORT msg
macro FLG$V_PARTIAL_READ = 240,16,1,0 %; !  Partial read in progress
macro UCB$L_CT_WIIRP = 244,0,32,0 %;    !  WRITE IIRP
macro UCB$L_CT_TQE = 248,0,32,0 %;      !  TQE ADDRESS
macro UCB$L_CT_NETQFL = 252,0,32,0 %;   !  Queue of DCB's waiting 
macro UCB$L_CT_NETQBL = 256,0,32,0 %;   !    for write IRP
macro UCB$L_CT_SENSEQFL = 260,0,32,0 %; !  Queue for pending 
macro UCB$L_CT_SENSEQBL = 264,0,32,0 %; !    IO$_SENSExxxx IRPs.
macro UCB$L_CT_READQFL = 268,0,32,0 %;  !  Queue for pending
macro UCB$L_CT_READQBL = 272,0,32,0 %;  !    read IRPs.
macro UCB$L_CT_WRTDCB = 276,0,32,0 %;   !  First DCB in current write chain.
macro UCB$L_CT_CURDCB = 280,0,32,0 %;   !  Last DCB added to write chain.
macro UCB$W_CT_REMSIZ = 284,0,16,0 %;   !  Remaining size in message.
macro UCB$W_CT_QDCBCNT = 286,0,16,1 %;  !  Number of queued DCBs.
macro UCB$W_CT_MAXMSG = 288,0,16,0 %;   !  MAX WRITE TO NET SIZE
macro UCB$W_CT_MAXREAD = 290,0,16,0 %;  !  MAX READ IN SERVER
macro UCB$L_CT_LEGALMSG = 292,0,32,0 %; !  LEGAL MESSAGE MASK
macro UCB$B_CT_VERSION = 296,0,8,0 %;   !  CTERM VERSION
macro UCB$B_CT_ECO = 297,0,8,0 %;       !  CTERM ECO
macro UCB$W_CT_SPEED = 298,0,16,0 %;    !  SPEED 
macro UCB$B_CT_CRFILL = 300,0,8,0 %;    !  CR FILL
macro UCB$B_CT_LFFILL = 301,0,8,0 %;    !  LF FILL
macro UCB$W_CT_PARITY = 302,0,16,0 %;   !  CTERM PARITY
macro UCB$L_CT_INCLUDE = 304,0,32,0 %;  !  INCLUDE OUT-OF-BAND CHARACTER MASK
macro UCB$L_CT_EXCLUDE = 308,0,32,0 %;  !  EXCLUDE OUT-OF-BAND CHARACTER MASK
macro UCB$L_CT_ABORT = 312,0,32,0 %;    !  ABORT OUT-OF-BAND CHARACTER MASK
macro UCB$B_CT_OOB_CHAR = 316,0,8,0 %;  !  Received out of band character.
macro UCB$B_CT_FILL_BYTE = 317,0,8,0 %; !  fill
macro UCB$W_CT_PRTCTL = 318,0,16,0 %;   !  Same as UCB$W_TT_PRTCTL
macro UCB$Q_CT_ISUPPORT = 320,0,0,0 %;
literal UCB$S_CT_ISUPPORT = 8;          !  Messages supported
macro UCB$L_CT_FILL_LONGWORD = 328,0,32,0 %; !  fill
!  end union
 
!*** MODULE $FTUCBDEF ***
! 
! 	$FTUCBDEF follows here only because there is no way to get the  the
!  UCB$K_TT_LENGTH into another module.
! 
! 	Pseudo Terminal Driver definitions
! 
! 	These definitions define the device dependent extenstions of the TTYUCB. 
!  Certain portions of the UCB are assumed to be contigious and must not be
!  split.  The AST list heads are order and must remain in order $PTDDEF in
!  STARDEFMP.SDL is in the same order.
! 
literal UCB$M_FT_BSY = 1;
literal UCB$M_FT_DELPEND = 2;
literal UCB$M_FT_DELETE_ACT = 4;
literal UCB$M_FT_INPUT_CRIT = 8;
literal UCB$C_FT_LENGTH = 432;          !  Size of FT UCB
literal UCB$K_FT_LENGTH = 432;          !   "   "   "  "
literal UCB$S_FTUCBDEF = 432;
macro UCB$L_FT_IPID = 348,0,32,0 %;     !  Interal PID of UCB control process
macro UCB$L_FT_1ST_PAGE = 352,0,32,0 %; !  P0/P1 address of first page of I/O buffer
macro UCB$L_FT_LST_PAGE = 356,0,32,0 %; !  P0/P1 address of end of the I/O buffer
macro UCB$L_FT_S0_PAGE = 360,0,32,0 %;  !  S0 address of first page that maps I/O buffer
macro UCB$Q_FT_BUFFER_HANDLE = 364,0,0,0 %;
literal UCB$S_FT_BUFFER_HANDLE = 8;     !  Pointer to buffer handle used by buffer object code
! 
!  Driver private state information
! 
macro UCB$W_FT_STS = 372,0,16,0 %;      !  Driver private status word
macro UCB$V_FT_BSY = 372,0,1,0 %;       !  Read request pending
macro UCB$V_FT_DELPEND = 372,1,1,0 %;   !  It is safe to queue deletion fork
macro UCB$V_FT_DELETE_ACT = 372,2,1,0 %; !  Deletion fork queued
macro UCB$V_FT_INPUT_CRIT = 372,3,1,0 %; !  Type ahead buffer running out or out of space
macro UCB$W_FT_CHAN = 374,0,16,0 %;     !  Control applications channel number
macro UCB$L_FT_READQFL = 376,0,32,0 %;  !  Read requests queue forward link
macro UCB$L_FT_READQBL = 380,0,32,0 %;  !  Read requests queue backward link
macro UCB$L_FT_CURR_READ = 384,0,32,0 %; !  Currend read request packet address
! 
!  AST list head this must remain in order and should not be changed.
! 
!  The AST list head is overlaid and becomes the fork block used to delete the
!  UCB when the control connection deassigns it's channel.  This is safe becuase
!  once the control connection channel is deleted it is impossible to enable one
!  of these ASTs.
! 
macro UCB$R_FT_DELETE_FORK = 388,0,0,0 %;
literal UCB$S_FT_DELETE_FORK = 44;
macro UCB$R_FTUCB = 388,0,0,0 %;
literal UCB$S_FTUCB = 44;
macro UCB$L_FT_HANGUP_AST = 388,0,32,0 %; !  Address of hangup template ACB
macro UCB$L_FT_XON_AST = 392,0,32,0 %;  !  Address of XON template ACB
macro UCB$L_FT_BELL_AST = 396,0,32,0 %; !  Address of BELL template ACB
macro UCB$L_FT_DC3_AST = 400,0,32,0 %;  !  Address of DC3 template ACB
macro UCB$L_FT_STOP_AST = 404,0,32,0 %; !  Address of stop output template ACB
macro UCB$L_FT_RESUME_AST = 408,0,32,0 %; !  Address of resume output template ACB
macro UCB$L_FT_SET_AST = 412,0,32,0 %;  !  Address of changed characteristics template ACB
macro UCB$L_FT_ABORT_AST = 416,0,32,0 %; !  Address of abort output template ACB
macro UCB$L_FT_START_READ_AST = 420,0,32,0 %; !  Address of start read template ACB
macro UCB$L_FT_MIDDLE_READ_AST = 424,0,32,0 %; !  Address of middle read template ACB
macro UCB$L_FT_END_READ_AST = 428,0,32,0 %; !  Address of end read template ACB
macro UCB$R_FT_FORK_OVERLAY = 388,0,0,0 %;
macro UCB$L_FT_FQFL = 388,0,32,0 %;     !  Fork queue forward link
macro UCB$L_FT_FQBL = 392,0,32,0 %;     !  Fork queue backward link
macro UCB$W_FT_FRKSIZE = 396,0,16,0 %;  !  Size of the fork block
macro UCB$B_FT_FRK_TYPE = 398,0,8,0 %;  !  Type of structure
macro UCB$B_FT_FLCK = 399,0,8,0 %;      !  Fork lock index
macro UCB$L_FT_FPC = 400,0,32,0 %;      !  Fork PC this points device deletion routine
macro UCB$L_FT_FR3 = 404,0,32,0 %;      !  R3 will be 0
macro UCB$L_FT_FR4 = 408,0,32,0 %;      !  UCB address
!  End Union
 
!*** MODULE $UQBDEF ***
! +
!  UQB  (Unit Queue Block)  Definitions -- MSCP Server, TMSCP Server
! -
literal UQB$M_SEQ = 1;
literal UQB$M_WRTPH = 2;
literal UQB$M_WRTPS = 4;
literal UQB$M_ONLINE = 8;
literal UQB$M_FLUSH = 16;
literal UQB$M_C = 31;
literal UQB$M_D1 = 992;
literal UQB$M_D0 = 31744;
literal UQB$K_ST_ONLINE = 2;            !   Unit is online to some host
literal UQB$K_ST_OFFLINE = 3;           !   Unit is offline
literal UQB$K_ST_AVAILABLE = 4;         !   Unit is available
literal UQB$S_GENERIC_UQBDEF = 112;
macro UQB$L_FLINK = 0,0,32,0 %;         !  Used to link together all
macro UQB$L_BLINK = 4,0,32,0 %;         !    UQBs being served 
macro UQB$W_SIZE = 8,0,16,0 %;          !  Structure size in bytes
macro UQB$B_TYPE = 10,0,8,0 %;          !  MSCP type structure
macro UQB$B_SUBTYPE = 11,0,8,0 %;       !   with a UQB subtype       (5)
macro UQB$W_STATE = 12,0,16,0 %;        !  Current state of this unit
macro UQB$W_FLAGS = 14,0,16,0 %;        !  Unit usage
macro UQB$V_SEQ = 14,0,1,0 %;           !  Sequential command executing
macro UQB$V_WRTPH = 14,1,1,0 %;         !  Unit is writelocked
macro UQB$V_WRTPS = 14,2,1,0 %;         !  Unit was mounted /NOWRITE
macro UQB$V_ONLINE = 14,3,1,0 %;        !  Unit is ONLINE.
macro UQB$V_FLUSH = 14,4,1,0 %;         !  Per-unit cache is being flushed	
macro UQB$W_OLD_UNIT = 16,0,16,0 %;     !  "Old Style" unit number
macro UQB$W_CURRENT = 18,0,16,0 %;      !  Commands active on this unit
macro UQB$W_MULT_UNIT = 20,0,16,0 %;    !  This information is set up
macro UQB$W_UNIT_FLAGS = 22,0,16,0 %;   !   in ADDUNIT when the device
macro UQB$Q_UNIT_ID = 24,0,0,0 %;
literal UQB$S_UNIT_ID = 8;              !   is set /SERVED.
macro UQB$L_ALLOCLS = 24,0,32,0 %;      !  The unit identifier is made up 
macro UQB$W_UNIT = 28,0,16,0 %;         !   of the allocation class, the 
macro UQB$W_DEVNAME = 30,0,16,0 %;      !   
macro UQB$V_C = 30,0,5,0 %;
literal UQB$S_C = 5;                    !   UCB unit number, the controller 
macro UQB$V_D1 = 30,5,5,0 %;
literal UQB$S_D1 = 5;                   !   letter, and the D1 D0 fields 
macro UQB$V_D0 = 30,10,5,0 %;
literal UQB$S_D0 = 5;                   !   from the media ID field
macro UQB$l_reserved = 32,0,32,0 %;     !   
macro UQB$L_UCB = 36,0,32,0 %;          !  UCB address for this unit
macro UQB$W_NUM_QUE = 40,0,16,0 %;      !  Host requests pending
macro UQB$W_MAX_QUE = 42,0,16,0 %;      !  Most requests ever pending
macro UQB$L_BLOCKED_FL = 44,0,32,0 %;   !  List head for HRBs pending
macro UQB$L_BLOCKED_BL = 48,0,32,0 %;   !   sequential cmd completion
macro UQB$B_ONLINE = 52,0,0,0 %;
literal UQB$S_ONLINE = 32;              !  Array of hosts with unit online 
macro UQB$L_EXTRA_IO = 84,0,32,0 %;     !  Splinter requests
macro UQB$L_IOCNT = 88,0,32,0 %;        !  Server contribution to total
macro UQB$W_QLEN = 92,0,16,0 %;         !  Server queue length for unit
macro UQB$W_SLUN = 94,0,16,0 %;         !  Server local unit number
!  max chars in Cluster unique
!    device name ( dependency in
!    PEDRIVER's PEM_DEF.SDL)
macro UQB$B_UNIQUE_DNAME_CNT = 96,0,8,0 %; !  .ASCIC string with
macro UQB$T_UNIQUE_DNAME = 97,0,0,0 %;
literal UQB$S_UNIQUE_DNAME = 15;        !   Cluster unique name for disk
!   unit (obtained VIA GETDVI
!   ALLDEVNAM item)
!  Unit state definitions
literal UQB$M_ST_BOT = 1;
literal UQB$M_ST_DLS = 2;
literal UQB$M_ST_EOT = 4;
literal UQB$M_ST_LEOT = 8;
literal UQB$M_ST_PLS = 16;
literal UQB$M_ST_SEREX = 32;
literal UQB$M_ST_WRTPH = 64;
literal UQB$S_TSRV_EXTENSION = 202;
macro UQB$L_ONLINE_HQB = 112,0,32,0 %;  !  Unit is excl. onl. to this host.
macro UQB$L_MEMW_TOT = 116,0,32,0 %;    !  Number of I/Os that had to wait.
macro UQB$L_MEMW_FL = 120,0,32,0 %;     !  Queue listhead for requests
macro UQB$L_MEMW_BL = 124,0,32,0 %;     !   in memory wait state.
macro UQB$W_MEMW_CNT = 128,0,16,0 %;    !  Current memory stalls.
macro UQB$W_MEMW_MAX = 130,0,16,0 %;    !  Most requests ever in MEMWAIT
macro UQB$L_CACHE_FL = 132,0,32,0 %;    !  Queue listhead for requests
macro UQB$L_CACHE_BL = 136,0,32,0 %;    !   in server cache.
macro UQB$W_NUM_CACHE = 140,0,16,0 %;   !  Number of requests in cache.
macro UQB$W_MAX_CACHE = 142,0,16,0 %;   !  Max ever cached
macro UQB$L_FREELIST_FL = 144,0,32,0 %; !  Queue listhead for available
macro UQB$L_FREELIST_BL = 148,0,32,0 %; !   local buffers
macro UQB$W_BUFF_AVAIL = 152,0,16,0 %;  !  Number of free buffers
macro UQB$W_MAX_BUFF_AVAIL = 154,0,16,0 %; !  Max ever of free buffers
macro UQB$W_BUFF_ALLOC = 156,0,16,0 %;  !  Number of allocated buffers
macro UQB$W_MAX_BUFF_ALLOC = 158,0,16,0 %; !  Max number of buffers alloc.	
macro UQB$L_SERV_RSPID = 160,0,32,0 %;  !  Last RSPID checked in GCS
macro UQB$L_CLASS_RSPID = 164,0,32,0 %; !  Last class driver RSPID
macro UQB$L_OLD_CLSSTS = 168,0,32,0 %;  !  Class driver command status.
macro UQB$W_TAPEM_SKIP = 172,0,16,0 %;  !  Storage for REPOS. OBJECT
macro UQB$W_RECORD_SKIP = 174,0,16,0 %; !  Storage for REPOS. OBJECT
macro UQB$L_STARTSTOP = 176,0,32,0 %;   !  Start/stop time for drive
macro UQB$L_IO_TIME = 180,0,32,0 %;     !  Cycle time of IO to local drive
macro UQB$W_NUM_IO = 184,0,16,0 %;      !  Number of IOs issued to drive
macro UQB$W_MAX_IO = 186,0,16,0 %;      !  Max num of IOs outstanding to
!   to drive
macro UQB$L_ARR_TIME = 188,0,32,0 %;    !  Average time it takes the host
!  to respond to a request and
!  send the next request out.
macro UQB$W_NUM_FLUSH = 192,0,16,0 %;   !  Number of flush commands.
macro UQB$W_MAX_NUM_FLUSH = 194,0,16,0 %; !  Max number of flush commands.
macro UQB$L_POSITION = 196,0,32,0 %;    !  Unit's current position
macro UQB$W_ST_FLAGS = 200,0,16,0 %;    !  Unit usage
macro UQB$V_ST_BOT = 200,0,1,0 %;       !  BOT
macro UQB$V_ST_DLS = 200,1,1,0 %;       !  Cached data lost
macro UQB$V_ST_EOT = 200,2,1,0 %;       !  End of tape 
macro UQB$V_ST_LEOT = 200,3,1,0 %;      !  Logical end of tape
macro UQB$V_ST_PLS = 200,4,1,0 %;       !  Position lost
macro UQB$V_ST_SEREX = 200,5,1,0 %;     !  Serious exception state
macro UQB$V_ST_WRTPH = 200,6,1,0 %;     !  Write protected
literal UQB$C_LENGTH = 202;
literal UQB$K_LENGTH = 202;
 
!*** MODULE $VADEF ***
! +
!  VIRTUAL ADDRESS VIELDS
! -
literal VA$M_BYTE = 511;
literal VA$M_PVPN = 1073741312;
literal VA$M_P1 = 1073741824;
literal VA$M_SVPN = 1073741312;
literal VA$M_SYSTEM = -2147483648;
literal VA$M_VPG = -512;
literal VA$M_VPN = 1073741312;
literal VA$S_VADEF = 4;
macro VA$V_BYTE = 0,0,9,0 %;
literal VA$S_BYTE = 9;                  ! BYTE VIELD 
macro VA$V_PVPN = 0,9,21,0 %;
literal VA$S_PVPN = 21;                 ! PROCESS VIRTUAL
!  PAGE NUMBER 
macro VA$V_P1 = 0,30,1,0 %;             ! P1 SPACE 
macro VA$V_SVPN = 0,9,21,0 %;
literal VA$S_SVPN = 21;                 ! SYSTEM VIRTUAL
!  PAGE NUMBER
macro VA$V_SYSTEM = 0,31,1,0 %;         ! SYSTEM SPACE 
macro VA$V_VPG = 0,9,23,0 %;
literal VA$S_VPG = 23;                  ! VIRTUAL PAGE,
!  INCLUDING P1 & S 
!  Use of VA$x_VPN in EXTV/EXTZV/INSV instructions should be replaced
!  with either VA$x_SVPN or VA$x_PVPN, depending on whether the virtual
!  address is a System or Process virtual address, respectively.
macro VA$V_VPN = 0,9,21,0 %;
literal VA$S_VPN = 21;                  ! VIRTUAL PAGE NUMBER
!  USE PVPN OR SVPN!
 
!*** MODULE $VCADEF ***
! +
! 
!  VCA - Volume Cache Block. This block contains the specialized caches for
!  a disk volume; to wit, the file ID cache, the extent cache, and the quota
!  file cache. The file ID cache and extent cache are together in one block;
!  the quota cache is located separately in another block. Both are pointed to
!  by the VCB.
! 
! -
literal VCA$M_FIDC_VALID = 1;
literal VCA$M_EXTC_VALID = 2;
literal VCA$M_FIDC_FLUSH = 4;
literal VCA$M_EXTC_FLUSH = 8;
literal VCA$K_LENGTH = 12;              !  length of block header 
literal VCA$C_LENGTH = 12;              !  length of block header 
! 
literal VCA$S_VCADEF = 12;
macro VCA$L_FIDCACHE = 0,0,32,0 %;      !  pointer to file ID cache 
macro VCA$L_EXTCACHE = 4,0,32,0 %;      !  pointer to extent cache 
macro VCA$W_SIZE = 8,0,16,0 %;          !  block size 
macro VCA$B_TYPE = 10,0,8,0 %;          !  block type code 
macro VCA$B_FLAGS = 11,0,8,1 %;         !  cache flags
macro VCA$V_FIDC_VALID = 11,0,1,0 %;    !  FID cache valid
macro VCA$V_EXTC_VALID = 11,1,1,0 %;    !  Extent cache valid
macro VCA$V_FIDC_FLUSH = 11,2,1,0 %;    !  FID cache to be flushed
macro VCA$V_EXTC_FLUSH = 11,3,1,0 %;    !  Extent cache to be flushed
!  The file ID cache consists of the cache header, followed by a longword
!  vector of file numbers, densely packed.
! 
literal VCA$S_VCADEF1 = 40;
macro VCA$W_FIDSIZE = 0,0,16,0 %;       !  number of entries allocated 
macro VCA$W_FIDCOUNT = 2,0,16,0 %;      !  number of entries present 
macro VCA$L_FIDCLKID = 4,0,32,0 %;      !  FID cache lock id.
macro VCA$B_FIDCACB = 8,0,0,0 %;
literal VCA$S_FIDCACB = 28;             !  FID cache blocking ACB
macro VCA$L_FIDLIST = 36,0,32,0 %;      !  first entry in list 
! 
!  The extent cache consists of the cache header, followed by a quadword
!  vector of extents, densely packed. Each quadword contains block count
!  and starting LBN.
! 
literal VCA$S_VCADEF2 = 52;
macro VCA$W_EXTSIZE = 0,0,16,0 %;       !  number of entries allocated 
macro VCA$W_EXTCOUNT = 2,0,16,0 %;      !  number of entries present 
macro VCA$L_EXTTOTAL = 4,0,32,0 %;      !  total number of blocks contained in cache 
macro VCA$W_EXTLIMIT = 8,0,16,0 %;      !  limit of volume to be cached, in percent/10 
macro VCA$L_EXTCLKID = 12,0,32,0 %;     !  EXT cache lock id.
macro VCA$B_EXTCACB = 16,0,0,0 %;
literal VCA$S_EXTCACB = 28;             !  Extent cache blocking ACB.
macro VCA$Q_EXTLIST = 44,0,0,0 %;
literal VCA$S_EXTLIST = 8;              !  first entry in list 
literal VCA$S_VCADEF3 = 8;
macro VCA$L_EXTBLOCKS = 0,0,32,0 %;     !  number of blocks 
macro VCA$L_EXTLBN = 4,0,32,0 %;        !  starting LBN 
! 
!  The quota cache consists of the cache header, followed by the cache
!  entries. Each cache entry is a block as defined below.
! 
literal VCA$M_CACHEVALID = 1;
literal VCA$M_CACHEFLUSH = 2;
literal VCA$S_VCADEF4 = 72;
macro VCA$W_QUOSIZE = 0,0,16,0 %;       !  number of entries allocated 
macro VCA$W_QUOLRU = 2,0,16,0 %;        !  current LRU counter 
macro VCA$L_QUOCLKID = 4,0,32,0 %;      !  whole cache lock ID
macro VCA$B_QUOCFLAGS = 11,0,8,1 %;     !  cache flags
macro VCA$V_CACHEVALID = 11,0,1,0 %;    !  cache is valid
macro VCA$V_CACHEFLUSH = 11,1,1,0 %;    !  cache is to be flushed
macro VCA$B_QUOACB = 12,0,0,0 %;
literal VCA$S_QUOACB = 28;              !  ACB to deliver blocking AST
macro VCA$B_QUOFLUSHACB = 40,0,0,0 %;
literal VCA$S_QUOFLUSHACB = 28;         !  ACB to deliver cache flush AST
macro VCA$L_QUOLIST = 68,0,32,0 %;      !  start of entries 
literal VCA$M_QUOVALID = 1;
literal VCA$M_QUODIRTY = 2;
literal VCA$K_QUOLENGTH = 28;           !  length of quota cache entry 
literal VCA$C_QUOLENGTH = 28;           !  length of quota cache entry 
literal VCA$S_VCADEF5 = 28;
macro VCA$R_QUOLOCK = 0,0,0,0 %;
literal VCA$S_QUOLOCK = 24;             !  lock status block
macro VCA$W_QUOSTATUS = 0,0,16,0 %;     !  $ENQ status
macro VCA$W_QUOINDEX = 0,0,16,0 %;      !  index in cache of this entry
macro VCA$W_QUOLRUX = 2,0,16,0 %;       !  LRU index for entry 
macro VCA$L_QUOLKID = 4,0,32,0 %;       !  lock ID of cache entry
macro VCA$L_QUORECNUM = 8,0,24,0 %;
literal VCA$S_QUORECNUM = 3;            !  record number 
macro VCA$B_QUOFLAGS = 11,0,8,0 %;      !  flags byte 
macro VCA$V_QUOVALID = 11,0,1,0 %;      !  valid entry is present
macro VCA$V_QUODIRTY = 11,1,1,0 %;      !  dirty flag 
macro VCA$L_USAGE = 12,0,32,0 %;        !  current usage 
macro VCA$L_PERMQUOTA = 16,0,32,0 %;    !  permanent quota 
macro VCA$L_OVERDRAFT = 20,0,32,0 %;    !  overdraft limit 
macro VCA$L_QUOUIC = 24,0,32,0 %;       !  UIC 
 
!*** MODULE $VCBDEF ***
literal VCB$K_MRKLEN = 11;              !  Mark length
literal VCB$C_MRKLEN = 11;              !  Mark length
literal VCB$M_WRITE_IF = 1;
literal VCB$M_WRITE_SM = 2;
literal VCB$M_HOMBLKBAD = 4;
literal VCB$M_IDXHDRBAD = 8;
literal VCB$M_NOALLOC = 16;
literal VCB$M_EXTFID = 32;
literal VCB$M_GROUP = 64;
literal VCB$M_SYSTEM = 128;
literal VCB$M_PARTFILE = 1;
literal VCB$M_LOGICEOVS = 2;
literal VCB$M_WAIMOUVOL = 4;
literal VCB$M_WAIREWIND = 8;
literal VCB$M_WAIUSRLBL = 16;
literal VCB$M_CANCELIO = 32;
literal VCB$M_MUSTCLOSE = 64;
literal VCB$M_NOWRITE = 128;
literal VCB$M_SHADMAST = 1;
literal VCB$M_FAILED = 2;
literal VCB$M_REBLDNG = 8;
literal VCB$M_BLKASTREC = 16;
literal VCB$M_MVBEGUN = 32;
literal VCB$M_ADDING = 64;
literal VCB$M_PACKACKED = 128;
literal VCB$K_COMLEN = 36;              !  LENGTH OF COMMON AREA 
literal VCB$S_VCBDEF_COMMON = 36;
macro VCB$L_FCBFL = 0,0,32,0 %;         !  FCB listhead forward link
macro VCB$L_BLOCKFL = 0,0,32,0 %;       !   or - Blocked request listhead forward link
macro VCB$L_MEMQFL = 0,0,32,0 %;        !   or - Shadow set members queue forward link
macro VCB$L_FCBBL = 4,0,32,0 %;         !  FCB listhead backward link
macro VCB$L_BLOCKBL = 4,0,32,0 %;       !   or - Blocked request listhead backward link
macro VCB$L_MEMQBL = 4,0,32,0 %;        !   or - Shadow set members queue backward link
macro VCB$W_SIZE = 8,0,16,0 %;          !  Size of VCB in bytes
macro VCB$B_TYPE = 10,0,8,0 %;          !  structure type of VCB 
!  Second mark point
macro VCB$B_STATUS = 11,0,8,0 %;        !  Volume status:
macro VCB$V_WRITE_IF = 11,0,1,0 %;      !     Index file is write accessed
macro VCB$V_WRITE_SM = 11,1,1,0 %;      !     Storage map is write accessed
macro VCB$V_HOMBLKBAD = 11,2,1,0 %;     !     Primary home block is bad
macro VCB$V_IDXHDRBAD = 11,3,1,0 %;     !     Primary index file header is bad
macro VCB$V_NOALLOC = 11,4,1,0 %;       !     Allocation/deallocation inhibited (bad bitmaps)
macro VCB$V_EXTFID = 11,5,1,0 %;        !     Volume has 24 bit file numbers
macro VCB$V_GROUP = 11,6,1,0 %;         !     Volume is mounted /group
macro VCB$V_SYSTEM = 11,7,1,0 %;        !     Volume is mounted /system
macro VCB$V_PARTFILE = 11,0,1,0 %;      !     Partial file exists on tape
macro VCB$V_LOGICEOVS = 11,1,1,0 %;     !     Positioned at logical end of volume set
macro VCB$V_WAIMOUVOL = 11,2,1,0 %;     !     Wait for volume mount
macro VCB$V_WAIREWIND = 11,3,1,0 %;     !     Wait for rewind completion
macro VCB$V_WAIUSRLBL = 11,4,1,0 %;     !     Wait for user label
macro VCB$V_CANCELIO = 11,5,1,0 %;      !     Cancel I/O 
macro VCB$V_MUSTCLOSE = 11,6,1,0 %;     !     Must close file
macro VCB$V_NOWRITE = 11,7,1,0 %;       !     Don't write trailers
macro VCB$V_SHADMAST = 11,0,1,0 %;      !     This VCB is for shadow set master
macro VCB$V_FAILED = 11,1,1,0 %;        !     Member failed out of shadow set
macro VCB$V_REBLDNG = 11,3,1,0 %;       !     Mount verfication rebuilding shadow set
macro VCB$V_BLKASTREC = 11,4,1,0 %;     !     Shadowing lock blocking AST received
macro VCB$V_MVBEGUN = 11,5,1,0 %;       !     Mount verification initiated
macro VCB$V_ADDING = 11,6,1,0 %;        !     Adding member to shadow set
macro VCB$V_PACKACKED = 11,7,1,0 %;     !     Member PACKACKed during rebuild attempt
macro VCB$W_TRANS = 12,0,16,0 %;        !  VOLUME TRANSACTION COUNT 
macro VCB$W_RVN = 14,0,16,0 %;          !  RELATIVE VOLUME NUMBER 
macro VCB$L_AQB = 16,0,32,0 %;          !  ADDRESS OF AQB 
macro VCB$T_VOLNAME = 20,0,0,0 %;
literal VCB$S_VOLNAME = 12;             !  VOLUME LABEL BLANK FILLED 
macro VCB$L_RVT = 32,0,32,0 %;          !  ADDRESS OF UCB OR RELATIVE VOLUME TABLE 
!  THIRD MARK POINT
literal VCB$C_COMLEN = 36;              !  LENGTH OF COMMON AREA 
literal VCB$K_LENGTH = 240;             !  LENGTH OF STANDARD VCB 
literal VCB$C_LENGTH = 240;             !  LENGTH OF STANDARD VCB 
literal VCB$S_VCBDEF_DISKS = 240;
macro VCB$L_HOMELBN = 36,0,32,0 %;      !  LBN OF VOLUME HOME BLOCK 
macro VCB$L_HOME2LBN = 40,0,32,0 %;     !  LBN OF ALTERNATE VOLUME HOME BLOCK 
macro VCB$L_IXHDR2LBN = 44,0,32,0 %;    !  LBN OF ALTERNATE INDEX FILE HEADER 
macro VCB$L_IBMAPLBN = 48,0,32,0 %;     !  LBN OF INDEX FILE BITMAP 
macro VCB$L_SBMAPLBN = 52,0,32,0 %;     !  LBN OF STORAGE BITMAP 
macro VCB$W_IBMAPSIZE = 56,0,16,0 %;    !  SIZE OF INDEX FILE BITMAP
macro VCB$B_IBMAPSIZE = 56,0,8,0 %;     !   SIZE OF INDEX FILE BITMAP (old form)
macro VCB$W_IBMAPVBN = 58,0,16,0 %;     !  CURRENT VBN IN INDEX FILE BIT MAP
macro VCB$B_IBMAPVBN = 58,0,8,0 %;      !   CURRENT VBN IN INDEX FILE BIT MAP (old form)
macro VCB$W_SBMAPSIZE = 60,0,16,0 %;    !  SIZE OF STORAGE BITMAP 
macro VCB$B_SBMAPSIZE = 60,0,8,0 %;     !   SIZE OF STORAGE BITMAP (old form)
macro VCB$W_SBMAPVBN = 62,0,16,0 %;     !  CURRENT VBN IN STORAGE MAP 
macro VCB$B_SBMAPVBN = 62,0,8,0 %;      !   CURRENT VBN IN STORAGE MAP (old form)
macro VCB$W_CLUSTER = 64,0,16,0 %;      !  VOLUME CLUSTER SIZE 
macro VCB$W_EXTEND = 66,0,16,0 %;       !  VOLUME DEFAULT FILE EXTENSION LENGTH 
macro VCB$L_FREE = 68,0,32,0 %;         !  NUMBER OF FREE BLOCKS ON VOLUME 
macro VCB$L_MAXFILES = 72,0,32,0 %;     !  MAXIMUM NUMBER OF FILES ALLOWED ON VOLUME 
macro VCB$B_WINDOW = 76,0,8,0 %;        !  VOLUME DEFAULT WINDOW SIZE 
macro VCB$B_LRU_LIM = 77,0,8,1 %;       !  VOLUME DIRECTORY LRU SIZE LIMIT 
macro VCB$W_FILEPROT = 78,0,16,0 %;     !  VOLUME DEFAULT FILE PROTECTION 
macro VCB$W_MCOUNT = 80,0,16,0 %;       !  MOUNT COUNT 
macro VCB$B_EOFDELTA = 82,0,8,0 %;      !  INDEX FILE EOF UPDATE COUNT 
macro VCB$B_RESFILES = 83,0,8,0 %;      !  NUMBER OF RESERVED FILES ON VOLUME 
macro VCB$W_RECORDSZ = 84,0,16,0 %;     !  NUMBER OF BYTES IN A RECORD 
macro VCB$B_BLOCKFACT = 86,0,8,0 %;     !  VOLUME BLOCKING FACTOR 
macro VCB$B_STATUS2 = 87,0,8,0 %;       !  SECOND STATUS BYTE 
macro VCB$V_WRITETHRU = 87,0,1,0 %;     !  VOLUME IS TO BE WRITE-THROUGH CACHED 
macro VCB$V_NOCACHE = 87,1,1,0 %;       !  ALL CACHEING IS DISABLED ON VOLUME 
macro VCB$V_MOUNTVER = 87,2,1,0 %;      !  VOLUME CAN UNDERGO MOUNT VERIFICATION 
macro VCB$V_ERASE = 87,3,1,0 %;         !  ERASE DATA WHEN BLOCKS REMOVED FROM FILE
macro VCB$V_NOHIGHWATER = 87,4,1,0 %;   !  TURN OFF HIGH-WATER MARKING (D = ON)
macro VCB$V_NOSHARE = 87,5,1,0 %;       !  non-shared mount
macro VCB$V_CLUSLOCK = 87,6,1,0 %;      !  CLUSTER WIDE LOCKING NECESSARY
macro VCB$V_SUBSET0 = 87,7,1,0 %;       !  ODS-2 SUBSET 0 VOLUME
macro VCB$L_QUOTAFCB = 88,0,32,0 %;     !  ADDRESS OF FCB OF DISK QUOTA FILE 
macro VCB$L_CACHE = 92,0,32,0 %;        !  ADDRESS OF VOLUME CACHE BLOCK 
macro VCB$L_QUOCACHE = 96,0,32,0 %;     !  ADDRESS OF VOLUME QUOTA CACHE 
macro VCB$W_QUOSIZE = 100,0,16,0 %;     !  LENGTH OF QUOTA CACHE TO ALLOCATE 
macro VCB$W_PENDERR = 102,0,16,0 %;     !  COUNT OF PENDING WRITE ERRORS 
macro VCB$L_SERIALNUM = 104,0,32,0 %;   !  VOLUME SERIAL NUMBER (DISKS ONLY) 
macro VCB$L_RESERVED1 = 108,0,32,0 %;   !  RESERVED
!  NOTE: the above field was formerly called JNLIOCNT
macro VCB$Q_RETAINMIN = 112,0,0,0 %;
literal VCB$S_RETAINMIN = 8;            !  MINIMUM FILE RETENTION PERIOD 
macro VCB$Q_RETAINMAX = 120,0,0,0 %;
literal VCB$S_RETAINMAX = 8;            !  MAXIMUM FILE RETENTION PERIOD 
macro VCB$L_VOLLKID = 128,0,32,0 %;     !  VOLUME LOCK ID
macro VCB$T_VOLCKNAM = 132,0,0,0 %;
literal VCB$S_VOLCKNAM = 12;            !  NAME FOR VOLUME LOCKS
macro VCB$L_BLOCKID = 144,0,32,0 %;     !  VOLUME BLOCKING LOCK.
macro VCB$Q_MOUNTTIME = 148,0,0,0 %;
literal VCB$S_MOUNTTIME = 8;            !  VOLUME MOUNT TIME
macro VCB$L_MEMHDFL = 156,0,32,0 %;     !  SHADOW SET MEMBERS QUEUE HEADER FL
macro VCB$L_MEMHDBL = 160,0,32,0 %;     !  SHADOW SET MEMBERS QUEUE HEADER BL
macro VCB$W_ACTIVITY = 164,0,16,0 %;    !  ACTIVITY COUNT/FLAG
macro VCB$B_SPL_CNT = 166,0,8,0 %;      !  NUMBER OF DEVICES SPOOLED TO VOLUME
macro VCB$B_SHAD_STS = 167,0,8,0 %;     !  STATUS BYTE RELATIVE TO MEMHDFL
macro VCB$L_SHAD_LKID = 168,0,32,0 %;   !  Shadowing lock lock-id
macro VCB$B_ACB = 172,0,0,0 %;
literal VCB$S_ACB = 28;                 !  ACB FOR BLOCKING AST.
macro VCB$R_MIN_CLASS = 200,0,0,0 %;
literal VCB$S_MIN_CLASS = 20;           !  MINIMUM CLASSIFICATION
macro VCB$R_MAX_CLASS = 220,0,0,0 %;
literal VCB$S_MAX_CLASS = 20;           !  MAXIMUM CLASSIFICATION
! 
!  SHADOW SET MEMBER VOLUME CONTROL BLOCK FIELDS
! 
literal VCB$K_SHAD_LEN = 68;            !  Shadow set member VCB length
literal VCB$S_VCBDEF_SHADOW = 68;
macro VCB$L_MEM_UCB = 36,0,32,0 %;      !  Shadow set member UCB address
macro VCB$L_MAST_UCB = 40,0,32,0 %;     !  Shadow set master UCB address
macro VCB$L_MAST_VCB = 44,0,32,0 %;     !  Shadow set master VCB address
macro VCB$W_COPY_TYPE = 48,0,16,0 %;    !  Member's MSCP copy type
macro VCB$W_CPYSEQNUM = 50,0,16,0 %;    !  IO$_COPYSHAD sequence number
macro VCB$Q_WORK = 52,0,0,0 %;
literal VCB$S_WORK = 8;                 !  Per-member workspace
macro VCB$Q_SHDM_RESV = 60,0,0,0 %;
literal VCB$S_SHDM_RESV = 8;            !  Reserved for future enhancements
! 
!  MTAACP VOLUME CONTROL BLOCK FIELDS
! 
literal VCB$S_VCBDEF2 = 120;
macro VCB$L_CUR_FID = 36,0,32,0 %;      !  CURRENT FILE IDENTIFICATION 
macro VCB$W_CUR_NUM = 36,0,16,0 %;      !  CURRENT FILE SECTION NUMBER 
macro VCB$W_CUR_SEQ = 38,0,16,0 %;      !  CURRENT FILE SEQUENCE NUMBER 
macro VCB$L_START_FID = 40,0,32,0 %;    !  FILE IDENTIFICATION AT START OF SEARCH 
macro VCB$W_START_NUM = 40,0,16,0 %;    !  FILE SECTION NUMBER AT START OF SEARCH 
macro VCB$W_START_SEQ = 42,0,16,0 %;    !  FILE SEQUENCE NUMBER AT START OF SEARCH 
macro VCB$W_MODE = 44,0,16,0 %;         !  MODE OF OPERATION 
macro VCB$V_OVREXP = 44,0,1,0 %;        !  OVERRIDE EXPIRATION 
macro VCB$V_OVRACC = 44,1,1,0 %;        !  OVERRIDE ACCESS 
macro VCB$V_OVRLBL = 44,2,1,0 %;        !  OVERRIDE LABELS 
macro VCB$V_OVRSETID = 44,3,1,0 %;      !  OVERRIDE SET IDENTIFIER 
macro VCB$V_INTCHG = 44,4,1,0 %;        !  INTERCHANGE TAPE 
macro VCB$V_EBCDIC = 44,5,1,0 %;        !  EBCDIC CODE SET 
macro VCB$V_NOVOL2 = 44,6,1,0 %;        !  DO NOT WRITE A VOL2 LABEL
macro VCB$V_NOHDR3 = 44,7,1,0 %;        !  DO NOT WRITE HDR3 LABELS 
macro VCB$V_STARFILE = 44,8,1,0 %;      !  CURRENT FILE IS A STARLET PRODUCED FILE 
macro VCB$V_ENUSEREOT = 44,9,1,0 %;     !  SET WHEN USER HANDLING OF EOT IS ENABLED
macro VCB$V_BLANK = 44,10,1,0 %;        !  SET FOR AVL WHEN NO READ SHOULD HAPPEN FIRST
macro VCB$V_INIT = 44,11,1,0 %;         !  SET FOR AVL WHEN NEXT VOL MOUNTED SHOULD BE INITED
macro VCB$V_NOAUTO = 44,12,1,0 %;       !  MTAACP NOT RUNNING IN AVL AND AVR MODE
macro VCB$V_OVRVOLO = 44,13,1,0 %;      !  OVERRIDE THEVOL1 OWNER IDENT FIELD
macro VCB$V_FIL_ACCESS = 44,14,1,0 %;   !  SET IF ACCESS ROUTINE ALLOWS CHECK OF VMS PROTECTION ON FILE
macro VCB$B_TM = 46,0,8,0 %;            !  NUMBER OF TM'S INTO FILE 
macro VCB$B_CUR_RVN = 47,0,8,0 %;       !  CURRENT RELATIVE VOLUME 
macro VCB$L_ST_RECORD = 48,0,32,0 %;    !  NUMBER OF RECORDS UP TO AND INCLUDING LAST TAPE MARK 
macro VCB$L_MVL = 52,0,32,0 %;          !  ADDRESS OF MAGNETIC TAPE VOLUME LIST 
macro VCB$L_WCB = 56,0,32,0 %;          !  ADDRESS OF WINDOW FOR THIS VOLUME 
macro VCB$L_VPFL = 60,0,32,0 %;         !  VIRTUAL PAGE LIST HEAD 
macro VCB$L_VPBL = 64,0,32,0 %;         !  VIRTUAL PAGE LIST TAIL 
macro VCB$L_USRLBLAST = 68,0,32,0 %;    !  ADDRESS OF USER LABEL AST CONTROL BLOCK 
macro VCB$B_LBLCNT = 72,0,8,0 %;        !  Count of HDRn labels read on file open
!  NOTE THAT FCP AND MTAACP SHARE VCB$W_MCOUNT(DISPLACEMENT 80)
macro VCB$t_fill_5 = 73,0,0,0 %;
literal VCB$s_fill_5 = 39;              !  Skip over fields up to RETAINMIN=112
macro VCB$Q_EXP_DATE = 112,0,0,0 %;
literal VCB$S_EXP_DATE = 8;             !  DEFAULT FILE EXPIRATION DATE
literal VCB$S_VCBDEF3 = 32;
macro VCB$B_QNAMECNT = 11,0,8,0 %;      !  BYTE COUNT OF QUEUE NAME 
macro VCB$T_QNAME = 12,0,0,0 %;
literal VCB$S_QNAME = 20;               !  ASCII NAME OF QUEUE FOR THIS DEVICE 
! 
!  JOURNAL ACP VOLUME CONTROL BLOCK FIELDS
! 
 
!*** MODULE $VCIBDEF ***
! +
!  VCIB - VAX Communication Interface Block
! 
!  The VCIB is the data structure used to define an instance of a VCI port
!  between two VCMs.  A single VCIB is used between only two layers.  Those
!  two layers may have many VCIBs between them; each one representing a
!  different VCI port.  Only the common fields within the VCIB are defined
!  here.  All layer-specific fields are defined elsewhere.  Some constants
!  used within the VCIB are defined here also.  And the VCM IDs are also
!  defined here.
! -
!  VCI Registry function codes.
literal VCIB$K_FC_REGISTER = 0;         !  Register a VCM
literal VCIB$K_FC_UNREGISTER = 1;       !  Unregister a VCM
literal VCIB$K_FC_CREATE_PORT = 2;      !  Create a port to a lower VCM
literal VCIB$K_FC_DELETE_PORT = 3;      !  Delete a port to a lower VCM
!  Registered users of the VCI.
literal VCI$K_ID_NWM = 2048;            !  Network Management
literal VCI$K_ID_CONF = 2049;           !  Conformance Test Tool
literal VCI$K_ID_SCL = 1280;            !  Session Control
literal VCI$K_ID_SCLSRV = 1281;         !  Session Control Session Services
literal VCI$K_ID_SCLMIN = 1282;         !  Session Control Minimum Services
literal VCI$K_ID_NSPTP = 1024;          !  Transport - NSP
literal VCI$K_ID_OSITP = 1025;          !  Transport - OSI
literal VCI$K_ID_LCLTP = 1026;          !  Transport - Local
literal VCI$K_ID_SCATP = 1027;          !  Transport - SCA
literal VCI$K_ID_LAT = 1028;            !  Transport - LAT
literal VCI$K_ID_LAST = 1029;           !  Transport - LAST
literal VCI$K_ID_LAVC = 1030;           !  Transport - LAVC
literal VCI$K_ID_MOP = 1031;            !  Maintenance Operations
literal VCI$K_ID_TCPIP = 1032;          !  Transport - TCPIP
literal VCI$K_ID_NRL = 768;             !  Network Routing
literal VCI$K_ID_ALIAS = 769;           !  Alias (Routing portion)
literal VCI$K_ID_LAN = 513;             !  Data Link - CSMACD & FDDI
literal VCI$K_ID_DDCMP = 514;           !  Data Link - DDCMP Synchronous
literal VCI$K_ID_HDLC = 515;            !  Data Link - HDLC  Synchronous
literal VCI$K_ID_ASY = 516;             !  Data Link - Asynchronous
literal VCI$K_ID_X25 = 517;             !  Data Link - X.25
literal VCI$K_ID_ADM = 518;             !  Data Link - ALTSTART DDCMP
literal VCI$K_ID_ACM = 519;             !  Data Link - ALTSTART CSMACD
literal VCI$K_ID_LAPB = 520;            !  Data Link - LAPB
literal VCI$K_ID_LLC2 = 521;            !  Data Link - LLC2
literal VCI$K_ID_TST1 = 2304;           !  Test VCM  - 1st
literal VCI$K_ID_TST2 = 2305;           !  Test VCM  - 2nd
literal VCI$K_ID_TST3 = 2306;           !  Test VCM  - 3rd
literal VCI$K_ID_TST4 = 2307;           !  Test VCM  - 4th
literal VCI$K_ID_TST5 = 2308;           !  Test VCM  - 5th
literal VCI$K_ID_TST6 = 2309;           !  Test VCM  - 6th
literal VCI$K_ID_TST7 = 2310;           !  Test VCM  - 7th
literal VCI$K_ID_TST8 = 2311;           !  Test VCM  - 8th
literal VCI$K_NUM_ID = 40;              !  Number of valid VCMs 
!  VCIB data structure
! 
!  The common fields within the VCIB are defined now.
literal VCIB$K_FIXED_LENGTH = 60;       !  Length of fixed portion of VCIB
literal VCIB$S_VCIBDEF = 60;
macro VCIB$L_FLINK = 0,0,32,0 %;        !  Forward Queue link
macro VCIB$L_BLINK = 4,0,32,0 %;        !  Backward Queue link
macro VCIB$W_SIZE = 8,0,16,0 %;         !  Size of structure
macro VCIB$B_TYPE = 10,0,8,0 %;         !  Type of structure - DYN$C_NET
macro VCIB$B_SUB_TYPE = 11,0,8,0 %;     !  Subtype of structure - DYN$C_VCIB
macro VCIB$L_VCI_ID = 12,0,32,0 %;      !  Field containing the VCI ID of the
!  VCM (used by the lower VCM for
!  validation of user)
macro VCIB$W_VERSION_UPPER = 16,0,16,0 %; !  VCI Version of Upper VCM
macro VCIB$W_VERSION_LOWER = 18,0,16,0 %; !  VCI Version of Lower VCM
macro VCIB$A_PORTMGMT_SYNCH = 20,0,32,0 %; !  Address of Lower VCM's Port
!  Management Synchronous service
macro VCIB$A_PORTMGMT_INITIATE = 24,0,32,0 %; !  Address of Lower VCM's Port
!  Management Initiate service
macro VCIB$A_PORTMGMT_COMPLETE = 28,0,32,0 %; !  Address of Upper VCM's Port
!  Management Complete service
macro VCIB$A_CONTROL_SYNCH = 32,0,32,0 %; !  Address of Lower VCM's Control
!  Synchronous service
macro VCIB$A_CONTROL_INITIATE = 36,0,32,0 %; !  Address of Lower VCM's Control
!  Initiate service
macro VCIB$A_CONTROL_COMPLETE = 40,0,32,0 %; !  Address of Upper VCM's Control
!  Complete service
macro VCIB$A_TRANSMIT_INITIATE = 44,0,32,0 %; !  Address of Lower VCM's Transmit
!  Initiate service
macro VCIB$A_TRANSMIT_COMPLETE = 48,0,32,0 %; !  Address of Upper VCM's Transmit
!  Complete service
macro VCIB$A_RECEIVE_COMPLETE = 52,0,32,0 %; !  Address of Upper VCM's Receive
!  Complete service
macro VCIB$A_REPORT_EVENT = 56,0,32,0 %; !  Address of Upper VCM's Report
!  Event service
 
!*** MODULE $VCRPDEF ***
! +
!  VCRP - VAX Communication Request Packet
! 
!  The VCRP is the data structure used to pass requests between VCMs.  A
!  single VCRP may traverse more than two VCMs.  Only the common fields
!  within the VCRP are defined here.  All layer-specific fields are defined
!  elsewhere.  The common VCRP function codes are also defined here.
! 
!  THE FORMAT OF A VCRP DATA REQUEST PACKET SHOULD NOT CHANGE WITHOUT
!  CORRESPONDING CHANGES BEING MAY TO THE DCBE.
! -
!  Function codes used in the VCRP$L_FUNCTION field.  The function codes
!  are separated numerically by layer as follows:
! 
!    0000-01FF Common function codes from the VCI functional specification
!    0200-02FF DLL Data Link function codes
!    0300-03FF NRL Network Routing function codes
!    0400-04FF TPL Transport function codes
!    0500-05FF SCL Session function codes
!    0600-06FF APP Application function codes
literal VCRP$K_FC_ENABLE_PORT = 0;
literal VCRP$K_FC_DISABLE_PORT = 1;
literal VCRP$K_FC_GET = 2;
literal VCRP$K_FC_SET = 3;
literal VCRP$K_FC_TRANSMIT = 4;
literal VCRP$K_FC_RECEIVE = 5;
!  Define the fields used within the STACK area of the VCRP.
literal STACK$k_STACK_HEADER = 12;
!  Size of Stack Header
literal STACK$K_STACK_SIZE = 72;        !  Size of Stack in bytes
literal STACK$S_VCRPSTACKDEF = 84;
macro STACK$L_LASTUSED = 0,0,32,0 %;    !  Stack Last Used position pointer
macro STACK$L_BTM = 4,0,32,0 %;         !  Stack Bottom
macro STACK$L_TOP = 8,0,32,0 %;         !  Stack Top
macro STACK$T_STACK = 12,0,0,0 %;
literal STACK$S_STACK = 72;
!  Context stack
!  Size of entire stack area
!  VCRP data structure
! 
!  The common fields within the VCRP are defined now.  The VCRP is created
!  such that it can be used as an ACB, a DCBE, or a VCRP.  So the fields at
!  the beginning of the VCRP mimic the fields in the ACB and the DCBE.
literal VCRP$M_PKAST = 16;
literal VCRP$M_NODELETE = 32;
literal VCRP$M_QUOTA = 64;
literal VCRP$M_KAST = 128;
literal VCRP$K_ACB_LENGTH = 28;         !  Length of VCRP ACB Block
literal VCRP$M_CMN_LOCKED = 1;
literal VCRP$M_CMN_RETBUF = 2;
literal VCRP$M_CMN_CACHE = 4;
literal VCRP$M_CMN_MGMT = 8;
literal VCRP$K_DATA_INFORMATION_OFFSET = 60;
literal VCRP$K_DATA_INFORMATION_LENGTH = 7;
literal VCRP$K_MGMT_INFORMATION_OFFSET = 48;
literal VCRP$K_MGMT_INFORMATION_LENGTH = 19;
literal VCRP$K_CREATOR_DATA_OFFSET = 92;
literal VCRP$K_CREATOR_DATA_LENGTH = 8;
literal VCRP$K_INTERNAL_STACK_OFFSET = 112;
literal VCRP$K_INTERNAL_STACK_LENGTH = 84;
literal VCRP$K_SCRATCH_AREA_OFFSET = 196;
literal VCRP$K_SCRATCH_AREA_LENGTH = 64;
literal VCRP$K_FIXED_LENGTH = 260;      !  Length of fixed part of VCRP
!  If this VCM contains data, it will start here or after here.
literal VCRP$C_DATA = 260;              !  Offset into start of data
literal VCRP$S_VCRPDEF = 260;
macro VCRP$L_FLINK = 0,0,32,0 %;        !  Forward Queue link
macro VCRP$L_BLINK = 4,0,32,0 %;        !  Backward Queue link
macro VCRP$W_SIZE = 8,0,16,0 %;         !  Size of structure
macro VCRP$B_TYPE = 10,0,8,0 %;         !  Type of structure - DYN$C_VCRP
macro VCRP$B_RMOD = 11,0,8,0 %;         !  Request Modifier for ACB
macro VCRP$V_MODE = 11,0,2,0 %;
literal VCRP$S_MODE = 2;                !  Mode for final delivery
macro VCRP$V_PKAST = 11,4,1,0 %;        !  Piggy back special kernel AST
macro VCRP$V_NODELETE = 11,5,1,0 %;     !  Don't delete ACB on delivery
macro VCRP$V_QUOTA = 11,6,1,0 %;        !  Account for quota
macro VCRP$V_KAST = 11,7,1,0 %;         !  Special kernel AST
macro VCRP$L_PID = 12,0,32,0 %;         !  Process Identifier
macro VCRP$A_ASTADR = 16,0,32,0 %;      !  Address of user AST routine
macro VCRP$L_ASTPRM = 20,0,32,0 %;      !  User AST input parameter
macro VCRP$A_KAST = 24,0,32,0 %;        !  Special kernel mode AST routine
macro VCRP$R_COMMON_FLAGS_OVERLAY = 28,0,16,0 %;
macro VCRP$W_COMMON_FLAGS = 28,0,16,0 %; !  Common flags
macro VCRP$V_CMN_LOCKED = 28,0,1,0 %;   !  Buffer is locked down
macro VCRP$V_CMN_RETBUF = 28,1,1,0 %;   !  Return buffer immediately
macro VCRP$V_CMN_CACHE = 28,2,1,0 %;    !  Owner's cache buffer
macro VCRP$V_CMN_MGMT = 28,3,1,0 %;     !  Mgmt VCRP; not data VCRP
macro VCRP$B_FLAGS = 30,0,8,0 %;        !  User controlled VCRP flags
macro VCRP$B_MODE = 31,0,8,0 %;         !  
macro VCRP$A_DEALLOC_RTN = 32,0,32,0 %; !  Address of VCRP deallocation routine
! 
!  This part of the VCRP contains the request specific information.
!  VCRPs can contain either a Management request or a Data request.  The
!  type of VCRP request is determined by the VCRP$W_COMMON_FLAGS field.
!  If VCRP$V_CMN_MGMT is set, then the VCRP is using the Management
!  request format.  IF VCRP$V_CMN_MGMT is NOT set, then the VCRP is
!  using the Data request format.
! 
macro VCRP$R_VCRP_REQUEST = 36,0,0,0 %;
literal VCRP$S_VCRP_REQUEST = 32;
macro VCRP$R_REQUEST_OVERLAY = 36,0,0,0 %;
! 
!  Data Request Format.  The position of these field are to be the same
!  as the DCB fields of the same name.
! 
macro VCRP$R_DATA_REQUEST = 36,0,0,0 %;
literal VCRP$S_DATA_REQUEST = 31;
macro VCRP$A_DCB_LINK = 36,0,32,0 %;    !  Address of next DCB in chain
macro VCRP$L_SVAPTE = 40,0,32,0 %;      !  Address of System Virtual Address PTE
macro VCRP$L_BUFFER_ADDRESS = 44,0,32,0 %; !  VM Address of buffer specified in SVAPTE
macro VCRP$L_BOFF = 48,0,32,0 %;        !  Offset to start of data in buffer
macro VCRP$L_BCNT = 52,0,32,0 %;        !  Byte count of data in buffer
! 
!  All fields preceeding this comment should be similar in layout,name and size 
!  to a DCB.  A programmer should verify that these fields are similar by
!  adding the appropriate ASSUMES to his or her code.
! 
macro VCRP$L_TOTAL_PDU_SIZE = 56,0,32,0 %; !  Total PDU Size
!  This 7 byte portion of the data request area can be used by each
!  layer to allow its client to pass more information in the request.
macro VCRP$T_DATA_INFORMATION = 60,0,0,1 %;
literal VCRP$S_DATA_INFORMATION = 7;
! 
!  Management Request Format.  
! 	    
macro VCRP$R_MGMT_REQUEST = 36,0,0,0 %;
literal VCRP$S_MGMT_REQUEST = 31;
macro VCRP$A_INPUT_LIST = 36,0,32,0 %;  !  Address of Input item list
macro VCRP$A_TEMPLATE_LIST = 40,0,32,0 %; !  Address of Template item list
macro VCRP$A_OUTPUT_LIST = 44,0,32,0 %; !  Address of Output item list
!  This 19 byte portion of the mgmt request area can be used by each
!  layer to allow its client to pass more information in the request.
macro VCRP$T_MGMT_INFORMATION = 48,0,0,1 %;
literal VCRP$S_MGMT_INFORMATION = 19;
macro VCRP$B_LES_FLAGS = 67,0,8,0 %;    !  LES flags
macro VCRP$L_FUNCTION = 68,0,32,0 %;    !  Function for this request
macro VCRP$L_ASSOCIATION_ID = 72,0,32,0 %;
macro VCRP$L_CONNECTION_ID = 76,0,32,0 %;
macro VCRP$R_STATUS_OVERLAY = 80,0,0,0 %; !  Status of request upon completion
macro VCRP$R_QUAD_REQUEST = 80,0,0,0 %;
literal VCRP$S_QUAD_REQUEST = 8;
macro VCRP$Q_REQUEST_STATUS = 80,0,0,0 %;
literal VCRP$S_REQUEST_STATUS = 8;
macro VCRP$R_LONG_REQUEST = 80,0,0,0 %;
literal VCRP$S_LONG_REQUEST = 8;
macro VCRP$L_REQUEST_STATUS = 80,0,32,0 %;
macro VCRP$L_REQUEST_STATUS_QUAL = 84,0,32,0 %;
macro VCRP$A_CREATOR = 88,0,32,0 %;     !  VCIB address of creator of VCRP
!  The creator data section is a section that is used privately by the
!  creator of the VCRP.
macro VCRP$R_CREATOR_DATA_OVERLAY = 92,0,0,0 %;
macro VCRP$R_QUAD_CREATOR_DATA = 92,0,0,0 %;
literal VCRP$S_QUAD_CREATOR_DATA = 8;
macro VCRP$Q_CREATOR_DATA = 92,0,0,0 %;
literal VCRP$S_CREATOR_DATA = 8;
macro VCRP$R_LONG_CREATOR_DATA = 92,0,0,0 %;
literal VCRP$S_LONG_CREATOR_DATA = 8;
macro VCRP$L_CREATOR_DATA1 = 92,0,32,0 %;
macro VCRP$L_CREATOR_DATA2 = 96,0,32,0 %;
macro VCRP$Q_LES = 100,0,0,0 %;
literal VCRP$S_LES = 8;                 !  LES information
!  The following fields describe the VCRP context stack, which is used by
!  by VCM's to preserve request context.  The use of the fields is as 
!  follows:
! 
!  STACK	 - contains an address which will point to a stack block.  The
!              stack block will contain the last used stack pointer
!              (LASTUSED), the address of the end of the stack (BTM), the
!              address of the top of the stack, and the stack itself
!              (STACK).  This is layout is used to insure that if the
!              context stack is removed from the VCRP and allocated in a
!              buffer pointed to by VCRP$A_STACK, that no VCM's will be
!              adversely affected.
! 	LASTUSED - pointer to the last used location in the stack.
! 	BTM	 - pointer to the bottom of the stack
! 	TOP	 - pointer to the top of the stack
! 	STACK    - Start of context stack.
!          
!  Saving on and restoring from the context stack can be done by using the
!  VCRP_PUSH and VCRP_POP macros.
macro VCRP$A_STACK = 108,0,32,0 %;      !  Pointer stack block
macro VCRP$T_INTERNAL_STACK = 112,0,0,0 %;
literal VCRP$S_INTERNAL_STACK = 84;
!  VCRP scratch area.  This area is not guaranteed to be preserved across
!  VCM's.  It is intended to be used as VCM temporary data.
macro VCRP$T_SCRATCH = 196,0,0,0 %;
literal VCRP$S_SCRATCH = 64;
macro VCRP$T_DATA = 260,0,0,0 %;        !  Start of data (if embedded in the VCRP)
 
!*** MODULE $DCBEDEF ***
! +
!  DCBE - Data Chain Block
! 
!  The DCBE is the data structure used to chain data packets together.  A
!  chain may consist of on buffer or may buffers each pointed to by a DCBE.
!  the format of the DCBE is the same as a VCRP data request, so that a 
!  VCRP may be the first DCBE in the chain, and describe the entire 
!  data request.
! 
!  THE FORMAT OF THIS PACKET SHOULD NOT CHANGE WITHOUT CORRESPONDING CHANGES
!  BEING MAY TO A VCRP DATA REQUEST PACKET.
! -
literal DCBE$M_CMN_LOCKED = 1;
literal DCBE$M_CMN_RETBUF = 2;
literal DCBE$M_CMN_CACHE = 4;
literal DCBE$K_DCB_HEADER = 56;         !  Length of DCB header
literal DCBE$S_DCBEDEF = 56;
macro DCBE$L_FLINK = 0,0,32,0 %;        !  Forward Queue link
macro DCBE$L_BLINK = 4,0,32,0 %;        !  Backward Queue link
macro DCBE$W_SIZE = 8,0,16,0 %;         !  Size of structure
macro DCBE$B_TYPE = 10,0,8,0 %;         !  Type of structure - DYN$C_NET
macro DCBE$B_SUB_TYPE = 11,0,8,0 %;     !  Subtype of structure - DYN$C_VCI_DCB
macro DCBE$L_RESERVED = 12,0,0,1 %;
literal DCBE$S_RESERVED = 16;           !  Reserved to ensure that VCRP and
!   DCB look the same up to DCB_HEADER
macro DCBE$R_COMMON_FLAGS_OVERLAY = 28,0,16,0 %;
macro DCBE$W_COMMON_FLAGS = 28,0,16,0 %; !  Common flags used by all users of DCBs
macro DCBE$V_CMN_LOCKED = 28,0,1,0 %;   !  Indicates buffer is locked down for direct I/O
macro DCBE$V_CMN_RETBUF = 28,1,1,0 %;   !  Indicates buffer must be return to owner immediately
macro DCBE$V_CMN_CACHE = 28,2,1,0 %;    !  Indicates buffer came from creator's cache
macro DCBE$B_FLAGS = 30,0,8,0 %;        !  User controlled DCB flags
macro DCBE$B_MODE = 31,0,8,0 %;         !  
macro DCBE$A_DEALLOC_RTN = 32,0,32,0 %; !  Address of routine to deallocate VCRP
macro DCBE$A_DCB_LINK = 36,0,32,0 %;    !  Address of next DCB in chain
macro DCBE$L_SVAPTE = 40,0,32,0 %;      !  Address of System Virtual Address PTE
macro DCBE$L_BUFFER_ADDRESS = 44,0,32,0 %; !  VM Address of buffer specified in SVAPTE
macro DCBE$L_BOFF = 48,0,32,0 %;        !  Offset to start of data in buffer
macro DCBE$L_BCNT = 52,0,32,0 %;        !  Byte count of data in buffer
 
!*** MODULE $VCCDEF ***
! 
!  CFCB - Cache File Control Block
! 
!  There is one CFCB for each cacheable file.  The Cache File Control
!  Block contains the information necessary for consistent data caching
!  in a VAXcluster.  The FCB contains the address of the CFCB.
!  
literal CFCB$K_LENGTH = 136;
literal CFCB$S_CFCBDEF = 136;
!  head of CFCB is an ACB which we use as a FKB
macro CFCB$L_ASTQFL = 0,0,32,0 %;       !  AST queue FLINK
macro CFCB$L_ASTQBL = 4,0,32,0 %;       !  AST queue BLINK
macro CFCB$W_SIZE = 8,0,16,0 %;         !  size of CFCB in bytes
macro CFCB$B_TYPE = 10,0,8,0 %;         !  type is VCC, a subtypable structure
macro CFCB$B_SUBTYPE = 11,0,8,0 %;      !  subtype for CFCB and RMODE for ACB
macro CFCB$L_AST_PID = 12,0,32,0 %;     !  either accesser/deacceser or server
macro CFCB$L_AST_ADDR = 16,0,32,0 %;    !  address to resume process
macro CFCB$L_AST_PRM = 20,0,32,0 %;     !  the parameter
!  no KAST field needed
!  end of ACB
!  cells to control access to and type of cache mode lock
macro CFCB$Q_LKSB = 24,0,0,0 %;
literal CFCB$S_LKSB = 8;                !  whole LKSB
macro CFCB$W_LKSB_STATUS = 24,0,16,0 %; !  completion status
macro CFCB$W_RESERVED = 26,0,16,0 %;
macro CFCB$L_LOCKID = 28,0,32,0 %;      !  lockid of cache mode lock
macro CFCB$L_WAIT_PID = 32,0,32,0 %;    !  PID waiting for cache mode lock access
macro CFCB$L_WAIT_ADDR = 36,0,32,0 %;   !  address at which to resume process
macro CFCB$L_WAIT_PRM = 40,0,32,0 %;    !  AST parameter for waiting process
macro CFCB$L_WRITERS = 44,0,32,0 %;     !  number of reasons to keep write lock
macro CFCB$L_HASHTABLE = 48,0,32,0 %;   !  address of hash table data structure
macro CFCB$L_STATUS = 52,0,32,0 %;      !  
macro CFCB$V_SEQ = 52,0,1,0 %;          !  file is being accessed sequentially
!  these next 3 bits must be together
!  they indicate the current cache mode
macro CFCB$V_CONFLICT = 52,1,1,0 %;     !  this node's access conflicts with another node
macro CFCB$V_WRITE = 52,2,1,0 %;        !  set for read/write, clear read only
macro CFCB$V_NOLOCK = 52,3,1,0 %;       !  no cache mode lock held
!  status bits for accessing the cache mode lock
macro CFCB$V_BUSY = 52,4,1,0 %;         !  cache mode lock is being modified
macro CFCB$V_DELAYBLKAST = 52,5,1,0 %;  !  BLKAST arrived while CFCB busy
macro CFCB$V_DELAYCMPLAST = 52,6,1,0 %; !  CMPLAST arrived while CFCB busy
macro CFCB$V_DISBLKFRK = 52,7,1,0 %;    !  disable future blocking forks
macro CFCB$V_DISCMPLFRK = 52,8,1,0 %;   !  disable future completion forks
!  OTHER STATUS BITS
macro CFCB$V_LIMBO = 52,9,1,0 %;        !  set if CFCB in LIMBO
macro CFCB$V_BYPASS = 52,10,1,0 %;      !  If set don't cache IO requests
macro CFCB$V_TRUNCATE = 52,11,1,0 %;    !  If set, need to truncate cache
macro CFCB$V_DELETE = 52,12,1,0 %;
macro CFCB$V_NOPRESERVE = 52,13,1,0 %;  !  If set delet cache at $DEACCESS
!  counts of interesting things
macro CFCB$L_VREAD = 56,0,32,0 %;       !  virtual reads to this file
macro CFCB$L_READHIT = 60,0,32,0 %;     !  read hits to this file
macro CFCB$L_VWRITE = 64,0,32,0 %;      !  virtual writes to this file
macro CFCB$L_WRITEHIT = 68,0,32,0 %;    !  write hits to this file
macro CFCB$L_AROUND = 72,0,32,0 %;      !  read or writes "around" this cache
macro CFCB$L_BLOCKCNT = 76,0,32,0 %;    !  data blocks allocated to this file
macro CFCB$L_CLCNT = 80,0,32,0 %;       !  cache lines allocated to this file
macro CFCB$L_IOERRORS = 84,0,32,0 %;    !  number of I/O errors for this file
macro CFCB$L_LASTVBN = 88,0,32,0 %;     !  last VBN read/written
macro CFCB$L_HIVBN = 92,0,32,0 %;       !  largest VBN ever cached for this file
macro CFCB$L_FCB = 96,0,32,0 %;         !  FCB associated with this CFCB
macro CFCB$W_FILL1 = 100,0,16,0 %;
macro CFCB$W_OCNT = 102,0,16,0 %;       !  Count of Reasons not to delete CFCB
macro CFCB$B_DISABLE = 104,0,8,0 %;     !  number of reasons to disable caching
!  of this file even if cache mode lock
!  will allow caching
!  zero means caching is enabled
macro CFCB$W_LKQ_STATUS = 106,0,16,0 %; !  status of ENQ/DEQ request (not final)
macro CFCB$Q_FREE_CLP = 108,0,0,0 %;
literal CFCB$S_FREE_CLP = 8;            !  Queue for CLPs with free CLs
macro CFCB$L_TIME = 116,0,32,0 %;       !  Time put CFCB put in LIMBO 
macro CFCB$Q_LIMBO = 120,0,0,0 %;
literal CFCB$S_LIMBO = 8;               !  Queue of CFCB that are in LIMBO
macro CFCB$L_CID = 128,0,32,0 %;        !  Cache ID 
macro CFCB$L_CVCB = 132,0,32,0 %;       !  VCB address for this file
! 
!  HT - Hash Table
! 
!  There is one hash table for each cacheable file.  The Cache File Control
!  Block contains the address of the hash table.  Access requires owning the
!  cache spin lock.
literal HT$Q_HASHTABLE = 12;            !  start of hash table
literal HT$S_HTDEF = 12;
!  The cache line and hash table sizes are not constants.  They may vary for
!  different files. The size of each must be a power of two. The VBN is
!  subdivided into bitfields based on the cache line size and the size of
!  the hash table.  The lowest bits, <0,CLSIZE-1> represent the offset in
!  the cache line. Bits <CLSIZE-1, HASHSIZE> are the hash index. These
!  fields are accessed via bitfield instructions and the values of CLSIZE
!  and HASHSIZE are encoded to define bitfields NOT the actual size of the
!  entity. 
macro HT$L_FILL = 0,0,32,0 %;
macro HT$B_CLSIZE = 4,0,8,0 %;          !  encoded cache line size (see above)
macro HT$B_HASHSIZE = 5,0,8,0 %;        !  encoded hash table size (see above)
macro HT$W_FILL1 = 6,0,16,0 %;          !  longword align
macro HT$W_SIZE = 8,0,16,0 %;           !  size of hash table strcuture in bytes
macro HT$B_TYPE = 10,0,8,0 %;           !  type is VCC, a subtypable structure
macro HT$B_SUBTYPE = 11,0,8,0 %;        !  subtype for HT
! 
!  CL - Cache Line
! 
!  A Cache Line is used by the VAXcluster Cache to track per VBN information.
!  The hash table in the CFCB points to cache lines.
!  
literal CL$L_VA = 44;                   !  virtual addresses for data blocks
literal CL$K_LENGTH = 112;              !  Size of Cache Line(rounded)
!  Count VA array which is a constant
literal CL$S_CLDEF = 112;
macro CL$L_FLINK = 0,0,32,0 %;          !  Equivalence class forward link
macro CL$L_BLINK = 4,0,32,0 %;          !  Equivalence class back link
macro CL$W_SIZE = 8,0,16,0 %;           !  size of CL in bytes
macro CL$B_TYPE = 10,0,8,0 %;           !  type is VCC, a subtypable structure
macro CL$B_SUBTYPE = 11,0,8,0 %;        !  subtype for CL
macro CL$L_TIME = 12,0,32,0 %;          !  Time CL last referenced
macro CL$L_FIRSTVBN = 16,0,32,0 %;      !  first VBN in this cache line
macro CL$L_CFCB = 20,0,32,0 %;          !  address of corresponding CFCB 
macro CL$Q_LRUENTRY = 24,0,0,0 %;
literal CL$S_LRUENTRY = 8;              !  absolute queue entry in VCC$Q_LRULINE
macro CL$L_VALID = 32,0,32,0 %;         !  set if corresponding VBN data valid ;$2
macro CL$L_DIRTY = 36,0,32,0 %;         !  set if corresponding VBN data    ;$2
!  needs to be written before block
!  is reused
macro CL$L_LOCK = 40,0,32,0 %;          !   looks just like mutex
macro CL$W_COUNT = 40,0,16,0 %;         !  Count of current accessers
macro CL$V_WRITE = 40,16,1,0 %;         !  write in progress or pending
macro CL$V_DELAYTRUNC = 40,17,1,0 %;    !  delete this line during unlock
!  next entry must go at the end of the CL
!  of 16 entries and round up
! 
!  CLP - Cache Line Page
! 
!  A Cache Line Page is used by the VAXcluster Cache to store multiple Cache
!  Lines so that NON-PAGED Pool need not be used are the CL resource. 
!  
literal CLP$K_OVERHEAD = 32;            !  Size of CLP overhead
literal CLP$L_CL1 = 32;                 !  Offset to 1st Cache Line
literal CLP$L_CL2 = 144;                !  Offset to 2nd Cache Line
literal CLP$L_CL3 = 256;                !  Offset to 3rd Cache Line
literal CLP$L_CL4 = 368;                !  Offset to 4th Cache Line
literal CLP$S_CLPDEF = 480;
macro CLP$L_FLINK = 0,0,32,0 %;         !  Equivalence class forward link
macro CLP$L_BLINK = 4,0,32,0 %;         !  Equivalence class back link
macro CLP$L_A1 = 8,0,32,0 %;            !  Address of 1st Free Cache Line
!  (0 = in use)
macro CLP$L_A2 = 12,0,32,0 %;           !  Address of 2nd Free Cache Line
!  (0 = in use)
macro CLP$L_A3 = 16,0,32,0 %;           !  Address of 3rd Free Cache Line
!  (0 = in use)
macro CLP$L_A4 = 20,0,32,0 %;           !  Address of 4th Free Cache Line
!  (0 = in use)
macro CLP$L_ZERO = 24,0,32,0 %;         !  MBZ
macro CLP$L_FILL1 = 28,0,32,0 %;
! 
!  CPT - Cache I/O Page Table
! 
!  A range of sequential VBNs is not guarenteed to be virtually contiguous
!  in the cache.  Physical I/O requires the SVAPTE which maps the buffer.
!  The cache builds a "fake" page table in this data structure and passes
!  its virtual address as the SVAPTE.  In addition some per I/O cache
!  information is stored here rather than enlarge the IRP.
! 
literal CPT$L_PTE = 24;                 !  start of PTEs
literal CPT$K_LENGTH = 24;              !  not counting size of VA array
!  which is run time dependent
literal CPT$S_CPTDEF = 24;
macro CPT$L_RHBCNT = 0,0,32,0 %;        !  read hit byte count
macro CPT$L_IOVA = 4,0,32,0 %;          !  cache I/O VA
macro CPT$W_SIZE = 8,0,16,0 %;          !  size of CPT in bytes
macro CPT$B_TYPE = 10,0,8,0 %;          !  type is VCC, a subtypable structure
macro CPT$B_SUBTYPE = 11,0,8,0 %;       !  subtype for CPT
macro CPT$L_IOVBN = 12,0,32,0 %;        !  cache I/O VBN
macro CPT$L_IOBCNT = 16,0,32,0 %;       !  cache I/O byte count
macro CPT$L_CFCB = 20,0,32,0 %;         !  CFCB address for this I/O
!  real length equals IRP length
! 
!  CVCB - Cache Volume Control Block
! 
!  There is one of these structures for each ODS2 volume currently
!  mounted by this node.  It is used to permit detection of users
!  that perform writes to volumes around the cache, so that the
!  file caches concerned may be flushed.
! 
literal CVCB$K_LENGTH = 108;
literal CVCB$S_CVCBDEF = 108;
macro CVCB$L_FLINK = 0,0,32,0 %;
macro CVCB$L_BLINK = 4,0,32,0 %;
macro CVCB$W_SIZE = 8,0,16,0 %;
macro CVCB$B_TYPE = 10,0,8,0 %;
macro CVCB$B_SUBTYPE = 11,0,8,0 %;
macro CVCB$L_FRK1 = 12,0,32,0 %;        !  Fork Block 
macro CVCB$L_FRK2 = 16,0,32,0 %;        !  Fork Block 
macro CVCB$L_FRK3 = 20,0,32,0 %;        !  Fork Block 
macro CVCB$L_FRK4 = 24,0,32,0 %;        !  Fork Block 
macro CVCB$L_FRK5 = 28,0,32,0 %;        !  Fork Block 
macro CVCB$L_FRK6 = 32,0,32,0 %;        !  Fork Block 
macro CVCB$L_VCB = 36,0,32,0 %;         !  VCB address 
macro CVCB$L_CID = 40,0,32,0 %;         !  Cache ID (monatonicaly increasing)
macro CVCB$L_CLUID = 44,0,32,0 %;       !  Cluster ID (similar to CID)
macro CVCB$L_STATE = 48,0,32,0 %;
macro CVCB$V_ON = 48,0,1,0 %;           !  Set if cache enabled this Volume
macro CVCB$V_MISMTCH = 48,1,1,0 %;      !  Set if not CACHE SAFE Driver 
macro CVCB$V_DELETE = 48,2,1,0 %;       !  Set if Deleteing this CVCB
macro CVCB$V_BSY = 48,3,1,0 %;          !  Set if State change in progress
macro CVCB$V_CONFLICT = 48,4,1,0 %;     !  Set if MISMTCH Set somewhere in
! 	Cluster
macro CVCB$V_QIRP = 48,5,1,0 %;         !  Set if IRP's Q'd waiting for 
!   Cluster Invalidate
macro CVCB$W_OCNT = 52,0,16,0 %;        !  Count of Reasons not to Delete CVCB
macro CVCB$W_MNTCT = 54,0,16,0 %;       !  VCB$W_MNTCT at last State Change
macro CVCB$Q_IRP = 56,0,0,0 %;
literal CVCB$S_IRP = 8;                 !  Q for IRP's
macro CVCB$Q_LKSB = 64,0,0,0 %;
literal CVCB$S_LKSB = 8;                !  whole LKSB
macro CVCB$W_LKSB_STATUS = 64,0,16,0 %; !  completion status
macro CVCB$W_RESERVED = 66,0,16,0 %;
macro CVCB$L_LOCKID = 68,0,32,0 %;      !  lockid of Cache volume lock
macro CVCB$L_SEQ = 72,0,32,0 %;         !  Cluster MEMSEQ for Node Bits
macro CVCB$L_BITS = 76,0,32,0 %;        !  Node bits 
macro CVCB$L_BITS1 = 80,0,32,0 %;
macro CVCB$L_BITS2 = 84,0,32,0 %;
macro CVCB$L_BITS3 = 88,0,32,0 %;
macro CVCB$L_BITS4 = 92,0,32,0 %;
macro CVCB$L_BITS5 = 96,0,32,0 %;
macro CVCB$L_BITS6 = 100,0,32,0 %;
macro CVCB$L_BITS7 = 104,0,32,0 %;
! 
!  VBNJDEF - Constants for Internal Jump table
! 
!  These constants are used to permit a single entry point into the CACHE
!  module from SUBSYTEMS external to it.
! 
! 
literal VBNJ$K_ACCESS = 1;
literal VBNJ$K_BACKOUT_QIO = 2;
literal VBNJ$K_DEACCESS = 3;
literal VBNJ$K_DELETE_CFCB = 4;
literal VBNJ$K_DIRPOST = 5;
literal VBNJ$K_IOPOST = 6;
literal VBNJ$K_QIO = 7;
literal VBNJ$K_TRIM = 8;
literal VBNJ$K_TRUNCATE = 9;
literal VBNJ$K_WRITE_ARND = 10;
literal VBNJ$K_MOUNT = 11;
literal VBNJ$K_DISMOUNT = 12;
literal VBNJ$K_SET_VOL = 13;
literal VBNJ$K_SET_MAX = 14;
literal VBNJ$K_SET_MIN = 15;
literal VBNJ$K_SET_AGE = 16;
literal VBNJ$K_SET_FILE = 17;
literal VBNJ$K_SET_LIMBO = 18;
literal VBNJ$K_RET_CVCB = 19;
literal VBNJ$K_CACHE_SAFE = 20;
literal VBNJ$K_CACHE_SWAP = 21;
literal VBNJ$K_PAGE_IO = 22;
literal VBNJ$S_VBNJDEF = 4;
macro VBNJ$L_FILL = 0,0,32,0 %;
!  
!  Bits in SYSGEN parameter CACHE$GL_FLAGS
!  This is actually 4 one byte sysgen parameters.
! 	CACHE$GB_FLAGS0 - user "visible" dynamic
! 	CACHE$GB_FLAGS1 - user "visible" static
! 	CACHE$GB_FLAGS2 - user "invisible" dynamic
! 	CACHE$GB_FLAGS3 - user "invisible" static
!  
literal CACHE$M_ENABLE = 1;
literal CACHE$M_ALLOW = 256;
literal CACHE$M_CACHE = 65536;
literal CACHE$M_FCB = 131072;
literal CACHE$M_CLUSAFE = 16777216;
literal CACHE$S_CACHEDEF = 4;
macro CACHE$L_STATUS = 0,0,32,0 %;      !  
! **** start of byte 0 - dynamic
macro CACHE$V_ENABLE = 0,0,1,0 %;       !  cache enable/disable
!  only valid if ALLOW is set
! *** must be start of byte 1 - static
macro CACHE$V_ALLOW = 0,8,1,0 %;        !  caching possible on node
!   controls allocation of PTEs
!  user "less visible" last two bytes
! *** must be start of byte 2 - dynamic
macro CACHE$V_CACHE = 0,16,1,0 %;       !  temp for ICLUSTER
!   disable all cache functionality
macro CACHE$V_FCB = 0,17,1,0 %;         !  enable FCB preservation code
! **** must be start of byte 3 - static
macro CACHE$V_CLUSAFE = 0,24,1,0 %;     !  set if safe to cache in cluster
!   prohibits nodes LEQ 5.3 from cluster
! 
! 
 
!*** MODULE $VCTXDEF ***
! +
!  $VCTXDEF - vector context block definitions
! -
literal VCTX$M_SAVED = 1;
literal VCTX$M_IMP = 2;
literal VCTX$M_PMF = 4;
literal VCTX$M_AEX = 8;
literal VCTX$M_IVO = 16;
literal VCTX$M_VTB = 32;
literal VCTX$M_FAST_SWITCH = 64;
literal VCTX$M_SLOW_SWITCH = 128;
literal VCTX$K_LENGTH = 8240;           ! Length of VCTX, fixed portion
literal VCTX$C_LENGTH = 8240;           ! Length of VCTX, fixed portion
literal VCTX$S_VCTXDEF = 8248;
macro VCTX$L_PCB = 0,0,32,0 %;          ! Address of the PCB
macro VCTX$L_FLAGS = 4,0,32,0 %;        ! Flags longword
macro VCTX$V_SAVED = 4,0,1,0 %;         ! Vector context saved
macro VCTX$V_IMP = 4,1,1,0 %;           ! Hardware error pending
macro VCTX$V_PMF = 4,2,1,0 %;           ! Async memory mgmt exception
macro VCTX$V_AEX = 4,3,1,0 %;           ! Vector arithmetic excpetion
macro VCTX$V_IVO = 4,4,1,0 %;           ! Illegal vector opcode
macro VCTX$V_VTB = 4,5,1,0 %;           ! Invalidate Vector TB
macro VCTX$V_FAST_SWITCH = 4,6,1,0 %;   ! Fast VP switch
macro VCTX$V_SLOW_SWITCH = 4,7,1,0 %;   ! Slow VP switch
macro VCTX$W_SIZE = 8,0,16,0 %;         ! Size in bytes 
macro VCTX$B_TYPE = 10,0,8,0 %;         ! Structure type code 
macro VCTX$B_SUBTYPE = 11,0,8,0 %;      ! Subtype, unused
macro VCTX$L_MARGIN = 12,0,32,0 %;      ! Vector margin
macro VCTX$L_VEXCFL = 16,0,32,0 %;      ! Exception block flink
macro VCTX$L_VEXCBL = 20,0,32,0 %;      ! Exception block backlink
macro VCTX$L_VAER = 24,0,32,0 %;        ! Vector Arithmetic Error Register
macro VCTX$W_IVO = 28,0,16,0 %;         ! Illegal opcode
macro VCTX$B_VCR = 30,0,8,0 %;          ! Vector Count Register
macro VCTX$B_VLR = 31,0,8,0 %;          ! Vector Length Register
macro VCTX$Q_VMR = 32,0,0,0 %;
literal VCTX$S_VMR = 8;                 ! Vector Mask Register
macro VCTX$W_EXC_COUNT = 40,0,16,0 %;   ! Saved exception count
macro VCTX$W_SPARE_W = 42,0,16,0 %;     ! Spare word
macro VCTX$L_SPARE_L = 44,0,32,0 %;     ! Spare longword
! 
!   Note: the following must start on a quad-word boundary
! 
macro VCTX$R_V0 = 48,0,0,0 %;
literal VCTX$S_V0 = 512;                ! V0
macro VCTX$R_V1 = 560,0,0,0 %;
literal VCTX$S_V1 = 512;                ! V1
macro VCTX$R_V2 = 1072,0,0,0 %;
literal VCTX$S_V2 = 512;                ! V2
macro VCTX$R_V3 = 1584,0,0,0 %;
literal VCTX$S_V3 = 512;                ! V3
macro VCTX$R_V4 = 2096,0,0,0 %;
literal VCTX$S_V4 = 512;                ! V4
macro VCTX$R_V5 = 2608,0,0,0 %;
literal VCTX$S_V5 = 512;                ! V5
macro VCTX$R_V6 = 3120,0,0,0 %;
literal VCTX$S_V6 = 512;                ! V6
macro VCTX$R_V7 = 3632,0,0,0 %;
literal VCTX$S_V7 = 512;                ! V7
macro VCTX$R_V8 = 4144,0,0,0 %;
literal VCTX$S_V8 = 512;                ! V8
macro VCTX$R_V9 = 4656,0,0,0 %;
literal VCTX$S_V9 = 512;                ! V9
macro VCTX$R_V10 = 5168,0,0,0 %;
literal VCTX$S_V10 = 512;               ! V10
macro VCTX$R_V11 = 5680,0,0,0 %;
literal VCTX$S_V11 = 512;               ! V11
macro VCTX$R_V12 = 6192,0,0,0 %;
literal VCTX$S_V12 = 512;               ! V12
macro VCTX$R_V13 = 6704,0,0,0 %;
literal VCTX$S_V13 = 512;               ! V13
macro VCTX$R_V14 = 7216,0,0,0 %;
literal VCTX$S_V14 = 512;               ! V14
macro VCTX$R_V15 = 7728,0,0,0 %;
literal VCTX$S_V15 = 512;               ! V15
macro VCTX$R_ASYNC = 8240,0,0,0 %;
literal VCTX$S_ASYNC = 8;               ! Start of async mem mgmt portion
 
!*** MODULE $VECDISDEF ***
! +
! 
!  Flags definitions for [$ENABLE|$DISABLE]_VP_USE services.
! 
!  Note well: DEBUG understands the semantics of these flags. When adding
! 	      a new flag, we must contact DEBUG group so DEBUG can take
! 	      approprite action for this new flag.
! -
literal VECDIS$M_VALID_FLAGS = 31;
literal VECDIS$M_ASYNC_HANDLER = 1;
literal VECDIS$M_DEBUG = 2;
literal VECDIS$M_PCA = 4;
literal VECDIS$M_ADA = 8;
literal VECDIS$M_VVIEF = 16;
literal VECDIS$S_VECDISDEF = 1;
macro VECDIS$V_VALID_FLAGS = 0,0,5,0 %;
literal VECDIS$S_VALID_FLAGS = 5;
macro VECDIS$V_ASYNC_HANDLER = 0,0,1,0 %; ! VMS async handlers
macro VECDIS$V_DEBUG = 0,1,1,0 %;       ! DEBUG
macro VECDIS$V_PCA = 0,2,1,0 %;         ! PCA
macro VECDIS$V_ADA = 0,3,1,0 %;         ! ADA
macro VECDIS$V_VVIEF = 0,4,1,0 %;       ! VVIEF
 
!*** MODULE $VEXCDEF ***
! +
!  $VEXCDEF - vector exception block definitions
! -
literal VEXC$K_LENGTH = 28;             ! Length of VEXC, fixed protion
literal VEXC$C_LENGTH = 28;             ! Length of VEXC, fixed portion
literal VEXC$S_VEXCDEF = 36;
macro VEXC$L_FLINK = 0,0,32,0 %;        ! Forward link
macro VEXC$L_BLINK = 4,0,32,0 %;        ! Backward link
macro VEXC$W_SIZE = 8,0,16,0 %;         ! Size in bytes 
macro VEXC$B_TYPE = 10,0,8,0 %;         ! Structure type code 
macro VEXC$B_SUBTYPE = 11,0,8,0 %;      ! Subtype, unused
macro VEXC$W_CHECKSUM = 12,0,16,0 %;    ! Checksum
macro VEXC$W_SAVED_IVO = 14,0,16,0 %;   ! Saved IVO 
macro VEXC$L_SAVED_VPSR = 16,0,32,0 %;  ! Saved VPSR
macro VEXC$L_SAVED_VAER = 20,0,32,0 %;  ! Saved VAER
macro VEXC$L_PCB = 24,0,32,0 %;         ! back-pointer to the PCB.
macro VEXC$R_SAVED_ASYNC = 28,0,0,0 %;
literal VEXC$S_SAVED_ASYNC = 8;         ! Start of saved Async memory mgmt portion
 
!*** MODULE $VL1DEF ***
! +
!  VOL1 ANSI MAGNETIC TAPE LABEL
!  THIS IS THE FIRST BLOCK ON EVERY ANSI LABELED MAGNETIC TAPE.
!  IT IDENTIFIES THE VOLUME AND ITS PROTECTION.
! -
literal VL1$S_VL1DEF = 80;
macro VL1$L_VL1LID = 0,0,32,0 %;        ! LABEL IDENTIFIER AND NUMBER 'VOL1' 
macro VL1$T_VOLLBL = 4,0,0,0 %;
literal VL1$S_VOLLBL = 6;               ! VOLUME LABEL 
macro VL1$B_VOLACCESS = 10,0,8,0 %;     ! VOLUME ACCESS 
macro VL1$T_SYSCODE = 24,0,0,0 %;
literal VL1$S_SYSCODE = 13;             !  SYSTEM CODE
macro VL1$T_OWNER_IDENT = 37,0,0,0 %;
literal VL1$S_OWNER_IDENT = 14;         !  VOL1 OWNER ID FIELD
macro VL1$T_VOLOWNER = 37,0,0,0 %;
literal VL1$S_VOLOWNER = 13;            ! VOLUME OWNER IDENTIFICATION 
macro VL1$B_DECSTDVER = 50,0,8,0 %;     ! DEC STANDARD VERSION 
macro VL1$B_LBLSTDVER = 79,0,8,0 %;     ! LABEL STANDARD VERSION '3' 
 
!*** MODULE $VL2DEF ***
! +
!  VOL2 ANSI MAGNETIC TAPE LABEL
!  THIS IS BLOCK IS WRITTEN TO TAPES WHEN A VMS PROTECTION IS SPECIFIED
! -
literal VL2$S_VL2DEF = 19;
macro VL2$L_VL2LID = 0,0,32,0 %;        ! LABEL IDENTIFIER AND NUMBER 'VOL2' 
macro VL2$T_VOLOWNER = 4,0,0,0 %;
literal VL2$S_VOLOWNER = 15;            ! VOLUME OWNER IDENTIFICATION 
 
!*** MODULE $VPERRDEF ***
! +
! 
!  Bit definitions for EXE$VP_ERROR_ACTION routine.
! 
! -
literal VPERR$M_SAVE_CTX = 1;
literal VPERR$M_ABORT = 2;
literal VPERR$M_DECONFIG = 4;
literal VPERR$S_VPERRDEF = 4;
macro VPERR$V_SAVE_CTX = 0,0,1,0 %;     ! Save vector context
macro VPERR$V_ABORT = 0,1,1,0 %;        ! Abort vector consumer
macro VPERR$V_DECONFIG = 0,2,1,0 %;     ! Deconfigure vector processor
 
!*** MODULE $VPFLAGSDEF ***
! +
! 
!  Bit definitions for EXE$GL_VP_FLAGS - Vector Processing flags
! 
! -
literal EXE$M_VP_PRESENT = 1;
literal EXE$M_VP_LOAD = 2;
literal EXE$M_VP_EXTENDED_WAIT = -2147483648;
literal EXE$S_VPFLAGSDEF = 4;
macro EXE$V_VP_PRESENT = 0,0,1,0 %;     ! System is vector-present
macro EXE$V_VP_LOAD = 0,1,1,0 %;        ! Load vector processing code
macro EXE$V_VP_EXTENDED_WAIT = 0,31,1,0 %; ! FORTRAN/PPL extended wait algorithm
! +
! 
!  Bit definitions for CTL$GL_VP_FLAGS - Vector Processing flags
! 
! -
literal CTLVP$M_VECTOR_VVIEF = 1;
literal CTLVP$S_CTLVPFLAGSDEF = 1;
macro CTLVP$V_VECTOR_VVIEF = 0,0,1,0 %; ! Process is a vector-VVIEF consumer
 
!*** MODULE $VSBDEF ***
! +
!  $VSBDEF - Vector State Block Definitions
! -
literal VSB$K_TYPE = 11;                ! Structure type constant
literal VSB$C_TYPE = 11;                ! Structure type constant
literal VSB$K_SUBTYPE = 12;             ! Structure subtype constant
literal VSB$C_SUBTYPE = 12;             ! Structure subtype constant
literal VSB$K_MAJORID = 1000;           ! Major ID 
literal VSB$C_MAJORID = 1000;           ! Major ID 
literal VSB$K_MINORID = 1;              ! Minor ID 
literal VSB$C_MINORID = 1;              ! Minor ID 
literal VSB$K_LENGTH = 8352;            ! Length of VSB
literal VSB$C_LENGTH = 8352;            ! Length of VSB
literal VSB$S_VSBDEF = 8352;
macro VSB$L_FLINK = 0,0,32,0 %;         ! Forward link
macro VSB$L_BLINK = 4,0,32,0 %;         ! Backward link
macro VSB$W_SIZE = 8,0,16,0 %;          ! Size in bytes 
macro VSB$B_TYPE = 10,0,8,0 %;          ! Structure type code 
macro VSB$B_SUBTYPE = 11,0,8,0 %;       ! Subtype, unused
macro VSB$W_MAJORID = 12,0,16,0 %;      ! Structure Major ID
macro VSB$W_MINORID = 14,0,16,0 %;      ! Structure Minor ID
macro VSB$L_EXCID = 16,0,32,0 %;        ! exception ID
macro VSB$B_VCR = 20,0,8,0 %;           ! Vector Count Register
macro VSB$B_VLR = 21,0,8,0 %;           ! Vector Length Register
macro VSB$W_UNUSED = 22,0,16,0 %;       ! Unused word
macro VSB$Q_VMR = 24,0,0,0 %;
literal VSB$S_VMR = 8;                  ! Vector Mask Register
macro VSB$R_V0 = 32,0,0,0 %;
literal VSB$S_V0 = 512;                 ! V0, must be quadword aligned
macro VSB$R_V1 = 544,0,0,0 %;
literal VSB$S_V1 = 512;                 ! V1
macro VSB$R_V2 = 1056,0,0,0 %;
literal VSB$S_V2 = 512;                 ! V2
macro VSB$R_V3 = 1568,0,0,0 %;
literal VSB$S_V3 = 512;                 ! V3
macro VSB$R_V4 = 2080,0,0,0 %;
literal VSB$S_V4 = 512;                 ! V4
macro VSB$R_V5 = 2592,0,0,0 %;
literal VSB$S_V5 = 512;                 ! V5
macro VSB$R_V6 = 3104,0,0,0 %;
literal VSB$S_V6 = 512;                 ! V6
macro VSB$R_V7 = 3616,0,0,0 %;
literal VSB$S_V7 = 512;                 ! V7
macro VSB$R_V8 = 4128,0,0,0 %;
literal VSB$S_V8 = 512;                 ! V8
macro VSB$R_V9 = 4640,0,0,0 %;
literal VSB$S_V9 = 512;                 ! V9
macro VSB$R_V10 = 5152,0,0,0 %;
literal VSB$S_V10 = 512;                ! V10
macro VSB$R_V11 = 5664,0,0,0 %;
literal VSB$S_V11 = 512;                ! V11
macro VSB$R_V12 = 6176,0,0,0 %;
literal VSB$S_V12 = 512;                ! V12
macro VSB$R_V13 = 6688,0,0,0 %;
literal VSB$S_V13 = 512;                ! V13
macro VSB$R_V14 = 7200,0,0,0 %;
literal VSB$S_V14 = 512;                ! V14
macro VSB$R_V15 = 7712,0,0,0 %;
literal VSB$S_V15 = 512;                ! V15
macro VSB$R_SPARE = 8224,0,0,0 %;
literal VSB$S_SPARE = 128;              ! Spares for future expansion
 
!*** MODULE $VVIEFDEF ***
! +
!  Definitions for VVIEF Facility.
! 
! -
literal VVIEF$K_EXCEPTION = 0;          !  EXCEPTION EVENT
literal VVIEF$K_INIT = 1;               !  INITIALIZATION
literal VVIEF$K_DISABLE_VP_USE = 2;     !  SERVICE EVENT
literal VVIEF$K_ENABLE_VP_USE = 3;      !  SERVICE EVENT
literal VVIEF$K_SAVE_VP_EXCEPTION = 4;  !  SERVICE EVENT
literal VVIEF$K_RESTORE_VP_EXCEPTION = 5; !  SERVICE EVENT
literal VVIEF$K_RELEASE_VP = 6;         !  SERVICE EVENT 
 
!*** MODULE $WCBDEF ***
! +
!  WCB - WINDOW CONTROL BLOCK
! 
!  THERE IS A WINDOW CONTROL BLOCK FOR EACH FILE ACCESSED BY A PROCESS.
!  IT CONTAINS MAPPING INFORMATION SUCH THAT A LARGE PERCENTAGE OF VIRTUAL
!  FILE I/O CAN BE MAPPED FROM VIRTUAL TO LOGICAL BLOCK NUMBERS WITHOUT
!  HAVING TO READ THE RESPECTIVE FILE HEADER.
! -
literal WCB$M_READ = 1;
literal WCB$M_WRITE = 2;
literal WCB$M_NOTFCP = 4;
literal WCB$M_SHRWCB = 8;
literal WCB$M_OVERDRAWN = 16;
literal WCB$M_COMPLETE = 32;
literal WCB$M_CATHEDRAL = 64;
literal WCB$M_EXPIRE = 128;
literal WCB$M_CONTROL = 4096;
literal WCB$M_NO_READ_DATA = 8192;
literal WCB$K_MAP = 48;                 !  MAP POINTERS START HERE 
literal WCB$C_MAP = 48;                 !  MAP POINTERS START HERE 
literal WCB$K_LENGTH = 48;              !  LENGTH OF STANDARD WCB SANS POINTERS 
literal WCB$C_LENGTH = 48;              !  LENGTH OF STANDARD WCB SANS POINTERS 
!  NOTE THAT VIRTUAL MAPPING
literal WCB$S_WCBDEF = 60;
macro WCB$L_WLFL = 0,0,32,0 %;          !  WINDOW LIST FORWARD LINK 
macro WCB$L_WLBL = 4,0,32,0 %;          !  WINDOW LIST BACKWARD LINK 
macro WCB$W_SIZE = 8,0,16,0 %;          !  SIZE OF WINDOW BLOCK IN BYTES 
macro WCB$B_TYPE = 10,0,8,0 %;          !  STRUCTURE TYPE OF WCB 
macro WCB$B_ACCESS = 11,0,8,0 %;        !  ACCESS CONTROL BYTE 
macro WCB$V_READ = 11,0,1,0 %;          !  READ ACCESS ALLOWED (1=YES) 
macro WCB$V_WRITE = 11,1,1,0 %;         !  WRITE ACCESS ALLOWED (1=YES) 
macro WCB$V_NOTFCP = 11,2,1,0 %;        !  FILE NOT ACCESSED BY FCP IF SET 
macro WCB$V_SHRWCB = 11,3,1,0 %;        !  SHARED WINDOW 
macro WCB$V_OVERDRAWN = 11,4,1,0 %;     !  FILE ACCESSOR HAS OVERDRAWN HIS QUOTA 
macro WCB$V_COMPLETE = 11,5,1,0 %;      !  SET WINDOW MAPS ENTIRE FILE 
macro WCB$V_CATHEDRAL = 11,6,1,0 %;     !  LARGE, COMPLEX WINDOW (SIC) TO MAP 
!  FILE COMPLETELY
macro WCB$V_EXPIRE = 11,7,1,0 %;        !  FILE EXPIRATION DATE MAY NEED TO BE SET 
macro WCB$L_PID = 12,0,32,0 %;          !  PROCESS ID OF ACCESSOR PROCESS 
macro WCB$W_REFCNT = 14,0,16,0 %;       !  REFERENCE COUNT FOR SHARED WINDOW 
macro WCB$L_ORGUCB = 16,0,32,0 %;       !  ADDRESS OF ORIGINAL UCB FROM CCB 
macro WCB$W_ACON = 20,0,16,0 %;         !  ACCESS CONTROL INFORMATION 
!  NOTE - THESE BITS TRACK THE BITS
!  IN FIB$L_ACCTL
macro WCB$V_NOWRITE = 20,0,1,0 %;       !  NO OTHER WRITERS 
macro WCB$V_DLOCK = 20,1,1,0 %;         !  ENABLE DEACCESS LOCK 
macro WCB$V_SPOOL = 20,4,1,0 %;         !  SPOOL FILE ON CLOSE 
macro WCB$V_WRITECK = 20,5,1,0 %;       !  ENABLE WRITE CHECK 
macro WCB$V_SEQONLY = 20,6,1,0 %;       !  SEQUENTIAL ONLY ACCESS 
macro WCB$V_SNAPSHOT = 20,7,1,0 %;      !  SNAPSHOT REVALIDATION PENDING
macro WCB$V_WRITEAC = 20,8,1,0 %;       !  WRITE ACCESS 
macro WCB$V_READCK = 20,9,1,0 %;        !  ENABLE READ CHECK 
macro WCB$V_NOREAD = 20,10,1,0 %;       !  NO OTHER READERS 
macro WCB$V_NOTRUNC = 20,11,1,0 %;      !  NO TRUNCATES
macro WCB$V_CONTROL = 20,12,1,0 %;      !  CONTROL ACCESS TO FILE
macro WCB$V_NO_READ_DATA = 20,13,1,0 %; !  NO READ ACCESS TO FILE DATA
!  THE FOLLOWING FIELD OVERLAYS THE FIRST
!  UNUSED FLAG IN WCB$W_ACON ABOVE.
macro WCB$V_NOACCLOCK = 20,2,1,0 %;     !  NO ACCESS LOCK CHECKING
macro WCB$V_READINIT = 20,14,1,0 %;     !  A READINIT WAS DONE OVER THIS CHANNEL 
macro WCB$V_WRITE_TURN = 20,15,1,0 %;   !  FORCE WINDOW TURN ON WRITES
!  SIZE DEVICE INDEPENDENT PART OF WCB
macro WCB$W_NMAP = 22,0,16,0 %;         !  NUMBER OF MAPPING POINTERS 
macro WCB$L_FCB = 24,0,32,0 %;          !  ADDRESS OF FCB 
macro WCB$L_RVT = 28,0,32,0 %;          !  ADDRESS OF RELATIVE VOLUME TABLE 
macro WCB$L_LINK = 32,0,32,0 %;         !  LINK TO NEXT WINDOW SEGMENT 
macro WCB$L_READS = 36,0,32,0 %;        !  COUNT OF READS PERFORMED 
macro WCB$L_WRITES = 40,0,32,0 %;       !  COUNT OF WRITES PERFORMED 
macro WCB$L_STVBN = 44,0,32,0 %;        !  STARTING VBN MAPPED BY WINDOW 
!  NEEDS P1_COUNT IMMEDIATELY
!  FOLLOWING STVBN
macro WCB$W_P1_COUNT = 48,0,16,0 %;     !  COUNT FIELD OF FIRST POINTER 
macro WCB$L_P1_LBN = 50,0,32,0 %;       !  LBN FIELD OF SECOND POINTER 
macro WCB$W_P2_COUNT = 54,0,16,0 %;     !  COUNT FIELD OF SECOND POINTER 
macro WCB$L_P2_LBN = 56,0,32,0 %;       !  LBN FIELD OF FIRST POINTER 
!  FORMAT OF RETRIEVAL POINTER
literal WCB$S_WCBDEF1 = 6;
macro WCB$W_COUNT = 0,0,16,0 %;         !  COUNT FIELD 
macro WCB$L_LBN = 2,0,32,0 %;           !  LBN FIELD 
literal WCB$S_WCBDEF2 = 7;
macro WCB$W_PREVCOUNT = -6,0,16,0 %;    !  PREVIOUS RETRIEVAL POINTER 
macro WCB$L_PREVLBN = -4,0,32,0 %;
!  RETRIEVAL POINTER FORMAT
 
!*** MODULE $WPREDEF ***
literal WPRE$K_LEN = 20;
literal WPRE$S_WPREDEF = 20;
macro WPRE$L_ORIGSPTE = 0,0,32,0 %;     !  Original SPTE value to restore.
macro WPRE$L_NEWSPTE = 4,0,32,0 %;      !  SPTE value when Watchpoint in place.
macro WPRE$L_SVAPTE = 8,0,32,0 %;       !  SVA of SPTE.
macro WPRE$L_INVALSVA = 12,0,32,0 %;    !  Addr to inval after resetting SPTE.
macro WPRE$L_WPCB = 16,0,32,0 %;        !  Addr of corresponding WPCB.
 
!*** MODULE $WPCBDEF ***
literal WPCB$K_LEN = 176;               !  Length of WPCB structure.
literal WPCB$S_WPCBDEF = 176;
macro WPCB$Q_INITCNTNTS = 0,0,0,0 %;
literal WPCB$S_INITCNTNTS = 8;          !  Initial contents of Watchpoint field.
macro WPCB$W_SIZE = 8,0,16,0 %;         !  Length of this block.
macro WPCB$B_TYPE = 10,0,8,0 %;         !  Type of this block.
macro WPCB$B_RESERVED01 = 11,0,8,0 %;   !  Reserved.
macro WPCB$B_FLD_LEN = 12,0,8,0 %;      !  Length of field to be trace (1-7).
macro WPCB$B_STATE = 13,0,8,0 %;        !  Type of watchpoint.
macro WPCB$W_RESERVED02 = 14,0,16,0 %;  !  Reserved.
macro WPCB$L_LINK = 16,0,32,0 %;        !  Linked list of WPCB's on a WPRE.
macro WPCB$L_WPRE = 20,0,32,0 %;        !  Address of associated WPRE.
!  The following group of longwords contain the addresses of the individual
!  bytes in the filed to be monitored.  Only WPCB$FLD_LEN of the 8 addresses
!  are valid.
macro WPCB$L_FLD_ADR = 24,0,32,0 %;     !  Address of start of field.
macro WPCB$L_FLD_ADR1 = 28,0,32,0 %;    !  Address of next byte of field.
macro WPCB$L_FLD_ADR2 = 32,0,32,0 %;    !  Address of next byte of field.
macro WPCB$L_FLD_ADR3 = 36,0,32,0 %;    !  Address of next byte of field.
macro WPCB$L_FLD_ADR4 = 40,0,32,0 %;    !  Address of next byte of field.
macro WPCB$L_FLD_ADR5 = 44,0,32,0 %;    !  Address of next byte of field.
macro WPCB$L_FLD_ADR6 = 48,0,32,0 %;    !  Address of next byte of field.
macro WPCB$L_FLD_ADR7 = 52,0,32,0 %;    !  Address of next byte of field.
!  The following group of fields are values stored at the last time that the
!  monitored field was touched.  The values are a subset of the values stored
!  in the circular trace buffer.
macro WPCB$L_TOUCHED = 56,0,32,0 %;     !  Address actually touched.
macro WPCB$L_COUNT = 60,0,32,0 %;       !  Number of times Watch Point touched.
macro WPCB$L_TTE = 64,0,32,0 %;         !  Address of last circular Trace Table
!   Entry associated with this field.
macro WPCB$L_PC = 68,0,32,0 %;          !  PC of instruction that touched Watch
!   Point.
macro WPCB$L_PSL = 72,0,32,0 %;         !  PSL at time that Watch Point touched.
macro WPCB$Q_TIME = 76,0,0,0 %;
literal WPCB$S_TIME = 8;                !  System time when last updated.
macro WPCB$L_R0 = 84,0,32,0 %;          !  R0  at time this entry last updated.
macro WPCB$L_R1 = 88,0,32,0 %;          !  R1  at time this entry last updated.
macro WPCB$L_R2 = 92,0,32,0 %;          !  R2  at time this entry last updated.
macro WPCB$L_R3 = 96,0,32,0 %;          !  R3  at time this entry last updated.
macro WPCB$L_R4 = 100,0,32,0 %;         !  R4  at time this entry last updated.
macro WPCB$L_R5 = 104,0,32,0 %;         !  R5  at time this entry last updated.
macro WPCB$L_R6 = 108,0,32,0 %;         !  R6  at time this entry last updated.
macro WPCB$L_R7 = 112,0,32,0 %;         !  R7  at time this entry last updated.
macro WPCB$L_R8 = 116,0,32,0 %;         !  R8  at time this entry last updated.
macro WPCB$L_R9 = 120,0,32,0 %;         !  R9  at time this entry last updated.
macro WPCB$L_R10 = 124,0,32,0 %;        !  R10 at time this entry last updated.
macro WPCB$L_R11 = 128,0,32,0 %;        !  R11 at time this entry last updated.
macro WPCB$L_AP = 132,0,32,0 %;         !  AP  at time this entry last updated.
macro WPCB$L_FP = 136,0,32,0 %;         !  FP  at time this entry last updated.
macro WPCB$L_SP = 140,0,32,0 %;         !  SP  at time this entry last updated.
macro WPCB$B_BCNT = 144,0,8,0 %;        !  Count of bytes of I-stream traced.
macro WPCB$T_ISTREAM = 145,0,0,0 %;
literal WPCB$S_ISTREAM = 15;            !  Space for tracing upto 15 bytes.
macro WPCB$Q_PREVCNTNTS = 160,0,0,0 %;
literal WPCB$S_PREVCNTNTS = 8;          !  Contents of Watchpoint field before
!   this access.
macro WPCB$Q_POSTCNTNTS = 168,0,0,0 %;
literal WPCB$S_POSTCNTNTS = 8;          !  Contents of Watchpoint field after
!   this access.
literal WPCB_STATE$M_READ = 1;
literal WPCB_STATE$M_FATAL = 2;
literal WPCB_STATE$M_BPT = 4;
literal WPCB_STATE$S_STATE = 1;         !  Set of state bits.
macro WPCB_STATE$V_READ = 0,0,1,0 %;    !  0 => Write WP, 1 => Read WP.
macro WPCB_STATE$V_FATAL = 0,1,1,0 %;   !  1 implies CRASH system on WRITE access
macro WPCB_STATE$V_BPT = 0,2,1,0 %;     !  1 implies Cause XDELTA Breakpoint
 
!*** MODULE $WPTTEDEF ***
literal WPTTE$K_LEN = 32;               !  Length of a TTE.
literal WPTTE$K_HEADER_LEN = 12;        !  Length of Trace Table Header
literal WPTTE$K_PARALLEL_LEN = 4;       !  Length of Parallel arrary entry
literal WPTTE$S_WPTTEDEF = 32;
macro WPTTE$L_FIELD = 0,0,32,0 %;       !  Address of field touched.
macro WPTTE$B_TOUCHED = 4,0,8,0 %;      !  Relative byte within field touched.
macro WPTTE$B_OPCODE = 5,0,8,0 %;       !  Opcode of instruction for this access.
macro WPTTE$W_RELBCKPTR = 6,0,16,0 %;   !  Offset, relative to base of Trace
!   Table of previous trace entry for
!   this Watchpoint (%xFFFF means invalid
macro WPTTE$L_PC = 8,0,32,0 %;          !  PC of instruction that touched field.
macro WPTTE$L_PSL = 12,0,32,0 %;        !  PSL at time field touched.
macro WPTTE$Q_TIME = 16,0,0,0 %;
literal WPTTE$S_TIME = 8;               !  System Time at time field touched.
macro WPTTE$Q_PREVCNTNTS = 24,0,0,0 %;
literal WPTTE$S_PREVCNTNTS = 8;         !  Contents of Watchpoint before this
!   access.
 
!*** MODULE $WSLDEF ***
! +
!  WORKING SET LIST DEFINITIONS
! -
literal WSL$M_VALID = 1;
literal WSL$M_PAGTYP = 14;
literal WSL$M_PFNLOCK = 16;
literal WSL$M_WSLOCK = 32;
literal WSL$M_GOODPAGE = 64;
literal WSL$M_MODIFY = 256;
literal WSL$C_LENGTH = 4;               ! SIZE OF WS LIST ENTRY 
! 
literal WSL$C_PROCESS = 0;              ! PROCESS PAGE 
literal WSL$C_SYSTEM = 2;               ! SYSTEM PAGE 
literal WSL$C_GLOBAL = 4;               ! GLOBAL PAGE (READ ONLY) 
literal WSL$C_GBLWRT = 6;               ! GLOBAL WRITABLE PAGE 
literal WSL$C_PPGTBL = 8;               ! PROCESS PAGE TABLE 
literal WSL$C_GPGTBL = 10;              ! GLOBAL PAGE TABLE 
literal WSL$S_WSLDEF = 2;
macro WSL$V_VALID = 0,0,1,0 %;          ! WSL ENTRY VALID 
macro WSL$V_PAGTYP = 0,1,3,0 %;
literal WSL$S_PAGTYP = 3;               ! PAGE TYPE (SEE PFNDEF FOR VALUES) 
macro WSL$V_PFNLOCK = 0,4,1,0 %;        ! PAGE FRAME LOCK 
! THE PRECEDING 5 BITS MUST BE IN ORDER
macro WSL$V_WSLOCK = 0,5,1,0 %;         ! WORKING SET LOCK 
macro WSL$V_GOODPAGE = 0,6,1,0 %;       ! THIS PAGE SHOULD REMAIN IN WS ONE MORE PASS 
macro WSL$V_MODIFY = 0,8,1,0 %;         ! SAVED MODIFY BIT 
! THE FOLLOWING 5 BITS MUST BE IN ORDER
!  PAGE TYPE VIELD DEFINITIONS
! 
! 	N.B.:	These constants have been adjusted by left-shifting the constant by the offset to the field WSL$V_PAGTYP.  
! 		To use these when explicitly extracting the field, the adjustment must be removed.  For example:
! 
! 		   IF .wsle [wsl$v_pagtyp] EQL (wsl$c_system^-1)		! Or (wsl$c_system/2)
! 
 
!*** MODULE $WQHDEF ***
! +
!  WAIT QUEUE HEADER DEFINITIONS
! -
literal WQH$K_LENGTH = 12;              ! LENGTH OF WAIT QUEUE HEADER 
literal WQH$C_LENGTH = 12;              ! LENGTH OF WAIT QUEUE HEADER 
literal WQH$S_WQHDEF = 12;
macro WQH$L_WQFL = 0,0,32,0 %;          ! HEAD OR FORWARD LINK 
macro WQH$L_WQBL = 4,0,32,0 %;          ! TAIL OR BACKWARD LINK 
macro WQH$W_WQCNT = 8,0,16,0 %;         ! WAIT QUEUE COUNT 
macro WQH$W_WQSTATE = 10,0,16,0 %;      ! STATE NUMBER FOR WAIT 
 
!*** MODULE $XBIDEF ***
! +
!  XBI and XBI-Plus unique registers
! -
literal XBI$M_PE_CPU = 1;
literal XBI$M_PE_CAB = 2;
literal XBI$M_PE_DATAB = 4;
literal XBI$M_PE_CA = 8;
literal XBI$M_PE_DATA = 16;
literal XBI$M_POWER = 32;
literal XBI$M_WRFAIL = 64;
literal XBI$M_INTERNAL = 128;
literal XBI$M_CABLE_OK = -2147483648;
literal XBIP$M_INVALID_BI_ADDR = 256;
literal XBIP$M_UNCOR_DMA_ECC = 512;
literal XBIP$M_COR_DMA_ECC = 1024;
literal XBIP$M_INVALID_PFN = 2048;
literal XBIP$M_UNCOR_PMR_ECC = 4096;
literal XBIP$M_COR_PMR_ECC = 8192;
literal XBIP$M_MULT_ERR = 16384;
literal XBI$M_INTR_PECPU = 1;
literal XBI$M_INTR_PECB = 2;
literal XBI$M_INTR_PEBDATA = 4;
literal XBI$M_INTR_PECA = 8;
literal XBI$M_INTR_PEADATA = 16;
literal XBI$M_INTR_POWER = 32;
literal XBI$M_INTR_WRFAIL = 64;
literal XBI$M_INTR_INTERNAL = 128;
literal XBI$M_INTR_CNAK = 32768;
literal XBI$M_INTR_RER = 65536;
literal XBI$M_INTR_RSE = 131072;
literal XBI$M_INTR_NRR = 262144;
literal XBI$M_INTR_CRD = 524288;
literal XBI$M_INTR_WDNAK = 1048576;
literal XBI$M_INTR_RIDNAK = 2097152;
literal XBI$M_INTR_WSE = 4194304;
literal XBI$M_INTR_PE = 8388608;
literal XBI$M_INTR_IPE = 67108864;
literal XBI$M_INTR_CC = 134217728;
literal XBI$M_ENAB_IVINTR = -2147483648;
literal XBIP$M_INTR_INVALID_ADDR = 256;
literal XBIP$M_INTR_UNCOR_ECC = 512;
literal XBIP$M_INTR_COR_ECC = 1024;
literal XBIP$M_INTR_IPFN = 2048;
literal XBIP$M_INTR_TTO = 8192;
literal XBIP$M_BIWIN = 16383;
literal XBIP$M_ENA_34BIT = 131072;
literal XBIP$M_MR_MD = 786432;
literal XBIP$M_TLIM = 15728640;
literal XBIP$M_LDEASRT = 251658240;
literal XBIP$M_LLIM = -268435456;
literal XBIP_AUTLR$K_DWMBA_MODE = 0;    !  DWMBA compatibility mode
literal XBIP_AUTLR$K_512B_MODE = 1;     !  512 Byte page mode
literal XBIP_AUTLR$K_4KB_MODE = 2;      !  4Kb page mode
literal XBIP_AUTLR$K_8KB_MODE = 3;      !  8Kb page mode
literal XBIP$M_RVR_DISABLE = 2;
literal XBIP$M_ME_ENA = 8;
literal XBIP$M_RES_REQ_ENA = 16;
literal XBIP$M_BIWIN_ENA = 32;
literal XBIP$M_LOCKOUT_ASSERT_ENA = 128;
literal XBIP$M_LOCKOUT_RESP_ENA = 256;
literal XBIP$M_SHORT_TMO_ENA = 512;
literal XBIP$M_ECC_SYND = 536739840;
literal XBIP$M_PMR_READY = 536870912;
literal XBIP$M_CONTROL_RESET = 1073741824;
literal XBIP$M_WMASK = 65535;
literal XBIP$M_ADDR_EXT = 67043328;
literal XBIP$M_FILL_1 = 201326592;
literal XBIP$M_FCMD = -268435456;
literal XBI$M_ENAB_IBUSPE = 1;
literal XBI$M_ENAB_IRFAIL = 4;
literal XBI$M_BI_BAD = 16;
literal XBI$M_ENAB_XBI = -2147483648;
literal XBI$M_IBUS_PE = 1;
literal XBI$M_IDENT = 2;
literal XBI$M_IRFAIL = 4;
literal XBI$M_NOCOMMD = 8;
literal XBI$M_MS_FAIL = 16;
literal XBI$M_SST_FAIL = 32;
literal XBI$M_CA_FAIL = 64;
literal XBI$M_CPUERROR = 128;
literal XBI$M_PENDING = 4096;
literal XBI$M_FORCE_PARERR = 4;
literal XBI$M_LOOPBACK = 8;
literal XBI$M_FLIP_BIT29 = 16;
literal XBI$M_FLIP_FADDR = 64;
literal XBIP$M_PFN = 1073741823;
literal XBIP$M_PMRE_30 = 1073741824;
literal XBIP$M_VALID = -2147483648;
literal XBI$S_XBIDEF = 262656;
macro XBI$L_AREAR = 12,0,32,0 %;        !  Responder Error Address
macro XBI$V_RFADR = 12,0,30,0 %;
literal XBI$S_RFADR = 30;               !  Failing Address
macro XBI$V_RFLN = 12,30,2,0 %;
literal XBI$S_RFLN = 2;                 !  Responder Failing length
macro XBI$L_AESR = 16,0,32,0 %;         !  XBIA Error Summary
macro XBI$V_PE_CPU = 16,0,1,0 %;        !  Parity error on CPU data
macro XBI$V_PE_CAB = 16,1,1,0 %;        !  Parity error on DMA-B C/A
macro XBI$V_PE_DATAB = 16,2,1,0 %;      !  Parity error on data B
macro XBI$V_PE_CA = 16,3,1,0 %;         !  Parity error on C/A location
macro XBI$V_PE_DATA = 16,4,1,0 %;       !  Parity error on data location
macro XBI$V_POWER = 16,5,1,0 %;         !  BCI AC LO
macro XBI$V_WRFAIL = 16,6,1,0 %;        !  I/O write failure
macro XBI$V_INTERNAL = 16,7,1,0 %;      !  Unexplained internal error
macro XBI$V_ECMD = 16,16,4,0 %;
literal XBI$S_ECMD = 4;                 !  Failing Command
macro XBI$V_EID = 16,20,6,0 %;
literal XBI$S_EID = 6;                  !  Failing Commander ID
macro XBI$V_CABLE_OK = 16,31,1,0 %;     !  XBI Cable OK
macro XBIP$V_INVALID_BI_ADDR = 16,8,1,0 %; !  Invalid BI address 
macro XBIP$V_UNCOR_DMA_ECC = 16,9,1,0 %; !  Uncorrectable DMA ECC error 
macro XBIP$V_COR_DMA_ECC = 16,10,1,0 %; !  Correctable DMA ECC error 
macro XBIP$V_INVALID_PFN = 16,11,1,0 %; !  Invalid PFN 
macro XBIP$V_UNCOR_PMR_ECC = 16,12,1,0 %; !  Uncorrectable PMR ECC error
macro XBIP$V_COR_PMR_ECC = 16,13,1,0 %; !  Correctable PMR ECC error 
macro XBIP$V_MULT_ERR = 16,14,1,0 %;    !  Multiply errors 
macro XBI$L_AIMR = 20,0,32,0 %;         !  XBIA Interrupt Mask
macro XBI$V_INTR_PECPU = 20,0,1,0 %;    !  INTR on CPU data parity error
macro XBI$V_INTR_PECB = 20,1,1,0 %;     !  INTR on DMA-B C/A parity error
macro XBI$V_INTR_PEBDATA = 20,2,1,0 %;  !  INTR on DMA-B data parity error
macro XBI$V_INTR_PECA = 20,3,1,0 %;     !  INTR on DMA-A C/A parity error
macro XBI$V_INTR_PEADATA = 20,4,1,0 %;  !  INTR on DMA-A data parity error
macro XBI$V_INTR_POWER = 20,5,1,0 %;    !  INTR on BCI AC LO
macro XBI$V_INTR_WRFAIL = 20,6,1,0 %;   !  INTR on I/O write fail
macro XBI$V_INTR_INTERNAL = 20,7,1,0 %; !  INTR on internal error
macro XBI$V_INTR_CNAK = 20,15,1,0 %;    !  INTR on Command NOACK
macro XBI$V_INTR_RER = 20,16,1,0 %;     !  INTR on Read Error Response
macro XBI$V_INTR_RSE = 20,17,1,0 %;     !  INTR on Read Sequence error
macro XBI$V_INTR_NRR = 20,18,1,0 %;     !  INTR on No Read Response
macro XBI$V_INTR_CRD = 20,19,1,0 %;     !  INTR on Corrected Read Data
macro XBI$V_INTR_WDNAK = 20,20,1,0 %;   !  INTR on Write Data NOACK 
macro XBI$V_INTR_RIDNAK = 20,21,1,0 %;  !  INTR on Read/IDENT DATA NOACK
macro XBI$V_INTR_WSE = 20,22,1,0 %;     !  INTR on Write Sequence Error
macro XBI$V_INTR_PE = 20,23,1,0 %;      !  INTR on Parity Error
macro XBI$V_INTR_IPE = 20,26,1,0 %;     !  INTR on Inconsistant PE
macro XBI$V_INTR_CC = 20,27,1,0 %;      !  INTR on Corrected Confirmation
macro XBI$V_ENAB_IVINTR = 20,31,1,0 %;  !  Enable IVINTR transactions
macro XBIP$V_INTR_INVALID_ADDR = 20,8,1,0 %; !  INTR on invalid BI address 
macro XBIP$V_INTR_UNCOR_ECC = 20,9,1,0 %; !  INTR on Uncorrectable ECC error 
macro XBIP$V_INTR_COR_ECC = 20,10,1,0 %; !  INTR on Correctable ECC error
macro XBIP$V_INTR_IPFN = 20,11,1,0 %;   !  INTR on Invalid PFN 
macro XBIP$V_INTR_TTO = 20,13,1,0 %;    !  INTR on Transaction Timeout 
macro XBI$L_AIVINTR = 24,0,32,0 %;      !  XBIA Implied Vector Interrupt
!  Destination
macro XBI$W_IVINTR = 24,0,16,0 %;       !  IVINTR destination mask
macro XBI$L_ADG1 = 28,0,32,0 %;         !  XBIA Diagnostic Reg. 1
!  The following registers are only available on the XBI-Plus
macro XBIP$L_AUTLR = 32,0,32,0 %;       !  XBI-Plus Utility register
macro XBIP$V_BIWIN = 32,0,14,0 %;
literal XBIP$S_BIWIN = 14;              !  BI window space
macro XBIP$V_ENA_34BIT = 32,17,1,0 %;   !  Enable 34-bit addressing
macro XBIP$V_MR_MD = 32,18,2,0 %;
literal XBIP$S_MR_MD = 2;               !  Mapping register mode
macro XBIP$V_TLIM = 32,20,4,0 %;
literal XBIP$S_TLIM = 4;                !  Timeout Limit
macro XBIP$V_LDEASRT = 32,24,4,0 %;
literal XBIP$S_LDEASRT = 4;             !  Lockout deassertion
macro XBIP$V_LLIM = 32,28,4,0 %;
literal XBIP$S_LLIM = 4;                !  Lockout limit
!  XBI-Plus operational modes
macro XBIP$L_ACSR = 36,0,32,0 %;        !  XBI-Plus Control and Status register
macro XBIP$V_RVR_DISABLE = 36,1,1,0 %;  !  RVR vector disable
macro XBIP$V_ME_ENA = 36,3,1,0 %;       !  Multiple interrupt enable
macro XBIP$V_RES_REQ_ENA = 36,4,1,0 %;  !  Responder request enable
macro XBIP$V_BIWIN_ENA = 36,5,1,0 %;    !  BI window space enable
macro XBIP$V_LOCKOUT_ASSERT_ENA = 36,7,1,0 %; !  Lockout assert enable
macro XBIP$V_LOCKOUT_RESP_ENA = 36,8,1,0 %; !  Lockout response enable
macro XBIP$V_SHORT_TMO_ENA = 36,9,1,0 %; !  Short timeout enable
macro XBIP$V_ECC_SYND = 36,17,12,0 %;
literal XBIP$S_ECC_SYND = 12;           !  ECC syndrome
macro XBIP$V_PMR_READY = 36,29,1,0 %;   !  PMR ready
macro XBIP$V_CONTROL_RESET = 36,30,1,0 %; !  Control reset
macro XBIP$L_ARVR = 40,0,32,0 %;        !  Vector returned on RER (XBI-Plus)
macro XBIP$L_XFAER = 44,0,32,0 %;       !  XMI Failing addr extension (XBI-Plus)                                 
macro XBIP$V_WMASK = 44,0,16,0 %;
literal XBIP$S_WMASK = 16;              !  Write mask
macro XBIP$V_ADDR_EXT = 44,16,10,0 %;
literal XBIP$S_ADDR_EXT = 10;           !  FADR address extension
macro XBIP$V_FCMD = 44,28,4,0 %;
literal XBIP$S_FCMD = 4;                !  Failed command
macro XBIP$L_ABEAR = 52,0,32,0 %;       !  Failing VAXBI address (XBI-Plus)
!  End of additional XBI-Plus register
macro XBI$L_BCSR = 64,0,32,0 %;         !  XBIB Control/Status
macro XBI$V_ENAB_IBUSPE = 64,0,1,0 %;   !  IBUS Parity err. interrupt mask
macro XBI$V_ENAB_IRFAIL = 64,2,1,0 %;   !  Interlock Read fail mask
macro XBI$V_BI_BAD = 64,4,1,0 %;        !  BI BAD
macro XBI$V_ENAB_XBI = 64,31,1,0 %;     !  Enable XBI interrupts
macro XBI$L_BESR = 68,0,32,0 %;         !  XBIB Error Summary
macro XBI$V_IBUS_PE = 68,0,1,0 %;       !  IBUS Parity Error
macro XBI$V_IDENT = 68,1,1,0 %;         !  IDENT error
macro XBI$V_IRFAIL = 68,2,1,0 %;        !  BI interlock read failed
macro XBI$V_NOCOMMD = 68,3,1,0 %;       !  Illegal command
macro XBI$V_MS_FAIL = 68,4,1,0 %;       !  Master Sequencer failed
macro XBI$V_SST_FAIL = 68,5,1,0 %;      !  Slave Sequencer Trans. failed
macro XBI$V_CA_FAIL = 68,6,1,0 %;       !  Command Address fetch failed
macro XBI$V_CPUERROR = 68,7,1,0 %;      !  Multiple CPU errors
macro XBI$V_BIPEND = 68,8,4,0 %;
literal XBI$S_BIPEND = 4;               !  BI Interrupt Pending
macro XBI$V_PENDING = 68,12,1,0 %;      !  XBI Interrupt Pending
macro XBI$V_ISSF = 68,13,4,0 %;
literal XBI$S_ISSF = 4;                 !  Interrupt Sent Status Flops
macro XBI$L_BIDR = 72,0,32,0 %;         !  XBIB Interrupt Destination
macro XBI$W_IDR = 72,0,16,0 %;          !  Interrupt destination mask
macro XBI$W_DIAG = 74,0,16,0 %;         !  For diagnostics
macro XBI$L_BTIM = 76,0,32,0 %;         !  XBIB Timeout Address
macro XBI$V_DMA_ADDR = 76,0,30,0 %;
literal XBI$S_DMA_ADDR = 30;            !  Failing Address
macro XBI$V_LEN = 76,30,2,0 %;
literal XBI$S_LEN = 2;                  !  Responder Failing length
macro XBI$L_BVOR = 80,0,32,0 %;         !  XBIB Vector Offset
macro XBI$V_VECOFF = 80,9,7,0 %;
literal XBI$S_VECOFF = 7;               !  XBI Vector Offset
macro XBI$L_BVR = 84,0,32,0 %;          !  XBIB vector register
macro XBI$V_VECTOR = 84,2,14,0 %;
literal XBI$S_VECTOR = 14;              !  XBI vector
macro XBI$L_BDCR1 = 88,0,32,0 %;        !  XBIB Diagnostic Control
macro XBI$V_FORCE_PARERR = 88,2,1,0 %;  !  Force BCI parity error
macro XBI$V_LOOPBACK = 88,3,1,0 %;      !  BIIC Loopback mode
macro XBI$V_FLIP_BIT29 = 88,4,1,0 %;    !  Flip Bit 29
macro XBI$V_FLIP_FADDR = 88,6,1,0 %;    !  Flip FADDR address bit 1
!  The following register is only available on the XBI-Plus
macro XBIP$L_PMR = 512,0,0,0 %;
literal XBIP$S_PMR = 262144;            !  Page map registers 64K
macro XBIP$V_PFN = 512,0,30,0 %;
literal XBIP$S_PFN = 30;                !  PFN of VAXBI page
macro XBIP$V_PMRE_30 = 512,30,1,0 %;    !  Diagnostic use only
macro XBIP$V_VALID = 512,31,1,0 %;      !  PFN is valid
 
!*** MODULE $XCPDEF ***
! +
!   XCP Offset Definitions for Registers Accessible Through XMI Private
!   Space.  Note that in making these registers available in virtual space,
!   we have only mapped real registers.  Therefore these virtual offsets are
!   different than the hardware physical offsets.
! -
literal XCP$M_FPBD = 16;
literal XCP$M_FPEEUE = 32;
literal XCP$M_XACLO = 64;
literal XCP$M_STL = 128;
literal XCP$M_DLOCKOUTE = 1024;
literal XCP$M_STPLED = 2048;
literal XCP$M_FHIT = 131072;
literal XCP$M_FMISS = 262144;
literal XCP$M_FBTP = 524288;
literal XCP$M_FCI = 1048576;
literal XCP$M_CPUD = 2097152;
literal XCP$M_FPSEL = 4194304;
literal XCP$M_FCACHEEN = 8388608;
literal XCP$M_LOCKOUTD = 33554432;
literal XCP$M_KMODE = 128;
literal XCP$M_WBD = 256;
literal XCP$M_ARD = 512;
literal XCP$M_ESI = 1024;
literal XCP$M_RUP = 2048;
literal XCP$M_TOS = 4096;
literal XCP$M_CRDID = 16384;
literal XCP$M_CCID = 32768;
literal XCP$M_WS = 65536;
literal XCP$M_BPD = 131072;
literal XCP$M_BP = 262144;
literal XCP$M_CNAKR = 524288;
literal XCP$M_UWP = 1048576;
literal XCP$M_LOCKOUT0 = 2097152;
literal XCP$M_LOCKOUT1 = 4194304;
literal XCP$M_DTPE = 67108864;
literal XCP$M_CFE = 134217728;
literal XCP$M_WDPE = 268435456;
literal XCP$M_IQO = 536870912;
literal XCP$M_TPE = 1073741824;
literal XCP$M_VBPE = -2147483648;
literal XCP$S_XCPDEF = 1540;
macro XCP$L_CSR1 = 0,0,32,0 %;          !  XCP Control/Status Register
macro XCP$V_NODE_ID = 0,0,4,0 %;
literal XCP$S_NODE_ID = 4;              !  Node ID
macro XCP$V_FPBD = 0,4,1,0 %;           !  Front Panel Boot Disable
macro XCP$V_FPEEUE = 0,5,1,0 %;         !  Front Panel EEROM Update Enable
macro XCP$V_XACLO = 0,6,1,0 %;          !  XMI AC LO
macro XCP$V_STL = 0,7,1,0 %;            !  Selftest loop
macro XCP$V_EEWADR = 0,8,2,0 %;
literal XCP$S_EEWADR = 2;               !  EEPROM Write Address
macro XCP$V_DLOCKOUTE = 0,10,1,0 %;     !  Delayed Lockout enabled
macro XCP$V_STPLED = 0,11,1,0 %;        !  Self-test Pass LED
macro XCP$V_STATLEDS = 0,12,5,0 %;
literal XCP$S_STATLEDS = 5;             !  Status LEDS D6-D2
macro XCP$V_FHIT = 0,17,1,0 %;          !  Force Hit
macro XCP$V_FMISS = 0,18,1,0 %;         !  Force Miss
macro XCP$V_FBTP = 0,19,1,0 %;          !  Force Bad Tag Parity
macro XCP$V_FCI = 0,20,1,0 %;           !  Force Cache Invalidate
macro XCP$V_CPUD = 0,21,1,0 %;          !  Cache Parity Update Disable
macro XCP$V_FPSEL = 0,22,1,0 %;         !  Force Parity Select
macro XCP$V_FCACHEEN = 0,23,1,0 %;      !  Force Cache Enable
macro XCP$V_LOCKOUTD = 0,25,1,0 %;      !  Lockout disabled
macro XCP$L_XGPR = 12,0,32,0 %;         !  XMI General Purpose register
macro XCP$L_CSR2 = 16,0,32,0 %;         !  XCP Control/Status register
macro XCP$V_GAREV = 16,0,4,0 %;
literal XCP$S_GAREV = 4;                !  Gate Array Revision
macro XCP$V_FP = 16,4,3,0 %;
literal XCP$S_FP = 3;                   !  Force Parity
macro XCP$V_KMODE = 16,7,1,0 %;         !  Kludge Mode
macro XCP$V_WBD = 16,8,1,0 %;           !  Write Buffer Disable
macro XCP$V_ARD = 16,9,1,0 %;           !  Auto Retry Disable
macro XCP$V_ESI = 16,10,1,0 %;          !  Enable Self Invalidates
macro XCP$V_RUP = 16,11,1,0 %;          !  Read Upper
macro XCP$V_TOS = 16,12,1,0 %;          !  Timeout Select
macro XCP$V_CRDID = 16,14,1,0 %;        !  CRD Interrupt Disable
macro XCP$V_CCID = 16,15,1,0 %;         !  CC Interrupt Disable
macro XCP$V_WS = 16,16,1,0 %;           !  Warm start
macro XCP$V_BPD = 16,17,1,0 %;          !  Boot processor disabled
macro XCP$V_BP = 16,18,1,0 %;           !  Boot processor
macro XCP$V_CNAKR = 16,19,1,0 %;        !  Commander NOACK received
macro XCP$V_UWP = 16,20,1,0 %;          !  Unlock Write Pending
macro XCP$V_LOCKOUT0 = 16,21,1,0 %;     !  Interlock lockout
macro XCP$V_LOCKOUT1 = 16,22,1,0 %;     !  Interlock lockout
macro XCP$V_DTPE = 16,26,1,0 %;         !  Duplicate Tag Parity Error
macro XCP$V_CFE = 16,27,1,0 %;          !  Cache Fill Error
macro XCP$V_WDPE = 16,28,1,0 %;         !  Write Data Parity Error
macro XCP$V_IQO = 16,29,1,0 %;          !  INVAL Queue Overflow
macro XCP$V_TPE = 16,30,1,0 %;          !  TAG parity error
macro XCP$V_VBPE = 16,31,1,0 %;         !  Valid Bit Parity error
!  +4.
macro XCP$L_SYSTYPE = 516,0,32,0 %;     !  System Type Register
macro XCP$L_CONSEL = 1072,0,32,0 %;
macro XCP$L_TCR0 = 1280,0,32,0 %;
macro XCP$L_TIR0 = 1284,0,32,0 %;
macro XCP$L_TNIR0 = 1288,0,32,0 %;
macro XCP$L_TIVR0 = 1292,0,32,0 %;
macro XCP$L_TCR1 = 1296,0,32,0 %;
macro XCP$L_TIR1 = 1300,0,32,0 %;
macro XCP$L_TNIR1 = 1304,0,32,0 %;
macro XCP$L_TIVR1 = 1308,0,32,0 %;
macro XCP$L_IPIVINTR = 1536,0,32,0 %;   !  Interprocessor communication area.
 
!*** MODULE $XGDEF ***
literal XG$C_PRIXMT = 0;                !  Primary xmt use vector slot 0 
literal XG$C_SECXMT = 1;                !  Secondary xmt use vector slot 1 
literal XG$C_PRIRCV = 2;                !  Primary rcv use vector slot 2 
literal XG$C_SECRCV = 3;                !  Secondary rcv use vector slot 3 
literal XG$C_RCV_CSR = 0;               !  Receive CSR 
literal XG$C_XMT_CSR = 2;               !  Transmit CSR 
literal XG$C_MISC_REG = 4;              !  Set misc bits 
literal XG$C_IND_ADDR = 6;              !  Use to access the ind reg (IR) 
literal XG$C_PROTOCOL = 0;              !  0th IR def's the protocol char 
literal XG$C_RCV_ERR = 1;               !  1st IR def's rcv errors 
literal XG$C_XMT_ERR = 2;               !  2nd IR def's xmt errors 
literal XG$C_SYNC = 3;                  !  3rd IR def's sync charateristics 
literal XG$C_MODEM = 4;                 !  4th IR def's modem state change 
literal XG$C_STN_ADDR = 5;              !  5th IR use to set station address 
literal XG$C_PRI_RCV = 6;               !  6th and 7th IR used to define 
literal XG$C_PRI_RCV1 = 7;              !  primary rcv buffer and address 
literal XG$C_SEC_RCV = 8;               !  8th and 9th IR used to define 
literal XG$C_SEC_RCV1 = 9;              !  secondary rcv buffer and address 
literal XG$C_PRI_XMT = 10;              !  10th and 11th IR used to define 
literal XG$C_PRI_XMT1 = 11;             !  primary xmt buffer and address 
literal XG$C_SEC_XMT = 12;              !  12th and 13th IR used to define 
literal XG$C_SEC_XMT1 = 13;             !  secondary xmt buffer and address 
literal XG$C_TERM_CHAR = 14;            !  14th used to describe term char 
literal XG$C_FREE = 15;                 !  15th unused register 
!  Bit def's for RCV and XMT CSR
literal XG$M_ENABLE = 1;
literal XG$M_PRM_SEC = 4;
literal XG$M_TERM_IDL = 8;
literal XG$M_DATA_SET_IE = 16;
literal XG$M_INT_ENABLE = 32;
literal XG$M_ACT_DSC = 64;
literal XG$M_DONE_S = 128;
literal XG$M_ILP_XCS = 256;
literal XG$M_LOOP_TYPE = 1536;
literal XG$M_RESIDUAL = 4096;
literal XG$M_PRI_SEC_STN = 8192;
literal XG$M_ERROR = 16384;
literal XG$M_DONE_P = 32768;
literal XG$M_MASTER_RESET = 128;
literal XG$M_USER_RCV_FLAG = 1024;
literal XG$M_CTS_FLAG = 4096;
literal XG$M_CARRIER_FLAG = 8192;
literal XG$M_RING_FLAG = 16384;
literal XG$M_DSR_FLAG = 32768;
literal XG$M_STRIP_SYNC = 64;
literal XG$M_LATENCY_RCV = 2;
literal XG$M_NXM_RCV = 4;
literal XG$M_BCC_ERR = 8;
literal XG$M_VRC_ERR = 16;
literal XG$M_ABORT = 32;
literal XG$M_BUFOVR = 64;
literal XG$M_RES_BIT_CNT = 1792;
literal XG$M_MSG_LEN = 1;
literal XG$M_NXM_XMT = 2;
literal XG$M_LATENCY_XMT = 4;
literal XG$M_CTS = 16;
literal XG$M_CARRIER = 32;
literal XG$M_RING_IND = 64;
literal XG$M_DSR = 128;
literal XG$M_USER_XMT = 256;
literal XG$M_DTR = 512;
literal XG$M_DATA_SGNL = 1024;
literal XG$M_RTS = 4096;
literal XG$C_INTCLK_OFF = 0;            !  No internal clock 
literal XG$C_INTCLK_ON = 1;             !  Set internal clock 
!  Error control definitions IR0<0:3>
literal XG$C_ERR_CRC1 = 0;              !  CRC-CCITT preset to 1's 
literal XG$C_ERR_CRC0 = 1;              !  CRC-CCITT preset to 0's 
literal XG$C_ERR_LVE = 2;               !  LRC/VRC even 
literal XG$C_ERR_CRC16 = 3;             !  CRC-16 preset to 0's 
literal XG$C_ERR_LRCO = 4;              !  LRC odd 
literal XG$C_ERR_LRCE = 5;              !  LRC even 
literal XG$C_ERR_LVO = 6;               !  LRC/VRC odd 
literal XG$C_NOCON = 7;                 !  No error control 
!  Protocol definitions  IR0<3:3>
literal XG$C_PRO_DDCMP = 0;             !  DDCMP 
literal XG$C_PRO_SDLC = 1;              !  SDLC 
literal XG$C_PRO_HDLC = 2;              !  HDLC 
literal XG$C_BISYNC = 3;                !  BISYNC 
literal XG$C_GENBYTE = 7;               !  General byte 
!  Bits per char definitions. RCV: IR0<8:10>  XMT:IR0<13:15>
literal XG$C_BPC_8 = 0;
literal XG$C_BPC_1 = 1;
literal XG$C_BPC_2 = 2;
literal XG$C_BPC_3 = 3;
literal XG$C_BPC_4 = 4;
literal XG$C_BPC_5 = 5;
literal XG$C_BPC_6 = 6;
literal XG$C_BPC_7 = 7;
!  Baud rate generator definitions IR2<8:11>
literal XG$C_BRG_800 = 0;
literal XG$C_BRG_1200 = 1;
literal XG$C_BRG_1760 = 2;
literal XG$C_BRG_2152 = 3;
literal XG$C_BRG_2400 = 4;
literal XG$C_BRG_4800 = 5;
literal XG$C_BRG_9600 = 6;
literal XG$C_BRG_19200 = 7;
!  Sync character definitions IR3<8:15>
literal XG$C_SYNC_DDCMP = 150;          !  Set sync character to HEX 96 
literal XG$C_SYNC_HDLC = 0;             !  Set no sync character 
literal XG$C_SYNC_BISYNC = 50;          !  Set sync character to HEX 32 
!  Struct of parameter buffer
literal XG$S_XGDEF = 2;
macro XG$V_ENABLE = 0,0,1,0 %;          !  Enable the receiver 
macro XG$V_PRM_SEC = 0,2,1,0 %;         !  0 = prim 1 = sec buffer and addr 
macro XG$V_TERM_IDL = 0,3,1,0 %;        !  Term char for RCV's Idle for XMT's 
macro XG$V_DATA_SET_IE = 0,4,1,0 %;     !  Enable intrpts for data set change 
macro XG$V_INT_ENABLE = 0,5,1,0 %;      !  Enable intrpts for rcv and xmt's 
macro XG$V_ACT_DSC = 0,6,1,0 %;         !  Active (rcv's) Data set change (xmt') 
macro XG$V_DONE_S = 0,7,1,0 %;          !  Sec buffer proceesing is finished 
macro XG$V_ILP_XCS = 0,8,1,0 %;         !  Interal loopback (rcv) XMT clock src 
macro XG$V_LOOP_TYPE = 0,9,2,0 %;
literal XG$S_LOOP_TYPE = 2;             !  Loopb type for devices like CPI which support many 
macro XG$V_RESIDUAL = 0,12,1,0 %;       !  Bit protocols only 
macro XG$V_PRI_SEC_STN = 0,13,1,0 %;    !  0 = control 1 = tributary station 
macro XG$V_ERROR = 0,14,1,0 %;          !  Error on rcv or xmt 
macro XG$V_DONE_P = 0,15,1,0 %;         !  Primary buffer processing complete 
!  Misc reg definitions
macro XG$V_IND_REG = 0,0,4,0 %;
literal XG$S_IND_REG = 4;               !  Ind reg address to access 
macro XG$V_MASTER_RESET = 0,7,1,0 %;    !  Master reset bit 
macro XG$V_USER_RCV_FLAG = 0,10,1,0 %;  !  User receive flag 
macro XG$V_CTS_FLAG = 0,12,1,0 %;       !  Clear to send flag 
macro XG$V_CARRIER_FLAG = 0,13,1,0 %;   !  Carrier detect flag 
macro XG$V_RING_FLAG = 0,14,1,0 %;      !  Ring indicator flag 
macro XG$V_DSR_FLAG = 0,15,1,0 %;       !  Data set ready flag 
!  Protocol parameter definitions Indirect register 0
macro XG$V_ERR_CNTRL = 0,0,3,0 %;
literal XG$S_ERR_CNTRL = 3;             !  Error control def CRC_CCITT 1's 
macro XG$V_PROTOCOL = 0,3,3,0 %;
literal XG$S_PROTOCOL = 3;              !  Protocol type def DDCMP 
macro XG$V_STRIP_SYNC = 0,6,1,0 %;      !  Set to strip excess sync characters 
macro XG$V_RCV_BPC = 0,8,3,0 %;
literal XG$S_RCV_BPC = 3;               !  RCV bits/char default is 8 
macro XG$V_XMT_RCV = 0,13,3,0 %;
literal XG$S_XMT_RCV = 3;               !  XMT bits/char default is 8 
!  Receive errors definitions Indirect register 1
macro XG$V_LATENCY_RCV = 0,1,1,0 %;     !  RCV latency error 
macro XG$V_NXM_RCV = 0,2,1,0 %;         !  Non-existant memory error 
macro XG$V_BCC_ERR = 0,3,1,0 %;         !  Block check error 
macro XG$V_VRC_ERR = 0,4,1,0 %;         !  Byte prot only char parity error 
macro XG$V_ABORT = 0,5,1,0 %;           !  Bit prot only 
macro XG$V_BUFOVR = 0,6,1,0 %;          !  When char COUNT and msg len aren't eq 
macro XG$V_RES_BIT_CNT = 0,8,3,0 %;
literal XG$S_RES_BIT_CNT = 3;           !  Residual bit count 
!  Transmit error definitions Indirect register 2
macro XG$V_MSG_LEN = 0,0,1,0 %;         !  Char count indicates a buff too small 
macro XG$V_NXM_XMT = 0,1,1,0 %;         !  Non existant memory 
macro XG$V_LATENCY_XMT = 0,2,1,0 %;     !  XMT latency error 
macro XG$V_XMT_BRG = 0,8,4,0 %;
literal XG$S_XMT_BRG = 4;               !  Baud rate 
!  Sync information definitions Indirect register 3
macro XG$V_NMB_OF_SYNC = 0,0,5,0 %;
literal XG$S_NMB_OF_SYNC = 5;           !  Number of syncs to send bettweenmsgs 
macro XG$V_SYNC = 0,8,8,0 %;
literal XG$S_SYNC = 8;                  !  Contains the sync char 
!  Data set change register Indirect register 4
macro XG$V_CTS = 0,4,1,0 %;             !  Clear to send 
macro XG$V_CARRIER = 0,5,1,0 %;         !  Carrier detect 
macro XG$V_RING_IND = 0,6,1,0 %;        !  Ring indicator 
macro XG$V_DSR = 0,7,1,0 %;             !  Data set ready 
macro XG$V_USER_XMT = 0,8,1,0 %;        !  User transmit 
macro XG$V_DTR = 0,9,1,0 %;             !  Data terminal ready 
macro XG$V_DATA_SGNL = 0,10,1,0 %;      !  Data signal rate 
macro XG$V_RTS = 0,12,1,0 %;            !  Request to send 
!  Internal clock def's TX.CSR<8>
literal XG$M_BUFFER_CHAR = 1;
literal XG$M_BUFFER_IN_PREV_POS = 2;
literal XG$M_COMPLETE_READ = 4;
literal XG$M_NEW_FRAME = -2147483648;
literal XG$S_XGDEF1 = 13;
macro XG$B_ERR_CNTRL = 0,0,8,0 %;       !  Set the type of error control to use 
macro XG$B_PROTOCOL = 1,0,8,0 %;        !  Set protocol type 
macro XG$B_TX_BPC = 2,0,8,0 %;          !  Set XMT bits per char 
macro XG$B_RX_BPC = 3,0,8,0 %;          !  Set RCV bits per char 
macro XG$B_BAUD = 4,0,8,0 %;            !  Set line speed 
macro XG$B_NUM_SYNC = 5,0,8,0 %;        !  Set number of sync to send 
macro XG$B_SYNC_REG = 6,0,8,0 %;        !  Set sync char to send 
macro XG$B_ICLK = 7,0,8,0 %;            !  Set the internal clock 
macro XG$B_BPC = 8,0,8,0 %;             !  RCV/XMT bits per char 
macro XG$B_MNTLOOP = 9,0,8,0 %;         !  Maint loopb type 
! 
!  Bit def for interface with the frame routine
! 
!  XG$V_BUFFER_CHAR         clear        Buffer char in the next position
!                         set         Use XG$V_BUFFER_IN_PREV_POS
!  XG$V_BUFFER_IN_PREV_POS
!                         clear        ignore the char
!                         set        Buffer in previous position
!  XG$V_COMPLETE_READ        set        complete framed buffer to user
! 
macro XG$V_BUFFER_CHAR = 9,0,1,0 %;
macro XG$V_BUFFER_IN_PREV_POS = 9,1,1,0 %;
macro XG$V_COMPLETE_READ = 9,2,1,0 %;
macro XG$V_NEW_FRAME = 9,31,1,0 %;      !  set if new rcv message 
 
!*** MODULE $XJADEF ***
! +
!  XJA Register Offset Definitions
! -
literal XJA_ERRS$M_XMI_PWR_UP = 1048576;
literal XJA_ERRS$M_XMI_PWR_FAIL = 2097152;
literal XJA_ERRS$M_XMI_ARB_TMO = 4194304;
literal XJA_ERRS$M_CBI_PARITY = 8388608;
literal XJA_ERRS$M_JXDI_CMD_LEN_ERR = 16777216;
literal XJA_ERRS$M_JXDI_RCVBUF_OVRUN = 33554432;
literal XJA_ERRS$M_CPU_REQ_OVRUN = 67108864;
literal XJA_ERRS$M_ICU_BUF_CNT_ERR = 134217728;
literal XJA_ERRS$M_XCE_TRNS_ENT_MCHERR = 268435456;
literal XJA_ERRS$M_MUL_JXDI_PARITY = 536870912;
literal XJA_ERRS$M_JXDI_PARITY_0 = 1073741824;
literal XJA_ERRS$M_JXDI_PARITY_1 = -2147483648;
literal XJA_FCMD$M_FORCE = 1;
literal XJA_DIAG$M_DIAG_MODE = 536870912;
literal XJA_DIAG$M_FLIP_ADDR_BIT_29 = 1073741824;
literal XJA_DIAG$M_FRC_LCL_XJA_REG_ACC = -2147483648;
literal XJA_DMAFADDR$M_FAILING_ADDR_29 = 536870912;
literal XJA_ERRINTR$M_IE_XMI_ARB_TMO = 1;
literal XJA_ERRINTR$M_IE_JXDI_PARITYERR = 2;
literal XJA_ERRINTR$M_IE_TRANS_TMO = 8192;
literal XJA_ERRINTR$M_IE_TRANSMIT_ERR = 16384;
literal XJA_ERRINTR$M_IE_CMD_NOACK = 32768;
literal XJA_ERRINTR$M_IE_READ_ERR_RSP = 65536;
literal XJA_ERRINTR$M_IE_READ_SEQ_ERR = 131072;
literal XJA_ERRINTR$M_IE_NO_READ_RSP = 262144;
literal XJA_ERRINTR$M_IE_CRD = 524288;
literal XJA_ERRINTR$M_IE_WR_DATA_NOACK = 1048576;
literal XJA_ERRINTR$M_IE_IDN_DATA_NOACK = 2097152;
literal XJA_ERRINTR$M_IE_WRITE_SEQ_ERR = 4194304;
literal XJA_ERRINTR$M_IE_PARITY_ERR = 8388608;
literal XJA_ERRINTR$M_IE_INCON_PARITY = 16777216;
literal XJA_ERRINTR$M_IE_CC = 134217728;
literal XJA$S_XJADEF = 80;
! +
!  XJA Registers
! -
macro XJA$L_ERRS = 0,0,32,0 %;
macro XJA_ERRS$V_CPU_ID = 0,0,6,0 %;
literal XJA_ERRS$S_CPU_ID = 6;          !  CPU ID of most recent operation
macro XJA_ERRS$V_XMI_PWR_UP = 0,20,1,0 %; !  XMI power up
macro XJA_ERRS$V_XMI_PWR_FAIL = 0,21,1,0 %; !  XMI power fail
macro XJA_ERRS$V_XMI_ARB_TMO = 0,22,1,0 %; !  XMI arbitration timeout
macro XJA_ERRS$V_CBI_PARITY = 0,23,1,0 %; !  CBI parity error
macro XJA_ERRS$V_JXDI_CMD_LEN_ERR = 0,24,1,0 %; !  JXDI Command/Length error
macro XJA_ERRS$V_JXDI_RCVBUF_OVRUN = 0,25,1,0 %; !  JXDI Receive Buffer Overrun
macro XJA_ERRS$V_CPU_REQ_OVRUN = 0,26,1,0 %; !  CPU Request overrun
macro XJA_ERRS$V_ICU_BUF_CNT_ERR = 0,27,1,0 %; !  ICU Buffer Count Error
macro XJA_ERRS$V_XCE_TRNS_ENT_MCHERR = 0,28,1,0 %; !  XCE_Transmit Entry Machine Error
macro XJA_ERRS$V_MUL_JXDI_PARITY = 0,29,1,0 %; !  Multiple JXDI Parity Errors
macro XJA_ERRS$V_JXDI_PARITY_0 = 0,30,1,0 %; !  JXDI Parity Error on JXDI Byte 0
macro XJA_ERRS$V_JXDI_PARITY_1 = 0,31,1,0 %; !  JXDI Parity Error on JXDI Byte 1
macro XJA$L_FCMD = 4,0,32,0 %;
macro XJA_FCMD$V_FORCE = 4,0,1,0 %;     !  Force XMI Command Cycle
macro XJA_FCMD$V_XMI_ADDR_25_1 = 4,1,25,0 %;
literal XJA_FCMD$S_XMI_ADDR_25_1 = 25;  !  XMI Address [25:1]
macro XJA_FCMD$V_CMD = 4,26,4,0 %;
literal XJA_FCMD$S_CMD = 4;             !  Command
macro XJA_FCMD$V_LEN = 4,30,2,0 %;
literal XJA_FCMD$S_LEN = 2;             !  XMI Length Code
macro XJA$L_IPINTRSRC = 8,0,32,0 %;
macro XJA_IPINTRSRC$V_SOURCE = 8,0,16,0 %;
literal XJA_IPINTRSRC$S_SOURCE = 16;    !  Interrupt Source
macro XJA$L_DIAG = 12,0,32,0 %;
macro XJA_DIAG$V_FRC_PARITY_ERR = 12,0,4,0 %;
literal XJA_DIAG$S_FRC_PARITY_ERR = 4;  !  Force Parity Error
macro XJA_DIAG$V_FRC_XMI_RCV_BUFBSY = 12,4,4,0 %;
literal XJA_DIAG$S_FRC_XMI_RCV_BUFBSY = 4; !  Force XMI Receive Buffer Busy
macro XJA_DIAG$V_LW_READ_SEL = 12,8,4,0 %;
literal XJA_DIAG$S_LW_READ_SEL = 4;     !  Longword Read Select
macro XJA_DIAG$V_DIAG_MODE = 12,29,1,0 %; !  Diagnostic Mode
macro XJA_DIAG$V_FLIP_ADDR_BIT_29 = 12,30,1,0 %; !  Flip Address Bit <29>
macro XJA_DIAG$V_FRC_LCL_XJA_REG_ACC = 12,31,1,0 %; !  Force Local XJA Register Access
macro XJA$L_DMAFADDR = 16,0,32,0 %;
macro XJA_DMAFADDR$V_FAILING_ADDR = 16,0,29,0 %;
literal XJA_DMAFADDR$S_FAILING_ADDR = 29; !  Failing Address
macro XJA_DMAFADDR$V_FAILING_ADDR_29 = 16,29,1,0 %; !  Failing Address Bit <29>
macro XJA_DMAFADDR$V_FAILING_LEN = 16,30,2,0 %;
literal XJA_DMAFADDR$S_FAILING_LEN = 2; !  Failing Length
macro XJA$L_DMAFCMD = 20,0,32,0 %;
macro XJA_DMAFCMD$V_FAIL_MASK = 20,0,16,0 %;
literal XJA_DMAFCMD$S_FAIL_MASK = 16;   !  Failing XMI Mask
macro XJA_DMAFCMD$V_FAIL_ADDR_38_29 = 20,16,10,0 %;
literal XJA_DMAFCMD$S_FAIL_ADDR_38_29 = 10; !  Failing XMI Address <38:29>
macro XJA_DMAFCMD$V_FAILING_CMD = 20,28,4,0 %;
literal XJA_DMAFCMD$S_FAILING_CMD = 4;  !  Failing Command
macro XJA$L_ERRINTR = 24,0,32,0 %;
macro XJA_ERRINTR$V_IE_XMI_ARB_TMO = 24,0,1,0 %; !  INTR Enable on XMI Arb Timeout
macro XJA_ERRINTR$V_IE_JXDI_PARITYERR = 24,1,1,0 %; !  INTR Enable on JXDI Parity Error
macro XJA_ERRINTR$V_IE_TRANS_TMO = 24,13,1,0 %; !  INTR Enable on Transaction Timeout
macro XJA_ERRINTR$V_IE_TRANSMIT_ERR = 24,14,1,0 %; !  INTR Enable on Transmit Error
macro XJA_ERRINTR$V_IE_CMD_NOACK = 24,15,1,0 %; !  INTR Enable on Command NOACK
macro XJA_ERRINTR$V_IE_READ_ERR_RSP = 24,16,1,0 %; !  INTR Enable on Read Error Response
macro XJA_ERRINTR$V_IE_READ_SEQ_ERR = 24,17,1,0 %; !  INTR Enable on Read Sequence Error
macro XJA_ERRINTR$V_IE_NO_READ_RSP = 24,18,1,0 %; !  INTR Enable on No Read Response
macro XJA_ERRINTR$V_IE_CRD = 24,19,1,0 %; !  INTR Enable on Corrected Read Data
macro XJA_ERRINTR$V_IE_WR_DATA_NOACK = 24,20,1,0 %; !  INTR Enable on Write Data NOACK
macro XJA_ERRINTR$V_IE_IDN_DATA_NOACK = 24,21,1,0 %; !  INTR Enable on Read/IDENT Data NOACK
macro XJA_ERRINTR$V_IE_WRITE_SEQ_ERR = 24,22,1,0 %; !  INTR Enable on Write Sequence Error
macro XJA_ERRINTR$V_IE_PARITY_ERR = 24,23,1,0 %; !  INTR Enable on Parity Error (XMI)
macro XJA_ERRINTR$V_IE_INCON_PARITY = 24,24,1,0 %; !  INTR Enable on Inconsistent Parity Error
macro XJA_ERRINTR$V_IE_CC = 24,27,1,0 %; !  INTR Enable on Corrected Confirmation Data
macro XJA$L_CNF = 28,0,32,0 %;
macro XJA_CNF$V_XJA_XMI_NODE_ID = 28,12,4,0 %;
literal XJA_CNF$S_XJA_XMI_NODE_ID = 4;  !  XJA XMI Node ID
macro XJA_CNF$V_MEMORY_SIZE = 28,16,8,0 %;
literal XJA_CNF$S_MEMORY_SIZE = 8;      !  Memory Size (64 MB chunks)
macro XJA_CNF$V_START_ADDR_33_26 = 28,24,8,0 %;
literal XJA_CNF$S_START_ADDR_33_26 = 8; !  Starting Address <33:26> (64 MB)
macro XJA$L_XBIIDA = 32,0,32,0 %;
macro XJA_XBIIDA$V_XBI_ID_0 = 32,0,4,0 %;
literal XJA_XBIIDA$S_XBI_ID_0 = 4;      !  XMI node ID of corresponding XBI
macro XJA_XBIIDA$V_XBI_ID_1 = 32,4,4,0 %;
literal XJA_XBIIDA$S_XBI_ID_1 = 4;      !  XMI node ID of corresponding XBI
macro XJA_XBIIDA$V_XBI_ID_2 = 32,8,4,0 %;
literal XJA_XBIIDA$S_XBI_ID_2 = 4;      !  XMI node ID of corresponding XBI
macro XJA_XBIIDA$V_XBI_ID_3 = 32,12,4,0 %;
literal XJA_XBIIDA$S_XBI_ID_3 = 4;      !  XMI node ID of corresponding XBI
macro XJA_XBIIDA$V_XBI_ID_4 = 32,16,4,0 %;
literal XJA_XBIIDA$S_XBI_ID_4 = 4;      !  XMI node ID of corresponding XBI
macro XJA_XBIIDA$V_XBI_ID_5 = 32,20,4,0 %;
literal XJA_XBIIDA$S_XBI_ID_5 = 4;      !  XMI node ID of corresponding XBI
macro XJA_XBIIDA$V_XBI_ID_6 = 32,24,4,0 %;
literal XJA_XBIIDA$S_XBI_ID_6 = 4;      !  XMI node ID of corresponding XBI
macro XJA_XBIIDA$V_XBI_ID_7 = 32,28,4,0 %;
literal XJA_XBIIDA$S_XBI_ID_7 = 4;      !  XMI node ID of corresponding XBI
macro XJA$L_XBIIDB = 36,0,32,0 %;
macro XJA_XBIIDB$V_XBI_ID_8 = 36,0,4,0 %;
literal XJA_XBIIDB$S_XBI_ID_8 = 4;      !  XMI node ID of corresponding XBI
macro XJA_XBIIDB$V_XBI_ID_9 = 36,4,4,0 %;
literal XJA_XBIIDB$S_XBI_ID_9 = 4;      !  XMI node ID of corresponding XBI
macro XJA_XBIIDB$V_XBI_ID_A = 36,8,4,0 %;
literal XJA_XBIIDB$S_XBI_ID_A = 4;      !  XMI node ID of corresponding XBI
macro XJA_XBIIDB$V_XBI_ID_B = 36,12,4,0 %;
literal XJA_XBIIDB$S_XBI_ID_B = 4;      !  XMI node ID of corresponding XBI
macro XJA_XBIIDB$V_XBI_ID_C = 36,16,4,0 %;
literal XJA_XBIIDB$S_XBI_ID_C = 4;      !  XMI node ID of corresponding XBI
macro XJA_XBIIDB$V_XBI_ID_D = 36,20,4,0 %;
literal XJA_XBIIDB$S_XBI_ID_D = 4;      !  XMI node ID of corresponding XBI
macro XJA$L_ERRSCB = 40,0,32,0 %;
macro XJA_ERRSCB$V_XJA_ERR_SCB_OFFSET = 40,0,16,0 %;
literal XJA_ERRSCB$S_XJA_ERR_SCB_OFFSET = 16; !  XJA Error SCB Offset
macro XJA$L_IDENT4 = 64,0,32,0 %;
macro XJA_IDENT4$V_IPL14_SCB_OFFSET = 64,0,16,0 %;
literal XJA_IDENT4$S_IPL14_SCB_OFFSET = 16; !  XJA IPL Hex 14 SCB Offset
macro XJA$L_IDENT5 = 68,0,32,0 %;
macro XJA_IDENT5$V_IPL15_SCB_OFFSET = 68,0,16,0 %;
literal XJA_IDENT5$S_IPL15_SCB_OFFSET = 16; !  XJA IPL Hex 15 SCB Offset
macro XJA$L_IDENT6 = 72,0,32,0 %;
macro XJA_IDENT6$V_IPL16_SCB_OFFSET = 72,0,16,0 %;
literal XJA_IDENT6$S_IPL16_SCB_OFFSET = 16; !  XJA IPL Hex 16 SCB Offset
macro XJA$L_IDENT7 = 76,0,32,0 %;
macro XJA_IDENT7$V_IPL17_SCB_OFFSET = 76,0,16,0 %;
literal XJA_IDENT7$S_IPL17_SCB_OFFSET = 16; !  XJA IPL Hex 17 SCB Offset
 
!*** MODULE $XMEMDEF ***
! +
!  XMI Memory Node Registers
! -
literal XMEM$M_MWRITER = 1024;
literal XMEM$M_UNLOCKERR = 2048;
literal XMEM$M_LOCKERR = 4096;
literal XMEM$M_ENPROTECT = 8192;
literal XMEM$M_MEMVAL = 16384;
literal XMEM$M_INHCRD = 32768;
literal XMEM$M_ECCDIS = 536870912;
literal XMEM$M_ECCDIAG = 1073741824;
literal XMEM$M_ERRSUM = -2147483648;
literal XMEM$M_COLPERR = 33554432;
literal XMEM$M_ROWPERR = 67108864;
literal XMEM$M_BWRITERR = 134217728;
literal XMEM$M_CRDLOGR = 536870912;
literal XMEM$M_HIERATE = 1073741824;
literal XMEM$M_RDSLOGR = -2147483648;
literal XMEM$M_FILL_10 = 536870912;
literal XMEM$M_INTID5 = 1073741824;
literal XMEM$M_INTFLG = -2147483648;
literal XMEM$M_DSBLHOLD = 32;
literal XMEM$M_RFRSHERR = 65536;
literal XMEM$M_TREF_REQ = 1;
literal XMEM$M_ECC_TEST = 2;
literal XMEM$M_TCY_MODE = -2147483648;
literal XMEM$S_XMEMDEF = 272;
macro XMEM$L_SEADR = 16,0,32,0 %;       ! Start/End Address Register
macro XMEM$V_INTLV = 16,0,2,0 %;
literal XMEM$S_INTLV = 2;               !  how many ways interleaved
macro XMEM$V_INTLVADDR = 16,5,3,0 %;
literal XMEM$S_INTLVADDR = 3;           !  Interleave address bits
macro XMEM$V_SADR = 16,8,8,0 %;
literal XMEM$S_SADR = 8;                !  Starting address
macro XMEM$V_EADR = 16,21,9,0 %;
literal XMEM$S_EADR = 9;                !  Ending address
macro XMEM$L_MCTL1 = 20,0,32,0 %;       !  Memory Control Reg. 1
macro XMEM$V_DIAGBTS = 20,0,8,0 %;
literal XMEM$S_DIAGBTS = 8;             !  Used during ECC diag cycles
macro XMEM$V_MWRITER = 20,10,1,0 %;     !  RDS on masked write
macro XMEM$V_UNLOCKERR = 20,11,1,0 %;   !  Unlock SEQ error
macro XMEM$V_LOCKERR = 20,12,1,0 %;     !  Lock queue error
macro XMEM$V_ENPROTECT = 20,13,1,0 %;   !  EN protect mode
macro XMEM$V_MEMVAL = 20,14,1,0 %;      !  Memory contents valid
macro XMEM$V_INHCRD = 20,15,1,0 %;      !  Inhib. CRD reporting
macro XMEM$V_RAMTYPE = 20,16,2,0 %;
literal XMEM$S_RAMTYPE = 2;             !  Size of RAM
macro XMEM$V_MEMSIZE = 20,18,11,0 %;
literal XMEM$S_MEMSIZE = 11;            !  Size in 256KB increments
macro XMEM$V_ECCDIS = 20,29,1,0 %;      !  Used with following bit
macro XMEM$V_ECCDIAG = 20,30,1,0 %;     !  
macro XMEM$V_ERRSUM = 20,31,1,0 %;      !  Error summary(includes MECER)
macro XMEM$L_MECER = 24,0,32,0 %;       !  Memory ECC Error Register
macro XMEM$V_ERRSYND = 24,0,8,0 %;
literal XMEM$S_ERRSYND = 8;             !  Error syndrome
macro XMEM$V_COLPERR = 24,25,1,0 %;     !  Column parity error
macro XMEM$V_ROWPERR = 24,26,1,0 %;     !  Row parity error
macro XMEM$V_BWRITERR = 24,27,1,0 %;    !  Byte write error
macro XMEM$V_CRDLOGR = 24,29,1,0 %;     !  CRD Error Log REQ
macro XMEM$V_HIERATE = 24,30,1,0 %;     !  Hi Error Rate
macro XMEM$V_RDSLOGR = 24,31,1,0 %;     !  RDS Error Log REQ
macro XMEM$L_MECEA = 28,0,32,0 %;       !  Memory ECC Error Register
macro XMEM$V_ERRADDR = 28,3,27,0 %;
literal XMEM$S_ERRADDR = 27;            !  Error address
macro XMEM$L_IFLG0 = 32,0,32,0 %;       !  INTLK FLAG 0 REGISTER
macro XMEM$V_INTLKID = 32,0,5,0 %;
literal XMEM$S_INTLKID = 5;             !  ID of last INTLK read
macro XMEM$V_INTLKADR = 32,5,24,0 %;
literal XMEM$S_INTLKADR = 24;           !  INTLK address
macro XMEM$V_FILL_10 = 32,29,1,0 %;     !  Filler		
macro XMEM$V_INTID5 = 32,30,1,0 %;      !  INTLK ID bit 5
macro XMEM$V_INTFLG = 32,31,1,0 %;      !  INTLK flag 0
macro XMEM$L_IFLG1 = 36,0,32,0 %;       !  INTLK FLAG 1  REGISTER
macro XMEM$L_IFLG2 = 40,0,32,0 %;       !  INTLK FLAG 2  REGISTER
macro XMEM$L_IFLG3 = 44,0,32,0 %;       !  INTLK FLAG 3  REGISTER
macro XMEM$L_MCTL2 = 48,0,32,0 %;       !  Memory Control Reg. 2
macro XMEM$V_SUPRESS = 48,0,2,0 %;
literal XMEM$S_SUPRESS = 2;             !  ARB suppress control
macro XMEM$V_REFRESH = 48,2,3,0 %;
literal XMEM$S_REFRESH = 3;             !  Refresh rate
macro XMEM$V_DSBLHOLD = 48,5,1,0 %;     !  Disable hold
macro XMEM$V_RFRSHERR = 48,16,1,0 %;    !  Refresh error
macro XMEM$L_TCY = 52,0,32,0 %;         !  TCY tester register
macro XMEM$V_TREF_REQ = 52,0,1,0 %;     !  Test refresh request
macro XMEM$V_ECC_TEST = 52,1,1,0 %;     !  Test ECC
macro XMEM$V_TCY_MODE = 52,31,1,0 %;    !  Disable ECC errors and 
!  refresh requests
macro XMEM$B_FILL_14 = 56,0,0,1 %;
literal XMEM$S_FILL_14 = 8;             !  Filler
macro XMEM$L_IFLG4 = 64,0,32,0 %;       !  INTLK FLAG 4  REGISTER
macro XMEM$L_IFLG5 = 68,0,32,0 %;       !  INTLK FLAG 5  REGISTER
macro XMEM$L_IFLG6 = 72,0,32,0 %;       !  INTLK FLAG 6  REGISTER
macro XMEM$L_IFLG7 = 76,0,32,0 %;       !  INTLK FLAG 7  REGISTER
macro XMEM$B_FILL_15 = 80,0,0,1 %;
literal XMEM$S_FILL_15 = 48;            !  Filler
macro XMEM$L_IFLG8 = 128,0,32,0 %;      !  INTLK FLAG 8  REGISTER
macro XMEM$L_IFLG9 = 132,0,32,0 %;      !  INTLK FLAG 9  REGISTER
macro XMEM$L_IFLG10 = 136,0,32,0 %;     !  INTLK FLAG 10 REGISTER
macro XMEM$L_IFLG11 = 140,0,32,0 %;     !  INTLK FLAG 11 REGISTER
macro XMEM$B_FILL_16 = 144,0,0,1 %;
literal XMEM$S_FILL_16 = 112;           !  Filler
macro XMEM$L_IFLG12 = 256,0,32,0 %;     !  INTLK FLAG 12 REGISTER
macro XMEM$L_IFLG13 = 260,0,32,0 %;     !  INTLK FLAG 13 REGISTER
macro XMEM$L_IFLG14 = 264,0,32,0 %;     !  INTLK FLAG 14 REGISTER
macro XMEM$L_IFLG15 = 268,0,32,0 %;     !  INTLK FLAG 15 REGISTER
 
!*** MODULE $XMEM2DEF ***
! +
!  XMA-2 Memory Node Registers
! -
literal XMEM2_SEADR$M_INTLV = 3;
literal XMEM2_SEADR$M_INTLVADDR = 224;
literal XMEM2_SEADR$M_SADR = 7936;
literal XMEM2_SEADR$M_TOP = 67108864;
literal XMEM2_SEADR$M_FILL_4 = 402653184;
literal XMEM2_MCTL1$M_DIAGBTS = 255;
literal XMEM2_MCTL1$M_MWRITER = 1024;
literal XMEM2_MCTL1$M_UNLOCKERR = 2048;
literal XMEM2_MCTL1$M_ENPROTECT = 8192;
literal XMEM2_MCTL1$M_MEMVAL = 16384;
literal XMEM2_MCTL1$M_INHCRD = 32768;
literal XMEM2_MCTL1$M_RAMTYPE = 196608;
literal XMEM2_MCTL1$M_MEMSIZE = 536608768;
literal XMEM2_MCTL1$M_ECCDIS = 536870912;
literal XMEM2_MCTL1$M_ECCDIAG = 1073741824;
literal XMEM2_MCTL1$M_ERRSUM = -2147483648;
literal XMEM2_MECER$M_ERRSYND = 255;
literal XMEM2_MECER$M_CMD_CODE = 61440;
literal XMEM2_MECER$M_CMD_ID = 4128768;
literal XMEM2_MECER$M_COLUMNPERR = 33554432;
literal XMEM2_MECER$M_ROWPERR = 67108864;
literal XMEM2_MECER$M_BWRITERR = 134217728;
literal XMEM2_MECER$M_CRDERR = 536870912;
literal XMEM2_MECER$M_DATASEO = 1073741824;
literal XMEM2_MECER$M_DATARER = -2147483648;
literal XMEM2_MCTL2$M_SUPRESS = 3;
literal XMEM2_MCTL2$M_REFRESH = 28;
literal XMEM2_MCTL2$M_DSBLHOLD = 32;
literal XMEM2_MCTL2$M_RFRSHERR = 65536;
literal XMEM2_MCTL2$M_FORCE_REFRESH = 131072;
literal XMEM2_TCY$M_REF_REQ = 1;
literal XMEM2_TCY$M_DATA_ECC_TEST = 2;
literal XMEM2_TCY$M_BLOCK_ECC_TEST = 4;
literal XMEM2_TCY$M_IGNORE_BLOCK_ECC = 8;
literal XMEM2_TCY$M_IGNORE_DATA_ECC = 16;
literal XMEM2_TCY$M_TCY_ENAREF = 1073741824;
literal XMEM2_TCY$M_TCY_DISREF = -2147483648;
literal XMEM2_BECER$M_BLOCKSYND = 31;
literal XMEM2_BECER$M_BLOCKSTID = 480;
literal XMEM2_BECER$M_BLOCKSTCOD = 1536;
literal XMEM2_BECER$M_CMD_CODE = 61440;
literal XMEM2_BECER$M_CMD_ID = 4128768;
literal XMEM2_BECER$M_TBB = 16777216;
literal XMEM2_BECER$M_COLUMNPERR = 33554432;
literal XMEM2_BECER$M_ROWPERR = 67108864;
literal XMEM2_BECER$M_BWRITERR = 134217728;
literal XMEM2_BECER$M_BLKCRDERR = 536870912;
literal XMEM2_BECER$M_BLOCKSEO = 1073741824;
literal XMEM2_BECER$M_BLOCKRER = -2147483648;
literal XMEM2_ENADR$M_TOP = 65536;
literal XMEM2_INTLV$M_INTLV_MODE = 3;
literal XMEM2_INTLV$M_INTLV_ADDR = 224;
literal XMEM2_INTLV$M_INTLV_SEG = 2031616;
literal XMEM2_MCTL3$M_TRIG_MODE = 32767;
literal XMEM2_MCTL3$M_TRIG_ENAB = 32768;
literal XMEM2_MCTL3$M_INCON_ERR = 134152192;
literal XMEM2_MCTL3$M_INV_UPDATE = 536870912;
literal XMEM2_MCTL3$M_UPDATE_ENA = 1073741824;
literal XMEM2_MCTL3$M_ES = -2147483648;
literal XMEM2_MCTL4$M_BLOCKSYND = 31;
literal XMEM2_MCTL4$M_BLOCKSTID = 480;
literal XMEM2_MCTL4$M_BLOCKSTCOD = 1536;
literal XMEM2_MCTL4$M_OWNSEQ_ERR = 2048;
literal XMEM2_MCTL4$M_MWRITER = 16384;
literal XMEM2_MCTL4$M_MODPOP = 32768;
literal XMEM2_MCTL4$M_RAMTYPE = 196608;
literal XMEM2_MCTL4$M_MEMSIZE = 8126464;
literal XMEM2_MCTL4$M_ECCDIS = 536870912;
literal XMEM2_MCTL4$M_ECCDIAG = 1073741824;
literal XMEM2_MCTL4$M_ES = -2147483648;
literal XMEM2_BSCTL$M_STATE_ECC = 31;
literal XMEM2_BSCTL$M_CMD_ID = 480;
literal XMEM2_BSCTL$M_STATE = 1536;
literal XMEM2_BSCTL$M_ACCMODE = 1610612736;
literal XMEM2_BSCTL$M_PORT_ENA = -2147483648;
literal XMEM2_EECTL$M_DATA = 255;
literal XMEM2_EECTL$M_ADDR = 134152192;
literal XMEM2_EECTL$M_OPERATION = -1073741824;
literal XMEM2_TMOER$M_MODE = 1;
literal XMEM2_TMOER$M_DISABLE = 32768;
literal XMEM2_TMOER$M_WRITE_TMO = 268435456;
literal XMEM2_TMOER$M_READ_TMO = 536870912;
literal XMEM2_TMOER$M_SECOND_TMO = 1073741824;
literal XMEM2_TMOER$M_TMO = -2147483648;
literal XMEM2$S_XMEM2DEF = 120;
macro XMEM2$L_SEADR = 16,0,32,0 %;      ! Start/End Address Register
macro XMEM2_SEADR$V_INTLV = 16,0,2,0 %;
literal XMEM2_SEADR$S_INTLV = 2;        !  How many ways interleaved
macro XMEM2_SEADR$V_INTLVADDR = 16,5,3,0 %;
literal XMEM2_SEADR$S_INTLVADDR = 3;    !  Interleave address bits
macro XMEM2_SEADR$V_SADR = 16,8,5,0 %;
literal XMEM2_SEADR$S_SADR = 5;         !  Starting address
macro XMEM2_SEADR$V_EADR = 16,21,5,0 %;
literal XMEM2_SEADR$S_EADR = 5;         !  Ending address
macro XMEM2_SEADR$V_TOP = 16,26,1,0 %;  !  Top of 512Mb memory
macro XMEM2$L_MCTL1 = 20,0,32,0 %;      !  Memory Control Reg. 1
macro XMEM2_MCTL1$V_DIAGBTS = 20,0,8,0 %;
literal XMEM2_MCTL1$S_DIAGBTS = 8;      !  Used during ECC diag cycles
macro XMEM2_MCTL1$V_MWRITER = 20,10,1,0 %; !  RDS on masked write
macro XMEM2_MCTL1$V_UNLOCKERR = 20,11,1,0 %; !  Unlock SEQ error
macro XMEM2_MCTL1$V_ENPROTECT = 20,13,1,0 %; !  EN protect mode
macro XMEM2_MCTL1$V_MEMVAL = 20,14,1,0 %; !  Memory contents valid
macro XMEM2_MCTL1$V_INHCRD = 20,15,1,0 %; !  Inhib. CRD reporting
macro XMEM2_MCTL1$V_RAMTYPE = 20,16,2,0 %;
literal XMEM2_MCTL1$S_RAMTYPE = 2;      !  Size of RAM
macro XMEM2_MCTL1$V_MEMSIZE = 20,18,11,0 %;
literal XMEM2_MCTL1$S_MEMSIZE = 11;     !  Size in 256KB increments
macro XMEM2_MCTL1$V_ECCDIS = 20,29,1,0 %; !  Used with following bit
macro XMEM2_MCTL1$V_ECCDIAG = 20,30,1,0 %; !  ECC diagnostic mode
macro XMEM2_MCTL1$V_ERRSUM = 20,31,1,0 %; !  Error summary(includes MECER)
macro XMEM2$L_MECER = 24,0,32,0 %;      !  Memory ECC Error Register
macro XMEM2_MECER$V_ERRSYND = 24,0,8,0 %;
literal XMEM2_MECER$S_ERRSYND = 8;      !  Error syndrome
macro XMEM2_MECER$V_CMD_CODE = 24,12,4,0 %;
literal XMEM2_MECER$S_CMD_CODE = 4;     !  Command code
macro XMEM2_MECER$V_CMD_ID = 24,16,6,0 %;
literal XMEM2_MECER$S_CMD_ID = 6;       !  Commander ID
macro XMEM2_MECER$V_COLUMNPERR = 24,25,1,0 %; !  Column parity error
macro XMEM2_MECER$V_ROWPERR = 24,26,1,0 %; !  Row parity error
macro XMEM2_MECER$V_BWRITERR = 24,27,1,0 %; !  Byte write error
macro XMEM2_MECER$V_CRDERR = 24,29,1,0 %; !  CRD error occured
macro XMEM2_MECER$V_DATASEO = 24,30,1,0 %; !  Second data error occured
macro XMEM2_MECER$V_DATARER = 24,31,1,0 %; !  RER on data read
macro XMEM2$L_MECEA = 28,0,32,0 %;      !  Memory ECC Error Address Register
macro XMEM2_MECEA$V_ERRADDR = 28,3,29,0 %;
literal XMEM2_MECEA$S_ERRADDR = 29;
macro XMEM2$L_MCTL2 = 48,0,32,0 %;      !  Memory Control Reg. 2
macro XMEM2_MCTL2$V_SUPRESS = 48,0,2,0 %;
literal XMEM2_MCTL2$S_SUPRESS = 2;      !  ARB suppress control
macro XMEM2_MCTL2$V_REFRESH = 48,2,3,0 %;
literal XMEM2_MCTL2$S_REFRESH = 3;      !  Refresh rate
macro XMEM2_MCTL2$V_DSBLHOLD = 48,5,1,0 %; !  Disable hold
macro XMEM2_MCTL2$V_RFRSHERR = 48,16,1,0 %; !  Refresh error 
macro XMEM2_MCTL2$V_FORCE_REFRESH = 48,17,1,0 %; !  Forces refresh		
macro XMEM2$L_TCY = 52,0,32,0 %;        !  TCY tester register
macro XMEM2_TCY$V_REF_REQ = 52,0,1,0 %; !  Refresh request
macro XMEM2_TCY$V_DATA_ECC_TEST = 52,1,1,0 %; !  Data ECC test
macro XMEM2_TCY$V_BLOCK_ECC_TEST = 52,2,1,0 %; !  Block state ECC test
macro XMEM2_TCY$V_IGNORE_BLOCK_ECC = 52,3,1,0 %; !  Ignore block ecc
macro XMEM2_TCY$V_IGNORE_DATA_ECC = 52,4,1,0 %; !  Ignore data ecc
macro XMEM2_TCY$V_TCY_ENAREF = 52,30,1,0 %; !  Enable refresh
macro XMEM2_TCY$V_TCY_DISREF = 52,31,1,0 %; !  Disable refresh
macro XMEM2$L_BECER = 56,0,32,0 %;      !  Block state ECC error reg.
macro XMEM2_BECER$V_BLOCKSYND = 56,0,5,0 %;
literal XMEM2_BECER$S_BLOCKSYND = 5;    !  Block Error syndrome
macro XMEM2_BECER$V_BLOCKSTID = 56,5,4,0 %;
literal XMEM2_BECER$S_BLOCKSTID = 4;    !  Block state id
macro XMEM2_BECER$V_BLOCKSTCOD = 56,9,2,0 %;
literal XMEM2_BECER$S_BLOCKSTCOD = 2;   !  Block state code
macro XMEM2_BECER$V_CMD_CODE = 56,12,4,0 %;
literal XMEM2_BECER$S_CMD_CODE = 4;     !  Command code
macro XMEM2_BECER$V_CMD_ID = 56,16,6,0 %;
literal XMEM2_BECER$S_CMD_ID = 6;       !  Commander ID
macro XMEM2_BECER$V_TBB = 56,24,1,0 %;  !  Tag bad block
macro XMEM2_BECER$V_COLUMNPERR = 56,25,1,0 %; !  Column parity error
macro XMEM2_BECER$V_ROWPERR = 56,26,1,0 %; !  Row parity error
macro XMEM2_BECER$V_BWRITERR = 56,27,1,0 %; !  Byte write error
macro XMEM2_BECER$V_BLKCRDERR = 56,29,1,0 %; !  Block CRD error occured
macro XMEM2_BECER$V_BLOCKSEO = 56,30,1,0 %; !  Second block error occured
macro XMEM2_BECER$V_BLOCKRER = 56,31,1,0 %; !  RER on block read
macro XMEM2$L_BECEA = 60,0,32,0 %;      !  Block ECC Error Address Register
macro XMEM2_BECEA$V_ERRADDR = 60,3,29,0 %;
literal XMEM2_BECEA$S_ERRADDR = 29;
macro XMEM2$L_STADR = 80,0,32,0 %;      !  Starting Address Register
macro XMEM2_STADR$V_STADDR = 80,6,10,0 %;
literal XMEM2_STADR$S_STADDR = 10;      !  Starting address
macro XMEM2$L_ENADR = 84,0,32,0 %;      !  Ending Address Register
macro XMEM2_ENADR$V_ENADDR = 84,6,10,0 %;
literal XMEM2_ENADR$S_ENADDR = 10;      !  Ending address
macro XMEM2_ENADR$V_TOP = 84,16,1,0 %;  !  Top 16Gb
macro XMEM2$L_INTLV = 88,0,32,0 %;      !  Block state ECC error reg.
macro XMEM2_INTLV$V_INTLV_MODE = 88,0,2,0 %;
literal XMEM2_INTLV$S_INTLV_MODE = 2;   !  Interleave mode
macro XMEM2_INTLV$V_INTLV_ADDR = 88,5,3,0 %;
literal XMEM2_INTLV$S_INTLV_ADDR = 3;   !  Interleave address
macro XMEM2_INTLV$V_INTLV_SEG = 88,16,5,0 %;
literal XMEM2_INTLV$S_INTLV_SEG = 5;    !  Interleave segment
macro XMEM2$L_MCTL3 = 92,0,32,0 %;      !  Memory control register 3
macro XMEM2_MCTL3$V_TRIG_MODE = 92,0,15,0 %;
literal XMEM2_MCTL3$S_TRIG_MODE = 15;   !  Trigger mode
macro XMEM2_MCTL3$V_TRIG_ENAB = 92,15,1,0 %; !  Trigger enable
macro XMEM2_MCTL3$V_INCON_ERR = 92,16,11,0 %;
literal XMEM2_MCTL3$S_INCON_ERR = 11;   !  Inconsistency errors 
macro XMEM2_MCTL3$V_INV_UPDATE = 92,29,1,0 %; !  Invalid EEPROM update
macro XMEM2_MCTL3$V_UPDATE_ENA = 92,30,1,0 %; !  EEPROM update enable
macro XMEM2_MCTL3$V_ES = 92,31,1,0 %;   !  Error summary
macro XMEM2$L_MCTL4 = 96,0,32,0 %;      !  Memory control register 4
macro XMEM2_MCTL4$V_BLOCKSYND = 96,0,5,0 %;
literal XMEM2_MCTL4$S_BLOCKSYND = 5;    !  Block Error syndrome
macro XMEM2_MCTL4$V_BLOCKSTID = 96,5,4,0 %;
literal XMEM2_MCTL4$S_BLOCKSTID = 4;    !  Block state id
macro XMEM2_MCTL4$V_BLOCKSTCOD = 96,9,2,0 %;
literal XMEM2_MCTL4$S_BLOCKSTCOD = 2;   !  Block state code
macro XMEM2_MCTL4$V_OWNSEQ_ERR = 96,11,1,0 %; !  Ownership sequence error
macro XMEM2_MCTL4$V_MWRITER = 96,14,1,0 %; !  RDS on masked write
macro XMEM2_MCTL4$V_MODPOP = 96,15,1,0 %; !  Module population
macro XMEM2_MCTL4$V_RAMTYPE = 96,16,2,0 %;
literal XMEM2_MCTL4$S_RAMTYPE = 2;      !  Size of RAM
macro XMEM2_MCTL4$V_MEMSIZE = 96,18,5,0 %;
literal XMEM2_MCTL4$S_MEMSIZE = 5;      !  Memory size
macro XMEM2_MCTL4$V_ECCDIS = 96,29,1,0 %; !  Used with following bit
macro XMEM2_MCTL4$V_ECCDIAG = 96,30,1,0 %; !  ECC diagnostic mode
macro XMEM2_MCTL4$V_ES = 96,31,1,0 %;   !  Error summary(includes MECER)
macro XMEM2$L_BSCTL = 104,0,32,0 %;     !  Block state control register
macro XMEM2_BSCTL$V_STATE_ECC = 104,0,5,0 %;
literal XMEM2_BSCTL$S_STATE_ECC = 5;    !  Block state ECC
macro XMEM2_BSCTL$V_CMD_ID = 104,5,4,0 %;
literal XMEM2_BSCTL$S_CMD_ID = 4;       !  Block commander id
macro XMEM2_BSCTL$V_STATE = 104,9,2,0 %;
literal XMEM2_BSCTL$S_STATE = 2;        !  Block state
macro XMEM2_BSCTL$V_ACCMODE = 104,29,2,0 %;
literal XMEM2_BSCTL$S_ACCMODE = 2;      !  Block state access command
macro XMEM2_BSCTL$V_PORT_ENA = 104,31,1,0 %; !  Block state port enable
macro XMEM2$L_BSADR = 108,0,32,0 %;     !  Block State Address Register
macro XMEM2_BSADR$V_BSADDR = 108,5,27,0 %;
literal XMEM2_BSADR$S_BSADDR = 27;      !  Block address
macro XMEM2$L_EECTL = 112,0,32,0 %;     !  Block state control register
macro XMEM2_EECTL$V_DATA = 112,0,8,0 %;
literal XMEM2_EECTL$S_DATA = 8;         !  Data byte
macro XMEM2_EECTL$V_ADDR = 112,16,11,0 %;
literal XMEM2_EECTL$S_ADDR = 11;        !  EEPROM address
macro XMEM2_EECTL$V_OPERATION = 112,30,2,0 %;
literal XMEM2_EECTL$S_OPERATION = 2;    !  Initiate EEPROM operation
macro XMEM2$L_TMOER = 116,0,32,0 %;     !  Block state control register
macro XMEM2_TMOER$V_MODE = 116,0,1,0 %; !  Timeout counter mode
macro XMEM2_TMOER$V_DISABLE = 116,15,1,0 %; !  Timeout counter disabled
macro XMEM2_TMOER$V_WRITE_TMO = 116,28,1,0 %; !  Deferred write timeout occurred
macro XMEM2_TMOER$V_READ_TMO = 116,29,1,0 %; !  Deferred read timeout occurred
macro XMEM2_TMOER$V_SECOND_TMO = 116,30,1,0 %; !  Second time-out occured
macro XMEM2_TMOER$V_TMO = 116,31,1,0 %; !  Time-out occured
 
!*** MODULE $XMIDEF ***
! +
!  XMI Required Registers
! -
literal XMI$C_IO_CLASS = 32;
literal XMI$C_MEMORY_CLASS = 64;
literal XMI$C_CPU_CLASS = 128;
! 
literal XMI$C_READ = 1;
literal XMI$C_IREAD = 2;
literal XMI$C_UWMASK = 6;
literal XMI$C_WMASK = 7;
literal XMI$C_INTR = 8;
literal XMI$C_IDENT = 9;
literal XMI$C_IVINTR = 15;
!  XMI-2 additional commands
literal XMI$C_OREAD = 3;
literal XMI$C_DWMASK = 4;
literal XMI$C_TBDATA = 11;
literal XMI$M_EMP = 2;
literal XMI$M_DXTO = 4;
literal XMI$M_EHWW = 8;
literal XMI$M_FCMD = 15;
literal XMI$M_FCID = 1008;
literal XMI$M_STF = 1024;
literal XMI$M_ETF = 2048;
literal XMI$M_NSES = 4096;
literal XMI$M_TTO = 8192;
literal XMI$M_TE = 16384;
literal XMI$M_CNAK = 32768;
literal XMI$M_RER = 65536;
literal XMI$M_RSE = 131072;
literal XMI$M_NRR = 262144;
literal XMI$M_CRD = 524288;
literal XMI$M_WDNAK = 1048576;
literal XMI$M_RIDNAK = 2097152;
literal XMI$M_WSE = 4194304;
literal XMI$M_PE = 8388608;
literal XMI$M_IPE = 16777216;
literal XMI$M_WEI = 33554432;
literal XMI$M_XFAULT = 67108864;
literal XMI$M_CC = 134217728;
literal XMI$M_XBAD = 268435456;
literal XMI$M_NHALT = 536870912;
literal XMI$M_NRESET = 1073741824;
literal XMI$M_ES = -2147483648;
literal XMI$M_SLEEP_MODE = 1073741824;
literal XMI$M_FAEM_ENABLE = -2147483648;
literal XMI$M_LOCMOD = 3;
literal XMI$M_XBADD = 4;
literal XMI$M_CRDID = 65536;
literal XMI$M_CCID = 131072;
literal XMI$M_SEO = 1;
literal XMI$M_OLR = 2;
literal XMI$M_URR = 4;
literal XMI$S_XMIDEF = 1592;
macro XMI$L_XDEV = 0,0,32,0 %;          !  XMI Device register
macro XMI$W_DTYPE = 0,0,16,0 %;         !  Device type
macro XMI$B_DEV_ID = 0,0,8,0 %;         !  Device ID
macro XMI$B_CLASS = 1,0,8,0 %;          !  Device class
macro XMI$W_DREV = 2,0,16,0 %;          !  Device Revision
!  XMI commands
! 
macro XMI$L_XBE = 4,0,32,0 %;           !  XMI Bus Error register
macro XMIDEF$$_FILL_1 = 4,0,1,0 %;      !  Reserved bit
macro XMI$V_EMP = 4,1,1,0 %;            !  Enable More Protocol
macro XMI$V_DXTO = 4,2,1,0 %;           !  Disable XMI Timeout
macro XMI$V_EHWW = 4,3,1,0 %;           !  Enable HexaWord Write
macro XMI$V_FCMD = 4,0,4,0 %;
literal XMI$S_FCMD = 4;                 !  Failing Command (Pre V1.4)
macro XMI$V_FCID = 4,4,6,0 %;
literal XMI$S_FCID = 6;                 !  Failing Commander ID
macro XMI$V_STF = 4,10,1,0 %;           !  Self-test fail
macro XMI$V_ETF = 4,11,1,0 %;           !  Extended Test fail
macro XMI$V_NSES = 4,12,1,0 %;          !  Node-specific Err. Summary
macro XMI$V_TTO = 4,13,1,0 %;           !  Transaction timeout
macro XMI$V_TE = 4,14,1,0 %;            !  Transmit error
macro XMI$V_CNAK = 4,15,1,0 %;          !  Command NoAck
macro XMI$V_RER = 4,16,1,0 %;           !  Read Error Response
macro XMI$V_RSE = 4,17,1,0 %;           !  Read Sequence Error
macro XMI$V_NRR = 4,18,1,0 %;           !  No Read Response
macro XMI$V_CRD = 4,19,1,0 %;           !  Corrected Read Data
macro XMI$V_WDNAK = 4,20,1,0 %;         !  Write Data NoACk
macro XMI$V_RIDNAK = 4,21,1,0 %;        !  Read/IDENT Data NoAck
macro XMI$V_WSE = 4,22,1,0 %;           !  Write Sequence Error
macro XMI$V_PE = 4,23,1,0 %;            !  Parity Error
macro XMI$V_IPE = 4,24,1,0 %;           !  Inconsistent Parity Error
macro XMI$V_WEI = 4,25,1,0 %;           !  Write Error Interrupt
macro XMI$V_XFAULT = 4,26,1,0 %;        !  XMI Fault
macro XMI$V_CC = 4,27,1,0 %;            !  Corrected Confirmation
macro XMI$V_XBAD = 4,28,1,0 %;          !  XMI Bad
macro XMI$V_NHALT = 4,29,1,0 %;         !  Node Halt
macro XMI$V_NRESET = 4,30,1,0 %;        !  Node Reset
macro XMI$V_ES = 4,31,1,0 %;            !  Error Summary
macro XMI$L_XFAD = 8,0,32,0 %;          !  XMI Failing Address register
macro XMI$L_XFADR0 = 8,0,32,0 %;        !  XMI Failing Address register
macro XMI$V_FADR = 8,0,30,0 %;
literal XMI$S_FADR = 30;                !  Failing Address
macro XMI$V_FLN = 8,30,2,0 %;
literal XMI$S_FLN = 2;                  !  Failing length
!   register. This is identical
!   to other node's XFAER except
!   that for the XJA it is here
!   at bb+C rather than at bb+2C.
macro XMI$L_XJA_XFADRB = 12,0,32,0 %;   !  XJA Failing Address register EXt.
!  For the field definitions, use
!   those defined below for XFAER.
macro XMI$L_XGPR = 12,0,32,0 %;         !  XMI General Purpose register
macro XMI$L_XJA_XGPR = 16,0,32,0 %;     !  XJA's General Purpose Register.
macro XMI$L_XCOMM = 16,0,32,0 %;        !  XMI Communication register
macro XMI$L_XJA_XFAEMCTL = 20,0,32,0 %; !  XJA's FAEM Control Register
macro XMI$V_XBI_WINDOW_MASK = 20,0,16,0 %;
literal XMI$S_XBI_WINDOW_MASK = 16;     !  XBI Window Space Mask
macro XMI$V_SLEEP_MODE = 20,30,1,0 %;   !  Set Sleep Mode
macro XMI$V_FAEM_ENABLE = 20,31,1,0 %;  !  Enable FAEM
macro XMI$L_XJA_AOSTS = 24,0,32,0 %;    !  XJA's Add On Self Test Status Register
macro XMI$L_XJA_SERNUM = 28,0,32,0 %;   !  XJA's Serial Number Register
macro XMI$V_SERIAL_NUMBER = 28,0,17,0 %;
literal XMI$S_SERIAL_NUMBER = 17;       !  Serial Number
macro XMI$V_PLANT = 28,17,4,0 %;
literal XMI$S_PLANT = 4;                !  Manufacturing Plant.
macro XMI$V_REV = 28,21,4,0 %;
literal XMI$S_REV = 4;                  !  Revision Level.
macro XMI$V_VARI = 28,25,4,0 %;
literal XMI$S_VARI = 4;                 !  Variation.
macro XMI$L_NSCSR = 28,0,32,0 %;        !  XMI-1 Node specific CSR
macro XMI$L_NSCSR0 = 28,0,32,0 %;       !  XMI-2 Node specific CSR
macro XMI$L_XBCR = 36,0,32,0 %;         !  XMI-1 Bus control register
macro XMI$L_XBCR0 = 36,0,32,0 %;        !  XMI-2 Bus control register
macro XMI$V_LOCMOD = 36,0,2,0 %;
literal XMI$S_LOCMOD = 2;               !  Lockout mode bits
macro XMI$V_XBADD = 36,2,1,0 %;         !  XMI Bad Drive
macro XMI$V_CRDID = 36,16,1,0 %;        !  Corrected Read Int. disable
macro XMI$V_CCID = 36,17,1,0 %;         !  Corrected Conf. Int. disable
macro XMI$L_XFAER = 44,0,32,0 %;        !  XMI-1 Failing Address Ext register
macro XMI$L_XFAER0 = 44,0,32,0 %;       !  XMI-2 Failing Address Ext register
macro XMI$V_MASK = 44,0,16,0 %;
literal XMI$S_MASK = 16;                !  Failing Mask
macro XMI$V_ADDREXT = 44,16,10,0 %;
literal XMI$S_ADDREXT = 10;             !  Failing Address Extension bits [38:29]
macro XMIDEF$$_FILL_3 = 44,26,2,0 %;
literal XMIDEFS_FILL_3 = 2;             !  Reserved bits
macro XMI$V_FCMDX = 44,28,4,0 %;
literal XMI$S_FCMDX = 4;                !  Failing Command
!  End of XMI-1 Register.  The addition register only apply to XMI-2.
macro XMI$L_XBEER = 52,0,32,0 %;        !  XMI-1 Bus Error extendion
macro XMI$L_XBEER0 = 52,0,32,0 %;       !  XMI-2 Bus Error extendion
macro XMI$V_SEO = 52,0,1,0 %;           !  Second Error Occured
macro XMI$V_OLR = 52,1,1,0 %;           !  Only LOC Response
macro XMI$V_URR = 52,2,1,0 %;           !  Unexpected Read Response
macro XMI$L_XBE1 = 516,0,32,0 %;        !  XMI-2 Bus Error register
macro XMI$L_XFAD1 = 520,0,32,0 %;       !  XMI-2 Failing Addr register
macro XMI$L_NSCSR1 = 540,0,32,0 %;      !  XMI-2 Node specific CSR
macro XMI$L_XBCR1 = 548,0,32,0 %;       !  XMI-2 Bus control register
macro XMI$L_XFAER1 = 556,0,32,0 %;      !  XMI-2 Failing addr. extension
macro XMI$L_XBEER1 = 564,0,32,0 %;      !  XMI-2 Bus Error extendion
!  
macro XMI$L_XBE2 = 1028,0,32,0 %;       !  XMI-2 Bus Error register
macro XMI$L_XFAD2 = 1032,0,32,0 %;      !  XMI-2 Failing Addr register
macro XMI$L_NSCSR2 = 1052,0,32,0 %;     !  XMI-2 Node specific CSR
macro XMI$L_XBCR2 = 1060,0,32,0 %;      !  XMI-2 Bus control register
macro XMI$L_XFAER2 = 1068,0,32,0 %;     !  XMI-2 Failing addr. extension
macro XMI$L_XBEER2 = 1076,0,32,0 %;     !  XMI-2 Bus Error extendion
!  
macro XMI$L_XBE3 = 1540,0,32,0 %;       !  XMI-2 Bus Error register
macro XMI$L_XFAD3 = 1544,0,32,0 %;      !  XMI-2 Failing Addr register
macro XMI$L_NSCSR3 = 1564,0,32,0 %;     !  XMI-2 Node specific CSR
macro XMI$L_XBCR3 = 1572,0,32,0 %;      !  XMI-2 Bus control register
macro XMI$L_XFAER3 = 1580,0,32,0 %;     !  XMI-2 Failing addr. extension
macro XMI$L_XBEER3 = 1588,0,32,0 %;     !  XMI-2 Bus Error extendion
 
!*** MODULE $XRPDEF ***
! +
!   XRP Offset Definitions for Registers Accessible Through XMI Private
!   Space.  Note that in making these registers available in virtual space,
!   we have only mapped real registers.  Therefore these virtual offsets are
!   different than the hardware physical offsets.
! -
literal XRP$M_LED1 = 1;
literal XRP$M_LED2 = 2;
literal XRP$M_LED3 = 4;
literal XRP$M_LED4 = 8;
literal XRP$M_LED5 = 16;
literal XRP$M_LED6 = 32;
literal XRP$M_LEDSTV = 64;
literal XRP$M_LEDSTP = 128;
literal XRP$M_TERM_SEL = 3;
literal XRP$M_TERM_ENA = 4;
literal XRP$M_FORCE_P2_PARITY = 8;
literal XRP$M_FORCE_P1_PARITY = 16;
literal XRP$M_FORCE_P0_PARITY = 32;
literal XRP$C_AUX_CONSOLE = 0;          !  Auxilary console
literal XRP$C_SYSTEM_CONSOLE = 1;       !  System console
literal XRP$C_AUX_LOOPBACK = 2;         !  Auxilary console loopback
literal XRP$C_SYSTEM_LOOPBACK = 3;      !  System console loopback
literal XRP$M_XCAREV = 15;
literal XRP$M_SE = 16;
literal XRP$M_WBD = 256;
literal XRP$M_ARD = 512;
literal XRP$M_ESI = 1024;
literal XRP$M_IPID = 2048;
literal XRP$M_TOS = 4096;
literal XRP$M_RAMSPD = 8192;
literal XRP$M_CRDID = 16384;
literal XRP$M_CCID = 32768;
literal XRP$M_WS = 65536;
literal XRP$M_BPD = 131072;
literal XRP$M_BP = 262144;
literal XRP$M_CNAKR = 524288;
literal XRP$M_UWP = 1048576;
literal XRP$M_LOCKOUT = 6291456;
literal XRP$M_LTS = 8388608;
literal XRP$M_SSCIPL = 50331648;
literal XRP$M_WD = 67108864;
literal XRP$M_CFE = 134217728;
literal XRP$M_WDPE = 268435456;
literal XRP$M_XDPPE = 1073741824;
literal XRP$M_XCAPE = -2147483648;
literal XRP$M_RWT = 1073741824;
literal XRP$M_BTO = -2147483648;
literal XRP$M_CREG0_SEL = 1;
literal XRP$M_CREG1_SEL = 2;
literal XRP$M_CREG_DATA = 1020;
literal XRP$M_NODE_ID = 15;
literal XRP$M_FP_BOOT_DISABLE = 16;
literal XRP$M_FP_EEPROM_ENABLE = 32;
literal XRP$M_XACLO = 64;
literal XRP$M_STL_DISABLE = 128;
literal XRP$M_SCAN_TEST_DISABLE = 256;
literal XRP$M_CONSOLE_ENABLE = -2147483648;
literal XRP$S_XRPDEF = 99840;
macro XRP$L_CREGWE = 0,0,32,0 %;        !  XRP CREG[0|1] write enable. 
macro XRP$L_CREG0 = 0,0,32,0 %;         !  XRP CREG0 write enable. 
macro XRP$V_LED1 = 0,0,1,0 %;           !  LED 1
macro XRP$V_LED2 = 0,1,1,0 %;           !  LED 2
macro XRP$V_LED3 = 0,2,1,0 %;           !  LED 3
macro XRP$V_LED4 = 0,3,1,0 %;           !  LED 4
macro XRP$V_LED5 = 0,4,1,0 %;           !  LED 5
macro XRP$V_LED6 = 0,5,1,0 %;           !  LED 6
macro XRP$V_LEDSTV = 0,6,1,0 %;         !  LED 7, Selftest Valid
macro XRP$V_LEDSTP = 0,7,1,0 %;         !  LED 8, Selftest Passed
macro XRP$L_CREG1 = 0,0,32,0 %;         !  XRP CREG1 write enable. 
macro XRP$V_TERM_SEL = 0,0,2,0 %;
literal XRP$S_TERM_SEL = 2;             !  Console terminal mode select
macro XRP$V_TERM_ENA = 0,2,1,0 %;       !  Console terminal enable
macro XRP$V_FORCE_P2_PARITY = 0,3,1,0 %; !  Force P2 parity error
macro XRP$V_FORCE_P1_PARITY = 0,4,1,0 %; !  Force P1 parity error
macro XRP$V_FORCE_P0_PARITY = 0,5,1,0 %; !  Force P0 parity error
!  Console terminal modes
macro XRP$L_RCSR = 16,0,32,0 %;         !  XRP Control/Status register
macro XRP$V_XCAREV = 16,0,4,0 %;
literal XRP$S_XCAREV = 4;               !  XCA revision
macro XRP$V_SE = 16,4,1,0 %;            !  Second Error (2ERR) bit
macro XRP$V_WBD = 16,8,1,0 %;           !  Write Buffer Disable
macro XRP$V_ARD = 16,9,1,0 %;           !  Auto Retry Disable
macro XRP$V_ESI = 16,10,1,0 %;          !  Enable Self Invalidates
macro XRP$V_IPID = 16,11,1,0 %;         !  IP Interrupt Disable
macro XRP$V_TOS = 16,12,1,0 %;          !  Timeout Select
macro XRP$V_RAMSPD = 16,13,1,0 %;       !  RAM speed
macro XRP$V_CRDID = 16,14,1,0 %;        !  CRD Interrupt Disable
macro XRP$V_CCID = 16,15,1,0 %;         !  CC Interrupt Disable
macro XRP$V_WS = 16,16,1,0 %;           !  Warm start
macro XRP$V_BPD = 16,17,1,0 %;          !  Boot processor disabled
macro XRP$V_BP = 16,18,1,0 %;           !  Boot processor
macro XRP$V_CNAKR = 16,19,1,0 %;        !  Commander NOACK received
macro XRP$V_UWP = 16,20,1,0 %;          !  Unlock Write Pending
macro XRP$V_LOCKOUT = 16,21,2,0 %;
literal XRP$S_LOCKOUT = 2;              !  Interlock lockout <1:0>
macro XRP$V_LTS = 16,23,1,0 %;          !  Lockout Time Select
macro XRP$V_SSCIPL = 16,24,2,0 %;
literal XRP$S_SSCIPL = 2;               !  RSSC IPL <1:0>
macro XRP$V_WD = 16,26,1,0 %;           !  Write disable
macro XRP$V_CFE = 16,27,1,0 %;          !  Cache Fill Error
macro XRP$V_WDPE = 16,28,1,0 %;         !  Write Data Parity Error
macro XRP$V_XDPPE = 16,30,1,0 %;        !  XDP Parity Error
macro XRP$V_XCAPE = 16,31,1,0 %;        !  XCA Parity Error
!  +4.
macro XRP$L_SYSTYPE = 516,0,32,0 %;     !  System Type Register
macro XRP$L_SSCBAR = 1024,0,32,0 %;     !  RSSC Base Address Register
macro XRP$L_SSCCNF = 1040,0,32,0 %;     !  RSSC Configuration Register
macro XRP$L_SSCBTR = 1056,0,32,0 %;     !  XRP Control/Status register
macro XRP$V_RWT = 1056,30,1,0 %;        !  Read write timeout
macro XRP$V_BTO = 1056,31,1,0 %;        !  Bus timeout
macro XRP$L_SSCOPRT = 1072,0,32,0 %;    !  RSSC Output Port Register
macro XRP$V_CREG0_SEL = 1072,0,1,0 %;   !  CREG0 select 
macro XRP$V_CREG1_SEL = 1072,1,1,0 %;   !  CREG1 select
macro XRP$V_CREG_DATA = 1072,2,8,0 %;
literal XRP$S_CREG_DATA = 8;            !  CREG data, written to CREGn
!  selected by CREGn_SEL
macro XRP$L_SSCIPRT = 1088,0,32,0 %;    !  RSSC Input Port Register
macro XRP$V_NODE_ID = 1088,0,4,0 %;
literal XRP$S_NODE_ID = 4;              !  XMI node ID
macro XRP$V_FP_BOOT_DISABLE = 1088,4,1,0 %; !  Front panel boot disable sw
macro XRP$V_FP_EEPROM_ENABLE = 1088,5,1,0 %; !  Front panel EEPROM update sw
macro XRP$V_XACLO = 1088,6,1,0 %;       !  XMI AC LO
macro XRP$V_STL_DISABLE = 1088,7,1,0 %; !  Self-test loop disable
macro XRP$V_SCAN_TEST_DISABLE = 1088,8,1,0 %; !  Scan test disable
macro XRP$V_CONSOLE_ENABLE = 1088,31,1,0 %; !  Front-panel console enable
macro XRP$L_TCR0 = 1376,0,32,0 %;
macro XRP$L_TIR0 = 1380,0,32,0 %;
macro XRP$L_TNIR0 = 1384,0,32,0 %;
macro XRP$L_TIVR0 = 1388,0,32,0 %;
macro XRP$L_TCR1 = 1392,0,32,0 %;
macro XRP$L_TIR1 = 1396,0,32,0 %;
macro XRP$L_TNIR1 = 1400,0,32,0 %;
macro XRP$L_TIVR1 = 1404,0,32,0 %;
macro XRP$L_SSCICR = 1528,0,32,0 %;
!  New page
macro XRP$L_IPIVINTR = 1536,0,32,0 %;   !  Interprocessor communication area.
macro XRP$AB_EEPROM = 67072,0,8,0 %;    !  First page of EEPROM
 
!*** MODULE $XSADEF ***
! +      
!  This file contains offset definitions for registers accessible through XMI 
!  private space on the XSA XMI-SCSI adapter.  There are four groups of
!  register accessable through the XSA:
! 
!  	1) XMI required register
! 	2) XII registers
! 	3) Port 0 SII register
! 	4) Port 1 SII register
! 
!  To access these registers, add the Phyical or Virtual offset constant to the
!  base XMI CSR address, then use the appropiate symbolic offsets.
! -
literal XSA$K_XMI_PHY = 0;
literal XSA$K_XMI_VIR = 0;
literal XSA$K_XII_PHY = 4096;
literal XSA$K_XII_VIR = 512;
literal XSA$K_SII0_PHY = 8192;
literal XSA$K_SII0_VIR = 1024;
literal XSA$K_SII1_PHY = 12288;
literal XSA$K_SII1_VIR = 1536;
literal XSA_XSACSR0$M_P0I = 1;
literal XSA_XSACSR0$M_P1I = 2;
literal XSA_XSACSR0$M_XIE = 4;
literal XSA_XSACSR0$M_P0IE = 8;
literal XSA_XSACSR0$M_P1IE = 16;
literal XSA_XSACSR0$M_DME0S = 32;
literal XSA_XSACSR0$M_DME1S = 64;
literal XSA_XSACSR0$M_XIIR = 1920;
literal XSA_XSACSR0$M_XRD = 2048;
literal XSA_XSACSR0$M_P0TPE = 4096;
literal XSA_XSACSR0$M_P1TPE = 8192;
literal XSA_XSACSR0$M_XUE = 16384;
literal XSA_XSACSR0$M_FILL_1 = 134184960;
literal XSA_XSACSR0$M_TTOV = -134217728;
literal XSA_XSADR$M_LPBK0 = 1;
literal XSA_XSADR$M_LPBK1 = 2;
literal XSA_XSADR$M_FBXPL0 = 4;
literal XSA_XSADR$M_FBXPL1 = 8;
literal XSA_XSADR$M_FBXPF = 16;
literal XSA_XSADR$M_FBPI0 = 32;
literal XSA_XSADR$M_FBPI1 = 64;
literal XSA_XSADR$M_FBPC0O = 128;
literal XSA_XSADR$M_FBPC1O = 256;
literal XSA_XSADR$M_FBPPXDO = 512;
literal XSA_XSADR$M_FCCB0B = 1024;
literal XSA_XSADR$M_FCCB1B = 2048;
literal XSA_XSADR$M_FDDB0F = 4096;
literal XSA_XSADR$M_FDDB1F = 8192;
literal XSA_XSADR$M_SLOWCLK = 16384;
literal XSA_XSADR$M_FILL_1 = 98304;
literal XSA_XSADR$M_VSEL = 4063232;
literal XSA_XSADR$M_SMSEL = 29360128;
literal XSA_XSADR$M_SM = 1040187392;
literal XSA_XSADR$M_FILL_2 = 1073741824;
literal XSA_XSADR$M_XIIIS = -2147483648;
literal XSA_XIIICR$M_XIL = 3;
literal XSA_XIIICR$M_XVEC = 65532;
literal XSA_XIIICR$M_XID = -65536;
literal XSA_XIIIESR$M_P0I = 1;
literal XSA_XIIIESR$M_P1I = 2;
literal XSA_XIIIESR$M_FILL_1 = 12;
literal XSA_XIIIESR$M_D0IXC = 16;
literal XSA_XIIIESR$M_D1IXC = 32;
literal XSA_XIIIESR$M_FILL_2 = 192;
literal XSA_XIIIESR$M_I0OPE = 256;
literal XSA_XIIIESR$M_I1OPE = 512;
literal XSA_XIIIESR$M_IEA = 1024;
literal XSA_XIIIESR$M_ISSM = 14336;
literal XSA_XIIIESR$M_WTE = 16384;
literal XSA_XIIIESR$M_XBES = 32768;
literal XSA_XIIIESR$M_I0IPE = 65536;
literal XSA_XIIIESR$M_I1IPE = 131072;
literal XSA_XIIIESR$M_TPEL0 = 262144;
literal XSA_XIIIESR$M_TPEL1 = 524288;
literal XSA_XIIIESR$M_P0O = 1048576;
literal XSA_XIIIESR$M_P0U = 2097152;
literal XSA_XIIIESR$M_P1O = 4194304;
literal XSA_XIIIESR$M_P1U = 8388608;
literal XSA_XIIIESR$M_P0PE = 16777216;
literal XSA_XIIIESR$M_P1PE = 33554432;
literal XSA_XIIIEMR$M_FILL_1 = 7;
literal XSA_XIIIEMR$M_XCM = 8;
literal XSA_XIIIEMR$M_D0IXC = 16;
literal XSA_XIIIEMR$M_D1IXC = 32;
literal XSA_XIIIEMR$M_FILL_2 = 192;
literal XSA_XIIIEMR$M_I0OPE = 256;
literal XSA_XIIIEMR$M_I1OPE = 512;
literal XSA_XIIIEMR$M_IEA = 1024;
literal XSA_XIIIEMR$M_ISSM = 2048;
literal XSA_XIIIEMR$M_FILL_3 = 12288;
literal XSA_XIIIEMR$M_WTE = 16384;
literal XSA_XIIIEMR$M_XBES = 32768;
literal XSA_XIIIEMR$M_I0IPE = 65536;
literal XSA_XIIIEMR$M_I1IPE = 131072;
literal XSA_XIIIEMR$M_TPEL0 = 262144;
literal XSA_XIIIEMR$M_TPEL1 = 524288;
literal XSA_XIIIEMR$M_P0O = 1048576;
literal XSA_XIIIEMR$M_P0U = 2097152;
literal XSA_XIIIEMR$M_P1O = 4194304;
literal XSA_XIIIEMR$M_P1U = 8388608;
literal XSA_XIIIEMR$M_P0PE = 16777216;
literal XSA_XIIIEMR$M_P1PE = 33554432;
literal XSA_P0DATPE$M_P0DATPE = 255;
literal XSA_P0DATPE$M_FILL_1 = 2147483392;
literal XSA_P0DATPE$M_DO = -2147483648;
literal XSA_P0ICR$M_P0IL = 3;
literal XSA_P0ICR$M_P0VEC = 65532;
literal XSA_P0ICR$M_P0ID = -65536;
literal XSA_P1DATPE$M_P1DATPE = 255;
literal XSA_P1DATPE$M_FILL_1 = 2147483392;
literal XSA_P1DATPE$M_DO = -2147483648;
literal XSA_P1ICR$M_P1IL = 3;
literal XSA_P1ICR$M_P1VEC = 65532;
literal XSA_P1ICR$M_P1ID = -65536;
literal XSA_XDATH0$M_P0AE = 255;
literal XSA_XDATH0$M_P0LT = 256;
literal XSA_XDATH0$M_FILL_1 = 65024;
literal XSA_XDATH0$M_P0DEBC = -65536;
literal XSA_XDATH1$M_P1AE = 255;
literal XSA_XDATH1$M_P1LT = 256;
literal XSA_XDATH1$M_FILL_1 = 65024;
literal XSA_XDATH1$M_P1DEBC = -65536;
literal XSA$S_XSADEF = 68;
macro XSA$L_XSACSR0 = 0,0,32,0 %;       !  XSA Control and Status reg.
macro XSA_XSACSR0$V_P0I = 0,0,1,0 %;    !  Initialize Port 0 
macro XSA_XSACSR0$V_P1I = 0,1,1,0 %;    !  Initialize Port 1 
macro XSA_XSACSR0$V_XIE = 0,2,1,0 %;    !  XII Interupt Enable
macro XSA_XSACSR0$V_P0IE = 0,3,1,0 %;   !  Port 0 Interupt Enable
macro XSA_XSACSR0$V_P1IE = 0,4,1,0 %;   !  Port 1 Interupt Enable
macro XSA_XSACSR0$V_DME0S = 0,5,1,0 %;  !  Abort DMA transaction on P0
macro XSA_XSACSR0$V_DME1S = 0,6,1,0 %;  !  Abort DMA transaction on P1
macro XSA_XSACSR0$V_XIIR = 0,7,4,0 %;
literal XSA_XSACSR0$S_XIIR = 4;         !  XII Revision
macro XSA_XSACSR0$V_XRD = 0,11,1,0 %;   !  XMI Retry Disable
macro XSA_XSACSR0$V_P0TPE = 0,12,1,0 %; !  Port 0 Transmit Parity Error
macro XSA_XSACSR0$V_P1TPE = 0,13,1,0 %; !  Port 1 Transmit Parity Error
macro XSA_XSACSR0$V_XUE = 0,14,1,0 %;   !  XMI Update Enable
macro XSA_XSACSR0$V_TTOV = 0,27,5,0 %;
literal XSA_XSACSR0$S_TTOV = 5;         !  Transaction Timeout Value
macro XSA$L_XSADR = 4,0,32,0 %;         !  XDA Diagnostic registers
macro XSA_XSADR$V_LPBK0 = 4,0,1,0 %;    !  Loopback 0
macro XSA_XSADR$V_LPBK1 = 4,1,1,0 %;    !  Loopback 1
macro XSA_XSADR$V_FBXPL0 = 4,2,1,0 %;   !  Xmit inverted partity on LW0
macro XSA_XSADR$V_FBXPL1 = 4,3,1,0 %;   !  Xmit inverted partity on LW1
macro XSA_XSADR$V_FBXPF = 4,4,1,0 %;    !  Force Bad XMI parity F/ID
macro XSA_XSADR$V_FBPI0 = 4,5,1,0 %;    !  Invert parity on II0 bus
macro XSA_XSADR$V_FBPI1 = 4,6,1,0 %;    !  Invert parity on II1 bus
macro XSA_XSADR$V_FBPC0O = 4,7,1,0 %;   !  Bad Parity CCB/DDB 0 outgoing
macro XSA_XSADR$V_FBPC1O = 4,8,1,0 %;   !  Bad Parity CCB/DDB 1 outgoing
macro XSA_XSADR$V_FBPPXDO = 4,9,1,0 %;  !  Bad Parity XMI Data Only
macro XSA_XSADR$V_FCCB0B = 4,10,1,0 %;  !  Force CPU Cmd. Buffer 0 Busy
macro XSA_XSADR$V_FCCB1B = 4,11,1,0 %;  !  Force CPU Cmd. Buffer 1 Busy
macro XSA_XSADR$V_FDDB0F = 4,12,1,0 %;  !  Force DMA Data Buffer 0 Full
macro XSA_XSADR$V_FDDB1F = 4,13,1,0 %;  !  Force DMA Data Buffer 1 Full
macro XSA_XSADR$V_SLOWCLK = 4,14,1,0 %; !  Use slow clock
macro XSA_XSADR$V_VSEL = 4,17,5,0 %;
literal XSA_XSADR$S_VSEL = 5;           !  Select signals output to VBUS
macro XSA_XSADR$V_SMSEL = 4,22,3,0 %;
literal XSA_XSADR$S_SMSEL = 3;          !  Select a state machine
macro XSA_XSADR$V_SM = 4,25,5,0 %;
literal XSA_XSADR$S_SM = 5;             !  Select a state number
macro XSA_XSADR$V_XIIIS = 4,31,1,0 %;   !  Interrupt summary
macro XSA$L_XIIICR = 8,0,32,0 %;        !  XII Interrupt Control reg.
macro XSA_XIIICR$V_XIL = 8,0,2,0 %;
literal XSA_XIIICR$S_XIL = 2;           !  Interrupt Level
macro XSA_XIIICR$V_XVEC = 8,2,14,0 %;
literal XSA_XIIICR$S_XVEC = 14;         !  Interrupt Vector
macro XSA_XIIICR$V_XID = 8,16,16,0 %;
literal XSA_XIIICR$S_XID = 16;          !  Interrupt Destination mask
macro XSA$L_XIIIESR = 12,0,32,0 %;      !  XII Interrupt & Error status
macro XSA_XIIIESR$V_P0I = 12,0,1,0 %;   !  Port 0 interrupt
macro XSA_XIIIESR$V_P1I = 12,1,1,0 %;   !  Port 1 interrupt
macro XSA_XIIIESR$V_D0IXC = 12,4,1,0 %; !  DME 0 Incomming Xfer Complete
macro XSA_XIIIESR$V_D1IXC = 12,5,1,0 %; !  DME 1 Incomming Xfer Complete
macro XSA_XIIIESR$V_I0OPE = 12,8,1,0 %; !  II0 Outgoing Partiy Error
macro XSA_XIIIESR$V_I1OPE = 12,9,1,0 %; !  II1 Outgoing Partiy Error
macro XSA_XIIIESR$V_IEA = 12,10,1,0 %;  !  Invalid ExPROM Address
macro XSA_XIIIESR$V_ISSM = 12,11,3,0 %;
literal XSA_XIIIESR$S_ISSM = 3;         !  Illegal State in State Mach.
macro XSA_XIIIESR$V_WTE = 12,14,1,0 %;  !  Write attempted EPROM
macro XSA_XIIIESR$V_XBES = 12,15,1,0 %; !  Copy of XBE error summary
macro XSA_XIIIESR$V_I0IPE = 12,16,1,0 %; !  II0 Incomming Partiy Error
macro XSA_XIIIESR$V_I1IPE = 12,17,1,0 %; !  II1 Incomming Partiy Error
macro XSA_XIIIESR$V_TPEL0 = 12,18,1,0 %; !  Transmit Parity Error on LW0
macro XSA_XIIIESR$V_TPEL1 = 12,19,1,0 %; !  Transmit Parity Error on LW1
macro XSA_XIIIESR$V_P0O = 12,20,1,0 %;  !  Port 0 Overflow
macro XSA_XIIIESR$V_P0U = 12,21,1,0 %;  !  Port 0 Underflow
macro XSA_XIIIESR$V_P1O = 12,22,1,0 %;  !  Port 1 Overflow
macro XSA_XIIIESR$V_P1U = 12,23,1,0 %;  !  Port 1 Underflow
macro XSA_XIIIESR$V_P0PE = 12,24,1,0 %; !  Port 0 Pointer Error
macro XSA_XIIIESR$V_P1PE = 12,25,1,0 %; !  Port 1 Pointer Error
macro XSA$L_XIIIEMR = 16,0,32,0 %;      !  XII Interrupt & Error mask
macro XSA_XIIIEMR$V_XCM = 16,3,1,0 %;   !  XBE CRD Mask
macro XSA_XIIIEMR$V_D0IXC = 16,4,1,0 %; !  DME 0 Incomming Xfer Complete
macro XSA_XIIIEMR$V_D1IXC = 16,5,1,0 %; !  DME 1 Incomming Xfer Complete
macro XSA_XIIIEMR$V_I0OPE = 16,8,1,0 %; !  II0 Outgoing Partiy Error
macro XSA_XIIIEMR$V_I1OPE = 16,9,1,0 %; !  II1 Outgoing Partiy Error
macro XSA_XIIIEMR$V_IEA = 16,10,1,0 %;  !  Invalid ExPROM Address
macro XSA_XIIIEMR$V_ISSM = 16,11,1,0 %; !  Illegal State in State Mach.
macro XSA_XIIIEMR$V_WTE = 16,14,1,0 %;  !  Write attempted EPROM
macro XSA_XIIIEMR$V_XBES = 16,15,1,0 %; !  Copy of XBE error summary
macro XSA_XIIIEMR$V_I0IPE = 16,16,1,0 %; !  II0 Incomming Partiy Error
macro XSA_XIIIEMR$V_I1IPE = 16,17,1,0 %; !  II1 Incomming Partiy Error
macro XSA_XIIIEMR$V_TPEL0 = 16,18,1,0 %; !  Transmit Parity Error on LW0
macro XSA_XIIIEMR$V_TPEL1 = 16,19,1,0 %; !  Transmit Parity Error on LW1
macro XSA_XIIIEMR$V_P0O = 16,20,1,0 %;  !  Port 0 Overflow
macro XSA_XIIIEMR$V_P0U = 16,21,1,0 %;  !  Port 0 Underflow
macro XSA_XIIIEMR$V_P1O = 16,22,1,0 %;  !  Port 1 Overflow
macro XSA_XIIIEMR$V_P1U = 16,23,1,0 %;  !  Port 1 Underflow
macro XSA_XIIIEMR$V_P0PE = 16,24,1,0 %; !  Port 0 Pointer Error
macro XSA_XIIIEMR$V_P1PE = 16,25,1,0 %; !  Port 1 Pointer Error
macro XSA$L_P0DATP = 20,0,32,0 %;       !  P0 DMA Address Table Pointer
!   Must be quadword aligned,
!   i.e. <2:0> must be zero
macro XSA$L_P0DATPE = 24,0,32,0 %;      !  P0 DMA Addr. Table Extension
macro XSA_P0DATPE$V_P0DATPE = 24,0,8,0 %;
literal XSA_P0DATPE$S_P0DATPE = 8;      !  Physical address <39:32>
macro XSA_P0DATPE$V_DO = 24,31,1,0 %;   !  Direction for mover - DMA Out
macro XSA$L_P0ICR = 28,0,32,0 %;        !  P0 Interrupt Control register
macro XSA_P0ICR$V_P0IL = 28,0,2,0 %;
literal XSA_P0ICR$S_P0IL = 2;           !  Interrupt Level
macro XSA_P0ICR$V_P0VEC = 28,2,14,0 %;
literal XSA_P0ICR$S_P0VEC = 14;         !  Interrupt Vector
macro XSA_P0ICR$V_P0ID = 28,16,16,0 %;
literal XSA_P0ICR$S_P0ID = 16;          !  Interrupt Destination mask
macro XSA$L_P1DATP = 32,0,32,0 %;       !  P1 DMA Address Table Pointer
!   Must be quadword aligned,
!   i.e. <2:0> must be zero
macro XSA$L_P1DATPE = 36,0,32,0 %;      !  P1 DMA Addr. Table Extension
macro XSA_P1DATPE$V_P1DATPE = 36,0,8,0 %;
literal XSA_P1DATPE$S_P1DATPE = 8;      !  Physical address <39:32>
macro XSA_P1DATPE$V_DO = 36,31,1,0 %;   !  Direction for mover - DMA Out
macro XSA$L_P1ICR = 40,0,32,0 %;        !  P1 Interrupt Control register
macro XSA_P1ICR$V_P1IL = 40,0,2,0 %;
literal XSA_P1ICR$S_P1IL = 2;           !  Interrupt Level
macro XSA_P1ICR$V_P1VEC = 40,2,14,0 %;
literal XSA_P1ICR$S_P1VEC = 14;         !  Interrupt Vector
macro XSA_P1ICR$V_P1ID = 40,16,16,0 %;
literal XSA_P1ICR$S_P1ID = 16;          !  Interrupt Destination mask
macro XSA$L_EAR = 44,0,32,0 %;          !  ExPROM address register 
macro XSA$L_EDR = 48,0,32,0 %;          !  ExPROM data register
macro XSA$L_XDATH0 = 52,0,32,0 %;       !  XII DAT High 0 register
macro XSA_XDATH0$V_P0AE = 52,0,8,0 %;
literal XSA_XDATH0$S_P0AE = 8;          !  Port 0 Physcal Addr. <39:32>
macro XSA_XDATH0$V_P0LT = 52,8,1,0 %;   !  Port 0 Last Transaction bit
macro XSA_XDATH0$V_P0DEBC = 52,16,16,0 %;
literal XSA_XDATH0$S_P0DEBC = 16;       !  Port 0 DAT Entry Byte Count
macro XSA$L_XDATL0 = 56,0,32,0 %;       !  XII DAT Low 0 register <31:0>
macro XSA$L_XDATH1 = 60,0,32,0 %;       !  XII DAT High 1 register
macro XSA_XDATH1$V_P1AE = 60,0,8,0 %;
literal XSA_XDATH1$S_P1AE = 8;          !  Port 1 Physcal Addr. <39:32>
macro XSA_XDATH1$V_P1LT = 60,8,1,0 %;   !  Port 1 Last Transaction bit
macro XSA_XDATH1$V_P1DEBC = 60,16,16,0 %;
literal XSA_XDATH1$S_P1DEBC = 16;       !  Port 1 DAT Entry Byte Count
macro XSA$L_XDATL1 = 64,0,32,0 %;       !  XII DAT Low 1 register <31:0>
literal XSA_DATH$M_AE = 255;
literal XSA_DATH$M_LT = 256;
literal XSA_DATH$M_FILL_1 = 65024;
literal XSA_DATH$M_DEBC = -65536;
literal XSA$S_DATDEF = 8;
macro XSA$L_DATL = 0,0,32,0 %;          !  XII DAT Low 0rder register <31:0>
macro XSA$L_DATH = 4,0,32,0 %;          !  XII DAT High 0 register
macro XSA_DATH$V_AE = 4,0,8,0 %;
literal XSA_DATH$S_AE = 8;              !  Port 0 Physcal Addr. <39:32>
macro XSA_DATH$V_LT = 4,8,1,0 %;        !  Port 0 Last Transaction bit
macro XSA_DATH$V_DEBC = 4,16,16,0 %;
literal XSA_DATH$S_DEBC = 16;           !  Port 0 DAT Entry Byte Count
 
!*** MODULE $X1202DEF ***
! +
!   This file contains offset definitions for registers accessible through XMI 
!   private space on the Mariah/XMP processor.  Note that in making these 
!   registers available in virtual space, we have only mapped real registers.  
!   Therefore these virtual offsets are different than the hardware physical 
!   offsets.
! -
literal X1202_CREG0$M_TERM_SEL = 3;
literal X1202_CREG0$M_TERM_ENA = 4;
literal X1202_CREG0$M_STP_LED = 8;
literal X1202_CREG0$M_IO_1 = 16;
literal X1202_CREG0$M_IO_2 = 32;
literal X1202_CREG0$M_FPSEL = 64;
literal X1202_CREG1$M_ST_LED1 = 1;
literal X1202_CREG1$M_ST_LED2 = 2;
literal X1202_CREG1$M_ST_LED3 = 4;
literal X1202_CREG1$M_ST_LED4 = 8;
literal X1202_CREG1$M_ST_LED5 = 16;
literal X1202_CREG1$M_ST_LED6 = 32;
literal X1202_CREG1$M_ST_LED7 = 64;
literal X1202_CREG1$M_ST_LED8 = 128;
literal X1202_CREG0$C_AUX_CONSOLE = 0;  !  Auxilary console
literal X1202_CREG0$C_SYSTEM_CONSOLE = 1; !  System console
literal X1202_CREG0$C_AUX_LOOPBACK = 2; !  Auxilary console loopback
literal X1202_CREG0$C_SYSTEM_LOOPBACK = 3; !  System console loopback
literal X1202_MFADR$M_INT_SOURCE = 65535;
literal X1202_MFADR$M_IPL = 983040;
literal X1202_MFADR$M_INT_DEST = 65535;
literal X1202_MFADR$M_IP_IVINTR = 65536;
literal X1202_MFADR$M_WE_IVINTR = 131072;
literal X1202_MFADR$M_FADR = 1073741823;
literal X1202_MFADR$M_FLN = -1073741824;
literal X1202_MCSR0$M_XGAREV = 15;
literal X1202_MCSR0$M_WS = 16;
literal X1202_MCSR0$M_BP = 32;
literal X1202_MCSR0$M_BPD = 64;
literal X1202_MCSR0$M_HDOD = 3968;
literal X1202_MCR0$M_LOCMOD = 3;
literal X1202_MCR0$M_XBADD = 4;
literal X1202_MCR0$M_TRIGC = 24;
literal X1202_MCR0$M_CRDID = 32;
literal X1202_MCR0$M_CCID = 64;
literal X1202_MCR0$M_MSCIPL = 1536;
literal X1202_MCR0$M_LDTE = 4096;
literal X1202_MCR0$M_LEDC = 24576;
literal X1202_MCR0$M_VME = 32768;
literal X1202_MCR0$M_TOS = 196608;
literal X1202_MCR0$M_ESI = 262144;
literal X1202_MCR0$M_XMIFP = 3670016;
literal X1202_MCR0$M_GMXSL = 62914560;
literal X1202_MCR0$M_FIBP = 268435456;
literal X1202_MCR0$M_CWBD = 536870912;
literal X1202_MCR0$M_ACPCD = 1073741824;
literal X1202_MCR0$M_FACBP = -2147483648;
literal X1202_MBEER0$M_SEO = 1;
literal X1202_MBEER0$M_OLR = 2;
literal X1202_MBEER0$M_URR = 4;
literal X1202_MBEER0$M_UUW = 256;
literal X1202_MBEER0$M_MCAXPE = 512;
literal X1202_MBEER0$M_MDAXPE = 1024;
literal X1202_MBEER0$M_UWP = 2048;
literal X1202_MBEER0$M_WFDQ0 = 4096;
literal X1202_MBEER0$M_WSEO0 = 8192;
literal X1202_MBEER0$M_WCNAK0 = 16384;
literal X1202_MBEER0$M_WWDNAK0 = 32768;
literal X1202_MBEER0$M_WTTO0 = 65536;
literal X1202_MBEER0$M_WTBDAT0 = 131072;
literal X1202_MBEER0$M_WSQE0 = 262144;
literal X1202_MBEER0$M_WCDE0 = 524288;
literal X1202_MBEER0$M_WFDQ1 = 1048576;
literal X1202_MBEER0$M_WSEO1 = 2097152;
literal X1202_MBEER0$M_WCNAK1 = 4194304;
literal X1202_MBEER0$M_WWDNAK1 = 8388608;
literal X1202_MBEER0$M_WTTO1 = 16777216;
literal X1202_MBEER0$M_WTBDAT1 = 33554432;
literal X1202_MBEER0$M_WSQE1 = 67108864;
literal X1202_MBEER0$M_WCDE1 = 134217728;
literal X1202_MBEER0$M_ACPE = 536870912;
literal X1202_MBEER0$M_WDPE = 1073741824;
literal X1202_MBEER0$M_CFE = -2147483648;
literal X1202_WFADR0$M_ADDR = 1073741823;
literal X1202_WFADR0$M_ADDR_EXT = -1073741824;
literal X1202_WFADR1$M_ADDR = 1073741823;
literal X1202_WFADR1$M_ADDR_EXT = -1073741824;
literal X1202_SSCCNR$M_CREG_ADS_ENA = 7;
literal X1202_SSCCNR$M_EEPROM_ADS_ENA = 112;
literal X1202_SSCCNR$M_TERM_BAUD_SEL = 28672;
literal X1202_SSCCNR$M_CTRL_P_ENA = 32768;
literal X1202_SSCCNR$M_HALT_PROT = 458752;
literal X1202_SSCCNR$M_ROM_SIZE = 7340032;
literal X1202_SSCCNR$M_ROM_SPEED = 8388608;
literal X1202_SSCCNR$M_IPL_SEL = 50331648;
literal X1202_SSCCNR$M_IV_DISABLE = 134217728;
literal X1202_SSCCNR$M_BLO = -2147483648;
literal X1202_SSCBTR$M_TMO_INTERVAL = 16777215;
literal X1202_SSCBTR$M_RWT = 1073741824;
literal X1202_SSCBTR$M_BTO = -2147483648;
literal X1202_SSCOPRT$M_CREG0_SEL = 1;
literal X1202_SSCOPRT$M_CREG1_SEL = 2;
literal X1202_SSCOPRT$M_CREG_DATA = 1020;
literal X1202_SSCIPRT$M_NODE_ID = 15;
literal X1202_SSCIPRT$M_FP_BOOT_DISABLE = 16;
literal X1202_SSCIPRT$M_FP_EEPROM_ENA = 32;
literal X1202_SSCIPRT$M_XACLO = 64;
literal X1202_SSCIPRT$M_STL_DISABLE = 128;
literal X1202_SSCIPRT$M_SCAN_TEST_DIS = 256;
literal X1202_SSCIPRT$M_CONSOLE_ENABLE = -2147483648;
literal X1202_TCR0$M_RUN = 1;
literal X1202_TCR0$M_STP = 4;
literal X1202_TCR0$M_XFR = 16;
literal X1202_TCR0$M_SGL = 32;
literal X1202_TCR0$M_IE = 64;
literal X1202_TCR0$M_INT = 128;
literal X1202_TCR0$M_ERR = -2147483648;
literal X1202_TIVR0$M_VECTOR = 1020;
literal X1202_TCR1$M_RUN = 1;
literal X1202_TCR1$M_STP = 4;
literal X1202_TCR1$M_XFR = 16;
literal X1202_TCR1$M_SGL = 32;
literal X1202_TCR1$M_IE = 64;
literal X1202_TCR1$M_INT = 128;
literal X1202_TCR1$M_ERR = -2147483648;
literal X1202_TIVR1$M_VECTOR = 1020;
literal X1202_DCSR$M_MDAREV = 15;
literal X1202_DCSR$M_EFECC = 16;
literal X1202_DCSR$M_EFDP = 32;
literal X1202_DCSR$M_RUP = 64;
literal X1202_DCSR$M_WBECCD = 128;
literal X1202_DCSR$M_FECC = 16128;
literal X1202_DCSR$M_FDP = 16384;
literal X1202_DCSR$M_WDPCD = 32768;
literal X1202_DCSR$M_EFXMIP = 65536;
literal X1202_DCSR$M_FXMIP = 393216;
literal X1202_FDAL3$M_ECC = 65535;
literal X1202_FDAL3$M_DP = 16711680;
literal X1202$S_X1202DEF = 100352;
! *****************************************************************************/
!  Page 0                                                                     */
! *****************************************************************************/
macro X1202$L_MDEV = 0,0,32,0 %;        !  Standard XMI XDEV register
macro X1202$L_CREGWE = 0,0,32,0 %;      !  CREG0/1 write enable
macro X1202$L_CREG0 = 0,0,32,0 %;       !  CREG0 (if mapped by SSCOPRT)
macro X1202_CREG0$V_TERM_SEL = 0,0,2,0 %;
literal X1202_CREG0$S_TERM_SEL = 2;     !  Console terminal mode
macro X1202_CREG0$V_TERM_ENA = 0,2,1,0 %; !  Console terminal enable
macro X1202_CREG0$V_STP_LED = 0,3,1,0 %; !  Self-test-passed LED
macro X1202_CREG0$V_IO_1 = 0,4,1,0 %;   !  Drives inverted bit on backplane
macro X1202_CREG0$V_IO_2 = 0,5,1,0 %;   !  Drives inverted bit on backplane
macro X1202_CREG0$V_FPSEL = 0,6,1,0 %;  !  Force MCA to bad XMI parity
macro X1202$L_CREG1 = 0,0,32,0 %;       !  CREG1 (if mapped by SSCOPRT)
macro X1202_CREG1$V_ST_LED1 = 0,0,1,0 %; !  XMP module LED 1
macro X1202_CREG1$V_ST_LED2 = 0,1,1,0 %; !  XMP module LED 2
macro X1202_CREG1$V_ST_LED3 = 0,2,1,0 %; !  XMP module LED 3
macro X1202_CREG1$V_ST_LED4 = 0,3,1,0 %; !  XMP module LED 4
macro X1202_CREG1$V_ST_LED5 = 0,4,1,0 %; !  XMP module LED 5
macro X1202_CREG1$V_ST_LED6 = 0,5,1,0 %; !  XMP module LED 6
macro X1202_CREG1$V_ST_LED7 = 0,6,1,0 %; !  XMP module LED 7
macro X1202_CREG1$V_ST_LED8 = 0,7,1,0 %; !  XMP module LED 8
!  Console terminal modes
macro X1202$L_MBE = 4,0,32,0 %;         !  Standard XMI XBE register
macro X1202$L_MFADR0 = 8,0,32,0 %;      !  XMI Failing Address register
macro X1202_MFADR$V_INT_SOURCE = 8,0,16,0 %;
literal X1202_MFADR$S_INT_SOURCE = 16;  !  Interrupt Source
macro X1202_MFADR$V_IPL = 8,16,4,0 %;
literal X1202_MFADR$S_IPL = 4;          !  Failing length
macro X1202_MFADR$V_INT_DEST = 8,0,16,0 %;
literal X1202_MFADR$S_INT_DEST = 16;    !  Interrupt Destination
macro X1202_MFADR$V_IP_IVINTR = 8,16,1,0 %; !  Interprocessor interrupt
macro X1202_MFADR$V_WE_IVINTR = 8,17,1,0 %; !  Write Enable interrupt
macro X1202_MFADR$V_FADR = 8,0,30,0 %;
literal X1202_MFADR$S_FADR = 30;        !  Failing Address
macro X1202_MFADR$V_FLN = 8,30,2,0 %;
literal X1202_MFADR$S_FLN = 2;          !  Failing length
macro X1202$L_XGPR = 12,0,32,0 %;       !  Standard XMI-2 XGPR register
macro X1202$L_MCSR0 = 28,0,32,0 %;      !  XMP Control/Status register0
macro X1202_MCSR0$V_XGAREV = 28,0,4,0 %;
literal X1202_MCSR0$S_XGAREV = 4;       !  MCA revision
macro X1202_MCSR0$V_WS = 28,4,1,0 %;    !  Warm start
macro X1202_MCSR0$V_BP = 28,5,1,0 %;    !  Boot processor
macro X1202_MCSR0$V_BPD = 28,6,1,0 %;   !  Boot processor disabled
macro X1202_MCSR0$V_HDOD = 28,7,5,0 %;
literal X1202_MCSR0$S_HDOD = 5;         !  High Drive Output Disable
macro X1202$L_MCR0 = 36,0,32,0 %;       !  XMP Control register0
macro X1202_MCR0$V_LOCMOD = 36,0,2,0 %;
literal X1202_MCR0$S_LOCMOD = 2;        !  Lockout Mode
macro X1202_MCR0$V_XBADD = 36,2,1,0 %;  !  XMI Bad Drive
macro X1202_MCR0$V_TRIGC = 36,3,2,0 %;
literal X1202_MCR0$S_TRIGC = 2;         !  Selects XMI Trigger Condition
macro X1202_MCR0$V_CRDID = 36,5,1,0 %;  !  Corrected Read Data Int. Dis.
macro X1202_MCR0$V_CCID = 36,6,1,0 %;   !  Corrected Conf. Int. Dis.
macro X1202_MCR0$V_MSCIPL = 36,9,2,0 %;
literal X1202_MCR0$S_MSCIPL = 2;        !  MSSC IPL (14,15,16,17 HEX)
macro X1202_MCR0$V_LDTE = 36,12,1,0 %;  !  Lockout Debug Timeout Enable
macro X1202_MCR0$V_LEDC = 36,13,2,0 %;
literal X1202_MCR0$S_LEDC = 2;          !  LED control
macro X1202_MCR0$V_VME = 36,15,1,0 %;   !  Vector Mode Enable
macro X1202_MCR0$V_TOS = 36,16,2,0 %;
literal X1202_MCR0$S_TOS = 2;           !  Timeout Select
macro X1202_MCR0$V_ESI = 36,18,1,0 %;   !  Enable Self Invalidates
macro X1202_MCR0$V_XMIFP = 36,19,3,0 %;
literal X1202_MCR0$S_XMIFP = 3;         !  Force XMI Parity
macro X1202_MCR0$V_GMXSL = 36,22,4,0 %;
literal X1202_MCR0$S_GMXSL = 4;         !  Gate Array Visability MuxSel
macro X1202_MCR0$V_FIBP = 36,28,1,0 %;  !  Force IBUS Bad Parity
macro X1202_MCR0$V_CWBD = 36,29,1,0 %;  !  Flush WriteBack & Invalid
macro X1202_MCR0$V_ACPCD = 36,30,1,0 %; !  Addr/Cmd Parity Check Disable
macro X1202_MCR0$V_FACBP = 36,31,1,0 %; !  Force Addr/Cmd Bad Parity
macro X1202$L_MFAER0 = 44,0,32,0 %;     !  Standard XMI-2 XFAER0 reg.
macro X1202$L_MBEER0 = 52,0,32,0 %;     !  XMP Error Extension register
macro X1202_MBEER0$V_SEO = 52,0,1,0 %;  !  Second Error Occured
macro X1202_MBEER0$V_OLR = 52,1,1,0 %;  !  Only LOC Response
macro X1202_MBEER0$V_URR = 52,2,1,0 %;  !  Unexpected Read Response
macro X1202_MBEER0$V_UUW = 52,8,1,0 %;  !  Unexpected Unlock Write
macro X1202_MBEER0$V_MCAXPE = 52,9,1,0 %; !  MCA XMI Parity Error
macro X1202_MBEER0$V_MDAXPE = 52,10,1,0 %; !  MDA XMI Parity Error
macro X1202_MBEER0$V_UWP = 52,11,1,0 %; !  Unlock Write Pending
macro X1202_MBEER0$V_WFDQ0 = 52,12,1,0 %; !  WB0 Failing Dal Qualifier
macro X1202_MBEER0$V_WSEO0 = 52,13,1,0 %; !  WB0 Second Error Occured
macro X1202_MBEER0$V_WCNAK0 = 52,14,1,0 %; !  WB0 Command NOACK
macro X1202_MBEER0$V_WWDNAK0 = 52,15,1,0 %; !  WB0 Write Data NoACK
macro X1202_MBEER0$V_WTTO0 = 52,16,1,0 %; !  WB0 Transaction Timeout
macro X1202_MBEER0$V_WTBDAT0 = 52,17,1,0 %; !  WB0 Tagged Bad Data
macro X1202_MBEER0$V_WSQE0 = 52,18,1,0 %; !  WB0 Sequence Error
macro X1202_MBEER0$V_WCDE0 = 52,19,1,0 %; !  WB0 Corrected data Error
macro X1202_MBEER0$V_WFDQ1 = 52,20,1,0 %; !  WB1 Failing Dal Qualifier
macro X1202_MBEER0$V_WSEO1 = 52,21,1,0 %; !  WB1 Second Error Occured
macro X1202_MBEER0$V_WCNAK1 = 52,22,1,0 %; !  WB1 Command NOACK
macro X1202_MBEER0$V_WWDNAK1 = 52,23,1,0 %; !  WB1 Write Data NoACK
macro X1202_MBEER0$V_WTTO1 = 52,24,1,0 %; !  WB1 Transaction Timeout
macro X1202_MBEER0$V_WTBDAT1 = 52,25,1,0 %; !  WB1 Tagged Bad Data
macro X1202_MBEER0$V_WSQE1 = 52,26,1,0 %; !  WB1 Sequence Error
macro X1202_MBEER0$V_WCDE1 = 52,27,1,0 %; !  WB1 Corrected data Error
macro X1202_MBEER0$V_ACPE = 52,29,1,0 %; !  Address/Command Parity Error
macro X1202_MBEER0$V_WDPE = 52,30,1,0 %; !  Write Data Parity Error
macro X1202_MBEER0$V_CFE = 52,31,1,0 %; !  Cache Fill Error
macro X1202$L_WFADR0 = 64,0,32,0 %;     !  Failed WB Address register 0
macro X1202_WFADR0$V_ADDR = 64,0,30,0 %;
literal X1202_WFADR0$S_ADDR = 30;       !  Failing Write Back Address
macro X1202_WFADR0$V_ADDR_EXT = 64,30,2,0 %;
literal X1202_WFADR0$S_ADDR_EXT = 2;    !  Failing Write Back Addr. Ext.
macro X1202$L_WFADR1 = 68,0,32,0 %;     !  Failed WB Address register 1
macro X1202_WFADR1$V_ADDR = 68,0,30,0 %;
literal X1202_WFADR1$S_ADDR = 30;       !  Failing Write Back Address
macro X1202_WFADR1$V_ADDR_EXT = 68,30,2,0 %;
literal X1202_WFADR1$S_ADDR_EXT = 2;    !  Failing Write Back Addr. Ext.
! *****************************************************************************/
!  Page 1                                                                     */
! *****************************************************************************/
macro X1202$L_SYSTYPE = 516,0,32,0 %;   !  System Type Register
! *****************************************************************************/
!  Page 2                                                                     */
! *****************************************************************************/
macro X1202$L_SSCBAR = 1024,0,32,0 %;   !  MSSC Base Address Register
macro X1202$L_SSCCNR = 1040,0,32,0 %;   !  MSSC Configuration Register
macro X1202_SSCCNR$V_CREG_ADS_ENA = 1040,0,3,0 %;
literal X1202_SSCCNR$S_CREG_ADS_ENA = 3; !  Enable writes to CREG0/CREG1
macro X1202_SSCCNR$V_EEPROM_ADS_ENA = 1040,4,3,0 %;
literal X1202_SSCCNR$S_EEPROM_ADS_ENA = 3; !  EEPROM address enable
macro X1202_SSCCNR$V_TERM_BAUD_SEL = 1040,12,3,0 %;
literal X1202_SSCCNR$S_TERM_BAUD_SEL = 3; !  Console baud rate
macro X1202_SSCCNR$V_CTRL_P_ENA = 1040,15,1,0 %; !  0=BREAK, 1=^P console halt
macro X1202_SSCCNR$V_HALT_PROT = 1040,16,3,0 %;
literal X1202_SSCCNR$S_HALT_PROT = 3;   !  Size of halt prot ROM/EEPROM 
macro X1202_SSCCNR$V_ROM_SIZE = 1040,20,3,0 %;
literal X1202_SSCCNR$S_ROM_SIZE = 3;    !  Size of ROM/EEPROM 
macro X1202_SSCCNR$V_ROM_SPEED = 1040,23,1,0 %; !  0=250ns.,1=150ns.
macro X1202_SSCCNR$V_IPL_SEL = 1040,24,2,0 %;
literal X1202_SSCCNR$S_IPL_SEL = 2;     !  MSSC IPL (14,15,16,17 HEX)
macro X1202_SSCCNR$V_IV_DISABLE = 1040,27,1,0 %; !  Disable return of int on RER
macro X1202_SSCCNR$V_BLO = 1040,31,1,0 %; !  1=BBU voltage below threshold 
macro X1202$L_SSCBTR = 1056,0,32,0 %;   !  XMP Control/Status register
macro X1202_SSCBTR$V_TMO_INTERVAL = 1056,0,24,0 %;
literal X1202_SSCBTR$S_TMO_INTERVAL = 24; !  Bus timeout interval
macro X1202_SSCBTR$V_RWT = 1056,30,1,0 %; !  Read write timeout
macro X1202_SSCBTR$V_BTO = 1056,31,1,0 %; !  Bus timeout
macro X1202$L_SSCOPRT = 1072,0,32,0 %;  !  MSSC Output Port Register
macro X1202_SSCOPRT$V_CREG0_SEL = 1072,0,1,0 %; !  20000000=CREG0              
macro X1202_SSCOPRT$V_CREG1_SEL = 1072,1,1,0 %; !  20000000=CREG1
macro X1202_SSCOPRT$V_CREG_DATA = 1072,2,8,0 %;
literal X1202_SSCOPRT$S_CREG_DATA = 8;  !  Data for CREG0/CREG1
macro X1202$L_SSCIPRT = 1088,0,32,0 %;  !  MSSC Input Port Register
macro X1202_SSCIPRT$V_NODE_ID = 1088,0,4,0 %;
literal X1202_SSCIPRT$S_NODE_ID = 4;    !  XMI node ID
macro X1202_SSCIPRT$V_FP_BOOT_DISABLE = 1088,4,1,0 %; !  Front panel boot disable sw
macro X1202_SSCIPRT$V_FP_EEPROM_ENA = 1088,5,1,0 %; !  Front panel EEPROM update sw
macro X1202_SSCIPRT$V_XACLO = 1088,6,1,0 %; !  XMI AC LO
macro X1202_SSCIPRT$V_STL_DISABLE = 1088,7,1,0 %; !  Self-test loop disable   
macro X1202_SSCIPRT$V_SCAN_TEST_DIS = 1088,8,1,0 %; !  Scan test disable
macro X1202_SSCIPRT$V_CONSOLE_ENABLE = 1088,31,1,0 %; !  Front-panel console enable
macro X1202$L_CRBADR = 1328,0,32,0 %;   !  CREG base address register
macro X1202$L_CRADMR = 1332,0,32,0 %;   !  CREG address decode mask reg
macro X1202$L_EEBADR = 1344,0,32,0 %;   !  CREG base address register
macro X1202$L_EEADMR = 1348,0,32,0 %;   !  CREG address decode mask reg
macro X1202$L_TCR0 = 1376,0,32,0 %;
macro X1202_TCR0$V_RUN = 1376,0,1,0 %;  !  Enables timer
macro X1202_TCR0$V_STP = 1376,2,1,0 %;  !  Stop on overflow
macro X1202_TCR0$V_XFR = 1376,4,1,0 %;  !  1=copy TNIRn to TIRn
macro X1202_TCR0$V_SGL = 1376,5,1,0 %;  !  Increment counter by one
macro X1202_TCR0$V_IE = 1376,6,1,0 %;   !  Interrupt Enable
macro X1202_TCR0$V_INT = 1376,7,1,0 %;  !  Set on timer overflow
macro X1202_TCR0$V_ERR = 1376,31,1,0 %; !  Indicates missed overflow
macro X1202$L_TIR0 = 1380,0,32,0 %;     !  Timer Interval Register 0
macro X1202$L_TNIR0 = 1384,0,32,0 %;    !  Timer Next Interval Reg. 0
macro X1202$L_TIVR0 = 1388,0,32,0 %;
macro X1202_TIVR0$V_VECTOR = 1388,2,8,0 %;
literal X1202_TIVR0$S_VECTOR = 8;       !  Longword aligned SCB vector
macro X1202$L_TCR1 = 1392,0,32,0 %;
macro X1202_TCR1$V_RUN = 1392,0,1,0 %;  !  Enables timer           
macro X1202_TCR1$V_STP = 1392,2,1,0 %;  !  Stop on overflow
macro X1202_TCR1$V_XFR = 1392,4,1,0 %;  !  1=copy TNIRn to TIRn
macro X1202_TCR1$V_SGL = 1392,5,1,0 %;  !  Increment counter by one
macro X1202_TCR1$V_IE = 1392,6,1,0 %;   !  Interrupt Enable
macro X1202_TCR1$V_INT = 1392,7,1,0 %;  !  Set on timer overflow
macro X1202_TCR1$V_ERR = 1392,31,1,0 %; !  Indicates missed overflow
macro X1202$L_TIR1 = 1396,0,32,0 %;     !  Timer Interval Register 1
macro X1202$L_TNIR1 = 1400,0,32,0 %;    !  Timer Next Interval Reg. 1
macro X1202$L_TIVR1 = 1404,0,32,0 %;
macro X1202_TIVR1$V_VECTOR = 1404,2,8,0 %;
literal X1202_TIVR1$S_VECTOR = 8;       !  Longword aligned SCB vector
macro X1202$L_SSCICR = 1528,0,32,0 %;   !  Diagnostic interval timer
! *****************************************************************************/
!  Page 3-131                                                                 */
! *****************************************************************************/
!  Interprocessor interrupt area - 128 Pages
macro X1202$L_IPIVINTR = 1536,0,32,0 %;
! *****************************************************************************/
!  Page 132                                                                     */
! *****************************************************************************/
macro X1202$L_DCSR = 67072,0,32,0 %;    !  XMP DAL Diagnostic Register
macro X1202_DCSR$V_MDAREV = 67072,0,4,0 %;
literal X1202_DCSR$S_MDAREV = 4;        !  MDA revision
macro X1202_DCSR$V_EFECC = 67072,4,1,0 %; !  Enable Force ECC
macro X1202_DCSR$V_EFDP = 67072,5,1,0 %; !  Enable Force DP
macro X1202_DCSR$V_RUP = 67072,6,1,0 %; !  Read Upper Longword
macro X1202_DCSR$V_WBECCD = 67072,7,1,0 %; !  WB ECC Check Disable
macro X1202_DCSR$V_FECC = 67072,8,6,0 %;
literal X1202_DCSR$S_FECC = 6;          !  Diagnostic ECC
macro X1202_DCSR$V_FDP = 67072,14,1,0 %; !  Diagnostic Parity
macro X1202_DCSR$V_WDPCD = 67072,15,1,0 %; !  WB Parity Check Disable
macro X1202_DCSR$V_EFXMIP = 67072,16,1,0 %; !  Enable force MDA XMI Parity
macro X1202_DCSR$V_FXMIP = 67072,17,2,0 %;
literal X1202_DCSR$S_FXMIP = 2;         !  Diagnostic MDA XMI parity
macro X1202$L_FDAL0 = 67104,0,32,0 %;   !  Failing DBUS<31:0>
macro X1202$L_FDAL1 = 67112,0,32,0 %;   !  Failing DBUS<63:32>
macro X1202$L_FDAL2 = 67120,0,32,0 %;   !  Failing ECC for DBUS<63:0>
macro X1202$L_FDAL3 = 67128,0,32,0 %;   !  XMP DAL Diagnostic Register
macro X1202_FDAL3$V_ECC = 67128,0,16,0 %;
literal X1202_FDAL3$S_ECC = 16;         !  Remaining ECC for DBUS<63:0>
macro X1202_FDAL3$V_DP = 67128,16,8,0 %;
literal X1202_FDAL3$S_DP = 8;           !  Parity bits for DBUS<63:0>
! *****************************************************************************/
!  Page 133-196                                                                     */
! *****************************************************************************/
!  Console EEPROM area - 64 Pages (32Kb)
macro X1202$AB_EEPROM = 67584,0,8,0 %;  !  First page of EEPROM
 
!*** MODULE $X1302DEF ***
! +
!   This file contains offset definitions for registers accessible through XMI 
!   private space on the Calypso/NVAX processor.  Note that in making these 
!   registers available in virtual space, we have only mapped real registers.  
!   Therefore these virtual offsets are different than the hardware physical 
!   offsets.  Addresses are accessed as offsets from EXE$GL_CPUNODSP.
! -
literal X1302_NCSR$M_SECCON = 1;
literal X1302_NCSR$M_NWQFL = 2;
literal X1302_NCSR$M_WBQFL = 4;
literal X1302_NCSR$M_FRCFL = 8;
literal X1302_NCSR$M_EFXMIP = 16;
literal X1302_NCSR$M_EFXMIDP = 32;
literal X1302_NCSR$M_WTR = 64;
literal X1302_NCSR$M_RBAT = 128;
literal X1302_NCSR$M_SSCIR = 256;
literal X1302_NCSR$M_SSCIW = 512;
literal X1302_NCSR$M_CTP = 2048;
literal X1302_NCSR$M_CNT = 4096;
literal X1302_NCSR$M_TM = 8192;
literal X1302_NCSR$M_EFNDALP = 32768;
literal X1302_NCSR$M_NDALFP = 458752;
literal X1302_NCSR$M_NWSE = 134217728;
literal X1302_NCSR$M_NRTAE = 536870912;
literal X1302_NCSR$M_NDIPE = 1073741824;
literal X1302_NCSR$M_NDPE = -2147483648;
literal X1302_XFADR0$M_INT_SOURCE = 65535;
literal X1302_XFADR0$M_IPL = 983040;
literal X1302_XFADR0$M_INT_DEST = 65535;
literal X1302_XFADR0$M_IP_IVINTR = 65536;
literal X1302_XFADR0$M_WE_IVINTR = 131072;
literal X1302_XFADR0$M_FADR = 1073741823;
literal X1302_XFADR0$M_FLN = -1073741824;
literal X1302_NSCSR0$M_NREV = 15;
literal X1302_NSCSR0$M_WS = 16;
literal X1302_NSCSR0$M_BP = 32;
literal X1302_NSCSR0$M_BPD = 64;
literal X1302_NSCSR0$M_RQOVFL = 128;
literal X1302_XCR0$M_LOCMOD = 3;
literal X1302_XCR0$M_XBADD = 4;
literal X1302_XCR0$M_TRIGC = 24;
literal X1302_XCR0$M_CRDID = 32;
literal X1302_XCR0$M_CCID = 64;
literal X1302_XCR0$M_LDTE = 4096;
literal X1302_XCR0$M_TOS = 196608;
literal X1302_XCR0$M_ESI = 262144;
literal X1302_XCR0$M_XMIFP = 3670016;
literal X1302_XBEER0$M_SEO = 1;
literal X1302_XBEER0$M_OLR = 2;
literal X1302_XBEER0$M_URR = 4;
literal X1302_XBEER0$M_WSEO0 = 8192;
literal X1302_XBEER0$M_WCNAK0 = 16384;
literal X1302_XBEER0$M_WWDNAK0 = 32768;
literal X1302_XBEER0$M_WTTO0 = 65536;
literal X1302_XBEER0$M_WSEO1 = 2097152;
literal X1302_XBEER0$M_WCNAK1 = 4194304;
literal X1302_XBEER0$M_WWDNAK1 = 8388608;
literal X1302_XBEER0$M_WTTO1 = 16777216;
literal X1302_WFADR0$M_ADDR = 536870911;
literal X1302_WFADR0$M_ADDR_EXT = -536870912;
literal X1302_WFADR1$M_ADDR = 536870911;
literal X1302_WFADR1$M_ADDR_EXT = -536870912;
literal X1302_IPORT$M_NODE_ID = 15;
literal X1302_IPORT$M_FP_BOOT_DISABLE = 16;
literal X1302_IPORT$M_FP_EEPROM_ENA = 32;
literal X1302_IPORT$M_XACLO = 64;
literal X1302_IPORT$M_STL_DISABLE = 128;
literal X1302_OPORT0$M_TERM_SEL = 3;
literal X1302_OPORT0$M_TERM_ENA = 4;
literal X1302_OPORT0$M_LED_ON = 8;
literal X1302_OPORT0$M_TEST_STROBE = 32;
literal X1302_OPORT0$M_ERR_STROBE = 64;
literal X1302_OPORT0$C_AUX_CONSOLE = 0; !  Auxilary console
literal X1302_OPORT0$C_SYSTEM_CONSOLE = 1; !  System console
literal X1302_OPORT0$C_AUX_LOOPBACK = 2; !  Auxilary console loopback
literal X1302_OPORT0$C_SYSTEM_LOOPBACK = 3; !  System console loopback
literal X1302_OPORT1$M_ST_LED1 = 1;
literal X1302_OPORT1$M_ST_LED2 = 2;
literal X1302_OPORT1$M_ST_LED3 = 4;
literal X1302_OPORT1$M_ST_LED4 = 8;
literal X1302_OPORT1$M_ST_LED5 = 16;
literal X1302_OPORT1$M_ST_LED6 = 32;
literal X1302_OPORT1$M_ST_LED7 = 64;
literal X1302_OPORT1$M_STV_LED = 128;
literal X1302$S_X1302DEF = 109568;
! *****************************************************************************/
!  Page 0                                                                     */
! *****************************************************************************/
!  Page 0 holds both NodeSpace register offsets and the first page
!  of Node Private Space registers.  This allows us to use the    
!  same structure for two different purposes.
macro X1302$L_XDEV = 0,0,32,0 %;        !  Standard XMI XDEV register
macro X1302$L_NCSR = 0,0,32,0 %;        !  XNP DAL Diagnostic Register
macro X1302_NCSR$V_SECCON = 0,0,1,0 %;  !  Secure Console
macro X1302_NCSR$V_NWQFL = 0,1,1,0 %;   !  NWQ Full
macro X1302_NCSR$V_WBQFL = 0,2,1,0 %;   !  WBQ Full
macro X1302_NCSR$V_FRCFL = 0,3,1,0 %;   !  Force Full
macro X1302_NCSR$V_EFXMIP = 0,4,1,0 %;  !  Enable Forced XMI2 non-WDAT Parity
macro X1302_NCSR$V_EFXMIDP = 0,5,1,0 %; !  Enable Forced XMI2 WDAT Parity
macro X1302_NCSR$V_WTR = 0,6,1,0 %;     !  Write to Rom
macro X1302_NCSR$V_RBAT = 0,7,1,0 %;    !  ROMBus Access Time
macro X1302_NCSR$V_SSCIR = 0,8,1,0 %;   !  SSC Illegal Read
macro X1302_NCSR$V_SSCIW = 0,9,1,0 %;   !  SSC Illegal Write
macro X1302_NCSR$V_CTP = 0,11,1,0 %;    !  Set Cntl-P Enable
macro X1302_NCSR$V_CNT = 0,12,1,0 %;    !  Count TODR
macro X1302_NCSR$V_TM = 0,13,1,0 %;     !  TODR Test Mode
macro X1302_NCSR$V_EFNDALP = 0,15,1,0 %; !  Enable Forced NDAL Parity
macro X1302_NCSR$V_NDALFP = 0,16,3,0 %;
literal X1302_NCSR$S_NDALFP = 3;        !  NDAL Force Parity<2:0>
macro X1302_NCSR$V_NWSE = 0,27,1,0 %;   !  NDAL Write Sequence Error
macro X1302_NCSR$V_NRTAE = 0,29,1,0 %;  !  NDAL Read Transmit ACK Error
macro X1302_NCSR$V_NDIPE = 0,30,1,0 %;  !  NDAL Inconsistant PE
macro X1302_NCSR$V_NDPE = 0,31,1,0 %;   !  NDAL Parity Error
macro X1302$L_XBE0 = 4,0,32,0 %;        !  Standard XMI XBE0 register
macro X1302$L_XFADR0 = 8,0,32,0 %;      !  XMI Failing Address register
macro X1302_XFADR0$V_INT_SOURCE = 8,0,16,0 %;
literal X1302_XFADR0$S_INT_SOURCE = 16; !  Interrupt Source
macro X1302_XFADR0$V_IPL = 8,16,4,0 %;
literal X1302_XFADR0$S_IPL = 4;         !  Failing length
macro X1302_XFADR0$V_INT_DEST = 8,0,16,0 %;
literal X1302_XFADR0$S_INT_DEST = 16;   !  Interrupt Destination
macro X1302_XFADR0$V_IP_IVINTR = 8,16,1,0 %; !  Interprocessor interrupt
macro X1302_XFADR0$V_WE_IVINTR = 8,17,1,0 %; !  Write Enable interrupt
macro X1302_XFADR0$V_FADR = 8,0,30,0 %;
literal X1302_XFADR0$S_FADR = 30;       !  Failing Address
macro X1302_XFADR0$V_FLN = 8,30,2,0 %;
literal X1302_XFADR0$S_FLN = 2;         !  Failing length
macro X1302$L_XGPR = 12,0,32,0 %;       !  Standard XMI-2 XGPR register
macro X1302$L_NSCSR0 = 28,0,32,0 %;     !  XMP Control/Status register0
macro X1302_NSCSR0$V_NREV = 28,0,4,0 %;
literal X1302_NSCSR0$S_NREV = 4;        !  MCA revision
macro X1302_NSCSR0$V_WS = 28,4,1,0 %;   !  Warm start
macro X1302_NSCSR0$V_BP = 28,5,1,0 %;   !  Boot processor
macro X1302_NSCSR0$V_BPD = 28,6,1,0 %;  !  Boot processor disabled
macro X1302_NSCSR0$V_RQOVFL = 28,7,1,0 %; !  Responder queue overflow
macro X1302$L_XCR0 = 36,0,32,0 %;       !  XMP Control register0
macro X1302_XCR0$V_LOCMOD = 36,0,2,0 %;
literal X1302_XCR0$S_LOCMOD = 2;        !  Lockout Mode
macro X1302_XCR0$V_XBADD = 36,2,1,0 %;  !  XMI Bad Drive
macro X1302_XCR0$V_TRIGC = 36,3,2,0 %;
literal X1302_XCR0$S_TRIGC = 2;         !  Selects XMI Trigger Condition
macro X1302_XCR0$V_CRDID = 36,5,1,0 %;  !  Corrected Read Data Int. Dis.
macro X1302_XCR0$V_CCID = 36,6,1,0 %;   !  Corrected Conf. Int. Dis.
macro X1302_XCR0$V_LDTE = 36,12,1,0 %;  !  Lockout Debug Timeout Enable
macro X1302_XCR0$V_TOS = 36,16,2,0 %;
literal X1302_XCR0$S_TOS = 2;           !  Timeout Select
macro X1302_XCR0$V_ESI = 36,18,1,0 %;   !  Enable Self Invalidates
macro X1302_XCR0$V_XMIFP = 36,19,3,0 %;
literal X1302_XCR0$S_XMIFP = 3;         !  Force XMI Parity
macro X1302$L_XFAER0 = 44,0,32,0 %;     !  Standard XMI-2 XFAER0 reg.
macro X1302$L_XBEER0 = 52,0,32,0 %;     !  XMP Error Extension register
macro X1302_XBEER0$V_SEO = 52,0,1,0 %;  !  Second Error Occured
macro X1302_XBEER0$V_OLR = 52,1,1,0 %;  !  Only LOC Response
macro X1302_XBEER0$V_URR = 52,2,1,0 %;  !  Unexpected Read Response
macro X1302_XBEER0$V_WSEO0 = 52,13,1,0 %; !  Second writeback0 hard error
macro X1302_XBEER0$V_WCNAK0 = 52,14,1,0 %; !  Writeback0 command noack
macro X1302_XBEER0$V_WWDNAK0 = 52,15,1,0 %; !  Writeback0 write data noack
macro X1302_XBEER0$V_WTTO0 = 52,16,1,0 %; !  Writeback0 transaction timeout
macro X1302_XBEER0$V_WSEO1 = 52,21,1,0 %; !  Second writeback1 hard error
macro X1302_XBEER0$V_WCNAK1 = 52,22,1,0 %; !  Writeback1 command noack
macro X1302_XBEER0$V_WWDNAK1 = 52,23,1,0 %; !  Writeback1 write data noack
macro X1302_XBEER0$V_WTTO1 = 52,24,1,0 %; !  Writeback1 transaction timeout
macro X1302$L_WFADR0 = 64,0,32,0 %;     !  Failed WB Address register 0
macro X1302_WFADR0$V_ADDR = 64,0,29,0 %;
literal X1302_WFADR0$S_ADDR = 29;       !  Failing Write Back Address
macro X1302_WFADR0$V_ADDR_EXT = 64,29,3,0 %;
literal X1302_WFADR0$S_ADDR_EXT = 3;    !  Failing Write Back Addr. Ext.
macro X1302$L_WFADR1 = 68,0,32,0 %;     !  Failed WB Address register 1
macro X1302_WFADR1$V_ADDR = 68,0,29,0 %;
literal X1302_WFADR1$S_ADDR = 29;       !  Failing Write Back Address
macro X1302_WFADR1$V_ADDR_EXT = 68,29,3,0 %;
literal X1302_WFADR1$S_ADDR_EXT = 3;    !  Failing Write Back Addr. Ext.
! *****************************************************************************/
!  Page 1                                                                     */
! *****************************************************************************/
macro X1302$L_SYSTYPE = 516,0,32,0 %;   !  System Type Register
! *****************************************************************************/
!  Page 2                                                                     */
! *****************************************************************************/
macro X1302$L_WATCH_TOD_BASE = 1024,0,32,0 %; !  WATCH chip 'base'
! *****************************************************************************/
!  Page 3-130                                                                 */
! *****************************************************************************/
!  Interprocessor interrupt area - 128 Pages
macro X1302$L_IPIVINTR = 1536,0,32,0 %;
! *****************************************************************************/
!  Page 131-194                                                               */
! *****************************************************************************/
!  EEPROM area - 64 pages (32 Kb)
macro X1302$L_EEPROM = 67072,0,32,0 %;
! *****************************************************************************/
!  Page 195-210                                                               */
! *****************************************************************************/
!  NEXMI RAM area - 16 pages (8 Kb)
macro X1302$L_NEXMI_RAM = 99840,0,32,0 %;
! *****************************************************************************/
!  Page 211                                                                    *
! *****************************************************************************/
macro X1302$L_IPORT = 108032,0,32,0 %;  !  NEXMI Input Port Register
macro X1302_IPORT$V_NODE_ID = 108032,0,4,0 %;
literal X1302_IPORT$S_NODE_ID = 4;      !  XMI node ID
macro X1302_IPORT$V_FP_BOOT_DISABLE = 108032,4,1,0 %; !  Front panel boot disable sw
macro X1302_IPORT$V_FP_EEPROM_ENA = 108032,5,1,0 %; !  Front panel EEPROM update sw
macro X1302_IPORT$V_XACLO = 108032,6,1,0 %; !  XMI AC LO
macro X1302_IPORT$V_STL_DISABLE = 108032,7,1,0 %; !  Self-test loop disable   
! *****************************************************************************/
!  Page 212                                                                   */
! *****************************************************************************/
macro X1302$L_OPORT0 = 108544,0,32,0 %; !  NEXMI Output Port1 Register
macro X1302_OPORT0$V_TERM_SEL = 108544,0,2,0 %;
literal X1302_OPORT0$S_TERM_SEL = 2;    !  Select console terminal mode 
macro X1302_OPORT0$V_TERM_ENA = 108544,2,1,0 %; !  Enables XNP to drive console line 
macro X1302_OPORT0$V_LED_ON = 108544,3,1,0 %; !  Indicates selftest successful 
macro X1302_OPORT0$V_TEST_STROBE = 108544,5,1,0 %; !  Diagnostic test strobe 
macro X1302_OPORT0$V_ERR_STROBE = 108544,6,1,0 %; !  Diagnostic error strobe 
!  Console terminal modes
! *****************************************************************************/
!  Page 213                                                                   */
! *****************************************************************************/
macro X1302$L_OPORT1 = 109056,0,32,0 %; !  NEXMI Output Port Register
macro X1302_OPORT1$V_ST_LED1 = 109056,0,1,0 %; !  Selftest LED 1 
macro X1302_OPORT1$V_ST_LED2 = 109056,1,1,0 %; !  Selftest LED 2 
macro X1302_OPORT1$V_ST_LED3 = 109056,2,1,0 %; !  Selftest LED 3 
macro X1302_OPORT1$V_ST_LED4 = 109056,3,1,0 %; !  Selftest LED 4 
macro X1302_OPORT1$V_ST_LED5 = 109056,4,1,0 %; !  Selftest LED 5 
macro X1302_OPORT1$V_ST_LED6 = 109056,5,1,0 %; !  Selftest LED 6 
macro X1302_OPORT1$V_ST_LED7 = 109056,6,1,0 %; !  Selftest LED 7 
macro X1302_OPORT1$V_STV_LED = 109056,7,1,0 %; !  Self test valid LED 
! 
!  Define offsets from WATCH_TOD_BASE for watch registers.
!  
literal WATCH_CSRA$M_BUSY = 128;
literal WATCH_CSRA$C_CSRA_SETUP = 32;
literal WATCH_CSRB$M_OFF = 128;
literal WATCH_CSRB$C_CSRB_SETUP = 6;
literal WATCH_CSRD$M_VALID = 128;
literal WATCH$S_WATCH_OFFSETS = 14;
macro WATCH$B_SECONDS = 0,0,8,0 %;      !  Seconds register 
macro WATCH$B_MINUTES = 2,0,8,0 %;      !  Minutes register 
macro WATCH$B_HOURS = 4,0,8,0 %;        !  Hour register 
macro WATCH$B_DAY = 7,0,8,0 %;          !  Day register 
macro WATCH$B_MONTH = 8,0,8,0 %;        !  Month register 
macro WATCH$B_YEAR = 9,0,8,0 %;         !  Year register 
macro WATCH$B_CSRA = 10,0,8,0 %;        !  CSRA (busy bit) 
macro WATCH_CSRA$V_BUSY = 10,7,1,0 %;   !  CSRA<7> = BUSY bit 
macro WATCH$B_CSRB = 11,0,8,0 %;        !  CSRB (off bit) 
macro WATCH_CSRB$V_OFF = 11,7,1,0 %;    !  CSRB<7> = OFF bit 
macro WATCH$B_FILL_4 = 12,0,8,0 %;
macro WATCH$B_CSRD = 13,0,8,0 %;        !  CSRD (valid bit) 
macro WATCH_CSRD$V_VALID = 13,7,1,0 %;  !  CSRD<7> = VALID bit 
 
!*** MODULE $X1303DEF ***
literal X1303$L_MEMCON = 0;
literal X1303$L_MEMSIG = 32;
literal X1303$L_MEAR = 64;
literal X1303$L_MESR = 68;
literal X1303$L_MMCDSR = 72;
literal X1303$L_MOAMR = 76;
literal X1303$L_CESR = 512;
literal X1303$L_CMCDSR = 516;
literal X1303$L_CSEAR1 = 520;
literal X1303$L_CSEAR2 = 524;
literal X1303$L_CIOEAR1 = 528;
literal X1303$L_CIOEAR2 = 532;
literal X1303$L_CNEAR = 536;
literal X1303$L_SCDADR = 1024;
literal X1303$L_SCDDIR = 1028;
literal X1303$B_INTMSK = 1032;
literal X1303$B_INTREQ = 1036;
literal X1303$B_INTCLR = 1036;
literal X1303$B_IORESET = 1040;
literal X1303$L_SSCBR = 1536;
literal X1303$L_SSCCR = 1552;
literal X1303$L_CBTCR = 1568;
literal X1303$L_DLEDR = 1584;
literal X1303$L_TCR0 = 1792;
literal X1303$L_TIR0 = 1796;
literal X1303$L_TNIR0 = 1800;
literal X1303$L_TIVR0 = 1804;
literal X1303$L_TCR1 = 1808;
literal X1303$L_TIR1 = 1812;
literal X1303$L_TNIR1 = 1816;
literal X1303$L_TIVR1 = 1820;
literal X1303$W_SER_CSR = 2048;
literal X1303$W_SER_RBUF = 2052;
literal X1303$W_SER_LPR = 2052;
literal X1303$W_SER_TCR = 2056;
literal X1303$W_SER_MSR = 2060;
literal X1303$W_SER_TDR = 2060;
literal X1303$B_SCSICSR = 2688;
literal X1303$B_NISAROM = 3072;
literal X1303$L_BDR = 3584;
literal X1303$L_ASYNCSR = 4096;
literal X1303$B_ASYNCROM = 4608;
literal X1303$B_NVR = 5120;
literal X1303$L_CONSPAGE = 5136;
literal X1303$B_SCSI = 6139;
literal X1303$W_QDSS = 6400;
literal X1303$W_IPCR0 = 6464;
literal X1303$W_IPCR1 = 6466;
literal X1303$W_IPCR2 = 6468;
literal X1303$W_IPCR3 = 6470;
literal X1303$L_SCR = 6656;
literal X1303$L_DSER = 6660;
literal X1303$L_QBEAR = 6664;
literal X1303$L_DEAR = 6668;
literal X1303$L_QBMBR = 6672;
literal X1303$W_CFG = 7168;
literal X1303$W_DIAGDISP = 7172;
literal X1303$L_SGEC = 7680;
literal X1303$L_SHAC1 = 8192;
literal X1303$B_SYNCROMS = 8704;
literal X1303$L_SYNCRST = 9728;
literal X1303$L_SCSIMAPS = 10240;
literal X1303$L_SCSIMAPE = 43007;
literal X1303$L_MODR = 43008;
literal X1303$L_QMAP = 75776;
literal X1303$B_ROM = 108544;
literal X1303$L_SIDEX = 108548;
literal X1303$L_GETCHAR = 108552;
literal X1303$L_OUTMSG = 108556;
literal X1303$L_SSHMA = 108584;
literal X1303$S_X1303DEF = 141312;
literal X1303$_SHAC_PMCSR = 92;
literal X1303$_SHAC_M_MIN = 1;
literal X1303$_SGEC_MODE = 24;
literal X1303$_SGEC_M_RESET = -2147483648;
literal X1303$M_IPCR_DBI_RQ = 1;
literal X1303$M_IPCR_LM_EAE = 32;
literal X1303$M_IPCR_DBI_IE = 64;
literal X1303$M_IPCR_AUX_HLT = 256;
literal X1303$M_IPCR_QMCIA = 16384;
literal X1303$M_IPCR_DMA_QME = 32768;
literal X1303$S_X1303_IPCR = 2;
macro X1303$V_IPCR_DBI_RQ = 0,0,1,0 %;
macro X1303$V_IPCR_LM_EAE = 0,5,1,0 %;
macro X1303$V_IPCR_DBI_IE = 0,6,1,0 %;
macro X1303$V_IPCR_AUX_HLT = 0,8,1,0 %;
macro X1303$V_IPCR_QMCIA = 0,14,1,0 %;
macro X1303$V_IPCR_DMA_QME = 0,15,1,0 %;
literal X1303$S_X1303_SIDEX = 4;
macro X1303$B_SIDEX_NUM_USER = 0,0,8,0 %;
macro X1303$B_SIDEX_SUB_TYPE = 1,0,8,0 %;
macro X1303$B_SIDEX_ROM_VERS = 2,0,8,0 %;
macro X1303$B_SIDEX_SYS_CODE = 3,0,8,0 %;
literal X1303$M_SCR_DOS = 14;
literal X1303$M_SCR_DCOK_HLT = 128;
literal X1303$M_SCR_AUX = 1024;
literal X1303$M_SCR_PPD = 4096;
literal X1303$M_SCR_BHE = 16384;
literal X1303$M_SCR_POK = 32768;
literal X1303$S_X1303_SCR = 4;
macro X1303$V_SCR_DOS = 0,1,3,0 %;
literal X1303$S_SCR_DOS = 3;
macro X1303$V_SCR_DCOK_HLT = 0,7,1,0 %;
macro X1303$V_SCR_AUX = 0,10,1,0 %;
macro X1303$V_SCR_PPD = 0,12,1,0 %;
macro X1303$V_SCR_BHE = 0,14,1,0 %;
macro X1303$V_SCR_POK = 0,15,1,0 %;
literal X1303$M_DSER_NXM = 1;
literal X1303$M_DSER_NG = 4;
literal X1303$M_DSER_LE = 8;
literal X1303$M_DSER_MME = 16;
literal X1303$M_DSER_PE = 32;
literal X1303$M_DSER_QNXM = 128;
literal X1303$M_DSER_DCOK = 16384;
literal X1303$M_DSER_BHALT = 32768;
literal X1303$S_X1303_DSER = 4;
macro X1303$V_DSER_NXM = 0,0,1,0 %;
macro X1303$V_DSER_NG = 0,2,1,0 %;
macro X1303$V_DSER_LE = 0,3,1,0 %;
macro X1303$V_DSER_MME = 0,4,1,0 %;
macro X1303$V_DSER_PE = 0,5,1,0 %;
macro X1303$V_DSER_QNXM = 0,7,1,0 %;
macro X1303$V_DSER_DCOK = 0,14,1,0 %;
macro X1303$V_DSER_BHALT = 0,15,1,0 %;
literal X1303$M_QBEAR_ADDR = 8191;
literal X1303$S_X1303_QBEAR = 4;
macro X1303$V_QBEAR_ADDR = 0,0,13,0 %;
literal X1303$S_QBEAR_ADDR = 13;
literal X1303$M_DEAR_ADDR = 8191;
literal X1303$S_X1303_DEAR = 4;
macro X1303$V_DEAR_ADDR = 0,0,13,0 %;
literal X1303$S_DEAR_ADDR = 13;
literal X1303$M_BDR_RSVD0 = 3;
literal X1303$M_BDR_ASYNC = 4;
literal X1303$M_BDR_MDML = 8;
literal X1303$M_BDR_MDMH = 16;
literal X1303$M_BDR_DLOL = 32;
literal X1303$M_BDR_DLOH = 64;
literal X1303$M_BDR_SYNC = 128;
literal X1303$M_BDR_NISA = 65280;
literal X1303$M_BDR_RSVD1 = 65536;
literal X1303$M_BDR_DSSIP = 131072;
literal X1303$M_BDR_RSVD2 = 16515072;
literal X1303$M_BDR_DSSI = 117440512;
literal X1303$M_BDR_RSVD3 = 2013265920;
literal X1303$M_BDR_FE_UPD = -2147483648;
literal X1303$S_X1303_BDR = 4;
macro X1303$V_BDR_RSVD0 = 0,0,2,0 %;
literal X1303$S_BDR_RSVD0 = 2;
macro X1303$V_BDR_ASYNC = 0,2,1,0 %;
macro X1303$V_BDR_MDML = 0,3,1,0 %;
macro X1303$V_BDR_MDMH = 0,4,1,0 %;
macro X1303$V_BDR_DLOL = 0,5,1,0 %;
macro X1303$V_BDR_DLOH = 0,6,1,0 %;
macro X1303$V_BDR_SYNC = 0,7,1,0 %;
macro X1303$V_BDR_NISA = 0,8,8,0 %;
literal X1303$S_BDR_NISA = 8;
macro X1303$V_BDR_RSVD1 = 0,16,1,0 %;
macro X1303$V_BDR_DSSIP = 0,17,1,0 %;
macro X1303$V_BDR_RSVD2 = 0,18,6,0 %;
literal X1303$S_BDR_RSVD2 = 6;
macro X1303$V_BDR_DSSI = 0,24,3,0 %;
literal X1303$S_BDR_DSSI = 3;
macro X1303$V_BDR_RSVD3 = 0,27,4,0 %;
literal X1303$S_BDR_RSVD3 = 4;
macro X1303$V_BDR_FE_UPD = 0,31,1,0 %;
literal X1303$M_CFG_RSVD0 = 1;
literal X1303$M_CFG_CPU = 2;
literal X1303$M_CFG_RSVD1 = 4;
literal X1303$M_CFG_BRK_EN = 8;
literal X1303$M_CFG_RSVD2 = 48;
literal X1303$M_CFG_BNK1P = 64;
literal X1303$M_CFG_BNK1S = 128;
literal X1303$M_CFG_BNK0P = 256;
literal X1303$M_CFG_BNK0S = 512;
literal X1303$M_CFG_BNK1_SER = 1024;
literal X1303$M_CFG_BNK1_PER = 2048;
literal X1303$M_CFG_BNK0_SER = 4096;
literal X1303$M_CFG_BNK0_PER = 8192;
literal X1303$S_X1303_CFG = 2;
macro X1303$V_CFG_RSVD0 = 0,0,1,0 %;
macro X1303$V_CFG_CPU = 0,1,1,0 %;
macro X1303$V_CFG_RSVD1 = 0,2,1,0 %;
macro X1303$V_CFG_BRK_EN = 0,3,1,0 %;
macro X1303$V_CFG_RSVD2 = 0,4,2,0 %;
literal X1303$S_CFG_RSVD2 = 2;
macro X1303$V_CFG_BNK1P = 0,6,1,0 %;
macro X1303$V_CFG_BNK1S = 0,7,1,0 %;
macro X1303$V_CFG_BNK0P = 0,8,1,0 %;
macro X1303$V_CFG_BNK0S = 0,9,1,0 %;
macro X1303$V_CFG_BNK1_SER = 0,10,1,0 %;
macro X1303$V_CFG_BNK1_PER = 0,11,1,0 %;
macro X1303$V_CFG_BNK0_SER = 0,12,1,0 %;
macro X1303$V_CFG_BNK0_PER = 0,13,1,0 %;
literal X1303$M_DLEDR_DSPL = 15;
literal X1303$S_X1303_DLEDR = 4;
macro X1303$V_DLEDR_DSPL = 0,0,4,0 %;
literal X1303$S_DLEDR_DSPL = 4;
literal X1303$M_TCR_RUN = 1;
literal X1303$M_TCR_STP = 4;
literal X1303$M_TCR_XFR = 16;
literal X1303$M_TCR_SGL = 32;
literal X1303$M_TCR_IE = 64;
literal X1303$M_TCR_INT = 128;
literal X1303$M_TCR_ERR = -2147483648;
literal X1303$S_X1303_TCR = 4;
macro X1303$V_TCR_RUN = 0,0,1,0 %;
macro X1303$V_TCR_STP = 0,2,1,0 %;
macro X1303$V_TCR_XFR = 0,4,1,0 %;
macro X1303$V_TCR_SGL = 0,5,1,0 %;
macro X1303$V_TCR_IE = 0,6,1,0 %;
macro X1303$V_TCR_INT = 0,7,1,0 %;
macro X1303$V_TCR_ERR = 0,31,1,0 %;
literal X1303$M_TIVR_VEC = 1020;
literal X1303$S_X1303_TIVR = 4;
macro X1303$V_TIVR_VEC = 0,2,8,0 %;
literal X1303$S_TIVR_VEC = 8;
literal X1303$K_RS_RB_HLT = 0;
literal X1303$K_RS_HLT = 1;
literal X1303$K_RB_HLT = 2;
literal X1303$K_HLT = 3;
literal X1303$M_HALT_ACTION = 3;
literal X1303$M_BIP = 4;
literal X1303$M_RIP = 8;
literal X1303$M_LANGUAGE = 240;
literal X1303$M_INSERT = 256;
literal X1303$M_CRT = 512;
literal X1303$M_MCS = 1024;
literal X1303$M_DIP = 2048;
literal X1303$M_MOP_ENB = 4096;
literal X1303$K_TTY = 0;
literal X1303$K_QVSS = 1;
literal X1303$K_QDSS = 2;
literal X1303$M_VIDEO_DEV = 57344;
literal X1303$S_X1303_NVR = 2;
macro X1303$V_HALT_ACTION = 0,0,2,0 %;
literal X1303$S_HALT_ACTION = 2;
macro X1303$V_BIP = 0,2,1,0 %;
macro X1303$V_RIP = 0,3,1,0 %;
macro X1303$V_LANGUAGE = 0,4,4,0 %;
literal X1303$S_LANGUAGE = 4;
macro X1303$V_INSERT = 0,8,1,0 %;
macro X1303$V_CRT = 0,9,1,0 %;
macro X1303$V_MCS = 0,10,1,0 %;
macro X1303$V_DIP = 0,11,1,0 %;
macro X1303$V_MOP_ENB = 0,12,1,0 %;
macro X1303$V_VIDEO_DEV = 0,13,3,0 %;
literal X1303$S_VIDEO_DEV = 3;
literal X1303$M_MEMCON_MODE64 = 1;
literal X1303$K_MEMCON_1MB = 1;
literal X1303$K_MEMCON_4MB = 2;
literal X1303$M_MEMCON_SIG = 6;
literal X1303$M_MEMCON_BASE = 520093696;
literal X1303$M_MEMCON_VALID = -2147483648;
literal X1303$S_X1303_MEMCON = 4;
macro X1303$V_MEMCON_MODE64 = 0,0,1,0 %;
macro X1303$V_MEMCON_SIG = 0,1,2,0 %;
literal X1303$S_MEMCON_SIG = 2;
macro X1303$V_MEMCON_BASE = 0,24,5,0 %;
literal X1303$S_MEMCON_BASE = 5;
macro X1303$V_MEMCON_VALID = 0,31,1,0 %;
literal X1303$M_MEAR_HWADDR = 268435448;
literal X1303$M_MEAR_ID = 1879048192;
literal X1303$S_X1303_MEAR = 4;
macro X1303$V_MEAR_HWADDR = 0,3,25,0 %;
literal X1303$S_MEAR_HWADDR = 25;
macro X1303$V_MEAR_ID = 0,28,3,0 %;
literal X1303$S_MEAR_ID = 3;
literal X1303$M_MESR_LMSE = 4;
literal X1303$M_MESR_OFE = 8;
literal X1303$M_MESR_OSE = 16;
literal X1303$M_MESR_OSYND = 480;
literal X1303$M_MESR_LMHE = 512;
literal X1303$M_MESR_MSE = 1024;
literal X1303$M_MESR_MHE = 2048;
literal X1303$M_MESR_SYND = 1044480;
literal X1303$M_MESR_NXM = 1048576;
literal X1303$M_MESR_NDPE = 4194304;
literal X1303$M_MESR_NIWC = 8388608;
literal X1303$M_MESR_PTTO = 16777216;
literal X1303$M_MESR_DU = 33554432;
literal X1303$M_MESR_NAE = 67108864;
literal X1303$M_MESR_BNE = 134217728;
literal X1303$M_MESR_RC = 268435456;
literal X1303$M_MESR_LNSE = 536870912;
literal X1303$M_MESR_LNHE = 1073741824;
literal X1303$M_MESR_ERROR = -2147483648;
literal X1303$S_X1303_MESR = 4;
macro X1303$V_MESR_LMSE = 0,2,1,0 %;
macro X1303$V_MESR_OFE = 0,3,1,0 %;
macro X1303$V_MESR_OSE = 0,4,1,0 %;
macro X1303$V_MESR_OSYND = 0,5,4,0 %;
literal X1303$S_MESR_OSYND = 4;
macro X1303$V_MESR_LMHE = 0,9,1,0 %;
macro X1303$V_MESR_MSE = 0,10,1,0 %;
macro X1303$V_MESR_MHE = 0,11,1,0 %;
macro X1303$V_MESR_SYND = 0,12,8,0 %;
literal X1303$S_MESR_SYND = 8;
macro X1303$V_MESR_NXM = 0,20,1,0 %;
macro X1303$V_MESR_NDPE = 0,22,1,0 %;
macro X1303$V_MESR_NIWC = 0,23,1,0 %;
macro X1303$V_MESR_PTTO = 0,24,1,0 %;
macro X1303$V_MESR_DU = 0,25,1,0 %;
macro X1303$V_MESR_NAE = 0,26,1,0 %;
macro X1303$V_MESR_BNE = 0,27,1,0 %;
macro X1303$V_MESR_RC = 0,28,1,0 %;
macro X1303$V_MESR_LNSE = 0,29,1,0 %;
macro X1303$V_MESR_LNHE = 0,30,1,0 %;
macro X1303$V_MESR_ERROR = 0,31,1,0 %;
literal X1303$M_MMCDSR_FRR = 1;
literal X1303$M_MMCDSR_DR = 2;
literal X1303$M_MMCDSR_FWPDI = 4;
literal X1303$M_MMCDSR_FWPAI = 8;
literal X1303$M_MMCDSR_FWPO = 16;
literal X1303$M_MMCDSR_RIS = 32;
literal X1303$M_MMCDSR_DMED = 64;
literal X1303$K_MMCDSR_2600 = 0;
literal X1303$K_MMCDSR_1600 = 1;
literal X1303$K_MMCDSR_800 = 2;
literal X1303$K_MMCDSR_400 = 3;
literal X1303$M_MMCDSR_TOS = 384;
literal X1303$M_MMCDSR_MCB = 130560;
literal X1303$M_MMCDSR_MDCB = 33423360;
literal X1303$M_MMCDSR_IOM = 33554432;
literal X1303$M_MMCDSR_BFM = 67108864;
literal X1303$M_MMCDSR_ESEL = 134217728;
literal X1303$M_MMCDSR_QOIO1 = 268435456;
literal X1303$M_MMCDSR_DCBM = 536870912;
literal X1303$M_MMCDSR_FDM = -2147483648;
literal X1303$S_X1303_MMCDSR = 4;
macro X1303$V_MMCDSR_FRR = 0,0,1,0 %;
macro X1303$V_MMCDSR_DR = 0,1,1,0 %;
macro X1303$V_MMCDSR_FWPDI = 0,2,1,0 %;
macro X1303$V_MMCDSR_FWPAI = 0,3,1,0 %;
macro X1303$V_MMCDSR_FWPO = 0,4,1,0 %;
macro X1303$V_MMCDSR_RIS = 0,5,1,0 %;
macro X1303$V_MMCDSR_DMED = 0,6,1,0 %;
macro X1303$V_MMCDSR_TOS = 0,7,2,0 %;
literal X1303$S_MMCDSR_TOS = 2;
macro X1303$V_MMCDSR_MCB = 0,9,8,0 %;
literal X1303$S_MMCDSR_MCB = 8;
macro X1303$V_MMCDSR_MDCB = 0,17,8,0 %;
literal X1303$S_MMCDSR_MDCB = 8;
macro X1303$V_MMCDSR_IOM = 0,25,1,0 %;
macro X1303$V_MMCDSR_BFM = 0,26,1,0 %;
macro X1303$V_MMCDSR_ESEL = 0,27,1,0 %;
macro X1303$V_MMCDSR_QOIO1 = 0,28,1,0 %;
macro X1303$V_MMCDSR_DCBM = 0,29,1,0 %;
macro X1303$V_MMCDSR_FDM = 0,31,1,0 %;
literal X1303$K_MOAMR_RECON = 0;
literal X1303$K_MOAMR_MEM = 2;
literal X1303$K_MOAMR_FAST_MEM = 3;
literal X1303$K_MOAMR_MEM_FCB = 6;
literal X1303$K_MOAMR_FAST_MEM_FCB = 7;
literal X1303$M_MOAMR_MODE = 7;
literal X1303$M_MOAMR_MASK = 56;
literal X1303$M_MOAMR_SEGMENT = 32704;
literal X1303$S_X1303_MOAMR = 4;
macro X1303$V_MOAMR_MODE = 0,0,3,0 %;
literal X1303$S_MOAMR_MODE = 3;
macro X1303$V_MOAMR_MASK = 0,3,3,0 %;
literal X1303$S_MOAMR_MASK = 3;
macro X1303$V_MOAMR_SEGMENT = 0,6,9,0 %;
literal X1303$S_MOAMR_SEGMENT = 9;
literal X1303$M_CESR_NXIOE1 = 1;
literal X1303$M_CESR_IOE1 = 2;
literal X1303$M_CESR_IORPE1 = 4;
literal X1303$M_CESR_BE1 = 8;
literal X1303$M_CESR_DPE1 = 16;
literal X1303$M_CESR_IOLE1 = 32;
literal X1303$M_CESR_DLE1 = 64;
literal X1303$M_CESR_MTTO1 = 128;
literal X1303$M_CESR_NXIOE2 = 256;
literal X1303$M_CESR_IOE2 = 512;
literal X1303$M_CESR_IORPE2 = 1024;
literal X1303$M_CESR_BE2 = 2048;
literal X1303$M_CESR_DPE2 = 4096;
literal X1303$M_CESR_IOLE2 = 8192;
literal X1303$M_CESR_DLE2 = 16384;
literal X1303$M_CESR_MTTO2 = 32768;
literal X1303$M_CESR_PREL1 = 65536;
literal X1303$M_CESR_PREL2 = 131072;
literal X1303$M_CESR_PREL = 262144;
literal X1303$M_CESR_PE = 1048576;
literal X1303$M_CESR_NAE = 2097152;
literal X1303$M_CESR_TOE1 = 4194304;
literal X1303$M_CESR_TOE2 = 8388608;
literal X1303$M_CESR_IL = 16777216;
literal X1303$M_CESR_RC = 33554432;
literal X1303$M_CESR_LE = 67108864;
literal X1303$M_CESR_RDRNAE = 134217728;
literal X1303$M_CESR_ERROR = -2147483648;
literal X1303$S_X1303_CESR = 4;
macro X1303$V_CESR_NXIOE1 = 0,0,1,0 %;
macro X1303$V_CESR_IOE1 = 0,1,1,0 %;
macro X1303$V_CESR_IORPE1 = 0,2,1,0 %;
macro X1303$V_CESR_BE1 = 0,3,1,0 %;
macro X1303$V_CESR_DPE1 = 0,4,1,0 %;
macro X1303$V_CESR_IOLE1 = 0,5,1,0 %;
macro X1303$V_CESR_DLE1 = 0,6,1,0 %;
macro X1303$V_CESR_MTTO1 = 0,7,1,0 %;
macro X1303$V_CESR_NXIOE2 = 0,8,1,0 %;
macro X1303$V_CESR_IOE2 = 0,9,1,0 %;
macro X1303$V_CESR_IORPE2 = 0,10,1,0 %;
macro X1303$V_CESR_BE2 = 0,11,1,0 %;
macro X1303$V_CESR_DPE2 = 0,12,1,0 %;
macro X1303$V_CESR_IOLE2 = 0,13,1,0 %;
macro X1303$V_CESR_DLE2 = 0,14,1,0 %;
macro X1303$V_CESR_MTTO2 = 0,15,1,0 %;
macro X1303$V_CESR_PREL1 = 0,16,1,0 %;
macro X1303$V_CESR_PREL2 = 0,17,1,0 %;
macro X1303$V_CESR_PREL = 0,18,1,0 %;
macro X1303$V_CESR_PE = 0,20,1,0 %;
macro X1303$V_CESR_NAE = 0,21,1,0 %;
macro X1303$V_CESR_TOE1 = 0,22,1,0 %;
macro X1303$V_CESR_TOE2 = 0,23,1,0 %;
macro X1303$V_CESR_IL = 0,24,1,0 %;
macro X1303$V_CESR_RC = 0,25,1,0 %;
macro X1303$V_CESR_LE = 0,26,1,0 %;
macro X1303$V_CESR_RDRNAE = 0,27,1,0 %;
macro X1303$V_CESR_ERROR = 0,31,1,0 %;
literal X1303$M_CMCDSR_FBO1 = 1;
literal X1303$M_CMCDSR_FBO2 = 2;
literal X1303$M_CMCDSR_FWBH = 4;
literal X1303$M_CMCDSR_EP = 8;
literal X1303$M_CMCDSR_FWSP = 16;
literal X1303$M_CMCDSR_FWMP = 32;
literal X1303$M_CMCDSR_FWP1 = 64;
literal X1303$M_CMCDSR_FWP2 = 128;
literal X1303$M_CMCDSR_ENAIO2 = 256;
literal X1303$M_CMCDSR_CQBIC = 512;
literal X1303$K_CMCDSR_3200 = 0;
literal X1303$K_CMCDSR_2000 = 1;
literal X1303$K_CMCDSR_1000 = 2;
literal X1303$K_CMCDSR_500 = 3;
literal X1303$M_CMCDSR_TOP = 3072;
literal X1303$K_CMCDSR_144 = 0;
literal X1303$K_CMCDSR_1440 = 1;
literal X1303$K_CMCDSR_14400 = 2;
literal X1303$K_CMCDSR_144000 = 3;
literal X1303$M_CMCDSR_MTTOP1 = 12288;
literal X1303$M_CMCDSR_MTTOP2 = 49152;
literal X1303$M_CMCDSR_PI1 = 983040;
literal X1303$M_CMCDSR_PI2 = 15728640;
literal X1303$S_X1303_CMCDSR = 4;
macro X1303$V_CMCDSR_FBO1 = 0,0,1,0 %;
macro X1303$V_CMCDSR_FBO2 = 0,1,1,0 %;
macro X1303$V_CMCDSR_FWBH = 0,2,1,0 %;
macro X1303$V_CMCDSR_EP = 0,3,1,0 %;
macro X1303$V_CMCDSR_FWSP = 0,4,1,0 %;
macro X1303$V_CMCDSR_FWMP = 0,5,1,0 %;
macro X1303$V_CMCDSR_FWP1 = 0,6,1,0 %;
macro X1303$V_CMCDSR_FWP2 = 0,7,1,0 %;
macro X1303$V_CMCDSR_ENAIO2 = 0,8,1,0 %;
macro X1303$V_CMCDSR_CQBIC = 0,9,1,0 %;
macro X1303$V_CMCDSR_TOP = 0,10,2,0 %;
literal X1303$S_CMCDSR_TOP = 2;
macro X1303$V_CMCDSR_MTTOP1 = 0,12,2,0 %;
literal X1303$S_CMCDSR_MTTOP1 = 2;
macro X1303$V_CMCDSR_MTTOP2 = 0,14,2,0 %;
literal X1303$S_CMCDSR_MTTOP2 = 2;
macro X1303$V_CMCDSR_PI1 = 0,16,4,0 %;
literal X1303$S_CMCDSR_PI1 = 4;
macro X1303$V_CMCDSR_PI2 = 0,20,4,0 %;
literal X1303$S_CMCDSR_PI2 = 4;
literal X1303$M_CSEAR_OWADDR = 1073741808;
literal X1303$S_X1303_CSEAR = 4;
macro X1303$V_CSEAR_OWADDR = 0,4,26,0 %;
literal X1303$S_CSEAR_OWADDR = 26;
literal X1303$M_CIOEAR_ADDR = 536870911;
literal X1303$M_CIOEAR_ID = -536870912;
literal X1303$S_X1303_CIOEAR = 4;
macro X1303$V_CIOEAR_ADDR = 0,0,29,0 %;
literal X1303$S_CIOEAR_ADDR = 29;
macro X1303$V_CIOEAR_ID = 0,29,3,0 %;
literal X1303$S_CIOEAR_ID = 3;
literal X1303$M_CNEAR_ADDR = 536870911;
literal X1303$M_CNEAR_ID = -536870912;
literal X1303$S_X1303_CNEAR = 4;
macro X1303$V_CNEAR_ADDR = 0,0,29,0 %;
literal X1303$S_CNEAR_ADDR = 29;
macro X1303$V_CNEAR_ID = 0,29,3,0 %;
literal X1303$S_CNEAR_ID = 3;
literal X1303$M_INTMSK_BA = 1;
literal X1303$M_INTMSK_SC = 2;
literal X1303$M_INTMSK_GR = 4;
literal X1303$M_INTMSK_QU = 8;
literal X1303$M_INTMSK_SO = 16;
literal X1303$M_INTMSK_SY = 32;
literal X1303$S_X1303_INTMSK = 1;
macro X1303$V_INTMSK_BA = 0,0,1,0 %;
macro X1303$V_INTMSK_SC = 0,1,1,0 %;
macro X1303$V_INTMSK_GR = 0,2,1,0 %;
macro X1303$V_INTMSK_QU = 0,3,1,0 %;
macro X1303$V_INTMSK_SO = 0,4,1,0 %;
macro X1303$V_INTMSK_SY = 0,5,1,0 %;
literal X1303$M_INTREQ_BA = 1;
literal X1303$M_INTREQ_SC = 2;
literal X1303$M_INTREQ_GR = 4;
literal X1303$M_INTREQ_QU = 8;
literal X1303$M_INTREQ_SO = 16;
literal X1303$M_INTREQ_SY = 32;
literal X1303$M_INTREQ_SC_CP_ERR = 64;
literal X1303$M_INTREQ_MAP_ERR = 128;
literal X1303$S_X1303_INTREQ = 1;
macro X1303$V_INTREQ_BA = 0,0,1,0 %;
macro X1303$V_INTREQ_SC = 0,1,1,0 %;
macro X1303$V_INTREQ_GR = 0,2,1,0 %;
macro X1303$V_INTREQ_QU = 0,3,1,0 %;
macro X1303$V_INTREQ_SO = 0,4,1,0 %;
macro X1303$V_INTREQ_SY = 0,5,1,0 %;
macro X1303$V_INTREQ_SC_CP_ERR = 0,6,1,0 %;
macro X1303$V_INTREQ_MAP_ERR = 0,7,1,0 %;
literal X1303$M_INTCLR_BA = 1;
literal X1303$M_INTCLR_SC = 2;
literal X1303$M_INTCLR_GR = 4;
literal X1303$M_INTCLR_QU = 8;
literal X1303$M_INTCLR_SO = 16;
literal X1303$M_INTCLR_SY = 32;
literal X1303$M_INTCLR_SC_CP_ERR = 64;
literal X1303$M_INTCLR_MAP_ERR = 128;
literal X1303$S_X1303_INTCLR = 1;
macro X1303$V_INTCLR_BA = 0,0,1,0 %;
macro X1303$V_INTCLR_SC = 0,1,1,0 %;
macro X1303$V_INTCLR_GR = 0,2,1,0 %;
macro X1303$V_INTCLR_QU = 0,3,1,0 %;
macro X1303$V_INTCLR_SO = 0,4,1,0 %;
macro X1303$V_INTCLR_SY = 0,5,1,0 %;
macro X1303$V_INTCLR_SC_CP_ERR = 0,6,1,0 %;
macro X1303$V_INTCLR_MAP_ERR = 0,7,1,0 %;
 
!*** MODULE $XVIBDEF ***
! +      
!  This contains the definitions for the XVIB which is a B board to the XBIA+/XVIB board
!  set. The A board definitions are located in XBIDEF.SDL.
! 
!  In order to cut development costs the XMI to VME adapter was implemented using the
!  the IBUS and the existing XBIA+ BI adapter board. The A board remains exactly as it
!  was designed for the XMI to BI adapter.
! -
literal VME$K_EXTEND = 0;
literal VME$K_INVALID1 = 1;
literal VME$K_SHORT = 2;
literal VME$K_STAND = 3;
! 
literal VME$K_INVALID = 0;
literal VME$K_BYTE = 1;
literal VME$K_WORD = 2;
literal VME$K_LONG = 3;
! 
literal XMI$K_ROAK = 0;
literal XMI$K_RORA = 1;
literal XMI$K_BR4_A = 0;
literal XMI$K_BR4_R = 1;
literal XMI$K_BR5_A = 2;
literal XMI$K_BR5_R = 3;
literal XMI$K_BR6_A = 4;
literal XMI$K_BR6_R = 5;
literal XMI$K_BR7_A = 6;
literal XMI$K_BR7_R = 7;
literal XMI$K_BR4 = 0;
literal XMI$K_BR5 = 1;
literal XMI$K_BR6 = 2;
literal XMI$K_BR7 = 3;
literal XMI$M_ERROR_BR4 = 0;
literal XMI$M_ERROR_BR5 = 4096;
literal XMI$M_ERROR_BR6 = 8192;
literal XMI$M_ERROR_BR7 = 12288;
literal VME$M_CLOCK_32MHz = 0;
literal VME$M_CLOCK_16MHz = 16384;
literal VME$M_CLOCK_8MHz = 32768;
literal VME$M_CLOCK_4MHz = 49152;
literal TRAN$M_DISAB = 458752;
literal TRAN$M_N328mS = 393216;
literal TRAN$M_N819uS = 327680;
literal TRAN$M_N128uS = 262144;
literal TRAN$M_N64uS = 196608;
literal TRAN$M_N32uS = 131072;
literal TRAN$M_N12_8uS = 65536;
literal TRAN$M_N800nS = 0;
literal ARB$M_DISAB = 3670016;
literal ARB$M_N328mS = 3145728;
literal ARB$M_N819uS = 2621440;
literal ARB$M_N128uS = 2097152;
literal ARB$M_N64uS = 1572864;
literal ARB$M_N32uS = 1048576;
literal ARB$M_N12_8uS = 524288;
literal ARB$M_N800nS = 0;
literal XVIB$M_RESET = 4194304;
literal XVIB$M_VMEWRITE = 8388608;
literal VME$M_REQL_0 = 0;
literal VME$M_REQL_1 = 16777216;
literal VME$M_REQL_2 = 33554432;
literal VME$M_REQL_3 = 50331648;
literal XMI$M_PAGE_4KB = 0;
literal XMI$M_PAGE_8KB = 67108864;
literal XMI$M_PAGE_512B = 134217728;
literal XVIB$M_ERRSUM = 268435456;
literal VME$M_ARB_RRS = 0;
literal VME$M_ARB_PRI = 536870912;
literal VME$M_ARB_PRS = 1073741824;
literal VME$M_ARB_SGL = 1610612736;
literal XVIB$M_ARBENBL = -2147483648;
literal XVIB$M_SYSRESET = 2048;
literal XVIB$M_DS0TMO = 4096;
literal XVIB$M_DS1TMO = 8192;
literal XVIB$M_ARBTMOXXX = 4194304;
literal XVIB$M_TRANTMOXXX = 8388608;
literal XVIB$M_IRPARERR = 16777216;
literal XVIB$M_ITPARERR = 33554432;
literal XVIB$M_VTPARERR = 67108864;
literal XVIB$M_RMWERR = 134217728;
literal XVIB$M_RMWERR2 = 268435456;
literal XVIB$M_ILOCKERR = 536870912;
literal XVIB$M_BERRSTATE = 1073741824;
literal XVIB$M_RAMERR = -2147483648;
literal VME$M_IRQ1_R0AK = 0;
literal VME$M_IRQ1_R0RA = 1;
literal VME$M_IRQ2_R0AK = 0;
literal VME$M_IRQ2_R0RA = 2;
literal VME$M_IRQ3_BR4AK = 0;
literal VME$M_IRQ3_BR4RA = 4;
literal VME$M_IRQ3_BR5AK = 8;
literal VME$M_IRQ3_BR5RA = 12;
literal VME$M_IRQ3_BR6AK = 16;
literal VME$M_IRQ3_BR6RA = 20;
literal VME$M_IRQ3_BR7AK = 24;
literal VME$M_IRQ3_BR7RA = 28;
literal VME$M_IRQ4_BR4AK = 0;
literal VME$M_IRQ4_BR4RA = 32;
literal VME$M_IRQ4_BR5AK = 64;
literal VME$M_IRQ4_BR5RA = 96;
literal VME$M_IRQ4_BR6AK = 128;
literal VME$M_IRQ4_BR6RA = 160;
literal VME$M_IRQ4_BR7AK = 192;
literal VME$M_IRQ4_BR7RA = 224;
literal VME$M_IRQ5_BR4AK = 0;
literal VME$M_IRQ5_BR4RA = 256;
literal VME$M_IRQ5_BR5AK = 512;
literal VME$M_IRQ5_BR5RA = 768;
literal VME$M_IRQ5_BR6AK = 1024;
literal VME$M_IRQ5_BR6RA = 1280;
literal VME$M_IRQ5_BR7AK = 1536;
literal VME$M_IRQ5_BR7RA = 1792;
literal VME$M_IRQ6_BR4AK = 0;
literal VME$M_IRQ6_BR4RA = 2048;
literal VME$M_IRQ6_BR5AK = 4096;
literal VME$M_IRQ6_BR5RA = 6144;
literal VME$M_IRQ6_BR6AK = 8192;
literal VME$M_IRQ6_BR6RA = 10240;
literal VME$M_IRQ6_BR7AK = 12288;
literal VME$M_IRQ6_BR7RA = 14336;
literal VME$M_IRQ7_BR4AK = 0;
literal VME$M_IRQ7_BR4RA = 16384;
literal VME$M_IRQ7_BR5AK = 32768;
literal VME$M_IRQ7_BR5RA = 49152;
literal VME$M_IRQ7_BR6AK = 65536;
literal VME$M_IRQ7_BR6RA = 81920;
literal VME$M_IRQ7_BR7AK = 98304;
literal VME$M_IRQ7_BR7RA = 114688;
literal XVIB$M_ERMWERR = 131072;
literal XVIB$M_ERMWERR2 = 262144;
literal XVIB$M_ELOCKERR = 524288;
literal XVIB$M_TRANSTMOERR = 1048576;
literal XVIB$M_ARBTMOERR = 2097152;
literal XVIB$M_VMEIBUSPAR = 4194304;
literal XVIB$M_SWAPPARERR = 8388608;
literal XVIB$M_BERR = 16777216;
literal VME$M_ENBL_IRQ1 = 0;
literal VME$M_ENBL_IRQ2 = 67108864;
literal VME$M_ENBL_IRQ3 = 134217728;
literal VME$M_ENBL_IRQ4 = 268435456;
literal VME$M_ENBL_IRQ5 = 536870912;
literal VME$M_ENBL_IRQ6 = 1073741824;
literal VME$M_ENBL_IRQ7 = -2147483648;
literal XVIB$M_DSBLVME = 16;
literal XVIB$M_DIAGMD = 32;
literal XVIB$M_TESTFAIL = 64;
literal XVIB$M_RESVD_2 = 128;
literal VME$K_NOSWAP = 0;
literal VME$K_BYTESWAP = 1;
literal VME$K_WORDSWAP = 2;
literal VME$K_LONGSWAP = 3;
literal XVIB$M_RMWMODE = 4;
literal XVIB$M_PARITY = 8;
literal XVIB$M_READWRITE = 16;
literal VME$K_VAER = 5;
literal VME$K_VDR = 6;
literal VME$K_VFDR = 7;
!  VME CPU transaction offest/length registers
literal VME$K_VAOR0 = 32;
literal VME$K_VAOR1 = 33;
literal VME$K_VAOR2 = 34;
literal VME$K_VAOR3 = 35;
literal VME$K_VAOR4 = 36;
literal VME$K_VAOR5 = 37;
literal VME$K_VAOR6 = 38;
literal VME$K_VAOR7 = 39;
literal VME$K_VAOR8 = 40;
literal VME$K_VAOR9 = 41;
literal VME$K_VAOR10 = 42;
literal VME$K_VAOR11 = 43;
literal VME$K_VAOR12 = 44;
literal VME$K_VAOR13 = 45;
literal VME$K_VAOR14 = 46;
literal VME$K_VAOR15 = 47;
literal VME$K_VAOR16 = 48;
literal VME$K_VAOR17 = 49;
literal VME$K_VAOR18 = 50;
literal VME$K_VAOR19 = 51;
literal VME$K_VAOR20 = 52;
literal VME$K_VAOR21 = 53;
literal VME$K_VAOR22 = 54;
literal VME$K_VAOR24 = 56;
literal VME$K_VAOR25 = 57;
literal VME$K_VAOR26 = 58;
literal VME$K_VAOR27 = 59;
literal VME$K_VAOR28 = 60;
literal VME$K_VAOR29 = 61;
literal VME$K_VAOR30 = 62;
literal VME$K_VAOR31 = 63;
literal XVIB$M_WRITE = 128;
literal XVIB$S_XVIBDEF = 96;
! 
!  Define the different types of VME acceses for the PIO mapping registers
! 
!  Define the different types of VME acceses for the PIO mapping registers
! 
!  BR levels with read ack or auto ack encoded
! 
! 
!  xmi interrupt levels
! 
macro XVIB$L_VDCR = 64,0,32,0 %;        !  VDCR Control/Status
macro XVIB$V_DEVTYPE = 64,0,8,0 %;
literal XVIB$S_DEVTYPE = 8;             !  VME bus adatper type */
macro XVIB$V_DREV = 64,8,4,0 %;
literal XVIB$S_DREV = 4;                !  VME bus adatper revision */
macro XVIB$V_INTPRI = 64,12,2,0 %;
literal XVIB$S_INTPRI = 2;              !  VME adatper error interrupt prio */
!  XVIB error interrupt level
macro XVIB$V_SERCLK = 64,14,2,0 %;
literal XVIB$S_SERCLK = 2;              !  VME bus clock frequency */
!  VME service clock frequency
macro XVIB$V_TRANTMO = 64,16,3,0 %;
literal XVIB$S_TRANTMO = 3;             !  VME transaction timeout value */
macro XVIB$V_ARBTMO = 64,19,3,0 %;
literal XVIB$S_ARBTMO = 3;              !  VME arbitration timeout value */
macro XVIB$V_RESET = 64,22,1,0 %;       !  Reset the XVIB
macro XVIB$V_VMEWRITE = 64,23,1,0 %;    !  Recieved a SYSRESET from VME
macro XVIB$V_REQLEV = 64,24,2,0 %;
literal XVIB$S_REQLEV = 2;              !  VME bus request level */
!  VME bus request levels
macro XVIB$V_PAGESZ = 64,26,2,0 %;
literal XVIB$S_PAGESZ = 2;              !  Size of pages
macro XVIB$V_ERRSUM = 64,28,1,0 %;      !  Adapter error summary
macro XVIB$V_ARBTYPE = 64,29,2,0 %;
literal XVIB$S_ARBTYPE = 2;             !  VME arbitration type selection */
!  Define arbitration mode bits for the VME
macro XVIB$V_ARBENBL = 64,31,1,0 %;     !  VME arbitration enable */
macro XVIB$L_VESR = 68,0,32,0 %;        !  XVIB Error Summary
macro XVIB$V_INTSENT = 68,0,4,0 %;
literal XVIB$S_INTSENT = 4;             !  BR level the interrupt from the XVIB
macro XVIB$V_INTPEND = 68,4,7,0 %;
literal XVIB$S_INTPEND = 7;             !  IRQ level on the VME bus
macro XVIB$V_SYSRESET = 68,11,1,0 %;    !  Write signal on VME
macro XVIB$V_DS0TMO = 68,12,1,0 %;      !  VME DS0 timeout has occured
macro XVIB$V_DS1TMO = 68,13,1,0 %;      !  VME DS1 timeout has occured
macro XVIB$V_ADRMODS = 68,14,6,0 %;
literal XVIB$S_ADRMODS = 6;             !  VME address moditfiers on VME timeout
macro XVIB$V_BUSGRANT = 68,20,2,0 %;
literal XVIB$S_BUSGRANT = 2;            !  VME bus grant at timeout
macro XVIB$V_ARBTMOXXX = 68,22,1,0 %;   !  VME arbitration timeout has occured
macro XVIB$V_TRANTMOXXX = 68,23,1,0 %;  !  VME transaction timeout has occured
macro XVIB$V_IRPARERR = 68,24,1,0 %;    !  IBUS recieve parity error 
macro XVIB$V_ITPARERR = 68,25,1,0 %;    !  IBUS transmit parity error
macro XVIB$V_VTPARERR = 68,26,1,0 %;    !  VME transmit parity error
macro XVIB$V_RMWERR = 68,27,1,0 %;      !  VME read modify write error
macro XVIB$V_RMWERR2 = 68,28,1,0 %;     !  VME Read modify write error
macro XVIB$V_ILOCKERR = 68,29,1,0 %;    !  VME interlock error
macro XVIB$V_BERRSTATE = 68,30,1,0 %;   !  BERR state on the VME bus
macro XVIB$V_RAMERR = 68,31,1,0 %;      !  Byte swap RAM parity error
macro XVIB$L_VFADR = 72,0,32,0 %;       !  XVIB interrupt configurtion register 
macro XVIB$V_TEMP = 72,0,32,0 %;
literal XVIB$S_TEMP = 32;
macro XVIB$L_VICR = 76,0,32,0 %;        !  XVIB interrupt configurtion register 
macro XVIB$V_IRQ1 = 76,0,1,0 %;         !  VME IRQ1 to BR conversion mask
macro XVIB$V_IRQ2 = 76,1,1,0 %;         !  VME IRQ2 to BR conversion mask
macro XVIB$V_IRQ3 = 76,2,3,0 %;
literal XVIB$S_IRQ3 = 3;                !  VME IRQ3 to BR conversion & IACK type
macro XVIB$V_IRQ4 = 76,5,3,0 %;
literal XVIB$S_IRQ4 = 3;                !  VME IRQ4 to BR conversion & IACK type
macro XVIB$V_IRQ5 = 76,8,3,0 %;
literal XVIB$S_IRQ5 = 3;                !  VME IRQ5 to BR conversion & IACK type
macro XVIB$V_IRQ6 = 76,11,3,0 %;
literal XVIB$S_IRQ6 = 3;                !  VME IRQ6 to BR conversion
macro XVIB$V_IRQ7 = 76,14,3,0 %;
literal XVIB$S_IRQ7 = 3;                !  VME IRQ7 to BR conversion
macro XVIB$V_ERMWERR = 76,17,1,0 %;     !  Enable RMW error interrupt
macro XVIB$V_ERMWERR2 = 76,18,1,0 %;    !  Enable RMW error interrupt
macro XVIB$V_ELOCKERR = 76,19,1,0 %;    !  Enable INTERLOCK error interrupt
macro XVIB$V_TRANSTMOERR = 76,20,1,0 %; !  Enable transaction timeout interrupt
macro XVIB$V_ARBTMOERR = 76,21,1,0 %;   !  Enable VME ARB timeout interrutps
macro XVIB$V_VMEIBUSPAR = 76,22,1,0 %;  !  Enable parity error interrupts
macro XVIB$V_SWAPPARERR = 76,23,1,0 %;  !  Enable byte swap parity interrupt
macro XVIB$V_BERR = 76,24,1,0 %;        !  Enable VME BERR interrupts
macro XVIB$V_VIRQENA = 76,25,7,0 %;
literal XVIB$S_VIRQENA = 7;             !  VME interrupt enable mask
macro XVIB$L_VVOR = 80,0,32,0 %;        !  XVIB/VME interrupt vector offset 
macro XVIB$V_IBUS = 80,0,4,0 %;
literal XVIB$S_IBUS = 4;                !  State of IBUS cable between boards
macro XVIB$V_DSBLVME = 80,4,1,0 %;      !  Disable VME
macro XVIB$V_DIAGMD = 80,5,1,0 %;       !  DIAG mode
macro XVIB$V_TESTFAIL = 80,6,1,0 %;     !  
macro XVIB$V_RESVD_2 = 80,7,1,0 %;
macro XVIB$B_XVEC = 81,0,8,0 %;         !  Vector offset from XVIB with VME vec
macro XVIB$V_RESVD_3 = 80,16,16,0 %;
literal XVIB$S_RESVD_3 = 16;
macro XVIB$L_VVR = 84,0,32,0 %;         !  XVIB	error interrupt vector offset 
macro XVIB$V_XVEC = 84,2,14,0 %;
literal XVIB$S_XVEC = 14;               !  Vector offset for XVIB errors
macro XVIB$V_XDEST = 84,16,8,0 %;
literal XVIB$S_XDEST = 8;               !  XMI CPU interrupt destination mask
macro XVIB$L_RAR = 88,0,32,0 %;         !  XVIB	byte swap RAM register 
macro XVIB$V_MODE = 88,0,2,0 %;
literal XVIB$S_MODE = 2;                !  Byte swap mode bits
macro XVIB$V_RMWMODE = 88,2,1,0 %;      !  Use interlocked accesses
macro XVIB$V_PARITY = 88,3,1,0 %;       !  State of parity
macro XVIB$V_READWRITE = 88,4,1,0 %;    !  Write set; Read clear
macro XVIB$V_RESVD_X = 88,5,4,0 %;
literal XVIB$S_RESVD_X = 4;
macro XVIB$V_ADDRS = 88,9,19,0 %;
literal XVIB$S_ADDRS = 19;              !  Byte swap page address
macro XVIB$V_RESVD_4 = 88,28,3,0 %;
literal XVIB$S_RESVD_4 = 3;
macro XVIB$L_VCAR = 92,0,32,0 %;        !  XBIB vector register
macro XVIB$V_REGNUM = 92,0,6,0 %;
literal XVIB$S_REGNUM = 6;              !  Register number to access on XVIB
!  CSR number definitions
!  starting and ending address registers
macro XVIB$V_WRITE = 92,7,1,0 %;        !  Write the CSR
macro XVIB$V_DATA = 92,14,18,0 %;
literal XVIB$S_DATA = 18;               !  Read write data from CSRs
! 
!  Layout of the PIO mapping registers
! 
literal XVIB$S_PIODEF = 4;
macro XVIB$L_PIOMAP = 0,0,32,0 %;       !  PIO map register
macro PIOMAP$V_DATALEN = 0,16,2,0 %;
literal PIOMAP$S_DATALEN = 2;           !  Size of data for each access to the VME
macro PIOMAP$V_ADRLEN = 0,18,2,0 %;
literal PIOMAP$S_ADRLEN = 2;            !  Type of VME addressing to generate
macro PIOMAP$V_VMEOFF = 0,20,11,0 %;
literal PIOMAP$S_VMEOFF = 11;           !  Offset to add to CPU's 0-19 address
! 
!  DMA map register definitions, Byteswap RAM definitions
! 
literal VME$M_NOSWAP = 0;
literal VME$M_BYTESWAP = 1;
literal VME$M_WORDSWAP = 2;
literal VME$M_LONGSWAP = 3;
literal VME$M_ENBLRMW = 0;              !  Enable RMW transactions
literal VME$M_READWRITE = 16;
literal VME$S_DMADEF = 5;
macro VME$L_DMAMAP = 0,0,32,0 %;        !  PIO map register
macro VME$V_SWAPMODE = 0,0,2,0 %;
literal VME$S_SWAPMODE = 2;             !  Type of swapping requested
macro VME$V_RMW = 0,2,1,0 %;            !  Size of data for each access to the VME
macro VME$V_PARITY = 0,3,1,0 %;         !  Parity of byteswap RAM location
macro VME$V_READWRITE = 0,4,1,0 %;      !  Control to read or write the RAM location
macro VME$V_RESVD_7 = 0,5,4,0 %;
literal VME$S_RESVD_7 = 4;
macro VME$V_RAMADDRS = 0,9,21,0 %;
literal VME$S_RAMADDRS = 21;            !  Address of RAM location to write
macro VME$V_RESVD_8 = 0,30,3,0 %;
literal VME$S_RESVD_8 = 3;
literal VME_MD$S_VME_MD_LAYOUT = 4;
macro VME_MD$W_MAPREG = 0,0,16,0 %;
macro VME_MD$W_NUMREG = 2,0,16,0 %;
! 
! ****************************************************************************
! *                                                                          *
! *  Copyright (c) 1992                                                      *
! *  by DIGITAL Equipment Corporation, Maynard, Mass.                        *
! *                                                                          *
! *  This software is furnished under a license and may be used and  copied  *
! *  only  in  accordance  with  the  terms  of  such  license and with the  *
! *  inclusion of the above copyright notice.  This software or  any  other  *
! *  copies  thereof may not be provided or otherwise made available to any  *
! *  other person.  No title to and ownership of  the  software  is  hereby  *
! *  transferred.                                                            *
! *                                                                          *
! *  The information in this software is subject to change  without  notice  *
! *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment  *
! *  Corporation.                                                            *
! *                                                                          *
! *  DIGITAL assumes no responsibility for the use or  reliability  of  its  *
! *  software on equipment which is not supplied by DIGITAL.                 *
! *                                                                          *
! ****************************************************************************
! ********************************************************************************************************************************
!  Created  7-JUL-1992 20:05:07 by VAX SDL T3.2-8      Source: 22-FEB-1991 11:07:18 _$22$DIA9:[VMSLIB.SRC]F11DEF.SDL;1 
! ********************************************************************************************************************************
 
!*** MODULE $FH1DEF ***
literal FH1$C_LEVEL1 = 257;             !  401 octal = structure level 1 
literal FH1$K_LENGTH = 46;              !  length of header area 
literal FH1$C_LENGTH = 46;              !  length of header area 
literal FH1$S_FH1DEF = 512;
macro FH1$B_IDOFFSET = 0,0,8,0 %;       !  ident area offset in words 
macro FH1$B_MPOFFSET = 1,0,8,0 %;       !  map area offset in words 
macro FH1$W_FID = 2,0,32,0 %;
literal FH1$S_FID = 4;                  !  file ID 
macro FH1$W_FID_NUM = 2,0,16,0 %;       !  file number 
macro FH1$W_FID_SEQ = 4,0,16,0 %;       !  file sequence number 
macro FH1$W_STRUCLEV = 6,0,16,0 %;      !  file structure level 
macro FH1$W_FILEOWNER = 8,0,16,0 %;     !  file owner UIC 
macro FH1$B_UICMEMBER = 8,0,8,0 %;      !  UIC member number 
macro FH1$B_UICGROUP = 9,0,8,0 %;       !  UIC group number 
macro FH1$W_FILEPROT = 10,0,16,0 %;     !  file protection 
macro FH1$V_SYSPRO = 10,0,4,0 %;
literal FH1$S_SYSPRO = 4;               !  system protection 
macro FH1$V_OWNPRO = 10,4,4,0 %;
literal FH1$S_OWNPRO = 4;               !  owner protection 
macro FH1$V_GROUPPRO = 10,8,4,0 %;
literal FH1$S_GROUPPRO = 4;             !  group protection 
macro FH1$V_WORLDPRO = 10,12,4,0 %;
literal FH1$S_WORLDPRO = 4;             !  world protection 
macro FH1$W_FILECHAR = 12,0,16,0 %;     !  file characteristics 
macro FH1$B_USERCHAR = 12,0,8,0 %;      !  user controlled characteristics 
macro FH1$V_WASCONTIG = 12,0,1,0 %;     !  file was (and should be) contiguous
macro FH1$V_NOBACKUP = 12,1,1,0 %;      !  file is not to be backed up 
macro FH1$V_READCHECK = 12,3,1,0 %;     !  verify all read operations 
macro FH1$V_WRITCHECK = 12,4,1,0 %;     !  verify all write operations 
macro FH1$V_CONTIGB = 12,5,1,0 %;       !  keep file as contiguous as possible 
macro FH1$V_LOCKED = 12,6,1,0 %;        !  file is deaccess locked 
macro FH1$V_CONTIG = 12,7,1,0 %;        !  file is contiguous 
macro FH1$B_SYSCHAR = 13,0,8,0 %;       !  system controlled characteristics 
macro FH1$V_SPOOL = 13,4,1,0 %;         !  intermediate spool file 
macro FH1$V_BADBLOCK = 13,6,1,0 %;      !  file contains bad blocks 
macro FH1$V_MARKDEL = 13,7,1,0 %;       !  file is marked for delete 
macro FH1$W_RECATTR = 14,0,0,0 %;
literal FH1$S_RECATTR = 32;             !  file record attributes 
macro FH1$W_CHECKSUM = 510,0,16,0 %;    !  file header checksum 
 
!*** MODULE $FI1DEF ***
literal FI1$K_LENGTH = 46;              !  length of ident area 
literal FI1$C_LENGTH = 46;              !  length of ident area 
literal FI1$S_FI1DEF = 286;
macro FI1$W_FILENAME = 0,0,0,0 %;
literal FI1$S_FILENAME = 6;             !  file name (RAD-50) 
macro FI1$W_FILETYPE = 6,0,16,0 %;      !  file type (RAD-50) 
macro FI1$W_VERSION = 8,0,16,0 %;       !  version number (binary) 
macro FI1$W_REVISION = 10,0,16,0 %;     !  revision number (binary) 
macro FI1$T_REVDATE = 12,0,0,0 %;
literal FI1$S_REVDATE = 7;              !  revision date (ASCII DDMMMYY) 
macro FI1$T_REVTIME = 19,0,0,0 %;
literal FI1$S_REVTIME = 6;              !  revision time (ASCII HHMMSS) 
macro FI1$T_CREDATE = 25,0,0,0 %;
literal FI1$S_CREDATE = 7;              !  creation date (ASCII DDMMMYY) 
macro FI1$T_CRETIME = 32,0,0,0 %;
literal FI1$S_CRETIME = 6;              !  creation time (ASCII HHMMSS) 
macro FI1$T_EXPDATE = 38,0,0,0 %;
literal FI1$S_EXPDATE = 7;              !  expiration date (ASCII DDMMMYY) 
macro FI1$T_MTHDR1 = 46,0,0,0 %;
literal FI1$S_MTHDR1 = 80;              !  HDR1 of ANSI magnetic tape file 
macro FI1$T_MTHDR2 = 126,0,0,0 %;
literal FI1$S_MTHDR2 = 80;              !  HDR2 of ANSI magnetic tape file 
macro FI1$T_MTHDR3 = 206,0,0,0 %;
literal FI1$S_MTHDR3 = 80;              !  HDR3 of ANSI magnetic tape file 
 
!*** MODULE $FM1DEF ***
literal FM1$K_POINTERS = 10;            !  start of retrieval pointers 
literal FM1$C_POINTERS = 10;            !  start of retrieval pointers 
literal FM1$K_LENGTH = 10;              !  length of map area 
literal FM1$C_LENGTH = 10;              !  length of map area 
!  retrieval pointer format
literal FM1$S_FM1DEF = 10;
macro FM1$B_EX_SEGNUM = 0,0,8,0 %;      !  extension segment number of this header 
macro FM1$B_EX_RVN = 1,0,8,0 %;         !  extension relative volume number 
macro FM1$W_EX_FILNUM = 2,0,16,0 %;     !  extension file number 
macro FM1$W_EX_FILSEQ = 4,0,16,0 %;     !  extension file sequence number 
macro FM1$B_COUNTSIZE = 6,0,8,0 %;      !  retrieval pointer count field size 
macro FM1$B_LBNSIZE = 7,0,8,0 %;        !  retrieval pointer LBN field size 
macro FM1$B_INUSE = 8,0,8,0 %;          !  number of retrieval words in use 
macro FM1$B_AVAIL = 9,0,8,0 %;          !  number of retrieval words available 
literal FM1$S_FM1DEF1 = 4;
macro FM1$B_HIGHLBN = 0,0,8,0 %;        !  high order LBN 
macro FM1$B_COUNT = 1,0,8,0 %;          !  block count 
macro FM1$W_LOWLBN = 2,0,16,0 %;        !  low order LBN 
literal FM1$S_FM1DEF2 = 5;
macro FM1$B_PREVHLBN = -4,0,8,0 %;
macro FM1$B_PREVCOUNT = -3,0,8,0 %;
macro FM1$W_PREVLLBN = -2,0,16,0 %;     !  previous retrieval pointer 
 
!*** MODULE $FH2DEF ***
! +
! 
!  File header definitions for Files-11 Structure Level 2
! 
! -
literal FH2$C_LEVEL1 = 257;             !  401 octal = structure level 1 
literal FH2$C_LEVEL2 = 512;             !  1000 octal = structure level 2 
literal FH2$M_VCC_STATE = 1792;
literal FH2$M_ALM_STATE = 786432;
literal FH2$M_WASCONTIG = 1;
literal FH2$M_NOBACKUP = 2;
literal FH2$M_WRITEBACK = 4;
literal FH2$M_READCHECK = 8;
literal FH2$M_WRITCHECK = 16;
literal FH2$M_CONTIGB = 32;
literal FH2$M_LOCKED = 64;
literal FH2$M_CONTIG = 128;
literal FH2$M_BADACL = 2048;
literal FH2$M_SPOOL = 4096;
literal FH2$M_DIRECTORY = 8192;
literal FH2$M_BADBLOCK = 16384;
literal FH2$M_MARKDEL = 32768;
literal FH2$M_NOCHARGE = 65536;
literal FH2$M_ERASE = 131072;
literal FH2$M_ALM_AIP = 262144;
literal FH2$M_ALM_ARCHIVED = 524288;
literal FH2$M_SCRATCH = 1048576;
literal FH2$M_NOMOVE = 2097152;
literal FH2$M_ONLY_RU = 1;
literal FH2$M_RUJNL = 2;
literal FH2$M_BIJNL = 4;
literal FH2$M_AIJNL = 8;
literal FH2$M_ATJNL = 16;
literal FH2$M_NEVER_RU = 32;
literal FH2$M_JOURNAL_FILE = 64;
literal FH2$C_RU_FACILITY_RMS = 1;      !  RMS
literal FH2$C_RU_FACILITY_DBMS = 2;     !  DBMS
literal FH2$C_RU_FACILITY_RDB = 3;      !  Rdb/VMS
literal FH2$C_RU_FACILITY_CHKPNT = 4;   !  Checkpoint/Restart
literal FH2$K_LENGTH = 80;              !  length of header area 
literal FH2$C_LENGTH = 80;              !  length of header area 
literal FH2$K_SUBSET0_LENGTH = 88;      !  length of header area 
literal FH2$C_SUBSET0_LENGTH = 88;      !  length of header area 
literal FH2$K_FULL_LENGTH = 108;        !  length of full header
literal FH2$C_FULL_LENGTH = 108;        !  length of full header
literal FH2$S_FH2DEF = 512;
macro FH2$B_IDOFFSET = 0,0,8,0 %;       !  ident area offset in words 
macro FH2$B_MPOFFSET = 1,0,8,0 %;       !  map area offset in words 
macro FH2$B_ACOFFSET = 2,0,8,0 %;       !  access control list offset in words 
macro FH2$B_RSOFFSET = 3,0,8,0 %;       !  reserved area offset in words 
macro FH2$W_SEG_NUM = 4,0,16,0 %;       !  file segment number 
macro FH2$W_STRUCLEV = 6,0,16,0 %;      !  file structure level 
macro FH2$B_STRUCVER = 6,0,8,0 %;       !  file structure version 
macro FH2$B_STRUCLEV = 7,0,8,0 %;       !  principal file structure level 
macro FH2$W_FID = 8,0,0,0 %;
literal FH2$S_FID = 6;                  !  file ID 
macro FH2$W_FID_NUM = 8,0,16,0 %;       !  file number 
macro FH2$W_FID_SEQ = 10,0,16,0 %;      !  file sequence number 
macro FH2$W_FID_RVN = 12,0,16,0 %;      !  relative volume number 
macro FH2$B_FID_RVN = 12,0,8,0 %;       !  alternate format RVN 
macro FH2$B_FID_NMX = 13,0,8,0 %;       !  alternate format file number extension 
macro FH2$W_EXT_FID = 14,0,0,0 %;
literal FH2$S_EXT_FID = 6;              !  extension file ID 
macro FH2$W_EX_FIDNUM = 14,0,16,0 %;    !  extension file number 
macro FH2$W_EX_FIDSEQ = 16,0,16,0 %;    !  extension file sequence number 
macro FH2$W_EX_FIDRVN = 18,0,16,0 %;    !  extension relative volume number 
macro FH2$B_EX_FIDRVN = 18,0,8,0 %;     !  alternate format extension RVN 
macro FH2$B_EX_FIDNMX = 19,0,8,0 %;     !  alternate format extension file number extension 
macro FH2$W_RECATTR = 20,0,0,0 %;
literal FH2$S_RECATTR = 32;             !  file record attributes 
macro FH2$L_FILECHAR = 52,0,32,0 %;     !  file characteristics 
macro FH2$V_VCC_STATE = 52,8,3,0 %;
literal FH2$S_VCC_STATE = 3;            !  VCC state bits
! **********The following line is different from FH2 
macro FH2$V_ALM_STATE = 52,18,2,0 %;
literal FH2$S_ALM_STATE = 2;            !  ALM state bits
macro FH2$V_WASCONTIG = 52,0,1,0 %;     !  file was (and should be) contiguous
macro FH2$V_NOBACKUP = 52,1,1,0 %;      !  file is not to be backed up 
macro FH2$V_WRITEBACK = 52,2,1,0 %;     !  file may be write-back cached 
macro FH2$V_READCHECK = 52,3,1,0 %;     !  verify all read operations 
macro FH2$V_WRITCHECK = 52,4,1,0 %;     !  verify all write operations 
macro FH2$V_CONTIGB = 52,5,1,0 %;       !  keep file as contiguous as possible 
macro FH2$V_LOCKED = 52,6,1,0 %;        !  file is deaccess locked 
macro FH2$V_CONTIG = 52,7,1,0 %;        !  file is contiguous 
macro FH2$V_BADACL = 52,11,1,0 %;       !  ACL is invalid 
macro FH2$V_SPOOL = 52,12,1,0 %;        !  intermediate spool file 
macro FH2$V_DIRECTORY = 52,13,1,0 %;    !  file is a directory 
macro FH2$V_BADBLOCK = 52,14,1,0 %;     !  file contains bad blocks 
macro FH2$V_MARKDEL = 52,15,1,0 %;      !  file is marked for delete 
macro FH2$V_NOCHARGE = 52,16,1,0 %;     !  file space is not to be charged 
macro FH2$V_ERASE = 52,17,1,0 %;        !  erase file contents before deletion 
! **********The following two lines are different from FCH
macro FH2$V_ALM_AIP = 52,18,1,0 %;      !  Archive in progress - ALM proj cancelled
macro FH2$V_ALM_ARCHIVED = 52,19,1,0 %; !  File archived - ALM proj cancelled
macro FH2$V_SCRATCH = 52,20,1,0 %;      !  Scratch Header used by movefile
macro FH2$V_NOMOVE = 52,21,1,0 %;       !  Disable movefile on this file
!  Note: The high 8 bits of this longword
!  are reserved for user and CSS use.
macro FH2$W_RECPROT = 56,0,16,0 %;      !  record protection 
macro FH2$B_MAP_INUSE = 58,0,8,0 %;     !  number of map area words in use 
macro FH2$B_ACC_MODE = 59,0,8,0 %;      !  least privileged access mode 
macro FH2$L_FILEOWNER = 60,0,32,0 %;    !  file owner UIC 
macro FH2$W_UICMEMBER = 60,0,16,0 %;    !  UIC member number 
macro FH2$W_UICGROUP = 62,0,16,0 %;     !  UIC group number 
macro FH2$W_FILEPROT = 64,0,16,0 %;     !  file protection 
macro FH2$W_BACKLINK = 66,0,0,0 %;
literal FH2$S_BACKLINK = 6;             !  back link pointer 
macro FH2$W_BK_FIDNUM = 66,0,16,0 %;    !  back link file number 
macro FH2$W_BK_FIDSEQ = 68,0,16,0 %;    !  back link file sequence number 
macro FH2$W_BK_FIDRVN = 70,0,16,0 %;    !  back link relative volume number 
macro FH2$B_BK_FIDRVN = 70,0,8,0 %;     !  alternate format back link RVN 
macro FH2$B_BK_FIDNMX = 71,0,8,0 %;     !  alternate format back link file number extension 
macro FH2$B_JOURNAL = 72,0,8,0 %;       !  journal control flags 
macro FH2$V_ONLY_RU = 72,0,1,0 %;       !  file is accessible only in recovery unit 
macro FH2$V_RUJNL = 72,1,1,0 %;         !  enable recovery unit journal 
macro FH2$V_BIJNL = 72,2,1,0 %;         !  enable before image journal 
macro FH2$V_AIJNL = 72,3,1,0 %;         !  enable after image journal 
macro FH2$V_ATJNL = 72,4,1,0 %;         !  enable audit trail journal 
macro FH2$V_NEVER_RU = 72,5,1,0 %;      !  file is never accessible in recovery unit
macro FH2$V_JOURNAL_FILE = 72,6,1,0 %;  !  this is a journal file
macro FH2$B_RU_ACTIVE = 73,0,8,0 %;     !  If non-zero, file has active recovery units
!  (value is recoverable facility id number)
!  1-99 reserved to DEC, 100-127 reserved for
!  CSS, 128-255 reserved for customers.
macro FH2$L_HIGHWATER = 76,0,32,0 %;    !  high-water mark in file
macro FH2$R_CLASS_PROT = 88,0,0,0 %;
literal FH2$S_CLASS_PROT = 20;          !  security classification mask
macro FH2$W_CHECKSUM = 510,0,16,0 %;    !  file header checksum 
 
!*** MODULE $FI2DEF ***
literal FI2$K_LENGTH = 120;             !  length of ident area 
literal FI2$C_LENGTH = 120;             !  length of ident area 
literal FI2$S_FI2DEF = 200;
macro FI2$T_FILENAME = 0,0,0,0 %;
literal FI2$S_FILENAME = 20;            !  file name, type, and version (ASCII) 
macro FI2$W_REVISION = 20,0,16,0 %;     !  revision number (binary) 
macro FI2$Q_CREDATE = 22,0,0,0 %;
literal FI2$S_CREDATE = 8;              !  creation date and time 
macro FI2$Q_REVDATE = 30,0,0,0 %;
literal FI2$S_REVDATE = 8;              !  revision date and time 
macro FI2$Q_EXPDATE = 38,0,0,0 %;
literal FI2$S_EXPDATE = 8;              !  expiration date and time 
macro FI2$Q_BAKDATE = 46,0,0,0 %;
literal FI2$S_BAKDATE = 8;              !  backup date and time 
macro FI2$T_FILENAMEXT = 54,0,0,0 %;
literal FI2$S_FILENAMEXT = 66;          !  extension file name area
macro FI2$T_USERLABEL = 120,0,0,0 %;
literal FI2$S_USERLABEL = 80;           !  optional user file label 
 
!*** MODULE $FM2DEF ***
!  retrieval pointer type codes 
literal FM2$C_PLACEMENT = 0;            !  00 = placement control data 
literal FM2$C_FORMAT1 = 1;              !  01 = format 1 
literal FM2$C_FORMAT2 = 2;              !  10 = format 2 
literal FM2$C_FORMAT3 = 3;              !  11 = format 3 
!  format of retrieval pointer
literal FM2$K_LENGTH0 = 2;              !  length of format 0 (placement) 
literal FM2$C_LENGTH0 = 2;              !  length of format 0 (placement) 
literal FM2$K_LENGTH1 = 4;              !  length of format 1 
literal FM2$C_LENGTH1 = 4;              !  length of format 1 
literal FM2$S_FM2DEF = 4;
macro FM2$W_WORD0 = 0,0,16,0 %;         !  first word, of many uses 
macro FM2$V_FORMAT = 0,14,2,0 %;
literal FM2$S_FORMAT = 2;               !  format type code 
macro FM2$V_EXACT = 0,0,1,0 %;          !  exact placement specified 
macro FM2$V_ONCYL = 0,1,1,0 %;          !  on cylinder allocation desired 
macro FM2$V_LBN = 0,12,1,0 %;           !  use LBN of next map pointer 
macro FM2$V_RVN = 0,13,1,0 %;           !  place on specified RVN 
macro FM2$V_HIGHLBN = 0,8,6,0 %;
literal FM2$S_HIGHLBN = 6;              !  high order LBN 
macro FM2$V_COUNT2 = 0,0,14,0 %;
literal FM2$S_COUNT2 = 14;              !  format 2 & 3 count field 
macro FM2$B_COUNT1 = 0,0,8,0 %;         !  format 1 count field 
macro FM2$W_LOWLBN = 2,0,16,0 %;        !  format 1 low order LBN 
literal FM2$K_LENGTH2 = 6;              !  length of format 2 
literal FM2$C_LENGTH2 = 6;              !  length of format 2 
literal FM2$S_FM2DEF1 = 6;
macro FM2$L_LBN2 = 2,0,32,0 %;          !  format 2 LBN (longword) 
literal FM2$K_LENGTH3 = 8;              !  length of format 3 
literal FM2$C_LENGTH3 = 8;              !  length of format 3 
literal FM2$S_FM2DEF2 = 8;
macro FM2$W_LOWCOUNT = 2,0,16,0 %;      !  format 3 low order count 
macro FM2$L_LBN3 = 4,0,32,0 %;          !  format 3 LBN (longword) 
 
!*** MODULE $FCHDEF ***
! +
! 
!  File characteristics bit definitions. These are identical to, and must
!  track, the bits in FILECHAR above, but are defined relative to the file
!  characteristics longword instead of relative to the file header.
! 
! -
literal FCH$M_VCC_STATE = 1792;
literal FCH$M_WASCONTIG = 1;
literal FCH$M_NOBACKUP = 2;
literal FCH$M_WRITEBACK = 4;
literal FCH$M_READCHECK = 8;
literal FCH$M_WRITCHECK = 16;
literal FCH$M_CONTIGB = 32;
literal FCH$M_LOCKED = 64;
literal FCH$M_CONTIG = 128;
literal FCH$M_BADACL = 2048;
literal FCH$M_SPOOL = 4096;
literal FCH$M_DIRECTORY = 8192;
literal FCH$M_BADBLOCK = 16384;
literal FCH$M_MARKDEL = 32768;
literal FCH$M_NOCHARGE = 65536;
literal FCH$M_ERASE = 131072;
literal FCH$M_SCRATCH = 1048576;
literal FCH$M_NOMOVE = 2097152;
literal FCH$S_FCHDEF = 4;
macro FCH$V_VCC_STATE = 0,8,3,0 %;
literal FCH$S_VCC_STATE = 3;            !  VCC state bits
! **********The following line is different from FH2 
macro FCH$V_WASCONTIG = 0,0,1,0 %;      !  file was (and should be) contiguous
macro FCH$V_NOBACKUP = 0,1,1,0 %;       !  file is not to be backed up 
macro FCH$V_WRITEBACK = 0,2,1,0 %;      !  file may be write-back cached 
macro FCH$V_READCHECK = 0,3,1,0 %;      !  verify all read operations 
macro FCH$V_WRITCHECK = 0,4,1,0 %;      !  verify all write operations 
macro FCH$V_CONTIGB = 0,5,1,0 %;        !  keep file as contiguous as possible 
macro FCH$V_LOCKED = 0,6,1,0 %;         !  file is deaccess locked 
macro FCH$V_CONTIG = 0,7,1,0 %;         !  file is contiguous 
macro FCH$V_BADACL = 0,11,1,0 %;        !  ACL is invalid 
macro FCH$V_SPOOL = 0,12,1,0 %;         !  intermediate spool file 
macro FCH$V_DIRECTORY = 0,13,1,0 %;     !  file is a directory 
macro FCH$V_BADBLOCK = 0,14,1,0 %;      !  file contains bad blocks 
macro FCH$V_MARKDEL = 0,15,1,0 %;       !  file is marked for delete 
macro FCH$V_NOCHARGE = 0,16,1,0 %;      !  file space is not to be charged 
macro FCH$V_ERASE = 0,17,1,0 %;         !  erase file contents before deletion
! **********The following line is different from FH2 
macro FCH$V_SCRATCH = 0,20,1,0 %;       !  Scratch Header used by movefile
macro FCH$V_NOMOVE = 0,21,1,0 %;        !  Disable movefile on this file
!  Note: The high 8 bits of this longword
!  are reserved for user and CSS use.
 
!*** MODULE $FJNDEF ***
! +
! 
!  File journal control bit definitions. These are identical to, and must
!  track, the bits in JOURNAL above, but are defined relative to the journal
!  control byte instead of relative to the file header.
! 
! -
literal FJN$M_ONLY_RU = 1;
literal FJN$M_RUJNL = 2;
literal FJN$M_BIJNL = 4;
literal FJN$M_AIJNL = 8;
literal FJN$M_ATJNL = 16;
literal FJN$M_NEVER_RU = 32;
literal FJN$M_JOURNAL_FILE = 64;
literal FJN$S_FJNDEF = 1;
macro FJN$V_ONLY_RU = 0,0,1,0 %;        !  file is accessible only in recovery unit 
macro FJN$V_RUJNL = 0,1,1,0 %;          !  enable recovery unit journal 
macro FJN$V_BIJNL = 0,2,1,0 %;          !  enable before image journal 
macro FJN$V_AIJNL = 0,3,1,0 %;          !  enable after image journal 
macro FJN$V_ATJNL = 0,4,1,0 %;          !  enable audit trail journal 
macro FJN$V_NEVER_RU = 0,5,1,0 %;       !  file is never accessible in recovery unit
macro FJN$V_JOURNAL_FILE = 0,6,1,0 %;   !  this is a journal file
 
!*** MODULE $FATDEF ***
! +
! 
!  Record attributes area as used by FCS and RMS.
! 
! -
literal FAT$C_UNDEFINED = 0;            !  undefined record type 
literal FAT$C_FIXED = 1;                !  fixed record type 
literal FAT$C_VARIABLE = 2;             !  variable length 
literal FAT$C_VFC = 3;                  !  variable + fixed control 
literal FAT$C_STREAM = 4;               !  RMS-11 (DEC traditional) stream format 
literal FAT$C_STREAMLF = 5;             !  LF-terminated stream format 
literal FAT$C_STREAMCR = 6;             !  CR-terminated stream format 
literal FAT$C_SEQUENTIAL = 0;           !  sequential organization 
literal FAT$C_RELATIVE = 1;             !  relative organization 
literal FAT$C_INDEXED = 2;              !  indexed organization 
literal FAT$C_DIRECT = 3;               !  direct organization 
literal FAT$M_FORTRANCC = 1;
literal FAT$M_IMPLIEDCC = 2;
literal FAT$M_PRINTCC = 4;
literal FAT$M_NOSPAN = 8;
literal FAT$K_LENGTH = 32;
literal FAT$C_LENGTH = 32;
literal FAT$S_FATDEF = 32;
macro FAT$B_RTYPE = 0,0,8,0 %;          !  record type 
macro FAT$V_RTYPE = 0,0,4,0 %;
literal FAT$S_RTYPE = 4;                !  record type subfield 
macro FAT$V_FILEORG = 0,4,4,0 %;
literal FAT$S_FILEORG = 4;              !  file organization 
macro FAT$B_RATTRIB = 1,0,8,0 %;        !  record attributes 
macro FAT$V_FORTRANCC = 1,0,1,0 %;      !  Fortran carriage control 
macro FAT$V_IMPLIEDCC = 1,1,1,0 %;      !  implied carriage control 
macro FAT$V_PRINTCC = 1,2,1,0 %;        !  print file carriage control 
macro FAT$V_NOSPAN = 1,3,1,0 %;         !  no spanned records 
macro FAT$W_RSIZE = 2,0,16,0 %;         !  record size in bytes 
macro FAT$L_HIBLK = 4,0,32,0 %;         !  highest allocated VBN 
macro FAT$W_HIBLKH = 4,0,16,0 %;        !  high order word 
macro FAT$W_HIBLKL = 6,0,16,0 %;        !  low order word 
macro FAT$L_EFBLK = 8,0,32,0 %;         !  end of file VBN 
macro FAT$W_EFBLKH = 8,0,16,0 %;        !  high order word 
macro FAT$W_EFBLKL = 10,0,16,0 %;       !  low order word 
macro FAT$W_FFBYTE = 12,0,16,0 %;       !  first free byte in EFBLK 
macro FAT$B_BKTSIZE = 14,0,8,0 %;       !  bucket size in blocks 
macro FAT$B_VFCSIZE = 15,0,8,0 %;       !  size in bytes of fixed length control for VFC records 
macro FAT$W_MAXREC = 16,0,16,0 %;       !  maximum record size in bytes 
macro FAT$W_DEFEXT = 18,0,16,0 %;       !  default extend quantity 
macro FAT$W_GBC = 20,0,16,0 %;          !  global buffer count 
macro FAT$W_VERSIONS = 30,0,16,0 %;     !  default version limit for directory file 
 
!*** MODULE $HM1DEF ***
! +
! 
!  Home block definitions for Files-11 Structure Level 1
! 
! -
literal HM1$C_LEVEL1 = 257;             !  401 octal = structure level 1 
literal HM1$C_LEVEL2 = 258;             !  402 octal = structure level 1, version 2 
literal HM1$S_HM1DEF = 512;
macro HM1$W_IBMAPSIZE = 0,0,16,0 %;     !  index file bitmap size, blocks 
macro HM1$L_IBMAPLBN = 2,0,32,0 %;      !  index file bitmap starting LBN 
macro HM1$W_MAXFILES = 6,0,16,0 %;      !  maximum ! files on volume 
macro HM1$W_CLUSTER = 8,0,16,0 %;       !  storage bitmap cluster factor 
macro HM1$W_DEVTYPE = 10,0,16,0 %;      !  disk device type 
macro HM1$W_STRUCLEV = 12,0,16,0 %;     !  volume structure level 
macro HM1$T_VOLNAME = 14,0,0,0 %;
literal HM1$S_VOLNAME = 12;             !  volume name (ASCII) 
macro HM1$W_VOLOWNER = 30,0,16,0 %;     !  volume owner UIC 
macro HM1$W_PROTECT = 32,0,16,0 %;      !  volume protection 
macro HM1$V_SYSPRO = 32,0,4,0 %;
literal HM1$S_SYSPRO = 4;               !  system protection 
macro HM1$V_OWNPRO = 32,4,4,0 %;
literal HM1$S_OWNPRO = 4;               !  owner protection 
macro HM1$V_GROUPPRO = 32,8,4,0 %;
literal HM1$S_GROUPPRO = 4;             !  group protection 
macro HM1$V_WORLDPRO = 32,12,4,0 %;
literal HM1$S_WORLDPRO = 4;             !  world protection 
macro HM1$W_VOLCHAR = 34,0,16,0 %;      !  volume characteristics 
macro HM1$W_FILEPROT = 36,0,16,0 %;     !  default file protection 
macro HM1$B_WINDOW = 44,0,8,0 %;        !  default window size 
macro HM1$B_EXTEND = 45,0,8,0 %;        !  default file extend 
macro HM1$B_LRU_LIM = 46,0,8,0 %;       !  default LRU limit 
macro HM1$W_CHECKSUM1 = 58,0,16,0 %;    !  first checksum 
macro HM1$T_CREDATE = 60,0,0,0 %;
literal HM1$S_CREDATE = 14;             !  volume creation date 
macro HM1$L_SERIALNUM = 456,0,32,0 %;   !  pack serial number 
macro HM1$T_VOLNAME2 = 472,0,0,0 %;
literal HM1$S_VOLNAME2 = 12;            !  2nd copy of volume name 
macro HM1$T_OWNERNAME = 484,0,0,0 %;
literal HM1$S_OWNERNAME = 12;           !  volume owner name 
macro HM1$T_FORMAT = 496,0,0,0 %;
literal HM1$S_FORMAT = 12;              !  volume format type 
macro HM1$W_CHECKSUM2 = 510,0,16,0 %;   !  second checksum 
 
!*** MODULE $HM2DEF ***
! +
! 
!  Home block definitions for Files-11 Structure Level 2
! 
! -
literal HM2$C_LEVEL1 = 257;             !  401 octal = structure level 1 
literal HM2$C_LEVEL2 = 512;             !  1000 octal = structure level 2 
literal HM2$M_READCHECK = 1;
literal HM2$M_WRITCHECK = 2;
literal HM2$M_ERASE = 4;
literal HM2$M_NOHIGHWATER = 8;
literal HM2$M_CLASS_PROT = 16;
literal HM2$S_HM2DEF = 512;
macro HM2$L_HOMELBN = 0,0,32,0 %;       !  LBN of home (i.e., this) block 
macro HM2$L_ALHOMELBN = 4,0,32,0 %;     !  LBN of alternate home block 
macro HM2$L_ALTIDXLBN = 8,0,32,0 %;     !  LBN of alternate index file header 
macro HM2$W_STRUCLEV = 12,0,16,0 %;     !  volume structure level 
macro HM2$B_STRUCVER = 12,0,8,0 %;      !  structure version number 
macro HM2$B_STRUCLEV = 13,0,8,0 %;      !  main structure level 
macro HM2$W_CLUSTER = 14,0,16,0 %;      !  storage bitmap cluster factor 
macro HM2$W_HOMEVBN = 16,0,16,0 %;      !  VBN of home (i.e., this) block 
macro HM2$W_ALHOMEVBN = 18,0,16,0 %;    !  VBN of alternate home block 
macro HM2$W_ALTIDXVBN = 20,0,16,0 %;    !  VBN of alternate index file header 
macro HM2$W_IBMAPVBN = 22,0,16,0 %;     !  VBN of index file bitmap 
macro HM2$L_IBMAPLBN = 24,0,32,0 %;     !  LBN of index file bitmap 
macro HM2$L_MAXFILES = 28,0,32,0 %;     !  maximum ! files on volume 
macro HM2$W_IBMAPSIZE = 32,0,16,0 %;    !  index file bitmap size, blocks 
macro HM2$W_RESFILES = 34,0,16,0 %;     !  ! reserved files on volume 
macro HM2$W_DEVTYPE = 36,0,16,0 %;      !  disk device type 
macro HM2$W_RVN = 38,0,16,0 %;          !  relative volume number of this volume 
macro HM2$W_SETCOUNT = 40,0,16,0 %;     !  count of volumes in set 
macro HM2$W_VOLCHAR = 42,0,16,0 %;      !  volume characteristics 
macro HM2$V_READCHECK = 42,0,1,0 %;     !  verify all read operations 
macro HM2$V_WRITCHECK = 42,1,1,0 %;     !  verify all write operations 
macro HM2$V_ERASE = 42,2,1,0 %;         !  erase all files on delete 
macro HM2$V_NOHIGHWATER = 42,3,1,0 %;   !  turn off high-water marking
macro HM2$V_CLASS_PROT = 42,4,1,0 %;    !  enable classification checks on the volume
macro HM2$L_VOLOWNER = 44,0,32,0 %;     !  volume owner UIC 
macro HM2$L_SEC_MASK = 48,0,32,0 %;     !  volume security mask 
macro HM2$W_PROTECT = 52,0,16,0 %;      !  volume protection 
macro HM2$W_FILEPROT = 54,0,16,0 %;     !  default file protection 
macro HM2$W_RECPROT = 56,0,16,0 %;      !  default file record protection 
macro HM2$W_CHECKSUM1 = 58,0,16,0 %;    !  first checksum 
macro HM2$Q_CREDATE = 60,0,0,0 %;
literal HM2$S_CREDATE = 8;              !  volume creation date 
macro HM2$B_WINDOW = 68,0,8,0 %;        !  default window size 
macro HM2$B_LRU_LIM = 69,0,8,0 %;       !  default LRU limit 
macro HM2$W_EXTEND = 70,0,16,0 %;       !  default file extend 
macro HM2$Q_RETAINMIN = 72,0,0,0 %;
literal HM2$S_RETAINMIN = 8;            !  minimum file retention period 
macro HM2$Q_RETAINMAX = 80,0,0,0 %;
literal HM2$S_RETAINMAX = 8;            !  maximum file retention period 
macro HM2$Q_REVDATE = 88,0,0,0 %;
literal HM2$S_REVDATE = 8;              !  volume revision date
macro HM2$R_MIN_CLASS = 96,0,0,0 %;
literal HM2$S_MIN_CLASS = 20;           !  volume minimum security class
macro HM2$R_MAX_CLASS = 116,0,0,0 %;
literal HM2$S_MAX_CLASS = 20;           !  volume maximum security class
macro HM2$W_FILETAB_FID = 136,0,0,0 %;
literal HM2$S_FILETAB_FID = 6;          !  file lookup table FID
macro HM2$W_LOWSTRUCLEV = 142,0,16,0 %; !  lowest struclev on volume
macro HM2$B_LOWSTRUCVER = 142,0,8,0 %;  !  structure version number 
macro HM2$B_LOWSTRUCLEV = 143,0,8,0 %;  !  main structure level 
macro HM2$W_HIGHSTRUCLEV = 144,0,16,0 %; !  highest struclev on volume
macro HM2$B_HIGHSTRUCVER = 144,0,8,0 %; !  structure version number 
macro HM2$B_HIGHSTRUCLEV = 145,0,8,0 %; !  main structure level 
macro HM2$L_SERIALNUM = 456,0,32,0 %;   !  pack serial number 
macro HM2$T_STRUCNAME = 460,0,0,0 %;
literal HM2$S_STRUCNAME = 12;           !  structure (volume set name) 
macro HM2$T_VOLNAME = 472,0,0,0 %;
literal HM2$S_VOLNAME = 12;             !  volume name 
macro HM2$T_OWNERNAME = 484,0,0,0 %;
literal HM2$S_OWNERNAME = 12;           !  volume owner name 
macro HM2$T_FORMAT = 496,0,0,0 %;
literal HM2$S_FORMAT = 12;              !  volume format type 
macro HM2$W_CHECKSUM2 = 510,0,16,0 %;   !  second checksum 
 
!*** MODULE $DIRDEF ***
! +
! 
!  Directory entry structure for Files-11 Structure Level 2
! 
! -
literal DIR$C_FID = 0;                  !  normal file ID 
literal DIR$C_LINKNAME = 1;             !  symbolic name 
literal DIR$K_LENGTH = 6;               !  length of directory entry overhead 
literal DIR$C_LENGTH = 6;               !  length of directory entry overhead 
literal DIR$S_NAME = 80;                !  maximum length of name string 
literal DIR$S_DIRDEF = 6;
macro DIR$W_SIZE = 0,0,16,0 %;          !  size of directory record in bytes 
macro DIR$W_VERLIMIT = 2,0,16,0 %;      !  maximum number of versions 
macro DIR$B_FLAGS = 4,0,8,0 %;          !  status flags 
macro DIR$V_TYPE = 4,0,3,0 %;
literal DIR$S_TYPE = 3;                 !  directory entry type 
macro DIR$V_NEXTREC = 4,6,1,0 %;        !  another record of same name & type follows 
macro DIR$V_PREVREC = 4,7,1,0 %;        !  another record of same name & type precedes 
!  directory entry type codes 
macro DIR$B_NAMECOUNT = 5,0,8,0 %;      !  byte count of name string 
macro DIR$T_NAME = 6,0,0,0 %;           !  name string 
!  the version numbers and file ID's follow the
!  variable length name area in the form of a
!  blockvector. Each entry is as follows:
literal DIR$K_VERSION = 8;              !  size of each version entry 
literal DIR$C_VERSION = 8;              !  size of each version entry 
literal DIR$S_DIRDEF1 = 8;
macro DIR$W_VERSION = 0,0,16,1 %;       !  version number 
macro DIR$W_FID = 2,0,0,0 %;
literal DIR$S_FID = 6;                  !  file ID 
macro DIR$W_FID_NUM = 2,0,16,0 %;       !  file number 
macro DIR$W_FID_SEQ = 4,0,16,0 %;       !  file sequence number 
macro DIR$W_FID_RVN = 6,0,16,0 %;       !  relative volume number 
macro DIR$B_FID_RVN = 6,0,8,0 %;        !  alternate format RVN 
macro DIR$B_FID_NMX = 7,0,8,0 %;        !  alternate format file number extension 
literal DIR$S_DIRDEF2 = 1;
macro DIR$T_LINKNAME = 0,0,8,0 %;       !  symbolic link name (counted string) 
 
!*** MODULE $SCBDEF ***
! +
! 
!  Format of storage control block, Files-11 Structure Level 2
! 
! -
literal SCB$C_LEVEL2 = 512;             !  1000 octal = structure level 2 
literal SCB$M_MAPDIRTY = 1;
literal SCB$M_MAPALLOC = 2;
literal SCB$M_FILALLOC = 4;
literal SCB$M_QUODIRTY = 8;
literal SCB$M_HDRWRITE = 16;
literal SCB$M_CORRUPT = 32;
literal SCB$M_MAPDIRTY2 = 1;
literal SCB$M_MAPALLOC2 = 2;
literal SCB$M_FILALLOC2 = 4;
literal SCB$M_QUODIRTY2 = 8;
literal SCB$M_HDRWRITE2 = 16;
literal SCB$M_CORRUPT2 = 32;
literal SCB$M_NORMAL = 1;
literal SCB$M_NEW = 2;
literal SCB$M_REBLDNG = 4;
literal SCB$M_VERIFY = 8;
literal SCB$M_MVBEGUN = 16;
literal SCB$M_COPYING = 32;
literal SCB$M_MERGING = 64;
literal SCB$M_MINIMRG = 128;
literal SCB$M_CPY_RESET = 256;
literal SCB$M_BOOTING = 512;
literal SCB$M_FAILED = 32768;
literal SCB$M_MBR_FCPY = 1;
literal SCB$M_MBR_MERGE = 2;
literal SCB$M_MBR_CIP = 4;
literal SCB$M_MBR_MASTER = 8;
literal SCB$M_MBR_ERROR = 16;
literal SCB$M_MBR_SRC = 32;
literal SCB$M_MBR_VALID = 128;
literal SCB$K_LENGTH = 512;             ! Length of Structure
literal SCB$C_LENGTH = 512;             ! Length of Structure
literal SCB$S_SCBDEF = 512;
macro SCB$W_STRUCLEV = 0,0,16,0 %;      !  file structure level 
macro SCB$B_STRUCVER = 0,0,8,0 %;       !  file structure version 
macro SCB$B_STRUCLEV = 1,0,8,0 %;       !  principal file structure level 
macro SCB$W_CLUSTER = 2,0,16,0 %;       !  storage map cluster factor 
macro SCB$L_VOLSIZE = 4,0,32,0 %;       !  volume size in logical blocks 
macro SCB$L_BLKSIZE = 8,0,32,0 %;       !  number of physical blocks per logical block 
macro SCB$L_SECTORS = 12,0,32,0 %;      !  number of sectors per track 
macro SCB$L_TRACKS = 16,0,32,0 %;       !  number of tracks per cylinder 
macro SCB$L_CYLINDER = 20,0,32,0 %;     !  number of cylinders 
macro SCB$L_STATUS = 24,0,32,0 %;       !  volume status flags 
macro SCB$V_MAPDIRTY = 24,0,1,0 %;      !  storage map is dirty (partially updated) 
macro SCB$V_MAPALLOC = 24,1,1,0 %;      !  storage map is preallocated (lost blocks) 
macro SCB$V_FILALLOC = 24,2,1,0 %;      !  file numbers are preallocated (lost header slots) 
macro SCB$V_QUODIRTY = 24,3,1,0 %;      !  quota file is dirty (partially updated) 
macro SCB$V_HDRWRITE = 24,4,1,0 %;      !  file headers are write back cached 
macro SCB$V_CORRUPT = 24,5,1,0 %;       !  file structure is corrupt
macro SCB$L_STATUS2 = 28,0,32,0 %;      !  backup status - bits must match those above 
macro SCB$V_MAPDIRTY2 = 28,0,1,0 %;     !  storage map is dirty (partially updated) 
macro SCB$V_MAPALLOC2 = 28,1,1,0 %;     !  storage map is preallocated (lost blocks) 
macro SCB$V_FILALLOC2 = 28,2,1,0 %;     !  file numbers are preallocated (lost header slots) 
macro SCB$V_QUODIRTY2 = 28,3,1,0 %;     !  quota file is dirty (partially updated) 
macro SCB$V_HDRWRITE2 = 28,4,1,0 %;     !  file headers are write back cached 
macro SCB$V_CORRUPT2 = 28,5,1,0 %;      !  file structure is corrupt
macro SCB$W_WRITECNT = 32,0,16,0 %;     !  count of write access mounters.
macro SCB$T_VOLOCKNAME = 34,0,0,0 %;
literal SCB$S_VOLOCKNAME = 12;          !  name used for file system serialization on volume.
macro SCB$Q_MOUNTTIME = 46,0,0,0 %;
literal SCB$S_MOUNTTIME = 8;            !  time of last initial mount.
macro SCB$W_BACKREV = 54,0,16,0 %;      !  BACKUP revision number.
macro SCB$Q_GENERNUM = 56,0,0,0 %;
literal SCB$S_GENERNUM = 8;             !  shadow set revision number.
macro SCB$Q_UNIT_ID = 64,0,0,0 %;
literal SCB$S_UNIT_ID = 8;              !  Virtual Unit specifier
macro SCB$W_SHADOW_STATUS = 72,0,16,0 %; !  Volume status:
macro SCB$V_NORMAL = 72,0,1,0 %;        !  Shadow set populated and online
macro SCB$V_NEW = 72,1,1,0 %;           !  Newly created, no members yet
macro SCB$V_REBLDNG = 72,2,1,0 %;       !  rebuilding shadow set
macro SCB$V_VERIFY = 72,3,1,0 %;        !  This SS needs verification
macro SCB$V_MVBEGUN = 72,4,1,0 %;       !  Mount verification initiated
macro SCB$V_COPYING = 72,5,1,0 %;       !  Full copy in progreess
macro SCB$V_MERGING = 72,6,1,0 %;       !  Merge copy in progress
macro SCB$V_MINIMRG = 72,7,1,0 %;       !  Mini-merge in progress
macro SCB$V_CPY_RESET = 72,8,1,0 %;     !  Copy mode is reset.
macro SCB$V_BOOTING = 72,9,1,0 %;       !  Shadow set in booting state
macro SCB$V_FAILED = 72,15,1,0 %;       !  Shadow set not populated
macro SCB$B_MEMBER_STATUS = 74,0,8,0 %; !  Member status bytes
macro SCB$V_MBR_FCPY = 74,0,1,0 %;      !  Member involved in copy
macro SCB$V_MBR_MERGE = 74,1,1,0 %;     !  Member being merged
macro SCB$V_MBR_CIP = 74,2,1,0 %;       !  Copy (or merge) in progress
macro SCB$V_MBR_MASTER = 74,3,1,0 %;    !  Member with guaranteed correct
!   SCB. Same member as MEMBERSHIP_LOCK
macro SCB$V_MBR_ERROR = 74,4,1,0 %;     !  Error processing in progress
macro SCB$V_MBR_SRC = 74,5,1,0 %;       !  member can be used for source
macro SCB$V_MBR_VALID = 74,7,1,0 %;     !  Status information is valid
macro SCB$Q_MEMBER_IDS = 80,0,0,0 %;
literal SCB$S_MEMBER_IDS = 24;          !  Unit ID for member
macro SCB$L_SCB_LBN = 104,0,32,0 %;     !  Unit Control Block for VU
macro SCB$B_DEVICES = 108,0,8,0 %;      !  Number of devices in SS
macro SCB$B_MEMBERS = 109,0,8,0 %;      !  Number of full members
macro SCB$B_MAST_INDX = 110,0,8,0 %;    !  Array index to master UCB
macro SCB$B_MRG_TARGETS = 111,0,8,0 %;  !  Merge Copy Targets
macro SCB$B_FC_TARGETS = 112,0,8,0 %;   !  Full Copy Targets
macro SCB$W_CHECKSUM = 510,0,16,0 %;    !  block checksum 
 
!*** MODULE $BBMDEF ***
! +
! 
!  Bad block map (generated by bad block scan program)
! 
! -
literal BBM$K_POINTERS = 4;             !  start of retrieval pointers 
literal BBM$C_POINTERS = 4;             !  start of retrieval pointers 
literal BBM$S_BBMDEF = 512;
macro BBM$B_COUNTSIZE = 0,0,8,0 %;      !  retrieval pointer count field size 
macro BBM$B_LBNSIZE = 1,0,8,0 %;        !  retrieval pointer LBN field size 
macro BBM$B_INUSE = 2,0,8,0 %;          !  number of retrieval words in use 
macro BBM$B_AVAIL = 3,0,8,0 %;          !  number of retrieval words available 
macro BBM$W_CHECKSUM = 510,0,16,0 %;    !  block checksum 
!  retrieval pointer format
literal BBM$S_BBMDEF1 = 4;
macro BBM$B_HIGHLBN = 0,0,8,0 %;        !  high order LBN 
macro BBM$B_COUNT = 1,0,8,0 %;          !  block count 
macro BBM$W_LOWLBN = 2,0,16,0 %;        !  low order LBN 
literal BBM$S_BBMDEF2 = 5;
macro BBM$B_PREVHLBN = -4,0,8,0 %;
macro BBM$B_PREVCOUNT = -3,0,8,0 %;
macro BBM$W_PREVLLBN = -2,0,16,0 %;     !  previous retrieval pointer 
 
!*** MODULE $BBDDEF ***
! +
! 
!  Bad block descriptor (generated by formatters for RK06, RM03, et al)
! 
! -
literal BBD$K_DESCRIPT = 8;             !  start of bad block descriptors 
literal BBD$C_DESCRIPT = 8;             !  start of bad block descriptors 
literal BBD$S_BBDDEF = 512;
macro BBD$L_SERIAL = 0,0,32,0 %;        !  pack serial number 
macro BBD$W_RESERVED = 4,0,16,0 %;      !  reserved area (MBZ) 
macro BBD$W_FLAGS = 6,0,16,0 %;         !  pack status flags (zero for normal use) 
macro BBD$L_LASTWORD = 508,0,32,0 %;    !  last longword of block 
literal BBD$K_ENTRY = 4;
literal BBD$C_ENTRY = 4;
literal BBD$S_BBDDEF1 = 4;
macro BBD$L_BADBLOCK = 0,0,32,0 %;      !  individual bad block entry 
macro BBD$V_CYLINDER = 0,0,15,0 %;
literal BBD$S_CYLINDER = 15;            !  cylinder number of bad block 
macro BBD$V_SECTOR = 0,16,8,0 %;
literal BBD$S_SECTOR = 8;               !  sector number of bad block 
macro BBD$V_TRACK = 0,24,7,0 %;
literal BBD$S_TRACK = 7;                !  track number of bad block 
 
!*** MODULE $VSLDEF ***
! +
! 
!  Structure of a volume set list file entry. Record 1 contains the volume
!  set name. Record n+1 contains the volume label of RVN n in the volume set.
! 
! -
literal VSL$K_LENGTH = 64;
literal VSL$C_LENGTH = 64;
literal VSL$S_VSLDEF = 64;
macro VSL$T_NAME = 0,0,0,0 %;
literal VSL$S_NAME = 12;                !  volume name 
 
!*** MODULE $PBBDEF ***
! +
! 
!  Pending bad block file record format. Each record describes a disk block
!  on which an error has occurred which has not been turned over to the bad
!  block file.
! 
! -
literal PBB$M_READERR = 1;
literal PBB$M_WRITERR = 2;
literal PBB$K_LENGTH = 16;              !  length of entry 
literal PBB$C_LENGTH = 16;              !  length of entry 
literal PBB$S_PBBDEF = 16;
macro PBB$W_FID = 0,0,0,0 %;
literal PBB$S_FID = 6;                  !  File ID of containing file 
macro PBB$B_FLAGS = 6,0,8,0 %;          !  status flags 
macro PBB$V_READERR = 6,0,1,0 %;        !  read error occurred 
macro PBB$V_WRITERR = 6,1,1,0 %;        !  write error occurred 
macro PBB$B_COUNT = 7,0,8,0 %;          !  error count 
macro PBB$L_VBN = 8,0,32,0 %;           !  virtual block in file 
macro PBB$L_LBN = 12,0,32,0 %;          !  logical block number 
 
!*** MODULE $DQFDEF ***
! +
! 
!  Structure of disk quota file record. Each record contains the authorization
!  and usage of a particular UIC for this volume set.
! 
! -
literal DQF$M_ACTIVE = 1;
literal DQF$K_LENGTH = 32;
literal DQF$C_LENGTH = 32;
literal DQF$S_DQFDEF = 32;
macro DQF$L_FLAGS = 0,0,32,0 %;         !  flags longword, containing... 
macro DQF$V_ACTIVE = 0,0,1,0 %;         !  record contains an active entry 
macro DQF$L_UIC = 4,0,32,0 %;           !  UIC of this record 
macro DQF$L_USAGE = 8,0,32,0 %;         !  number of blocks in use 
macro DQF$L_PERMQUOTA = 12,0,32,0 %;    !  permanent disk quota 
macro DQF$L_OVERDRAFT = 16,0,32,0 %;    !  overdraft limit 
! 
! ****************************************************************************
! *                                                                          *
! *  Copyright (c) 1992                                                      *
! *  by DIGITAL Equipment Corporation, Maynard, Mass.                        *
! *                                                                          *
! *  This software is furnished under a license and may be used and  copied  *
! *  only  in  accordance  with  the  terms  of  such  license and with the  *
! *  inclusion of the above copyright notice.  This software or  any  other  *
! *  copies  thereof may not be provided or otherwise made available to any  *
! *  other person.  No title to and ownership of  the  software  is  hereby  *
! *  transferred.                                                            *
! *                                                                          *
! *  The information in this software is subject to change  without  notice  *
! *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment  *
! *  Corporation.                                                            *
! *                                                                          *
! *  DIGITAL assumes no responsibility for the use or  reliability  of  its  *
! *  software on equipment which is not supplied by DIGITAL.                 *
! *                                                                          *
! ****************************************************************************
! ********************************************************************************************************************************
!  Created  7-JUL-1992 20:06:37 by VAX SDL T3.2-8      Source: 30-JAN-1992 13:49:10 _$22$DIA9:[SHRLIB]SYS_OFFSETS.SDL;1 
! ********************************************************************************************************************************
 
!*** MODULE SYSVECTOR IDENT X-4 ***
! 
!  Define offsets to System Service Areas
! 
!  offset to 1st system vector area
!  offset to 2nd system vector area
!  offset to 4th system vector area
!  offset to 4th system vector area
!  offset to rms service vector area
!  offset to ruf service vector area
!  offset to special area in the
!  system service vector area.
!  spare vectors
!  offset to global symbol area
! 
!  Global Symbol offsets
! 
literal BASE$SYS$K_GL_ASTRET = 784;     !  Return address from AST dispatching
literal BASE$SYS$K_GL_COMMON = 788;     !  Address of common core descriptor
! 
!  	1st area of system service vector offsets
! 
! 		*** WARNING ***
! 	There should be no new vectors added to the end
! 	of this area, because there would be an overlap
! 	into the common wait code area.
! 
literal BASE$EXE$K_QIOW = 0;            !  QIO and wait
literal BASE$EXE$K_QIOW_2 = 8;          !  ******* DUMMY *******
literal BASE$EXE$K_QIOW_3 = 16;         !  ******* DUMMY *******
literal BASE$EXE$K_CLI = 24;            !  Command interpreter dispatch
literal BASE$EXE$K_ADJSTK = 32;         !  Adjust outer mode stack pointer
literal BASE$EXE$K_ADJWSL = 40;         !  Adjust working set limit
literal BASE$EXE$K_ALCDNP = 48;         !  Allocate diagnostic page
literal BASE$EXE$K_ALLOC = 56;          !  Allocate device
literal BASE$EXE$K_ASCEFC = 64;         !  Associate common event flag cluster
literal BASE$EXE$K_ASCTIM = 72;         !  Convert to ASCII time
literal BASE$EXE$K_ASSIGN = 80;         !  Assign I/O channel
literal BASE$EXE$K_BINTIM = 88;         !  Convert to binary time
literal BASE$EXE$K_CANCEL = 96;         !  Cancel I/O on channel
literal BASE$EXE$K_CANTIM = 104;        !  Cancel timer request
literal BASE$EXE$K_CANWAK = 112;        !  Cancel wake up requests
literal BASE$EXE$K_CRMPSC = 120;        !  Create and map section
literal BASE$EXE$K_CLRPAR = 128;        !  Clear hard parity error
literal BASE$EXE$K_CMEXEC = 136;        !  Change mode to executive
literal BASE$EXE$K_CMKRNL = 144;        !  Change mode to kernel
literal BASE$EXE$K_CLREF = 152;         !  Clear event flag
literal BASE$EXE$K_CNTREG = 160;        !  Contract region
literal BASE$EXE$K_GETPTI = 168;        !  Get page table information
literal BASE$EXE$K_CRELOG = 176;        !  Create logical name
literal BASE$EXE$K_CREMBX = 184;        !  Create mailbox
literal BASE$EXE$K_CREPRC = 192;        !  Create process
literal BASE$EXE$K_CRETVA = 200;        !  Create virtual address
literal BASE$EXE$K_DACEFC = 208;        !  Disassociate event flag cluster
literal BASE$EXE$K_DALLOC = 216;        !  Deallocate device
literal BASE$EXE$K_DASSGN = 224;        !  Deassign I/O channel
literal BASE$EXE$K_DCLAST = 232;        !  Declare AST system service
literal BASE$EXE$K_DCLEXH = 240;        !  Declare exit handler
literal BASE$EXE$K_DELLOG = 248;        !  Delete logical name
literal BASE$EXE$K_DELMBX = 256;        !  Delete mailbox
literal BASE$EXE$K_DELPRC = 264;        !  Delete process
literal BASE$EXE$K_DELTVA = 272;        !  Delete virtual address
literal BASE$EXE$K_DGBLSC = 280;        !  Delete global section
literal BASE$EXE$K_DLCDNP = 288;        !  Deallocate diagnostic page
literal BASE$EXE$K_DLCEFC = 296;        !  Delete common event cluster
literal BASE$EXE$K_UPDSEC = 304;        !  Update section file
literal BASE$EXE$K_SNDERR = 312;        !  Send message to error logger
literal BASE$EXE$K_EXIT = 320;          !  Image exit
literal BASE$EXE$K_EXPREG = 328;        !  Expand program region
literal BASE$EXE$K_FAO = 336;           !  Format ASCII output
literal BASE$EXE$K_FAOL = 344;          !  Format ASCII output with value list
literal BASE$EXE$K_FORCEX = 352;        !  Force exit
literal BASE$EXE$K_IMGSTA = 360;        !  Image startup
literal BASE$EXE$K_SNDJBC = 368;        !  Send message to job controller
literal BASE$EXE$K_GETTIM = 376;        !  Get system time
literal BASE$EXE$K_UPDSECW = 384;       !  Update section and wait
literal BASE$EXE$K_HIBER = 392;         !  Hibernate
literal BASE$EXE$K_IMGACT = 400;        !  Image activation
literal BASE$EXE$K_LCKPAG = 408;        !  Lock page in memory
literal BASE$EXE$K_LKWSET = 416;        !  Lock pages in working set
literal BASE$EXE$K_MGBLSC = 424;        !  Map global section
literal BASE$EXE$K_PURGWS = 432;        !  Purge working set
literal BASE$EXE$K_NUMTIM = 440;        !  Convert time to numeric
literal BASE$EXE$K_SNDOPR = 448;        !  Send message to operator
literal BASE$EXE$K_QIO = 456;           !  Queue I/O request
literal BASE$EXE$K_READEF = 464;        !  Read event flag
literal BASE$EXE$K_RESUME = 472;        !  Resume process
literal BASE$EXE$K_RUNDWN = 480;        !  Rundown
literal BASE$EXE$K_SNDSMB = 488;        !  Send message to symbiont manager
literal BASE$EXE$K_SCHDWK = 496;        !  Schedule wakeup
literal BASE$EXE$K_SETAST = 504;        !  Set AST enable service
literal BASE$EXE$K_SETEF = 512;         !  Set event flag
literal BASE$EXE$K_SETEXV = 520;        !  Set exception vector
literal BASE$EXE$K_SETPRN = 528;        !  Set process name
literal BASE$EXE$K_SETPRA = 536;        !  Set power recovery AST
literal BASE$EXE$K_SETIMR = 544;        !  Set timer
literal BASE$EXE$K_SETPRI = 552;        !  Set process priority
literal BASE$EXE$K_SETPRT = 560;        !  Set page protection
literal BASE$EXE$K_SETRWM = 568;        !  Set resource wait mode
literal BASE$EXE$K_SETSFM = 576;        !  Set system service failure mode
literal BASE$EXE$K_SETSWM = 584;        !  Set process swap mode
literal BASE$EXE$K_SUSPND = 592;        !  Suspend process
literal BASE$EXE$K_TRNLOG = 600;        !  Translate logical name
literal BASE$EXE$K_ULKPAG = 608;        !  Unlock page from memory
literal BASE$EXE$K_ULWSET = 616;        !  Unlock pages from working set
literal BASE$EXE$K_UNWIND = 624;        !  Unwind procedure call stack
literal BASE$EXE$K_WAITFR = 632;        !  Wait for event flag
literal BASE$EXE$K_WAKE = 640;          !  Wake process
literal BASE$EXE$K_WFLAND = 648;        !  Wait for logical AND of event flags
literal BASE$EXE$K_WFLOR = 656;         !  Wait for logical OR of event flags
literal BASE$EXE$K_BRDCST = 664;        !  Broadcast to terminals
literal BASE$EXE$K_DCLCMH = 672;        !  Declare change mode handler
literal BASE$EXE$K_SETPFM = 680;        !  Set page fault monitoring
literal BASE$EXE$K_GETMSG = 688;        !  Get message
literal BASE$EXE$K_DERLMB = 696;        !  Declare error log mailbox
literal BASE$EXE$K_CANEXH = 704;        !  Cancel exit handler
literal BASE$EXE$K_GETCHN = 712;        !  Get channel information
literal BASE$EXE$K_GETDEV = 720;        !  Get device information
literal BASE$EXE$K_GETJPI = 728;        !  Get job process information
literal BASE$EXE$K_PUTMSG = 736;        !  Put formatted error message
literal BASE$EXE$K_EXCMSG = 744;        !  Output exception summary message
literal BASE$EXE$K_SNDACC = 752;        !  Send message to acounting manager
literal BASE$EXE$K_SETIME = 760;        !  Set system time
literal BASE$EXE$K_SETPRV = 768;        !  Set privileges
literal BASE$EXE$K_CLRAST = 776;        !  Clear active AST
literal BASE$EXE$K_CLRAST_2 = 784;      !  ******* DUMMY ********
literal BASE$EXE$K_SRCHANDLER = 792;    !  Search for condition handler
! 	This is a special part of the system service vector
! 	area.  It contains the common wait code of the $UPDSECW,
! 	$GETDVIW, $GETJPIW, $GETSYIW, and $SNDJBCW system services,
! 	along a part of the command interpreter dispatch vector.
! 	Do not add vectors here!
literal BASE$EXE$K_WAIT_FORM = 800;     !  Marks beginning of common wait code area
!  These two areas are adjacent; do not add vectors here.
! 
! 	RMS service vector offsets
! 
literal BASE$RMS$K_DELETE = 872;        !  Delete a record
literal BASE$RMS$K_FIND = 880;          !  Find record
literal BASE$RMS$K_FREE = 888;          !  Release lock on all records
literal BASE$RMS$K_GET = 896;           !  Get a record
literal BASE$RMS$K_PUT = 904;           !  Put a record
literal BASE$RMS$K_READ = 912;          !  Read a block
literal BASE$RMS$K_RELEASE = 920;       !  Release lock on named record
literal BASE$RMS$K_UPDATE = 928;        !  Rewrite existing record
literal BASE$RMS$K_WAIT = 936;          !  Stall for record operation complete
literal BASE$RMS$K_WRITE = 944;         !  Write block
literal BASE$RMS$K_CLOSE = 952;         !  Close file
literal BASE$RMS$K_CONNECT = 960;       !  Connect rab
literal BASE$RMS$K_CREATE = 968;        !  Create file
literal BASE$RMS$K_DISCONNECT = 976;    !  Disconnect rab
literal BASE$RMS$K_DISPLAY = 984;       !  Display file information
literal BASE$RMS$K_ERASE = 992;         !  Erase (delete) file
literal BASE$RMS$K_EXTEND = 1000;       !  Extend file allocation
literal BASE$RMS$K_FLUSH = 1008;        !  Finish i/o activity for stream
literal BASE$RMS$K_MODIFY = 1016;       !  Modify file attributes
literal BASE$RMS$K_NXTVOL = 1024;       !  Next volume
literal BASE$RMS$K_OPEN = 1032;         !  Open file
literal BASE$RMS$K_REWIND = 1040;       !  Rewind file
literal BASE$RMS$K_SPACE = 1048;        !  Position for transfer
literal BASE$RMS$K_TRUNCATE = 1056;     !  Truncate file
literal BASE$RMS$K_ENTER = 1064;        !  Enter filename into directory
literal BASE$RMS$K_PARSE = 1072;        !  Parse filename specification
literal BASE$RMS$K_REMOVE = 1080;       !  Remove filename from directory
literal BASE$RMS$K_RENAME = 1088;       !  Rename a file
literal BASE$RMS$K_SEARCH = 1096;       !  Search a file directory
literal BASE$RMS$K_SETDDIR = 1104;      !  Set default directory string
literal BASE$RMS$K_SETDFPROT = 1112;    !  Set default file protection mask
literal BASE$RMS$K_SSVEXC = 1120;       !  Generate sys serv exception
literal BASE$RMS$K_RMSRUNDWN = 1128;    !  Perform rundown on RMS files
literal BASE$RMS$K_SPARE_VECTOR_1 = 1136; !  Obsolete RMS Recovery Unit Handler
literal BASE$RMS$K_FILESCAN = 1144;     !  Perform syntax check for file specs
!  These two areas are adjacent; do not add vectors here.
! 
!  2nd area of system service vector offsets
! 
literal BASE$EXE$K_DCLEVT = 1416;       !  Declare an event
literal BASE$EXE$K_SETEVTAST = 1424;    !  Set Event AST
literal BASE$EXE$K_SETEVTASTW = 1432;   !  Set Event AST and wait
literal BASE$EXE$K_SETEVTASTW_2 = 1440; !  ******* DUMMY *******
literal BASE$EXE$K_SETEVTASTW_3 = 1448; !  ******* DUMMY *******
literal BASE$EXE$K_CANEVTAST = 1456;    !  Cancel Event AST
literal BASE$EXE$K_GETEVI = 1464;       !  Get event information
literal BASE$EXE$K_ENQ = 1472;          !  Enqueue
literal BASE$EXE$K_DEQ = 1480;          !  Dequeue
literal BASE$EXE$K_ENQW = 1488;         !  Enqueue and wait
literal BASE$EXE$K_ENQW_2 = 1496;       !  ******* DUMMY *******
literal BASE$EXE$K_ENQW_3 = 1504;       !  ******* DUMMY *******
literal BASE$EXE$K_SETSSF = 1512;       !  Set system service filter mask
literal BASE$EXE$K_SETSTK = 1520;       !  Set stack limits
literal BASE$EXE$K_GETSYI = 1528;       !  Get system information
literal BASE$EXE$K_IMGFIX = 1536;       !  Image address relocation fixup
literal BASE$EXE$K_IMGFIX_2 = 1544;     !  ********** TEMP **********
literal BASE$EXE$K_GETDVI = 1552;       !  Get device and volume information
literal BASE$EXE$K_GETDVIW = 1560;      !  Get device information and wait
literal BASE$EXE$K_GETJPIW = 1568;      !  Get job/process information and wait
literal BASE$EXE$K_GETJPIW_2 = 1576;    !  ********* DUMMY *********
literal BASE$EXE$K_GETSYIW = 1584;      !  Get system information and wait
literal BASE$EXE$K_SNDJBCW = 1592;      !  Send to job controller and wait
literal BASE$EXE$K_SYNCH = 1600;        !  Synchronize EFN and IOSB
!  These two areas are adjacent; do not add vectors here.
! 
!  3rd area of system service vector offsets
! 
literal BASE$EXE$K_ERAPAT = 1648;       !  Generate a security erase pattern
literal BASE$EXE$K_CRELNT = 1656;       !  Create logical name table
literal BASE$EXE$K_CRELNM = 1664;       !  Create logical name
literal BASE$EXE$K_DELLNM = 1672;       !  Delete logical name
literal BASE$EXE$K_TRNLNM = 1680;       !  Translate logical name
literal BASE$EXE$K_GETLKI = 1688;       !  Get lock information
literal BASE$EXE$K_GETLKIW = 1696;      !  Get lock information and wait
literal BASE$EXE$K_GETLKIW_2 = 1704;    !  ******** DUMMY ********
literal BASE$EXE$K_ASCTOID = 1712;      !  ASCII to identifier conversion
literal BASE$EXE$K_FINISH_RDB = 1720;   !  Finish RDB context stream
literal BASE$EXE$K_IDTOASC = 1728;      !  Identifier to ASCII conversion
literal BASE$EXE$K_BRKTHRU = 1736;      !  Break through writes
literal BASE$EXE$K_GRANTID = 1744;      !  Grant identifier to process
literal BASE$EXE$K_REVOKID = 1752;      !  Revoke identifier from process
literal BASE$EXE$K_CHKPRO = 1760;       !  General protection check routine
literal BASE$EXE$K_BRKTHRUW = 1768;     !  Break though write and wait
literal BASE$EXE$K_BRKTHRUW_2 = 1776;   !  ******** DUMMY ********
literal BASE$EXE$K_GETQUI = 1784;       !  Get queue information
literal BASE$EXE$K_GETQUIW = 1792;      !  Get queue information and wait
literal BASE$EXE$K_GETQUIW_2 = 1800;    !  ******** DUMMY ********
!  These two areas are adjacent; do not add vectors here.
literal BASE$EXE$K_PROCESS_SCAN = 1808; !  Process scan across cluster
literal BASE$EXE$K_DEVICE_SCAN = 1816;  !  Wildcard device scan
literal BASE$EXE$K_DCLRNH = 1824;       !  Declare snapshot restart handler
literal BASE$EXE$K_CANRNH = 1832;       !  Cancel snapshot restart handler
literal BASE$EXE$K_EXTRNH = 1840;       !  Exit from a snapshot rundown handler
literal BASE$EXE$K_HASH_PASSWORD = 1848; !  Hash password
literal BASE$EXE$K_MAKE_REF = 1856;     !  Reference unloadable exec image
literal BASE$EXE$K_REMOVE_REF = 1864;   !  End of reference to unloadable exec image
literal BASE$EXE$K_CREATE_BUFOBJ = 1872; !  Create buffer object for I/O
literal BASE$EXE$K_DELETE_BUFOBJ = 1880; !  Delete buffer object for I/O
literal BASE$EXE$K_DIAGNOSE = 1888;     !  Diagnose service for affinity work
literal BASE$EXE$K_CALL_HANDL_JACKET = 1896; !  Call condition handler
!    supersedes SYS$CALL_HANDL
literal BASE$EXE$K_TIMCON = 1904;       !  Convert Smithsonian to UTC, and back
literal BASE$EXE$K_GETUTC = 1912;       !  Get a UTC format time
literal BASE$EXE$K_NUMUTC = 1920;       !  Convert UTC to numeric time
literal BASE$EXE$K_BINUTC = 1928;       !  Convert ASCII to binary UTC time
literal BASE$EXE$K_ASCUTC = 1936;       !  Convert Binary UTC time to ASCII
literal BASE$EXE$K_SUBSYSTEM = 1944;    !  Modify protected subsystem attributes
literal BASE$EXE$K_DNS = 1952;          !  Distributed Name Service Clerk interface
literal BASE$EXE$K_DNSW = 1960;         !  Distributed Name Service Clerk interface
!  These two areas are adjacent; do not add vectors here.
literal BASE$DDTM$K_END_BRANCH = 1968;  !  DECdtm application is finished
literal BASE$DDTM$K_END_BRANCHW = 1976; !  DECdtm application is finished (wait form)
literal BASE$DDTM$K_END_BRANCHW_2 = 1984; !  *** DUMMY ***
!  These two areas are adjacent; do not add vectors here.
literal BASE$EXE$K_SS_VECTOR_DUMMY_3_1 = 1992; !  Reserved for future
literal BASE$EXE$K_POSIX_SERVICE = 2000; !  All other kernel-mode Posix services
literal BASE$EXE$K_POSIX_IOSERVICE = 2008; !  All exec-mode Posix services
literal BASE$EXE$K_POSIX_FORK_CONTROL = 2016; !  Fork() control
literal BASE$EXE$K_CANCEL_SELECTIVE = 2024; !  Selective Cancel I/O on channel
literal BASE$EXE$K_POSIX_UMSERVICE = 2032; !  Mode-of-caller POSIX services
literal BASE$EXE$K_CFS_SERVICE = 2040;  !  POSIX file system service
literal BASE$EXE$K_SS_VECTOR_DUMMY_3_8 = 2048; !  Reserved for future
literal BASE$EXE$K_SS_VECTOR_DUMMY_3_9 = 2056; !  Reserved for future
literal BASE$EXE$K_SS_VECTOR_DUMMY_3_10 = 2064; !  Reserved for future
literal BASE$EXE$K_SS_VECTOR_DUMMY_3_11 = 2072; !  Reserved for future
literal BASE$EXE$K_SS_VECTOR_DUMMY_3_12 = 2080; !  Reserved for future
!  These two areas are adjacent; do not add vectors here.
! 
! 	RUF system services
! 
literal BASE$EXE$K_START_RU = 2088;     ! 
literal BASE$EXE$K_PREPARE_RU = 2096;   ! 
literal BASE$EXE$K_COMMIT_RU = 2104;    ! 
literal BASE$EXE$K_ABORT_RU = 2112;     ! 
literal BASE$EXE$K_DCLRUH = 2120;       ! 
literal BASE$EXE$K_CANRUH = 2128;       ! 
literal BASE$EXE$K_JOIN_RU = 2136;      ! 
literal BASE$EXE$K_UNJOIN_RU = 2144;    ! 
literal BASE$EXE$K_RUNDOWN_RU = 2152;   ! 
literal BASE$EXE$K_GET_RUID = 2160;     ! 
literal BASE$EXE$K_END_RU = 2168;       ! 
literal BASE$EXE$K_END_RU_2 = 2176;     ! 
!  These two areas are adjacent; do not add vectors here.
literal BASE$EXE$K_MTACCESS = 2184;     !  Magnetic Tape Accessibility
literal BASE$EXE$K_GETLUI = 2192;       !  Get license unit information
literal BASE$EXE$K_GRANT_LICENSE = 2200; !  Authorize software product execution
literal BASE$EXE$K_RELEASE_LICENSE = 2208; !  Revoke software product authorization
literal BASE$EXE$K_SIGPRC = 2216;       !  Signal another process
literal BASE$EXE$K_RESCHED = 2224;      !  Relenquish CPU via rescheduling interrupt
literal BASE$EXE$K_GETSECI = 2232;      !  Get section information
literal BASE$EXE$K_LOOKUP_LICENSE = 2240; !  LP interface to $GRANT_LICENSE
literal BASE$EXE$K_IPC = 2248;
!  These two areas are adjacent; do not add vectors here.
literal BASE$DDTM$K_START_TRANS = 2256; !  Start transaction
literal BASE$DDTM$K_END_TRANS = 2264;   !  End transaction
literal BASE$DDTM$K_ABORT_TRANS = 2272; !  Abort transaction
literal BASE$DDTM$K_DECLARE_RM = 2280;  !  Declare resource manager
literal BASE$DDTM$K_FORGET_RM = 2288;   !  Forget resource manager
literal BASE$DDTM$K_JOIN_RM = 2296;     !  Join RM to transaction
literal BASE$DDTM$K_FINISH_RMOP = 2304; !  Complete transaction state transition
literal BASE$DDTM$K_ADD_BRANCH = 2312;  !  Add child node to transaction
literal BASE$DDTM$K_START_BRANCH = 2320; !  Start subordinate transaction branch
literal BASE$DDTM$K_START_TRANSW = 2328; !  Start transaction
literal BASE$DDTM$K_START_TRANSW_2 = 2336; !  *** DUMMY ***
literal BASE$DDTM$K_START_TRANSW_3 = 2344; !  *** DUMMY ***
literal BASE$DDTM$K_END_TRANSW = 2352;  !  End transaction
literal BASE$DDTM$K_ABORT_TRANSW = 2360; !  Abort transaction
literal BASE$DDTM$K_DECLARE_RMW = 2368; !  Declare resource manager
literal BASE$DDTM$K_FORGET_RMW = 2376;  !  Forget resource manager
literal BASE$DDTM$K_JOIN_RMW = 2384;    !  Join RM to transaction
literal BASE$DDTM$K_FINISH_RMOPW = 2392; !  Complete transaction state transition
literal BASE$DDTM$K_ADD_BRANCHW = 2400; !  Add child node to transaction
literal BASE$DDTM$K_START_BRANCHW = 2408; !  Start subordinate transaction branch
!  These two areas are adjacent; do not add vectors here.
literal BASE$EXE$K_IPCW = 2416;         !  InterProcess Communication Request and Wait
literal BASE$EXE$K_IPCW_2 = 2424;       !  *** DUMMY ***
literal BASE$EXE$K_IPCW_3 = 2432;       !  *** DUMMY ***
literal BASE$EXE$K_CREATE_UID = 2440;   !  Create Universal Identifier
literal BASE$EXE$K_EMAA = 2448;         !  Entity Management Agent Access Call
literal BASE$EXE$K_EVDPOSTEVENT = 2456; !  Post Event Call
!  These two areas are adjacent; do not add vectors here.
literal BASE$EXE$K_ENABLE_VP_USE = 2464; !  Enable use of vector processor
literal BASE$EXE$K_ENABLE_VP_USE_INT = 2472; !  Enable use of vector processor, internal form
literal BASE$EXE$K_DISABLE_VP_USE = 2480; !  Disable use of vector procssor
literal BASE$EXE$K_DISABLE_VP_USE_INT = 2488; !  Disable use of vector processor, internal form
literal BASE$EXE$K_RELEASE_VP = 2496;   !  Release the vector processor
literal BASE$EXE$K_RELEASE_VP_INT = 2504; !  Release the vector processorm internal form
literal BASE$EXE$K_RESTORE_VP_EXCEPTION = 2512; !  Restore vector exception state
literal BASE$EXE$K_RESTORE_VP_EXC_INT = 2520; !  Restore vector exception state, internal form
literal BASE$EXE$K_SAVE_VP_EXCEPTION = 2528; !  Save vector exception state
literal BASE$EXE$K_SAVE_VP_EXC_INT = 2536; !  Save vector exception state, internal form
literal BASE$EXE$K_RESTORE_VP_STATE = 2544; !  Restore mainline vector state	
! 
!  The following area is free for the addition of new system services.
!  Add new services before SS_VECTOR_SPARE.
! 
literal BASE$EXE$K_SS_VECTOR_DUMMY_8_1 = 2552; !  Reserved for future
literal BASE$EXE$K_SS_VECTOR_DUMMY_8_2 = 2560; !  Reserved for future
literal BASE$EXE$K_REPORT_EVENT = 2568; !  Report performance event to Performance Data Platform
literal BASE$EXE$K_SS_VECTOR_DUMMY_8_3 = 2576; !  Reserved for future
literal BASE$EXE$K_SS_VECTOR_DUMMY_8_4 = 2584; !  Reserved for future
literal BASE$EXE$K_SS_VECTOR_DUMMY_8_5 = 2592; !  Reserved for future
literal BASE$EXE$K_NETWORK_LOGIN = 2600; !  Distributed Authentication Security Services
literal BASE$EXE$K_SS_VECTOR_DUMMY_8_7 = 2608; !  Reserved for future
literal BASE$DDTM$K_ACK_EVENT = 2616;   !  Acknowledge DECdtm Event
literal BASE$DDTM$K_CREATE_BRANCH = 2624; !  Create Transaction Branch
literal BASE$DDTM$K_CREATE_BRANCHW = 2632; !  Create Transaction Branch (wait form)
literal BASE$DDTM$K_CREATE_BRANCHW_1 = 2640; !  **** DUMMY **** Required for CREATE_BRANCHW
literal BASE$DDTM$K_GET_DEFAULT_TRANS = 2648; !  Get Default Transaction Identifier
literal BASE$DDTM$K_RECOVER = 2656;     !  Recover DECdtm Transaction for RM
literal BASE$DDTM$K_RECOVERW = 2664;    !  Recover DECdtm Transaction for RM (wait form)
literal BASE$DDTM$K_RECOVERW_1 = 2672;  !  **** DUMMY **** Required for RECOVERW
literal BASE$DDTM$K_SET_DEFAULT_TRANS = 2680; !  Set Default Transaction
literal BASE$DDTM$K_SET_DEFAULT_TRANSW = 2688; !  Wait Form Set Default Transaction
literal BASE$DDTM$K_SET_DEF_TRAN_DUMMY = 2696; !  **** DUMMY **** Required for SET_DEFAULT_TRANSW
literal BASE$DDTM$K_TRANS_EVENT = 2704; !  Generate Transaction Event
literal BASE$DDTM$K_TRANS_EVENTW = 2712; !  Generate Transaction Event (wait form)
literal BASE$DDTM$K_TRANS_EVENTW_1 = 2720; !  **** DUMMY **** Required for TRANS_EVENTW
literal BASE$EXE$K_SS_VECTOR_SPARE = 2728; !  Marks beginning of spare vector area
! 
! ****************************************************************************
! *                                                                          *
! *  Copyright (c) 1992                                                      *
! *  by DIGITAL Equipment Corporation, Maynard, Mass.                        *
! *                                                                          *
! *  This software is furnished under a license and may be used and  copied  *
! *  only  in  accordance  with  the  terms  of  such  license and with the  *
! *  inclusion of the above copyright notice.  This software or  any  other  *
! *  copies  thereof may not be provided or otherwise made available to any  *
! *  other person.  No title to and ownership of  the  software  is  hereby  *
! *  transferred.                                                            *
! *                                                                          *
! *  The information in this software is subject to change  without  notice  *
! *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment  *
! *  Corporation.                                                            *
! *                                                                          *
! *  DIGITAL assumes no responsibility for the use or  reliability  of  its  *
! *  software on equipment which is not supplied by DIGITAL.                 *
! *                                                                          *
! ****************************************************************************
! ********************************************************************************************************************************
!  Created  7-JUL-1992 20:06:43 by VAX SDL T3.2-8      Source: 27-FEB-1987 15:50:44 _$22$DIA9:[SHRLIB]SYSTEM_PRIMITIVES_DATA.SDL;1 
! ********************************************************************************************************************************
 
!*** MODULE $SYSTEM_PRIM_DATA ***
! +
!  DEFINITION OF SYSTEM PRIMITIVES LOCAL DATA
! -
literal S_SYSTEM_PRIM_DATA = 84;
macro IOC_GQ_IRPIQ = 0,0,0,0 %;
literal S_IOC_GQ_IRPIQ = 8;             !  I/O REQUEST PACKET IQ LISTHEAD
macro IOC_GL_IRPREM = 8,0,32,0 %;
macro IOC_GL_IRPCNT = 12,0,32,0 %;
macro IOC_GL_IRPMIN = 16,0,32,0 %;
macro IOC_GL_XTRA1 = 20,0,32,0 %;       !  EXTRA LONGWORD for QUAD align
macro IOC_GQ_SRPIQ = 24,0,0,0 %;
literal S_IOC_GQ_SRPIQ = 8;             !  SMALL REQUEST PACKET IQ LISTHEAD
macro IOC_GL_SRPSIZE = 32,0,32,0 %;
macro IOC_GL_SRPMIN = 36,0,32,0 %;
macro IOC_GL_SRPSPLIT = 40,0,32,0 %;
macro IOC_GL_SRPREM = 44,0,32,0 %;
macro IOC_GL_SRPCNT = 48,0,32,0 %;
macro IOC_GL_XTRA2 = 52,0,32,0 %;       !  EXTRA LONGWORD for QUAD align
macro IOC_GQ_LRPIQ = 56,0,0,0 %;
literal S_IOC_GQ_LRPIQ = 8;             !  LARGE REQUEST PACKET IQ LISTHEAD
macro IOC_GL_LRPSIZE = 64,0,32,0 %;
macro IOC_GL_LRPMIN = 68,0,32,0 %;
macro IOC_GL_LRPSPLIT = 72,0,32,0 %;
macro IOC_GL_LRPREM = 76,0,32,0 %;
macro IOC_GL_LRPCNT = 80,0,32,0 %;
 
!*** MODULE FORKQ ***
literal S_FORKQ = 8;
macro EXE_GL_FKWAITFL = 0,0,32,0 %;     !  FORK-AND-WAIT QUEUE FL
macro EXE_GL_FKWAITBL = 4,0,32,0 %;     !  FORK-AND-WAIT QUEUE BL
! 
! ****************************************************************************
! *                                                                          *
! *  Copyright (c) 1992                                                      *
! *  by DIGITAL Equipment Corporation, Maynard, Mass.                        *
! *                                                                          *
! *  This software is furnished under a license and may be used and  copied  *
! *  only  in  accordance  with  the  terms  of  such  license and with the  *
! *  inclusion of the above copyright notice.  This software or  any  other  *
! *  copies  thereof may not be provided or otherwise made available to any  *
! *  other person.  No title to and ownership of  the  software  is  hereby  *
! *  transferred.                                                            *
! *                                                                          *
! *  The information in this software is subject to change  without  notice  *
! *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment  *
! *  Corporation.                                                            *
! *                                                                          *
! *  DIGITAL assumes no responsibility for the use or  reliability  of  its  *
! *  software on equipment which is not supplied by DIGITAL.                 *
! *                                                                          *
! ****************************************************************************
! ********************************************************************************************************************************
!  Created  7-JUL-1992 20:06:47 by VAX SDL T3.2-8      Source: 24-APR-1985 13:18:46 _$22$DIA9:[SHRLIB]IO_ROUTINES_DATA.SDL;1 
! ********************************************************************************************************************************
 
!*** MODULE $IO_ROUTINES_DATA ***
! +
!  DEFINITION OF IO_ROUTINES IMAGE LOCAL DATA
! -
literal S_IO_ROUTINES_DATA = 8;
macro IOC_GL_PSFL = 0,0,32,0 %;         !  I/O POST QUEUE FORWARD LINK
macro IOC_GL_PSBL = 4,0,32,0 %;         !  I/O POST QUEUE BACKWARD LINK
! 
! ****************************************************************************
! *                                                                          *
! *  Copyright (c) 1992                                                      *
! *  by DIGITAL Equipment Corporation, Maynard, Mass.                        *
! *                                                                          *
! *  This software is furnished under a license and may be used and  copied  *
! *  only  in  accordance  with  the  terms  of  such  license and with the  *
! *  inclusion of the above copyright notice.  This software or  any  other  *
! *  copies  thereof may not be provided or otherwise made available to any  *
! *  other person.  No title to and ownership of  the  software  is  hereby  *
! *  transferred.                                                            *
! *                                                                          *
! *  The information in this software is subject to change  without  notice  *
! *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment  *
! *  Corporation.                                                            *
! *                                                                          *
! *  DIGITAL assumes no responsibility for the use or  reliability  of  its  *
! *  software on equipment which is not supplied by DIGITAL.                 *
! *                                                                          *
! ****************************************************************************
! ********************************************************************************************************************************
!  Created  7-JUL-1992 20:06:51 by VAX SDL T3.2-8      Source: 25-JUL-1989 13:46:08 _$22$DIA9:[SHRLIB]LDRDEF.SDL;1 
! ********************************************************************************************************************************
 
!*** MODULE LDRPTE ***
literal LDRPTE$M_LINK = 2097151;
literal LDRPTE$M_FLAG = 2097152;
literal LDRPTE$S_LDRPTEDEF = 8;
macro LDRPTE$L_LINK_PTE = 0,0,32,0 %;   !  link word
macro LDRPTE$V_LINK = 0,0,21,0 %;
literal LDRPTE$S_LINK = 21;             !  actual link field
macro LDRPTE$V_FLAG = 0,21,1,0 %;       !  1 If a single free PTE
macro LDRPTE$L_COUNT = 4,0,32,0 %;      !  count of free PTE's
 
!*** MODULE LDRIMG ***
literal LDR_DYN$M_PAG = 1;
literal LDR_DYN$M_UNL = 2;
literal LDR_DYN$M_OVR = 4;
literal LDR_DYN$S_LDR_DYN = 4;
macro LDR_DYN$V_PAG = 0,0,1,0 %;
macro LDR_DYN$V_UNL = 0,1,1,0 %;
macro LDR_DYN$V_OVR = 0,2,1,0 %;
literal LDRIMG$M_NOT_XQP = 1;
literal LDRIMG$M_DELAY_INIT = 2;
literal LDRIMG$M_NO_PFN_DB = 4;
literal LDRIMG$M_FIX_UPS_DONE = 8;
literal LDRIMG$M_NONPAGED_FIXUP = 16;
literal LDRIMG$M_NOOVERLAY = 32;
literal LDRIMG$M_CAN_UNL = 64;
literal LDRIMG$M_UNL_PEN = 128;
literal LDRIMG$M_SYNC = 256;
literal LDRIMG$M_VALID = 512;
literal LDRIMG$K_LENGTH = 164;
literal LDRIMG$C_LENGTH = 164;
literal LDRIMG$S_LDRIMGDEF = 164;
macro LDRIMG$L_FLINK = 0,0,32,0 %;      !  forward link
macro LDRIMG$L_BLINK = 4,0,32,0 %;      !  backward link
macro LDRIMG$W_LENGTH = 8,0,16,0 %;     !  structure length
macro LDRIMG$B_TYPE = 10,0,8,0 %;       !  DYN$C_LOADCODE	
macro LDRIMG$B_IMGNAMLEN = 12,0,8,0 %;  !  count for image name
macro LDRIMG$T_IMGNAM = 13,0,0,0 %;
literal LDRIMG$S_IMGNAM = 39;           !  image name string
macro LDRIMG$L_BASE = 52,0,32,0 %;      !  base virtual address
macro LDRIMG$L_PAGE_COUNT = 56,0,32,0 %; !  image size in pages
macro LDRIMG$R_FLAGS_OVERLAY = 60,0,32,0 %;
macro LDRIMG$L_FLAGS = 60,0,32,0 %;     !  status flags
macro LDRIMG$R_FLAGS_BITS = 60,0,16,0 %;
macro LDRIMG$V_NOT_XQP = 60,0,1,0 %;    !  not opened by XQP
macro LDRIMG$V_DELAY_INIT = 60,1,1,0 %; !  needs delayed initialization
macro LDRIMG$V_NO_PFN_DB = 60,2,1,0 %;  !  no PFN data base when loaded
macro LDRIMG$V_FIX_UPS_DONE = 60,3,1,0 %; !  address fix-ups complete
macro LDRIMG$V_NONPAGED_FIXUP = 60,4,1,0 %; !  Non-paged fix-ups done
macro LDRIMG$V_NOOVERLAY = 60,5,1,0 %;  !  not overlaid by bugcheck 
macro LDRIMG$V_CAN_UNL = 60,6,1,0 %;    !  unloadable exec image 
macro LDRIMG$V_UNL_PEN = 60,7,1,0 %;    !  exec image unload is pending 
macro LDRIMG$V_SYNC = 60,8,1,0 %;       !  synchronize access to this block
macro LDRIMG$V_VALID = 60,9,1,0 %;      !  contents of this block are valid 
macro LDRIMG$Q_LINKTIME = 64,0,0,0 %;
literal LDRIMG$S_LINKTIME = 8;          !  link time
macro LDRIMG$L_VERSION = 72,0,32,0 %;   !  image version
macro LDRIMG$L_NONPAG_R_BASE = 76,0,32,0 %; !  nonpaged read-only base
macro LDRIMG$L_NONPAG_R_LEN = 80,0,32,0 %; !  nonpaged read-only length
macro LDRIMG$L_NONPAG_W_BASE = 84,0,32,0 %; !  nonpaged writable base
macro LDRIMG$L_NONPAG_W_LEN = 88,0,32,0 %; !  nonpaged writable length
macro LDRIMG$L_PAG_R_BASE = 92,0,32,0 %; !  paged read-only base
macro LDRIMG$L_PAG_R_LEN = 96,0,32,0 %; !  paged read-only length
macro LDRIMG$L_PAG_W_BASE = 100,0,32,0 %; !  paged writable base
macro LDRIMG$L_PAG_W_LEN = 104,0,32,0 %; !  paged writable length
macro LDRIMG$L_FIXUP_BASE = 108,0,32,0 %; !  base VA of .ADDRESS fixup section
macro LDRIMG$L_FIXUP_LEN = 112,0,32,0 %; !  size of fixup section
macro LDRIMG$L_INIT_BASE = 116,0,32,0 %; !  base VA of initialization code
macro LDRIMG$L_INIT_LEN = 120,0,32,0 %; !  size of initialization code
macro LDRIMG$W_PAG_R_STX = 124,0,16,1 %; !  section table index (read-only)
macro LDRIMG$W_PAG_W_STX = 126,0,16,1 %; !  section table index (writable)
macro LDRIMG$L_WCB = 128,0,32,0 %;      !  WCB pointer
macro LDRIMG$L_INIT_RTN = 132,0,32,0 %; !  delayed initialization routine
macro LDRIMG$L_PID = 136,0,32,0 %;      !  pid of proc attempting load
macro LDRIMG$L_CHAN = 140,0,32,0 %;     !  chan number
macro LDRIMG$L_BASIMGVEC = 144,0,32,0 %; !  VA of list of base image vectors (in pool)
macro LDRIMG$L_NUM_BASVEC = 148,0,32,0 %; !  number of base image contributions  
macro LDRIMG$L_SEQ = 152,0,32,0 %;      !  sequence no. (exe$gl_ldr_seq) at last load    
macro LDRIMG$L_UNLVEC = 156,0,32,0 %;   !  VA of unload routine(s) vector
macro LDRIMG$L_REFCNT = 160,0,32,0 %;   !  number of references pending
 
!*** MODULE STAT ***
literal STAT_M_INPOOL = 1;
literal STAT_M_NOIMGHDR = 2;
literal STAT_M_OPEN = 4;
literal STAT_M_NOLOAD_SA_APP = 8;
literal STAT_M_OPTIONAL_LOAD = 16;
literal STAT_M_INHIBIT_LOAD = 32;
literal STAT_C_SIZE = 32;               !  Size of statistics block
literal STAT_S_STATDEF = 32;
macro STAT_L_VBN = 0,0,32,0 %;          !  Starting VBN (after image header)
macro STAT_L_BYTECNT = 4,0,32,1 %;      !  Size of image in bytes
macro STAT_L_SYSVA = 8,0,32,0 %;        !  Base relative address of pool address
macro STAT_L_LENGTH = 12,0,32,0 %;      !  Length of ASCII file name
macro STAT_L_NAME = 16,0,32,0 %;        !  Base relative address of ASCII file name
macro STAT_L_FLAGS = 20,0,32,0 %;       !  Loading flags
macro STAT_V_INPOOL = 20,0,1,0 %;
macro STAT_V_NOIMGHDR = 20,1,1,0 %;
macro STAT_V_OPEN = 20,2,1,0 %;
macro STAT_V_NOLOAD_SA_APP = 20,3,1,0 %; !  Don't load image if SA_APP=1
macro STAT_V_OPTIONAL_LOAD = 20,4,1,0 %; !  Image may not be present
macro STAT_V_INHIBIT_LOAD = 20,5,1,0 %; !  Don't load image if set
macro STAT_L_MAP = 24,0,32,0 %;         !  Address of virtual-to-logical map
macro STAT_L_VBN2ADR = 28,0,32,0 %;     !  Buffer address containing VBN 2
 
!*** MODULE BOOSTATE ***
literal BOOSTATE$M_SYSBOOT = 1;
literal BOOSTATE$M_INIT = 2;
literal BOOSTATE$M_SWAPPER = 4;
literal BOOSTATE$M_SYSINIT = 8;
literal BOOSTATE$M_STARTUP = 16;
literal BOOSTATE$M_MAPPED = 32;
literal BOOSTATE$M_PFN_INIT = 64;
literal BOOSTATE$M_POOL_INIT = 128;
literal BOOSTATE$M_XQP = 256;
literal BOOSTATE$M_RMS = 512;
literal BOOSTATE$M_CONSOLE = 1024;
literal BOOSTATE$S_BOOSTATEDEF = 4;
macro BOOSTATE$V_SYSBOOT = 0,0,1,0 %;   !  SYSBOOT is executing
macro BOOSTATE$V_INIT = 0,1,1,0 %;      !  INIT is executing
macro BOOSTATE$V_SWAPPER = 0,2,1,0 %;   !  The SWAPPER process is executing
macro BOOSTATE$V_SYSINIT = 0,3,1,0 %;   !  The SYSINIT process is executing
macro BOOSTATE$V_STARTUP = 0,4,1,0 %;   !  The STARTUP process is executing
macro BOOSTATE$V_MAPPED = 0,5,1,0 %;    !  Virtual memory mapping is enabled
macro BOOSTATE$V_PFN_INIT = 0,6,1,0 %;  !  The PFN database is initialized
macro BOOSTATE$V_POOL_INIT = 0,7,1,0 %; !  Nonpaged pool is available
macro BOOSTATE$V_XQP = 0,8,1,0 %;       !  The XQP has been mapped
macro BOOSTATE$V_RMS = 0,9,1,0 %;       !  RMS has been loaded
macro BOOSTATE$V_CONSOLE = 0,10,1,0 %;  !  Console routines are connected
 
!*** MODULE INIRTN ***
literal INIRTN$M_SYSRTN = 1;
literal INIRTN$M_CALLED = 2;
literal INIRTN$M_NO_RECALL = 4;
literal INIRTN$S_INIRTNDEF = 4;
macro INIRTN$V_SYSRTN = 0,0,1,0 %;      !  Routine is external to image
macro INIRTN$V_CALLED = 0,1,1,0 %;      !  Routine has been called already
macro INIRTN$V_NO_RECALL = 0,2,1,0 %;   !  Routine is not to be recalled 
 
!*** MODULE S0PAGING ***
literal S0PAGING$M_EXEC = 1;
literal S0PAGING$M_RMS = 2;
literal S0PAGING$S_S0PAGINGDEF = 4;
macro S0PAGING$V_EXEC = 0,0,1,0 %;      !  exec paging (most loadable pieces) 
macro S0PAGING$V_RMS = 0,1,1,0 %;       !  RMS paging
! 
! ****************************************************************************
! *                                                                          *
! *  Copyright (c) 1992                                                      *
! *  by DIGITAL Equipment Corporation, Maynard, Mass.                        *
! *                                                                          *
! *  This software is furnished under a license and may be used and  copied  *
! *  only  in  accordance  with  the  terms  of  such  license and with the  *
! *  inclusion of the above copyright notice.  This software or  any  other  *
! *  copies  thereof may not be provided or otherwise made available to any  *
! *  other person.  No title to and ownership of  the  software  is  hereby  *
! *  transferred.                                                            *
! *                                                                          *
! *  The information in this software is subject to change  without  notice  *
! *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment  *
! *  Corporation.                                                            *
! *                                                                          *
! *  DIGITAL assumes no responsibility for the use or  reliability  of  its  *
! *  software on equipment which is not supplied by DIGITAL.                 *
! *                                                                          *
! ****************************************************************************
! ********************************************************************************************************************************
!  Created  7-JUL-1992 20:06:58 by VAX SDL T3.2-8      Source:  7-MAR-1991 11:54:07 _$22$DIA9:[SHRLIB]VECTORS.SDL;1 
! ********************************************************************************************************************************
 
!*** MODULE SSVEC ***
literal SSVEC_K_LENGTH = 8;             !  Size of list element
literal SSVEC_S_SSVECDEF = 8;
macro SSVEC_W_ENTRY_MASK = 0,0,16,0 %;  !  Register save mask
macro SSVEC_B_OPCODE = 2,0,8,0 %;       !  Instruction opcode
macro SSVEC_B_ADDRESSING_MODE = 3,0,8,0 %; !  Addressing mode
macro SSVEC_A_JMP_DESTINATION = 4,0,32,0 %;
macro SSVEC_W_CHMX_CODE = 4,0,16,1 %;   !  CHMx code
macro SSVEC_B_RET = 6,0,8,0 %;
 
!*** MODULE DISP ***
literal DISP_K_LENGTH = 8;              !  Size of list element
literal DISP_S_DISPDEF = 8;
macro DISP_W_ARG_LIST_SIZE = 0,0,16,0 %; !  Size in bytes of argument list    
macro DISP_B_ARGUMENT_COUNT = 2,0,8,0 %; !  Number of required parameters
macro DISP_B_EXIT_TYPE = 3,0,8,0 %;     ! Exit code type
macro DISP_A_SERVICE_ROUTINE = 4,0,32,0 %; !  Address of first instruction of
!   service-specific procedure
 
!*** MODULE SSDESCR ***
literal MODE_K_KERNEL = 0;              !  Service executes in KERNEL mode
literal MODE_K_EXEC = 1;                !  Service executes in EXECUTIVE mode
literal MODE_K_SUPER = 2;               !  Service executes in SUPERVISOR mode
literal MODE_K_USER = 3;                !  Service executes in USER mode
literal MODE_K_CALLERS_MODE = 4;        !  Service executes in the mode of the caller
literal TYPE_K_NORMAL = 0;              !  No composite type, default value
literal TYPE_K_QIOW = 1;                !  Composite type QIOW
literal TYPE_K_ENQW = 2;                !  Composite type ENQW
literal TYPE_K_GETDVIW = 3;             !  Composite type GETDVIW
literal TYPE_K_GETJPIW = 4;             !  Composite type GETJPIW
literal TYPE_K_GETSYIW = 5;             !  Composite type GETSYIW
literal TYPE_K_SNDJBCW = 6;             !  Composite type SNDJBCW
literal TYPE_K_GETLKIW = 7;             !  Composite type GETLKIW
literal TYPE_K_BRKTHRUW = 8;            !  Composite type BRKTHRUW
literal TYPE_K_GETQUIW = 9;             !  Composite type GETQUIW
literal TYPE_K_END_RU = 10;             !  Composite type END_RU
literal TYPE_K_START_TRANSW = 11;       !  Composite type START_TRANS
literal TYPE_K_END_TRANSW = 12;         !  Composite type END_TRANS
literal TYPE_K_ABORT_TRANSW = 13;       !  Composite type ABORT_TRANS
literal TYPE_K_DECLARE_RMW = 14;        !  Composite type DECLARE_RM
literal TYPE_K_FORGET_RMW = 15;         !  Composite type FORGET_RM
literal TYPE_K_JOIN_RMW = 16;           !  Composite type JOIN_RM
literal TYPE_K_FINISH_RMOPW = 17;       !  Composite type FINISH_RMOP
literal TYPE_K_ADD_BRANCHW = 18;        !  Composite type ADD_BRANCH
literal TYPE_K_START_BRANCHW = 19;      !  Composite type START_BRANCH
literal TYPE_K_IPCW = 20;               !  Composite type IPCW
literal TYPE_K_END_BRANCHW = 21;        !  Composite type END_BRANCHW
literal TYPE_K_CREATE_BRANCHW = 22;     !  Composite type CREATE_BRANCHW
literal TYPE_K_RECOVERW = 23;           !  Composite type RECOVERW
literal TYPE_K_SET_DEFAULT_TRANSW = 24; !  Composite type SET_DEFAULT_TRANSW
literal TYPE_K_TRANS_EVENTW = 25;       !  Composite type TRANS_EVENTW
literal TYPE_K_DNSW = 26;               !  Composite type DNSW
literal TYPE_K_MAXIMUM = 27;            !  Maximum number of types
literal EXIT_K_NORMAL_EXIT = 0;         !  Default exit code
literal EXIT_K_RMS_STALL = 1;           !  RMS wait for I/O completion
literal EXIT_K_RMS_WAIT = 2;            !  RMS $WAIT eit code
literal EXIT_K_ASSIGN_EXIT = 3;         !  Special exit code for $ASSIGN to perform
!  assign to network object in caller's mode.
literal SSDESCR_M_CLASS_0 = 1;
literal SSDESCR_M_CLASS_1 = 2;
literal SSDESCR_M_CLASS_2 = 4;
literal SSDESCR_M_CLASS_3 = 8;
literal SSDESCR_M_CLASS_4 = 16;
literal SSDESCR_M_CLASS_5 = 32;
literal SSDESCR_M_CLASS_6 = 64;
literal SSDESCR_M_CLASS_7 = 128;
literal SSDESCR_K_LENGTH = 16;          !  Size of list element
literal SSDESCR_S_SSDESCRDEF = 16;
macro SSDESCR_A_VECTOR_ADDRESS = 0,0,32,0 %; !  Address of vector in S0 space
macro SSDESCR_A_ENTRY_ADDRESS = 4,0,32,0 %; !  Self-relative pointer to .ENTRY mask
macro SSDESCR_B_ARG_COUNT = 8,0,8,0 %;  !  Argument count
macro SSDESCR_B_MIN_ARG_COUNT = 9,0,8,0 %; !  Minimum argument count
macro SSDESCR_B_MODE = 10,0,8,0 %;      !  Access mode in which service executes
macro SSDESCR_B_INHIBIT_MASK = 11,0,8,0 %; !  System service inhibit mask
macro SSDESCR_V_CLASS_0 = 11,0,1,0 %;
macro SSDESCR_V_CLASS_1 = 11,1,1,0 %;
macro SSDESCR_V_CLASS_2 = 11,2,1,0 %;
macro SSDESCR_V_CLASS_3 = 11,3,1,0 %;
macro SSDESCR_V_CLASS_4 = 11,4,1,0 %;
macro SSDESCR_V_CLASS_5 = 11,5,1,0 %;
macro SSDESCR_V_CLASS_6 = 11,6,1,0 %;
macro SSDESCR_V_CLASS_7 = 11,7,1,0 %;
macro SSDESCR_B_SYNCH_TYPE = 12,0,8,0 %; !  Composite service type
macro SSDESCR_B_EXIT_TYPE = 13,0,8,0 %; !  Exit code type
! ********************************************************************************************************************************
!  Created  7-JUL-1992 19:28:56 by VAX SDL T3.2-8      Source: 14-NOV-1991 16:56:02 _$22$DIA9:[NCP.SRC]NMADEF.SDL;1 
! ********************************************************************************************************************************
 
!*** MODULE $NMADEF ***
! 
!  Object type
! 
literal NMA$C_OBJ_NIC = 19;             !  Nice listener 
! 
!  Function codes
! 
literal NMA$C_FNC_LOA = 15;             !  Request down-line load 
literal NMA$C_FNC_DUM = 16;             !  Request up-line dump 
literal NMA$C_FNC_TRI = 17;             !  Trigger bootstrap 
literal NMA$C_FNC_TES = 18;             !  Test 
literal NMA$C_FNC_CHA = 19;             !  Change parameter 
literal NMA$C_FNC_REA = 20;             !  Read information 
literal NMA$C_FNC_ZER = 21;             !  Zero counters 
literal NMA$C_FNC_SYS = 22;             !  System-specific function 
! 
!  Option byte
! 
!     common to change parameter, read information and zero counters
! 
literal NMA$M_OPT_ENT = 7;
literal NMA$M_OPT_CLE = 64;
literal NMA$M_OPT_PER = 128;
literal NMA$M_OPT_INF = 112;
literal NMA$C_OPINF_SUM = 0;            !  Summary 
literal NMA$C_OPINF_STA = 1;            !  Status 
literal NMA$C_OPINF_CHA = 2;            !  Characteristics 
literal NMA$C_OPINF_COU = 3;            !  Counters 
literal NMA$C_OPINF_EVE = 4;            !  Events 
! 
literal NMA$M_OPT_ACC = 128;
literal NMA$M_OPT_REA = 128;
literal NMA$C_SYS_RST = 1;              !  Rsts 
literal NMA$C_SYS_RSX = 2;              !  Rsx family 
literal NMA$C_SYS_TOP = 3;              !  Tops-20 
literal NMA$C_SYS_VMS = 4;              !  Vms 
literal NMA$C_SYS_RT = 5;               !  RT-11 
! 
literal NMA$C_ENT_NOD = 0;              !  Node 
literal NMA$C_ENT_LIN = 1;              !  Line 
literal NMA$C_ENT_LOG = 2;              !  Logging 
literal NMA$C_ENT_CIR = 3;              !  Circuit 
literal NMA$C_ENT_MOD = 4;              !  Module 
literal NMA$C_ENT_ARE = 5;              !  Area 
! 
literal NMA$C_SENT_PROXY = 2;           !  Proxies
literal NMA$C_SENT_ALI = 3;             !  Alias 
literal NMA$C_SENT_OBJ = 4;             !  Object 
literal NMA$C_SENT_PRO = 5;             !  Process 
literal NMA$C_SENT_SYS = 6;             !  System 
literal NMA$C_SENT_LNK = 7;             !  Links 
literal NMA$C_SENT_WLD = -30;           !  Wildcarded entity
literal NMA$M_ENT_EXE = 128;
literal NMA$C_ENT_WAR = -7;             !  Wildcarded area
literal NMA$C_ENT_WAD = -6;             !  Wildcarded address
literal NMA$C_ENT_ADJ = -4;             !  Adjacent 
literal NMA$C_ENT_ACT = -2;             !  Active 
literal NMA$C_ENT_KNO = -1;             !  Known 
literal NMA$C_ENT_ADD = 0;              !  Node address 
literal NMA$C_ENT_ALL = -3;             !  All 
literal NMA$C_ENT_LOO = -3;             !  Loop 
! 
literal NMA$C_SNK_CON = 1;              !  Console 
literal NMA$C_SNK_FIL = 2;              !  File 
literal NMA$C_SNK_MON = 3;              !  Monitor 
! 
literal NMA$M_CNT_TYP = 4095;
literal NMA$M_CNT_MAP = 4096;
literal NMA$M_CNT_WID = 24576;
literal NMA$M_CNT_COU = 32768;
literal NMA$M_CNT_WIL = 8192;
literal NMA$M_CNT_WIH = 16384;
literal NMA$S_NMADEF = 2;
macro NMA$V_OPT_ENT = 0,0,3,0 %;
literal NMA$S_OPT_ENT = 3;              !  Entity type 
! 
!     change parameter
! 
macro NMA$V_OPT_CLE = 0,6,1,0 %;        !  Clear parameter 
! 
!     common to change parameter or read information
! 
macro NMA$V_OPT_PER = 0,7,1,0 %;        !  Permanent parameters 
! 
!     read information
! 
macro NMA$V_OPT_INF = 0,4,3,0 %;
literal NMA$S_OPT_INF = 3;              !  Information type mask 
!     test
! 
macro NMA$V_OPT_ACC = 0,7,1,0 %;        !  Access control included 
! 
!     zero
! 
macro NMA$V_OPT_REA = 0,7,1,0 %;        !  Read and zero 
! 
!  System types
! 
!  Entity types.  This numbering scheme must be used in non-system-specific
!  NICE messages.  (See below for conflicting system-specific entities).
! 
!  System-specific (function 22) entity types.  This numbering scheme
!  for objects must be used in any entity type in system-specific NICE
!  messages.
! 
macro NMA$V_ENT_EXE = 0,7,1,0 %;        !  Executor indicator flag for response messages 
! 
!  Entity identification format types
! 
!  Logging sink types
! 
!  Counter data type values
! 
macro NMA$V_CNT_TYP = 0,0,12,0 %;
literal NMA$S_CNT_TYP = 12;             !  Type mask 
macro NMA$V_CNT_MAP = 0,12,1,0 %;       !  Bitmapped indicator 
macro NMA$V_CNT_WID = 0,13,2,0 %;
literal NMA$S_CNT_WID = 2;              !  Width field mask 
macro NMA$V_CNT_COU = 0,15,1,0 %;       !  Counter indicator 
macro NMA$V_CNT_WIL = 0,13,1,0 %;       !  Width field low bit 
macro NMA$V_CNT_WIH = 0,14,1,0 %;       !  Width field high bit 
! 
!  Node area and address extraction
! 
literal NMA$M_PTY_TYP = 32767;
literal NMA$C_PTY_MAX = 15;             !  Maximum fields within coded multiple 
literal NMA$M_PTY_CLE = 63;
literal NMA$M_PTY_MUL = 64;
literal NMA$M_PTY_COD = 128;
literal NMA$M_PTY_CMU = 192;
literal NMA$M_PTY_NLE = 15;
literal NMA$M_PTY_NTY = 48;
literal NMA$M_PTY_ASC = 64;
literal NMA$C_NTY_DU = 0;               !  Unsigned decimal 
literal NMA$C_NTY_DS = 1;               !  Signed decimal 
literal NMA$C_NTY_H = 2;                !  Hexidecimal 
literal NMA$C_NTY_O = 3;                !  Octal 
!  NLE values (length of number): 
literal NMA$C_NLE_IMAGE = 0;            !  Image field (byte-counted) 
literal NMA$C_NLE_BYTE = 1;             !  Byte 
literal NMA$C_NLE_WORD = 2;             !  Word 
literal NMA$C_NLE_LONG = 4;             !  Longword 
literal NMA$C_NLE_QUAD = 8;             !  Quadword 
! 
literal NMA$C_PTY_AI = 64;              !  ASCII image (ASC=1) 
literal NMA$C_PTY_HI = 32;              !  Hex image (NTY=H, NLE=IMAGE) 
literal NMA$C_PTY_H1 = 33;              !  Hex byte (NTY=H, NLE=BYTE) 
literal NMA$C_PTY_H2 = 34;              !  Hex word (NTY=H, NLE=WORD) 
literal NMA$C_PTY_H4 = 36;              !  Hex byte (NTY=H, NLE=LONG)
literal NMA$C_PTY_DU1 = 1;              !  Decimal unsigned byte (NTY=DU,NLE=BYTE) 
literal NMA$C_PTY_DU2 = 2;              !  Decimal unsigned word (NTY=DU,NLE=WORD) 
literal NMA$C_PTY_CD1 = 129;            !  Coded decimal byte (COD=1, 1 byte) 
literal NMA$C_PTY_CM2 = 194;            !  Coded multiple, 2 fields 
literal NMA$C_PTY_CM3 = 195;            !  Coded multiple, 3 fields 
literal NMA$C_PTY_CM4 = 196;            !  Coded multiple, 4 fields 
literal NMA$C_PTY_CM5 = 197;            !  Coded multiple, 5 fields 
! 
literal NMA$C_CTLVL_UI = 3;             !  User interface
literal NMA$C_CTLVL_XID = 175;          ! 
literal NMA$C_CTLVL_XID_P = 191;        ! 
literal NMA$C_CTLVL_TEST = 227;         ! 
literal NMA$C_CTLVL_TEST_P = 243;       ! 
! 
literal NMA$C_PCCI_STA = 0;             !  State (coded byte of NMA$C_STATE_) 
literal NMA$C_PCCI_SUB = 1;             !  Substate (coded byte of NMA$C_LINSS_) 
literal NMA$C_PCCI_SER = 100;           !  Service (coded byte of NMA$C_LINSV_) 
literal NMA$C_PCCI_LCT = 110;           !  Counter timer (word) 
literal NMA$C_PCCI_SPY = 120;           !  Service physical address (NI address) 
literal NMA$C_PCCI_SSB = 121;           !  Service substate (coded byte of NMA$C_LINSS_) 
literal NMA$C_PCCI_CNO = 200;           !  Connected node 
literal NMA$C_PCCI_COB = 201;           !  Connected object 
literal NMA$C_PCCI_LOO = 400;           !  Loopback name (ascic) 
literal NMA$C_PCCI_ADJ = 800;           !  Adjacent node 
literal NMA$C_PCCI_DRT = 801;           !  Designated router on NI 
literal NMA$C_PCCI_BLO = 810;           !  Block size (word) 
literal NMA$C_PCCI_COS = 900;           !  Cost (byte) 
literal NMA$C_PCCI_MRT = 901;           !  Maximum routers on NI (byte) 
literal NMA$C_PCCI_RPR = 902;           !  Router priority on NI (byte) 
literal NMA$C_PCCI_HET = 906;           !  Hello timer (word) 
literal NMA$C_PCCI_LIT = 907;           !  Listen timer (word) 
literal NMA$C_PCCI_BLK = 910;           !  Blocking (coded byte of NMA$C_CIRBLK_) 
literal NMA$C_PCCI_MRC = 920;           !  Maximum recalls (byte) 
literal NMA$C_PCCI_RCT = 921;           !  Recall timer (word) 
literal NMA$C_PCCI_NUM = 930;           !  Number (ascic) 
literal NMA$C_PCCI_USR = 1000;          !  User entity identification 
literal NMA$C_PCCI_POL = 1010;          !  Polling state (coded byte of NMA$C_CIRPST_) 
literal NMA$C_PCCI_PLS = 1011;          !  Polling substate (coded byte) 
literal NMA$C_PCCI_OWN = 1100;          !  Owner entity identification 
literal NMA$C_PCCI_LIN = 1110;          !  Line (ascic) 
literal NMA$C_PCCI_USE = 1111;          !  Usage (coded byte of NMA$C_CIRUS_) 
literal NMA$C_PCCI_TYP = 1112;          !  Type (coded byte of NMA$C_CIRTY_) 
literal nma$c_pcci_net = 1119;          !  Network (ascic)
literal NMA$C_PCCI_DTE = 1120;          !  DTE (ascic) 
literal NMA$C_PCCI_CHN = 1121;          !  Channel (word) 
literal NMA$C_PCCI_MBL = 1122;          !  Maximum data (word) 
literal NMA$C_PCCI_MWI = 1123;          !  Maximum window (byte) 
literal NMA$C_PCCI_TRI = 1140;          !  Tributary (byte) 
literal NMA$C_PCCI_BBT = 1141;          !  Babble timer (word) 
literal NMA$C_PCCI_TRT = 1142;          !  Transmit timer (word) 
literal NMA$C_PCCI_RTT = 1143;          !  Retransmit timer (word) 
literal NMA$C_PCCI_MRB = 1145;          !  Maximum receive buffers (coded byte) 
!  0-254 is value, 255 = UNLIMITED
literal NMA$C_PCCI_MTR = 1146;          !  Maximum transmits (byte) 
literal NMA$C_PCCI_ACB = 1150;          !  Active base (byte) 
literal NMA$C_PCCI_ACI = 1151;          !  Active increment (byte) 
literal NMA$C_PCCI_IAB = 1152;          !  Inactive base (byte) 
literal NMA$C_PCCI_IAI = 1153;          !  Inactive increment (byte) 
literal NMA$C_PCCI_IAT = 1154;          !  Inactive threshold (byte) 
literal NMA$C_PCCI_DYB = 1155;          !  Dying base (byte) 
literal NMA$C_PCCI_DYI = 1156;          !  Dying increment (byte) 
literal NMA$C_PCCI_DYT = 1157;          !  Dying threshold (byte) 
literal NMA$C_PCCI_DTH = 1158;          !  Dead threshold (byte) 
! 
literal NMA$C_PCCI_RSX_MAC = 2320;      !  Multipoint active ratio 
literal NMA$C_PCCI_RSX_LOG = 2380;      !  Logical name 
literal NMA$C_PCCI_RSX_DLG = 2385;      !  Designated name 
literal NMA$C_PCCI_RSX_ACT = 2390;      !  Actual name 
! 
literal NMA$C_PCCI_VER = 2700;          !  Verification (coded byte of NMA$C_CIRVE_) 
literal NMA$C_PCCI_XPT = 2720;          !  Transport type (coded byte of NMA$C_CIRXPT_) 
!   VMS Specific codes that are used for the X21 project
literal NMA$C_PCCI_IRC = 2750;          ! Incoming Reverse
literal NMA$C_PCCI_ORC = 2751;          ! Outgoing Reverse
literal NMA$C_PCCI_GRP = 2752;          ! Cug
literal NMA$C_PCCI_NOP = 2753;          ! National Facility Data
literal NMA$C_PCCI_CAL = 2754;          ! Call request "Now/Clear"
literal NMA$C_PCCI_INA = 2755;          ! Inactive
literal NMA$C_PCCI_RED = 2756;          ! Redirected status
literal NMA$C_PCCI_MOD = 2757;          ! Time-cut Mode status "Auto/Noauto"
literal NMA$C_PCCI_REQ = 2758;          ! Request timer T1
literal NMA$C_PCCI_DTW = 2759;          ! Dte waiting timer t2
literal NMA$C_PCCI_PRO = 2760;          ! Progress timer t3a
literal NMA$C_PCCI_INF = 2761;          ! Information timer t4a
literal NMA$C_PCCI_ACC = 2762;          ! Accepted timer t4b
literal NMA$C_PCCI_CLR = 2763;          ! Request timer t5
literal NMA$C_PCCI_DTC = 2764;          ! Dte clear timer t6
literal NMA$C_PCCI_CCG = 2765;          ! Charging timer t7
literal NMA$C_PCCI_ESA = 2766;          ! Enhanced Subaddress
literal NMA$C_PCCI_DTI = 2767;          ! DTE provided info
literal NMA$C_PCCI_SWC = 2768;          ! Switched - set line leased
literal NMA$C_PCCI_TIC = 2769;          ! Timecutting on/off
literal NMA$C_PCCI_CSG = 2770;          ! Send signal-data enable/disable
literal NMA$C_PCCI_AAS = 2771;          ! Abbreviated address.
literal NMA$C_PCCI_DTS = 2772;          ! DTE Status
literal NMA$C_PCCI_CAS = 2773;          ! Call Status
literal NMA$C_PCCI_CPS = 2774;          ! Call-Progress Status
literal NMA$C_PCCI_CNT = 2775;          ! Counter .
literal NMA$C_PCCI_RAT = 2776;          ! Rate item read only for show
literal NMA$C_PCCI_PRD = 2777;          ! Period hh:mm-hh:mm
literal NMA$C_PCCI_DAY = 2778;          ! day of week
literal NMA$C_PCCI_BFN = 2779;          ! number of buffers for driver to issue
literal NMA$C_PCCI_BSZ = 2780;          ! size of buffer to allocate.
literal NMA$C_PCCI_MDM = 2781;          ! Modem signals on/off
literal NMA$C_PCCI_DTL = 2782;          ! DTE-List element.
literal NMA$C_PCCI_IDL = 2783;          ! Idle time
literal NMA$C_PCCI_IMT = 2784;          ! Initial Minimum timer
literal NMA$C_PCCI_CAC = 2785;          ! Call accept control
literal NMA$C_PCCI_ORD = 2786;          ! Outgoing request Delay
literal NMA$C_PCCI_CID = 2787;          ! Calling DTE id
! 
literal NMA$C_PCCI_MST = 2810;          !  Maintenance state 
! 
literal NMA$C_PCCI_SRV_LOG = 3380;      !  Logical name 
literal NMA$C_PCCI_SRV_DLG = 3385;      !  Designated name 
literal NMA$C_PCCI_SRV_ACT = 3390;      !  Actual name 
! 
literal NMA$C_PCLI_STA = 0;             !  State (coded byte of NMA$C_STATE_) 
literal NMA$C_PCLI_SUB = 1;             !  Substate (coded byte of NMA$C_LINSS_) 
literal NMA$C_PCLI_SER = 100;           !  Service (coded byte of NMA$C_LINSV_) 
literal NMA$C_PCLI_LCT = 110;           !  Counter timer (word) 
literal NMA$C_PCLI_LOO = 400;           !  Loopback name (ascic) [V2 only] 
literal NMA$C_PCLI_ADJ = 800;           !  Adjacent node [V2 only] 
literal NMA$C_PCLI_BLO = 810;           !  Block size (word) [V2 only] 
literal NMA$C_PCLI_COS = 900;           !  Cost (byte) [V2 only] 
literal NMA$C_PCLI_DEV = 1100;          !  Device (ascic) 
literal NMA$C_PCLI_BFN = 1105;          !  Receive buffers 
literal NMA$C_PCLI_CON = 1110;          !  Controller (coded byte of NMA$C_LINCN_) 
literal NMA$C_PCLI_DUP = 1111;          !  Duplex (coded byte of NMA$C_DPX_) 
literal NMA$C_PCLI_PRO = 1112;          !  Protocol (coded byte of NMA$C_LINPR_) 
literal NMA$C_PCLI_LTY = 1112;          !  Type (coded byte of NMA$C_LINTY_) [V2 only] 
literal NMA$C_PCLI_CLO = 1113;          !  Clock (coded byte of NMA$C_LINCL_) 
literal NMA$C_PCLI_STI = 1120;          !  Service timer (word) 
literal NMA$C_PCLI_NTI = 1121;          !  Normal timer (word) [V2 only] 
literal NMA$C_PCLI_RTT = 1121;          !  Retransmit timer (word) 
literal NMA$C_PCLI_HTI = 1122;          !  Holdback timer (word) 
literal NMA$C_PCLI_MBL = 1130;          !  Maximum block (word) 
literal NMA$C_PCLI_MRT = 1131;          !  Maximum retransmits (byte) 
literal NMA$C_PCLI_MWI = 1132;          !  Maximum window (byte) 
literal NMA$C_PCLI_TRI = 1140;          !  Tributary (byte) [V2 only] 
literal NMA$C_PCLI_SLT = 1150;          !  Scheduling timer (word) 
literal NMA$C_PCLI_DDT = 1151;          !  Dead timer (word) 
literal NMA$C_PCLI_DLT = 1152;          !  Delay timer (word) 
literal NMA$C_PCLI_SRT = 1153;          !  Stream timer (word) 
literal NMA$C_PCLI_HWA = 1160;          !  Hardware address (NI address) 
! 
literal NMA$C_PCLI_TREQ = 1161;         !  Requested TRT
literal NMA$C_PCLI_TVX = 1162;          !  Valid transmission time
literal NMA$C_PCLI_REST_TTO = 1163;     !  Restricted token timeout
literal NMA$C_PCLI_RPE = 1164;          !  Ring purger enable
literal NMA$C_PCLI_NIF_TARG = 1165;     !  NIF target
literal NMA$C_PCLI_SIF_CONF_TARG = 1166; !  SIF configuration target
literal NMA$C_PCLI_SIF_OP_TARG = 1167;  !  SIF operation target
literal NMA$C_PCLI_ECHO_TARG = 1168;    !  Echo target
literal NMA$C_PCLI_ECHO_DAT = 1169;     !  Echo data
literal NMA$C_PCLI_ECHO_LEN = 1180;     !  Echo length
literal NMA$C_PCLI_LAST_NIF = 1181;     !  Last NIF
literal NMA$C_PCLI_LAST_SIF = 1182;     !  Last SIF
literal NMA$C_PCLI_LAST_ECHO = 1183;    !  Last echo
literal NMA$C_PCLI_T_NEG = 1184;        !  Negotiated TRT
literal NMA$C_PCLI_DAT = 1185;          !  Duplicate address flag
literal NMA$C_PCLI_UNA = 1173;          !  Upstream neighbor
literal NMA$C_PCLI_OLD_UNA = 1187;      !  Old upstream neighbor
literal NMA$C_PCLI_UN_DAT = 1188;       !  Upstream neighbor DA flag
literal NMA$C_PCLI_DNA = 1189;          !  Downstream neighbor
literal NMA$C_PCLI_OLD_DNA = 1192;      !  Old downstream neighbor
literal NMA$C_PCLI_RPS = 1193;          !  Ring purger state
literal NMA$C_PCLI_RER = 1194;          !  Ring error reason
literal NMA$C_PCLI_NBR_PHY = 1300;      !  Neighbor PHY type
literal NMA$C_PCLI_LEE = 1301;          !  Link error estimate
literal NMA$C_PCLI_RJR = 1302;          !  Reject reason
literal nma$c_pcli_net = 1190;          !  Network name (ascic)
literal NMA$C_PCLI_XMD = 1191;          !  X.25 line mode (coded byte of NMA$C_X25MD_) 
! 
literal NMA$C_PCLI_RSX_OWN = 2300;      !  Owner 
literal NMA$C_PCLI_RSX_CCS = 2310;      !  Controller CSR 
literal NMA$C_PCLI_RSX_UCS = 2311;      !  Unit CSR 
literal NMA$C_PCLI_RSX_VEC = 2312;      !  Vector 
literal NMA$C_PCLI_RSX_PRI = 2313;      !  Priority 
literal NMA$C_PCLI_RSX_MDE = 2321;      !  Dead polling ratio 
literal NMA$C_PCLI_RSX_LLO = 2330;      !  Location 
!   0, Firstfit
literal NMA$C_PCLI_RSX_LOG = 2380;      !  Logical name 
literal NMA$C_PCLI_RSX_DLG = 2385;      !  Designated name 
literal NMA$C_PCLI_RSX_ACT = 2390;      !  Actual name 
! 
literal NMA$C_PCLI_MCD = 2701;          !  Micro-code dump filespec (ascic) 
literal NMA$C_PCLI_EPT = 2720;          !  Ethernet Protocol Type (hex word) 
literal NMA$C_PCLI_LNS = 2730;          !  Line speed (word)
literal NMA$C_PCLI_SWI = 2740;          !  SWITCH (coded byte of nma$c_linswi_)
literal NMA$C_PCLI_HNG = 2750;          !  HANGUP (coded byte of NMA$C_LINHNG_)
literal NMA$C_PCLI_TPI = 2760;          !  Transmit pipeline 
literal nma$c_pcli_nrzi = 2761;         !  NRZI bit encoding
literal nma$c_pcli_code = 2762;         !  Character code (encoded as CODE_)
!    This section are parameters for 802 support.
literal NMA$C_PCLI_FMT = 2770;          !  Packet format(coded of linfm_)
literal NMA$C_PCLI_SRV = 2771;          !  Driver service coded of linsr
literal NMA$C_PCLI_SAP = 2772;          !  SAP
literal NMA$C_PCLI_GSP = 2773;          !  GSP
literal NMA$C_PCLI_PID = 2774;          !  PID
literal NMA$C_PCLI_CNM = 2775;          !  Client name
literal NMA$C_PCLI_CCA = 2776;          !  Can change address
literal NMA$C_PCLI_APC = 2777;          !  Allow promiscuous client
literal NMA$C_PCLI_MED = 2778;          !  Communication medium
literal NMA$C_PCLI_PNM = 2779;          !  Port name
literal NMA$C_PCLI_SNM = 2780;          !  Station name
! 
literal NMA$C_PCLI_BUS = 2801;          !  Buffer size (word) 
literal NMA$C_PCLI_NMS = 2810;          !  Number of DMP/DMF synch chars (word) 
literal NMA$C_PCLI_PHA = 2820;          !  Physical NI address of UNA (hex string) 
literal NMA$C_PCLI_DPA = 2821;          !  (same as HWA) ; Default UNA physical address (hex string) 
literal NMA$C_PCLI_PTY = 2830;          !  Ethernet Protocol type (word) 
literal NMA$C_PCLI_MCA = 2831;          !  UNA Multicast address list (special) 
!         (See NMA$C_LINMC_)
literal NMA$C_PCLI_ILP = 2839;          !  DELUA Internal Loopback mode 
!  (coded byte of NMA$C_STATE_)
literal NMA$C_PCLI_PRM = 2840;          !  UNA Promiscuous mode (coded byte of NMA$C_STATE_) 
literal NMA$C_PCLI_MLT = 2841;          !  UNA Multicast address mode (coded byte of NMA$C_STATE_) 
literal NMA$C_PCLI_PAD = 2842;          !  UNA Padding mode (coded byte of NMA$C_STATE_) 
literal NMA$C_PCLI_DCH = 2843;          !  UNA Data chaining mode (coded byte of NMA$C_STATE_) 
literal NMA$C_PCLI_CRC = 2844;          !  UNA CRC mode (coded byte of NMA$C_STATE_) 
literal NMA$C_PCLI_HBQ = 2845;          !  UNA Hardware Buffer Quota (word) 
literal NMA$C_PCLI_ACC = 2846;          !  UNA protocol access mode (coded byte of NMA$C_ACC_) 
literal NMA$C_PCLI_EKO = 2847;          !  UNA Echo mode (coded byte of NMA$C_STATE_) 
literal NMA$C_PCLI_BSZ = 2848;          !  UNA Device Buffer size 
literal NMA$C_PCLI_DES = 2849;          !  UNA destination Ethernet address 
literal NMA$C_PCLI_RET = 2850;          !  PCL number of retries (word) 
literal NMA$C_PCLI_MOD = 2851;          !  PCL address mode (coded byte of NMA$C_LINMO_) 
literal NMA$C_PCLI_RIB = 2852;          !  PCL retry-if-busy state (coded byte of NMA$C_STATE_) 
literal NMA$C_PCLI_MNTL = 2860;         !  Maintenance loopback mode for devices 
!   which support several different loop back modes
literal NMA$C_PCLI_INTL0 = 2861;        !  Internal loopback level 0 
literal NMA$C_PCLI_INTL1 = 2862;        !  Internal loopback level 1 
literal NMA$C_PCLI_INTL2 = 2863;        !  Internal loopback level 2 
literal NMA$C_PCLI_INTL3 = 2864;        !  Internal loopback level 3 
literal NMA$C_PCLI_FRA = 2865;          !  Framing address for Bisync 
literal NMA$C_PCLI_STI1 = 2866;         !  State info 1st longword 
literal NMA$C_PCLI_STI2 = 2867;         !  State info 2st longword 
literal NMA$C_PCLI_TMO = 2868;          !  Wait for CTS time out value for DMF sync half duplex 
literal NMA$C_PCLI_MCL = 2869;          !  Clear modem on deassign of channel 
literal NMA$C_PCLI_SYC = 2870;          !  BISYNC protocol sync char 
literal NMA$C_PCLI_BPC = 2871;          !  Number of bits per character 
literal NMA$C_PCLI_MBS = 2872;          !  Maximum buffer size
literal NMA$C_PCLI_RES = 2873;          !  Restart value (coded byte of LINRES_
literal NMA$C_PCLI_XFC = 2874;          !  Transmit FC (coded byte of NMA$C_STATE_)
literal NMA$C_PCLI_RFC = 2875;          !  Receive  FC (coded byte of NMA$C_STATE_)
! 
literal NMA$C_PCLI_SRV_OWN = 3300;      !  Owner 
literal NMA$C_PCLI_SRV_UCS = 3311;      !  Unit CSR 
literal NMA$C_PCLI_SRV_VEC = 3312;      !  Vector 
literal NMA$C_PCLI_SRV_PRI = 3313;      !  Priority 
literal NMA$C_PCLI_SRV_LOG = 3380;      !  Logical name 
literal NMA$C_PCLI_SRV_DLG = 3385;      !  Designated name 
literal NMA$C_PCLI_SRV_ACT = 3390;      !  Actual name 
! 
literal NMA$C_LINMD_CSMACD = 10;        ! 
literal NMA$C_LINMD_FDDI = 11;          ! 
literal NMA$C_LINMD_CI = 12;            ! 
! 
literal NMA$C_PCCO_RTR = 110;           !  Reservation timer (word) 
! 
literal NMA$C_PCLD_ASS = 10;            !  Assistance flag (coded byte of NMA$C_ASS_) 
! 
literal NMA$C_PCLP_ASS = 10;            !  Assistance flag (coded byte of NMA$C_ASS_) 
! 
literal NMA$C_PCCN_CIR = 100;           !  NI circuit name (ascic) 
literal NMA$C_PCCN_SUR = 110;           !  Surveillance flag (coded byte of NMA$C_SUR_) 
literal NMA$C_PCCN_ELT = 111;           !  Elapsed time 
literal NMA$C_PCCN_PHA = 120;           !  Physical address (NI address) 
literal NMA$C_PCCN_LRP = 130;           !  Time of last report 
literal NMA$C_PCCN_MVR = 20001;         !  Maintenance version 
literal NMA$C_PCCN_FCT = 20002;         !  Function list 
literal NMA$C_PCCN_CUS = 20003;         !  Current console user (NI address) 
literal NMA$C_PCCN_RTR = 20004;         !  Reservation timer (word) 
literal NMA$C_PCCN_CSZ = 20005;         !  Command buffer size (word) 
literal NMA$C_PCCN_RSZ = 20006;         !  Response buffer size (word) 
literal NMA$C_PCCN_HWA = 20007;         !  Hardware address (NI address) 
literal NMA$C_PCCN_DTY = 20100;         !  Device type (coded byte of NMA$C_SOFD_) 
literal NMA$C_PCCN_SFI = 20200;         !  Software ID 
literal NMA$C_PCCN_SPR = 20300;         !  System processor (coded word) 
literal NMA$C_PCCN_DLK = 20400;         !  Data link type (coded word) 
! 
literal NMA$C_PCLO_STA = 0;             !  State (coded byte of NMA$C_STATE_) 
literal NMA$C_PCLO_LNA = 100;           !  System/name (ascic) 
literal NMA$C_PCLO_SIN = 200;           !  Sink node 
literal NMA$C_PCLO_EVE = 201;           !  Events 
! 
literal NMA$C_PCXA_NOD = 320;           !  Node 
literal NMA$C_PCXA_USR = 330;           !  User (ascic) 
literal NMA$C_PCXA_SPW = 331;           !  Password to set (ascic) 
literal NMA$C_PCXA_RPW = 331;           !  Password to read (coded byte of NMA$C_NODPW_) 
literal NMA$C_PCXA_ACC = 332;           !  Account (ascic) 
literal NMA$C_PCXA_NET = 1110;          !  Network (ascic) 
! 
literal NMA$C_PCXA_RSX_ADS = 2310;      !  Destination 
literal NMA$C_PCXA_RSX_ANB = 2320;      !  Number 
literal NMA$C_PCXA_RSX_ASC = 2330;      !  Scope 
! 
literal NMA$C_PCXA_SRV_ADS = 3310;      !  Destination 
literal NMA$C_PCXA_SRV_ANB = 3320;      !  Number 
literal NMA$C_PCXA_SRV_ASC = 3330;      !  Scope 
! 
literal NMA$C_PCXP_STA = 0;             !  State (coded byte of NMA$C_STATE_) 
literal NMA$C_PCXP_SBS = 1;             !  Substate, qualified by DTE (coded byte of NMA$C_XPRSB_) 
literal NMA$C_PCXP_CTM = 100;           !  Counter timer (word) 
literal NMA$C_PCXP_ACH = 1000;          !  Active channels (word) 
literal NMA$C_PCXP_ASW = 1010;          !  Active switched (word) 
literal NMA$C_PCXP_DTE = 1100;          !  DTE (ascic) 
literal NMA$C_PCXP_GRP = 1101;          !  Group (ascic) 
literal NMA$C_pcxp_netent = 1110;       !  Network entity (ascic) 
literal NMA$C_pcxp_dnt = 1111;          !  DTE Network (ascic) 
literal NMA$C_PCXP_LIN = 1120;          !  Line (ascic) 
literal NMA$C_PCXP_CHN = 1130;          !  Channels 
literal NMA$C_PCXP_MCH = 1131;          !  Maximum channels (word) 
literal NMA$C_PCXP_DBL = 1140;          !  Default data (word) 
literal NMA$C_PCXP_DWI = 1141;          !  Default window (byte) 
literal NMA$C_PCXP_MBL = 1150;          !  Maximum data (word) 
literal NMA$C_PCXP_MWI = 1151;          !  Maximum window (byte) 
literal NMA$C_PCXP_MCL = 1152;          !  Maximum clears (byte) 
literal NMA$C_PCXP_MRS = 1153;          !  Maximum resets (byte) 
literal NMA$C_PCXP_MST = 1154;          !  Maximum restarts (byte) 
literal NMA$C_PCXP_CAT = 1160;          !  Call timer (byte) 
literal NMA$C_PCXP_CLT = 1161;          !  Clear timer (byte) 
literal NMA$C_PCXP_RST = 1162;          !  Reset timer (byte) 
literal NMA$C_PCXP_STT = 1163;          !  Restart timer (byte)
literal NMA$C_pcxp_itt = 1164;          !  Interrupt timer (byte)
literal NMA$C_PCXP_GDT = 1170;          !  Group DTE (ascic) 
literal NMA$C_PCXP_GNM = 1171;          !  Group number (word) 
literal NMA$C_PCXP_GTY = 1172;          !  Group type (coded byte of NMA$C_XPRTY_) 
literal NMA$C_pcxp_gnt = 1173;          !  Group Network name (ascic)
literal nma$c_pcxp_mode = 1180;         !  DTE mode (coded byte of NMA$C_X25MD_)
literal nma$c_pcxp_prof = 1190;         !  Profile (ascic)
! 
literal NMA$C_PCXP_RSX_PMC = 2300;      !  Maximum circuits 
! 
literal NMA$C_PCXP_MCI = 2710;          !  Maximum circuits, qualified by DTE 
! 
literal NMA$C_PCXP_SRV_PMC = 3300;      !  Maximum circuits 
! 
literal nma$c_pcxs_sta = 1;             !  State (coded byte of NMA$C_STATE_)
literal NMA$C_PCXS_CTM = 100;           !  Counter timer (word) 
literal NMA$C_PCXS_ACI = 200;           !  Active circuits (word) 
literal NMA$C_PCXS_DST = 300;           !  Destination (ascic) 
literal NMA$C_PCXS_MCI = 310;           !  Maximum circuits (word) 
literal NMA$C_PCXS_NOD = 320;           !  Node 
literal NMA$C_PCXS_USR = 330;           !  Username 
literal NMA$C_PCXS_SPW = 331;           !  Password to set (ascic) 
literal NMA$C_PCXS_RPW = 331;           !  Password to read (coded byte of NMA$C_NODPW_) 
literal NMA$C_PCXS_ACC = 332;           !  Account (ascic) 
literal NMA$C_PCXS_OBJ = 340;           !  Object 
literal NMA$C_PCXS_PRI = 350;           !  Priority (byte) 
literal NMA$C_PCXS_CMK = 351;           !  Call mask (byte-counted hex) 
literal NMA$C_PCXS_CVL = 352;           !  Call value (byte-counted hex) 
literal NMA$C_PCXS_GRP = 353;           !  Group (ascic) 
literal NMA$C_PCXS_SDTE = 354;          !  Sending DTE, formally "Number" (ascic) 
literal NMA$C_PCXS_SAD = 355;           !  Subaddresses 
literal nma$c_pcxs_red = 390;           !  Redirect reason (coded byte nma$c_x25red_)
literal nma$c_pcxs_cdte = 391;          !  Called DTE (ascic)
literal nma$c_pcxs_rdte = 392;          !  Receiving DTE (ascic)
literal nma$c_pcxs_net = 393;           !  Network (ascic)
literal nma$C_pcxs_emk = 394;           !  Extension mask (ascic) 
literal nma$C_pcxs_evl = 395;           !  Extension value (ascic) 
literal nma$C_pcxs_idte = 396;          !  Incoming address (ascii)
! 
literal NMA$C_PCXS_RSX_5ST = 2310;      !  State 
!   0, On
literal NMA$C_PCXS_FIL = 2710;          !  Object filespec (ascic) 
! 
literal NMA$C_PCXS_SRV_5ST = 3310;      !  State 
!   0, On
literal NMA$C_PCXT_STA = 0;             !  State (coded byte of NMA$C_STATE_) 
literal NMA$C_PCXT_BSZ = 100;           !  Buffer size (word) 
literal NMA$C_PCXT_MBK = 101;           !  Maximum blocks/file (word) 
literal NMA$C_PCXT_FNM = 102;           !  Filename (ascic) 
literal NMA$C_PCXT_MBF = 103;           !  Maximum number of buffers (word) 
literal NMA$C_PCXT_CPL = 104;           !  Global data capture limit (word) 
literal NMA$C_PCXT_MVR = 105;           !  Maximum trace file version (word) 
literal NMA$C_PCXT_TPT = 106;           !  Trace point name (ascic) 
literal NMA$C_PCXT_CPS = 110;           !  Per-trace capture size (word) 
literal NMA$C_PCXT_TST = 111;           !  Per-trace state (coded byte of NMA$C_STATE_) 
! 
literal NMA$C_PCNO_STA = 0;             !  State (coded byte of NMA$C_STATE_) 
literal NMA$C_PCNO_PHA = 10;            !  Physical address (NI address) 
literal NMA$C_PCNO_IDE = 100;           !  Identification (ascic) 
literal NMA$C_PCNO_MVE = 101;           !  Management version (3 bytes) 
literal NMA$C_PCNO_SLI = 110;           !  Service circuit (ascic) 
literal NMA$C_PCNO_SPA = 111;           !  Service password (8 bytes) 
literal NMA$C_PCNO_SDV = 112;           !  Service device (coded byte of NMA$C_SOFD_) 
literal NMA$C_PCNO_CPU = 113;           !  CPU type (coded byte of NMA$C_CPU_) 
literal NMA$C_PCNO_HWA = 114;           !  Hardware address (NI address) 
literal NMA$C_PCNO_SNV = 115;           !  Service node version (coded byte of NMA$C_SVN_) 
literal NMA$C_PCNO_LOA = 120;           !  Load file (ascic) 
literal NMA$C_PCNO_SLO = 121;           !  Secondary loader (ascic) 
literal NMA$C_PCNO_TLO = 122;           !  Tertiary loader (ascic) 
literal NMA$C_PCNO_DFL = 123;           !  Diagnostic file (ascic) 
literal NMA$C_PCNO_STY = 125;           !  Software type (coded byte of NMA$C_SOFT_) 
literal NMA$C_PCNO_SID = 126;           !  Software ID (ascic) 
literal NMA$C_PCNO_MFL = 127;           !  Management File (ascic)
literal NMA$C_PCNO_DUM = 130;           !  Dump file (ascic) 
literal NMA$C_PCNO_SDU = 131;           !  Secondary dumper (ascic) 
literal NMA$C_PCNO_DAD = 135;           !  Dump address (longword) 
literal NMA$C_PCNO_DCT = 136;           !  Dump count (longword) 
literal NMA$C_PCNO_OHO = 140;           !  Host (read only parameter) 
literal NMA$C_PCNO_IHO = 141;           !  Host (write only parameter) 
literal NMA$C_PCNO_LPC = 150;           !  Loop count (word) 
literal NMA$C_PCNO_LPL = 151;           !  Loop length (word) 
literal NMA$C_PCNO_LPD = 152;           !  Loop Data type (coded byte of NMA$C_LOOP_) 
literal NMA$C_PCNO_LPA = 153;           !  Loop assistant physical address (NI address) 
literal NMA$C_PCNO_LPH = 154;           !  Loop help type (coded byte) 
literal NMA$C_PCNO_LPN = 155;           !  Loop circuit node 
literal NMA$C_PCNO_LAN = 156;           !  Loop circuit assistant node 
literal NMA$C_PCNO_CTI = 160;           !  Counter timer (word) 
literal NMA$C_PCNO_NNA = 500;           !  Name 
literal NMA$C_PCNO_NLI = 501;           !  Circuit (ascic) 
literal NMA$C_PCNO_ADD = 502;           !  Address 
literal NMA$C_PCNO_ITI = 510;           !  Incoming timer (word) 
literal NMA$C_PCNO_OTI = 511;           !  Outgoing timer (word) 
literal NMA$C_PCNO_IPR = 522;           !  Incoming Proxy
literal NMA$C_PCNO_OPR = 523;           !  Outgoing Proxy
literal NMA$C_PCNO_ACL = 600;           !  Active links (word) 
literal NMA$C_PCNO_DEL = 601;           !  Delay (word) 
literal NMA$C_PCNO_NVE = 700;           !  Nsp version (3 bytes) 
literal NMA$C_PCNO_MLK = 710;           !  Maximum links (word) 
literal NMA$C_PCNO_DFA = 720;           !  Delay factor (byte) 
literal NMA$C_PCNO_DWE = 721;           !  Delay weight (byte) 
literal NMA$C_PCNO_IAT = 722;           !  Inactivity timer (word) 
literal NMA$C_PCNO_RFA = 723;           !  Retransmit factor (word) 
literal NMA$C_PCNO_DTY = 810;           !  Destination Type (coded byte of NMA$C_XPRTY_) 
literal NMA$C_PCNO_DCO = 820;           !  Destination Cost (word) 
literal NMA$C_PCNO_DHO = 821;           !  Destination Hops (byte) 
literal NMA$C_PCNO_DLI = 822;           !  Destination circuit (ascic) 
literal NMA$C_PCNO_NND = 830;           !  Next node to destination 
literal NMA$C_PCNO_RVE = 900;           !  Routing version (3 bytes) 
literal NMA$C_PCNO_ETY = 901;           !  Executor Type (coded byte of NMA$C_NODTY_) 
literal NMA$C_PCNO_RTI = 910;           !  Routing timer (word) 
literal NMA$C_PCNO_SAD = 911;           !  Subaddress (2 words) 
literal NMA$C_PCNO_BRT = 912;           !  Broadcast routing timer (word) 
literal NMA$C_PCNO_MAD = 920;           !  Maximum address (word) 
literal NMA$C_PCNO_MLN = 921;           !  Maximum circuits (word) 
literal NMA$C_PCNO_MCO = 922;           !  Maximum cost (word) 
literal NMA$C_PCNO_MHO = 923;           !  Maximum hops (byte) 
literal NMA$C_PCNO_MVI = 924;           !  Maximum visits (byte) 
literal NMA$C_PCNO_MAR = 925;           !  Maximum areas (byte) 
literal NMA$C_PCNO_MBE = 926;           !  Maximum broadcast nonrouters (word) 
literal NMA$C_PCNO_MBR = 927;           !  Maximum broadcast routers (word) 
literal NMA$C_PCNO_AMC = 928;           !  Area maximum cost (word) 
literal NMA$C_PCNO_AMH = 929;           !  Area maximum hops (byte) 
literal NMA$C_PCNO_MBU = 930;           !  Maximum buffers (word) 
literal NMA$C_PCNO_BUS = 931;           !  Executor buffer size (word) 
literal NMA$C_PCNO_SBS = 932;           !  Segment buffer size (word) 
literal NMA$C_PCNO_MPS = 933;           !  Maximum path splits
literal NMA$C_PCNO_FBS = 933;           !  Forwarding buffer size (word) 
! 
literal NMA$C_PCNO_RSX_RPA = 2300;      !  Receive password 
!   0, Password set
literal NMA$C_PCNO_RSX_TPA = 2301;      !  Transmit password 
!   0, Password set
literal NMA$C_PCNO_RSX_VER = 2310;      !  Verification state 
!   0, On
literal NMA$C_PCNO_PUS = 2704;          !  Privileged user id 
literal NMA$C_PCNO_PAC = 2705;          !  Privileged account 
literal NMA$C_PCNO_PPW = 2706;          !  Privileged password 
literal NMA$C_PCNO_NUS = 2712;          !  Non-privileged user id 
literal NMA$C_PCNO_NAC = 2713;          !  Non-privileged account 
literal NMA$C_PCNO_NPW = 2714;          !  Non-privileged password 
literal NMA$C_PCNO_RPA = 2720;          !  Receive password 
literal NMA$C_PCNO_TPA = 2721;          !  Transmit password 
literal NMA$C_PCNO_ACC = 2730;          !  Access (coded byte of NMA$C_ACES_) 
literal NMA$C_PCNO_DAC = 2731;          !  Default access (coded byte of NMA$C_ACES_) 
literal NMA$C_PCNO_PIQ = 2740;          !  Pipeline quota (word) 
literal NMA$C_PCNO_ALI = 2742;          !  Alias incoming (coded byte of ALIINC))
literal NMA$C_PCNO_ALM = 2743;          !  Alias Maximum links
literal NMA$C_PCNO_ALN = 2744;          !  Alias node
literal NMA$C_PCNO_PRX = 2750;          !  Proxy access (coded byte of NMA$C_ACES_) !! Obsolete: Only for LIST/PURGE 
literal NMA$C_PCNO_DPX = 2751;          !  Default proxy access (coded byte of NMA$C_ACES_) 
literal NMA$C_PCNO_COP = 2760;          !  Remote nodefor COPY command
literal NMA$C_PCNO_INB = 2765;          !  Inbound for async DECnet.
literal NMA$C_PCNO_LAA = 2770;          !  Load Assist Agent
literal NMA$C_PCNO_LAP = 2771;          !  Load Assist Parameter
literal NMA$C_PCNO_PSP = 2780;          !  Path Splits Policy
!  (Coded byte f PSPCY)
literal NMA$C_PCNO_MDO = 2785;          !  Maximum Declared Objects
literal NMA$C_PCNO_DNS = 2790;          !  DNS interface
literal NMA$C_PCNO_IDP = 2791;          !  IDP of ISO address
literal NMA$C_PCNO_DNM = 2792;          !  DNS namespace
! 
literal NMA$C_PCNO_SRV_RPA = 3300;      !  Receive password 
!   0, Password set
literal NMA$C_PCNO_SRV_TPA = 3301;      !  Transmit password 
!   0, Password set
literal NMA$C_PCNO_SRV_VER = 3310;      !  Verification state 
!   0, On
literal NMA$C_PCNO_SRV_ACB = 3402;      !  Active control buffers 
literal NMA$C_PCNO_SRV_ASB = 3404;      !  Active small buffers 
literal NMA$C_PCNO_SRV_ALB = 3406;      !  Active large buffers 
literal NMA$C_PCNO_SRV_MCB = 3410;      !  Maximum control buffers 
literal NMA$C_PCNO_SRV_MSB = 3420;      !  Maximum small buffers 
literal NMA$C_PCNO_SRV_MLB = 3430;      !  Maximum large buffers 
literal NMA$C_PCNO_SRV_LBS = 3431;      !  Large buffer size 
literal NMA$C_PCNO_SRV_NRB = 3440;      !  Minimum receive buffers 
literal NMA$C_PCNO_SRV_CPT = 3450;      !  CEX pool: total bytes 
literal NMA$C_PCNO_SRV_CPF = 3452;      !  CEX pool: number of segments 
literal NMA$C_PCNO_SRV_CPL = 3454;      !  CEX pool: largest segment 
literal NMA$C_PCNO_SRV_XPT = 3460;      !  Extended pool: total bytes 
literal NMA$C_PCNO_SRV_XPF = 3462;      !  Extended pool: number of segments 
literal NMA$C_PCNO_SRV_XPL = 3464;      !  Extended pool: largest segment 
! 
literal NMA$C_PCAR_STA = 0;             !  State (coded byte of NMA$C_STATE_) 
literal NMA$C_PCAR_COS = 820;           !  Cost (word) 
literal NMA$C_PCAR_HOP = 821;           !  Hops (byte) 
literal NMA$C_PCAR_CIR = 822;           !  Circuit (ascic) 
literal NMA$C_PCAR_NND = 830;           !  Next node to area 
! 
literal NMA$C_PCOB_OAN = 400;           !  Active name 
literal NMA$C_PCOB_OAC = 410;           !  Active links 
literal NMA$C_PCOB_ONA = 500;           !  Name 
literal NMA$C_PCOB_OCO = 510;           !  Copies 
literal NMA$C_PCOB_OUS = 511;           !  User 
literal NMA$C_PCOB_OVE = 520;           !  Verification 
literal NMA$C_PCOB_NAM = 500;           !  Name 
literal NMA$C_PCOB_NUM = 513;           !  Number 
literal NMA$C_PCOB_FID = 530;           !  File id 
literal NMA$C_PCOB_PID = 535;           !  Process id 
literal NMA$C_PCOB_PRV = 540;           !  Privilege list 
literal NMA$C_PCOB_OCPRV = 542;         !  Outgoing connect privilege list 
literal NMA$C_PCOB_USR = 550;           !  User id 
literal NMA$C_PCOB_ACC = 551;           !  Account 
literal NMA$C_PCOB_PSW = 552;           !  Password 
literal NMA$C_PCOB_PRX = 560;           !  Proxy access (coded byte of NMA$C_ACES_) 
literal NMA$C_PCOB_ALO = 565;           !  Alias outgoing- coded byte of nma$c_alout
literal NMA$C_PCOB_ALI = 566;           !  Alias incoming- coded byte of nma$c_alinc
! 
literal NMA$C_PCLK_STA = 0;             !  State 
literal NMA$C_PCLK_PID = 101;           !  Process id 
literal NMA$C_PCLK_NID = 102;           !  Partner Node 
literal NMA$C_PCLK_LAD = 105;           !  Link address [V2 only] 
!  entity is node rather than link !
literal NMA$C_PCLK_DLY = 110;           !  Round trip delay time (word) 
literal NMA$C_PCLK_RLN = 120;           !  Remote link number (word) 
literal NMA$C_PCLK_RID = 121;           !  Remote identification, PID or username (ascic) 
literal NMA$C_PCLK_USR = 130;           !  Username of link owner (ascic) 
literal NMA$C_PCLK_PRC = 131;           !  Process name of link owner (ascic) 
! 
literal NMA$C_CTCIR_ZER = 0;            !  Seconds since last zeroed 
literal NMA$C_CTCIR_APR = 800;          !  Terminating packets received 
literal NMA$C_CTCIR_DPS = 801;          !  Originating packets sent 
literal NMA$C_CTCIR_ACL = 802;          !  Terminating congestion loss 
literal NMA$C_CTCIR_CRL = 805;          !  Corruption loss 
literal NMA$C_CTCIR_TPR = 810;          !  Transit packets received 
literal NMA$C_CTCIR_TPS = 811;          !  Transit packets sent 
literal NMA$C_CTCIR_TCL = 812;          !  Transit congestion loss 
literal NMA$C_CTCIR_LDN = 820;          !  Circuit down 
literal NMA$C_CTCIR_IFL = 821;          !  Initialization failure 
literal NMA$C_CTCIR_AJD = 822;          !  Adjacency down events
literal NMA$C_CTCIR_PAJ = 900;          !  Peak adjacencies 
literal NMA$C_CTCIR_BRC = 1000;         !  Bytes received 
literal NMA$C_CTCIR_BSN = 1001;         !  Bytes sent 
literal NMA$C_CTCIR_MBY = 1002;         !  Multicast bytes received 
literal NMA$C_CTCIR_DBR = 1010;         !  Data blocks received 
literal NMA$C_CTCIR_DBS = 1011;         !  Data blocks sent 
literal NMA$C_CTCIR_DEI = 1020;         !  Data errors inbound 
literal NMA$C_CTCIR_DEO = 1021;         !  Data errors outbound 
literal NMA$C_CTCIR_RRT = 1030;         !  Remote reply timeouts 
literal NMA$C_CTCIR_LRT = 1031;         !  Local reply timeouts 
literal NMA$C_CTCIR_RBE = 1040;         !  Remote buffer errors 
literal NMA$C_CTCIR_LBE = 1041;         !  Local buffer errors 
literal NMA$C_CTCIR_SIE = 1050;         !  Selection intervals elapsed 
literal NMA$C_CTCIR_SLT = 1051;         !  Selection timeouts 
literal NMA$C_CTCIR_UBU = 1065;         !  NI user buffer unavailable 
literal NMA$C_CTCIR_RPE = 1100;         !  Remote process errors [V2 only] 
literal NMA$C_CTCIR_LPE = 1101;         !  Local process errors [V2 only] 
literal NMA$C_CTCIR_LIR = 1240;         !  Locally initiated resets 
literal NMA$C_CTCIR_RIR = 1241;         !  Remotely initiated resets 
literal NMA$C_CTCIR_NIR = 1242;         !  Network initiated resets 
! 
literal NMA$C_CTCIR_MNE = 2701;         !  Multicast received for protocol 
!  type, but not enabled
literal NMA$C_CTCIR_ERI = 2750;         !  PCL Errors inbound, bit-mapped 
!         0  CRC error on receive
literal NMA$C_CTCIR_ERO = 2751;         !  PCL Errors outbound, bit-mapped 
!         1  CRC on transmit
literal NMA$C_CTCIR_RTO = 2752;         !  PCL Remote timeouts, bit-mapped 
!         0  Receiver busy
literal NMA$C_CTCIR_LTO = 2753;         !  PCL Local timeouts 
literal NMA$C_CTCIR_BER = 2754;         !  PCL Remote buffer errors 
literal NMA$C_CTCIR_BEL = 2755;         !  PCL Local buffer errors 
! 
literal NMA$C_CTLIN_ZER = 0;            !  Seconds since last zeroed 
literal NMA$C_CTLIN_APR = 800;          !  Arriving packets received [V2 only] 
literal NMA$C_CTLIN_DPS = 801;          !  Departing packets sent [V2 only] 
literal NMA$C_CTLIN_ACL = 802;          !  Arriving congestion loss [V2 only] 
literal NMA$C_CTLIN_TPR = 810;          !  Transit packets received [V2 only] 
literal NMA$C_CTLIN_TPS = 811;          !  Transit packets sent [V2 only] 
literal NMA$C_CTLIN_TCL = 812;          !  Transit congestion loss [V2 only] 
literal NMA$C_CTLIN_LDN = 820;          !  Line down [V2 only] 
literal NMA$C_CTLIN_IFL = 821;          !  Initialization failure [V2 only] 
literal NMA$C_CTLIN_BRC = 1000;         !  Bytes received 
literal NMA$C_CTLIN_BSN = 1001;         !  Bytes sent 
literal NMA$C_CTLIN_MBY = 1002;         !  Multicast bytes received 
literal NMA$C_CTLIN_DBR = 1010;         !  Data blocks received 
literal NMA$C_CTLIN_DBS = 1011;         !  Data blocks sent 
literal NMA$C_CTLIN_MBL = 1012;         !  Multicast blocks received 
literal NMA$C_CTLIN_BID = 1013;         !  Blocks sent, initially deferred 
literal NMA$C_CTLIN_BS1 = 1014;         !  Blocks sent, single collision 
literal NMA$C_CTLIN_BSM = 1015;         !  Blocks sent, multiple collisions 
literal NMA$C_CTLIN_MFC = 1016;         !  MAC frame count
literal NMA$C_CTLIN_MEC = 1017;         !  MAC error count
literal NMA$C_CTLIN_MLC = 1018;         !  MAC lost count
literal NMA$C_CTLIN_DEI = 1020;         !  Data errors inbound 
literal NMA$C_CTLIN_DEO = 1021;         !  Data errors outbound 
literal NMA$C_CTLIN_RRT = 1030;         !  Remote reply timeouts 
literal NMA$C_CTLIN_LRT = 1031;         !  Local reply timeouts 
literal NMA$C_CTLIN_RII = 1032;         !  Ring initializations initiated
literal NMA$C_CTLIN_RIR = 1033;         !  Ring initializations received
literal NMA$C_CTLIN_RBI = 1034;         !  Ring beacons initiated
literal NMA$C_CTLIN_DAT = 1035;         !  Duplicate address test failures
literal NMA$C_CTLIN_DTD = 1036;         !  Duplicate tokens detected
literal NMA$C_CTLIN_RPR = 1037;         !  Ring purge errors
literal NMA$C_CTLIN_FSE = 1038;         !  FCI strip errors
literal NMA$C_CTLIN_TRI = 1039;         !  Traces initiated
literal NMA$C_CTLIN_RBE = 1040;         !  Remote buffer errors 
literal NMA$C_CTLIN_LBE = 1041;         !  Local buffer errors 
literal NMA$C_CTLIN_TRR = 1042;         !  Traces initiated
literal NMA$C_CTLIN_DBC = 1043;         !  Directed beacons received
literal NMA$C_CTLIN_SIE = 1050;         !  Selection intervals elapsed [V2 only] 
literal NMA$C_CTLIN_SLT = 1051;         !  Selection timeouts [V2 only] 
literal NMA$C_CTLIN_SFL = 1060;         !  Send failure 
literal NMA$C_CTLIN_CDC = 1061;         !  Collision detect check failure 
literal NMA$C_CTLIN_RFL = 1062;         !  Receive failure 
literal NMA$C_CTLIN_UFD = 1063;         !  Unrecognized frame destination 
literal NMA$C_CTLIN_OVR = 1064;         !  Data overrun 
literal NMA$C_CTLIN_SBU = 1065;         !  System buffer unavailable 
literal NMA$C_CTLIN_UBU = 1066;         !  User buffer unavailable 
literal NMA$C_CTLIN_SFR = 1070;         !  Send failures (Token Ring)
literal NMA$C_CTLIN_RFR = 1071;         !  Receive failures (Token Ring)
literal NMA$C_CTLIN_IFR = 1072;         !  Insertion failures 
literal NMA$C_CTLIN_RGF = 1073;         !  Ring failures
literal NMA$C_CTLIN_RPG = 1074;         !  Ring purges
literal NMA$C_CTLIN_MNC = 1075;         !  Monitor contention
literal NMA$C_CTLIN_BCN = 1076;         !  Beaconing conditions
literal NMA$C_CTLIN_LER = 1080;         !  Line errors
literal NMA$C_CTLIN_IER = 1081;         !  Internal errors
literal NMA$C_CTLIN_BER = 1082;         !  Burst errors
literal NMA$C_CTLIN_RAE = 1083;         !  Ring poll AC errors
literal NMA$C_CTLIN_ADS = 1084;         !  Abort delimiters sent
literal NMA$C_CTLIN_PIE = 1085;         !  Private isolating errors                                                                 
literal NMA$C_CTLIN_TLF = 1086;         !  Transmit lost frames
literal NMA$C_CTLIN_RCE = 1087;         !  Receiver congestion errors
literal NMA$C_CTLIN_FCE = 1088;         !  Frame copied errors
literal NMA$C_CTLIN_FER = 1089;         !  Frequency errors (802.5 defined but not implemented)
literal NMA$C_CTLIN_TER = 1090;         !  Token errors
literal NMA$C_CTLIN_PNE = 1091;         !  Private non-isolating errors
literal NMA$C_CTLIN_RPE = 1100;         !  Remote process errors 
literal NMA$C_CTLIN_LPE = 1101;         !  Local process errors 
literal NMA$C_CTLIN_EBE = 1200;         !  Elasticity buffer errors	
literal NMA$C_CTLIN_LCT = 1201;         !  LCT rejects
literal NMA$C_CTLIN_LEM = 1202;         !  LEM rejects
literal NMA$C_CTLIN_LNK = 1203;         !  Link errors
literal NMA$C_CTLIN_CNC = 1204;         !  Connections completed
! 
literal NMA$S_NMADEF1 = 2;
macro NMA$W_NODE = 0,0,16,0 %;
macro NMA$V_ADDR = 0,0,10,0 %;
literal NMA$S_ADDR = 10;
macro NMA$V_AREA = 0,10,6,0 %;
literal NMA$S_AREA = 6;
! 
!  Parameter ID word (DATA ID)
! 
macro NMA$V_PTY_TYP = 0,0,15,0 %;
literal NMA$S_PTY_TYP = 15;             !  Type mask 
! 
!  Parameter data type byte (DATA TYPE)
! 
macro NMA$V_PTY_CLE = 0,0,6,0 %;
literal NMA$S_PTY_CLE = 6;              !  Coded length mask 
macro NMA$V_PTY_MUL = 0,6,1,0 %;        !  Coded multiple indicator 
macro NMA$V_PTY_COD = 0,7,1,0 %;        !  Coded indicator 
macro NMA$V_PTY_CMU = 0,6,2,0 %;
literal NMA$S_PTY_CMU = 2;              !  Coded multiple 
macro NMA$V_PTY_NLE = 0,0,4,0 %;
literal NMA$S_PTY_NLE = 4;              !  Number length mask 
macro NMA$V_PTY_NTY = 0,4,2,0 %;
literal NMA$S_PTY_NTY = 2;              !  Number type mask 
macro NMA$V_PTY_ASC = 0,6,1,0 %;        !  Ascii image indicator 
!  NTY values (how to display number): 
!  Define standard values for the DATA TYPE byte
! 
!  Parameters for 802 control support
! 
!     Circuit parameters
! 
!  RSX-specific circuit parameters
! 
!  VMS-specific circuit NICE parameters [2700 - 2799]
! 
! 
!  VMS-specific datalink only circuit parameters   [2800 - 2899]
! 
!  (these will never be used in NICE messages).
! 
!  Server Base specific Circuit parameters
! 
!     Line parameters
! 
!  FDDI-specific line parameters
! 
!  RSX-specific line parameters
! 
!   1, Topdown
!  VMS-specific line NICE parameters [2700 - 2799]
! 
!  VMS-specific datalink only line parameters   [2800 - 2899]
! 
!  (these will never be used in NICE messages).
! 
!     Server Base specific line parameters
! 
!     Communication Medium parameters
! 
!     Console module parameters
! 
!     Loader module parameters
! 
!     Looper module parameters
! 
!     Configurator module parameters
! 
!     Logging parameters
! 
!     X.25 Access module parameters
! 
!  RSX-specific X.25-Access module parameters
! 
!  Server Base specific X.25-Access module parameters
! 
!     X.25 Protocol module parameters
! 
!       RSX-specific X.25-Protocol Module parameters
! 
!  VMS-specific X25-PROTOCOL NICE parameters [2700 - 2799]
! 
!  Server Base specific X.25-Protocol Module parameters
! 
!     X.25 server module parameters
! 
!  RSX-specific X.25-Server Module parameters
! 
!   1, Off
! 
!  VMS-specific X25-SERVER NICE parameters [2700 - 2799]
! 
!  Server Base specific X.25-Server Module parameters
! 
!   1, Off
! 
!  X.25 trace module parameters (VMS-specific)
! 
!     Node parameters
! 
!  RSX-Specific Node (Executor) parameters
! 
!   1, Off
! 
!  VMS-specific node parameters
! 
!  Server Base specific Node (Executor) parameters
! 
!   1, Off
!     Area parameters
! 
!     VMS-specific object parameters
! 
!     VMS-specific link parameters
! 
!  CM-1/2, DU-2 (link !), HI-4 (pid)
!     Circuit counters
! 
!  VMS-specific circuit counters
! 
!         2  Timeout on word
!         1  Transmitter offline
!         2  Receiver offline
!     Line counters
! 
!  Line counter flags (byte offset will be 0)
! 
literal NMA$M_CTLIN_BTL = 8;
literal NMA$M_CTLIN_FCS = 16;
literal NMA$M_CTLIN_TRJ = 32;
literal NMA$S_NMADEF2 = 1;
macro NMA$V_CTLIN_BTL = 0,3,1,0 %;      !  block too long 
macro NMA$V_CTLIN_FCS = 0,4,1,0 %;      !  frame check 
macro NMA$V_CTLIN_TRJ = 0,5,1,0 %;      !  REJ sent 
literal NMA$M_CTLIN_RRJ = 8;
literal NMA$S_NMADEF3 = 1;
macro NMA$V_CTLIN_RRJ = 0,3,1,0 %;      !  REJ received 
literal NMA$M_CTLIN_RRN = 4;
literal NMA$S_NMADEF4 = 1;
macro NMA$V_CTLIN_RRN = 0,2,1,0 %;      !  RNR received 
literal NMA$M_CTLIN_TRN = 4;
literal NMA$S_NMADEF5 = 1;
macro NMA$V_CTLIN_TRN = 0,2,1,0 %;      !  RNR sent 
literal NMA$M_CTLIN_INR = 16;
literal NMA$M_CTLIN_FMS = 32;
literal NMA$S_NMADEF6 = 1;
macro NMA$V_CTLIN_INR = 0,4,1,0 %;      !  invalid N(R) received 
macro NMA$V_CTLIN_FMS = 0,5,1,0 %;      !  FRMR sent 
literal NMA$M_CTLIN_TUN = 4;
literal NMA$M_CTLIN_RUN = 16;
literal NMA$M_CTLIN_FMR = 32;
literal NMA$C_CTLIN_MBS = 2701;         !  Multicast packets transmitted 
literal NMA$C_CTLIN_MSN = 2702;         !  Multicast bytes transmitted 
literal NMA$C_CTLIN_RME = 2750;         !  PCL Remote errors, bit-mapped 
!         0  TDM bus busy
literal NMA$C_CTLIN_LCE = 2751;         !  PCL Local errors, bit-mapped 
!         0  Transmitter overrun
literal NMA$C_CTLIN_MSE = 2752;         !  PCL master/secondary errors, bit-mapped 
!         1  Master down
literal NMA$C_CTNOD_ZER = 0;            !  Seconds since last zeroed 
literal NMA$C_CTNOD_BRC = 600;          !  Bytes received 
literal NMA$C_CTNOD_BSN = 601;          !  Bytes sent 
literal NMA$C_CTNOD_MRC = 610;          !  Messages received 
literal NMA$C_CTNOD_MSN = 611;          !  Messages sent 
literal NMA$C_CTNOD_CRC = 620;          !  Connects received 
literal NMA$C_CTNOD_CSN = 621;          !  Connects sent 
literal NMA$C_CTNOD_RTO = 630;          !  Response timeouts 
literal NMA$C_CTNOD_RSE = 640;          !  Received connect resource errors 
literal NMA$C_CTNOD_BUN = 650;          !  Buffer unavailable 
literal NMA$C_CTNOD_MLL = 700;          !  Maximum logical links active 
literal NMA$C_CTNOD_APL = 900;          !  Aged packet loss 
literal NMA$C_CTNOD_NUL = 901;          !  Node unreachable packet loss 
literal NMA$C_CTNOD_NOL = 902;          !  Node out-of-range packet loss 
literal NMA$C_CTNOD_OPL = 903;          !  Oversized packet loss 
literal NMA$C_CTNOD_PFE = 910;          !  Packet format error 
literal NMA$C_CTNOD_RUL = 920;          !  Partial routing update loss 
literal NMA$C_CTNOD_VER = 930;          !  Verification reject 
! 
literal NMA$C_CTNOD_SRV_SYC = 3310;     !  Control buffer failures 
literal NMA$C_CTNOD_SRV_SYS = 3320;     !  Small buffer failures 
literal NMA$C_CTNOD_SRV_SYL = 3330;     !  Large buffer failures 
literal NMA$C_CTNOD_SRV_SYR = 3340;     !  Receive buffer failures 
! 
literal NMA$C_CTXP_ZER = 0;             !  Seconds since last zeroed 
literal NMA$C_CTXP_BRC = 1000;          !  Bytes received 
literal NMA$C_CTXP_BSN = 1001;          !  Bytes sent 
literal NMA$C_CTXP_BLR = 1010;          !  Data blocks received 
literal NMA$C_CTXP_BLS = 1011;          !  Data blocks sent 
literal NMA$C_CTXP_CRC = 1200;          !  Calls received 
literal NMA$C_CTXP_CSN = 1201;          !  Calls sent 
literal NMA$C_CTXP_FSR = 1210;          !  Fast selects received 
literal NMA$C_CTXP_FSS = 1211;          !  Fast selects sent 
literal NMA$C_CTXP_MSA = 1220;          !  Maximum switched circuits active 
literal NMA$C_CTXP_MCA = 1221;          !  Maximum channels active 
literal NMA$C_CTXP_RSE = 1230;          !  Received call resource errors 
literal NMA$C_CTXP_LIR = 1240;          !  Locally initiated resets 
literal NMA$C_CTXP_RIR = 1241;          !  Remotely initiated resets 
literal NMA$C_CTXP_NIR = 1242;          !  Network initiated resets 
literal NMA$C_CTXP_RST = 1250;          !  Restarts 
! 
literal NMA$C_CTXS_ZER = 0;             !  Seconds since last zeroed 
literal NMA$C_CTXS_MCA = 200;           !  Maximum circuits active 
literal NMA$C_CTXS_ICR = 210;           !  Incoming calls rejected, no resources 
literal NMA$C_CTXS_LLR = 211;           !  Logical links rejected, no resources 
! 
literal NMA$C_LOOP_MIX = 2;             !  Mixed 
literal NMA$C_LOOP_ONE = 1;             !  Ones 
literal NMA$C_LOOP_ZER = 0;             !  Zeroes 
! 
literal NMA$C_LOOP_DCNT = 1;            !  Default count 
literal NMA$C_LOOP_DSIZ = 40;           !  Default message size 
! 
literal NMA$C_LOOP_XMIT = 0;            !  Transmit 
literal NMA$C_LOOP_RECV = 1;            !  Receive 
literal NMA$C_LOOP_FULL = 2;            !  Full (both transmit and receive) 
! 
literal NMA$C_STATE_ON = 0;             !  On 
literal NMA$C_STATE_OFF = 1;            !  Off 
! 
literal NMA$C_DNS_ENA = 0;              !  Enabled
literal NMA$C_DNS_DIS = 1;              !  Disabled
! 
literal NMA$C_STATE_SER = 2;            !  Service (circuit/line only) 
literal NMA$C_STATE_CLE = 3;            !  Cleared 
! 
literal NMA$C_STATE_HOL = 2;            !  Hold 
! 
literal NMA$C_STATE_SHU = 2;            !  Shut 
literal NMA$C_STATE_RES = 3;            !  Restricted 
literal NMA$C_STATE_REA = 4;            !  Reachable 
literal NMA$C_STATE_UNR = 5;            !  Unreachable 
! 	PVM0001+
literal NMA$C_PCNO_DMAD = 1023;         ! 
! 	PVM0001-	
literal NMA$C_ASS_ENA = 0;              !  Enabled 
literal NMA$C_ASS_DIS = 1;              !  Disabled 
! 
literal NMA$C_SUR_ENA = 0;              !  Enabled 
literal NMA$C_SUR_DIS = 1;              !  Disabled 
! 
literal NMA$C_LINSS_STA = 0;            !  Starting 
literal NMA$C_LINSS_REF = 1;            !  Reflecting 
literal NMA$C_LINSS_LOO = 2;            !  Looping 
literal NMA$C_LINSS_LOA = 3;            !  Loading 
literal NMA$C_LINSS_DUM = 4;            !  Dumping 
literal NMA$C_LINSS_TRI = 5;            !  Triggering 
literal NMA$C_LINSS_ASE = 6;            !  Autoservice 
literal NMA$C_LINSS_ALO = 7;            !  Autoloading 
literal NMA$C_LINSS_ADU = 8;            !  Autodumping 
literal NMA$C_LINSS_ATR = 9;            !  Autotriggering 
literal NMA$C_LINSS_SYN = 10;           !  Synchronizing 
literal NMA$C_LINSS_FAI = 11;           !  Failed 
literal NMA$C_LINSS_RUN = 12;           !  Running 
literal NMA$C_LINSS_UNS = 13;           !  Unsyncronised 
literal NMA$C_LINSS_IDL = 14;           !  Idle (PSI-only) 
! 
literal NMA$C_CIRTY_POI = 0;            !  DDCMP Point 
literal NMA$C_CIRTY_CON = 1;            !  DDCMP Controller 
literal NMA$C_CIRTY_TRI = 2;            !  DDCMP Tributary 
literal NMA$C_CIRTY_X25 = 3;            !  X25 
literal NMA$C_CIRTY_DMC = 4;            !  DDCMP DMC compatibility mode (DMP) 
! /*        CIRTY_LAPB, 5                /* LAPB  *** remove once all references have been changed to LAPB ***
literal NMA$C_CIRTY_NI = 6;             !  NI 
literal NMA$C_CIRTY_TRNG = 11;          !  Token Ring
literal NMA$C_CIRTY_FDDI = 12;          !  FDDI
! 
literal NMA$C_LINSV_ENA = 0;            !  Enabled 
literal NMA$C_LINSV_DIS = 1;            !  Disabled 
! 
literal NMA$C_CIRPST_AUT = 1;           !  Automatic 
literal NMA$C_CIRPST_ACT = 2;           !  Active 
literal NMA$C_CIRPST_INA = 3;           !  Inactive 
literal NMA$C_CIRPST_DIE = 4;           !  Dying 
literal NMA$C_CIRPST_DED = 5;           !  Dead 
! 
literal NMA$C_CIRBLK_ENA = 0;           !  Enabled 
literal NMA$C_CIRBLK_DIS = 1;           !  Disabled 
! 
literal NMA$C_CIRUS_PER = 0;            !  Permanent 
literal NMA$C_CIRUS_INC = 1;            !  Incoming 
literal NMA$C_CIRUS_OUT = 2;            !  Outgoing 
! 
literal NMA$C_CIRHS_ENA = 0;            !  Enabled
literal NMA$C_CIRHS_DIS = 1;            !  Disabled
! 
literal NMA$C_CIRBF_UNL = 255;          !  Unlimited 
! 
literal NMA$C_CIRVE_ENA = 0;            !  Enabled 
literal NMA$C_CIRVE_DIS = 1;            !  Disabled 
literal NMA$C_CIRVE_INB = 2;            !  Inbound
! 
literal NMA$C_CIRXPT_ZND = 1;           !  Z-node 
literal NMA$C_CIRXPT_PH2 = 2;           !  Force Phase II on this circuit 
literal NMA$C_CIRXPT_PH3 = 3;           !  Routing III 
literal NMA$C_CIRXPT_RO3 = 3;           !  Routing III 
literal NMA$C_CIRXPT_NR4 = 4;           !  Nonrouting Phase IV 
! 
literal NMA$C_DPX_FUL = 0;              !  Full 
literal NMA$C_DPX_HAL = 1;              !  Half 
literal NMA$C_DPX_MPT = 4;              !  Multipoint
! 
literal NMA$C_LINCN_NOR = 0;            !  Normal 
literal NMA$C_LINCN_LOO = 1;            !  Loop 
! 
literal NMA$C_LINPR_POI = 0;            !  DDCMP Point 
literal NMA$C_LINPR_CON = 1;            !  DDCMP Controller 
literal NMA$C_LINPR_TRI = 2;            !  DDCMP Tributary 
literal NMA$C_LINPR_DMC = 4;            !  DDCMP DMC compatibility mode (DMP) 
literal NMA$C_LINPR_LAPB = 5;           !  LAPB 
literal NMA$C_LINPR_NI = 6;             !  NI 
literal NMA$C_LINPR_BSY = 9;            !  BISYNC (not really - just Genbyte)
literal NMA$C_LINPR_GENBYTE = 9;        !  Genbyte (real name)
literal nma$c_linpr_lapbe = 10;         !  LAPBE
literal nma$c_LINPR_TRNG = 11;          !  Token Ring
literal nma$c_LINPR_FDDI = 12;          !  FDDI
literal nma$c_linpr_ea_hdlc = 20;       !  Extended addressing HDLC
literal nma$c_linpr_sdlc = 21;          !  SDLC
literal nma$c_linpr_bisync = 22;        !  IBM Bisync protocol (not BSY framing)
literal nma$c_linpr_swift = 23;         !  SWIFT Bisync variant
literal nma$c_linpr_chips = 24;         !  CHIPS Bisync variant
literal nma$m_linpr_mop = 128;          !  MOP support
! 
literal nma$c_code_ascii = 1;           !  ASCII character code
literal nma$c_code_ebcdic = 2;          !  EBCDIC character code
! 
literal NMA$C_LINPR_MAS = 1;            !  Master (controls clock signals) 
literal NMA$C_LINPR_NEU = 2;            !  Neutral (uses master's clock signals) 
literal NMA$C_LINPR_SEC = 0;            !  Secondary (backup for master failure) 
! 
literal NMA$C_LINCL_EXT = 0;            !  External 
literal NMA$C_LINCL_INT = 1;            !  Internal 
! 
literal NMA$C_LINFM_802E = 0;           !  802 Extended
literal NMA$C_LINFM_ETH = 1;            !  Ethernet
literal NMA$C_LINFM_802 = 2;            !  802
literal NMA$C_LINFM_SMT = 4;            !  SMT (FDDI)
! 
literal NMA$C_LINCN_LEN = 0;            !  Local Entity Name
literal NMA$C_LINCN_NAM = 1;            !  Ascii Name
! 
literal NMA$C_LINSR_USR = 1;            !  User supplied
literal NMA$C_LINSR_CLI = 2;            !  Class I
! 
literal NMA$C_LINSWI_DIS = 1;           !  Switch disabled
literal NMA$C_LINSWI_ENA = 0;           !  Switch enabled
! 
literal NMA$C_LINRPE_ON = 1;            !  Ring purge on
literal NMA$C_LINRPE_OFF = 0;           !  Ring purge off
! 	
literal NMA$C_LINHNG_DIS = 1;           !  Hangup disabled
literal NMA$C_LINHNG_ENA = 0;           !  Hangup enabled
! 	
literal NMA$C_LINRES_DIS = 1;           !  Restart disabled
literal NMA$C_LINRES_ENA = 0;           !  Restart enabled
! 
literal NMA$C_LINTY_POI = 0;            !  DDCMP Point 
literal NMA$C_LINTY_CON = 1;            !  DDCMP Controller 
literal NMA$C_LINTY_TRI = 2;            !  DDCMP Tributary 
literal NMA$C_LINTY_DMC = 3;            !  DDCMP DMC compatibility mode (DMP) 
! 
literal NMA$C_LINMC_SET = 1;            !  Set address(es) 
literal NMA$C_LINMC_CLR = 2;            !  Clear address(es) 
literal NMA$C_LINMC_CAL = 3;            !  Clear entire list of multicast addresses 
literal NMA$C_LINMC_SDF = 4;            !  Set physical address to DECnet default 
! 
literal NMA$C_LINDAT_UNK = 0;           !  Unknown
literal NMA$C_LINDAT_SUC = 1;           !  Success
literal NMA$C_LINDAT_DUP = 2;           !  Duplicate
! 
literal NMA$C_LINUN_DAT_UNK = 0;        !  Unknown
literal NMA$C_LINUN_DAT_SUC = 1;        !  Success
literal NMA$C_LINUN_DAT_DUP = 2;        !  Duplicate
! 
literal NMA$C_LINRPS_OFF = 0;           !  Off
literal NMA$C_LINRPS_CAN = 1;           !  Candidate
literal NMA$C_LINRPS_NON = 2;           !  Non-purger
literal NMA$C_LINRPS_PUR = 3;           !  Purger
! 
literal NMA$C_LINRER_NOE = 0;           !  No error
literal NMA$C_LINRER_RII = 5;           !  Ring init initiated
literal NMA$C_LINRER_RIR = 6;           !  Ring init received
literal NMA$C_LINRER_RBI = 7;           !  Ring beaconing initiated
literal NMA$C_LINRER_DAD = 8;           !  Duplicate address detected
literal NMA$C_LINRER_DTD = 9;           !  Duplicate token detected
literal NMA$C_LINRER_RPE = 10;          !  Ring purge error
literal NMA$C_LINRER_FSE = 11;          !  FCI strip error
literal NMA$C_LINRER_ROC = 12;          !  Ring OP oscillation
literal NMA$C_LINRER_DBR = 13;          !  Directed beacon received
literal NMA$C_LINRER_PCTI = 14;         !  PC trace initiated
literal NMA$C_LINRER_PCTR = 15;         !  PC trace received
! 
literal NMA$C_LINNBR_PHY_A = 0;         !  A
literal NMA$C_LINNBR_PHY_B = 1;         !  B
literal NMA$C_LINNBR_PHY_S = 2;         !  S
literal NMA$C_LINNBR_PHY_M = 3;         !  M
literal NMA$C_LINNBR_PHY_U = 4;         !  Unknown
! 
literal NMA$C_LINRJR_NON = 0;           !  None
literal NMA$C_LINRJR_LLCT = 1;          !  Local LCT
literal NMA$C_LINRJR_RLCT = 2;          !  Remote LCT
literal NMA$C_LINRJR_LCTB = 3;          !  LCT both sides
literal NMA$C_LINRJR_LEM = 4;           !  LEM reject
literal NMA$C_LINRJR_TOP = 5;           !  Topology error
literal NMA$C_LINRJR_NRJ = 6;           !  Noise reject 
literal NMA$C_LINRJR_RRJ = 7;           !  Remote reject
literal NMA$C_LINRJR_TIP = 8;           !  Trace in progress
literal NMA$C_LINRJR_TRD = 9;           !  Trace received-disabled
literal NMA$C_LINRJR_STA = 10;          !  Standby
literal NMA$C_LINRJR_LCTE = 11;         !  LCT protocol error
! 
literal NMA$C_ACC_SHR = 1;              !  Shared access (default protocol user) 
literal NMA$C_ACC_LIM = 2;              !  Limited access (point-to-point conn.) 
literal NMA$C_ACC_EXC = 3;              !  Exclusive access (allow no others) 
! 
literal NMA$C_LINMO_AUT = 1;            !  Auto address mode 
literal NMA$C_LINMO_SIL = 2;            !  Silo address mode 
! 
literal NMA$C_X25MD_DTE = 1;            !  line operates as DTE 
literal NMA$C_X25MD_DCE = 2;            !  line operates as DCE 
literal NMA$C_X25MD_DTL = 3;            !  line is a DTE in loopback 
literal NMA$C_X25MD_DCL = 4;            !  line is a DCE in loopback 
literal nma$c_x25md_neg = 5;            !  line negotiates mode of operation
! 
literal nma$c_x25red_busy = 0;          !  redirected beacuse DTE was Busy
literal nma$c_x25red_out_of_order = 1;  !  redirected beacuse DTE was out of order
literal nma$c_x25red_systematic = 2;    !  redirected systematically
! 
literal NMA$C_NODTY_ROU = 0;            !  Routing Phase III 
literal NMA$C_NODTY_NON = 1;            !  Nonrouting Phase III 
literal NMA$C_NODTY_PHA = 2;            !  Phase II 
literal NMA$C_NODTY_AREA = 3;           !  Area 
literal NMA$C_NODTY_RT4 = 4;            !  Routing Phase IV 
literal NMA$C_NODTY_NR4 = 5;            !  Nonrouting Phase IV 
! 
literal NMA$C_NODINB_ROUT = 1;          !  Router
literal NMA$C_NODINB_ENDN = 2;          !  Endnode
! 
literal NMA$C_NODPW_SET = 0;            !  Password set 
! 
literal NMA$C_CPU_8 = 0;                !  PDP-8 processor 
literal NMA$C_CPU_11 = 1;               !  PDP-11 processor 
literal NMA$C_CPU_1020 = 2;             !  Decsystem 10/20 processor 
literal NMA$C_CPU_VAX = 3;              !  Vax processor 
! 
literal NMA$C_NODSNV_PH3 = 0;           !  Phase III 
literal NMA$C_NODSNV_PH4 = 1;           !  Phase IV 
! 
literal NMA$C_SOFT_SECL = 0;            !  Secondary loader 
literal NMA$C_SOFT_TERL = 1;            !  Tertiary loader 
literal NMA$C_SOFT_OSYS = 2;            !  Operating system 
literal NMA$C_SOFT_DIAG = 3;            !  Diagnostics 
! 
literal NMA$C_ACES_NONE = 0;            !  None 
literal NMA$C_ACES_INCO = 1;            !  Incoming 
literal NMA$C_ACES_OUTG = 2;            !  Outgoing 
literal NMA$C_ACES_BOTH = 3;            !  Both 
literal NMA$C_ACES_REQU = 4;            !  Required 
! 
literal NMA$C_ALIINC_ENA = 0;           !  Enabled
literal NMA$C_ALIINC_DIS = 1;           !  Disabled
! 
literal NMA$C_ALOUT_ENA = 0;            !  Enabled
literal NMA$C_ALOUT_DIS = 1;            !  Disabled
! 
literal NMA$C_ALINC_ENA = 0;            !  Enabled
literal NMA$C_ALINC_DIS = 1;            !  Disabled
! 
literal NMA$C_PRXY_ENA = 0;             !  Enabled
literal NMA$C_PRXY_DIS = 1;             !  Disabled
! 
literal NMA$C_PSPCY_NOR = 0;            !  Normal
literal NMA$C_PSPCY_INT = 1;            !  Interim
! 
literal NMA$C_XPRTY_BIL = 1;            !  Bilateral 
! 
literal NMA$C_XPRST_ON = 0;             !  On 
literal NMA$C_XPRST_OFF = 1;            !  Off 
literal NMA$C_XPRST_SHU = 2;            !  Shut 
! 
literal NMA$C_XPRMN_ENA = 0;            !  Enabled 
literal NMA$C_XPRMN_DIS = 1;            !  Disabled 
! 
literal NMA$C_XPRSB_RUN = 12;           !  Running 
literal NMA$C_XPRSB_UNS = 13;           !  Unsynchronized 
literal NMA$C_XPRSB_SYN = 10;           !  Synchronizing 
! 
literal NMA$C_Clear_String = 0;         ! Clear string value
literal NMA$C_Clear_Longword = -1;      ! Clear longword value
literal NMA$C_CAL_CLR = 0;              ! Call clear
literal NMA$C_CAL_NOW = 1;              ! Call now
literal NMA$C_DAY_ALL = 0;
literal NMA$C_DAY_MON = 1;
literal NMA$C_DAY_TUE = 2;
literal NMA$C_DAY_WED = 3;
literal NMA$C_DAY_THU = 4;
literal NMA$C_DAY_FRI = 5;
literal NMA$C_DAY_SAT = 6;
literal NMA$C_DAY_SUN = 7;
literal NMA$C_TIC_No_Cut = 0;           ! Inhibit timecutting
literal NMA$C_TIC_Cut = 1;              ! Perform Timecutting
literal NMA$C_CSG_No_Signal = 0;        ! Inhibit call-signal data
literal NMA$c_CSG_Signal = 1;           ! Send call-signal data
literal NMA$c_IRC_DIS = 0;              ! Incoming Reverse Disable
literal NMA$c_IRC_ENA = 1;              ! Incoming Reverse Enable
literal NMA$c_ORC_DIS = 0;              ! Outgoing Reverse Enable
literal NMA$c_ORC_ENA = 1;              ! Outgoing Reverse Disable
literal NMA$c_RED_DIS = 0;              ! Redirect Enable
literal NMA$c_RED_ENA = 1;              ! Redirect Disable
literal NMA$c_MOD_NOAUTO = 0;           ! Mode AUTO time-cutting
literal NMA$c_MOD_AUTO = 1;             ! Mode non-auto time-cutting
literal NMA$c_SWC_DIS = 0;              ! Enable switched mode
literal NMA$c_SWC_ENA = 1;              ! Set line for Leased operation
literal NMA$c_MDM_OFF = 0;              ! Enable modem signals
literal NMA$c_MDM_ON = 1;               ! Disable modem signals
literal NMA$c_DTS_NO_CABLE = 1;         ! DTE does not have X21 cable
literal NMA$c_DTS_NO_X21_CABLE = 2;     ! DTE has none-X21 cable.
literal NMA$c_DTS_READY = 3;            ! DCE is not ready
literal NMA$c_DTS_NOT_READY = 4;        ! DTE is signalling Not-Ready to network.
literal NMA$c_DTS_ACTIVE = 5;           ! DTE in normal working mode.
literal NMA$c_DTS_NO_OUTGOING = 6;      ! Outgoing calls prohibitedin normal working mode.
literal NMA$c_CAS_NONE = 1;             ! Call-Status - No call active
literal NMA$c_CAS_OUT = 2;              ! Outgoing call active
literal NMA$c_CAS_IN = 3;               ! Incoming call active
literal NMA$c_CAS_OUT_R = 4;            ! Outgoing reverse active
literal NMA$c_CAS_IN_R = 5;             ! Incoming reverse active
literal NMA$c_DTL_ACCEPT = 1;           ! Accept call from
literal NMA$c_DTL_REJECT = 2;           ! Reject call from
literal NMA$C_CAC_MAN = 1;              ! X21 controls connect/accept
literal NMA$C_CAC_AUTO_CONNECT = 2;     ! Driver connects automatically
literal NMA$C_CAC_AUTO_ACCEPT = 3;      ! Enhanced subaddressing
! 
literal NMA$C_JAN = 1;
literal NMA$C_FEB = 2;
literal NMA$C_MAR = 3;
literal NMA$C_APR = 4;
literal NMA$C_MAY = 5;
literal NMA$C_JUN = 6;
literal NMA$C_JUL = 7;
literal NMA$C_AUG = 8;
literal NMA$C_SEP = 9;
literal NMA$C_OCT = 10;
literal NMA$C_NOV = 11;
literal NMA$C_DEC = 12;
! 
literal NMA$C_SOFD_DP = 0;              !  DP11-DA (OBSOLETE)
literal NMA$C_SOFD_UNA = 1;             !  DEUNA UNIBUS CSMA/CD communication link
literal NMA$C_SOFD_DU = 2;              !  DU11-DA synchronous line interface
literal NMA$C_SOFD_CNA = 3;             !  DECNA CSMA/CD communication link
literal NMA$C_SOFD_DL = 4;              !  DL11-C, -E, or -WA synchronous line interface
literal NMA$C_SOFD_QNA = 5;             !  DEQNA CSMA/CD communication link
literal NMA$C_SOFD_DQ = 6;              !  DQ11-DA (OBSOLETE)
literal NMA$C_SOFD_CI = 7;              !  Computer Interconnect Interface
literal NMA$C_SOFD_DA = 8;              !  DA11-B or -AL UNIBUS link
literal NMA$C_SOFD_PCL = 9;             !  PCL11-B multiple CPU link
literal NMA$C_SOFD_DUP = 10;            !  DUP11-DA synchronous line interface
literal NMA$C_SOFD_LUA = 11;            !  DELUA CSMA/CD communication link
literal NMA$C_SOFD_DMC = 12;            !  DMC11-DA/AR, -FA/AR, -MA/AL or -MD/AL interprocessor link
literal NMA$C_SOFD_LNA = 13;            !  MicroServer Lance CSMA/CD communication link
literal NMA$C_SOFD_DN = 14;             !  DN11-BA or -AA automatic calling unit
literal NMA$C_SOFD_DLV = 16;            !  DLV11-E, -F, -J, MXV11-A or -B asynchronous line
literal NMA$C_SOFD_LCS = 17;            !  Lance/Decserver 100 CSMA/CD communication link
literal NMA$C_SOFD_DMP = 18;            !  DMP11 multipoint interprocessor link
literal NMA$C_SOFD_AMB = 19;            !  AMBER (OBSOLETE)
literal NMA$C_SOFD_DTE = 20;            !  DTE20 PDP-11 to KL10 interface
literal NMA$C_SOFD_DBT = 21;            !  DEBET CSMA/CD communication link
literal NMA$C_SOFD_DV = 22;             !  DV11-AA/BA synchronous line multiplexer
literal NMA$C_SOFD_BNA = 23;            !  DEBNA BI CSMA/CD communication link
literal NMA$C_SOFD_BNT = 23;            !  DEBNT **obsolete**
literal NMA$C_SOFD_DZ = 24;             !  DZ11-A, -B, -C, -D asynchronous line multiplexer
literal NMA$C_SOFD_LPC = 25;            !  LANCE/PCXX CSMA/CD communication link
literal NMA$C_SOFD_DSV = 26;            !  DSV11 Q-bus synchronous link
literal NMA$C_SOFD_CEC = 27;            !  3-COM/IBM-PC CSMA/CD communication link
literal NMA$C_SOFD_KDP = 28;            !  KMC11/DUP11-DA synchronous line multiplexer
literal NMA$C_SOFD_IEC = 29;            !  Interlan/IBM-PC CSMA/CD communication link
literal NMA$C_SOFD_KDZ = 30;            !  KMC11/DZ11-A, -B, -C, or -D asynchronous line multiplexer
literal NMA$C_SOFD_UEC = 31;            !  Univation/RAINBOW-100 CSMA/CD communication link
literal NMA$C_SOFD_KL8 = 32;            !  KL8-J (OBSOLETE)
literal NMA$C_SOFD_DS2 = 33;            !  LANCE/DECserver 200 CSMA/CD communication link
literal NMA$C_SOFD_DMV = 34;            !  DMV11 interprocessor link 
literal NMA$C_SOFD_DS5 = 35;            !  DECserver 500 CSMA/CD communication link
literal NMA$C_SOFD_DPV = 36;            !  DPV11 synchronous line interface
literal NMA$C_SOFD_LQA = 37;            !  DELQA CSMA/CD communication link
literal NMA$C_SOFD_DMF = 38;            !  DMF32 synchronous line unit
literal NMA$C_SOFD_SVA = 39;            !  DESVA CSMA/CD communication link
literal NMA$C_SOFD_DMR = 40;            !  DMR11-AA, -AB, -AC, or -AE interprocessor link
literal NMA$C_SOFD_MUX = 41;            !  MUXserver 100 CSMA/CD communication link
literal NMA$C_SOFD_KMY = 42;            !  KMS11-PX synchronous line interface with X.25 Level 2 microcode
literal NMA$C_SOFD_DEP = 43;            !  DEPCA PCSG/IBM-PC CSMA/CD communication link
literal NMA$C_SOFD_KMX = 44;            !  KMS11-BD/BE synchronous line interface with X.25 Level 2 microcode
literal NMA$C_SOFD_LTM = 45;            !  LTM (911) Ethernet monitor
literal NMA$C_SOFD_DMB = 46;            !  DMB-32 BI synchronous line multiplexer
literal NMA$C_SOFD_DES = 47;            !  DESNC Ethernet Encryption Module
literal NMA$C_SOFD_KCP = 48;            !  KCP synchronous/asynchronous line
literal NMA$C_SOFD_MX3 = 49;            !  MUXServer 300 CSMA/CD communication link 
literal NMA$C_SOFD_SYN = 50;            !  MicroServer synchronous line interface
literal NMA$C_SOFD_MEB = 51;            !  DEMEB multiport bridge CSMA/CD communication link 
literal NMA$C_SOFD_DSB = 52;            !  DSB32 BI synchronous line interface
literal NMA$C_SOFD_BAM = 53;            !  DEBAM LANBridge-200 Data Link 
literal NMA$C_SOFD_DST = 54;            !  DST-32 TEAMmate synchronous line interface (DEC423)
literal NMA$C_SOFD_FAT = 55;            !  DEFAT DataKit Server CSMA/CD communication link 
literal NMA$C_SOFD_RSM = 56;            !  DERSM - Remote Segment Monitor 
literal NMA$C_SOFD_RES = 57;            !  DERES - Remote Environmental Sensor 
literal NMA$C_SOFD_3C2 = 58;            !  3COM Etherlink II (part number 3C503) 
literal NMA$C_SOFD_3CM = 59;            !  3COM Etherlink/MC (part number 3C523) 
literal NMA$C_SOFD_DS3 = 60;            !  DECServer 300 CSMA/CD communication link 
literal NMA$C_SOFD_MF2 = 61;            !  Mayfair-2 CSMA/CD communication link 
literal NMA$C_SOFD_MMR = 62;            !  DEMMR Ethernet Multiport Manageable Repeater 
literal NMA$C_SOFD_VIT = 63;            !  Vitalink TransLAN III/IV (NP3A) Bridge 
literal NMA$C_SOFD_VT5 = 64;            !  Vitalink TransLAN 350 (NPC25) Bridge 
literal NMA$C_SOFD_BNI = 65;            !  DEBNI BI CSMA/CD communication link 
literal NMA$C_SOFD_MNA = 66;            !  DEMNA XMI CSMA/CD communication link 
literal NMA$C_SOFD_PMX = 67;            !  PMAX (KN01) CSMA/CD communication link 
literal NMA$C_SOFD_NI5 = 68;            !  Interlan NI5210-8 CSMA/CD comm link for IBM PC XT/AT 
literal NMA$C_SOFD_NI9 = 69;            !  Interlan NI9210 CSMA/CD comm link for IBM PS/2 
literal NMA$C_SOFD_KMK = 70;            !  KMS11-K DataKit UNIBUS adapter 
literal NMA$C_SOFD_3CP = 71;            !  Etherlink Plus (part number 3C505) 
literal NMA$C_SOFD_DP2 = 72;            !  DPNserver-200 CSMA/CD communication link 
literal NMA$C_SOFD_ISA = 73;            !  SGEC CSMA/CD communication link 
literal NMA$C_SOFD_DIV = 74;            !  DIV-32 DEC WAN controller-100
literal NMA$C_SOFD_QTA = 75;            !  DEQTA CSMA/CD communication link
literal NMA$C_SOFD_B15 = 76;            !  LANbridge-150 CSMA/CD communication link
literal NMA$C_SOFD_WD8 = 77;            !  WD8003 Family CSMA/CD communication link
literal NMA$C_SOFD_ILA = 78;            !  BICC ISOLAN 4110-2 PC/AT CSMA/CD communication link
literal NMA$C_SOFD_ILM = 79;            !  BICC ISOLAN 4110-3 PC MicroChannel CSMA/CD comm link
literal NMA$C_SOFD_APR = 80;            !  Apricot Xen-S and Qi CSMA/CD adapter
literal NMA$C_SOFD_ASN = 81;            !  AST EtherNode CSMA/CD communication link
literal NMA$C_SOFD_ASE = 82;            !  AST Ethernet CSMA/CD communication link
literal NMA$C_SOFD_TRW = 83;            !  TRW HC-2001 CSMA/CD communication link
literal NMA$C_SOFD_EDX = 84;            !  Ethernet-XT/AT CSMA/CD communication link
literal NMA$C_SOFD_EDA = 85;            !  Ethernet-AT CSMA/CD communication link
literal NMA$C_SOFD_DR2 = 86;            !  DECrouter-250 CSMA/CD communication link
literal NMA$C_SOFD_SCC = 87;            !  DECrouter-250 DUSCC serial comm link (DDCMP or HDLC)
literal NMA$C_SOFD_DCA = 88;            !  DCA Series 300 Net Processor CSMA/CD communication link
literal NMA$C_SOFD_TIA = 89;            !  LANcard/E CSMA/CD controllers
literal NMA$C_SOFD_FBN = 90;            !  DEFEB DECbridge-500 CSMA/CD communication link
literal NMA$C_SOFD_FEB = 91;            !  DEFEB DECbridge-500 FDDI communication link
literal NMA$C_SOFD_FCN = 92;            !  DEFCN DECconcentrator-500 wiring concentrator FDDI comm link
literal NMA$C_SOFD_MFA = 93;            !  DEMFA FDDI communication link
literal NMA$C_SOFD_MXE = 94;            !  MIPS workstation family CSMA/CD communication links
literal NMA$C_SOFD_CED = 95;            !  Cabletron Ethernet Desktop Network Interface CSMA/CD comm link
literal NMA$C_SOFD_C20 = 96;            !  3Com CS/200 terminal server CSMA/CD comm link
literal NMA$C_SOFD_CS1 = 97;            !  3Com CS/1 terminal server CSMA/CD comm link
literal NMA$C_SOFD_C2M = 98;            !  3Com CS/210, CS/2000, CS/2100 terminal server CSMA/CD comm link
literal NMA$C_SOFD_ACA = 99;            !  ACA/32000 system CSMA/CD comm link
literal NMA$C_SOFD_GSM = 100;           !  Gandalf StarMaster CSMA/CD comm link
literal NMA$C_SOFD_DSF = 101;           !  DSF32 2 line sync comm link for Cirrus
literal NMA$C_SOFD_CS5 = 102;           !  3Com CS/50 terminal server CSMA/CD comm link
literal NMA$C_SOFD_XIR = 103;           !  XIRCOM PE10B2 CSMA/CD comm link
literal NMA$C_SOFD_KFE = 104;           !  KFE52 CSMA/CD comm link for Cirrus
literal NMA$C_SOFD_RT3 = 105;           !  rtVAX-300 SGEC-based CSMA/CD comm link
literal NMA$C_SOFD_SPI = 106;           !  Spiderport M250 terminal server CSMA/CD comm link
literal NMA$C_SOFD_FOR = 107;           !  LAT gateway CSMA/CD comm link
literal NMA$C_SOFD_MER = 108;           !  Meridian CSMA/CD comm link drivers
literal NMA$C_SOFD_PER = 109;           !  Persoft CSMA/CD comm link drivers
literal NMA$C_SOFD_STR = 110;           !  AT&T StarLan-10 twisted pair comm link
literal NMA$C_SOFD_MPS = 111;           !  MIPSfair SGEC CSMA/CD comm link
literal NMA$C_SOFD_L20 = 112;           !  LPS20 print server CSMA/CD comm link
literal NMA$C_SOFD_VT2 = 113;           !  Vitalink TransLAN 320 Bridge
literal NMA$C_SOFD_DWT = 114;           !  VT-1000 DECwindows terminal
literal NMA$C_SOFD_WGB = 115;           !  DEWGB Work Group Bridge CSMA/CD comm link
literal NMA$C_SOFD_ZEN = 116;           !  Zenith Z-LAN4000 XT, AT and MicroChannel Z-LAN comm link
literal NMA$C_SOFD_TSS = 117;           !  Thursby Software Systems CSMA/CD comm link drivers
literal NMA$C_SOFD_MNE = 118;           !  3MIN (KN02-BA) integral CSMA/CD comm link
literal NMA$C_SOFD_FZA = 119;           !  DEFZA TurboChannel FDDI comm link
literal NMA$C_SOFD_90L = 120;           !  DS90L terminal server CSMA/CD comm link
literal NMA$C_SOFD_CIS = 121;           !  Cisco Systems terminal servers CSMA/CD comm link
literal NMA$C_SOFD_STC = 122;           !  STRTC terminal servers
literal NMA$C_SOFD_UBE = 123;           !  Ungermann-Bass PC2030, PC3030 CSMA/CD comm link
literal NMA$C_SOFD_DW2 = 124;           !  DECwindows terminal II CSMA/CD comm link
literal NMA$C_SOFD_FUE = 125;           !  Fujitsu Etherstar MB86950 CSMA/CD comm link
literal NMA$C_SOFD_M38 = 126;           !  MUXServer 380 CSMA/CD comm link
literal NMA$C_SOFD_NTI = 127;           !  NTI Group PC Ethernet Card CSMA/CD comm link
literal NMA$C_SOFD_RAD = 130;           !  RADLINX LAN Gateway CSMA/CD comm link
literal NMA$C_SOFD_INF = 131;           !  Infotron Commix series terminal server CSMA/CD comm link
literal NMA$C_SOFD_XMX = 132;           !  Xyplex MAXserver series terminal server CSMA/CD comm link
literal NMA$C_SOFD_NDI = 133;           !  NDIS data link driver for MS/DOS systems CSMA/CD comm link
literal NMA$C_SOFD_ND2 = 134;           !  NDIS data link driver for OS/2 systems CSMA/CD comm link
literal NMA$C_SOFD_TRN = 135;           !  DEC LANcontroller 520 Token Ring comm link 
literal NMA$C_SOFD_DEV = 136;           !  Develcon Electronics Ltd. LAT gateway CSMA/CD comm link
literal NMA$C_SOFD_ACE = 137;           !  Acer 5220, 5270 adapter CSMA/CD comm link
literal NMA$C_SOFD_PNT = 138;           !  ProNet-4/18 #1390 802.5 comm link
literal NMA$C_SOFD_ISE = 139;           !  Network Integration Server 600 CSMA/CD line card
literal NMA$C_SOFD_IST = 140;           !  Network Integration Server 600 T1 sync line card
literal NMA$C_SOFD_ISH = 141;           !  Network Integration Server 64 kb HDLC line card
literal NMA$C_SOFD_ISF = 142;           !  Network Integration Server 600 FDDI line card
literal NMA$C_SOFD_DSW = 149;           !  DSW-21 single line serial comm link
literal NMA$C_SOFD_DW4 = 150;           !  DSW-41/42 single/dual line serial comm link
! 
literal NMA$_SUCCESS = 1;               !  Unqualified success 
literal NMA$_SUCCFLDRPL = 9;            !  Success with field replaced 
literal NMA$_BADFID = 0;                !  Invalid field id code 
literal NMA$_BADDAT = 8;                !  Invalid data format 
literal NMA$_BADOPR = 16;               !  Invalid operation 
literal NMA$_BUFTOOSMALL = 24;          !  Buffer too small 
literal NMA$_FLDNOTFND = 32;            !  Field not found 
! 
literal NMA$C_OPN_MIN = 0;              !  Minimum ! 
literal NMA$C_OPN_NODE = 0;             !  Nodes 
literal NMA$C_OPN_LINE = 1;             !  Lines 
literal NMA$C_OPN_LOG = 2;              !  Logging 
literal NMA$C_OPN_OBJ = 3;              !  Object 
literal NMA$C_OPN_CIR = 4;              !  Circuit 
literal NMA$C_OPN_X25 = 5;              !  Module X25 
literal NMA$C_OPN_X29 = 6;              !  Module X29 
literal NMA$C_OPN_CNF = 7;              !  Module Configurator 
literal NMA$C_OPN_MAX = 7;              !  Maximum ! permanent database files 
literal NMA$C_OPN_ALL = 127;            !  All opened files 
! 
literal NMA$C_OPN_AC_RO = 0;            !  Read Only 
literal NMA$C_OPN_AC_RW = 1;            !  Read write 
! 
literal NMA$C_FN2_DLL = 2;              !  Down line load 
literal NMA$C_FN2_ULD = 3;              !  Upline Dump 
literal NMA$C_FN2_TRI = 4;              !  Trigger remote bootstrap 
literal NMA$C_FN2_LOO = 5;              !  Loop back test 
literal NMA$C_FN2_TES = 6;              !  Send test message to be looped 
literal NMA$C_FN2_SET = 7;              !  Set parameter 
literal NMA$C_FN2_REA = 8;              !  Read Parameter 
literal NMA$C_FN2_ZER = 9;              !  Zero counters 
literal NMA$C_FN2_LNS = 14;             !  Line service 
! 
literal NMA$C_OP2_CHNST = 5;            !  Node operational status 
literal NMA$C_OP2_CHLST = 8;            !  Line operational status 
! 
literal NMA$C_OP2_RENCT = 0;            !  Local node counters 
literal NMA$C_OP2_RENST = 1;            !  local node status 
literal NMA$C_OP2_RELCT = 4;            !  Line counters 
literal NMA$C_OP2_RELST = 5;            !  Line status 
! 
literal NMA$C_OP2_ZENCT = 0;            !  Local Node counters 
literal NMA$C_OP2_ZELCT = 2;            !  Line counters 
! 
literal NMA$C_EN2_KNO = 0;              !  Known lines 
literal NMA$C_EN2_LID = 1;              !  Line id 
literal NMA$C_EN2_LCN = 2;              !  Line convenience name 
! 
literal NMA$C_STS_SUC = 1;              !  Success 
literal NMA$C_STS_MOR = 2;              !  Request accepted, more to come 
literal NMA$C_STS_PAR = 3;              !  Partial reply 
! 
literal NMA$C_STS_DON = -128;           !  Done 
! 
literal NMA$C_STS_FUN = -1;             !  Unrecognized function or option 
literal NMA$C_STS_INV = -2;             !  Invalid message format 
literal NMA$C_STS_PRI = -3;             !  Privilege violation 
literal NMA$C_STS_SIZ = -4;             !  Oversized management command message 
literal NMA$C_STS_MPR = -5;             !  Network management program error 
literal NMA$C_STS_PTY = -6;             !  Unrecognized parameter type 
literal NMA$C_STS_MVE = -7;             !  Incompatible management version 
literal NMA$C_STS_CMP = -8;             !  Unrecognised component 
literal NMA$C_STS_IDE = -9;             !  Invalid identification format 
literal NMA$C_STS_LCO = -10;            !  Line communication error 
literal NMA$C_STS_STA = -11;            !  Component in wrong state 
literal NMA$C_STS_FOP = -13;            !  File open error 
literal NMA$C_STS_FCO = -14;            !  Invalid file contents 
literal NMA$C_STS_RES = -15;            !  Resource error 
literal NMA$C_STS_PVA = -16;            !  Invalid parameter value 
literal NMA$C_STS_LPR = -17;            !  Line protocol error 
literal NMA$C_STS_FIO = -18;            !  File i/o error 
literal NMA$C_STS_MLD = -19;            !  Mirror link disconnected 
literal NMA$C_STS_ROO = -20;            !  No room for new entry 
literal NMA$C_STS_MCF = -21;            !  Mirror connect failed 
literal NMA$C_STS_PNA = -22;            !  Parameter not applicable 
literal NMA$C_STS_PLO = -23;            !  Parameter value too long 
literal NMA$C_STS_HAR = -24;            !  Hardware failure 
literal NMA$C_STS_OPE = -25;            !  Operation failure 
literal NMA$C_STS_SYS = -26;            !  System-specific management 
!  function not supported
literal NMA$C_STS_PGP = -27;            !  Invalid parameter grouping 
literal NMA$C_STS_BLR = -28;            !  Bad loopback response 
literal NMA$C_STS_PMS = -29;            !  Parameter missing 
! 
literal NMA$C_STS_ALI = -127;           !  Invalid alias identification 
literal NMA$C_STS_OBJ = -126;           !  Invalid object identification 
literal NMA$C_STS_PRO = -125;           !  Invalid process identification 
literal NMA$C_STS_LNK = -124;           !  Invalid link identification 
! 
literal NMA$C_FOPDTL_PDB = 0;           !  Permanent database 
literal NMA$C_FOPDTL_LFL = 1;           !  Load file 
literal NMA$C_FOPDTL_DFL = 2;           !  Dump file 
literal NMA$C_FOPDTL_SLF = 3;           !  Secondary loader 
literal NMA$C_FOPDTL_TLF = 4;           !  Tertiary loader 
literal NMA$C_FOPDTL_SDF = 5;           !  Secondary dumper 
literal NMA$C_FOPDTL_PDR = 6;           !  Permanent Database,on remote node
literal NMA$C_FOPDTL_MFL = 7;           !  Management file
! 
literal NMA$C_NCEDTL_NNA = 0;           !  No node name set 
literal NMA$C_NCEDTL_INN = 1;           !  Invalid node name format 
literal NMA$C_NCEDTL_UNA = 2;           !  Unrecognised node name 
literal NMA$C_NCEDTL_UNR = 3;           !  Node unreachable 
literal NMA$C_NCEDTL_RSC = 4;           !  Network resources 
literal NMA$C_NCEDTL_RJC = 5;           !  Rejected by object 
literal NMA$C_NCEDTL_ONA = 6;           !  Invalid object name format 
literal NMA$C_NCEDTL_OBJ = 7;           !  Unrecognised object 
literal NMA$C_NCEDTL_ACC = 8;           !  Access control rejected 
literal NMA$C_NCEDTL_BSY = 9;           !  Object too busy 
literal NMA$C_NCEDTL_NRS = 10;          !  No response from object 
literal NMA$C_NCEDTL_NSD = 11;          !  Node shut down 
literal NMA$C_NCEDTL_DIE = 12;          !  Node or object failed 
literal NMA$C_NCEDTL_DIS = 13;          !  Disconnect by object 
literal NMA$C_NCEDTL_ABO = 14;          !  Abort by object 
literal NMA$C_NCEDTL_ABM = 15;          !  Abort by management 
! 
literal NMA$C_OPEDTL_DCH = 0;           ! 	Data check
literal NMA$C_OPEDTL_TIM = 1;           ! 	Timeout
literal NMA$C_OPEDTL_ORN = 2;           ! 	Data overrun
literal NMA$C_OPEDTL_ACT = 3;           ! 	Unit is active
literal NMA$C_OPEDTL_BAF = 4;           ! 	Buffer allocation failure
literal NMA$C_OPEDTL_RUN = 5;           ! 	Protocol running
literal NMA$C_OPEDTL_DSC = 6;           ! 	Line disconnected
literal NMA$C_OPEDTL_FTL = 8;           ! 	Fatal hardware error
literal NMA$C_OPEDTL_MNT = 11;          ! 	DDCMP maintainance message received
literal NMA$C_OPEDTL_LST = 12;          ! 	Data lost due to buffer size mismatch
literal NMA$C_OPEDTL_THR = 13;          ! 	Threshold error
literal NMA$C_OPEDTL_TRB = 14;          ! 	Tributary malfunction
literal NMA$C_OPEDTL_STA = 15;          ! 	DDCMP start message received
literal NMA$S_NMADEF7 = 1;
macro NMA$V_CTLIN_TUN = 0,2,1,0 %;      !  transmit underrun 
macro NMA$V_CTLIN_RUN = 0,4,1,0 %;      !  receive underrun 
macro NMA$V_CTLIN_FMR = 0,5,1,0 %;      !  FRMR received 
! 
!  VMS-specific line counters
! 
!         1  Message rejected
!         2  Message truncated
!         3  Receiver offline
!         4  Receiver busy
!         5  Transmitter offline
!         1  CRC error on transmit
!         2  CRC error on receive
!         3  Timeouts
!         4  Non-existant memory transmit
!         5  Non-existant memory receive
!         6  Buffer to small
!         7  Failed to open channel
!         8  Memory overflow
!         2  Now master
! 
!     Node counters
! 
!  Server Base Specific Executor Node Counters
! 
!         X.25 Protocol module counters
! 
!         X.25 Server module counters
! 
!         Coded parameter values
! 
! 
!  Loop test block type coded values
! 
!  Default values for loop functions
! 
!  Values for LOOP HELP
! 
!  State coded values
! 
!     DNS interface
! 
!     circuit/line/process specific state values
! 
!     logging specific state values
! 
!     node specific state values
! 
! 	
! 	Default value for EXECUTOR MAXIMUM ADDRESS.
! 	Note: DNA Network Management does not specify a default.
! 	      This is defined for VMS only, for compatibility with
! 	      previous releases that used a hard coded value in
! 	      [NETACP.SRC]NETCONFIG.MAR.
! 
! 
! 
!  Looper/loader assistance coded values
! 
!  Configurator surveillance coded values
! 
!  Circuit/Line substate coded values
! 
!  Circuit type coded values   [In V2, line type coded values]
! 
!         Circuit/Line Service
! 
!  Circuit polling state
! 
!  Circuit blocking values
! 
!  Circuit usage values
! 
!  Circuit parameter, Handshake Required
! 
!  Circuit maximum receive buffers
! 
!  Circuit verification    [VMS only]
! 
!  Circuit (desired) transport type    [VMS only]
! 
!  Line duplex coded values
! 
!  Line controller mode
! 
!  Line protocol values (same as CIRTY_)
! 
! 	Character encoding
! 
!  Line protocol values for the PCL-11B
! 
!  Line clock values
! 
!  Line packet format types.  Note that only the Ethernet format is allowed
!  allowed to be odd.  All other format values must be even.
! 
!  Line client name types.
! 
!  Line services
! 
!  Line Switch states
! 
!  Ring purger enable states (FDDI)
! 
!  Line Hangup state
! 
!  Line Restart state
! 
!  Line type coded values  [V2 only]
! 
!  Line multicast address function code [VMS datalink only].
!  Destination and physical address function codes too [VMS datalink only].
!                                       
!  Duplicate address flag states (FDDI)
! 
!  Upstream neighbor DA flag states (FDDI)
! 
!  Ring purger states (FDDI)
! 
!  Ring error reason states (FDDI)
! 
!  Neighbor PHY type states (FDDI)
! 
!  Reject reason states (FDDI)
! 
!  NI line protocol access mode  [VMS datalink only]
! 
!  PCL-11B address mode
! 
!  X.25 line mode
! 
!  X.25 server redirect reason
! 
!  Node type values
! 
!  Node inbound states
! 
!  Node password values
! 
!  Node CPU type codes
! 
!  Service node version coded values
! 
!  Node software type code
! 
!  Node access (and default access) codes
! 
!  Executor Alias incoming values
! 
!  Object alias outgoing
! 
!  Object alias incoming
! 
!  Executor Proxy 
! 
!  Path Split Policy
! 
!  X.25 Protocol type values
! 
!  X.25 protocol state values
! 
!  X.25 protocol multi-network support flag
! 
!  X.25 protocol DTE substate values
! 
!  X21 literals
! 	
!   Months of the Year Codes
! 
!  Service device codes (MOP)
! 
!         Status codes for field support routines
! 
!         Permanent database file ID codes
! 
!         Open access codes
! 
!         Define Phase II NICE function codes
! 
!         Change parameters (volatile only)
! 
!         Read Information (Status and Counters only)
! 
!         Zero counters
! 
!         Line entity codes
! 
!  NML Return codes
! 
!         Error details
! 
! 
!         STS_FOP and STS_FIO
! 
!         STS_MLD, STS_MCF
! 
!         STS_OPE
! 
! ********************************************************************************************************************************
!  Created  7-JUL-1992 19:29:28 by VAX SDL T3.2-8      Source: 14-NOV-1991 17:03:23 _$22$DIA9:[NETACP.SRC]NETUSR.SDL;1 
! ********************************************************************************************************************************
 
!*** MODULE NFB ***
! 
! 	The following generic field identifiers are defined for all databases.
! 
literal NFB$C_ENDOFLIST = 0;            !  Used to terminate the field i.d. 
literal NFB$C_WILDCARD = 1;             !  Field i.d. used for "match all" database searches 
literal NFB$C_CTX_SIZE = 64;            !  Length of context area in P2 buffer 
! 
! 	The following codes are passed in the second IOSB longword to qualify
! 	as SS$_ILLCNTRFUNC error.
! 
!  The high order word of these error codes must be 0 
!  so that they won't be confused with field i.d.s
literal NFB$_ERR_FCT = 1;               !  Unrecognized NFB$B_FCT value. 
literal NFB$_ERR_DB = 2;                !  Unrecognized NFB$B_DATABASE value. 
literal NFB$_ERR_P1 = 3;                !  The P1 buffer is invalid. 
literal NFB$_ERR_P2 = 4;                !  The P2 buffer is invalid. 
literal NFB$_ERR_P3 = 5;                !  The P3 buffer is invalid. 
literal NFB$_ERR_P4 = 6;                !  The P4 buffer is invalid. 
literal NFB$_ERR_P5 = 7;                !  The P5 buffer should not have been specified. 
literal NFB$_ERR_P6 = 8;                !  The P6 buffer should not have been specified. 
literal NFB$_ERR_CELL = 9;              !  Unrecognized NFB$B_CELL value. 
literal NFB$_ERR_OPER = 10;             !  Unrecognized NFB$B_OPER value. 
literal NFB$_ERR_SRCH = 11;             !  Unrecognized NFB$L_SRCH_KEY field ID 
literal NFB$_ERR_SRCH2 = 12;            !  Unrecognized NFB$L_SRCH2_KEY field ID 
literal NFB$_ERR_OPER2 = 13;            !  Unrecognized NFB$B_OPER2 value. 
literal NFB$_ERR_FLAGS = 14;            !  Undefined bits in NFB$B_FLAGS were not zero. 
literal NFB$_ERR_LOCK = 15;             !  Lock was not granted
! 
! 	Define the P1 buffer format
! 
literal NFB$C_DECLNAME = 21;            !  Declare name 
literal NFB$C_DECLOBJ = 22;             !  Declare object 
literal NFB$C_DECLSERV = 23;            !  Declare server process available 
!  Resume defining function codes 
literal NFB$C_LOGEVENT = 28;            !  Log a network event 
literal NFB$C_READEVENT = 29;           !  Read current raw event queue (used by EVL only) 
!  Resume defining function codes 
literal NFB$C_FC_DELETE = 33;           !  Remove an entry from the data base. 
literal NFB$C_FC_SHOW = 34;             !  Return specified field values. 
literal NFB$C_FC_SET = 35;              !  Set/modify the field values. 
literal NFB$C_FC_CLEAR = 36;            !  Clear specified field values. 
literal NFB$C_FC_ZERCOU = 37;           !  Zero (and optionally read) counters 
literal NFB$C_FC_LOOP = 38;             !  Loop (used only to PSI to loop an X.25 line) 
literal NFB$C_REBUILD_PROXY = 39;       !  Rebuild the proxy data base
literal NFB$C_ADD_PROXY = 40;           !  Add/Modify proxy DB entry
literal NFB$C_DELETE_PROXY = 41;        !  Remove/Delete proxy access
!  Maximum FCT value 
literal NFB$C_FC_MAX = 41;              !  Maximum FCT value 
literal NFB$M_ERRUPD = 1;
literal NFB$M_MULT = 2;
literal NFB$M_NOCTX = 4;
literal NFB$M_LOCAL = 8;
literal NFB$C_DB_LNI = 1;               !  Local node 
literal NFB$C_DB_NDI = 2;               !  Common nodes 
literal NFB$C_DB_OBI = 3;               !  Network objects 
literal NFB$C_DB_CRI = 4;               !  Circuits 
literal NFB$C_DB_PLI = 5;               !  Lines 
literal NFB$C_DB_EFI = 6;               !  Event logging filters 
literal NFB$C_DB_ESI = 7;               !  Event logging sinks 
literal NFB$C_DB_LLI = 8;               !  Logical-links 
literal NFB$C_DB_XNI = 9;               !  X.25 networks 
literal NFB$C_DB_XGI = 10;              !  X.25 groups 
literal NFB$C_DB_XDI = 11;              !  X.25 DTEs 
literal NFB$C_DB_XS5 = 12;              !  X.25 server 
literal NFB$C_DB_XD5 = 13;              !  X.25 destinations 
literal NFB$C_DB_XS9 = 14;              !  X.29 server 
literal NFB$C_DB_XD9 = 15;              !  X.29 destinations 
literal NFB$C_DB_XTI = 16;              !  X.25 trace facility 
literal NFB$C_DB_XTT = 17;              !  X.25 tracepoints 
literal NFB$C_DB_SPI = 18;              !  Server Process 
literal NFB$C_DB_AJI = 19;              !  Adjacency information 
literal NFB$C_DB_ARI = 20;              !  Area information 
!  (The following codes are reserved for future PSIACP
!   databases.  These codes should only be used in the
!   event PSIACP needs a database code before a new
!   new NETACP can be supplied to support it).
literal NFB$C_DB_XDTE = 21;             !  PSI reserved database 
literal NFB$C_DB_PSI2 = 22;             !  PSI reserved database 
literal NFB$C_DB_PSI3 = 23;             !  PSI reserved database 
literal NFB$C_DB_PSI4 = 24;             !  PSI reserved database 
literal NFB$C_DB_PSI5 = 25;             !  PSI reserved database 
literal NFB$C_DB_SDI = 26;              !  Service (DLE) information 
literal NFB$C_DB_XAI = 27;              !  X.25 access database 
literal NFB$C_DB_PROXY = 28;            !  Proxy data base
literal NFB$C_DB_XXX = 29;              !  Last database definition for NFB$C_DB_MAX calc. 
!  Maximum DATABASE value 
literal NFB$C_DB_MAX = 28;              !  Maximum DATABASE value 
literal NFB$C_OP_EQL = 0;               !  Match if SEARCH_KEY value EQL database entry field 
literal NFB$C_OP_GTRU = 1;              !  Match if SEARCH_KEY value GTRU database entry field 
literal NFB$C_OP_LSSU = 2;              !  Match if SEARCH_KEY value LSSU database entry field 
literal NFB$C_OP_NEQ = 3;               !  Match if SEARCH_KEY value NEQ database entry field 
!  The following may only be used internally by NETACP
literal NFB$C_OP_FNDMIN = 4;            !  Find entry with minimum key value 
literal NFB$C_OP_FNDMAX = 5;            !  Find entry with maximum key value 
literal NFB$C_OP_FNDPOS = 6;            !  Find entry position in database 
!  Maximum operator function 
literal NFB$C_OP_MAXFCT = 3;            !  Maximum operator function 
literal NFB$C_OP_MAXINT = 6;            !  Maximum internal function 
literal NFB$K_LENGTH = 16;              !  Minimum structure size. 
literal NFB$C_LENGTH = 16;              !  Minimum structure size. 
!  counted strings.  If the "cell size" is non-zero, it
literal NFB$S_NFBDEF = 20;
macro NFB$B_FCT = 0,0,8,0 %;            !  A function code as follows: 
!  Function codes for the NFB 
!   (leaving room for 20 obsolete function codes)
!   (leave room for 4 obsolete function codes)
!   (leave room for 3 obsolete function codes)
macro NFB$B_FLAGS = 1,0,8,0 %;          !  Miscellaneous control flags 
macro NFB$V_ERRUPD = 1,0,1,0 %;         !  Update position context, even on error 
macro NFB$V_MULT = 1,1,1,0 %;           !  Process as many entries as can be fit into P4 
macro NFB$V_NOCTX = 1,2,1,0 %;          !  Don't update position context, even if successful 
!   (used to stay on an entry for a while).  This
!   flag Overrides the ERRUPD flag.
macro NFB$V_LOCAL = 1,3,1,0 %;          !  Signal that REBUILD_PROXY should only be
!  performed locally
macro NFB$B_DATABASE = 2,0,8,0 %;       !  A code identifying the database as follows: 
!  ZERO is an illegal value for this field 
macro NFB$B_OPER = 3,0,8,0 %;           !  Specifies the sense of the search (e.g. EQL, GEQU) 
!  when comparing against the SRCH_KEY field.
macro NFB$L_SRCH_KEY = 4,0,32,0 %;      !  Search key field identifier specifying the key used 
!  to locate the entry in the database.  This search is
!  controlled by the sense of the NFB$B_OPER field.
! 
!  If this field has the value "NFB$C_WILDCARD", then
!  the very next entry in the list is assumed to be the
!  target of the search.
! 
!  If this field is not specified (zero), then it
!  is assumed to be NFB$C_WILDCARD (no search key).
! 
macro NFB$L_SRCH2_KEY = 8,0,32,0 %;     !  Secondary search key field ID specifying the key used 
!  to locate the entry in the database.  This search is
!  controlled by the sense of the NFB$B_OPER2 field.
! 
!  If both SRCH_KEY and SRCH2_KEY are specified, then
!  only those database entries matching both search keys
!  will be processed.
! 
!  If this field is not specified (zero), then it
!  is assumed to be NFB$C_WILDCARD (no search key).
! 
macro NFB$B_OPER2 = 12,0,8,0 %;         !  Specifies the sense of the search (e.g. EQL, GEQU) 
!  when comparing against the SRCH2_KEY field.
macro NFB$B_MBZ1 = 13,0,8,0 %;          !  Reserved. MBZ. 
macro NFB$W_CELL_SIZE = 14,0,16,0 %;    !  Some of the field values found in the P4 buffer are 
!  indicates the number of bytes which each string in
!  the P4 buffer occupies.  If it is zero then strings
!  fields are stored as variable lengthed strings.
macro NFB$L_FLDID = 16,0,32,0 %;        !  Cell containing the first field ID -- the list 
!  of field IDs begins here and continues to the
!  end of the structure.
! 
!  The list may be terminated before the end of the
!  structure by placing the value NFB$C_ENDOFLIST
!  in the longword following the last field ID.
! 
! 
! 	Define the "field i.d." format.
! 
literal NFB$M_INX = 65535;
literal NFB$M_TYP = 196608;
literal NFB$M_SPARE = 16515072;
literal NFB$M_DB = -16777216;
literal NFB$C_TYP_BIT = 0;              !  Field type for bits 
literal NFB$C_TYP_V = 0;                !  Field type for bits 
literal NFB$C_TYP_LNG = 1;              !  Field type for longwords 
literal NFB$C_TYP_L = 1;                !  Field type for longwords 
literal NFB$C_TYP_STR = 2;              !  Field type for strings 
literal NFB$C_TYP_S = 2;                !  Field type for strings 
! 
literal NFB$S_NFBDEF1 = 4;
macro NFB$L_PARAM_ID = 0,0,32,0 %;      !  Define parameter ID longword 
macro NFB$V_INX = 0,0,16,0 %;
literal NFB$S_INX = 16;                 !  Index into semantic table 
macro NFB$V_TYP = 0,16,2,0 %;
literal NFB$S_TYP = 2;                  !  Field type (string, bit, etc.) 
macro NFB$V_SPARE = 0,18,6,0 %;
literal NFB$S_SPARE = 6;                !  Reserved, MBZ 
macro NFB$V_DB = 0,24,8,0 %;
literal NFB$S_DB = 8;                   !  Data-base i.d. 
!    Define useful symbols for storing and retreiving binary and string
!    values from the P2 and P4 buffers
! 
literal NFB$S_NFBDEF2 = 4;
macro NFB$L_LNG_VALUE = 0,0,32,0 %;     !  Longword value 
literal NFB$S_NFBDEF3 = 4;
macro NFB$L_BIT_VALUE = 0,0,32,0 %;     !  Boolean value 
literal NFB$C_NDI_LCK = 33554433;       !  Set if conditionally writable fields are not writable 
literal NFB$C_NDI_LOO = 33554434;       !  Set if CNF is for a "loopback" node 
literal NFB$C_NDI_REA = 33554435;       !  Set if node is reachable 
! 
literal NFB$C_NDI_TAD = 33619984;       !  "transformed address" - uses local node address 
!  for the local NDI (instead of zero as does ADD)
literal NFB$C_NDI_CTA = 33619985;       !  Absolute due time for logging counters 
literal NFB$C_NDI_ADD = 33619986;       !  Address 
literal NFB$C_NDI_CTI = 33619987;       !  Counter timer 
literal NFB$C_NDI_ACL = 33619988;       !  Active links 
literal NFB$C_NDI_DEL = 33619989;       !  Delay 
literal NFB$C_NDI_DTY = 33619990;       !  Destination Type 
literal NFB$C_NDI_DCO = 33619991;       !  Destination Cost 
literal NFB$C_NDI_DHO = 33619992;       !  Destination Hops 
literal NFB$C_NDI_SDV = 33619993;       !  Service Device 
literal NFB$C_NDI_CPU = 33619994;       !  CPU type 
literal NFB$C_NDI_STY = 33619995;       !  Software type 
literal NFB$C_NDI_DAD = 33619996;       !  Dump address 
literal NFB$C_NDI_DCT = 33619997;       !  Dump count 
literal NFB$C_NDI_OHO = 33619998;       !  Host 
literal NFB$C_NDI_IHO = 33619999;       !  Host 
literal NFB$C_NDI_ACC = 33620000;       !  Access switch (inbound, outbound, etc) 
literal NFB$C_NDI_PRX = 33620001;       !  ** obsolete ** (Node proxy parameter) 
literal NFB$C_NDI_NND = 33620002;       !  Next node address 
literal NFB$C_NDI_SNV = 33620003;       !  Service Node Version
literal NFB$C_NDI_INB = 33620004;       !  Async Line - Inbound node type
! 
literal NFB$C_NDI_COL = 33685568;       !  Collating field 
literal NFB$C_NDI_HAC = 33685569;       !  Node address/loop linename combination 
literal NFB$C_NDI_CNT = 33685570;       !  Counters 
literal NFB$C_NDI_NNA = 33685571;       !  Name 
literal NFB$C_NDI_SLI = 33685572;       !  Service line 
literal NFB$C_NDI_SPA = 33685573;       !  Service password 
literal NFB$C_NDI_LOA = 33685574;       !  Load file 
literal NFB$C_NDI_SLO = 33685575;       !  Secondary loader 
literal NFB$C_NDI_TLO = 33685576;       !  Tertiary loader 
literal NFB$C_NDI_SID = 33685577;       !  Software ID 
literal NFB$C_NDI_DUM = 33685578;       !  Dump file 
literal NFB$C_NDI_SDU = 33685579;       !  Secondary dumper 
literal NFB$C_NDI_NLI = 33685580;       !  Loopback Line 
literal NFB$C_NDI_DLI = 33685581;       !  Destination Line 
literal NFB$C_NDI_PUS = 33685582;       !  Privileged user id 
literal NFB$C_NDI_PAC = 33685583;       !  Privileged account 
literal NFB$C_NDI_PPW = 33685584;       !  Privileged password 
literal NFB$C_NDI_NUS = 33685585;       !  Non-privileged user id 
literal NFB$C_NDI_NAC = 33685586;       !  Non-privileged account 
literal NFB$C_NDI_NPW = 33685587;       !  Non-privileged password 
literal NFB$C_NDI_RPA = 33685588;       !  Receive password 
literal NFB$C_NDI_TPA = 33685589;       !  Transmit password 
literal NFB$C_NDI_DFL = 33685590;       !  Diagnostic load file 
literal NFB$C_NDI_HWA = 33685591;       !  Hardware NI address (ROM address) 
literal NFB$C_NDI_LPA = 33685592;       !  Loop assistant NI address 
literal NFB$C_NDI_NNN = 33685593;       !  Next node name to destination (goes with NND) 
literal NFB$C_NDI_LAA = 33685594;       !  Load Assist Agent
literal NFB$C_NDI_LAP = 33685595;       !  Load Assist Parameter
literal NFB$C_NDI_MFL = 33685596;       !  Management File
! 
literal NFB$C_LNI_LCK = 16777217;       !  Set if conditionally writable fields are not writable 
literal NFB$C_LNI_ALI = 16777218;       !  Set if ALIAS INBOUND has been enabled
literal NFB$C_LNI_IPR = 16777219;       !  Incoming proxy enabled/disabled
literal NFB$C_LNI_OPR = 16777220;       !  Outgoing proxy enabled/disabled
literal NFB$C_LNI_DNS = 16777221;       !  DNS interface enabled/disabled
! 
literal NFB$C_LNI_ADD = 16842768;       !  Address 
literal NFB$C_LNI_ACL = 16842769;       !  Total number of active links 
literal NFB$C_LNI_ITI = 16842770;       !  Incoming timer 
literal NFB$C_LNI_OTI = 16842771;       !  Outgoing timer 
literal NFB$C_LNI_STA = 16842772;       !  State 
literal NFB$C_LNI_MLK = 16842773;       !  Maximum links 
literal NFB$C_LNI_DFA = 16842774;       !  Delay factor 
literal NFB$C_LNI_DWE = 16842775;       !  Delay weight 
literal NFB$C_LNI_IAT = 16842776;       !  Inactivity timer 
literal NFB$C_LNI_RFA = 16842777;       !  Retransmit factor 
literal NFB$C_LNI_ETY = 16842778;       !  Executor Type 
literal NFB$C_LNI_RTI = 16842779;       !  Routing timer 
literal NFB$C_LNI_RSI = 16842780;       !  Routing suppression timer 
literal NFB$C_LNI_SAD = 16842781;       !  Subaddress 
!  (lower word = lower limit, upper word = upper limit)
literal NFB$C_LNI_MAD = 16842782;       !  Maximum address 
literal NFB$C_LNI_MLN = 16842783;       !  Maximum lines 
literal NFB$C_LNI_MCO = 16842784;       !  Maximum cost 
literal NFB$C_LNI_MHO = 16842785;       !  Maximum hops 
literal NFB$C_LNI_MVI = 16842786;       !  Maximum visits 
literal NFB$C_LNI_MBU = 16842787;       !  Maximum buffers 
literal NFB$C_LNI_BUS = 16842788;       !  Forwarding buffer size 
literal NFB$C_LNI_LPC = 16842789;       !  Loop count 
literal NFB$C_LNI_LPL = 16842790;       !  Loop length 
literal NFB$C_LNI_LPD = 16842791;       !  Loop Data type 
literal NFB$C_LNI_DAC = 16842792;       !  Default access switch (inbound, outbound, etc) 
literal NFB$C_LNI_fill1 = 16842793;     !  Place holder, used to be Default proxy access (inbound, outbound, etc) 
literal NFB$C_LNI_PIQ = 16842794;       !  Pipeline quota 
literal NFB$C_LNI_LPH = 16842795;       !  Loop help type of assistance given to loop requestors 
literal NFB$C_LNI_BRT = 16842796;       !  Broadcast routing timer 
literal NFB$C_LNI_MAR = 16842797;       !  Maximum areas 
literal NFB$C_LNI_MBE = 16842798;       !  Maximum nonrouters on NI 
literal NFB$C_LNI_MBR = 16842799;       !  Maximum routers on NI 
literal NFB$C_LNI_AMC = 16842800;       !  Area maximum cost 
literal NFB$C_LNI_AMH = 16842801;       !  Area maximum hops 
literal NFB$C_LNI_SBS = 16842802;       !  Segment buffer size 
literal NFB$C_LNI_ALA = 16842803;       !  Alias local node address (cluster address) 
literal NFB$C_LNI_ALM = 16842804;       !  Alias maximum links
literal NFB$C_LNI_PSP = 16842805;       !  Path split policy normal/interim
literal NFB$C_LNI_MPS = 16842806;       !  Maximum path split
literal NFB$C_LNI_MDO = 16842807;       !  Maximum Declared Object
! 
literal NFB$C_LNI_COL = 16908352;       !  Collating field 
literal NFB$C_LNI_NAM = 16908353;       !  Local node name 
literal NFB$C_LNI_CNT = 16908354;       !  Counters 
literal NFB$C_LNI_IDE = 16908355;       !  Identification 
literal NFB$C_LNI_MVE = 16908356;       !  Management version 
literal NFB$C_LNI_NVE = 16908357;       !  Nsp version 
literal NFB$C_LNI_RVE = 16908358;       !  Routing version 
literal NFB$C_LNI_PHA = 16908359;       !  Physical NI address (current address)
literal NFB$C_LNI_IDP = 16908360;       !  IDP of ISO address
literal NFB$C_LNI_DNM = 16908361;       !  DNS namespace 
! 
literal NFB$C_OBI_LCK = 50331649;       !  Set if conditionally writable fields are not writable 
literal NFB$C_OBI_SET = 50331650;       !  Set if a "set" QIO has ever modified the CNF. If 
!  not then the CNF was due to a "declare name/obect"
!  only and may be deleted when the declaring process
!  breaks the channel over which the object was declared
literal NFB$C_OBI_ALO = 50331651;       !  Alias Outgoing enabled/disabled
literal NFB$C_OBI_ALI = 50331652;       !  Alias Incoming enabled/disabled
! 
literal NFB$C_OBI_LPR = 50397200;       !  Low order privileges 
literal NFB$C_OBI_HPR = 50397201;       !  High order privileges 
literal NFB$C_OBI_DOV = 50397202;       !  Point to Owners UCB
literal NFB$C_OBI_CHN = 50397203;       !  Owner's channel 
literal NFB$C_OBI_NUM = 50397204;       !  Number 
literal NFB$C_OBI_PID = 50397205;       !  Process id 
literal NFB$C_OBI_PRX = 50397206;       !  Proxy login switch (inbound, outbound, etc) 
! 
literal NFB$C_OBI_COL = 50462784;       !  Collating field 
literal NFB$C_OBI_ZNA = 50462785;       !  Zero obj+name identifier 
literal NFB$C_OBI_SFI = 50462786;       !  Parsed file i.d. 
literal NFB$C_OBI_IAC = 50462787;       !  Default inbound combined access control string 
literal NFB$C_OBI_NAM = 50462788;       !  Name 
literal NFB$C_OBI_FID = 50462789;       !  File id 
literal NFB$C_OBI_USR = 50462790;       !  User id 
literal NFB$C_OBI_ACC = 50462791;       !  Account 
literal NFB$C_OBI_PSW = 50462792;       !  Password 
literal NFB$C_OBI_OCPRV = 50462793;     !  Outgoing Connect Privileges
! 
literal NFB$C_CRI_LCK = 67108865;       !  D Set if conditionally writable fields are 
! 	not writable
literal NFB$C_CRI_SER = 67108866;       !  D Set if Service functions not allowed 
literal NFB$C_CRI_BLK_FILL = 67108867;  !    Filler (BLK retired)
literal NFB$C_CRI_VER_FILL = 67108868;  !    Filler (VER retired)
literal NFB$C_CRI_DLM = 67108869;       !  E Circuit to be used as X.25 datalink, if set 
! 	If clear, circuit is for X.25 native use
literal NFB$C_CRI_OWPID = 67174416;     !  D PID of temp owner of line in service state 
literal NFB$C_CRI_CTA = 67174417;       !  D Absolute due time for counter logging 
literal NFB$C_CRI_SRV = 67174418;       !  D Service substate qualifier 
literal NFB$C_CRI_STA = 67174419;       !  C State 
literal NFB$C_CRI_SUB = 67174420;       !  C Substate 
literal NFB$C_CRI_LCT = 67174421;       !  C Counter timer 
literal NFB$C_CRI_PNA = 67174422;       !  E Adjacent node address 
literal NFB$C_CRI_BLO = 67174423;       !  E Partner's receive block size 
literal NFB$C_CRI_COS = 67174424;       !  E Cost 
literal NFB$C_CRI_HET = 67174425;       !  E Hello timer 
literal NFB$C_CRI_LIT = 67174426;       !  E Listen timer 
literal NFB$C_CRI_MRC = 67174427;       !  E Maximum recalls 
literal NFB$C_CRI_RCT = 67174428;       !  E Recall timer 
literal NFB$C_CRI_POL = 67174429;       !  D Polling state 
literal NFB$C_CRI_PLS = 67174430;       !  D Polling substate 
literal NFB$C_CRI_USE = 67174431;       !  X Usage 
literal NFB$C_CRI_TYP = 67174432;       !  C Type 
literal NFB$C_CRI_CHN = 67174433;       !  X X.25 Channel 
literal NFB$C_CRI_MBL = 67174434;       !  X Maximum block 
literal NFB$C_CRI_MWI = 67174435;       !  X Maximum window 
literal NFB$C_CRI_TRI = 67174436;       !  D Tributary 
literal NFB$C_CRI_BBT = 67174437;       !  D Babble timer 
literal NFB$C_CRI_TRT = 67174438;       !  D Transmit timer 
literal NFB$C_CRI_MRB = 67174439;       !  D Maximum receive buffers 
literal NFB$C_CRI_MTR = 67174440;       !  D Maximum transmits 
literal NFB$C_CRI_ACB = 67174441;       !  D Active base 
literal NFB$C_CRI_ACI = 67174442;       !  D Active increment 
literal NFB$C_CRI_IAB = 67174443;       !  D Inactive base 
literal NFB$C_CRI_IAI = 67174444;       !  D Inactive increment 
literal NFB$C_CRI_IAT = 67174445;       !  D Inactive threshold 
literal NFB$C_CRI_DYB = 67174446;       !  D Dying base 
literal NFB$C_CRI_DYI = 67174447;       !  D Dying increment 
literal NFB$C_CRI_DYT = 67174448;       !  D Dying threshold 
literal NFB$C_CRI_DTH = 67174449;       !  D Dead threshold 
literal NFB$C_CRI_MST = 67174450;       !  D Maintenance mode state (0 => On, 1 => Off> 
literal NFB$C_CRI_XPT = 67174451;       !  E Transport protocol to use 
literal NFB$C_CRI_MRT = 67174452;       !  E Maximum routers on this NI 
literal NFB$C_CRI_RPR = 67174453;       !  E Router priority 
literal NFB$C_CRI_DRT = 67174454;       !  E Designated router on NI (node address) 
literal NFB$C_CRI_VER = 67174455;       !  D Verification Enabled/Disabled/Inbound on circuit
! 
literal NFB$C_CRI_COL = 67240000;       !  D Collating field 
literal NFB$C_CRI_NAM = 67240001;       !  C Circuit name 
literal NFB$C_CRI_VMSNAM = 67240002;    !  D Device name in VMS format 
literal NFB$C_CRI_CHR = 67240003;       !  D Characteristics buffer for startup control QIO 
literal NFB$C_CRI_CNT = 67240004;       !  C Counters 
literal NFB$C_CRI_P2P = 67240005;       !  D Line's PhaseII partner name (for loopback) 
literal NFB$C_CRI_LOO = 67240006;       !  E Loopback name 
literal NFB$C_CRI_PNN = 67240007;       !  E Adjacent node name 
literal NFB$C_CRI_NUM = 67240008;       !  X Call Number 
literal NFB$C_CRI_DTE = 67240009;       !  X DTE 
literal NFB$C_CRI_DEVNAM = 67240010;    !  D Device name in VMS format, with unit included 
literal NFB$C_CRI_net = 67240011;       !  XD Network name
! 
literal NFB$C_PLI_LCK = 83886081;       !  D Set if conditionally writable fields are 
! 	not writable
literal NFB$C_PLI_SER = 83886082;       !  D Service 
literal NFB$C_PLI_DUP = 83886083;       !  C Duplex (set if half) 
literal NFB$C_PLI_CON = 83886084;       !  C Controller (set if loopback) 
literal NFB$C_PLI_CLO = 83886085;       !  C Clock mode (set if internal) 
literal NFB$C_PLI_SWI = 83886086;       !  D Async Line - Switch
literal NFB$C_PLI_HNG = 83886087;       !  D Async Line - Hangup
! 
literal NFB$C_PLI_CTA = 83951632;       !  D Absolute time for counter read and clear 
literal NFB$C_PLI_STA = 83951633;       !  C State 
literal NFB$C_PLI_SUB = 83951634;       !  C Substate 
literal NFB$C_PLI_LCT = 83951635;       !  D Counter timer 
literal NFB$C_PLI_PRO = 83951636;       !  C Protocol 
literal NFB$C_PLI_STI = 83951637;       !  D Service timer 
literal NFB$C_PLI_HTI = 83951638;       !  L Holdback timer 
literal NFB$C_PLI_MBL = 83951639;       !  L Maximum block 
literal NFB$C_PLI_MRT = 83951640;       !  L Maximum retransmits 
literal NFB$C_PLI_MWI = 83951641;       !  L Maximum window 
literal NFB$C_PLI_SLT = 83951642;       !  D Scheduling timer 
literal NFB$C_PLI_DDT = 83951643;       !  D Dead timer 
literal NFB$C_PLI_DLT = 83951644;       !  D Delay timer 
literal NFB$C_PLI_SRT = 83951645;       !  D Stream timer 
literal NFB$C_PLI_BFN = 83951646;       !  D Receive buffers 
literal NFB$C_PLI_BUS = 83951647;       !  D Action routine returns bufsiz used for line 
literal NFB$C_PLI_PLVEC = 83951648;     !  D PLVEC i.d. 
literal NFB$C_PLI_RTT = 83951649;       !  D Retransmit timer 
literal NFB$C_PLI_MOD = 83951650;       !  L X.25 mode (DCE, DTE, etc). 
literal NFB$C_PLI_LPC = 83951651;       !  L Loop count 
literal NFB$C_PLI_LPL = 83951652;       !  L Loop length 
literal NFB$C_PLI_LPD = 83951653;       !  L Loop Data type 
literal NFB$C_PLI_EPT = 83951654;       !  E Ethernet protocol type for datalink 
literal NFB$C_PLI_LNS = 83951655;       !  D Async Line - Line speed
literal NFB$C_PLI_BFS = 83951656;       !  C Line buffer size (overrides executor bufsiz) 
literal NFB$C_PLI_TPI = 83951657;       !  D Transmit Pipeline
literal NFB$C_PLI_TREQ = 83951658;      !  F Requested TRT
literal NFB$C_PLI_TVX = 83951659;       !  F Valid transmission time
literal NFB$C_PLI_REST_TTO = 83951660;  !  F Restricted token timeout
literal NFB$C_PLI_RPE = 83951661;       !  F Ring purger enable
literal NFB$C_PLI_ECHO_DAT = 83951662;  !  F Echo data
literal NFB$C_PLI_ECHO_LEN = 83951663;  !  F Echo length
literal NFB$C_PLI_T_NEG = 83951664;     !  F Negotiated TRT
literal NFB$C_PLI_DAT = 83951665;       !  F Duplicate address flag
literal NFB$C_PLI_UN_DAT = 83951666;    !  F Upstream neighbor DA flag
literal NFB$C_PLI_RPS = 83951667;       !  F Ring purger state
literal NFB$C_PLI_RER = 83951668;       !  F Ring error reason
literal NFB$C_PLI_NBR_PHY = 83951669;   !  F Neighbor PHY type
literal NFB$C_PLI_LEE = 83951670;       !  F Link error estimate
literal NFB$C_PLI_RJR = 83951671;       !  F Reject reason
! 
literal NFB$C_PLI_COL = 84017216;       !  D Collating field 
literal NFB$C_PLI_NAM = 84017217;       !  C Line name 
literal NFB$C_PLI_VMSNAM = 84017218;    !  D Device name in VMS format 
literal NFB$C_PLI_CHR = 84017219;       !  D Set-mode $QIO line Characteristics buffer 
literal NFB$C_PLI_CNT = 84017220;       !  C Counters 
literal NFB$C_PLI_MCD = 84017221;       !  L Filespec for microcode dump (initiates dump) 
literal NFB$C_PLI_HWA = 84017222;       !  D NI hardware address (ROM address) 
literal NFB$C_PLI_DEVNAM = 84017223;    !  D Device name in VMS format, with unit included 
literal NFB$C_PLI_NET = 84017224;       !  L Network name
literal NFB$C_PLI_NIF_TARG = 84017225;  !  F NIF target
literal NFB$C_PLI_SIF_CONF_TARG = 84017226; !  F SIF configuration target
literal NFB$C_PLI_SIF_OP_TARG = 84017227; !  F SIF operation target
literal NFB$C_PLI_ECHO_TARG = 84017228; !  F Echo target
literal NFB$C_PLI_MAC_CHR = 84017229;   !  F Set-mode $QIO MAC line characteristics buffer
literal NFB$C_PLI_UNA = 84017230;       !  F Upstream neighbor
literal NFB$C_PLI_OLD_UNA = 84017231;   !  F Old upstream neighbor
literal NFB$C_PLI_DNA = 84017232;       !  F Downstream neighbor
literal NFB$C_PLI_OLD_DNA = 84017233;   !  F Old downstream neighbor
! 
literal NFB$C_EFI_LCK = 100663297;      !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_EFI_SIN = 100728848;
literal NFB$C_EFI_SP1 = 100728849;
literal NFB$C_EFI_B1 = 100728850;
literal NFB$C_EFI_B2 = 100728851;
! 
literal NFB$C_EFI_COL = 100794432;      !  Collating field 
literal NFB$C_EFI_EVE = 100794433;
literal NFB$C_EFI_SB1 = 100794434;
literal NFB$C_EFI_SB2 = 100794435;
literal NFB$C_EFI_SB3 = 100794436;
! 
literal NFB$C_ESI_LCK = 117440513;      !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_ESI_SNK = 117506064;
literal NFB$C_ESI_STA = 117506065;
literal NFB$C_ESI_SP1 = 117506066;
literal NFB$C_ESI_B1 = 117506067;
literal NFB$C_ESI_B2 = 117506068;
! 
literal NFB$C_ESI_COL = 117571648;      !  Collating field 
literal NFB$C_ESI_LNA = 117571649;
literal NFB$C_ESI_SB1 = 117571650;
literal NFB$C_ESI_SB2 = 117571651;
literal NFB$C_ESI_SB3 = 117571652;
! 
literal NFB$C_LLI_LCK = 134217729;      !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_LLI_DLY = 134283280;      !  Round trip delay time 
literal NFB$C_LLI_STA = 134283281;      !  State 
literal NFB$C_LLI_LLN = 134283282;      !  Local link number 
literal NFB$C_LLI_RLN = 134283283;      !  Remote link number 
literal NFB$C_LLI_PNA = 134283284;      !  Partner's node address 
literal NFB$C_LLI_PID = 134283285;      !  External Process I.D.
literal NFB$C_LLI_IPID = 134283286;     !  Internal Process I.D.
literal NFB$C_LLI_XWB = 134283287;      !  Pointer to XWB
literal NFB$C_LLI_CNT = 134283288;      !  Counters
! 
literal NFB$C_LLI_COL = 134348864;      !  Collating field 
literal NFB$C_LLI_USR = 134348865;      !  User name 
literal NFB$C_LLI_PRC = 134348866;      !  Process name 
literal NFB$C_LLI_PNN = 134348867;      !  Partner's node name 
literal NFB$C_LLI_RID = 134348868;      !  Partner's process i.d. 
! 
literal NFB$C_XNI_LCK = 150994945;      !  Set if conditionally writable fields are not writable 
literal NFB$C_XNI_MNS_FILL = 150994946; !  X.25 multi-network support (set if enabled) [No longer used]
! 
literal NFB$C_XNI_CAT = 151060496;      !  Call timer 
literal NFB$C_XNI_CLT = 151060497;      !  Clear timer 
literal NFB$C_XNI_DBL = 151060498;      !  Default data 
literal NFB$C_XNI_DWI = 151060499;      !  Default window 
literal NFB$C_XNI_MBL = 151060500;      !  Maximum data 
literal NFB$C_XNI_MCL = 151060501;      !  Maximum clears 
literal NFB$C_XNI_MRS = 151060502;      !  Maximum resets 
literal NFB$C_XNI_MST = 151060503;      !  Maximum restarts 
literal NFB$C_XNI_MWI = 151060504;      !  Maximum window 
literal NFB$C_XNI_RST = 151060505;      !  Reset timer 
literal NFB$C_XNI_STT = 151060506;      !  Restart timer 
! 
literal NFB$C_XNI_COL = 151126080;      !  Collating field 
literal NFB$C_XNI_netent = 151126081;   !  Network 
literal NFB$C_XNI_PROF = 151126082;     !  Profile name
! 
literal NFB$C_XDI_LCK = 184549377;      !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_XDI_ACH = 184614928;      !  Active channels 
literal NFB$C_XDI_ASW = 184614929;      !  Active switched 
literal NFB$C_XDI_CTM = 184614930;      !  Counter timer 
literal NFB$C_XDI_MCH = 184614931;      !  Maximum channels 
literal NFB$C_XDI_STA = 184614932;      !  State 
literal NFB$C_XDI_SUB = 184614933;      !  Substate 
literal NFB$C_XDI_MCI = 184614934;      !  Maximum circuits [VMS only] 
literal NFB$C_XDI_CAT = 184614935;      !  Call timer 
literal NFB$C_XDI_CLT = 184614936;      !  Clear timer 
literal NFB$C_XDI_DBL = 184614937;      !  Default data 
literal NFB$C_XDI_DWI = 184614938;      !  Default window 
literal NFB$C_XDI_MBL = 184614939;      !  Maximum data 
literal NFB$C_XDI_MCL = 184614940;      !  Maximum clears 
literal NFB$C_XDI_MRS = 184614941;      !  Maximum resets 
literal NFB$C_XDI_MST = 184614942;      !  Maximum restarts 
literal NFB$C_XDI_MWI = 184614943;      !  Maximum window 
literal NFB$C_XDI_RST = 184614944;      !  Reset timer 
literal NFB$C_XDI_STT = 184614945;      !  Restart timer 
literal NFB$C_XDI_mode = 184614946;     !  DTE Mode
literal NFB$C_XDI_itt = 184614947;      !  Interrupt timer
! 
literal NFB$C_XDI_COL = 184680512;      !  Collating field 
literal NFB$C_XDI_DTE = 184680513;      !  DTE address 
literal NFB$C_XDI_CHN = 184680514;      !  Channels 
literal NFB$C_XDI_LIN = 184680515;      !  Line 
literal NFB$C_XDI_dnt = 184680516;      !  Network 
literal NFB$C_XDI_CNT = 184680517;      !  Counters 
! 
literal NFB$C_XGI_LCK = 167772161;      !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_XGI_GNM = 167837712;      !  Group number 
literal NFB$C_XGI_GTY = 167837713;      !  Group type 
! 
literal NFB$C_XGI_COL = 167903296;      !  Collating field. This field must be unique across 
!  all entries in this database.  It consists of the
!  group-name string followed by the DTE address.
literal NFB$C_XGI_GRP = 167903297;      !  Group name 
literal NFB$C_XGI_GDT = 167903298;      !  Group DTE address 
literal NFB$C_XGI_gnt = 167903299;      !  Group Network
! 
literal NFB$C_XS5_LCK = 201326593;      !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_XS5_MCI = 201392144;      !  Maximum circuits allowed 
literal NFB$C_XS5_STA = 201392145;      !  State 
literal NFB$C_XS5_ACI = 201392146;      !  Active circuits 
literal NFB$C_XS5_CTM = 201392147;      !  Counter timer 
! 
literal NFB$C_XS5_COL = 201457728;      !  Collating field. This field must be unique across 
!  all entries in this database.
literal NFB$C_XS5_CNT = 201457729;      !  Counters 
! 
literal NFB$C_XD5_LCK = 218103809;      !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_XD5_PRI = 218169360;      !  Priority 
literal NFB$C_XD5_SAD = 218169361;      !  Subaddress range 
!  (lower word = lower limit, upper word = upper limit)
literal NFB$C_XD5_NOD = 218169362;      !  Remote node address containing server (gateways only) 
literal NFB$C_XD5_red = 218169363;      !  Redirect reason
! 
literal NFB$C_XD5_COL = 218234944;      !  Collating field. This field must be unique across 
!  all entries in this database.
literal NFB$C_XD5_DST = 218234945;      !  Destination DTE address 
literal NFB$C_XD5_CMK = 218234946;      !  Call mask 
literal NFB$C_XD5_CVL = 218234947;      !  Call value 
literal NFB$C_XD5_GRP = 218234948;      !  Group name 
literal NFB$C_XD5_SDTE = 218234949;     !  Sending DTE address (formally number)
literal NFB$C_XD5_OBJ = 218234950;      !  && Object name 
literal NFB$C_XD5_FIL = 218234951;      !  Command procedure to execute when starting object 
literal NFB$C_XD5_USR = 218234952;      !  User name 
literal NFB$C_XD5_PSW = 218234953;      !  Password 
literal NFB$C_XD5_ACC = 218234954;      !  Account 
literal NFB$C_XD5_cdte = 218234955;     !  Called DTE
literal NFB$C_XD5_rdte = 218234956;     !  Receiving DTE
literal NFB$C_XD5_net = 218234957;      !  Network
literal NFB$C_XD5_emk = 218234958;      !  Extension mask
literal NFB$C_XD5_evl = 218234959;      !  Extension value
literal NFB$C_XD5_acl = 218234960;      !  ACL, a list of ACE'structure, parto of ORB
literal NFB$C_XD5_idte = 218234961;     !  Incoming address
! 
literal NFB$C_XS9_LCK = 234881025;      !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_XS9_MCI = 234946576;      !  Maximum circuits allowed 
literal NFB$C_XS9_STA = 234946577;      !  State 
literal NFB$C_XS9_ACI = 234946578;      !  Active circuits 
literal NFB$C_XS9_CTM = 234946579;      !  Counter timer 
! 
literal NFB$C_XS9_COL = 235012160;      !  Collating field. This field must be unique across 
!  all entries in this database.
literal NFB$C_XS9_CNT = 235012161;      !  Counters 
! 
literal NFB$C_XD9_LCK = 251658241;      !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_XD9_PRI = 251723792;      !  Priority 
literal NFB$C_XD9_SAD = 251723793;      !  Subaddress range 
!  (lower word = lower limit, upper word = upper limit)
literal NFB$C_XD9_NOD = 251723794;      !  Remote node address containing server (gateways only) 
literal NFB$C_XD9_red = 251723795;      !  Redirect reason
! 
literal NFB$C_XD9_COL = 251789376;      !  Collating field. This field must be unique across 
!  all entries in this database.
literal NFB$C_XD9_DST = 251789377;      !  Destination DTE address 
literal NFB$C_XD9_CMK = 251789378;      !  Call mask 
literal NFB$C_XD9_CVL = 251789379;      !  Call value 
literal NFB$C_XD9_GRP = 251789380;      !  Group name 
literal NFB$C_XD9_sdte = 251789381;     !  Sending DTE 
literal NFB$C_XD9_OBJ = 251789382;      !  && Object name 
literal NFB$C_XD9_FIL = 251789383;      !  Command procedure to execute when starting object 
literal NFB$C_XD9_USR = 251789384;      !  User name 
literal NFB$C_XD9_PSW = 251789385;      !  Password 
literal NFB$C_XD9_ACC = 251789386;      !  Account 
literal NFB$C_XD9_cdte = 251789387;     !  Caller DTE
literal NFB$C_XD9_rdte = 251789388;     !  Receiving DTE
literal NFB$C_XD9_net = 251789389;      !  Network
literal NFB$C_XD9_emk = 251789390;      !  Extension mask
literal NFB$C_XD9_evl = 251789391;      !  Extension value
literal NFB$C_XD9_acl = 251789392;      !  ACL, a list of ACE'structure, parto of ORB
literal NFB$C_XD9_idte = 251789393;     !  Incoming address
! 
literal NFB$C_XTI_LCK = 268435457;      !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_XTI_STA = 268501008;      !  State 
literal NFB$C_XTI_BFZ = 268501009;      !  Buffer size 
literal NFB$C_XTI_CPL = 268501010;      !  Capture limit 
literal NFB$C_XTI_MBK = 268501011;      !  Maximum blocks/file 
literal NFB$C_XTI_MBF = 268501012;      !  Maximum number of buffers 
literal NFB$C_XTI_MVR = 268501013;      !  Maximum trace file version number 
! 
literal NFB$C_XTI_COL = 268566592;      !  Collating field. This field must be unique across 
!  all entries in this database.
literal NFB$C_XTI_FNM = 268566593;      !  Trace file name 
! 
literal NFB$C_XTT_LCK = 285212673;      !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_XTT_TST = 285278224;      !  State 
literal NFB$C_XTT_CPS = 285278225;      !  Capture size 
! 
literal NFB$C_XTT_COL = 285343808;      !  Collating field. This field must be unique across 
!  all entries in this database.
literal NFB$C_XTT_TPT = 285343809;      !  Tracepoint name 
! 
literal NFB$C_XAI_LCK = 452984833;      !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_XAI_NDA = 453050384;      !  Node address 
! 
literal NFB$C_XAI_COL = 453115968;      !  Collating field 
literal NFB$C_XAI_NET = 453115969;      !  Network 
literal NFB$C_XAI_USR = 453115970;      !  User id 
literal NFB$C_XAI_PSW = 453115971;      !  Password 
literal NFB$C_XAI_ACC = 453115972;      !  Account 
literal NFB$C_XAI_NOD = 453115973;      !  Node id 
! 
literal NFB$C_XDTE_LCK = 352321537;     !  Set if conditionally writable fields are not writable
!     C(,$C_XDTE_,(((NFB$C_DB_XDTE@24)+(NFB$C_TYP_LNG@16)+16)),1
literal NFB$C_XDTE_COL = 352452672;     !  Collating field
literal NFB$C_XDTE_NET = 352452673;     !  Network
literal NFB$C_XDTE_DTE = 352452674;     !  DTE address
literal NFB$C_XDTE_ID = 352452675;      !  ID list, ARB rights list
literal NFB$C_XDTE_ACL = 352452676;     !  ACL, a list of ACE's, part of ORB
! 
literal NFB$C_SPI_LCK = 301989889;      !  Set if conditionally writable fields are not writable 
literal NFB$C_SPI_PRL = 301989890;      !  Proxy flag which initially started server process 
! 
literal NFB$C_SPI_PID = 302055440;      !  Server PID 
literal NFB$C_SPI_IRP = 302055441;      !  IRP of waiting DECLSERV QIO (0 if process active) 
literal NFB$C_SPI_CHN = 302055442;      !  Channel associated with DECLSERV IRP 
literal NFB$C_SPI_RNA = 302055443;      !  Remote node address which initially started server 
! 
literal NFB$C_SPI_COL = 302121024;      !  Collating field 
literal NFB$C_SPI_ACS = 302121025;      !  ACS used to initally start server process 
literal NFB$C_SPI_RID = 302121026;      !  Remote user ID which initially started server 
literal NFB$C_SPI_SFI = 302121027;      !  Last (current) SFI given to server process 
literal NFB$C_SPI_NCB = 302121028;      !  Last (current) NCB given to server process 
literal NFB$C_SPI_PNM = 302121029;      !  Last (current) process name given to server 
! 
literal NFB$C_AJI_LCK = 318767105;      !  Set if conditionally writable fields are not writable 
literal NFB$C_AJI_REA = 318767106;      !  Reachable (set if two-way communication established) 
literal NFB$C_AJI_RRA = 318767107;      !  Reachable Routing Adjacency
! 
literal NFB$C_AJI_ADD = 318832656;      !  Node address 
literal NFB$C_AJI_TYP = 318832657;      !  Node type 
literal NFB$C_AJI_LIT = 318832658;      !  Listen timer for this adjacency 
literal NFB$C_AJI_BLO = 318832659;      !  Partner's block size 
literal NFB$C_AJI_RPR = 318832660;      !  Partner's router priority (on NI) 
! 
literal NFB$C_AJI_COL = 318898240;      !  Collating field 
literal NFB$C_AJI_NNA = 318898241;      !  Node name 
literal NFB$C_AJI_CIR = 318898242;      !  Circuit name 
! 
literal NFB$C_SDI_LCK = 436207617;      !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_SDI_SUB = 436273168;      !  Service substate 
literal NFB$C_SDI_PID = 436273169;      !  PID of process owning this DLE link 
! 
literal NFB$C_SDI_COL = 436338752;      !  Collating field 
literal NFB$C_SDI_CIR = 436338753;      !  Circuit name 
literal NFB$C_SDI_PHA = 436338754;      !  Service physical address (BC only) 
literal NFB$C_SDI_PRC = 436338755;      !  Name of process owning this DLE link 
! 
literal NFB$C_ARI_LCK = 335544321;      !  Set if conditionally writable fields are not writable 
literal NFB$C_ARI_REA = 335544322;      !  Set if node is reachable 
! 
literal NFB$C_ARI_ADD = 335609872;      !  Address 
literal NFB$C_ARI_DCO = 335609873;      !  Destination Cost 
literal NFB$C_ARI_DHO = 335609874;      !  Destination Hops 
literal NFB$C_ARI_NND = 335609875;      !  Next node address 
! 
literal NFB$C_ARI_COL = 335675456;      !  Collating field 
literal NFB$C_ARI_DLI = 335675457;      !  Circuit used for normal traffic to area 
! 
literal NFB$C_PROXY_LCK = 469762049;    !  Set if conditionally writable fields are not writable 
! 
literal NFB$C_PROXY_RUIC = 469827600;   !  Remote UIC
! 
literal NFB$C_PROXY_RNODE = 469893184;  !  Remote node
literal NFB$C_PROXY_RNAME = 469893185;  !  Remote user name
literal NFB$C_PROXY_DEFACCOUNT = 469893186; !  Default local proxy account
literal NFB$C_PROXY_ACCOUNT1 = 469893187; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT2 = 469893188; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT3 = 469893189; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT4 = 469893190; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT5 = 469893191; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT6 = 469893192; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT7 = 469893193; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT8 = 469893194; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT9 = 469893195; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT10 = 469893196; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT11 = 469893197; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT12 = 469893198; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT13 = 469893199; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT14 = 469893200; !  Local proxy account
literal NFB$C_PROXY_ACCOUNT15 = 469893201; !  Local proxy account
literal NFB$C_PROXY_HASHKEY = 469893202; !  Hash key lookup string
literal NFB$C_PROXY_COL = 469893184;    !  Collating field 
literal NFB$C_PROXY_MAXACC = 15;        !  Maximum numver of local proxy accounts
!   including the default
literal NFB$S_NFBDEF4 = 2;
macro NFB$W_STR_COUNT = 0,0,16,0 %;     !  String count field 
macro NFB$B_STR_TEXT = 2,0,0,0 %;       !  Start of string data 
! 
!   Define identifiers for each parameter in all database
! 
!    **  The low order 16 bits for each parameter must be unique  **
!   ***  with respect to all other parameters in its particular   ***
!    **  database.						 **
! 
!  Define a field identifier index for each parameter in the NDI database.
! 
! 
!    Boolean parameters
! 
!    "Longword" Parameters
! 
!    String parameters
! 
!  Define a field identifier index for each parameter in the LNI database.
! 
! 
!    Boolean parameters
! 
!    "Longword parameters
! 
!    String parameters
! 
!  Define a field identifier index for each parameter in the OBI database.
! 
! 
!    Boolean Parameters
! 
!    Longword Parameters
! 
!    String Parameters
! 
!  Define a field identifier index for each parameter in the CRI database.
! 
! 
! 			/* Use
! 			/* ----
! 			C = common
! 			E = Executor (used by Transport)
! 			X = Native X.25 network management
! 			D = DECnet (not X.25)
! 
! 
!    Boolean Parameters
! 
! 
!    "Longword" parameters
! 
!    String Parameters
! 
!  Define a field identifier index for each parameter in the PLI database.
! 
! 			C = common
! 			L = LAPB (X.25)
! 			D = DDCMP (not X.25)
! 			E = Ethernet
! 			F = FDDI
! 			T = Token Ring
! 
! 			/* Use
!  ----
! 
!    Boolean Parameters
! 
!    "Longword"  Parameters
! 
!    String Parameters
! 
!  Define a field identifier index for each parameter in the EFI database.
! 
! 
!    Boolean Parameters
! 
!    "Longword" Parameters
! 
!    String Parameters
! 
!  Define a field identifier index for each parameter in the ESI database.
! 
! 
!    Boolean Parameters
! 
!    "Longword" Parameters
! 
!    String Parameters
! 
!  Define a field identifier index for each parameter in the LLI database.
! 
! 
!    Boolean Parameters
! 
!    Longword Parameters
! 
!    String Parameters
! 
!  X.25 network parameters (part of MODULE X25-PROTOCOL)
! 
!  Define a field identifier index for each parameter in the XNI database.
! 
! 
!    Boolean Parameters
! 
!    "Longword" Parameters
! 
!    String Parameters
! 
!  X.25 DTE parameters (qualified by a given network)
! 
!  Define a field identifier index for each parameter in the XDI database.
! 
! 
!    Boolean Parameters
! 
!    "Longword" Parameters
! 
!    String Parameters
! 
!  X.25 group parameters (qualified by a given DTE)
! 
!  Define a field identifier index for each parameter in the XGI database.
! 
! 
!    Boolean Parameters
! 
!    "Longword" Parameters
! 
!    String Parameters
! 
!  X.25 server parameters (global parameters for all destinations)
! 
!  Define a field identifier index for each parameter in the XS5 database.
! 
! 
!    Boolean Parameters
! 
!    "Longword" Parameters
! 
!    String Parameters
! 
!  X.25 destination parameters (part of MODULE X25-SERVER)
! 
!  Define a field identifier index for each parameter in the XD5 database.
! 
! 
!    Boolean Parameters
! 
!    "Longword" Parameters
! 
!    String Parameters
! 
!  X.29 server parameters (global parameters for all destinations)
! 
!  Define a field identifier index for each parameter in the XS9 database.
! 
! 
!    Boolean Parameters
! 
!    "Longword" Parameters
! 
!    String Parameters
! 
!  X.29 destination parameters (part of MODULE X29-SERVER)
! 
!  Define a field identifier index for each parameter in the XD9 database.
! 
! 
!    Boolean Parameters
! 
!    "Longword" Parameters
! 
!    String Parameters
! 
!  X.25 tracing facility (global) parameters.
! 
!  Define a field identifier index for each parameter in the XTI database.
! 
! 
!    Boolean Parameters
! 
!    "Longword" Parameters
! 
!    String Parameters
! 
!  X.25 tracpoint (local) parameters.
! 
!  Define a field identifier index for each parameter in the XTT database.
! 
! 
!    Boolean Parameters
! 
!    "Longword" Parameters
! 
!    String Parameters
! 
!  X.25 Access (qualified by a given network)
! 
!  Define a field identifier index for each parameter in the XAI database.
! 
! 
!    Boolean Parameters
! 
!    "Longword" Parameters
! 
!    String Parameters
! 
!  X.25 Security (qualified by a given network)
! 
!  Define a field identifier index for each parameter in the XDTE database.
! 
! 
!    Boolean Parameters
! 
! 
!    "Longword" Parameters
! 
!     )
! 
!    String Parameters
! 
!  Define SPI (Server Process) parameters
! 
! 
!    Boolean Parameters
! 
!    Longword Parameters
! 
!    String Parameters
! 
!  Define AJI (Adjacency) parameters
! 
! 
!    Boolean Parameters
! 
!    Longword Parameters
! 
!    String Parameters
! 
!  Define SDI (Service DLE) parameters
! 
! 
!    Boolean Parameters
! 
!    Longword Parameters
! 
!    String Parameters
! 
!  Define the AREA database (read only) for level 2 Phase IV routers only.
! 
! 
!    Boolean parameters
! 
!    "Longword" Parameters
! 
!    String parameters
! 
!  Define the PROXY database 
! 
! 
!    Boolean parameters
! 
!    "Longword" Parameters
! 
!    String parameters
! 
 
!*** MODULE DR ***
! 
!  DISCONNECT REASONS
! 
literal NET$C_DR_NORMAL = 0;            !  NO ERROR (SYNCH DISCONNECT) 
literal NET$C_DR_RSU = 1;               !  COULDN'T ALLOCATE UCB ADDRESS 
literal NET$C_DR_NONODE = 2;            !  Unrecognized node name 
literal NET$C_DR_SHUT = 3;              !  NODE OR LINE SHUTTING DOWN 
literal NET$C_DR_NOBJ = 4;              !  UNKNOWN OBJECT TYPE OR PROCESS 
literal NET$C_DR_FMT = 5;               !  ILLEGAL PROCESS NAME FIELD 
literal NET$C_DR_BUSY = 6;              !  Object too busy 
literal NET$C_DR_PROTCL = 7;            !  GENERAL PROTOCOL ERROR 
literal NET$C_DR_THIRD = 8;             !  THIRD PARTY DISCONNECT 
literal NET$C_DR_ABORT = 9;             !  DISCONNECT ABORT 
literal NET$C_DR_IVNODE = 2;            !  Invalid node name format 
literal NET$C_DR_NONZ = 21;             !  NON-ZERO DST ADDRESS 
literal NET$C_DR_BADLNK = 22;           !  INCONSISTENT DSTLNK 
literal NET$C_DR_ZERO = 23;             !  ZERO SOURCE ADDRESS 
literal NET$C_DR_BADFC = 24;            !  FCVAL ILLEGAL 
literal NET$C_DR_NOCON = 32;            !  NO CONNECT SLOTS AVAILABLE 
literal NET$C_DR_ACCESS = 34;           !  INVALID ACCESS CONTROL 
literal NET$C_DR_BADSRV = 35;           !  LOGICAL LINK SERVICES MISMATCH 
literal NET$C_DR_ACCNT = 36;            !  INVALID ACCOUNT INFORMATION 
literal NET$C_DR_SEGSIZ = 37;           !  SEGSIZE TOO SMALL 
literal NET$C_DR_EXIT = 38;             !  USER EXIT OR TIMEOUT 
literal NET$C_DR_NOPATH = 39;           !  NO PATH TO DESTINATION NODE 
literal NET$C_DR_LOSS = 40;             !  LOSS OF DATA HAS OCCURRED 
literal NET$C_DR_NOLINK = 41;           !  ILLEGAL MSG FOR LINK NOLINK STATE 
literal NET$C_DR_CONF = 42;             !  REAL DISCONNECT CONFIRM 
literal NET$C_DR_IMLONG = 43;           !  IMAGE DATA FIELD TOO LONG 
literal NET$C_DR_MISLSCV = 50;          !  MISSING CRYPTOGRAPHIC KEY
literal NET$C_DR_EXPSCV = 51;           !  EXPIRED CRYPTOGRAPHIC KEY
literal NET$C_DR_MACFAIL = 53;          !  INTEGRITY CHECK FAILED
literal NET$C_DR_SRVMMAT = 54;          !  CRYPTOGRAPHIC SERVICE MISMATCH
literal NET$C_DR_VERFAIL = 55;          !  CRYPTOGRAPHIC CONNECT VERIFICATION FAILURE
literal NET$C_DR_CSWRAP = 56;           !  CRYPTOGRAPHIC SEQUENCE SPACE EXHAUSED
! 
! ****************************************************************************
! *                                                                          *
! *  Copyright (c) 1992                                                      *
! *  by DIGITAL Equipment Corporation, Maynard, Mass.                        *
! *                                                                          *
! *  This software is furnished under a license and may be used and  copied  *
! *  only  in  accordance  with  the  terms  of  such  license and with the  *
! *  inclusion of the above copyright notice.  This software or  any  other  *
! *  copies  thereof may not be provided or otherwise made available to any  *
! *  other person.  No title to and ownership of  the  software  is  hereby  *
! *  transferred.                                                            *
! *                                                                          *
! *  The information in this software is subject to change  without  notice  *
! *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment  *
! *  Corporation.                                                            *
! *                                                                          *
! *  DIGITAL assumes no responsibility for the use or  reliability  of  its  *
! *  software on equipment which is not supplied by DIGITAL.                 *
! *                                                                          *
! ****************************************************************************
! ********************************************************************************************************************************
!  Created  7-JUL-1992 19:12:30 by VAX SDL T3.2-8      Source: 12-OCT-1989 16:13:03 _$22$DIA9:[RMS.SRC]RMSPUBSTR.SDL;1 
! ********************************************************************************************************************************
 
!*** MODULE $FSBDEF ***
! 
!          FSB field definitions
! 
!         File statistics block (fsb)
! 
! 	An FSB is associated with a file when the ACE$V_STATISTICS
! 	bit is set in the RMS attributes ACE. It is used to keep track
! 	of RMS file statistics.
! 
literal FSB$M_PRIVATE = 1;
literal FSB$M_RMSDEV = 2;
literal FSB$C_BID = 25;                 !  fsb id code 
literal FSB$K_STANDARD_BLN = 276;       !  Length of FSB without RMS development specific fields
literal FSB$C_STANDARD_BLN = 276;       !  Length of FSB without RMS development specific fields
!  Reserved for RMS development private monitoring
literal FSBFLG$_GET = 0;                !  Flags used for keeping track of relative file statistics updates
literal FSBFLG$_FIND = 1;
literal FSBFLG$_PUT = 2;
literal FSBFLG$_UPDATE = 3;
literal FSBFLG$_DELETE = 4;
literal FSBFLG$_MAX = 5;
literal FSB$K_VERSION = 1;              !  Current version of FSB
literal FSB$C_VERSION = 1;              !  Current version of FSB
literal FSB$C_SEQ = 1;
literal FSB$C_REL = 2;
literal FSB$C_IDX = 3;                  !  File organization constants 
literal FSB$K_BLN = 368;                !  Length of FSB
literal FSB$C_BLN = 368;                !  Length of FSB
literal FSB$S_FSBDEF = 368;
macro FSB$W_FLAGS = 6,0,16,0 %;         !  fsb flags
macro FSB$V_PRIVATE = 6,0,1,0 %;        !  FSB is for only one stream
macro FSB$V_RMSDEV = 6,1,1,0 %;         !  Reserved RMS fields being used
macro FSB$B_BID = 8,0,8,0 %;            !  block id 
macro FSB$B_BLN = 9,0,8,0 %;            !  block length in longwords 
macro FSB$B_ORG = 10,0,8,0 %;           !  file organization
macro FSB$B_VERSION = 11,0,8,0 %;       !  current version of FSB
macro FSB$L_SEQGETS = 12,0,32,0 %;      !  # of sequential gets to file
macro FSB$L_KEYGETS = 16,0,32,0 %;      !  # of keyed gets to file
macro FSB$L_RFAGETS = 20,0,32,0 %;      !  # of gets by RFA to file
macro FSB$Q_GETBYTES = 24,0,0,0 %;
literal FSB$S_GETBYTES = 8;             !  Total size of all gets in bytes
macro FSB$L_SEQPUTS = 32,0,32,0 %;      !  # of sequential puts
macro FSB$L_KEYPUTS = 36,0,32,0 %;      !  # of puts by key
macro FSB$Q_PUTBYTES = 40,0,0,0 %;
literal FSB$S_PUTBYTES = 8;             !  Total size of all puts in bytes
macro FSB$L_UPDATES = 48,0,32,0 %;      !  # of updates
macro FSB$Q_UPDATEBYTES = 52,0,0,0 %;
literal FSB$S_UPDATEBYTES = 8;          !  Total size of all updates in bytes
macro FSB$L_DELETES = 60,0,32,0 %;      !  # of deletes
macro FSB$L_TRUNCATES = 64,0,32,0 %;    !  # of truncates
macro FSB$L_TRUNCBLKS = 68,0,32,0 %;    !  Total size in blocks of all truncates
macro FSB$L_SEQFINDS = 72,0,32,0 %;     !  # of sequential finds
macro FSB$L_KEYFINDS = 76,0,32,0 %;     !  # of keyed finds
macro FSB$L_RFAFINDS = 80,0,32,0 %;     !  # of finds by RFA
macro FSB$L_READS = 84,0,32,0 %;        !  # of $READs to file
macro FSB$Q_READBYTES = 88,0,0,0 %;
literal FSB$S_READBYTES = 8;            !  # of bytes of all $READs
macro FSB$L_CONNECTS = 96,0,32,0 %;     !  # of connects to this file
macro FSB$L_DISCONNECTS = 100,0,32,0 %; !  # of disconnects from file
macro FSB$L_EXTENDS = 104,0,32,0 %;     !  # of extends of file
macro FSB$L_EXTBLOCKS = 108,0,32,0 %;   !  # of blocks file has been extended
macro FSB$L_FLUSHES = 112,0,32,0 %;     !  # of flushes of file
macro FSB$L_REWINDS = 116,0,32,0 %;     !  # of rewinds of file
macro FSB$L_WRITES = 120,0,32,0 %;      !  # of $WRITEs to file
macro FSB$Q_WRITEBYTES = 124,0,0,0 %;
literal FSB$S_WRITEBYTES = 8;           !  # of bytes of all $WRITEs to file
macro FSB$L_FLCKENQS = 132,0,32,0 %;    !  # of file lock ENQ's
macro FSB$L_FLCKDEQS = 136,0,32,0 %;    !  # of file lock DEQ's
macro FSB$L_FLCKCNVS = 140,0,32,0 %;    !  # of file lock conversions
macro FSB$L_LBLCKENQS = 144,0,32,0 %;   !  # of local buffer lock ENQ's
macro FSB$L_LBLCKDEQS = 148,0,32,0 %;   !  # of local buffer lock DEQ's
macro FSB$L_LBLCKCNVS = 152,0,32,0 %;   !  # of local buffer lock conversions
macro FSB$L_GBLCKENQS = 156,0,32,0 %;   !  # of global buffer lock ENQ's
macro FSB$L_GBLCKDEQS = 160,0,32,0 %;   !  # of global buffer lock DEQ's
macro FSB$L_GBLCKCNVS = 164,0,32,0 %;   !  # of global buffer lock conversions
macro FSB$L_GSLCKENQS = 168,0,32,0 %;   !  # of global section lock ENQ's
macro FSB$L_GSLCKDEQS = 172,0,32,0 %;   !  # of global section lock DEQ's
macro FSB$L_GSLCKCNVS = 176,0,32,0 %;   !  # of global section lock conversions
macro FSB$L_RLCKENQS = 180,0,32,0 %;    !  # of record lock ENQ's
macro FSB$L_RLCKDEQS = 184,0,32,0 %;    !  # of record lock DEQ's
macro FSB$L_RLCKCNVS = 188,0,32,0 %;    !  # of record lock conversions
macro FSB$L_APPLCKENQS = 192,0,32,0 %;  !  # of append lock ENQ's
macro FSB$L_APPLCKDEQS = 196,0,32,0 %;  !  # of append lock DEQ's
macro FSB$L_APPLCKCNVS = 200,0,32,0 %;  !  # of append lock conversions
macro FSB$L_FLBLKASTS = 204,0,32,0 %;   !  # of file lock blocking ASTs queued
macro FSB$L_LBLBLKASTS = 208,0,32,0 %;  !  # of local buffer lock blocking ASTs queued
macro FSB$L_GBLBLKASTS = 212,0,32,0 %;  !  # of global buffer lock blocking ASTs queued
macro FSB$L_APPBLKASTS = 216,0,32,0 %;  !  # of shared append lock blocking ASTs queued
macro FSB$L_LCACHEHITS = 220,0,32,0 %;  !  # of cache hits on local buffers
macro FSB$L_LCACHE_ATTEMPTS = 224,0,32,0 %; !  # of attempts to use the local buffer cache
macro FSB$L_GCACHEHITS = 228,0,32,0 %;  !  # of cache hits on global buffers
macro FSB$L_GCACHE_ATTEMPTS = 232,0,32,0 %; !  # of attempts to use the global buffer cache
macro FSB$L_GBRDIRIOS = 236,0,32,0 %;   !  # of direct io's due to global buffer reads
macro FSB$L_GBWDIRIOS = 240,0,32,0 %;   !  # of direct io's due to global buffer writes
macro FSB$L_LBRDIRIOS = 244,0,32,0 %;   !  # of direct io's due to local buffer reads
macro FSB$L_LBWDIRIOS = 248,0,32,0 %;   !  # of direct io's due to local buffer writes
macro FSB$L_BKTSPLT = 252,0,32,0 %;     !  # of 2 bucket splits
macro FSB$L_MBKTSPLT = 256,0,32,0 %;    !  # of multi-bucket splits
macro FSB$L_OPENS = 260,0,32,0 %;       !  # of times the file is opened
macro FSB$L_CLOSES = 264,0,32,0 %;      !  # of times the file is closed
macro FSB$L_GSBLKASTS = 268,0,32,0 %;   !  # of global section lock blocking ASTs queued
macro FSB$L_XQPQIOS = 272,0,32,0 %;     !  Count of XQP QIOs requested by RMS
macro FSB$L_FLWAITS = 276,0,32,0 %;     !  # of waits forced by getting the file lock
macro FSB$L_LBWAITS = 280,0,32,0 %;     !  # of waits forced by getting local buffer locks
macro FSB$L_GBWAITS = 284,0,32,0 %;     !  # of waits forced by getting global buffer locks
macro FSB$L_GSWAITS = 288,0,32,0 %;     !  # of waits forced by getting the global section lock
macro FSB$L_RLWAITS = 292,0,32,0 %;     !  # of waits forced by getting record locks
macro FSB$L_APWAITS = 296,0,32,0 %;     !  # of waits forced by getting the Append lock
macro FSB$L_TOTWAITS = 300,0,32,0 %;    !  Total # of waits (or stalls) performed by RMS. 
macro FSB$L_OUTBUFQUO = 304,0,32,0 %;   !  Number of times a process runs out of global buffer quota
macro FSB$L_RMSDEV1 = 308,0,32,0 %;     !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV2 = 312,0,32,0 %;     !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV3 = 316,0,32,0 %;     !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV4 = 320,0,32,0 %;     !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV5 = 324,0,32,0 %;     !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV6 = 328,0,32,0 %;     !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV7 = 332,0,32,0 %;     !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV8 = 336,0,32,0 %;     !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV9 = 340,0,32,0 %;     !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV10 = 344,0,32,0 %;    !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV11 = 348,0,32,0 %;    !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV12 = 352,0,32,0 %;    !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV13 = 356,0,32,0 %;    !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV14 = 360,0,32,0 %;    !  Reserved for RMS development private monitoring
macro FSB$L_RMSDEV15 = 364,0,32,0 %;    !  Reserved for RMS development private monitoring
 
!*** MODULE $RMSEDTDEF ***
! 
! 	RMS Extension Dispatch Table
! 
! 	The RMS extension dispatch table defines the vector area for RMS processing
! 	callouts.
! 
literal RMSEDT$K_CURVER = 1;
literal RMSEDT$C_CURVER = 1;
literal RMSEDT$K_XAB_DISPLAY = 63;
literal RMSEDT$K_LENGTH = 180;
literal RMSEDT$C_LENGTH = 180;
literal RMSEDT$S_RMSEDTDEF = 180;
macro RMSEDT$W_SIZE = 0,0,16,0 %;
macro RMSEDT$B_VERSION = 2,0,8,0 %;
macro RMSEDT$B_FLAGS = 3,0,8,0 %;
macro RMSEDT$A_CLOSE = 4,0,32,0 %;
macro RMSEDT$A_CONNECT = 8,0,32,0 %;
macro RMSEDT$A_CREATE = 12,0,32,0 %;
macro RMSEDT$A_IMPLIED_CREATE = 16,0,32,0 %;
macro RMSEDT$A_DELETE = 20,0,32,0 %;
macro RMSEDT$A_DISCONNECT = 24,0,32,0 %;
macro RMSEDT$A_DISPLAY = 28,0,32,0 %;
macro RMSEDT$A_ERASE = 32,0,32,0 %;
macro RMSEDT$A_IMPLIED_ERASE = 36,0,32,0 %;
macro RMSEDT$A_EXTEND = 40,0,32,0 %;
macro RMSEDT$A_AUTOEXTEND = 44,0,32,0 %;
macro RMSEDT$A_FIND = 48,0,32,0 %;
macro RMSEDT$A_FLUSH = 52,0,32,0 %;
macro RMSEDT$A_GET = 56,0,32,0 %;
macro RMSEDT$A_OPEN = 60,0,32,0 %;
macro RMSEDT$A_PUT = 64,0,32,0 %;
macro RMSEDT$A_READ = 68,0,32,0 %;
macro RMSEDT$A_RENAME = 72,0,32,0 %;
macro RMSEDT$A_IMPLIED_RENAME = 76,0,32,0 %;
macro RMSEDT$A_REWIND = 80,0,32,0 %;
macro RMSEDT$A_INIT_WCC_SEARCH = 84,0,32,0 %;
macro RMSEDT$A_NEXT_ECXT_SEARCH = 88,0,32,0 %;
macro RMSEDT$A_DELETE_WCC_SEARCH = 92,0,32,0 %;
macro RMSEDT$A_SPACE = 96,0,32,0 %;
macro RMSEDT$A_TRUNCATE = 100,0,32,0 %;
macro RMSEDT$A_UPDATE = 104,0,32,0 %;
macro RMSEDT$A_WRITE = 108,0,32,0 %;
macro RMSEDT$A_OPEN_LTJ = 112,0,32,0 %;
macro RMSEDT$A_CLOSE_LTJ = 116,0,32,0 %;
macro RMSEDT$A_FORMAT_JOURNAL = 120,0,32,0 %;
macro RMSEDT$A_WRITE_JOURNAL = 124,0,32,0 %;
macro RMSEDT$A_FLUSH_JOURNAL = 128,0,32,0 %;
macro RMSEDT$A_CREATE_RUJ = 132,0,32,0 %;
macro RMSEDT$A_CLOSE_RUJ = 136,0,32,0 %;
macro RMSEDT$A_DISPOSE_RU = 140,0,32,0 %;
macro RMSEDT$A_WRITE_RUJ = 144,0,32,0 %;
macro RMSEDT$A_FLUSH_RUJ = 148,0,32,0 %;
macro RMSEDT$A_LOCK_RECORD = 152,0,32,0 %;
macro RMSEDT$A_UNLOCK_RECORD = 156,0,32,0 %;
macro RMSEDT$A_UNLOCK_ALL_RECORDS = 160,0,32,0 %;
macro RMSEDT$A_IS_RECORD_LOCKED = 164,0,32,0 %;
macro RMSEDT$A_IS_RECORD_WRITE_LOCKED = 168,0,32,0 %;
macro RMSEDT$A_IS_RECORD_LOCK_HELD = 172,0,32,0 %;
macro RMSEDT$A_XAB_DISPATCH = 176,0,32,0 %;
 
!*** MODULE $DISPLAY_WILDEF ***
! 
!   $DISPLAY_WILD
! 
!     Display File
! 
!       $DISPLAY_WILD fab, [err], [suc], ctx
! 
!       fab_rab	= address of fab or rab
! 
! 	err	= address of user error completion routine
! 
! 	suc	= address of user success completion routine
! 	ctx	= address of a longword used to hold the next ifi.
! 
%if not %declared(%quote SDL$$DISPLAY_WILDEF_REQ) %then
! MACRO to emit warning and default to 0 if required argument is missing
!
macro
SDL$$DISPLAY_WILDEF_REQ(ARG1, arg2) =
    %IF not %NULL(ARG1) %THEN ARG1
    %else
	%warn(%string('REQUIRED ARGUMENT ', %NAME(ARG2), ' MISSING')) 0
    %FI %;
%fi
 
%if not %declared(%quote SDL$$DISPLAY_WILDEF_OPT) %then
! Defaults omitted arguments to 0 if followed by additional arguments
!
macro
SDL$$DISPLAY_WILDEF_OPT[ARG] =
    %IF %NULL(ARG)
    %THEN
	%IF NOT %NULL(%REMAINING)
	%THEN
	    0
	%FI
    %ELSE
	ARG
    %FI %;
%fi
 
%if not %declared(%quote SDL$$DISPLAY_WILDEF_LIST_0_REQ) %then
! Handles LIST parameters that are also OPTIONAL
!
macro
SDL$$DISPLAY_WILDEF_LIST_0_REQ(ARG) =
    %IF NOT %NULL(ARG) %THEN %REMOVE(ARG) %FI %;
%fi
 
%if not %declared(%quote SDL$$DISPLAY_WILDEF_LIST_1_REQ) %then
! Handles LIST parameters that are not OPTIONAL
! Emits warning and defaults to 0 if required argument is missing
!
macro
SDL$$DISPLAY_WILDEF_LIST_1_REQ(ARG, ARG2) =
    %IF %NULL(ARG) %THEN
	 %warn(%string('REQUIRED ARGUMENT ', %NAME(ARG2), ' MISSING')) 0
    %ELSE
        SDL$$DISPLAY_WILDEF_LIST_0_REQ(ARG) %FI %;
%fi
 
%if not %declared(%quote SDL$$DISPLAY_WILDEF_CONCAT) %then
! Eliminates trailing null arguments
!
macro
SDL$$DISPLAY_WILDEF_CONCAT[ARG] =
    %IF NOT %NULL(ARG) %THEN ARG %FI %;
%fi
 
!             ***********************************	
 
KEYWORDMACRO $DISPLAY_WILD (FAB_RAB,ERR=0,SUC=0,CTX) =
   BEGIN
   EXTERNAL ROUTINE SYS$DISPLAY : BLISS ADDRESSING_MODE (GENERAL);
	   SYS$DISPLAY (SDL$$DISPLAY_WILDEF_CONCAT( SDL$$DISPLAY_WILDEF_REQ(FAB_RAB, %QUOTE FAB_RAB) , 
	   ERR, SUC, SDL$$DISPLAY_WILDEF_REQ(CTX, %QUOTE CTX) ))
   END %;
 
 
!*** MODULE $MODDEF ***
! 
!                 RMS MODify definitions
! 
!   The following values identify various requests for non-standard rms
!   functions.  They are currently input to the $modify function in the
!   ctx field of the fab only if the esc bit is set in fop (rab functions
!   are also accepted).  Incorrect use of these capabilties could cause 
!   RMS to fail, hence great caution should be exercised in their use.
! 
!   The first five functions are also called RME$C_xxxx. They are defined
!   in the public module RMSUSR.SDL and cannot be changed. 
! 
!   FAB function calls
literal MOD$C_SETRFM = 1;               !  change rfm, mrs, and fsz (if vfc) in ifab only 
literal MOD$C_PPFECHO = 2;              !  enable echo of SYS$INPUT to SYS$OUTPUT
literal MOD$C_SETRCF = 3;               !  change recovery mode
literal MOD$C_KEEP_LOCK_ON = 4;         !  Turn on Keep Lock behavior
literal MOD$C_KEEP_LOCK_OFF = 5;        !  Turn off Keep Lock behavior
literal MOD$C_RU_ACE_ON = 6;            !  Turn on RU ACE locking
literal MOD$C_RU_ACE_OFF = 7;           !  Turn off RU ACE locking
!   RAB function calls
literal MOD$C_LOCK_RECORD = 1;          !  Lock a record 
literal MOD$C_ASSOCIATE = 2;            !  Associate a stream with a transaction
! 
! ****************************************************************************
! *                                                                          *
! *  Copyright (c) 1992                                                      *
! *  by DIGITAL Equipment Corporation, Maynard, Mass.                        *
! *                                                                          *
! *  This software is furnished under a license and may be used and  copied  *
! *  only  in  accordance  with  the  terms  of  such  license and with the  *
! *  inclusion of the above copyright notice.  This software or  any  other  *
! *  copies  thereof may not be provided or otherwise made available to any  *
! *  other person.  No title to and ownership of  the  software  is  hereby  *
! *  transferred.                                                            *
! *                                                                          *
! *  The information in this software is subject to change  without  notice  *
! *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment  *
! *  Corporation.                                                            *
! *                                                                          *
! *  DIGITAL assumes no responsibility for the use or  reliability  of  its  *
! *  software on equipment which is not supplied by DIGITAL.                 *
! *                                                                          *
! ****************************************************************************
! ********************************************************************************************************************************
!  Created  7-JUL-1992 19:13:16 by VAX SDL T3.2-8      Source: 12-OCT-1989 12:33:52 _$22$DIA9:[RMS.SRC]RMSFILSTR.SDL;1 
! ********************************************************************************************************************************
 
!*** MODULE $PLGDEF ***
literal PLG$M_NOEXTEND = 1;
literal PLG$C_VER_NO = 1;               !  current prolog version number 
literal PLG$C_VER_IDX = 2;              !  new plg for indexed files 
literal PLG$C_VER_3 = 3;                !  new plg for compression, space reclamation (plg 3) 
literal PLG$K_BLN = 122;
literal PLG$C_BLN = 122;
literal PLG$S_PLGDEF = 122;
macro PLG$B_DBKTSIZ = 11,0,8,0 %;       !  data bucket size 
macro PLG$B_FLAGS = 16,0,8,0 %;         !  flag bits
macro PLG$V_NOEXTEND = 16,0,1,0 %;      !  no extend allowed (rel)
macro PLG$B_AVBN = 102,0,8,0 %;         !  vbn of first area descriptor 
macro PLG$B_AMAX = 103,0,8,0 %;         !  maximum number of areas 
macro PLG$W_DVBN = 104,0,16,0 %;        !  first data bucket vbn 
macro PLG$L_MRN = 108,0,32,0 %;         !  maximum record number (rel) 
macro PLG$L_EOF = 112,0,32,0 %;         !  eof vbn (rel) 
macro PLG$W_VER_NO = 116,0,16,0 %;      !  version number 
macro PLG$W_GBC = 118,0,16,0 %;         !  default global buffer count 
macro PLG$W_COLVBN = 120,0,16,0 %;      !  VBN where collate tables begin (if any)
 
!*** MODULE $DLCDEF ***
! 
! 
!   relative file deletion control byte bit definitions
! 
literal DLC$M_DELETED = 4;
literal DLC$M_REC = 8;
literal DLC$S_DLCDEF = 1;
macro DLC$R_DLCDEF_BITS = 0,0,8,0 %;
macro DLC$V_DELETED = 0,2,1,0 %;        !  record deleted 
macro DLC$V_REC = 0,3,1,0 %;            !  record exists (but may have been deleted) 
 
!*** MODULE $BKTDEF ***
! 
!  index bucket definition
! 
!  this is the bucket format for RMS-11/RMS-32 index files.
! 
literal BKT$K_OVERHDSZ = 14;            !  length of bucket overhead 
literal BKT$C_OVERHDSZ = 14;            !  length of bucket overhead 
literal BKT$M_LASTBKT = 1;
literal BKT$M_ROOTBKT = 2;
literal BKT$M_PTR_SZ = 24;
literal BKT$C_ENDOVHD = 4;              !  end of bucket overhead 
literal BKT$C_DATBKTOVH = 2;            !  end of bucket overhead for data buckets 
literal BKT$C_DUPBKTOVH = 4;            !  additional end of data bucket overhead 
!   when duplicates are allowed (LCB pointer
literal BKT$C_MAXBKTSIZ = 63;           !  maximum bucket size
literal BKT$S_BKTDEF = 14;
macro BKT$B_CHECKCHAR = 0,0,8,0 %;      !  bucket check character 
macro BKT$R_AREANO_OVERLAY = 1,0,8,0 %;
macro BKT$B_AREANO = 1,0,8,0 %;         !  area number form which bucket was allocated 
macro BKT$B_INDEXNO = 1,0,8,0 %;        !  index to which this bucket belongs (plg 3) 
macro BKT$W_ADRSAMPLE = 2,0,16,0 %;     !  address sample - low 16 bits of first vbn in bucket 
macro BKT$R_FREESPACE_OVERLAY = 4,0,16,0 %;
macro BKT$W_FREESPACE = 4,0,16,0 %;     !  displacement in bucket of first free byte 
macro BKT$W_KEYFRESPC = 4,0,16,0 %;     !  pointer to key's free space (plg 3) 
macro BKT$R_NXTRECID_OVERLAY = 6,0,16,0 %;
macro BKT$W_NXTRECID = 6,0,16,0 %;      !  next available word record id (plg 3) 
macro BKT$R_NXTRECID_FIELDS = 6,0,16,0 %;
macro BKT$B_NXTRECID = 6,0,8,0 %;       !  next available record id 
macro BKT$B_LSTRECID = 7,0,8,0 %;       !  last id in range 
macro BKT$L_NXTBKT = 8,0,32,0 %;        !  vbn of next bucket 
macro BKT$B_LEVEL = 12,0,8,0 %;         !  bucket level number 
macro BKT$R_BKTCB_OVERLAY = 13,0,8,0 %;
macro BKT$B_BKTCB = 13,0,8,0 %;         !  bucket control bits 
macro BKT$R_BKTCB_BITS = 13,0,8,0 %;
macro BKT$V_LASTBKT = 13,0,1,0 %;       !  last bucket in horizontal chain 
macro BKT$V_ROOTBKT = 13,1,1,0 %;       !  root bucket 
macro BKT$V_PTR_SZ = 13,3,2,0 %;
literal BKT$S_PTR_SZ = 2;               !  size of vbn pointers in this bucket 
 
!*** MODULE $IRCDEF ***
! 
!  index record definition
! 
!  this is the definition of RMS-11/RMS-32 index file record formats
! 
literal IRC$M_PTRSZ = 3;
literal IRC$M_RECORDCB = 252;
literal IRC$M_DELETED = 4;
literal IRC$M_NOPTRSZ = 16;
literal IRC$M_FIRST_KEY = 128;
literal IRC$M_RRV = 8;
literal IRC$M_NODUPCNT = 16;
literal IRC$M_RU_DELETE = 32;
literal IRC$M_RU_UPDATE = 64;
literal IRC$C_IDXPTRBAS = 2;            !  used to determine size of pointer in index 
literal IRC$C_IDXOVHDSZ = 1;            !  includes record control byte 
! 
literal IRC$S_IRCDEF = 1;
macro IRC$B_CONTROL = 0,0,8,0 %;        !  record control byte 
macro IRC$R_CONTROL_BITS0 = 0,0,8,0 %;
macro IRC$V_PTRSZ = 0,0,2,0 %;
literal IRC$S_PTRSZ = 2;                !  size of pointer 
macro IRC$V_RECORDCB = 0,2,6,0 %;
literal IRC$S_RECORDCB = 6;             !  record control bits 
! 
!  record control bits used only in primary data record and SIDR array element
!  control bytes
! 
macro IRC$R_CONTROL_BITS1 = 0,0,8,0 %;
macro IRC$V_DELETED = 0,2,1,0 %;        !  record is deleted 
macro IRC$V_NOPTRSZ = 0,4,1,0 %;        !  no RRV
macro IRC$V_FIRST_KEY = 0,7,1,0 %;
! 
!  record control bits used only in primary data record control bytes
! 
macro IRC$R_CONTROL_BITS2 = 0,0,8,0 %;
macro IRC$V_RRV = 0,3,1,0 %;            !  rrv record 
! 
!  record control bits used only in prologue 2 SIDR record control bytes
! 
macro IRC$R_CONTROL_BITS3 = 0,0,8,0 %;
macro IRC$V_NODUPCNT = 0,4,1,0 %;       !  DUP_CNT field absent
! 
!  record control bits used only in prologue 3 RRV, UDR and SIDR record control
!  bytes of RU journalled files. (RU_UPDATE is set only in UDR record control
!  bytes)
! 
macro IRC$R_CONTROL_BITS4 = 0,0,8,0 %;
macro IRC$V_RU_DELETE = 0,5,1,0 %;      !  record is RU deleted
macro IRC$V_RU_UPDATE = 0,6,1,0 %;      !  record is RU updated
! 
!  record control bits reserved for RMS-11 use only (these may not be re-defined
!  except for prologue 3 records)
! 
!  Bit number 5
!  Bit number 6
! 
! 
!  index bucket record
! 
macro IRC$R_CONTROL_FIELDS4 = 0,0,8,0 %;
macro IRC$T_BUCKETPTR = 1,0,0,0 %;      !  bucket pointer (not referenced in the code, 
!   just present for consistency)
!  data bucket record
! 
literal IRC$S_IRCDEF1 = 3;
macro IRC$B_ID = 1,0,8,0 %;             !  record id 
macro IRC$B_RRV_ID = 2,0,8,0 %;         !  rrv's id -- always in the same place 
! 
!  prologue 3 data bucket record
! 
literal IRC$C_DATSZFLD = 2;             !  size of size field in variable length records 
literal IRC$C_DATPTRBAS = 3;            !  used to determine size of RRV in data buckets
literal IRC$C_DCNTSZFLD = 4;            !  size of duplicate count field in Plg 2 SIDRs
literal IRC$C_DATOVHDSZ = 2;            !  includes the record control byte, and the id 
literal IRC$C_FIXOVHDSZ = 7;            !  the record overhead for fixed record 
literal IRC$C_VAROVHDSZ = 9;            !  record overhead for variable records 
literal IRC$C_RRVOVHDSZ = 7;            !  size of RRV
! 
literal IRC$C_DATPTRBS3 = 4;            !  used to determine size of RRV in data buckets 
literal IRC$C_DATOVHSZ3 = 3;            !  record control byte, and id 
literal IRC$C_FIXOVHSZ3 = 9;            !  record overhead for fixed length records
literal IRC$C_VAROVHSZ3 = 11;           !  record overhead for variable length records
literal IRC$C_RRVOVHSZ3 = 9;            !  size of RRV
literal IRC$C_SDROVHSZ3 = 2;            !  record overhead for SIDRs
literal IRC$C_KEYCMPOVH = 2;            !  key compression overhead 
literal IRC$C_DATCMPOVH = 3;            !  data compression overhead 
literal IRC$S_IRCDEF2 = 5;
macro IRC$W_ID = 1,0,16,0 %;            !  record id 
macro IRC$W_RRV_ID = 3,0,16,0 %;        !  rrv's id -- always in the same place 
! 
!  constants
! 
!  prologue 3 constants
! 
 
!*** MODULE $KEYDEF ***
! 
!  definitions for the key descriptors in the prologue
! 
!  these definitions are associated w/ the plg and area definitions
! 
literal KEY$M_DUPKEYS = 1;
literal KEY$M_CHGKEYS = 2;
literal KEY$M_NULKEYS = 4;
literal KEY$M_IDX_COMPR = 8;
literal KEY$M_INITIDX = 16;
literal KEY$M_KEY_COMPR = 64;
literal KEY$M_REC_COMPR = 128;
literal KEY$C_MAX_DAT = 10;             !  (PLG3) Maximum size of a non-compressed data 
!   record
literal KEY$C_MAX_PRIMARY = 6;          !  (PLG3) Maximum size of a non-compressed 
!   primary key
literal KEY$C_MAX_INDEX = 6;            !  (PLG3) Maximum size of a non-compressed 
!   index and SIDR key
literal KEY$C_STRING = 0;               !  string data type 
literal KEY$C_SGNWORD = 1;              !  signed binary word 
literal KEY$C_UNSGNWORD = 2;            !  unsigned binary word 
literal KEY$C_SGNLONG = 3;              !  signed binary long word 
literal KEY$C_UNSGNLONG = 4;            !  unsigned binary long word 
literal KEY$C_PACKED = 5;               !  packed decimal
literal KEY$C_SGNQUAD = 6;              !  signed binary quadword
literal KEY$C_UNSGNQUAD = 7;            !  unsigned binary quadword
literal KEY$C_COLLATED = 8;             !  collated
literal KEY$C_MAX_ASCEND = 8;           !  maximum ASCENDING data type
literal KEY$C_DSTRING = 32;             !  descending string data type 
literal KEY$C_DSGNWORD = 33;            !     "       signed binary word 
literal KEY$C_DUNSGNWORD = 34;          !     "       unsigned binary word 
literal KEY$C_DSGNLONG = 35;            !     "       signed binary long word 
literal KEY$C_DUNSGNLONG = 36;          !     "       unsigned binary long word 
literal KEY$C_DPACKED = 37;             !     "       packed decimal
literal KEY$C_DSGNQUAD = 38;            !     "       signed binary quadword
literal KEY$C_DUNSGNQUAD = 39;          !     "       unsigned binary quadword
literal KEY$C_DCOLLATED = 40;           !     "	      collated
literal KEY$C_MAX_DATA = 40;            !  maximum data type value allowed 
literal KEY$K_BLN = 96;                 !  length of key descriptor in the prologue (plg 3) 
literal KEY$C_BLN = 96;                 !  length of key descriptor in the prologue (plg 3) 
literal KEY$C_SPARE = 6;                !  these are spare words in key block (plg 3) 
literal KEY$S_KEYDEF = 96;
macro KEY$L_IDXFL = 0,0,32,0 %;         !  vbn for next key descriptor 
macro KEY$W_NOFF = 4,0,16,0 %;          !  offset to next key descriptor 
macro KEY$B_IANUM = 6,0,8,0 %;          !  index area number 
macro KEY$B_LANUM = 7,0,8,0 %;          !  level 1 area number 
macro KEY$B_DANUM = 8,0,8,0 %;          !  data area number 
macro KEY$B_ROOTLEV = 9,0,8,0 %;        !  root level 
macro KEY$B_IDXBKTSZ = 10,0,8,0 %;      !  index bucket size 
macro KEY$B_DATBKTSZ = 11,0,8,0 %;      !  data bucket size 
macro KEY$L_ROOTVBN = 12,0,32,0 %;      !  root bucket pointer 
macro KEY$R_FLAGS_OVERLAY = 16,0,8,0 %;
macro KEY$B_FLAGS = 16,0,8,0 %;         !  flag bits 
macro KEY$R_FLAGS_BITS0 = 16,0,8,0 %;
macro KEY$V_DUPKEYS = 16,0,1,0 %;       !  duplicate key values allowed 
macro KEY$V_CHGKEYS = 16,1,1,0 %;       !  key value may change on $update operation 
macro KEY$V_NULKEYS = 16,2,1,0 %;       !  null key character enabled 
macro KEY$V_IDX_COMPR = 16,3,1,0 %;     !  index is compressed 
macro KEY$V_INITIDX = 16,4,1,0 %;       !  index must be initialized 
macro KEY$V_KEY_COMPR = 16,6,1,0 %;     !  (PLG3) key is compressed in data record 
macro KEY$R_FLAGS_BITS1 = 16,0,8,0 %;
macro KEY$V_REC_COMPR = 16,7,1,0 %;     !  (PLG3) Data record is compressed 
macro KEY$B_DATATYPE = 17,0,8,0 %;      !  data type for key 
macro KEY$B_SEGMENTS = 18,0,8,0 %;      !  number of segments in key 
macro KEY$B_NULLCHAR = 19,0,8,0 %;      !  "null" character 
macro KEY$B_KEYSZ = 20,0,8,0 %;         !  total key size 
macro KEY$B_KEYREF = 21,0,8,0 %;        !  key of reference 
macro KEY$W_MINRECSZ = 22,0,16,0 %;     !  minimum record length 
macro KEY$W_IDXFILL = 24,0,16,0 %;      !  index fill quantity 
macro KEY$W_DATFILL = 26,0,16,0 %;      !  data fill quantity 
macro KEY$R_POSITION_OVERLAY = 28,0,16,0 %;
macro KEY$W_POSITION = 28,0,16,0 %;     !  key seg position 
macro KEY$W_POSITION0 = 28,0,16,0 %;    !  another name for position 0 
macro KEY$W_POSITION1 = 30,0,16,0 %;    !  position 1 
macro KEY$W_POSITION2 = 32,0,16,0 %;    !  position 2 
macro KEY$W_POSITION3 = 34,0,16,0 %;    !  position 3 
macro KEY$W_POSITION4 = 36,0,16,0 %;    !  position 4 
macro KEY$W_POSITION5 = 38,0,16,0 %;
macro KEY$W_POSITION6 = 40,0,16,0 %;
macro KEY$W_POSITION7 = 42,0,16,0 %;
macro KEY$R_SIZE_OVERLAY = 44,0,8,0 %;
macro KEY$B_SIZE = 44,0,8,0 %;          !  key segment size 
macro KEY$B_SIZE0 = 44,0,8,0 %;         !  another name for size 
macro KEY$B_SIZE1 = 45,0,8,0 %;         !  size 1 
macro KEY$B_SIZE2 = 46,0,8,0 %;
macro KEY$B_SIZE3 = 47,0,8,0 %;
macro KEY$B_SIZE4 = 48,0,8,0 %;
macro KEY$B_SIZE5 = 49,0,8,0 %;
macro KEY$B_SIZE6 = 50,0,8,0 %;
macro KEY$B_SIZE7 = 51,0,8,0 %;
macro KEY$T_KEYNAM = 52,0,0,0 %;
literal KEY$S_KEYNAM = 32;              !  key name 
macro KEY$L_LDVBN = 84,0,32,0 %;        !  first data bucket 
macro KEY$R_TYPE_OVERLAY = 88,0,8,0 %;
macro KEY$B_TYPE = 88,0,8,0 %;          !  key segment datatype (plg 3) 
macro KEY$B_TYPE0 = 88,0,8,0 %;         !  another name for first datatype (plg 3) 
macro KEY$B_TYPE1 = 89,0,8,0 %;         !  (plg 3) 
macro KEY$B_TYPE2 = 90,0,8,0 %;         !  (plg 3) 
macro KEY$B_TYPE3 = 91,0,8,0 %;         !  (plg 3) 
macro KEY$B_TYPE4 = 92,0,8,0 %;         !  (plg 3) 
macro KEY$B_TYPE5 = 93,0,8,0 %;         !  (plg 3) 
macro KEY$B_TYPE6 = 94,0,8,0 %;         !  (plg 3) 
macro KEY$B_TYPE7 = 95,0,8,0 %;         !  (plg 3) 
 
!*** MODULE $AREADEF ***
! 
! 
!  definitions for the area descriptor in the prologue
! 
! 
literal AREA$C_CYL = 1;                 !  cylinded alignment 
literal AREA$C_LBN = 2;                 !  logical block alignment 
literal AREA$C_VBN = 3;                 !  virtual block alignment 
literal AREA$C_RFI = 4;                 !  allocate close to related file by fid 
literal AREA$M_HARD = 1;
literal AREA$M_ONC = 2;
literal AREA$M_CBT = 32;
literal AREA$M_CTG = 128;
literal AREA$K_BLN = 64;                !  length of area descriptor in the prologue 
literal AREA$C_BLN = 64;                !  length of area descriptor in the prologue 
literal AREA$S_AREADEF = 64;
macro AREA$B_FLAGS = 1,0,8,0 %;         !  not currently used 
macro AREA$B_AREAID = 2,0,8,0 %;        !  area id 
macro AREA$B_ARBKTSZ = 3,0,8,0 %;       !  bucket size for area 
macro AREA$W_VOLUME = 4,0,16,0 %;       !  relative volume number 
macro AREA$B_ALN = 6,0,8,0 %;           !  extend allocation alignment 
macro AREA$R_AOP_OVERLAY = 7,0,8,0 %;
macro AREA$B_AOP = 7,0,8,0 %;           !  alignment options 
macro AREA$R_AOP_BITS = 7,0,8,0 %;
macro AREA$V_HARD = 7,0,1,0 %;          !  absolute alignment or nothing 
macro AREA$V_ONC = 7,1,1,0 %;           !  locate on cylinder 
macro AREA$V_CBT = 7,5,1,0 %;           !  contiguous best try 
macro AREA$V_CTG = 7,7,1,0 %;           !  contiguous 
macro AREA$L_AVAIL = 8,0,32,0 %;        !  available (returned) buckets 
macro AREA$L_CVBN = 12,0,32,0 %;        !  start vbn for current extent 
macro AREA$L_CNBLK = 16,0,32,0 %;       !  number of blocks in current extent 
macro AREA$L_USED = 20,0,32,0 %;        !  number of blocks used 
macro AREA$L_NXTVBN = 24,0,32,0 %;      !  next vbn to use 
macro AREA$L_NXT = 28,0,32,0 %;         !  start vbn for next extent 
macro AREA$L_NXBLK = 32,0,32,0 %;       !  number of blocks in next extent 
macro AREA$W_DEQ = 36,0,16,0 %;         !  default extend quantity 
macro AREA$L_LOC = 40,0,32,0 %;         !  start lbn on volume 
macro AREA$W_RFI = 44,0,0,0 %;
literal AREA$S_RFI = 6;                 !  related file id 
macro AREA$L_TOTAL_ALLOC = 50,0,32,0 %; !  total block allocation
macro AREA$W_CHECK = 62,0,16,0 %;       !  checksum 
 
!*** MODULE $RJRDEF ***
! 
! 
!  definitions for the journal records in RMS journal files
! 
! 
literal RJR$C_RMS_AI = 1;               !  after-image journal
literal RJR$C_RMS_BI = 2;               !  before-image journal
literal RJR$C_RMS_RU = 3;               !  recovery unit
literal RJR$C_RMS_AT = 4;               !  audit trail
literal RJR$C_MAXJNL = 4;               !  jnl type limit
literal RJR$C_VER1 = 1;                 !  journal version 1
literal RJR$C_CURVER = 1;               !  current version
literal RJR$C_NULL = 0;                 !  No entry follows the header
literal RJR$C_LEADER = 1;               !  leader entry
literal RJR$C_TRAILER = 2;              !  trailer entry
literal RJR$C_RECORD = 3;               !  record entry (AI, BI, RU)
literal RJR$C_BLOCK = 4;                !  block entry  (AI, BI, RU)
literal RJR$C_EXTEND = 5;               !  extend entry (AI, AT)
literal RJR$C_CREATE = 6;               !  create entry (AI, AT)
literal RJR$C_AT_RECORD = 7;            !  audit trail record (AT)
literal RJR$C_DEFINE_JNL = 8;           !  Journal creation record
literal RJR$C_BACKUP = 9;               !  Backup done entry (AI, BI)
literal RJR$C_COMMIT = 10;              !  RU commit entry (AI, BI)
literal RJR$C_ABORT = 11;               !  RU abort entry (AI, BI)
literal RJR$C_PREPARE = 12;             !  RU prepare entry (AI, BI, RU)
literal RJR$C_FORCED_COMMIT = 13;       !  RU forced commit for AI jnls
literal RJR$C_MAXTYP = 13;              !  entry-type limit
literal RJR$C_SEQ = 0;                  !  sequential file org
literal RJR$C_REL = 1;                  !  relative file org
literal RJR$C_IDX = 2;                  !  indexed file org
literal RJR$C_HSH = 3;                  !  hashed file org
literal RJR$C_MAXORG = 3;               !  org limit
literal RJR$_CLOSE = 1;                 !  close
literal RJR$_CONNECT = 2;               !  connect
literal RJR$_CREATE = 3;                !  create
literal RJR$_DELETE = 4;                !  delete
literal RJR$_DISCONNECT = 5;            !  disconnect
literal RJR$_DISPLAY = 6;               !  display
literal RJR$_ENTER = 7;                 !  enter
literal RJR$_ERASE = 8;                 !  erase
literal RJR$_EXTEND = 9;                !  extend
literal RJR$_FIND = 10;                 !  find
literal RJR$_FLUSH = 11;                !  flush
literal RJR$_FREE = 12;                 !  free
literal RJR$_GET = 13;                  !  get
literal RJR$_MODIFY = 14;               !  modify
literal RJR$_NXTVOL = 15;               !  next volume
literal RJR$_OPEN = 16;                 !  open
literal RJR$_PARSE = 17;                !  parse
literal RJR$_PUT = 18;                  !  put
literal RJR$_READ = 19;                 !  block I/O read
literal RJR$_RELEASE = 20;              !  release
literal RJR$_REMOVE = 21;               !  remove
literal RJR$_RENAME = 22;               !  rename
literal RJR$_REWIND = 23;               !  rewind
literal RJR$_SEARCH = 24;               !  search
literal RJR$_SPACE = 25;                !  block I/O space
literal RJR$_TRUNCATE = 26;             !  truncate
literal RJR$_UPDATE = 27;               !  update
literal RJR$_WAIT = 28;                 !  wait
literal RJR$_WRITE = 29;                !  block I/O write
literal RJR$_TPT = 30;                  !  truncate on PUT
literal RJR$_MAXOPER = 30;              !  oper limit
literal RJR$C_HDRLEN = 72;              !  common header len
literal RJR$K_HDRLEN = 72;              !  common header len
literal RJR$C_COMMITLEN = 72;           !  commit entry len
literal RJR$K_COMMITLEN = 72;           !  commit entry len
literal RJR$C_ABORTLEN = 72;            !  abort entry len
literal RJR$K_ABORTLEN = 72;            !  abort entry len
literal RJR$C_FORCED_COMMITLEN = 72;    !  forced commit entry len
literal RJR$K_FORCED_COMMITLEN = 72;    !  forced commit entry len
! 
literal RJR$C_LDRLEN = 169;             !  leader entry len
literal RJR$K_LDRLEN = 169;             !  leader entry len
!  the 3 filespec strings above appear here
literal RJR$C_TRLLEN = 107;             !  trailer entry len
literal RJR$K_TRLLEN = 107;             !  trailer entry len
!  filespec of next journal file appears here
literal RJR$C_RECLEN = 100;             !  record entry len
literal RJR$K_RECLEN = 100;             !  record entry len
literal RJR$C_BLKLEN = 96;              !  block i/o entry len
literal RJR$K_BLKLEN = 96;              !  block i/o entry len
literal RJR$M_EXT_USE_XAB = 1;
literal RJR$C_EXTLEN = 114;             !  extend entry len
literal RJR$K_EXTLEN = 114;             !  extend entry len
literal RJR$M_ATR_UCHAR = 1;
literal RJR$M_ATR_PROT = 2;
literal RJR$M_ATR_UIC = 4;
literal RJR$M_ATR_REC = 8;
literal RJR$M_ATR_EXPIRE = 16;
literal RJR$C_FIBLEN = 64;
literal RJR$K_FIBLEN = 64;
literal RJR$C_RECATRLEN = 32;
literal RJR$K_RECATRLEN = 32;
literal RJR$C_CRELEN = 226;
literal RJR$K_CRELEN = 226;
literal RJR$C_AT_RECLEN = 104;
literal RJR$K_AT_RECLEN = 104;
literal RJR$C_BACKUPLEN = 92;
literal RJR$K_BACKUPLEN = 92;
literal RJR$C_PREPARELEN = 112;         !  prepare entry len
literal RJR$K_PREPARELEN = 112;         !  prepare entry len
!  actual node name string follows here
literal RJR$C_BLN = 226;                !  length of RJR descriptor in the prologue 
literal RJR$K_BLN = 226;                !  length of RJR descriptor in the prologue 
literal RJR$S_RJRDEF = 226;
macro RJR$W_FACILITY = 0,0,16,0 %;      !  facility code (=1)
macro RJR$W_FLAGS = 2,0,16,0 %;         !  flags
macro RJR$V_FIRST_RU_RECORD = 2,0,1,0 %; !  first journal record for this RU
macro RJR$V_RUJ_IN_LTJ = 2,1,1,0 %;     !  this is a RU record written to a LTJ
macro RJR$V_WRITTEN_BY_RECOVER = 2,2,1,0 %; !  written during detached reocvery
macro RJR$V_FIRST_STREAM_RU_RECORD = 2,3,1,0 %; !  first journal record for this stream and RU
macro RJR$V_RECOVERED = 2,4,1,0 %;      !  entries for leader record already recovered
macro RJR$V_NOPAD = 2,5,1,0 %;          !  Do not pad AI record
macro RJR$L_JNLIDX = 4,0,32,0 %;        !  journal stream index
macro RJR$B_JNL_TYPE = 8,0,8,0 %;       !  journaling type
macro RJR$B_VERSION = 9,0,8,0 %;        !  RMS journal version #
macro RJR$B_ENTRY_TYPE = 10,0,8,0 %;    !  journal entry type
macro RJR$B_ORG = 11,0,8,0 %;           !  file organization
macro RJR$B_OPER = 12,0,8,0 %;          !  RMS operation id
macro RJR$T_RUID = 16,0,0,0 %;
literal RJR$S_RUID = 16;                !  RUID (if operation performed in an RU)
macro RJR$T_TID = 16,0,0,0 %;
literal RJR$S_TID = 16;                 !  TID is the RUID under DDTM
macro RJR$L_EPID = 32,0,32,0 %;         !  EPID of the process writing the entry
macro RJR$Q_DATE = 36,0,0,0 %;
literal RJR$S_DATE = 8;                 !  date/time of record
macro RJR$L_AT_STS = 44,0,32,0 %;       !  status of operation (AT)
macro RJR$L_AT_STV = 48,0,32,0 %;       !  secondary status (AT)
macro RJR$L_AT_CTX = 52,0,32,0 %;       !  user FAB/RAB CTX field (AT)
!  End of common RJR header. Begin entry-specific definitions.
! 
! 
!  Leader record. First record in each journal file.
! 
macro RJR$W_FILESPEC_OFF = 72,0,16,0 %; !  offset to filespec of file being journaled (from top of RJR)
macro RJR$W_FILESPEC_LEN = 74,0,16,0 %; !  length of filespec of file being journaled
macro RJR$B_VOLNAM_LEN = 76,0,8,0 %;    !  length of volume name string
macro RJR$T_VOLNAM = 77,0,0,0 %;
literal RJR$S_VOLNAM = 12;              !  volume name of file being journaled
macro RJR$T_FID = 89,0,0,0 %;
literal RJR$S_FID = 6;                  !  FID of file being journaled
macro RJR$Q_CDATE = 95,0,0,0 %;
literal RJR$S_CDATE = 8;                !  creation date of file being journaled
macro RJR$W_J_FILESPEC_OFF = 103,0,16,0 %; !  offset to filespec of journal file (from top of RJR)
macro RJR$W_J_FILESPEC_LEN = 105,0,16,0 %; !  length of filespec of journal file
macro RJR$B_J_VOLNAM_LEN = 107,0,8,0 %; !  length of volume name string
macro RJR$T_J_VOLNAM = 108,0,0,0 %;
literal RJR$S_J_VOLNAM = 12;            !  volume name of journal file
macro RJR$T_J_FID = 120,0,0,0 %;
literal RJR$S_J_FID = 6;                !  FID of journal file
macro RJR$Q_J_CDATE = 126,0,0,0 %;
literal RJR$S_J_CDATE = 8;              !  creation date of journal file
macro RJR$W_PJ_FILESPEC_OFF = 134,0,16,0 %; !  offset to filespec of previous journal file (from top of RJR)
macro RJR$W_PJ_FILESPEC_LEN = 136,0,16,0 %; !  length of filespec of previous journal file
macro RJR$B_PJ_VOLNAM_LEN = 138,0,8,0 %; !  length of volume name string
macro RJR$T_PJ_VOLNAM = 139,0,0,0 %;
literal RJR$S_PJ_VOLNAM = 12;           !  volume name of previous journal file
macro RJR$T_PJ_FID = 151,0,0,0 %;
literal RJR$S_PJ_FID = 6;               !  FID of previous journal file
macro RJR$Q_PJ_CDATE = 157,0,0,0 %;
literal RJR$S_PJ_CDATE = 8;             !  creation date of previous journal file
macro RJR$L_PJ_JNLIDX = 165,0,32,0 %;   !  journal stream index of the previous journal file
! 
!  Trailer record. This record is only present in AI or BI journal files that
!  have newer versions. It is written to the old journal file when a file that
!  was already marked for journaling is re-marked for journaling to point to
!  a newer version of a journal file.
! 
macro RJR$W_NJ_FILESPEC_OFF = 72,0,16,0 %; !  offset to filespec of next journal file (from top of RJR)
macro RJR$W_NJ_FILESPEC_LEN = 74,0,16,0 %; !  length of filespec of next journal file
macro RJR$B_NJ_VOLNAM_LEN = 76,0,8,0 %; !  length of volume name string
macro RJR$T_NJ_VOLNAM = 77,0,0,0 %;
literal RJR$S_NJ_VOLNAM = 12;           !  volume name of next journal file
macro RJR$T_NJ_FID = 89,0,0,0 %;
literal RJR$S_NJ_FID = 6;               !  FID of next journal file
macro RJR$Q_NJ_CDATE = 95,0,0,0 %;
literal RJR$S_NJ_CDATE = 8;             !  creation date of next journal file
macro RJR$L_NJ_JNLIDX = 103,0,32,0 %;   !  Journal stream index of the next journal file
! 
!  Record entry. Used for AI, BI, and RU to journal record operations.
! 
macro RJR$L_CHKSUM = 88,0,32,0 %;       !  checksum of old record
macro RJR$W_RFA = 92,0,0,0 %;
literal RJR$S_RFA = 6;                  !  RFA of record
macro RJR$L_RFA0 = 92,0,32,0 %;         !  alternate RFA def
macro RJR$W_RFA4 = 96,0,16,0 %;
macro RJR$L_RRN = 92,0,32,0 %;          !  relative record number
macro RJR$W_RSIZE = 98,0,16,0 %;        !  record size
macro RJR$T_RIMAGE = 100,0,0,0 %;       !  record data
! 
!  The block entry is used for ISAM AI/BI bucket entries, $WRITEs, and AT.
! 
macro RJR$L_BLOCK_VBN = 88,0,32,0 %;    !  vbn of block
macro RJR$W_BLOCK_SIZE = 92,0,16,0 %;   !  transfer size
macro RJR$W_JBLOCK_SIZE = 94,0,16,0 %;  !  actual size of
!  journaled data
macro RJR$T_BLOCK = 96,0,0,0 %;         !  block data
! 
!  RJR$C_BLKLEN must be a quadword multiple or indexed data buffers
!  will not be quadword aligned!!! This constant is used to size
!  indexed data buffers which have imbedded AI and BI RJR headers
!  when long term journaling is used.
! 
! 
!  The extend entry is common to both AT and AI journaling.
! 
macro RJR$L_EXT_FLAGS = 88,0,32,0 %;
macro RJR$V_EXT_USE_XAB = 88,0,1,0 %;   !  ALL XAB fields present
! 
!  Fields EXT_AOP (unused) through EXT_RFI are in same relative locations as
!  the same fields in allocation XAB.
! 
macro RJR$B_EXT_AOP = 92,0,8,0 %;       !  align options
macro RJR$B_EXT_ALN = 93,0,8,0 %;       !  alignment boundary
macro RJR$W_EXT_VOL = 94,0,16,0 %;      !  relative volume number
macro RJR$L_EXT_LOC = 96,0,32,0 %;      !  location
macro RJR$L_EXT_ALQ = 100,0,32,0 %;     !  allocation quantity
macro RJR$W_EXT_DEQ = 104,0,16,0 %;     !  default extension
macro RJR$B_EXT_BKZ = 106,0,8,0 %;      !  bucket size
macro RJR$B_EXT_AID = 107,0,8,0 %;      !  area ID
macro RJR$W_EXT_RFI = 108,0,0,0 %;
literal RJR$S_EXT_RFI = 6;              !  related file IFI
macro RJR$T_EXT_ENDALL = 114,0,0,0 %;   !  end of all info
! 
!  The CREATE entry is used to record the information required to re-create
!  a file for AI journaling, and to record a create for AT journaling.
! 
macro RJR$L_ATR_FLAGS = 88,0,32,0 %;
macro RJR$V_ATR_UCHAR = 88,0,1,0 %;     !  UCHAR attribute present
macro RJR$V_ATR_PROT = 88,1,1,0 %;      !  PROT attribute present
macro RJR$V_ATR_UIC = 88,2,1,0 %;       !  UIC attribute present
macro RJR$V_ATR_REC = 88,3,1,0 %;       !  RECORD attributes present
macro RJR$V_ATR_EXPIRE = 88,4,1,0 %;    !  EXPIRATION present
macro RJR$L_UIC = 92,0,32,0 %;          !  owner UIC
macro RJR$L_PROT = 96,0,32,0 %;         !  prot mask
macro RJR$L_ALLOC = 100,0,32,0 %;       !  initial allocation (audit)
macro RJR$L_UCHAR = 104,0,32,0 %;       !  user characteristics (create)
macro RJR$Q_EXPIRE = 108,0,0,0 %;
literal RJR$S_EXPIRE = 8;               !  expiration date (create)
macro RJR$B_FAC = 116,0,8,0 %;          !  file access (audit)
macro RJR$B_SHR = 117,0,8,0 %;          !  sharing allowed (audit)
macro RJR$W_DID = 118,0,0,0 %;
literal RJR$S_DID = 6;                  !  directory ID (create, volume recovery)
macro RJR$T_FIB = 126,0,0,0 %;
literal RJR$S_FIB = 64;                 !  FIB (create)
macro RJR$T_REC_ATTR = 190,0,0,0 %;
literal RJR$S_REC_ATTR = 32;            !  record attributes (create)
macro RJR$W_C_FILESPEC_OFF = 222,0,16,0 %; !  offset to full filespec (from top of RJR)
macro RJR$W_C_FILESPEC_LEN = 224,0,16,0 %; !  length of full filespec
! 
!  The AT record is used for audit-trail journaling.
! 
macro RJR$L_AT_ROP = 88,0,32,0 %;       !  record options
macro RJR$B_AT_KRF = 92,0,8,0 %;        !  key of reference
macro RJR$B_AT_KSZ = 93,0,8,0 %;        !  key size
macro RJR$B_AT_RAC = 94,0,8,0 %;        !  record access mode
macro RJR$W_AT_RFA = 96,0,0,0 %;
literal RJR$S_AT_RFA = 6;               !  RFA of record
macro RJR$L_AT_RFA0 = 96,0,32,0 %;      !  alternate RFA def
macro RJR$W_AT_RFA4 = 100,0,16,0 %;
macro RJR$L_AT_RRN = 96,0,32,0 %;       !  relative record number
macro RJR$T_AT_KEY = 104,0,0,0 %;       !  key if used
! 
!   The BACKUP_ENTRY record is used to flag that a backup has been taken on the
!   data file being journaled.  It provides a known starting point for rollforward.
! 
macro RJR$L_BACKUP_SEQNO = 88,0,32,0 %; !  Backup sequence number
! 
!  The prepare record is written to RU, AI, and BI journals for transactions
!  that required a two-phase commit protocol.
! 
macro RJR$T_DDTM_LOG_ID = 72,0,0,0 %;
literal RJR$S_DDTM_LOG_ID = 16;         !  DDTM log id
macro RJR$T_RUJ_LOG_ID = 88,0,0,0 %;
literal RJR$S_RUJ_LOG_ID = 16;          !  RMS RUJ log id
macro RJR$W_NODE_NAME_OFF = 104,0,16,0 %; !  offset to node name string
macro RJR$W_NODE_NAME_LEN = 106,0,16,0 %; !  length of node name string
macro RJR$W_RM_NAME_OFF = 108,0,16,0 %; !  offset to resource manager name string
macro RJR$W_RM_NAME_LEN = 110,0,16,0 %; !  length of resource manager name string
